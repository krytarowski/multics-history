	COMPILATION LISTING OF SEGMENT ed_appending_simulation_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1507.9 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 ed_appending_simulation_: proc;
        7 
        8 /* Modified routine to access segments in the saved Multics memory image.
        9*Taken from bce_appending_simulation.  Keith Loepere, December 1983. */
       10 
       11 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
       12 
       13 dcl  address		        fixed bin (26);	/* running absolute or virtual (within segment) address */
       14 dcl  code			        fixed bin (35) parameter;
       15 dcl  crash_system_type	        fixed bin static;	/* supplied from dump */
       16 dcl  data_length		        fixed bin (18);	/* running data left to be gotten */
       17 dcl  data_part		        (data_part_length) bit (36) aligned based; /* part of page to extract toward total desired */
       18 dcl  data_part_length	        fixed bin (18);
       19 dcl  data_ptr		        ptr;		/* running ptr to user data area */
       20 dcl  dbr_value		        bit (72) aligned parameter;
       21 dcl  desired_segnum		        fixed bin (15) parameter;
       22 dcl  dseg_sdw		        fixed bin (71);
       23 dcl  1 dseg_info		        aligned like seg_info static; /* describe dseg in dump */
       24 dcl  error_table_$argerr	        fixed bin (35) ext static;
       25 dcl  error_table_$boundviol	        fixed bin (35) ext static;
       26 dcl  error_table_$invalidsegno        fixed bin (35) ext static;
       27 dcl  error_table_$out_of_bounds       fixed bin (35) ext static;
       28 dcl  memory_block_ptrs	        (4) ptr static;	/* forms a set of 4 128k blocks of memory */
       29 dcl  multics_data_ptr	        ptr;		/* running ptr to area in dump to copy out for user */
       30 dcl  1 my_dbr_info		        aligned like dbr_info;
       31 dcl  1 my_ptw_info		        aligned like ptw_info;
       32 dcl  p_address		        fixed bin (26) parameter; /* desired address */
       33 dcl  p_crash_system_type	        fixed bin parameter;
       34 dcl  p_data_length		        fixed bin (18) parameter; /* desired data length */
       35 dcl  p_data_ptr		        ptr parameter;	/* ptr to user data area */
       36 dcl  p_last_segnum		        fixed bin (15) parameter;
       37 dcl  p_memory_block_ptrs	        (4) ptr parameter;
       38 dcl  p_seg_info_ptr		        ptr parameter;
       39 dcl  page_num		        fixed bin;		/* loop counter */
       40 dcl  page_offset		        fixed bin;		/* start within page of data to get */
       41 dcl  ptp			        ptr;		/* ptw ptr */
       42 dcl  sdwp			        ptr;		/* sdw ptr */
       43 dcl  seg_sdw		        fixed bin (71);
       44 dcl  size			        builtin;
       45 
       46 init: entry (p_memory_block_ptrs, p_crash_system_type);
       47 
       48 /* save away data about dump */
       49 
       50 	memory_block_ptrs = p_memory_block_ptrs;
       51 	crash_system_type = p_crash_system_type;
       52 	return;
       53 
       54 new_dbr: entry (dbr_value, p_last_segnum, code);
       55 
       56 /* Supply a new dseg for the simulation. */
       57 
       58 /* Examine the new dbr. */
       59 
       60 	code = 0;
       61 	dbr_info_ptr = addr (my_dbr_info);
       62 	ptw_info_ptr = addr (my_ptw_info);
       63 	call dbr_util_$dissect (addr (dbr_value), dbr_info_ptr);
       64 	p_last_segnum = divide (dbr_info.bound, 2, 15) - 1;
       65 	dseg_info.sdwi.paged = dbr_info.paged;
       66 	dseg_info.sdwi.address = dbr_info.address;
       67 
       68 /* Get the sdw & page table for dseg. */
       69 
       70 	if dseg_info.sdwi.paged then do;
       71 	     call get_absolute (dseg_info.sdwi.address - size (aste), size (aste) + divide (dbr_info.bound + 1023, 1024, 8), addr (dseg_info.sst_data), code);
       72 	     if code ^= 0 then return;
       73 	     call ptw_util_$dissect (addr (dseg_info.page_table (0)), ptw_info_ptr);
       74 	     call get_absolute (ptw_info.address, 2, addr (dseg_sdw), code);
       75 	     if code ^= 0 then return;
       76 	end;
       77 	else do;
       78 	     call get_absolute (dseg_info.sdwi.address, 2, addr (dseg_sdw), code);
       79 	     if code ^= 0 then return;
       80 	end;
       81 	call sdw_util_$dissect (addr (dseg_sdw), addr (dseg_info.sdwi));
       82 	return;
       83 
       84 get_absolute: entry (p_address, p_data_length, p_data_ptr, code);
       85 
       86 	data_length = p_data_length;
       87 
       88 /* We march the address we desire downwards, by at most a page at a time.  As
       89*we do this, we appropriately keep track of the memory this is in (or not in)
       90*to validate the address. */
       91 
       92 	do while (data_length > 0);
       93 
       94 /* Find amount of data in this page. */
       95 
       96 	     data_part_length = mod (p_address + data_length - 1, 1024) + 1; /* amount from start of page to last word */
       97 	     if data_part_length <= data_length then address = p_address + data_length - data_part_length; /* data crosses into this page */
       98 	     else do;				/* data within a page */
       99 		address = p_address;
      100 		data_part_length = data_length;
      101 	     end;
      102 	     data_ptr = addrel (p_data_ptr, address - p_address);
      103 
      104 	     if address >= 512 * 1024 then do;		/* address beyond this memory */
      105 		code = error_table_$out_of_bounds;
      106 		unspec (data_ptr -> data_part) = "0"b;
      107 	     end;
      108 	     else do;
      109 		multics_data_ptr = addrel (memory_block_ptrs (divide (address, 128 * 1024, 17) + 1), mod (address, 128 * 1024));
      110 		data_ptr -> data_part = multics_data_ptr -> data_part;
      111 	     end;
      112 	     data_length = data_length - data_part_length;
      113 	end;
      114 	return;
      115 
      116 new_segment: entry (desired_segnum, p_seg_info_ptr, code);
      117 
      118 /* Supply a new segnum for virtual simulation. */
      119 
      120 	code = 0;
      121 	seg_info_ptr = p_seg_info_ptr;
      122 
      123 /*  We will get the user's new segment's sdw and page table.  We call virtual, 
      124*telling it to get the seg's sdw. */
      125 
      126 	call get_virtual (addr (dseg_info), desired_segnum * 2, 2, addr (seg_sdw), code);
      127 	if code ^= 0 then go to bad_segment;
      128 
      129 	call sdw_util_$dissect (addr (seg_sdw), addr (seg_info.sdwi));
      130 	if seg_info.sdwi.faulted then do;
      131 	     code = error_table_$invalidsegno;
      132 	     go to bad_segment;
      133 	end;
      134 	if seg_info.sdwi.paged then do;		/* Get the seg's aste/page table */
      135 	     call get_absolute (seg_info.sdwi.address - size (aste), size (aste) + divide (seg_info.sdwi.size + 1023, 1024, 8), addr (seg_info.sst_data), code);
      136 	     if code ^= 0 then do;			/* It could just be that the page table is in good memory and has no aste in front of it, but... */
      137 		seg_info.sdwi.faulted = "1"b;
      138 bad_segment:	return;
      139 	     end;
      140 	end;
      141 	return;
      142 
      143 get_virtual: entry (p_seg_info_ptr, p_address, p_data_length, p_data_ptr, code);
      144 
      145 /* Fetch a given set of words from the current segment. */
      146 
      147 	code = 0;
      148 	seg_info_ptr = p_seg_info_ptr;
      149 	ptw_info_ptr = addr (my_ptw_info);
      150 
      151 	data_length = p_data_length;
      152 	if p_address + p_data_length > seg_info.sdwi.size then do;
      153 	     data_part_length = p_address + data_length - seg_info.sdwi.size;
      154 	     data_ptr = addrel (p_data_ptr, data_length - data_part_length);
      155 	     unspec (data_ptr -> data_part) = "0"b;
      156 	     code = error_table_$boundviol;
      157 	     data_length = data_length - data_part_length;
      158 	end;
      159 	if seg_info.sdwi.paged then do;
      160 	     do while (data_length > 0);
      161 		data_part_length = mod (p_address + data_length - 1, 1024) + 1; /* amount from start of page to last word */
      162 		if data_part_length <= data_length then address = p_address + data_length - data_part_length; /* data crosses into this page */
      163 		else do;				/* data within a page */
      164 		     address = p_address;
      165 		     data_part_length = data_length;
      166 		end;
      167 		data_ptr = addrel (p_data_ptr, address - p_address);
      168 		page_num = divide (address, 1024, 8);
      169 		page_offset = mod (address, 1024);
      170 
      171 /* Find the appropriate page.  Move the amount found in that page to the
      172*user's area. */
      173 
      174 		call ptw_util_$dissect (addr (seg_info.page_table (page_num)), ptw_info_ptr);
      175 		if ptw_info.valid then		/* properly in memory */
      176 		     call get_absolute (ptw_info.address + page_offset, data_part_length, data_ptr, code);
      177 		else do;
      178 bad_page:		     unspec (data_ptr -> data_part) = "0"b;
      179 		     if code = 0 then code = error_table_$argerr;
      180 		end;
      181 		data_length = data_length - data_part_length;
      182 	     end;
      183 	end;
      184 	else do;					/* in memory (unpaged) */
      185 	     address = seg_info.sdwi.address + p_address;
      186 	     call get_absolute (address, p_data_length, p_data_ptr, code);
      187 	end;
      188 	return;
      189 
      190 
      191 /* The following routines were stolen from their namesakes for use here.
      192*They are striped down and key off crash_system_type for operation. */
      193 
      194 dbr_util_$dissect: proc (dbr_ptr, p_dbr_info_ptr);
      195 
      196 /* Routine to take apart (and assemble?) dbr (descriptor segment base register)
      197*values.  Initially coded by Keith Loepere, October 1983. */
      198 
      199 dcl  dbr_ptr		        ptr parameter;
      200 dcl  p_dbr_info_ptr		        ptr parameter;
      201 
      202 	dbr_info_ptr = p_dbr_info_ptr;
      203 	if crash_system_type = ADP_SYSTEM then do;
      204 	     dbr_info.address = bin (dbr_ptr -> adp_dbr.add, 26);
      205 	     dbr_info.bound = (bin (dbr_ptr -> adp_dbr.bound, 14) + 1) * 16;
      206 	     dbr_info.stack_base_segnum = dbr_ptr -> adp_dbr.stack_base_segno * 8;
      207 	     dbr_info.paged = ^ dbr_ptr -> adp_dbr.unpaged;
      208 	end;
      209 	else do;
      210 	     dbr_info.address = bin (dbr_ptr -> l68_dbr.add, 24);
      211 	     dbr_info.bound = (bin (dbr_ptr -> l68_dbr.bound, 14) + 1) * 16;
      212 	     dbr_info.stack_base_segnum = dbr_ptr -> l68_dbr.stack_base_segno * 8;
      213 	     dbr_info.paged = ^ dbr_ptr -> l68_dbr.unpaged;
      214 	end;
      215 	return;
      216      end;
      217 
      218 ptw_util_$dissect: proc (P_ptw_ptr, P_ptw_info_ptr);
      219 
      220 dcl  P_ptw_ptr		        pointer parameter;
      221 dcl  P_ptw_info_ptr		        pointer parameter;
      222 
      223 	ptp = P_ptw_ptr;
      224 	ptw_info_ptr = P_ptw_info_ptr;
      225 	if crash_system_type = ADP_SYSTEM then do;
      226 	     if adp_ptw.add_type = add_type.core then do;
      227 		ptw_info.address = adp_core_ptw.frame * 1024;
      228 		ptw_info.null_disk = "0"b;
      229 	     end;
      230 	     else if adp_ptw.add_type = add_type.disk then do;
      231 		ptw_info.address = bin (substr (adp_ptw.add, 2, 17), 17);
      232 		ptw_info.null_disk = substr (adp_ptw.add, 1, 1);
      233 	     end;
      234 	     else do;
      235 		ptw_info.address = bin (adp_ptw.add, 18);
      236 		ptw_info.null_disk = "0"b;
      237 	     end;
      238 	     ptw_info = adp_ptw.flags, by name;
      239 	end;
      240 	else do;
      241 	     if l68_ptw.add_type = add_type.core then do;
      242 		ptw_info.address = l68_core_ptw.frame * 1024;
      243 		ptw_info.null_disk = "0"b;
      244 	     end;
      245 	     else if l68_ptw.add_type = add_type.disk then do;
      246 		ptw_info.address = bin (substr (l68_ptw.add, 2, 17), 17);
      247 		ptw_info.null_disk = substr (l68_ptw.add, 1, 1);
      248 	     end;
      249 	     else do;
      250 		ptw_info.address = bin (l68_ptw.add, 18);
      251 		ptw_info.null_disk = "0"b;
      252 	     end;
      253 	     ptw_info = l68_ptw.flags, by name;
      254 	end;
      255 	return;
      256      end;
      257 
      258 sdw_util_$dissect: proc (P_sdw_ptr, P_sdw_info_ptr);
      259 
      260 dcl  P_sdw_ptr		        pointer parameter;
      261 dcl  P_sdw_info_ptr		        pointer parameter;
      262 
      263 	sdwp = P_sdw_ptr;				/* Make it addressable */
      264 	sdw_info_ptr = P_sdw_info_ptr;
      265 	unspec (sdw_info) = ""b;			/* Clear it out, and fill it in */
      266 
      267 	if crash_system_type = ADP_SYSTEM then do;
      268 	     string (sdw_info.access) = string (adp_sdw.access);
      269 	     string (sdw_info.rings) = string (adp_sdw.rings);
      270 
      271 	     sdw_info.faulted = ^adp_sdw.valid;		/* Bits are different in state */
      272 	     sdw_info.paged = ^adp_sdw.unpaged;
      273 
      274 	     if ^adp_sdw.not_a_gate then		/* Copy the entry bound, if interesting */
      275 		sdw_info.gate_entry_bound = 1 + binary (adp_sdw.entry_bound, 14);
      276 
      277 	     sdw_info.size = 16 + 16 * binary (adp_sdw.bound, 14);
      278 	     sdw_info.address = binary (adp_sdw.add, 26);
      279 	end;
      280 
      281 	else do;					/* Ordinary Level 68 */
      282 	     string (sdw_info.access) = string (l68_sdw.access);
      283 	     string (sdw_info.rings) = string (l68_sdw.rings);
      284 
      285 	     sdw_info.faulted = ^l68_sdw.valid;		/* Bits are different in state */
      286 	     sdw_info.paged = ^l68_sdw.unpaged;
      287 	     sdw_info.cache = l68_sdw.cache;		/* Only on the Level 68 */
      288 
      289 	     if ^l68_sdw.not_a_gate then		/* Copy the entry bound, if interesting */
      290 		sdw_info.gate_entry_bound = 1 + binary (l68_sdw.entry_bound, 14);
      291 
      292 	     sdw_info.size = 16 + 16 * binary (l68_sdw.bound, 14);
      293 	     sdw_info.address = binary (l68_sdw.add, 24);
      294 	end;
      295 
      296 	return;
      297      end;
      298  
  1     2 	/* BEGIN INCLUDE FILE add_type.incl.pl1 */
  1     3 	/* 02/26/75 by Bernard S. Greenberg */
  1     4 
  1     5 	/* This file provides a structure for checking
  1     6*		PTW/CME address type fields in PL/I */
  1     7 
  1     8 dcl 1 add_type unaligned static internal,
  1     9 	2 core bit (4) init ("1000"b),		/* in core- S/B only in PTW */
  1    10 	2 disk bit (4) init ("0100"b),		/* Disk address */
  1    11 	2 pd   bit (4) init ("0010"b),		/* Paging Device */
  1    12 	2 reserved bit (4) init ("0001"b),		/* Reserved */
  1    13 	2 non_null bit (4) init ("1111"b);		/* Not null address */
  1    14 
  1    15 dcl 1 badd_type unaligned based,
  1    16     2 (core, disk, pd, reserved) bit (1) unaligned;
  1    17 
  1    18 	/* END INCLUDE FILE add_type.incl.pl1 */
      298 
      299  /* BEGIN include file bce_appending_seg_info.incl.pl1 */
  2     2 
  2     3 /* Description of data returned by bce_appending_simulation$new_segment. 
  2     4*Keith Loepere, November 1983. */
  2     5 
  2     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  2     7 
  2     8 dcl  seg_info_ptr		        ptr;
  2     9 dcl  1 seg_info		        aligned based (seg_info_ptr),
  2    10        2 sst_data		        aligned like aste,
  2    11        2 page_table		        (0:255) bit (36) aligned,
  2    12        2 sdwi		        aligned like sdw_info;
  2    13 
  2    14  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  3     2 
  3     3 /* Template for an AST entry. Length = 12 words. */
  3     4 
  3     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  3     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  3     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  3     8 
  3     9 dcl  astep ptr;
  3    10 
  3    11 dcl 1 aste based (astep) aligned,
  3    12 
  3    13     (2 fp bit (18),					/* forward  used list rel pointer */
  3    14     2 bp bit (18),					/* backward used list rel pointer */
  3    15 
  3    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  3    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  3    18 
  3    19     2 strp bit (18),				/* rel pointer to process trailer */
  3    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  3    21 
  3    22     2 uid bit (36),					/* segment unique id */
  3    23 
  3    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    25     2 pvtx fixed bin (8),				/* physical volume table index */
  3    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    27 
  3    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  3    29     2 init bit (1),					/* used bit - insure 1 lap */
  3    30     2 gtus bit (1),					/* global transparent usage switch */
  3    31     2 gtms bit (1),					/* global transparent modified switch */
  3    32     2 hc bit (1),					/* hard core segment */
  3    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  3    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  3    35     2 write_access_on bit (1),			/* any sdw allows write access */
  3    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  3    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  3    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  3    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  3    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  3    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  3    42     2 pad1 bit (2),					/* OO */
  3    43     2 dius bit (1),					/* dumper in use switch */
  3    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  3    45     2 dmpr_pad bit (1),
  3    46     2 ehs bit (1),					/* entry hold switch */
  3    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    48     2 dirsw bit (1),				/* directory switch */
  3    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  3    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  3    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  3    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  3    53 
  3    54     2 dtu bit (36),					/* date and time segment last used */
  3    55 
  3    56     2 dtm bit (36),					/* date and time segment last modified */
  3    57 
  3    58 
  3    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    60 
  3    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    62 
  3    63     2 csl bit (9),					/* current segment length in 1024 words units */
  3    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  3    65     2 fms bit (1),					/* file modified switch */
  3    66     2 npfs bit (1),					/* no page fault switch */
  3    67     2 gtpd bit (1),					/* global transparent paging device switch */
  3    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  3    69     2 per_process bit (1),				/* use master quota for this entry */
  3    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  3    71     2 pad2 bit (2),
  3    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  3    73     2 np bit (9),					/* number of pages in core */
  3    74 
  3    75 
  3    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  3    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  3    78     2 damaged bit (1),				/* PC declared segment unusable */
  3    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  3    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  3    81     2 pad3 bit (6),					/* OOOOOOOOO */
  3    82     2 ptsi bit (2),					/* page table size index */
  3    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  3    84 
  3    85 
  3    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  3    87 
  3    88 
  3    89 dcl 1 aste_part aligned based (astep),
  3    90 
  3    91     2 one bit (36) unaligned,				/* fp and bp */
  3    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  3    93     2 three bit (8) unaligned;			/* ptsi and marker */
  3    94 
  3    95 
  3    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  3    97     2 pad1 bit (8*36),
  3    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    99     2 pad2 bit (3*36);
  3   100 
  3   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
  2    14 
  2    15  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
  4     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  4     3 
  4     4 dcl  sdw_info_ptr pointer;
  4     5 
  4     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
  4     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
  4     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
  4     9 
  4    10     2 access unaligned,				/* REWP */
  4    11       3 read bit (1) unaligned,
  4    12       3 execute bit (1) unaligned,
  4    13       3 write bit (1) unaligned,
  4    14       3 privileged bit (1) unaligned,
  4    15 
  4    16     2 pad1 bit (32) unaligned,
  4    17 
  4    18     2 rings unaligned,				/* Ring brackets */
  4    19       3 r1 bit (3) unaligned,
  4    20       3 r2 bit (3) unaligned,
  4    21       3 r3 bit (3) unaligned,
  4    22 
  4    23     2 pad2 bit (27) unaligned,
  4    24 
  4    25     2 flags aligned,
  4    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
  4    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
  4    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
  4    29       3 pad3 bit (33) unaligned,
  4    30 
  4    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
  4    32 
  4    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
  2    15 
  2    16 
  2    17 /* END include file bce_appending_seg_info.incl.pl1 */
      299 
      300  /* BEGIN INCLUDE FILE ... dbr.adp.incl.pl1 ... Created July, 1981 */
  5     2 
  5     3 dcl 1 adp_dbr aligned based,				/* ADP Descriptor Base Register */
  5     4 
  5     5    (2 add bit (26), 				/* Page table address */
  5     6     2 pad1 bit (1),					/* overlays adp_sdw.valid */
  5     7     2 pad2 bit (9),					/* overlays adp_sdw.rungs */
  5     8 
  5     9     2 bound bit (14),				/* Bound of segment, in 16 word blocks */
  5    10     2 pad3 bit (2),
  5    11     2 stack_base_segno fixed bin (14) unsigned,		/* overlays ad_sdw.entry_bound */
  5    12     2 pad4 bit (4),					/* overlays adp_sdw.access */
  5    13     2 unpaged bit (1),				/* "1"b => segment is unpaged */
  5    14     2 pad5 bit (1)) unaligned;			/* overlays adp_sdw.not_a_gate */
  5    15 
  5    16 /* END INCLUDE FILE dbr.adp.incl.pl1 */
      300 
      301  /* BEGIN INCLUDE FILE ... dbr.l68.incl.pl1 ... Created July, 1981 */
  6     2 
  6     3 dcl 1 l68_dbr aligned based,				/* Level 68 Descriptor Base Register */
  6     4 
  6     5    (2 add bit (24), 				/* main memory address of page table */
  6     6     2 pad1 bit (9),					/* overlays l68_sdw.rings */
  6     7     2 pad2 bit (3),					/* overlays l68_sdw.valid & df_no */
  6     8 
  6     9     2 pad3 bit (1),
  6    10     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  6    11     2 pad4 bit (4),					/* overlays l68_sdw.access */
  6    12     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  6    13     2 pad5 bit (1),					/* overlays l68_sdw.not_a_gate */
  6    14     2 pad6 bit (1),					/* overlays l68_sdw.cache */
  6    15     2 stack_base_segno fixed bin (14) unsigned) unaligned;	/* overlays l68_sdw.entry_bound */
  6    16 
  6    17 /* END INCLUDE FILE ... dbr.l68.incl.pl1 */
      301 
      302  /* BEGIN include file dbr_info.incl.pl1 */
  7     2 
  7     3 /* This include file describes the structure returned by dbr_util_$dissect.
  7     4*Keith Loepere, October 1983. */
  7     5 
  7     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  7     7 
  7     8 dcl  dbr_info_ptr		        ptr;
  7     9 
  7    10 dcl  1 dbr_info		        aligned based (dbr_info_ptr),
  7    11        2 address		        fixed bin (26),	/* of dseg or dseg page table */
  7    12        2 bound		        fixed bin (18),	/* length of dseg in words */
  7    13        2 stack_base_segnum	        fixed bin (15),	/* segment number of ring 0 stack */
  7    14        2 paged		        bit (1);		/* is dseg paged? */
  7    15 
  7    16 /* END include file dbr_info.incl.pl1 */
      302 
      303  /* BEGIN INCLUDE FILE ... ptw.adp.incl.pl1 ... 02/11/81, for ADP conversion */
  8     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  8     3 
  8     4 dcl 1 adp_core_ptw aligned based (ptp), 		/* PTW for in-core page */
  8     5     2 pad1 bit (2) unaligned,
  8     6     2 frame fixed bin (16) unsigned unaligned,		/* Core frame number */
  8     7     2 flags like adp_ptw_flags unaligned;		/* add_type = "00"b; */
  8     8 
  8     9 dcl 1 adp_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  8    10     2 add bit (18) unaligned,
  8    11     2 flags like adp_ptw_flags unaligned;
  8    12 
  8    13 dcl 1 adp_special_ptw aligned based (ptp) like adp_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  8    14 dcl 1 adp_real_disk_ptw aligned based (ptp) like adp_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  8    15 dcl 1 adp_null_disk_ptw aligned based (ptp) like adp_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  8    16 
  8    17 dcl 1 adp_ptw_flags unaligned based,			/* Common lower halfword for ADP PTW */
  8    18    (2 add_type bit (4),				/* See specific declarations */
  8    19     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  8    20     2 wired bit (1),				/* page is to remain in core */
  8    21     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  8    22     2 phu1 bit (1), 				/* page has been used in the quantum */
  8    23     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  8    24 
  8    25     2 unusable1 bit (3),				/* Shares hardware byte */
  8    26     2 valid bit (1),				/* "1"b if page is in core */
  8    27     2 write bit (1),				/* "1"b if page may be written into */
  8    28     2 unusable2 bit (1),				/* Shares hardware byte */
  8    29     2 iox bit (1),					/* "1"b if page is to be present to IOX */
  8    30     2 phm bit (1),					/* page has been modified bit */
  8    31     2 phu bit (1)) unaligned; 			/* page has been used bit */
  8    32 
  8    33 /* END INCLUDE FILE ... ptw.adp.incl.pl1 */
      303 
      304  /* BEGIN INCLUDE FILE ... ptw.l68.incl.pl1 ... 02/26/81, for ADP conversion */
  9     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  9     3 
  9     4 dcl 1 l68_core_ptw aligned based (ptp), 		/* In-core page descriptor */
  9     5     2 frame fixed bin (14) unsigned unaligned,		/* Core frame number */
  9     6     2 pad1 bit (4) unaligned,
  9     7     2 flags unaligned like l68_ptw_flags;
  9     8 
  9     9 dcl 1 l68_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  9    10     2 add bit (18) unaligned,
  9    11     2 flags like l68_ptw_flags unaligned;
  9    12 
  9    13 dcl 1 l68_special_ptw aligned based (ptp) like l68_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  9    14 dcl 1 l68_real_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  9    15 dcl 1 l68_null_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  9    16 
  9    17 dcl 1 l68_ptw_flags unaligned based,			/* Various software/hardware flags */
  9    18    (2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  9    19     2 first bit (1),				/* the page has not yet been written out */
  9    20     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  9    21 
  9    22     2 pad1 bit (1),
  9    23     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  9    24     2 phu bit (1),					/* page has been used bit */
  9    25 
  9    26     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  9    27     2 nypd bit (1), 				/* must be moved to paging device */
  9    28     2 phm bit (1),					/* page has been modified bit */
  9    29 
  9    30     2 phu1 bit (1), 				/* page has been used in the quantum */
  9    31     2 wired bit (1),				/* page is to remain in core */
  9    32     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  9    33     2 valid bit (1),				/* directed fault if this is 0 (page not in core) */
  9    34     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  9    35 
  9    36 /* END INCLUDE FILE ... ptw.l68.incl.pl1 */
      304 
      305  /* BEGIN include file ptw_info.incl.pl1 */
 10     2 
 10     3 /* Description of the info returned by ptw_util_$dissect.  
 10     4*Keith Loepere, October 1983. */
 10     5 
 10     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 10     7 
 10     8 dcl  ptw_info_ptr		        ptr;
 10     9 
 10    10 dcl  1 ptw_info		        aligned based (ptw_info_ptr),
 10    11        2 address		        fixed bin (26),	/* memory or device number */
 10    12        2 add_type		        bit (4) unal,
 10    13        2 null_disk		        bit (1) unal,
 10    14        2 er		        bit (1) unal,
 10    15        2 wired		        bit (1) unal,
 10    16        2 os		        bit (1) unal,
 10    17        2 phu1		        bit (1) unal,	/* used in quantum */
 10    18        2 phm1		        bit (1) unal,	/* modified in quantum */
 10    19        2 valid		        bit (1) unal,
 10    20        2 phu		        bit (1) unal,
 10    21        2 phm		        bit (1) unal;
 10    22 
 10    23 /* END include file ptw_info.incl.pl1 */
      305 
      306  /* BEGIN INCLUDE FILE ... sdw.adp.incl.pl1 ... 01/16/81, for ADP conversion */
 11     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
 11     3 
 11     4 dcl 1 adp_sdw based (sdwp) aligned,			/* ADP Segment Descriptor Word */
 11     5 
 11     6    (2 add bit (26), 				/* Page table address */
 11     7     2 valid bit (1),				/* "1"b => SDW is valid */
 11     8     2 rings,					/* Ring brackets */
 11     9       3 r1 bit (3),
 11    10       3 r2 bit (3),
 11    11       3 r3 bit (3),
 11    12 
 11    13     2 bound bit (14),				/* Bound of segment, in 16 word blocks */
 11    14     2 pad1 bit (2),
 11    15     2 entry_bound bit (14),				/* Gate entry bound */
 11    16     2 access,					/* Access permission bits */
 11    17       3 read bit (1),
 11    18       3 execute bit (1),
 11    19       3 write bit (1),
 11    20       3 privileged bit (1),
 11    21     2 unpaged bit (1),				/* "1"b => segment is unpaged */
 11    22     2 not_a_gate bit (1)) unaligned;			/* "0"b => entry bound is checked by hardware */
 11    23 
 11    24 /* END INCLUDE FILE sdw.adp.incl.pl1 */
      306 
      307  /* BEGIN INCLUDE FILE ... sdw.l68.incl.pl1 ... Updated for ADP conversion 03/01/81 */
 12     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
 12     3 
 12     4 dcl 1 l68_sdw based (sdwp) aligned,			/* Level 68 Segment Descriptor Word */
 12     5 
 12     6    (2 add bit (24), 				/* main memory address of page table */
 12     7     2 rings,					/* ring brackets for the segment */
 12     8       3 r1 bit (3),
 12     9       3 r2 bit (3),
 12    10       3 r3 bit (3),
 12    11     2 valid bit (1),				/* directed fault bit (0 => fault) */
 12    12     2 df_no bit (2),				/* directed fault number */
 12    13 
 12    14     2 pad1 bit (1),
 12    15     2 bound bit (14),				/* boundary field (in 16 word blocks) */
 12    16     2 access,					/* access bits */
 12    17       3 read bit (1),				/* read permission bit */
 12    18       3 execute bit (1),				/* execute permission bit */
 12    19       3 write bit (1),				/* write permission bit */
 12    20       3 privileged bit (1),				/* privileged bit */
 12    21     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
 12    22     2 not_a_gate bit (1),				/* if this is 0 the entry bound is checked by hardware */
 12    23     2 cache bit (1),				/* cache enable bit */
 12    24     2 entry_bound bit (14)) unaligned;			/* entry bound */
 12    25 
 12    26 /* END INCLUDE FILE ... sdw.l68.incl.pl1 */
      307 
      308  /* BEGIN INCLUDE FILE ... system_types.incl.pl1 ... 03/23/81 ... W. Olin Sibert */
 13     2 
 13     3 dcl  L68_SYSTEM	fixed bin (17) internal static options (constant) init (1);
 13     4 dcl  ADP_SYSTEM	fixed bin (17) internal static options (constant) init (2);
 13     5 
 13     6 dcl  SYSTEM_TYPE_NAME (2) char (8) internal static options (constant) init
 13     7     ("Level68", "ADP");
 13     8 
 13     9 /* END INCLUDE FILE ... system_types.incl.pl1 */
      308 
      309      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1300.8  ed_appending_simulation_.pl1      >spec>temp>41-5>ed_appending_simulation_.pl1
298          1    09/29/77  1502.7  add_type.incl.pl1                 >ldd>include>add_type.incl.pl1
299          2    07/11/84  0937.3  bce_appending_seg_info.incl.pl1   >ldd>include>bce_appending_seg_info.incl.pl1
2-14         3    01/22/85  1321.5  aste.incl.pl1                     >spec>temp>41-5>aste.incl.pl1
2-15         4    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
300          5    03/27/82  0430.3  dbr.adp.incl.pl1                  >ldd>include>dbr.adp.incl.pl1
301          6    03/27/82  0430.3  dbr.l68.incl.pl1                  >ldd>include>dbr.l68.incl.pl1
302          7    07/11/84  0937.3  dbr_info.incl.pl1                 >ldd>include>dbr_info.incl.pl1
303          8    03/27/82  0430.2  ptw.adp.incl.pl1                  >ldd>include>ptw.adp.incl.pl1
304          9    03/27/82  0430.2  ptw.l68.incl.pl1                  >ldd>include>ptw.l68.incl.pl1
305         10    07/11/84  0937.3  ptw_info.incl.pl1                 >ldd>include>ptw_info.incl.pl1
306         11    03/27/82  0429.8  sdw.adp.incl.pl1                  >ldd>include>sdw.adp.incl.pl1
307         12    03/27/82  0429.8  sdw.l68.incl.pl1                  >ldd>include>sdw.l68.incl.pl1
308         13    06/19/81  2115.0  system_types.incl.pl1             >ldd>include>system_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADP_SYSTEM                             constant        fixed bin(17,0)          initial dcl 13-4 ref 203 225 267
P_ptw_info_ptr                         parameter       pointer                  dcl 221 ref 218 224
P_ptw_ptr                              parameter       pointer                  dcl 220 ref 218 223
P_sdw_info_ptr                         parameter       pointer                  dcl 261 ref 258 264
P_sdw_ptr                              parameter       pointer                  dcl 260 ref 258 263
access                    2            based           structure                level 2 in structure "sdw_info" packed unaligned
                                                                                  dcl 4-6 in procedure "ed_appending_simulation_"
                                                                                  set ref 268* 282*
access                    1(30)        based           structure                level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 268
access                    1(15)        based           structure                level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 282
add                                    based           bit(18)                  level 2 in structure "adp_ptw" packed unaligned
                                                                                  dcl 8-9 in procedure "ed_appending_simulation_"
                                                                                  ref 231 232 235
add                                    based           bit(24)                  level 2 in structure "l68_dbr" packed unaligned
                                                                                  dcl 6-3 in procedure "ed_appending_simulation_"
                                                                                  ref 210
add                                    based           bit(18)                  level 2 in structure "l68_ptw" packed unaligned
                                                                                  dcl 9-9 in procedure "ed_appending_simulation_"
                                                                                  ref 246 247 250
add                                    based           bit(26)                  level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 278
add                                    based           bit(24)                  level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 293
add                                    based           bit(26)                  level 2 in structure "adp_dbr" packed unaligned
                                                                                  dcl 5-3 in procedure "ed_appending_simulation_"
                                                                                  ref 204
add_type                  0(18)        based           bit(4)                   level 3 in structure "adp_ptw" packed unaligned
                                                                                  dcl 8-9 in procedure "ed_appending_simulation_"
                                                                                  ref 226 230
add_type                  0(18)        based           bit(4)                   level 3 in structure "l68_ptw" packed unaligned
                                                                                  dcl 9-9 in procedure "ed_appending_simulation_"
                                                                                  ref 241 245
add_type                        000000 constant        structure                level 1 packed unaligned dcl 1-8 in procedure
                                                                                  "ed_appending_simulation_"
address                 414     000011 internal static fixed bin(26,0)          level 3 in structure "dseg_info" dcl 23 in procedure
                                                                                  "ed_appending_simulation_" set ref 66* 71 78*
address                                based           fixed bin(26,0)          level 2 in structure "dbr_info" dcl 7-10
                                                                                  in procedure "ed_appending_simulation_" set ref 66
                                                                                  204* 210*
address                                based           fixed bin(26,0)          level 2 in structure "ptw_info" dcl 10-10
                                                                                  in procedure "ed_appending_simulation_" set ref
                                                                                  74* 175 227* 231* 235* 242* 246* 250*
address                                based           fixed bin(26,0)          level 2 in structure "sdw_info" dcl 4-6 in procedure
                                                                                  "ed_appending_simulation_" set ref 278* 293*
address                 414            based           fixed bin(26,0)          level 3 in structure "seg_info" dcl 2-9 in procedure
                                                                                  "ed_appending_simulation_" set ref 135 185
address                         000100 automatic       fixed bin(26,0)          dcl 13 in procedure "ed_appending_simulation_" set
                                                                                  ref 97* 99* 102 104 109 109 162* 164* 167 168 169
                                                                                  185* 186*
adp_core_ptw                           based           structure                level 1 dcl 8-4
adp_dbr                                based           structure                level 1 dcl 5-3
adp_ptw                                based           structure                level 1 dcl 8-9
adp_ptw_flags                          based           structure                level 1 packed unaligned dcl 8-17
adp_sdw                                based           structure                level 1 dcl 11-4
aste                                   based           structure                level 1 dcl 3-11 ref 71 71 135 135
astep                                  automatic       pointer                  dcl 3-9 ref 71 71 135 135
bound                     1            based           bit(14)                  level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 277
bound                     1            based           fixed bin(18,0)          level 2 in structure "dbr_info" dcl 7-10
                                                                                  in procedure "ed_appending_simulation_" set ref 64
                                                                                  71 205* 211*
bound                     1            based           bit(14)                  level 2 in structure "adp_dbr" packed unaligned
                                                                                  dcl 5-3 in procedure "ed_appending_simulation_"
                                                                                  ref 205
bound                     1(01)        based           bit(14)                  level 2 in structure "l68_dbr" packed unaligned
                                                                                  dcl 6-3 in procedure "ed_appending_simulation_"
                                                                                  ref 211
bound                     1(01)        based           bit(14)                  level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 292
cache                     4(02)        based           bit(1)                   level 3 in structure "sdw_info" packed unaligned
                                                                                  dcl 4-6 in procedure "ed_appending_simulation_"
                                                                                  set ref 287*
cache                     1(21)        based           bit(1)                   level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 287
code                                   parameter       fixed bin(35,0)          dcl 14 set ref 54 60* 71* 72 74* 75 78* 79 84 105*
                                                                                  116 120* 126* 127 131* 135* 136 143 147* 156* 175*
                                                                                  179 179* 186*
core                            000000 constant        bit(4)                   initial level 2 packed unaligned dcl 1-8 ref 226 241
crash_system_type               000010 internal static fixed bin(17,0)          dcl 15 set ref 51* 203 225 267
data_length                     000101 automatic       fixed bin(18,0)          dcl 16 set ref 86* 92 96 97 97 100 112* 112 151* 153
                                                                                  154 157* 157 160 161 162 162 165 181* 181
data_part                              based           bit(36)                  array dcl 17 set ref 106* 110* 110 155* 178*
data_part_length                000102 automatic       fixed bin(18,0)          dcl 18 set ref 96* 97 97 100* 106 110 112 153* 154
                                                                                  155 157 161* 162 162 165* 175* 178 181
data_ptr                        000104 automatic       pointer                  dcl 19 set ref 102* 106 110 154* 155 167* 175* 178
dbr_info                               based           structure                level 1 dcl 7-10
dbr_info_ptr                    000134 automatic       pointer                  dcl 7-8 set ref 61* 63* 64 65 66 71 202* 204 205 206
                                                                                  207 210 211 212 213
dbr_ptr                                parameter       pointer                  dcl 199 ref 194 204 205 206 207 210 211 212 213
dbr_value                              parameter       bit(72)                  dcl 20 set ref 54 63 63
desired_segnum                         parameter       fixed bin(15,0)          dcl 21 ref 116 126
disk                      0(04) 000000 constant        bit(4)                   initial level 2 packed unaligned dcl 1-8 ref 230 245
dseg_info                       000011 internal static structure                level 1 dcl 23 set ref 126 126
dseg_sdw                        000106 automatic       fixed bin(71,0)          dcl 22 set ref 74 74 78 78 81 81
entry_bound               1(16)        based           bit(14)                  level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 274
entry_bound               1(22)        based           bit(14)                  level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 289
error_table_$argerr             000444 external static fixed bin(35,0)          dcl 24 ref 179
error_table_$boundviol          000446 external static fixed bin(35,0)          dcl 25 ref 156
error_table_$invalidsegno       000450 external static fixed bin(35,0)          dcl 26 ref 131
error_table_$out_of_bounds      000452 external static fixed bin(35,0)          dcl 27 ref 105
faulted                 420(01)        based           bit(1)                   level 4 in structure "seg_info" packed unaligned
                                                                                  dcl 2-9 in procedure "ed_appending_simulation_"
                                                                                  set ref 130 137*
faulted                   4(01)        based           bit(1)                   level 3 in structure "sdw_info" packed unaligned
                                                                                  dcl 4-6 in procedure "ed_appending_simulation_"
                                                                                  set ref 271* 285*
flags                     4            based           structure                level 2 in structure "sdw_info" dcl 4-6 in procedure
                                                                                  "ed_appending_simulation_"
flags                   420     000011 internal static structure                level 3 in structure "dseg_info" dcl 23 in procedure
                                                                                  "ed_appending_simulation_"
flags                     0(18)        based           structure                level 2 in structure "l68_ptw" packed unaligned
                                                                                  dcl 9-9 in procedure "ed_appending_simulation_"
                                                                                  ref 253
flags                     0(18)        based           structure                level 2 in structure "adp_ptw" packed unaligned
                                                                                  dcl 8-9 in procedure "ed_appending_simulation_"
                                                                                  ref 238
flags                   420            based           structure                level 3 in structure "seg_info" dcl 2-9 in procedure
                                                                                  "ed_appending_simulation_"
frame                                  based           fixed bin(14,0)          level 2 in structure "l68_core_ptw" packed unsigned
                                                                                  unaligned dcl 9-4 in procedure
                                                                                  "ed_appending_simulation_" ref 242
frame                     0(02)        based           fixed bin(16,0)          level 2 in structure "adp_core_ptw" packed unsigned
                                                                                  unaligned dcl 8-4 in procedure
                                                                                  "ed_appending_simulation_" ref 227
gate_entry_bound          5            based           fixed bin(14,0)          level 2 dcl 4-6 set ref 274* 289*
l68_core_ptw                           based           structure                level 1 dcl 9-4
l68_dbr                                based           structure                level 1 dcl 6-3
l68_ptw                                based           structure                level 1 dcl 9-9
l68_ptw_flags                          based           structure                level 1 packed unaligned dcl 9-17
l68_sdw                                based           structure                level 1 dcl 12-4
memory_block_ptrs               000434 internal static pointer                  array dcl 28 set ref 50* 109
multics_data_ptr                000110 automatic       pointer                  dcl 29 set ref 109* 110
my_dbr_info                     000112 automatic       structure                level 1 dcl 30 set ref 61
my_ptw_info                     000116 automatic       structure                level 1 dcl 31 set ref 62 149
not_a_gate                1(35)        based           bit(1)                   level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 274
not_a_gate                1(20)        based           bit(1)                   level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 289
null_disk                 1(04)        based           bit(1)                   level 2 packed unaligned dcl 10-10 set ref 228* 232*
                                                                                  236* 243* 247* 251*
p_address                              parameter       fixed bin(26,0)          dcl 32 ref 84 96 97 99 102 143 152 153 161 162 164
                                                                                  167 185
p_crash_system_type                    parameter       fixed bin(17,0)          dcl 33 ref 46 51
p_data_length                          parameter       fixed bin(18,0)          dcl 34 set ref 84 86 143 151 152 186*
p_data_ptr                             parameter       pointer                  dcl 35 set ref 84 102 143 154 167 186*
p_dbr_info_ptr                         parameter       pointer                  dcl 200 ref 194 202
p_last_segnum                          parameter       fixed bin(15,0)          dcl 36 set ref 54 64*
p_memory_block_ptrs                    parameter       pointer                  array dcl 37 ref 46 50
p_seg_info_ptr                         parameter       pointer                  dcl 38 ref 116 121 143 148
page_num                        000120 automatic       fixed bin(17,0)          dcl 39 set ref 168* 174 174
page_offset                     000121 automatic       fixed bin(17,0)          dcl 40 set ref 169* 175
page_table               14     000011 internal static bit(36)                  array level 2 in structure "dseg_info" dcl 23
                                                                                  in procedure "ed_appending_simulation_" set ref 73
                                                                                  73
page_table               14            based           bit(36)                  array level 2 in structure "seg_info" dcl 2-9
                                                                                  in procedure "ed_appending_simulation_" set ref
                                                                                  174 174
paged                     3            based           bit(1)                   level 2 in structure "dbr_info" dcl 7-10
                                                                                  in procedure "ed_appending_simulation_" set ref 65
                                                                                  207* 213*
paged                   420     000011 internal static bit(1)                   level 4 in structure "dseg_info" packed unaligned
                                                                                  dcl 23 in procedure "ed_appending_simulation_" set
                                                                                  ref 65* 70
paged                     4            based           bit(1)                   level 3 in structure "sdw_info" packed unaligned
                                                                                  dcl 4-6 in procedure "ed_appending_simulation_"
                                                                                  set ref 272* 286*
paged                   420            based           bit(1)                   level 4 in structure "seg_info" packed unaligned
                                                                                  dcl 2-9 in procedure "ed_appending_simulation_"
                                                                                  set ref 134 159
ptp                             000122 automatic       pointer                  dcl 41 set ref 223* 226 227 230 231 232 235 238 241
                                                                                  242 245 246 247 250 253
ptw_info                               based           structure                level 1 dcl 10-10 set ref 238* 253*
ptw_info_ptr                    000136 automatic       pointer                  dcl 10-8 set ref 62* 73* 74 149* 174* 175 175 224*
                                                                                  227 228 231 232 235 236 238 242 243 246 247 250
                                                                                  251 253
rings                     3            based           structure                level 2 in structure "sdw_info" packed unaligned
                                                                                  dcl 4-6 in procedure "ed_appending_simulation_"
                                                                                  set ref 269* 283*
rings                     0(24)        based           structure                level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 283
rings                     0(27)        based           structure                level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 269
sdw_info                               based           structure                level 1 dcl 4-6 set ref 265*
sdw_info_ptr                    000132 automatic       pointer                  dcl 4-4 set ref 264* 265 268 269 271 272 274 277 278
                                                                                  282 283 285 286 287 289 292 293
sdwi                    414     000011 internal static structure                level 2 in structure "dseg_info" dcl 23 in procedure
                                                                                  "ed_appending_simulation_" set ref 81 81
sdwi                    414            based           structure                level 2 in structure "seg_info" dcl 2-9 in procedure
                                                                                  "ed_appending_simulation_" set ref 129 129
sdwp                            000124 automatic       pointer                  dcl 42 set ref 263* 268 269 271 272 274 274 277 278
                                                                                  282 283 285 286 287 289 289 292 293
seg_info                               based           structure                level 1 dcl 2-9
seg_info_ptr                    000130 automatic       pointer                  dcl 2-8 set ref 121* 129 129 130 134 135 135 135 135
                                                                                  137 148* 152 153 159 174 174 185
seg_sdw                         000126 automatic       fixed bin(71,0)          dcl 43 set ref 126 126 129 129
size                    415            based           fixed bin(19,0)          level 3 in structure "seg_info" dcl 2-9 in procedure
                                                                                  "ed_appending_simulation_" set ref 135 152 153
size                      1            based           fixed bin(19,0)          level 2 in structure "sdw_info" dcl 4-6 in procedure
                                                                                  "ed_appending_simulation_" set ref 277* 292*
size                                                   builtin function         dcl 44 in procedure "ed_appending_simulation_" ref
                                                                                  71 71 135 135
sst_data                               based           structure                level 2 in structure "seg_info" dcl 2-9 in procedure
                                                                                  "ed_appending_simulation_" set ref 135 135
sst_data                        000011 internal static structure                level 2 in structure "dseg_info" dcl 23 in procedure
                                                                                  "ed_appending_simulation_" set ref 71 71
stack_base_segno          1(16)        based           fixed bin(14,0)          level 2 in structure "adp_dbr" packed unsigned
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "ed_appending_simulation_" ref 206
stack_base_segno          1(22)        based           fixed bin(14,0)          level 2 in structure "l68_dbr" packed unsigned
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "ed_appending_simulation_" ref 212
stack_base_segnum         2            based           fixed bin(15,0)          level 2 dcl 7-10 set ref 206* 212*
unpaged                   1(19)        based           bit(1)                   level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 286
unpaged                   1(19)        based           bit(1)                   level 2 in structure "l68_dbr" packed unaligned
                                                                                  dcl 6-3 in procedure "ed_appending_simulation_"
                                                                                  ref 213
unpaged                   1(34)        based           bit(1)                   level 2 in structure "adp_dbr" packed unaligned
                                                                                  dcl 5-3 in procedure "ed_appending_simulation_"
                                                                                  ref 207
unpaged                   1(34)        based           bit(1)                   level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 272
valid                     0(26)        based           bit(1)                   level 2 in structure "adp_sdw" packed unaligned
                                                                                  dcl 11-4 in procedure "ed_appending_simulation_"
                                                                                  ref 271
valid                     0(33)        based           bit(1)                   level 2 in structure "l68_sdw" packed unaligned
                                                                                  dcl 12-4 in procedure "ed_appending_simulation_"
                                                                                  ref 285
valid                     1(10)        based           bit(1)                   level 2 in structure "ptw_info" packed unaligned
                                                                                  dcl 10-10 in procedure "ed_appending_simulation_"
                                                                                  set ref 175

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
L68_SYSTEM                             internal static fixed bin(17,0)          initial dcl 13-3
SYSTEM_TYPE_NAME                       internal static char(8)                  initial array unaligned dcl 13-6
adp_null_disk_ptw                      based           structure                level 1 dcl 8-15
adp_real_disk_ptw                      based           structure                level 1 dcl 8-14
adp_special_ptw                        based           structure                level 1 dcl 8-13
asta                                   based           bit(432)                 array dcl 3-86
aste_part                              based           structure                level 1 dcl 3-89
badd_type                              based           structure                level 1 packed unaligned dcl 1-15
l68_null_disk_ptw                      based           structure                level 1 dcl 9-15
l68_real_disk_ptw                      based           structure                level 1 dcl 9-14
l68_special_ptw                        based           structure                level 1 dcl 9-13
seg_aste                               based           structure                level 1 dcl 3-96

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_page                        000661 constant        label                    dcl 178
bad_segment                     000475 constant        label                    dcl 138 ref 127 132
dbr_util_$dissect               000722 constant        entry                    internal dcl 194 ref 63
ed_appending_simulation_        000015 constant        entry                    external dcl 6
get_absolute                    000230 constant        entry                    external dcl 84 ref 71 74 78 135 175 186
get_virtual                     000504 constant        entry                    external dcl 143 ref 126
init                            000027 constant        entry                    external dcl 46
new_dbr                         000050 constant        entry                    external dcl 54
new_segment                     000347 constant        entry                    external dcl 116
ptw_util_$dissect               001005 constant        entry                    internal dcl 218 ref 73 174
sdw_util_$dissect               001264 constant        entry                    internal dcl 258 ref 81 129

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 61 62 63 63 71 71 73 73 74 74 78 78 81 81 81 81
                                                                                  126 126 126 126 129 129 129 129 135 135 149 174
                                                                                  174
addrel                                                 builtin function         ref 102 109 154 167
bin                                                    builtin function         ref 204 205 210 211 231 235 246 250
binary                                                 builtin function         ref 274 277 278 289 292 293
divide                                                 builtin function         ref 64 71 109 135 168
mod                                                    builtin function         ref 96 109 161 169
string                                                 builtin function         set ref 268 268 269* 269 282* 282 283* 283
substr                                                 builtin function         ref 231 232 246 247
unspec                                                 builtin function         set ref 106 155* 178* 265*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1606        2262    1464        1616
Length      2720    1464       454         421     122         434

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ed_appending_simulation_            153 external procedure  is an external procedure.  
dbr_util_$dissect                       internal procedure  shares stack frame of external procedure ed_appending_simulation_.  
ptw_util_$dissect                       internal procedure  shares stack frame of external procedure ed_appending_simulation_.  
sdw_util_$dissect                       internal procedure  shares stack frame of external procedure ed_appending_simulation_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 crash_system_type           ed_appending_simulation_
000011 dseg_info                   ed_appending_simulation_
000434 memory_block_ptrs           ed_appending_simulation_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ed_appending_simulation_ 000100 address                     ed_appending_simulation_
                         000101 data_length                 ed_appending_simulation_
                         000102 data_part_length            ed_appending_simulation_
                         000104 data_ptr                    ed_appending_simulation_
                         000106 dseg_sdw                    ed_appending_simulation_
                         000110 multics_data_ptr            ed_appending_simulation_
                         000112 my_dbr_info                 ed_appending_simulation_
                         000116 my_ptw_info                 ed_appending_simulation_
                         000120 page_num                    ed_appending_simulation_
                         000121 page_offset                 ed_appending_simulation_
                         000122 ptp                         ed_appending_simulation_
                         000124 sdwp                        ed_appending_simulation_
                         000126 seg_sdw                     ed_appending_simulation_
                         000130 seg_info_ptr                ed_appending_simulation_
                         000132 sdw_info_ptr                ed_appending_simulation_
                         000134 dbr_info_ptr                ed_appending_simulation_
                         000136 ptw_info_ptr                ed_appending_simulation_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in         return              mod_fx1             ext_entry

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$boundviol        error_table_$invalidsegno     error_table_$out_of_bounds


CONSTANTS
001430  aa     757777777777

001432  aa     000004000000
001433  aa     000000000000
001434  aa     600000000041
001435  aa     000212000000
001436  aa     600000000041
001437  aa     000136000000

001440  aa     000004000000
001441  aa     000000000000
001442  aa     600000000041
001443  aa     000174000000
001444  aa     600000000041
001445  aa     000212000000

001446  aa     000004000000
001447  aa     000000000000
001450  aa     600000000041
001451  aa     000174000000
001452  aa     600000000041
001453  aa     000136000000

001454  aa     000004000000
001455  aa     000000000000
001456  aa     600000000041
001457  aa     000174000000
001460  aa     600000000041
001461  aa     000134000000

001462  aa     000000400000

001463  aa     000000002000

000001  aa     464000000000

000002  aa     404000000022

000003  aa     404000000021

000004  aa     404000000032

000005  aa     404000000017

000006  aa     514000000110

000007  aa     404000000043

000010  aa     464100000000
000011  aa     000000000001
000012  aa     000000000004
000013  aa     000000000002

BEGIN PROCEDURE ed_appending_simulation_
ENTRY TO ed_appending_simulation_                           STATEMENT 1 ON LINE 6
ed_appending_simulation_: proc;

000014  da     000061200000
000015  aa   000240 6270 00	eax7 	160
000016  aa  7 00034 3521 20	epp2 	pr7|28,*
000017  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000020  aa     000000000000
000021  aa     000000000000
						STATEMENT 1 ON LINE 46
init: entry (p_memory_block_ptrs, p_crash_system_type);

000022  aa   000012 7100 04	tra  	10,ic		000034
ENTRY TO init                                               STATEMENT 1 ON LINE 46
init: entry (p_memory_block_ptrs, p_crash_system_type);

000023  at     000002000010
000024  ta     000003000000
000025  ta     000023000000
000026  da     000066300000
000027  aa   000240 6270 00	eax7 	160
000030  aa  7 00034 3521 20	epp2 	pr7|28,*
000031  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000032  aa     000004000000
000033  aa     000000000000
						STATEMENT 1 ON LINE 50
	memory_block_ptrs = p_memory_block_ptrs;

000034  aa  6 00032 3735 20	epp7 	pr6|26,*
000035  aa  7 00002 3715 20	epp5 	pr7|2,*
000036  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000037  aa  5 00000 00 0040	desc9a	pr5|0,32		p_memory_block_ptrs
000040  ia  4 00434 00 0040	desc9a	pr4|284,32	memory_block_ptrs
						STATEMENT 1 ON LINE 51
	crash_system_type = p_crash_system_type;

000041  aa  7 00004 2361 20	ldq  	pr7|4,*		p_crash_system_type
000042  ia  4 00010 7561 00	stq  	pr4|8		crash_system_type
						STATEMENT 1 ON LINE 52
	return;

000043  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO new_dbr                                            STATEMENT 1 ON LINE 54
new_dbr: entry (dbr_value, p_last_segnum, code);

000044  at     000003000006
000045  tt     000005000007
000046  ta     000044000000
000047  da     000073300000
000050  aa   000240 6270 00	eax7 	160
000051  aa  7 00034 3521 20	epp2 	pr7|28,*
000052  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000053  aa     000006000000
000054  aa     000000000000
000055  aa  6 00032 3735 20	epp7 	pr6|26,*
000056  aa  7 00006 3715 20	epp5 	pr7|6,*
000057  aa  6 00140 6515 00	spri5	pr6|96
						STATEMENT 1 ON LINE 60
	code = 0;

000060  aa  6 00140 4501 20	stz  	pr6|96,*		code
						STATEMENT 1 ON LINE 61
	dbr_info_ptr = addr (my_dbr_info);

000061  aa  6 00112 3735 00	epp7 	pr6|74		my_dbr_info
000062  aa  6 00134 6535 00	spri7	pr6|92		dbr_info_ptr
						STATEMENT 1 ON LINE 62
	ptw_info_ptr = addr (my_ptw_info);

000063  aa  6 00116 3715 00	epp5 	pr6|78		my_ptw_info
000064  aa  6 00136 6515 00	spri5	pr6|94		ptw_info_ptr
						STATEMENT 1 ON LINE 63
	call dbr_util_$dissect (addr (dbr_value), dbr_info_ptr);

000065  aa  6 00032 3535 20	epp3 	pr6|26,*
000066  aa  3 00002 3515 20	epp1 	pr3|2,*		dbr_value
000067  aa  6 00174 2515 00	spri1	pr6|124
000070  aa   001364 3520 04	epp2 	756,ic		001454 = 000004000000
000071  aa   000631 6700 04	tsp4 	409,ic		000722
						STATEMENT 1 ON LINE 64
	p_last_segnum = divide (dbr_info.bound, 2, 15) - 1;

000072  aa  6 00134 3735 20	epp7 	pr6|92,*		dbr_info_ptr
000073  aa  7 00001 2361 00	ldq  	pr7|1		dbr_info.bound
000074  aa   000002 5060 07	div  	2,dl
000075  aa   000001 1760 07	sbq  	1,dl
000076  aa  6 00032 3715 20	epp5 	pr6|26,*
000077  aa  5 00004 7561 20	stq  	pr5|4,*		p_last_segnum
						STATEMENT 1 ON LINE 65
	dseg_info.sdwi.paged = dbr_info.paged;

000100  aa  7 00003 2351 00	lda  	pr7|3		dbr_info.paged
000101  aa  6 00044 3701 20	epp4 	pr6|36,*
000102  ia  4 00431 6751 00	era  	pr4|281		dseg_info.paged
000103  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
000104  ia  4 00431 6551 00	ersa 	pr4|281		dseg_info.paged
						STATEMENT 1 ON LINE 66
	dseg_info.sdwi.address = dbr_info.address;

000105  aa  7 00000 2361 00	ldq  	pr7|0		dbr_info.address
000106  ia  4 00425 7561 00	stq  	pr4|277		dseg_info.address
						STATEMENT 1 ON LINE 70
	if dseg_info.sdwi.paged then do;

000107  ia  4 00431 2351 00	lda  	pr4|281		dseg_info.paged
000110  aa   400000 3150 03	cana 	131072,du
000111  aa   000060 6000 04	tze  	48,ic		000171
						STATEMENT 1 ON LINE 71
	     call get_absolute (dseg_info.sdwi.address - size (aste), size (aste) + divide (dbr_info.bound + 1023, 1024, 8), addr (dseg_info.sst_data), code);

000112  aa   000014 1760 07	sbq  	12,dl
000113  aa  6 00176 7561 00	stq  	pr6|126
000114  aa  7 00001 2361 00	ldq  	pr7|1		dbr_info.bound
000115  aa   001777 0760 07	adq  	1023,dl
000116  aa   002000 5060 07	div  	1024,dl
000117  aa   000014 0760 07	adq  	12,dl
000120  aa  6 00177 7561 00	stq  	pr6|127
000121  ia  4 00011 3535 00	epp3 	pr4|9		dseg_info.sst_data
000122  aa  6 00174 2535 00	spri3	pr6|124
000123  aa  6 00176 3521 00	epp2 	pr6|126
000124  aa  6 00202 2521 00	spri2	pr6|130
000125  aa  6 00177 3521 00	epp2 	pr6|127
000126  aa  6 00204 2521 00	spri2	pr6|132
000127  aa  6 00174 3521 00	epp2 	pr6|124
000130  aa  6 00206 2521 00	spri2	pr6|134
000131  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000132  aa  6 00210 2521 00	spri2	pr6|136
000133  aa  6 00200 6211 00	eax1 	pr6|128
000134  aa   020000 4310 07	fld  	8192,dl
000135  aa   000073 3520 04	epp2 	59,ic		000230 = 000240627000
000136  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 72
	     if code ^= 0 then return;

000137  aa  6 00140 2361 20	ldq  	pr6|96,*		code
000140  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 73
	     call ptw_util_$dissect (addr (dseg_info.page_table (0)), ptw_info_ptr);

000141  aa  6 00044 3701 20	epp4 	pr6|36,*
000142  ia  4 00025 3735 00	epp7 	pr4|21		dseg_info.page_table
000143  aa  6 00174 6535 00	spri7	pr6|124
000144  aa   001302 3520 04	epp2 	706,ic		001446 = 000004000000
000145  aa   000640 6700 04	tsp4 	416,ic		001005
						STATEMENT 1 ON LINE 74
	     call get_absolute (ptw_info.address, 2, addr (dseg_sdw), code);

000146  aa   000002 2360 07	ldq  	2,dl
000147  aa  6 00177 7561 00	stq  	pr6|127
000150  aa  6 00106 3735 00	epp7 	pr6|70		dseg_sdw
000151  aa  6 00174 6535 00	spri7	pr6|124
000152  aa  6 00136 3521 20	epp2 	pr6|94,*		ptw_info.address
000153  aa  6 00202 2521 00	spri2	pr6|130
000154  aa  6 00177 3521 00	epp2 	pr6|127
000155  aa  6 00204 2521 00	spri2	pr6|132
000156  aa  6 00174 3521 00	epp2 	pr6|124
000157  aa  6 00206 2521 00	spri2	pr6|134
000160  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000161  aa  6 00210 2521 00	spri2	pr6|136
000162  aa  6 00200 6211 00	eax1 	pr6|128
000163  aa   020000 4310 07	fld  	8192,dl
000164  aa   000044 3520 04	epp2 	36,ic		000230 = 000240627000
000165  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 75
	     if code ^= 0 then return;

000166  aa  6 00140 2361 20	ldq  	pr6|96,*		code
000167  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 76
	end;

000170  aa   000023 7100 04	tra  	19,ic		000213
						STATEMENT 1 ON LINE 77
	else do;

						STATEMENT 1 ON LINE 78
	     call get_absolute (dseg_info.sdwi.address, 2, addr (dseg_sdw), code);

000171  aa   000002 2360 07	ldq  	2,dl
000172  aa  6 00177 7561 00	stq  	pr6|127
000173  aa  6 00106 3535 00	epp3 	pr6|70		dseg_sdw
000174  aa  6 00174 2535 00	spri3	pr6|124
000175  ia  4 00425 3521 00	epp2 	pr4|277		dseg_info.address
000176  aa  6 00202 2521 00	spri2	pr6|130
000177  aa  6 00177 3521 00	epp2 	pr6|127
000200  aa  6 00204 2521 00	spri2	pr6|132
000201  aa  6 00174 3521 00	epp2 	pr6|124
000202  aa  6 00206 2521 00	spri2	pr6|134
000203  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000204  aa  6 00210 2521 00	spri2	pr6|136
000205  aa  6 00200 6211 00	eax1 	pr6|128
000206  aa   020000 4310 07	fld  	8192,dl
000207  aa   000021 3520 04	epp2 	17,ic		000230 = 000240627000
000210  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 79
	     if code ^= 0 then return;

000211  aa  6 00140 2361 20	ldq  	pr6|96,*		code
000212  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 80
	end;

						STATEMENT 1 ON LINE 81
	call sdw_util_$dissect (addr (dseg_sdw), addr (dseg_info.sdwi));

000213  aa  6 00106 3735 00	epp7 	pr6|70		dseg_sdw
000214  aa  6 00174 6535 00	spri7	pr6|124
000215  aa  6 00044 3701 20	epp4 	pr6|36,*
000216  ia  4 00425 3715 00	epp5 	pr4|277		dseg_info.sdwi
000217  aa  6 00212 6515 00	spri5	pr6|138
000220  aa   001220 3520 04	epp2 	656,ic		001440 = 000004000000
000221  aa   001043 6700 04	tsp4 	547,ic		001264
						STATEMENT 1 ON LINE 82
	return;

000222  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO get_absolute                                       STATEMENT 1 ON LINE 84
get_absolute: entry (p_address, p_data_length, p_data_ptr, code);

000223  at     000004000004
000224  tt     000002000001
000225  ta     000007000000
000226  ta     000223000000
000227  da     000102300000
000230  aa   000240 6270 00	eax7 	160
000231  aa  7 00034 3521 20	epp2 	pr7|28,*
000232  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000233  aa     000010000000
000234  aa     000000000000
000235  aa  6 00032 3735 20	epp7 	pr6|26,*
000236  aa  7 00002 3715 20	epp5 	pr7|2,*
000237  aa  6 00142 6515 00	spri5	pr6|98
000240  aa  7 00004 3535 20	epp3 	pr7|4,*
000241  aa  6 00144 2535 00	spri3	pr6|100
000242  aa  7 00006 3515 20	epp1 	pr7|6,*
000243  aa  6 00146 2515 00	spri1	pr6|102
000244  aa  7 00010 3715 20	epp5 	pr7|8,*
000245  aa  6 00140 6515 00	spri5	pr6|96
						STATEMENT 1 ON LINE 86
	data_length = p_data_length;

000246  aa  6 00144 2361 20	ldq  	pr6|100,*		p_data_length
000247  aa  6 00101 7561 00	stq  	pr6|65		data_length
						STATEMENT 1 ON LINE 92
	do while (data_length > 0);

000250  aa  6 00101 2361 00	ldq  	pr6|65		data_length
000251  aa   000071 6044 04	tmoz 	57,ic		000342
						STATEMENT 1 ON LINE 96
	     data_part_length = mod (p_address + data_length - 1, 1024) + 1;

000252  aa  6 00142 0761 20	adq  	pr6|98,*		p_address
000253  aa  6 00177 7561 00	stq  	pr6|127
000254  aa   000001 1760 07	sbq  	1,dl
000255  aa   001206 3520 04	epp2 	646,ic		001463 = 000000002000
000256  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000257  aa   000001 0760 07	adq  	1,dl
000260  aa  6 00102 7561 00	stq  	pr6|66		data_part_length
						STATEMENT 1 ON LINE 97
	     if data_part_length <= data_length then address = p_address + data_length - data_part_length;

000261  aa  6 00101 1161 00	cmpq 	pr6|65		data_length
000262  aa   000005 6054 04	tpnz 	5,ic		000267
000263  aa  6 00177 2361 00	ldq  	pr6|127
000264  aa  6 00102 1761 00	sbq  	pr6|66		data_part_length
000265  aa  6 00100 7561 00	stq  	pr6|64		address
000266  aa   000005 7100 04	tra  	5,ic		000273
						STATEMENT 1 ON LINE 98
	     else do;

						STATEMENT 1 ON LINE 99
		address = p_address;

000267  aa  6 00142 2361 20	ldq  	pr6|98,*		p_address
000270  aa  6 00100 7561 00	stq  	pr6|64		address
						STATEMENT 1 ON LINE 100
		data_part_length = data_length;

000271  aa  6 00101 2361 00	ldq  	pr6|65		data_length
000272  aa  6 00102 7561 00	stq  	pr6|66		data_part_length
						STATEMENT 1 ON LINE 101
	     end;

						STATEMENT 1 ON LINE 102
	     data_ptr = addrel (p_data_ptr, address - p_address);

000273  aa  6 00100 2361 00	ldq  	pr6|64		address
000274  aa  6 00142 1761 20	sbq  	pr6|98,*		p_address
000275  aa  6 00146 3515 20	epp1 	pr6|102,*		p_data_ptr
000276  aa  1 00000 3515 66	epp1 	pr1|0,*ql		p_data_ptr
000277  aa   000000 0510 03	adwp1	0,du
000300  aa  6 00104 2515 00	spri1	pr6|68		data_ptr
						STATEMENT 1 ON LINE 104
	     if address >= 512 * 1024 then do;

000301  aa  6 00100 2361 00	ldq  	pr6|64		address
000302  aa   000002 1160 03	cmpq 	2,du
000303  aa   000014 6040 04	tmi  	12,ic		000317
						STATEMENT 1 ON LINE 105
		code = error_table_$out_of_bounds;

000304  aa  6 00044 3701 20	epp4 	pr6|36,*
000305  la  4 00452 2361 20	ldq  	pr4|298,*		error_table_$out_of_bounds
000306  aa  6 00140 7561 20	stq  	pr6|96,*		code
						STATEMENT 1 ON LINE 106
		unspec (data_ptr -> data_part) = "0"b;

000307  aa  6 00102 2361 00	ldq  	pr6|66		data_part_length
000310  aa   000044 4020 07	mpy  	36,dl
000311  aa   000010 0760 07	adq  	8,dl
000312  aa   000011 5060 07	div  	9,dl
000313  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000314  aa   000000 00 0000	desc9a	0,0
000315  aa  1 00000 00 0006	desc9a	pr1|0,ql
						STATEMENT 1 ON LINE 107
	     end;

000316  aa   000021 7100 04	tra  	17,ic		000337
						STATEMENT 1 ON LINE 108
	     else do;

						STATEMENT 1 ON LINE 109
		multics_data_ptr = addrel (memory_block_ptrs (divide (address, 128 * 1024, 17) + 1), mod (address, 128 * 1024));

000317  aa   400000 5060 07	div  	131072,dl
000320  aa   000001 7360 00	qls  	1
000321  aa  6 00177 7561 00	stq  	pr6|127
000322  aa  6 00100 2361 00	ldq  	pr6|64		address
000323  aa   001137 3520 04	epp2 	607,ic		001462 = 000000400000
000324  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000325  aa  6 00177 7271 00	lxl7 	pr6|127
000326  aa  6 00044 3701 20	epp4 	pr6|36,*
000327  ia  4 00434 3535 37	epp3 	pr4|284,7*	memory_block_ptrs
000330  aa  3 00000 5075 06	awd  	pr3|0,ql
000331  aa  6 00110 2535 00	spri3	pr6|72		multics_data_ptr
						STATEMENT 1 ON LINE 110
		data_ptr -> data_part = multics_data_ptr -> data_part;

000332  aa  6 00102 2361 00	ldq  	pr6|66		data_part_length
000333  aa   000002 7360 00	qls  	2
000334  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
000335  aa  3 00000 00 0006	desc9a	pr3|0,ql		data_part
000336  aa  1 00000 00 0006	desc9a	pr1|0,ql		data_part
						STATEMENT 1 ON LINE 111
	     end;

						STATEMENT 1 ON LINE 112
	     data_length = data_length - data_part_length;

000337  aa  6 00102 3361 00	lcq  	pr6|66		data_part_length
000340  aa  6 00101 0561 00	asq  	pr6|65		data_length
						STATEMENT 1 ON LINE 113
	end;

000341  aa   777707 7100 04	tra  	-57,ic		000250
						STATEMENT 1 ON LINE 114
	return;

000342  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO new_segment                                        STATEMENT 1 ON LINE 116
new_segment: entry (desired_segnum, p_seg_info_ptr, code);

000343  at     000003000005
000344  tt     000001000007
000345  ta     000343000000
000346  da     000110300000
000347  aa   000240 6270 00	eax7 	160
000350  aa  7 00034 3521 20	epp2 	pr7|28,*
000351  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000352  aa     000006000000
000353  aa     000000000000
000354  aa  6 00032 3735 20	epp7 	pr6|26,*
000355  aa  7 00004 3715 20	epp5 	pr7|4,*
000356  aa  6 00150 6515 00	spri5	pr6|104
000357  aa  7 00006 3535 20	epp3 	pr7|6,*
000360  aa  6 00140 2535 00	spri3	pr6|96
						STATEMENT 1 ON LINE 120
	code = 0;

000361  aa  6 00140 4501 20	stz  	pr6|96,*		code
						STATEMENT 1 ON LINE 121
	seg_info_ptr = p_seg_info_ptr;

000362  aa  6 00150 3735 20	epp7 	pr6|104,*		p_seg_info_ptr
000363  aa  7 00000 3735 20	epp7 	pr7|0,*		p_seg_info_ptr
000364  aa  6 00130 6535 00	spri7	pr6|88		seg_info_ptr
						STATEMENT 1 ON LINE 126
	call get_virtual (addr (dseg_info), desired_segnum * 2, 2, addr (seg_sdw), code);

000365  aa  6 00044 3701 20	epp4 	pr6|36,*
000366  ia  4 00011 3715 00	epp5 	pr4|9		dseg_info
000367  aa  6 00212 6515 00	spri5	pr6|138
000370  aa  6 00032 3535 20	epp3 	pr6|26,*
000371  aa  3 00002 2361 20	ldq  	pr3|2,*		desired_segnum
000372  aa   000001 7360 00	qls  	1
000373  aa  6 00177 7561 00	stq  	pr6|127
000374  aa   000002 2360 07	ldq  	2,dl
000375  aa  6 00176 7561 00	stq  	pr6|126
000376  aa  6 00126 3515 00	epp1 	pr6|86		seg_sdw
000377  aa  6 00174 2515 00	spri1	pr6|124
000400  aa  6 00212 3521 00	epp2 	pr6|138
000401  aa  6 00216 2521 00	spri2	pr6|142
000402  aa  6 00177 3521 00	epp2 	pr6|127
000403  aa  6 00220 2521 00	spri2	pr6|144
000404  aa  6 00176 3521 00	epp2 	pr6|126
000405  aa  6 00222 2521 00	spri2	pr6|146
000406  aa  6 00174 3521 00	epp2 	pr6|124
000407  aa  6 00224 2521 00	spri2	pr6|148
000410  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000411  aa  6 00226 2521 00	spri2	pr6|150
000412  aa  6 00214 6211 00	eax1 	pr6|140
000413  aa   024000 4310 07	fld  	10240,dl
000414  aa   000070 3520 04	epp2 	56,ic		000504 = 000240627000
000415  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 127
	if code ^= 0 then go to bad_segment;

000416  aa  6 00140 2361 20	ldq  	pr6|96,*		code
000417  aa   000056 6010 04	tnz  	46,ic		000475
						STATEMENT 1 ON LINE 129
	call sdw_util_$dissect (addr (seg_sdw), addr (seg_info.sdwi));

000420  aa  6 00126 3735 00	epp7 	pr6|86		seg_sdw
000421  aa  6 00174 6535 00	spri7	pr6|124
000422  aa  6 00130 3715 20	epp5 	pr6|88,*		seg_info_ptr
000423  aa  5 00414 3715 00	epp5 	pr5|268		seg_info.sdwi
000424  aa  6 00212 6515 00	spri5	pr6|138
000425  aa   001013 3520 04	epp2 	523,ic		001440 = 000004000000
000426  aa   000636 6700 04	tsp4 	414,ic		001264
						STATEMENT 1 ON LINE 130
	if seg_info.sdwi.faulted then do;

000427  aa  6 00130 3735 20	epp7 	pr6|88,*		seg_info_ptr
000430  aa  7 00420 2351 00	lda  	pr7|272		seg_info.faulted
000431  aa   200000 3150 03	cana 	65536,du
000432  aa   000005 6000 04	tze  	5,ic		000437
						STATEMENT 1 ON LINE 131
	     code = error_table_$invalidsegno;

000433  aa  6 00044 3701 20	epp4 	pr6|36,*
000434  la  4 00450 2361 20	ldq  	pr4|296,*		error_table_$invalidsegno
000435  aa  6 00140 7561 20	stq  	pr6|96,*		code
						STATEMENT 1 ON LINE 132
	     go to bad_segment;

000436  aa   000037 7100 04	tra  	31,ic		000475
						STATEMENT 1 ON LINE 133
	end;

						STATEMENT 1 ON LINE 134
	if seg_info.sdwi.paged then do;

000437  aa  7 00420 2351 00	lda  	pr7|272		seg_info.paged
000440  aa   400000 3150 03	cana 	131072,du
000441  aa   000035 6000 04	tze  	29,ic		000476
						STATEMENT 1 ON LINE 135
	     call get_absolute (seg_info.sdwi.address - size (aste), size (aste) + divide (seg_info.sdwi.size + 1023, 1024, 8), addr (seg_info.sst_data), code);

000442  aa  7 00414 2361 00	ldq  	pr7|268		seg_info.address
000443  aa   000014 1760 07	sbq  	12,dl
000444  aa  6 00176 7561 00	stq  	pr6|126
000445  aa  7 00415 2361 00	ldq  	pr7|269		seg_info.size
000446  aa   001777 0760 07	adq  	1023,dl
000447  aa   002000 5060 07	div  	1024,dl
000450  aa   000014 0760 07	adq  	12,dl
000451  aa  6 00177 7561 00	stq  	pr6|127
000452  aa  7 00000 3715 00	epp5 	pr7|0		seg_info.sst_data
000453  aa  6 00212 6515 00	spri5	pr6|138
000454  aa  6 00176 3521 00	epp2 	pr6|126
000455  aa  6 00202 2521 00	spri2	pr6|130
000456  aa  6 00177 3521 00	epp2 	pr6|127
000457  aa  6 00204 2521 00	spri2	pr6|132
000460  aa  6 00212 3521 00	epp2 	pr6|138
000461  aa  6 00206 2521 00	spri2	pr6|134
000462  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000463  aa  6 00210 2521 00	spri2	pr6|136
000464  aa  6 00200 6211 00	eax1 	pr6|128
000465  aa   020000 4310 07	fld  	8192,dl
000466  aa   777542 3520 04	epp2 	-158,ic		000230 = 000240627000
000467  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 136
	     if code ^= 0 then do;

000470  aa  6 00140 2361 20	ldq  	pr6|96,*		code
000471  aa   000005 6000 04	tze  	5,ic		000476
						STATEMENT 1 ON LINE 137
		seg_info.sdwi.faulted = "1"b;

000472  aa   200000 2350 03	lda  	65536,du
000473  aa  6 00130 3735 20	epp7 	pr6|88,*		seg_info_ptr
000474  aa  7 00420 2551 00	orsa 	pr7|272		seg_info.faulted
						STATEMENT 1 ON LINE 138
bad_segment:	return;

000475  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 139
	     end;

						STATEMENT 1 ON LINE 140
	end;

						STATEMENT 1 ON LINE 141
	return;

000476  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO get_virtual                                        STATEMENT 1 ON LINE 143
get_virtual: entry (p_seg_info_ptr, p_address, p_data_length, p_data_ptr, code);

000477  at     000005000001
000500  tt     000004000002
000501  tt     000001000007
000502  ta     000477000000
000503  da     000116300000
000504  aa   000240 6270 00	eax7 	160
000505  aa  7 00034 3521 20	epp2 	pr7|28,*
000506  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000507  aa     000012000000
000510  aa     000000000000
000511  aa  6 00032 3735 20	epp7 	pr6|26,*
000512  aa  7 00002 3715 20	epp5 	pr7|2,*
000513  aa  6 00150 6515 00	spri5	pr6|104
000514  aa  7 00004 3535 20	epp3 	pr7|4,*
000515  aa  6 00142 2535 00	spri3	pr6|98
000516  aa  7 00006 3515 20	epp1 	pr7|6,*
000517  aa  6 00144 2515 00	spri1	pr6|100
000520  aa  7 00010 3715 20	epp5 	pr7|8,*
000521  aa  6 00146 6515 00	spri5	pr6|102
000522  aa  7 00012 3535 20	epp3 	pr7|10,*
000523  aa  6 00140 2535 00	spri3	pr6|96
						STATEMENT 1 ON LINE 147
	code = 0;

000524  aa  6 00140 4501 20	stz  	pr6|96,*		code
						STATEMENT 1 ON LINE 148
	seg_info_ptr = p_seg_info_ptr;

000525  aa  6 00150 3735 20	epp7 	pr6|104,*		p_seg_info_ptr
000526  aa  7 00000 3735 20	epp7 	pr7|0,*		p_seg_info_ptr
000527  aa  6 00130 6535 00	spri7	pr6|88		seg_info_ptr
						STATEMENT 1 ON LINE 149
	ptw_info_ptr = addr (my_ptw_info);

000530  aa  6 00116 3715 00	epp5 	pr6|78		my_ptw_info
000531  aa  6 00136 6515 00	spri5	pr6|94		ptw_info_ptr
						STATEMENT 1 ON LINE 151
	data_length = p_data_length;

000532  aa  6 00144 2361 20	ldq  	pr6|100,*		p_data_length
000533  aa  6 00101 7561 00	stq  	pr6|65		data_length
						STATEMENT 1 ON LINE 152
	if p_address + p_data_length > seg_info.sdwi.size then do;

000534  aa  6 00142 0761 20	adq  	pr6|98,*		p_address
000535  aa  7 00415 1161 00	cmpq 	pr7|269		seg_info.size
000536  aa   000027 6044 04	tmoz 	23,ic		000565
						STATEMENT 1 ON LINE 153
	     data_part_length = p_address + data_length - seg_info.sdwi.size;

000537  aa  6 00142 2361 20	ldq  	pr6|98,*		p_address
000540  aa  6 00101 0761 00	adq  	pr6|65		data_length
000541  aa  7 00415 1761 00	sbq  	pr7|269		seg_info.size
000542  aa  6 00102 7561 00	stq  	pr6|66		data_part_length
						STATEMENT 1 ON LINE 154
	     data_ptr = addrel (p_data_ptr, data_length - data_part_length);

000543  aa  6 00101 2361 00	ldq  	pr6|65		data_length
000544  aa  6 00102 1761 00	sbq  	pr6|66		data_part_length
000545  aa  6 00146 3521 20	epp2 	pr6|102,*		p_data_ptr
000546  aa  2 00000 3521 66	epp2 	pr2|0,*ql		p_data_ptr
000547  aa   000000 0520 03	adwp2	0,du
000550  aa  6 00104 2521 00	spri2	pr6|68		data_ptr
						STATEMENT 1 ON LINE 155
	     unspec (data_ptr -> data_part) = "0"b;

000551  aa  6 00102 2361 00	ldq  	pr6|66		data_part_length
000552  aa   000044 4020 07	mpy  	36,dl
000553  aa   000010 0760 07	adq  	8,dl
000554  aa   000011 5060 07	div  	9,dl
000555  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000556  aa   000000 00 0000	desc9a	0,0
000557  aa  2 00000 00 0006	desc9a	pr2|0,ql
						STATEMENT 1 ON LINE 156
	     code = error_table_$boundviol;

000560  aa  6 00044 3701 20	epp4 	pr6|36,*
000561  la  4 00446 2361 20	ldq  	pr4|294,*		error_table_$boundviol
000562  aa  6 00140 7561 20	stq  	pr6|96,*		code
						STATEMENT 1 ON LINE 157
	     data_length = data_length - data_part_length;

000563  aa  6 00102 3361 00	lcq  	pr6|66		data_part_length
000564  aa  6 00101 0561 00	asq  	pr6|65		data_length
						STATEMENT 1 ON LINE 158
	end;

						STATEMENT 1 ON LINE 159
	if seg_info.sdwi.paged then do;

000565  aa  7 00420 2351 00	lda  	pr7|272		seg_info.paged
000566  aa   400000 3150 03	cana 	131072,du
000567  aa   000113 6000 04	tze  	75,ic		000702
						STATEMENT 1 ON LINE 160
	     do while (data_length > 0);

000570  aa  6 00101 2361 00	ldq  	pr6|65		data_length
000571  aa   000130 6044 04	tmoz 	88,ic		000721
						STATEMENT 1 ON LINE 161
		data_part_length = mod (p_address + data_length - 1, 1024) + 1;

000572  aa  6 00142 0761 20	adq  	pr6|98,*		p_address
000573  aa  6 00177 7561 00	stq  	pr6|127
000574  aa   000001 1760 07	sbq  	1,dl
000575  aa   000666 3520 04	epp2 	438,ic		001463 = 000000002000
000576  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000577  aa   000001 0760 07	adq  	1,dl
000600  aa  6 00102 7561 00	stq  	pr6|66		data_part_length
						STATEMENT 1 ON LINE 162
		if data_part_length <= data_length then address = p_address + data_length - data_part_length;

000601  aa  6 00101 1161 00	cmpq 	pr6|65		data_length
000602  aa   000005 6054 04	tpnz 	5,ic		000607
000603  aa  6 00177 2361 00	ldq  	pr6|127
000604  aa  6 00102 1761 00	sbq  	pr6|66		data_part_length
000605  aa  6 00100 7561 00	stq  	pr6|64		address
000606  aa   000005 7100 04	tra  	5,ic		000613
						STATEMENT 1 ON LINE 163
		else do;

						STATEMENT 1 ON LINE 164
		     address = p_address;

000607  aa  6 00142 2361 20	ldq  	pr6|98,*		p_address
000610  aa  6 00100 7561 00	stq  	pr6|64		address
						STATEMENT 1 ON LINE 165
		     data_part_length = data_length;

000611  aa  6 00101 2361 00	ldq  	pr6|65		data_length
000612  aa  6 00102 7561 00	stq  	pr6|66		data_part_length
						STATEMENT 1 ON LINE 166
		end;

						STATEMENT 1 ON LINE 167
		data_ptr = addrel (p_data_ptr, address - p_address);

000613  aa  6 00100 2361 00	ldq  	pr6|64		address
000614  aa  6 00142 1761 20	sbq  	pr6|98,*		p_address
000615  aa  6 00146 3515 20	epp1 	pr6|102,*		p_data_ptr
000616  aa  1 00000 3515 66	epp1 	pr1|0,*ql		p_data_ptr
000617  aa   000000 0510 03	adwp1	0,du
000620  aa  6 00104 2515 00	spri1	pr6|68		data_ptr
						STATEMENT 1 ON LINE 168
		page_num = divide (address, 1024, 8);

000621  aa  6 00100 2361 00	ldq  	pr6|64		address
000622  aa  2 00000 5061 00	div  	pr2|0
000623  aa  6 00120 7561 00	stq  	pr6|80		page_num
						STATEMENT 1 ON LINE 169
		page_offset = mod (address, 1024);

000624  aa  6 00100 2361 00	ldq  	pr6|64		address
000625  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000626  aa  6 00121 7561 00	stq  	pr6|81		page_offset
						STATEMENT 1 ON LINE 174
		call ptw_util_$dissect (addr (seg_info.page_table (page_num)), ptw_info_ptr);

000627  aa  6 00120 7271 00	lxl7 	pr6|80		page_num
000630  aa  6 00130 3735 20	epp7 	pr6|88,*		seg_info_ptr
000631  aa  7 00014 3735 17	epp7 	pr7|12,7		seg_info.page_table
000632  aa  6 00212 6535 00	spri7	pr6|138
000633  aa   000577 3520 04	epp2 	383,ic		001432 = 000004000000
000634  aa   000151 6700 04	tsp4 	105,ic		001005
						STATEMENT 1 ON LINE 175
		if ptw_info.valid then		/* properly in memory */
		     call get_absolute (ptw_info.address + page_offset, data_part_length, data_ptr, code);

000635  aa  6 00136 3735 20	epp7 	pr6|94,*		ptw_info_ptr
000636  aa  7 00001 2351 00	lda  	pr7|1		ptw_info.valid
000637  aa   000200 3150 03	cana 	128,du
000640  aa   000021 6000 04	tze  	17,ic		000661
000641  aa  7 00000 2361 00	ldq  	pr7|0		ptw_info.address
000642  aa  6 00121 0761 00	adq  	pr6|81		page_offset
000643  aa  6 00177 7561 00	stq  	pr6|127
000644  aa  6 00177 3521 00	epp2 	pr6|127
000645  aa  6 00202 2521 00	spri2	pr6|130
000646  aa  6 00102 3521 00	epp2 	pr6|66		data_part_length
000647  aa  6 00204 2521 00	spri2	pr6|132
000650  aa  6 00104 3521 00	epp2 	pr6|68		data_ptr
000651  aa  6 00206 2521 00	spri2	pr6|134
000652  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000653  aa  6 00210 2521 00	spri2	pr6|136
000654  aa  6 00200 6211 00	eax1 	pr6|128
000655  aa   020000 4310 07	fld  	8192,dl
000656  aa   777352 3520 04	epp2 	-278,ic		000230 = 000240627000
000657  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
000660  aa   000016 7100 04	tra  	14,ic		000676
						STATEMENT 1 ON LINE 177
		else do;

						STATEMENT 1 ON LINE 178
bad_page:		     unspec (data_ptr -> data_part) = "0"b;

000661  aa  6 00102 2361 00	ldq  	pr6|66		data_part_length
000662  aa   000044 4020 07	mpy  	36,dl
000663  aa   000010 0760 07	adq  	8,dl
000664  aa   000011 5060 07	div  	9,dl
000665  aa  6 00104 3715 20	epp5 	pr6|68,*		data_ptr
000666  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000667  aa   000000 00 0000	desc9a	0,0
000670  aa  5 00000 00 0006	desc9a	pr5|0,ql
						STATEMENT 1 ON LINE 179
		     if code = 0 then code = error_table_$argerr;

000671  aa  6 00140 2361 20	ldq  	pr6|96,*		code
000672  aa   000004 6010 04	tnz  	4,ic		000676
000673  aa  6 00044 3701 20	epp4 	pr6|36,*
000674  la  4 00444 2361 20	ldq  	pr4|292,*		error_table_$argerr
000675  aa  6 00140 7561 20	stq  	pr6|96,*		code
						STATEMENT 1 ON LINE 180
		end;

						STATEMENT 1 ON LINE 181
		data_length = data_length - data_part_length;

000676  aa  6 00102 3361 00	lcq  	pr6|66		data_part_length
000677  aa  6 00101 0561 00	asq  	pr6|65		data_length
						STATEMENT 1 ON LINE 182
	     end;

000700  aa   777670 7100 04	tra  	-72,ic		000570
						STATEMENT 1 ON LINE 183
	end;

000701  aa   000020 7100 04	tra  	16,ic		000721
						STATEMENT 1 ON LINE 184
	else do;

						STATEMENT 1 ON LINE 185
	     address = seg_info.sdwi.address + p_address;

000702  aa  7 00414 2361 00	ldq  	pr7|268		seg_info.address
000703  aa  6 00142 0761 20	adq  	pr6|98,*		p_address
000704  aa  6 00100 7561 00	stq  	pr6|64		address
						STATEMENT 1 ON LINE 186
	     call get_absolute (address, p_data_length, p_data_ptr, code);

000705  aa  6 00100 3521 00	epp2 	pr6|64		address
000706  aa  6 00202 2521 00	spri2	pr6|130
000707  aa  6 00144 3521 20	epp2 	pr6|100,*		p_data_length
000710  aa  6 00204 2521 00	spri2	pr6|132
000711  aa  6 00146 3521 20	epp2 	pr6|102,*		p_data_ptr
000712  aa  6 00206 2521 00	spri2	pr6|134
000713  aa  6 00140 3521 20	epp2 	pr6|96,*		code
000714  aa  6 00210 2521 00	spri2	pr6|136
000715  aa  6 00200 6211 00	eax1 	pr6|128
000716  aa   020000 4310 07	fld  	8192,dl
000717  aa   777311 3520 04	epp2 	-311,ic		000230 = 000240627000
000720  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 187
	end;

						STATEMENT 1 ON LINE 188
	return;

000721  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 309
     end;

BEGIN PROCEDURE dbr_util_$dissect
ENTRY TO dbr_util_$dissect                                  STATEMENT 1 ON LINE 194
dbr_util_$dissect: proc (dbr_ptr, p_dbr_info_ptr);

000722  aa  6 00152 6501 00	spri4	pr6|106
000723  aa  6 00154 2521 00	spri2	pr6|108
						STATEMENT 1 ON LINE 202
	dbr_info_ptr = p_dbr_info_ptr;

000724  aa  2 00004 3735 20	epp7 	pr2|4,*		p_dbr_info_ptr
000725  aa  7 00000 3735 20	epp7 	pr7|0,*		p_dbr_info_ptr
000726  aa  6 00134 6535 00	spri7	pr6|92		dbr_info_ptr
						STATEMENT 1 ON LINE 203
	if crash_system_type = ADP_SYSTEM then do;

000727  aa  6 00044 3701 20	epp4 	pr6|36,*
000730  ia  4 00010 2361 00	ldq  	pr4|8		crash_system_type
000731  aa   000002 1160 07	cmpq 	2,dl
000732  aa   000026 6010 04	tnz  	22,ic		000760
						STATEMENT 1 ON LINE 204
	     dbr_info.address = bin (dbr_ptr -> adp_dbr.add, 26);

000733  aa  2 00002 3715 20	epp5 	pr2|2,*		dbr_ptr
000734  aa  5 00000 2351 20	lda  	pr5|0,*		adp_dbr.add
000735  aa   000056 7730 00	lrl  	46
000736  aa  7 00000 7561 00	stq  	pr7|0		dbr_info.address
						STATEMENT 1 ON LINE 205
	     dbr_info.bound = (bin (dbr_ptr -> adp_dbr.bound, 14) + 1) * 16;

000737  aa  5 00000 3535 20	epp3 	pr5|0,*		dbr_ptr
000740  aa  3 00001 2351 00	lda  	pr3|1		adp_dbr.bound
000741  aa   000072 7730 00	lrl  	58
000742  aa   000001 0760 07	adq  	1,dl
000743  aa   000004 7360 00	qls  	4
000744  aa  7 00001 7561 00	stq  	pr7|1		dbr_info.bound
						STATEMENT 1 ON LINE 206
	     dbr_info.stack_base_segnum = dbr_ptr -> adp_dbr.stack_base_segno * 8;

000745  aa  3 00001 2351 00	lda  	pr3|1		adp_dbr.stack_base_segno
000746  aa   000020 7350 00	als  	16
000747  aa   000072 7730 00	lrl  	58
000750  aa   000003 7360 00	qls  	3
000751  aa  7 00002 7561 00	stq  	pr7|2		dbr_info.stack_base_segnum
						STATEMENT 1 ON LINE 207
	     dbr_info.paged = ^ dbr_ptr -> adp_dbr.unpaged;

000752  aa  3 00001 2351 00	lda  	pr3|1		adp_dbr.unpaged
000753  aa   000042 7350 00	als  	34
000754  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000755  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000756  aa  7 00003 7551 00	sta  	pr7|3		dbr_info.paged
						STATEMENT 1 ON LINE 208
	end;

000757  aa   000025 7100 04	tra  	21,ic		001004
						STATEMENT 1 ON LINE 209
	else do;

						STATEMENT 1 ON LINE 210
	     dbr_info.address = bin (dbr_ptr -> l68_dbr.add, 24);

000760  aa  2 00002 3715 20	epp5 	pr2|2,*		dbr_ptr
000761  aa  5 00000 2351 20	lda  	pr5|0,*		l68_dbr.add
000762  aa   000060 7730 00	lrl  	48
000763  aa  7 00000 7561 00	stq  	pr7|0		dbr_info.address
						STATEMENT 1 ON LINE 211
	     dbr_info.bound = (bin (dbr_ptr -> l68_dbr.bound, 14) + 1) * 16;

000764  aa  5 00000 3535 20	epp3 	pr5|0,*		dbr_ptr
000765  aa  3 00001 2351 00	lda  	pr3|1		l68_dbr.bound
000766  aa   000001 7350 00	als  	1
000767  aa   000072 7730 00	lrl  	58
000770  aa   000001 0760 07	adq  	1,dl
000771  aa   000004 7360 00	qls  	4
000772  aa  7 00001 7561 00	stq  	pr7|1		dbr_info.bound
						STATEMENT 1 ON LINE 212
	     dbr_info.stack_base_segnum = dbr_ptr -> l68_dbr.stack_base_segno * 8;

000773  aa  3 00001 2361 00	ldq  	pr3|1		l68_dbr.stack_base_segno
000774  aa  0 00404 3771 00	anaq 	pr0|260		= 000000000000 000000037777
000775  aa   000003 7360 00	qls  	3
000776  aa  7 00002 7561 00	stq  	pr7|2		dbr_info.stack_base_segnum
						STATEMENT 1 ON LINE 213
	     dbr_info.paged = ^ dbr_ptr -> l68_dbr.unpaged;

000777  aa  3 00001 2351 00	lda  	pr3|1		l68_dbr.unpaged
001000  aa   000023 7350 00	als  	19
001001  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001002  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001003  aa  7 00003 7551 00	sta  	pr7|3		dbr_info.paged
						STATEMENT 1 ON LINE 214
	end;

						STATEMENT 1 ON LINE 215
	return;

001004  aa  6 00152 6101 00	rtcd 	pr6|106
						STATEMENT 1 ON LINE 216
     end;

  END PROCEDURE dbr_util_$dissect
BEGIN PROCEDURE ptw_util_$dissect
ENTRY TO ptw_util_$dissect                                  STATEMENT 1 ON LINE 218
ptw_util_$dissect: proc (P_ptw_ptr, P_ptw_info_ptr);

001005  aa  6 00160 6501 00	spri4	pr6|112
001006  aa  6 00162 2521 00	spri2	pr6|114
						STATEMENT 1 ON LINE 223
	ptp = P_ptw_ptr;

001007  aa  2 00002 3735 20	epp7 	pr2|2,*		P_ptw_ptr
001010  aa  7 00000 3735 20	epp7 	pr7|0,*		P_ptw_ptr
001011  aa  6 00122 6535 00	spri7	pr6|82		ptp
						STATEMENT 1 ON LINE 224
	ptw_info_ptr = P_ptw_info_ptr;

001012  aa  2 00004 3715 20	epp5 	pr2|4,*		P_ptw_info_ptr
001013  aa  5 00000 3715 20	epp5 	pr5|0,*		P_ptw_info_ptr
001014  aa  6 00136 6515 00	spri5	pr6|94		ptw_info_ptr
						STATEMENT 1 ON LINE 225
	if crash_system_type = ADP_SYSTEM then do;

001015  aa  6 00044 3701 20	epp4 	pr6|36,*
001016  ia  4 00010 2361 00	ldq  	pr4|8		crash_system_type
001017  aa   000002 1160 07	cmpq 	2,dl
001020  aa   000123 6010 04	tnz  	83,ic		001143
						STATEMENT 1 ON LINE 226
	     if adp_ptw.add_type = add_type.core then do;

001021  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.add_type
001022  aa   000022 7350 00	als  	18
001023  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001024  aa  6 00230 7551 00	sta  	pr6|152		adp_ptw.add_type
001025  aa   776753 2350 04	lda  	-533,ic		000000 = 410207600000
001026  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001027  aa  6 00230 1151 00	cmpa 	pr6|152		adp_ptw.add_type
001030  aa   000011 6010 04	tnz  	9,ic		001041
						STATEMENT 1 ON LINE 227
		ptw_info.address = adp_core_ptw.frame * 1024;

001031  aa  7 00000 2351 00	lda  	pr7|0		adp_core_ptw.frame
001032  aa   000002 7350 00	als  	2
001033  aa   000070 7730 00	lrl  	56
001034  aa   000012 7360 00	qls  	10
001035  aa  5 00000 7561 00	stq  	pr5|0		ptw_info.address
						STATEMENT 1 ON LINE 228
		ptw_info.null_disk = "0"b;

001036  aa   000372 2350 04	lda  	250,ic		001430 = 757777777777
001037  aa  5 00001 3551 00	ansa 	pr5|1		ptw_info.null_disk
						STATEMENT 1 ON LINE 229
	     end;

001040  aa   000025 7100 04	tra  	21,ic		001065
						STATEMENT 1 ON LINE 230
	     else if adp_ptw.add_type = add_type.disk then do;

001041  aa   776737 2350 04	lda  	-545,ic		000000 = 410207600000
001042  aa   000004 7350 00	als  	4
001043  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001044  aa  6 00230 1151 00	cmpa 	pr6|152		adp_ptw.add_type
001045  aa   000013 6010 04	tnz  	11,ic		001060
						STATEMENT 1 ON LINE 231
		ptw_info.address = bin (substr (adp_ptw.add, 2, 17), 17);

001046  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.add
001047  aa   000001 7350 00	als  	1
001050  aa   000067 7730 00	lrl  	55
001051  aa  5 00000 7561 00	stq  	pr5|0		ptw_info.address
						STATEMENT 1 ON LINE 232
		ptw_info.null_disk = substr (adp_ptw.add, 1, 1);

001052  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.add
001053  aa   000004 7710 00	arl  	4
001054  aa  5 00001 6751 00	era  	pr5|1		ptw_info.null_disk
001055  aa   020000 3750 03	ana  	8192,du
001056  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.null_disk
						STATEMENT 1 ON LINE 233
	     end;

001057  aa   000006 7100 04	tra  	6,ic		001065
						STATEMENT 1 ON LINE 234
	     else do;

						STATEMENT 1 ON LINE 235
		ptw_info.address = bin (adp_ptw.add, 18);

001060  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.add
001061  aa   000066 7730 00	lrl  	54
001062  aa  5 00000 7561 00	stq  	pr5|0		ptw_info.address
						STATEMENT 1 ON LINE 236
		ptw_info.null_disk = "0"b;

001063  aa   000345 2350 04	lda  	229,ic		001430 = 757777777777
001064  aa  5 00001 3551 00	ansa 	pr5|1		ptw_info.null_disk
						STATEMENT 1 ON LINE 237
	     end;

						STATEMENT 1 ON LINE 238
	     ptw_info = adp_ptw.flags, by name;

001065  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.add_type
001066  aa   000022 7350 00	als  	18
001067  aa  5 00001 6751 00	era  	pr5|1		ptw_info.add_type
001070  aa  0 00010 3751 00	ana  	pr0|8		= 740000000000
001071  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.add_type
001072  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.er
001073  aa   000021 7350 00	als  	17
001074  aa  5 00001 6751 00	era  	pr5|1		ptw_info.er
001075  aa   010000 3750 03	ana  	4096,du
001076  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.er
001077  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.wired
001100  aa   000021 7350 00	als  	17
001101  aa  5 00001 6751 00	era  	pr5|1		ptw_info.wired
001102  aa   004000 3750 03	ana  	2048,du
001103  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.wired
001104  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.os
001105  aa   000021 7350 00	als  	17
001106  aa  5 00001 6751 00	era  	pr5|1		ptw_info.os
001107  aa   002000 3750 03	ana  	1024,du
001110  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.os
001111  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.phu1
001112  aa   000021 7350 00	als  	17
001113  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phu1
001114  aa   001000 3750 03	ana  	512,du
001115  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phu1
001116  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.phm1
001117  aa   000021 7350 00	als  	17
001120  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phm1
001121  aa   000400 3750 03	ana  	256,du
001122  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phm1
001123  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.valid
001124  aa   000024 7350 00	als  	20
001125  aa  5 00001 6751 00	era  	pr5|1		ptw_info.valid
001126  aa   000200 3750 03	ana  	128,du
001127  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.valid
001130  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.phm
001131  aa   000026 7350 00	als  	22
001132  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phm
001133  aa   000040 3750 03	ana  	32,du
001134  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phm
001135  aa  7 00000 2351 00	lda  	pr7|0		adp_ptw.phu
001136  aa   000030 7350 00	als  	24
001137  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phu
001140  aa   000100 3750 03	ana  	64,du
001141  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phu
						STATEMENT 1 ON LINE 239
	end;

001142  aa   000121 7100 04	tra  	81,ic		001263
						STATEMENT 1 ON LINE 240
	else do;

						STATEMENT 1 ON LINE 241
	     if l68_ptw.add_type = add_type.core then do;

001143  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.add_type
001144  aa   000022 7350 00	als  	18
001145  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001146  aa  6 00230 7551 00	sta  	pr6|152		l68_ptw.add_type
001147  aa   776631 2350 04	lda  	-615,ic		000000 = 410207600000
001150  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001151  aa  6 00230 1151 00	cmpa 	pr6|152		l68_ptw.add_type
001152  aa   000010 6010 04	tnz  	8,ic		001162
						STATEMENT 1 ON LINE 242
		ptw_info.address = l68_core_ptw.frame * 1024;

001153  aa  7 00000 2351 00	lda  	pr7|0		l68_core_ptw.frame
001154  aa   000072 7730 00	lrl  	58
001155  aa   000012 7360 00	qls  	10
001156  aa  5 00000 7561 00	stq  	pr5|0		ptw_info.address
						STATEMENT 1 ON LINE 243
		ptw_info.null_disk = "0"b;

001157  aa   000251 2350 04	lda  	169,ic		001430 = 757777777777
001160  aa  5 00001 3551 00	ansa 	pr5|1		ptw_info.null_disk
						STATEMENT 1 ON LINE 244
	     end;

001161  aa   000025 7100 04	tra  	21,ic		001206
						STATEMENT 1 ON LINE 245
	     else if l68_ptw.add_type = add_type.disk then do;

001162  aa   776616 2350 04	lda  	-626,ic		000000 = 410207600000
001163  aa   000004 7350 00	als  	4
001164  aa  0 00010 3771 00	anaq 	pr0|8		= 740000000000 000000000000
001165  aa  6 00230 1151 00	cmpa 	pr6|152		l68_ptw.add_type
001166  aa   000013 6010 04	tnz  	11,ic		001201
						STATEMENT 1 ON LINE 246
		ptw_info.address = bin (substr (l68_ptw.add, 2, 17), 17);

001167  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.add
001170  aa   000001 7350 00	als  	1
001171  aa   000067 7730 00	lrl  	55
001172  aa  5 00000 7561 00	stq  	pr5|0		ptw_info.address
						STATEMENT 1 ON LINE 247
		ptw_info.null_disk = substr (l68_ptw.add, 1, 1);

001173  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.add
001174  aa   000004 7710 00	arl  	4
001175  aa  5 00001 6751 00	era  	pr5|1		ptw_info.null_disk
001176  aa   020000 3750 03	ana  	8192,du
001177  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.null_disk
						STATEMENT 1 ON LINE 248
	     end;

001200  aa   000006 7100 04	tra  	6,ic		001206
						STATEMENT 1 ON LINE 249
	     else do;

						STATEMENT 1 ON LINE 250
		ptw_info.address = bin (l68_ptw.add, 18);

001201  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.add
001202  aa   000066 7730 00	lrl  	54
001203  aa  5 00000 7561 00	stq  	pr5|0		ptw_info.address
						STATEMENT 1 ON LINE 251
		ptw_info.null_disk = "0"b;

001204  aa   000224 2350 04	lda  	148,ic		001430 = 757777777777
001205  aa  5 00001 3551 00	ansa 	pr5|1		ptw_info.null_disk
						STATEMENT 1 ON LINE 252
	     end;

						STATEMENT 1 ON LINE 253
	     ptw_info = l68_ptw.flags, by name;

001206  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.add_type
001207  aa   000022 7350 00	als  	18
001210  aa  5 00001 6751 00	era  	pr5|1		ptw_info.add_type
001211  aa  0 00010 3751 00	ana  	pr0|8		= 740000000000
001212  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.add_type
001213  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.er
001214  aa   000022 7350 00	als  	18
001215  aa  5 00001 6751 00	era  	pr5|1		ptw_info.er
001216  aa   010000 3750 03	ana  	4096,du
001217  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.er
001220  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.phu
001221  aa   000017 7350 00	als  	15
001222  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phu
001223  aa   000100 3750 03	ana  	64,du
001224  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phu
001225  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.phm1
001226  aa   000022 7350 00	als  	18
001227  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phm1
001230  aa   000400 3750 03	ana  	256,du
001231  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phm1
001232  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.phm
001233  aa   000021 7350 00	als  	17
001234  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phm
001235  aa   000040 3750 03	ana  	32,du
001236  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phm
001237  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.phu1
001240  aa   000026 7350 00	als  	22
001241  aa  5 00001 6751 00	era  	pr5|1		ptw_info.phu1
001242  aa   001000 3750 03	ana  	512,du
001243  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.phu1
001244  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.wired
001245  aa   000031 7350 00	als  	25
001246  aa  5 00001 6751 00	era  	pr5|1		ptw_info.wired
001247  aa   004000 3750 03	ana  	2048,du
001250  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.wired
001251  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.os
001252  aa   000031 7350 00	als  	25
001253  aa  5 00001 6751 00	era  	pr5|1		ptw_info.os
001254  aa   002000 3750 03	ana  	1024,du
001255  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.os
001256  aa  7 00000 2351 00	lda  	pr7|0		l68_ptw.valid
001257  aa   000027 7350 00	als  	23
001260  aa  5 00001 6751 00	era  	pr5|1		ptw_info.valid
001261  aa   000200 3750 03	ana  	128,du
001262  aa  5 00001 6551 00	ersa 	pr5|1		ptw_info.valid
						STATEMENT 1 ON LINE 254
	end;

						STATEMENT 1 ON LINE 255
	return;

001263  aa  6 00160 6101 00	rtcd 	pr6|112
						STATEMENT 1 ON LINE 256
     end;

  END PROCEDURE ptw_util_$dissect
BEGIN PROCEDURE sdw_util_$dissect
ENTRY TO sdw_util_$dissect                                  STATEMENT 1 ON LINE 258
sdw_util_$dissect: proc (P_sdw_ptr, P_sdw_info_ptr);

001264  aa  6 00166 6501 00	spri4	pr6|118
001265  aa  6 00170 2521 00	spri2	pr6|120
						STATEMENT 1 ON LINE 263
	sdwp = P_sdw_ptr;

001266  aa  2 00002 3735 20	epp7 	pr2|2,*		P_sdw_ptr
001267  aa  7 00000 3735 20	epp7 	pr7|0,*		P_sdw_ptr
001270  aa  6 00124 6535 00	spri7	pr6|84		sdwp
						STATEMENT 1 ON LINE 264
	sdw_info_ptr = P_sdw_info_ptr;

001271  aa  2 00004 3715 20	epp5 	pr2|4,*		P_sdw_info_ptr
001272  aa  5 00000 3715 20	epp5 	pr5|0,*		P_sdw_info_ptr
001273  aa  6 00132 6515 00	spri5	pr6|90		sdw_info_ptr
						STATEMENT 1 ON LINE 265
	unspec (sdw_info) = ""b;

001274  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001275  aa   000000 00 0000	desc9a	0,0
001276  aa  5 00000 00 0030	desc9a	pr5|0,24
						STATEMENT 1 ON LINE 267
	if crash_system_type = ADP_SYSTEM then do;

001277  aa  6 00044 3701 20	epp4 	pr6|36,*
001300  ia  4 00010 2361 00	ldq  	pr4|8		crash_system_type
001301  aa   000002 1160 07	cmpq 	2,dl
001302  aa   000051 6010 04	tnz  	41,ic		001353
						STATEMENT 1 ON LINE 268
	     string (sdw_info.access) = string (adp_sdw.access);

001303  aa  7 00001 2351 00	lda  	pr7|1
001304  aa   000036 7350 00	als  	30
001305  aa  5 00002 6751 00	era  	pr5|2
001306  aa  0 00010 3751 00	ana  	pr0|8		= 740000000000
001307  aa  5 00002 6551 00	ersa 	pr5|2
						STATEMENT 1 ON LINE 269
	     string (sdw_info.rings) = string (adp_sdw.rings);

001310  aa  7 00000 2351 00	lda  	pr7|0
001311  aa   000033 7350 00	als  	27
001312  aa  5 00003 5511 40	stba 	pr5|3,40
						STATEMENT 1 ON LINE 271
	     sdw_info.faulted = ^adp_sdw.valid;

001313  aa  7 00000 2351 00	lda  	pr7|0		adp_sdw.valid
001314  aa   000032 7350 00	als  	26
001315  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001316  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001317  aa   000001 7710 00	arl  	1
001320  aa  5 00004 6751 00	era  	pr5|4		sdw_info.faulted
001321  aa   200000 3750 03	ana  	65536,du
001322  aa  5 00004 6551 00	ersa 	pr5|4		sdw_info.faulted
						STATEMENT 1 ON LINE 272
	     sdw_info.paged = ^adp_sdw.unpaged;

001323  aa  7 00001 2351 00	lda  	pr7|1		adp_sdw.unpaged
001324  aa   000042 7350 00	als  	34
001325  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001326  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001327  aa  5 00004 6751 00	era  	pr5|4		sdw_info.paged
001330  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
001331  aa  5 00004 6551 00	ersa 	pr5|4		sdw_info.paged
						STATEMENT 1 ON LINE 274
	     if ^adp_sdw.not_a_gate then		/* Copy the entry bound, if interesting */
		sdw_info.gate_entry_bound = 1 + binary (adp_sdw.entry_bound, 14);

001332  aa  7 00001 2351 00	lda  	pr7|1		adp_sdw.not_a_gate
001333  aa   000001 3150 07	cana 	1,dl
001334  aa   000006 6010 04	tnz  	6,ic		001342
001335  aa  7 00001 2351 00	lda  	pr7|1		adp_sdw.entry_bound
001336  aa   000020 7350 00	als  	16
001337  aa   000072 7730 00	lrl  	58
001340  aa   000001 0760 07	adq  	1,dl
001341  aa  5 00005 7561 00	stq  	pr5|5		sdw_info.gate_entry_bound
						STATEMENT 1 ON LINE 277
	     sdw_info.size = 16 + 16 * binary (adp_sdw.bound, 14);

001342  aa  7 00001 2351 00	lda  	pr7|1		adp_sdw.bound
001343  aa   000072 7730 00	lrl  	58
001344  aa   000004 7360 00	qls  	4
001345  aa   000020 0760 07	adq  	16,dl
001346  aa  5 00001 7561 00	stq  	pr5|1		sdw_info.size
						STATEMENT 1 ON LINE 278
	     sdw_info.address = binary (adp_sdw.add, 26);

001347  aa  7 00000 2351 00	lda  	pr7|0		adp_sdw.add
001350  aa   000056 7730 00	lrl  	46
001351  aa  5 00000 7561 00	stq  	pr5|0		sdw_info.address
						STATEMENT 1 ON LINE 279
	end;

001352  aa   000055 7100 04	tra  	45,ic		001427
						STATEMENT 1 ON LINE 281
	else do;

						STATEMENT 1 ON LINE 282
	     string (sdw_info.access) = string (l68_sdw.access);

001353  aa  7 00001 2351 00	lda  	pr7|1
001354  aa   000017 7350 00	als  	15
001355  aa  5 00002 6751 00	era  	pr5|2
001356  aa  0 00010 3751 00	ana  	pr0|8		= 740000000000
001357  aa  5 00002 6551 00	ersa 	pr5|2
						STATEMENT 1 ON LINE 283
	     string (sdw_info.rings) = string (l68_sdw.rings);

001360  aa  7 00000 2351 00	lda  	pr7|0
001361  aa   000030 7350 00	als  	24
001362  aa  5 00003 5511 40	stba 	pr5|3,40
						STATEMENT 1 ON LINE 285
	     sdw_info.faulted = ^l68_sdw.valid;

001363  aa  7 00000 2351 00	lda  	pr7|0		l68_sdw.valid
001364  aa   000041 7350 00	als  	33
001365  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001366  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001367  aa   000001 7710 00	arl  	1
001370  aa  5 00004 6751 00	era  	pr5|4		sdw_info.faulted
001371  aa   200000 3750 03	ana  	65536,du
001372  aa  5 00004 6551 00	ersa 	pr5|4		sdw_info.faulted
						STATEMENT 1 ON LINE 286
	     sdw_info.paged = ^l68_sdw.unpaged;

001373  aa  7 00001 2351 00	lda  	pr7|1		l68_sdw.unpaged
001374  aa   000023 7350 00	als  	19
001375  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001376  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001377  aa  5 00004 6751 00	era  	pr5|4		sdw_info.paged
001400  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
001401  aa  5 00004 6551 00	ersa 	pr5|4		sdw_info.paged
						STATEMENT 1 ON LINE 287
	     sdw_info.cache = l68_sdw.cache;

001402  aa  7 00001 2351 00	lda  	pr7|1		l68_sdw.cache
001403  aa   000023 7350 00	als  	19
001404  aa  5 00004 6751 00	era  	pr5|4		sdw_info.cache
001405  aa   100000 3750 03	ana  	32768,du
001406  aa  5 00004 6551 00	ersa 	pr5|4		sdw_info.cache
						STATEMENT 1 ON LINE 289
	     if ^l68_sdw.not_a_gate then		/* Copy the entry bound, if interesting */
		sdw_info.gate_entry_bound = 1 + binary (l68_sdw.entry_bound, 14);

001407  aa  7 00001 2351 00	lda  	pr7|1		l68_sdw.not_a_gate
001410  aa   100000 3150 07	cana 	32768,dl
001411  aa   000005 6010 04	tnz  	5,ic		001416
001412  aa  7 00001 2361 00	ldq  	pr7|1		l68_sdw.entry_bound
001413  aa  0 00404 3771 00	anaq 	pr0|260		= 000000000000 000000037777
001414  aa   000001 0760 07	adq  	1,dl
001415  aa  5 00005 7561 00	stq  	pr5|5		sdw_info.gate_entry_bound
						STATEMENT 1 ON LINE 292
	     sdw_info.size = 16 + 16 * binary (l68_sdw.bound, 14);

001416  aa  7 00001 2351 00	lda  	pr7|1		l68_sdw.bound
001417  aa   000001 7350 00	als  	1
001420  aa   000072 7730 00	lrl  	58
001421  aa   000004 7360 00	qls  	4
001422  aa   000020 0760 07	adq  	16,dl
001423  aa  5 00001 7561 00	stq  	pr5|1		sdw_info.size
						STATEMENT 1 ON LINE 293
	     sdw_info.address = binary (l68_sdw.add, 24);

001424  aa  7 00000 2351 00	lda  	pr7|0		l68_sdw.add
001425  aa   000060 7730 00	lrl  	48
001426  aa  5 00000 7561 00	stq  	pr5|0		sdw_info.address
						STATEMENT 1 ON LINE 294
	end;

						STATEMENT 1 ON LINE 296
	return;

001427  aa  6 00166 6101 00	rtcd 	pr6|118
						STATEMENT 1 ON LINE 297
     end;

  END PROCEDURE sdw_util_$dissect
  END PROCEDURE ed_appending_simulation_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
