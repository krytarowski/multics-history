	COMPILATION LISTING OF SEGMENT tolts_util_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/09/86  1526.9 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /* Initially coded 6/78 by J. A. Bush
       13*   Modified by Rich Coppola 9/29/81 to return value of iocbp if non-null so
       14*   caller can clean up.
       15*   Modified by R. Fakoury 3/16/83 to add the get_ttl_date entry.
       16*   Modified by R. Fakoury 6/10/83 to add opr_msg facility.
       17*   Modified by R. Fakoury 8/02/83 to fix a typo in opr_msg.
       18*   Modified by R. Fakoury 10/84 to replace the internal proc, find_card with an external entry of find_card,
       19*   and to remove the obsolete entry config.
       20**/
       21 
       22 
       23 
       24 
       25 /****^  HISTORY COMMENTS:
       26*  1) change(84-11-01,Fakoury), approve(86-08-21,MCR7514),
       27*     audit(86-11-17,Martinson), install(86-12-04,MR12.0-1235):
       28*     to add the dev0_valid entry.
       29*     to change call hcs_$status_long to hcs_$status_minf.
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 
       34 
       35 /* tolts_util_ - a group of utility subroutines for TOLTS, MOLTS, POLTS, and ISOLTS */
       36 
       37 
       38 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
       39 tolts_util_: proc;
       40 
       41 
       42 /* External entries */
       43 
       44 dcl  decode_clock_value_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin (71), fixed bin, char (3));
       45 dcl  (get_wdir_, get_default_wdir_) entry returns (char (168));
       46 dcl  hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
       47 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       48 dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
       49 dcl  hcs_$status_mins entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
       50 dcl  (ioa_, ioa_$nnl, ioa_$rsnnl, com_err_) entry options (variable);
       51 dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       52 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
       53 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       54 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
       55 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
       56 dcl  iox_$seek_key entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
       57 dcl  object_info_$display entry (ptr, fixed bin (24), ptr, fixed bin (35));
       58 dcl  opr_query_ entry options (variable);
       59 
       60 
       61 /* External static */
       62 
       63 dcl  iox_$user_input ptr ext;
       64 
       65 /* Entry parameters */
       66 
       67 dcl  seg_name entry;
       68 dcl  com_string char (132) aligned;
       69 dcl  mess char (*);
       70 dcl  c_args (32) char (28) varying;
       71 dcl  rcode fixed bin (35);
       72 dcl  cmd_cnt fixed bin;
       73 dcl  c_len fixed bin;
       74 dcl  (a_iocbp, c_ptr) ptr;
       75 dcl  config_name char (4);
       76 dcl  in bit (*);
       77 dcl  out char (*) varying;
       78 dcl  bci_len fixed bin;
       79 dcl  c_name char (32);
       80 dcl  exec char (6);
       81 dcl  state char (3);
       82 dcl  ttl_date char (6);
       83 
       84 /* Automatic */
       85 
       86 dcl  1 o_info like object_info;
       87 dcl  (month, dom, year, dow) fixed bin;
       88 dcl  tod fixed bin (71);
       89 dcl  zone char (3);
       90 dcl  ttl char (6);
       91 dcl  bc fixed bin (24);
       92 dcl  type fixed bin (2);
       93 dcl  (i, j, lp, escape_cnt) fixed bin;
       94 dcl  rec_len fixed bin (21);
       95 dcl  seek_key char (256) varying;
       96 dcl  ename char (32);
       97 dcl  tim char (12);
       98 dcl  cc char (1);
       99 dcl  (temp_ptr, info_ptr, seg_ptr, iocbp) ptr;
      100 dcl  cur_char bit (6);
      101 dcl  bit_cnt fixed bin (24);
      102 dcl  code fixed bin (35);				/* error code */
      103 dcl  info (20) bit (36);
      104 dcl  gki (20) bit (36);
      105 
      106 /* Builtins */
      107 
      108 dcl  (addr, addrel, before, date, divide, fixed, hbound, length, ltrim,
      109      null, rtrim, codeptr, ptr, reverse, search, substr, time, unspec, verify) builtin;
      110 
      111 /* Based */
      112 
      113 dcl  1 rsi like rs_info aligned;
      114 
      115 dcl  1 cata_info based (c_ptr) aligned,			/* info structure for cata_sel entry */
      116        2 n_keys fixed bin,				/* number of multiple keys */
      117        2 cata_keys (1 refer (cata_info.n_keys)) char (24);	/* multiple key array */
      118 
      119 
      120 /* Constants */
      121 
      122 dcl  opn_ksi fixed bin int static options (constant) init (8);
      123 dcl  bcd_to_ascii char (64) int static options (constant) init
      124       ("0123456789[#@:>? abcdefghi&.](<\^jklmnopqr-$*);'+/stuvwxyz_,%=""!");
      125 dcl  lib_dir char (168) int static options (constant) init
      126       (">system_library_tandd");
      127 dcl  WS char (2) int static options (constant) init (" 	");
      128 dcl  NL char (1) int static options (constant) init ("
      129 ");
      130 dcl  NP char (1) int static options (constant) init ("");
      131 
      132 
      133 
      134 /* query - entry to query and get response from user */
      135 
      136 query: entry (mess, com_string, c_len, c_args, cmd_cnt);
      137 
      138       cmd_cnt = 0;					/* initilize parameters */
      139       c_args = "";
      140 m_retry:
      141       if length (rtrim (mess)) ^= 0 then		/* only print message if there */
      142          call ioa_$nnl (mess);			/* print out prompt for user */
      143       com_string = "";				/* clear out last command */
      144       call iox_$get_line (iox_$user_input, addr (com_string), length (com_string), rec_len, code);
      145       if code ^= 0 then do;				/* error reading from  terminal */
      146          call com_err_ (code, "tolts_util_$query", "reading input from user_input, re-enter");
      147          go to m_retry;
      148       end;
      149       substr (com_string, rec_len) = "";		/* strip out new_line */
      150       c_len = rec_len;				/* set command line length */
      151       if rec_len = 1 then return;			/* return if no message */
      152 
      153 /* separate arguments into arg array */
      154 
      155       lp = 1;					/* start at beginning of line */
      156       do i = 1 to hbound (c_args, 1) while (lp < rec_len);
      157          j = length (ltrim (substr (com_string, lp, rec_len), WS)); /* strip off leading white space */
      158          lp = (rec_len - j) + lp;			/* lp = starting position of next string */
      159          j = search (substr (com_string, lp), WS);	/* find end of string */
      160          c_args (i) = substr (com_string, lp, j - 1);
      161          lp = lp + (j - 1);				/* update line position */
      162       end;
      163       cmd_cnt = i - 1;				/* set arg count for user */
      164       return;
      165 
      166 
      167 /* on_off - entry to display greeting or signoff message from executives */
      168 
      169 on_off: entry (exec, state, ttl_date);
      170 
      171 
      172       tim = time;
      173 
      174 /* output message */
      175 
      176       call ioa_ ("^/***^a executive version ^a ^a ^a at ^a", exec, ttl_date, state, date,
      177        substr (tim, 1, 2) || "." || substr (tim, 3, 3));
      178 
      179       return;
      180 
      181 
      182 /* bci_to_ascii - entry to convert bcd with imbedded escape and ignore characters to ascii */
      183 
      184 bci_to_ascii: entry (in, out, bci_len);
      185 
      186       out = "";					/* pad output string with blanks */
      187       escape_cnt = 0;				/* initialize escape_cnt */
      188 
      189       do i = 1 to bci_len;				/* go through entire input string */
      190          cur_char = substr (in, 6 * (i - 1) + 1, 6);	/* pick up current bcd char */
      191          if escape_cnt = 2 then			/* if 2 times through here... */
      192 	  go to use_char;				/* convert the character */
      193          else if cur_char = "77"b3 then			/* escape character */
      194 	  escape_cnt = escape_cnt + 1;		/* increment escape count */
      195          else if escape_cnt = 1 then do;		/* if only 1 escape... */
      196 	  lp = fixed (cur_char, 6);			/* get slew count */
      197 	  if lp = 0 then lp = 1;
      198 	  if lp >= 16 then				/* if slew to top of page */
      199 	     out = out || NP;			/* set new page charater in out string */
      200 	  else do j = 1 to lp;			/* put in correct number off new lines */
      201 	     out = out || NL;
      202 	  end;
      203 	  escape_cnt = 0;				/* clear out escape cnt */
      204          end;
      205          else if cur_char = "17"b3 then			/* ignore character */
      206 	  escape_cnt = 0;
      207          else do;					/* valid bcd character */
      208 use_char:
      209 	  cc = substr (bcd_to_ascii, fixed (cur_char, 6) + 1, 1); /* extract current char from table */
      210 	  if cc = ")" | cc = "," then do;		/* check for white space before close paren or comma */
      211 	     j = verify (reverse (out), WS);		/* find leading blank or tab */
      212 	     if j ^= 1 then				/* if we found some */
      213 	        out = substr (out, 1, length (out) - j + 1); /* wipe it out */
      214 	  end;
      215 	  out = out || cc;				/* add in current character */
      216 	  escape_cnt = 0;
      217          end;
      218       end;
      219 
      220       return;
      221 
      222 
      223 /* search - entry to find and return a pointer to a test page */
      224 
      225 search: entry (a_iocbp, c_name, c_ptr, c_len, rcode);
      226 
      227       temp_ptr, c_ptr = null;				/* preset return parameters */
      228       rcode, c_len = 0;
      229       iocbp = a_iocbp;				/* copy dkfile iocb ptr */
      230       ename = c_name;				/* copy search name */
      231 
      232 /* attempt to initiate the segment first in working dir, home dir and then in sys lib */
      233 
      234       call hcs_$initiate_count ((get_wdir_ ()), ename, "", bit_cnt, 0, temp_ptr, code);
      235       if temp_ptr = null then				/* no find, check home dir */
      236          call hcs_$initiate_count ((get_default_wdir_ ()), ename, "", bit_cnt, 0, temp_ptr, code);
      237       if temp_ptr = null then				/* no find, check sys dir */
      238          call hcs_$initiate_count (lib_dir, ename, "", bit_cnt, 0, temp_ptr, code);
      239       if temp_ptr ^= null then do;			/* found it, return to user */
      240          c_ptr = temp_ptr;				/* copy seg ptr */
      241          c_len = divide (bit_cnt, 36, 17, 0);
      242          return;
      243       end;
      244 
      245 /* couldn't find entry as a ssf, now lets check to see if we have a deckfile */
      246 
      247       if iocbp = null then do;			/* deckfile not attached */
      248          call find_deckfile ((get_wdir_ ()));		/* try to find deckfile in working dir */
      249          if code ^= 0 then				/* no deck file there, try sys dir */
      250 	  call find_deckfile (lib_dir);
      251          if code ^= 0 then do;			/* still couln't find it, return */
      252 	  rcode = code;				/* give user the error */
      253 	  return;
      254          end;
      255       end;
      256       call find_record;				/* go find desired record */
      257       if code = 0 then do;				/* found it ok */
      258          a_iocbp = iocbp;				/* return good iocb ptr to user */
      259          c_ptr = rsi.record_ptr;			/* return ptr to deckfile record */
      260          c_len = divide (rsi.record_length, 4, 17, 0);	/* and record word length */
      261       end;
      262       else rcode = code;				/* else return error */
      263       return;
      264 
      265 /* cata_sel - entry to find all catalog search keys, given search key head */
      266 
      267 cata_sel: entry (a_iocbp, c_name, c_ptr, rcode);
      268 
      269       rcode = 0;
      270       iocbp = a_iocbp;				/* copy dkfile iocb ptr */
      271       ename = c_name;				/* copy search name */
      272       info_ptr = addr (info);				/* set info ptrs */
      273       unspec (info) = "0"b;				/* clear structure first */
      274       if iocbp = null then do;			/* deckfile not attached */
      275          call find_deckfile ((get_wdir_ ()));		/* try to find deckfile in working dir */
      276          if code ^= 0 then				/* no deck file there, try sys dir */
      277 	  call find_deckfile (lib_dir);
      278          if code ^= 0 then do;			/* still couln't find it, return */
      279 	  rcode = code;				/* give user the error */
      280 	  if iocbp ^= null then
      281 	     a_iocbp = iocbp;			/* let caller clean up */
      282 	  return;
      283          end;
      284       end;
      285       a_iocbp = iocbp;				/* copy iocb ptr back */
      286       common_sl_info.version = sl_info_version_0;
      287       common_sl_info.list_type = 1;			/* set to reuse subset */
      288       common_sl_info.output_descriptors = "1"b;		/* want descriptors */
      289       common_sl_info.array_limit = 1;			/* 1 element array */
      290       common_sl_info.desc_arrayp = null;		/* let vfile_ allocate area for storage */
      291       hi_sl_info.first_head (1).length, hi_sl_info.last_head (1).length = length (rtrim (ename));
      292       hi_sl_info.first_head (1).kptr, hi_sl_info.last_head (1).kptr = addr (ename);
      293       call iox_$control (iocbp, "select", addr (info), code); /* get select info */
      294       if code ^= 0 then do;				/* problem with select */
      295          rcode = code;
      296          return;
      297       end;
      298       call iox_$position (iocbp, -1, 0, code);		/* position to beginning of file */
      299       if code ^= 0 then do;				/* problem with select */
      300          rcode = code;
      301          return;
      302       end;
      303       cata_info.n_keys = common_sl_info.count;		/* copy number of descriptors */
      304       gk_info_ptr = addr (gki);			/* set info ptr */
      305       unspec (gki) = "0"b;				/* clear structure first */
      306       gk_info.input_desc = "1"b;			/* using input descriptors */
      307       gk_info.reset_pos = "1"b;			/* don't change position */
      308       do i = 1 to common_sl_info.count;			/* find each key */
      309          gk_info.descrip = desc_array (i);		/* insert each descriptor */
      310          call iox_$control (iocbp, "get_key", addr (gki), code);
      311          if code ^= 0 then do;			/* error */
      312 	  rcode = code;
      313 	  return;
      314          end;
      315          cata_info.cata_keys (i) = gk_info.key;		/* copy key */
      316       end;
      317       common_sl_info.list_type = 0;			/* set to reuse subset */
      318       common_sl_info.subset_no = 0;
      319       common_sl_info.array_limit = 0;			/* 0 element array */
      320       common_sl_info.desc_arrayp = null;		/* let vfile_ allocate area for storage */
      321       call iox_$control (iocbp, "select", addr (info), code); /* reset current subset */
      322       return;					/* thats it folks */
      323 
      324 
      325 /* find_deckfile - int procedure to search for tandd_deck_file and return desired record info if found */
      326 
      327 find_deckfile: proc (dir);
      328 
      329 dcl  deckfile_dir char (168);
      330 dcl  dir char (168);
      331 dcl  type fixed bin (2) init (0);
      332 
      333       call hcs_$status_minf (dir, "tandd_deck_file", 1, type, 0, code);
      334       if type = 2 then do;				/* found deck file 0 = link, 1 = seg, 2 = dir */
      335 
      336 /* attach and open deck file for keyed seq input */
      337 
      338          call iox_$attach_name ("dk_file_sw", iocbp, "vfile_ " || rtrim (dir) || ">tandd_deck_file", null, code);
      339          if code ^= 0 then return;
      340 
      341          call iox_$open (iocbp, opn_ksi, "0"b, code);	/* attach ok, open it */
      342          if code ^= 0 then return;
      343 
      344          unspec (rsi) = "0"b;				/* clear structure */
      345          rsi.version = rs_info_version_2;		/* set proper version for vfile_ */
      346          call iox_$control (iocbp, "record_status", addr (rsi), code); /* get record info */
      347          if code ^= 0 then return;
      348 
      349          call hcs_$fs_get_path_name (rsi.record_ptr, deckfile_dir, 0, "", code); /* code always = 0 */
      350 
      351          if before (deckfile_dir, ">tandd_deck_file") ^= lib_dir then
      352 	  call ioa_ ("Using ^a", deckfile_dir);
      353       end;
      354 
      355    end find_deckfile;
      356 
      357 /* find_record - int precdure to find desired record in deckfile */
      358 
      359 find_record: proc;
      360 
      361       seek_key = ename;				/* copy search key */
      362       call iox_$seek_key (iocbp, seek_key, rec_len, code);	/* find record */
      363       if code = 0 then do;				/* record exists, get record info */
      364          unspec (rsi) = "0"b;				/* clear structure */
      365          rsi.version = rs_info_version_2;		/* set proper version for vfile_ */
      366          call iox_$control (iocbp, "record_status", addr (rsi), code); /* get record info */
      367       end;
      368 
      369    end find_record;
      370 
      371 
      372 /* find_card - external procedure to search config deck for desired config card */
      373 
      374 find_card: entry (config_name, cardp);
      375 
  1     1 /* BEGIN INCLUDE FILE ... config_deck.incl.pl1 ... 11/13/80, W. Olin Sibert */
  1     2 
  1     3 dcl (configp, cardp) pointer;
  1     4 dcl  config_n_cards fixed bin;			/* Number of cards used in config */
  1     5 dcl  config_max_cards fixed bin;			/* Max number of cards in config */
  1     6 
  1     7 dcl  config_deck$ fixed bin external static;
  1     8 
  1     9 dcl 1 config_deck aligned based (configp),
  1    10     2 cards (config_n_cards) aligned like config_card,
  1    11     2 pad_cards (config_max_cards - config_n_cards) aligned like config_card;
  1    12 
  1    13 dcl 1 config_card aligned based (cardp),
  1    14     2 word char (4) aligned,
  1    15     2 data_field (14) bit (36) aligned,
  1    16     2 type_word aligned like config_card_type_word;
  1    17 
  1    18 dcl 1 config_card_type_word aligned based,
  1    19     2 field_type (14) bit (2) unaligned,
  1    20     2 pad1 bit (4) unaligned,
  1    21     2 n_fields fixed bin (4) unsigned unaligned;
  1    22 
  1    23 dcl (CONFIG_DECIMAL_TYPE	init ("11"b),
  1    24      CONFIG_OCTAL_TYPE	init ("00"b),
  1    25      CONFIG_SINGLE_CHAR_TYPE	init ("01"b),
  1    26      CONFIG_STRING_TYPE	init ("10"b)) bit (2) aligned static options (constant);
  1    27 
  1    28 dcl  ZERO_CARD_WORD char (4) aligned internal static options (constant) init ("    ");
  1    29 dcl  FREE_CARD_WORD char (4) aligned internal static options (constant) init ("ÿÿÿÿ");
  1    30 
  1    31 dcl  VALID_CARD_WORD_CHARACTERS char (38) internal static options (constant) init
  1    32     ("abcdefghijklmnopqrstuvwxyz0123456789_.");		/* lowercase letters, digits, period and underscore */
  1    33 
  1    34 dcl  EMPTY_FIELD bit (36) aligned internal static options (constant) init ("777777777777"b3);
  1    35 
  1    36 /* END INCLUDE FILE config_deck.incl.pl1 */
      376 
      377 
      378 dcl  config_deck_end fixed bin based (addr (config_card.word));
      379 
      380       if cardp = null then				/* if pointer is null, set it  */
      381          cardp = addr (config_deck$);
      382       else cardp = addrel (cardp, 16);			/* else go to next card */
      383 
      384       do while (config_deck_end ^= -1);			/* go through entire deck if necessary */
      385          if config_card.word = config_name then		/* found the right card */
      386 	  return;
      387          else cardp = addrel (cardp, 16);		/* get next card */
      388       end;
      389       cardp = null;					/* did'nt find it */
      390       return;
      391 
      392 
      393 /* get_ttl_date - entry to find date a obj seg was compiled */
      394 
      395 get_ttl_date: entry (seg_name, ttl_date);
      396 
      397 
      398 
      399       seg_ptr = ptr (codeptr (seg_name), 0);
      400       o_info.version_number = 2;
      401       call hcs_$status_mins (seg_ptr, type, bc, code);
      402       call object_info_$display (seg_ptr, bc, addr (o_info), code);
      403       call decode_clock_value_ (o_info.compile_time, month, dom, year, tod, dow, zone);
      404       year = year - 1900;
      405       call ioa_$rsnnl ("^d^[0^]^d^[0^]^d", ttl, i, year, (month < 10), month, (dom < 10), dom);
      406       ttl_date = ttl;
      407       return;
      408 
      409 
      410 /* opr_msg - internal procedure to send messages to the operator */
      411 
      412 
      413 opr_msg: entry;
      414 
      415 dcl  tolts_util_$query entry (char (*), char (132) aligned, fixed bin, (32) char (28) var, fixed bin);
      416 dcl  d fixed bin (71) init (1);
      417 dcl  c_string char (132) aligned;
      418 dcl  (clen, c_cnt) fixed bin;
      419 dcl  cargs (32) char (28) varying;
      420 
      421 
      422       call ioa_ ("^/enter 1 line message of up to 80 characters");
      423       call tolts_util_$query ("??? ", c_string, clen, cargs, c_cnt);
      424       if substr (c_string, clen - 1, 1) = "?" then do;
      425          opr_query_info.q_sw = "1"b;
      426          opr_query_info.prim = "";
      427          opr_query_info.alt = "";
      428          opr_query_info.r_comment = "Please reply: x oqr followed by message of up to 80 characters";
      429          if clen > 80 then clen = 80;			/* truncate message length if necessary */
      430          call opr_query_ (addr (opr_query_info), substr (c_string, 1, clen));
      431          call ioa_ ("^a", opr_query_info.answer);
      432       end;
      433       else do;
      434          opr_query_info.q_sw = "0"b;			/* no operator response needed */
      435          call opr_query_ (addr (opr_query_info), substr (c_string, 1, clen));
      436       end;
      437       return;
      438 
      439 
      440 
      441 /*
      442*   The following function returns the value of the first
      443*   disk driver in a string .
      444**/
      445 
      446 dev0_valid: entry (cdp, Model) returns (bit (1));
      447 
      448 
      449 dcl  (Model, nnames) fixed bin;
      450 dcl  cdp ptr;
      451 dcl  1 cd_model_info based (cdp) aligned,
      452        2 count fixed bin,
      453        2 names (nnames) aligned,
      454          3 model fixed bin,
      455          3 name char (8),
      456          3 dev_0_valid bit (1);
      457 
      458 
      459       nnames = cd_model_info.count;
      460       do i = 1 to cd_model_info.count while (cd_model_info.names (i).model ^= Model);
      461       end;
      462       if cd_model_info.names (i).dev_0_valid then return ("1"b);
      463       else return ("0"b);
      464 
      465 
  2     1 /* ak_info -- include file for info structures used by the following vfile_
  2     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  2     3*   Created by M. Asherman 3/23/76
  2     4*   Modified 5/13/77 to add separate gk_info structure */
  2     5 
  2     6      dcl	   1 ak_info	      based (ak_info_ptr),
  2     7 	     2 header	      like ak_header,
  2     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  2     9 
  2    10      dcl	   1 ak_header	      based (ak_info_ptr),
  2    11 	     2 flags	      aligned,
  2    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  2    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  2    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  2    15 	     2 descrip	      fixed (35),		/* record designator */
  2    16 	     2 key_len	      fixed;
  2    17 
  2    18      dcl	   ak_info_ptr	      ptr;
  2    19      dcl	   ak_key_len	      fixed;
  2    20 
  2    21 
  2    22      dcl	   1 rk_info	      based (rk_info_ptr),
  2    23 	     2 header	      like rk_header,
  2    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  2    25 
  2    26      dcl	   1 rk_header	      based (rk_info_ptr),
  2    27 	     2 flags	      aligned,
  2    28 	       3 input_key	      bit (1) unal,		/* same as above */
  2    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  2    30*						   given by old_descrip */
  2    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  2    32 	       3 mbz	      bit (33) unal,
  2    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  2    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  2    35 	     2 key_len	      fixed;
  2    36 
  2    37      dcl	   rk_info_ptr	      ptr;
  2    38      dcl	   rk_key_len	      fixed;
  2    39 
  2    40 
  2    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  2    42 	     2 header	      like gk_header,
  2    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  2    44 						/* may be Input as well as Output */
  2    45 
  2    46      dcl	   1 gk_header	      based (gk_info_ptr),
  2    47 	     2 flags	      aligned,
  2    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  2    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  2    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  2    51 	       3 position_specification
  2    52 			      unal,
  2    53 	         4 current	      bit (1) unal,		/* otherwise next */
  2    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  2    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  2    56 						/* size of head for initial seek */
  2    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  2    58 	       3 pad	      bit (8) unal,
  2    59 	       3 version	      fixed (8) unal,
  2    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  2    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  2    62 
  2    63      dcl	   gk_info_ptr	      ptr;
  2    64      dcl	   gk_key_len	      fixed;
  2    65 
  2    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  2    67 
  2    68 /* end ak_info.incl.pl1 */
      466 
      467 
  3     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  3     2*coded February 8, 1972 by Michael J. Spier	*/
  3     3 /* modified May 26, 1972 by M. Weaver */
  3     4 /* modified 15 April, 1975 by M. Weaver */
  3     5 
  3     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  3     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  3     8 	2 textp pointer,			/* pointer to beginning of text section */
  3     9 	2 defp pointer,			/* pointer to beginning of definition section */
  3    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  3    11 	2 statp pointer,			/* pointer to beginning of static section */
  3    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  3    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  3    14 	2 tlng fixed bin,			/* length in words of text section */
  3    15 	2 dlng fixed bin,			/* length in words of definition section */
  3    16 	2 llng fixed bin,			/* length in words of linkage section */
  3    17 	2 ilng fixed bin,			/* length in words of static section */
  3    18 	2 slng fixed bin,			/* length in words of symbol section */
  3    19 	2 blng fixed bin,			/* length in words of break map */
  3    20 	2 format,				/* word containing bit flags about object type */
  3    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  3    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  3    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  3    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  3    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  3    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  3    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  3    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  3    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  3    30 	  3 pad bit(27) unaligned,
  3    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  3    32 	2 textlinkp pointer,		/* ptr to first link in text */
  3    33 
  3    34 	/* LIMIT OF BRIEF STRUCTURE */
  3    35 
  3    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  3    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  3    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  3    39 	2 cvers aligned,			/* generator version name in printable char string form */
  3    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  3    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  3    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  3    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  3    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  3    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  3    46 
  3    47 	/* LIMIT OF DISPLAY STRUCTURE */
  3    48 
  3    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  3    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  3    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  3    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  3    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  3    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  3    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  3    56 					/* currently not used by system */
  3    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  3    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  3    59 
  3    60 declare	object_info_version_2 fixed bin int static init(2);
  3    61 
  3    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      468 
      469 
  4     1 
  4     2 /* BEGIN INCLUDE FILE opr_query_info.incl.pl1 */
  4     3 
  4     4 /* created 10/20/78 by J. A. Bush. 
  4     5*   Modified by Rick Fakoury to increase size of the allowable answer.
  4     6**/
  4     7 
  4     8 dcl 1 opr_query_info aligned,				/* info structure for the opr_query_ subroutine */
  4     9     2 version fixed bin,				/* version of this structure, currently = to 1 */
  4    10     2 q_sw bit (1) aligned,				/* = "1"b if aswer is expected from operator */
  4    11     2 prim char (8),				/* primary expected operators response */
  4    12     2 alt char (8),					/* alternate expected operator response */
  4    13     2 answer char (80) varying,				/* operators answer */
  4    14     2 r_comment char (64),				/* comment to be output with respond message */
  4    15     2 err_code fixed bin (35);			/* standard system status code */
  4    16 
  4    17 /* END INCLUDE FILE opr_query_info.incl.pl1 */
  4    18 
      470 
      471 
  5     1 /* include file for info structure used with record_status control order
  5     2*   created by M. Asherman 1/6/76 */
  5     3 /* modified 6/15/77 to support stationary type records */
  5     4 
  5     5      dcl	   rs_info_ptr	      ptr;
  5     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
  5     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
  5     8 	     2 flags	      aligned,
  5     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
  5    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
  5    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
  5    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
  5    13*						   located outside the index by descrip, or created without key */
  5    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
  5    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
  5    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
  5    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
  5    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
  5    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
  5    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
  5    21*						   Input if create_sw is set--overrides min_block_size in effect */
  5    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
  5    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
  5    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
  5    25 	     2 time_last_modified fixed (71),		/* Output */
  5    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
  5    27 	     2 block_ptr	      ptr unal,		/* Output */
  5    28 	     2 last_image_modifier
  5    29 			      fixed (35),
  5    30 	     2 mbz2	      fixed;
  5    31 
  5    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
  5    33 						/* record block descriptor structure */
  5    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
  5    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
  5    36 
  5    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
  5    38 						/* for sequential files */
  5    39 	     2 bitno	      bit (6) unal,
  5    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
  5    41 	     2 wordno	      bit (18) unal;	/* word offset */
  5    42 
  5    43      dcl	   rs_info_version_1      static internal fixed init (1);
  5    44      dcl	   rs_info_version_2      static internal fixed init (2);
  5    45 
      472 
      473 
  6     1 /* Include file for vfile_ control orders dealing with key ranges in indexed files */
  6     2 /* created by M. Asherman 4/7/77
  6     3*Modified:
  6     4*12/18/80  by  Lindsey Spratt: Add the delete_old_subsets bit.
  6     5**/
  6     6 
  6     7 /* format: style2 */
  6     8      dcl	   1 common_sl_info	      based (info_ptr),	/* info structure for select and exclude orders */
  6     9 	     2 flags	      aligned,		/* Input */
  6    10 	       3 list_type	      fixed (3) unal,	/* code identifies format of tail structure */
  6    11 	       3 status_only      bit (1) unal,		/* if set, subset info is returned, but current subset stays the same */
  6    12 	       3 output_descriptors
  6    13 			      bit (1) unal,		/* if set, resulting descriptor list is returned */
  6    14 	       3 delete_old_subsets
  6    15 			      bit (1) unal,		/* if set, causes all of the existing subsets on this switch to be deleted. */
  6    16 	       3 mbz	      bit (11) unal,	/* must be zero--in case of extensions */
  6    17 	       3 version	      fixed (17) unal,	/* current info version */
  6    18 	     2 array_limit	      fixed,		/* upper bound of array in tail of info structure */
  6    19 	     2 subset_no	      fixed,		/* identifies temporary subset-- Output */
  6    20 	     2 count	      fixed (34),		/* Output--number of distinct descrips */
  6    21 	     2 desc_arrayp	      ptr;		/* pointer to resulting array of descriptors */
  6    22 
  6    23 /* descriptor array generated if requested */
  6    24      dcl	   desc_array	      (1:common_sl_info.count) based (common_sl_info.desc_arrayp);
  6    25 
  6    26 /* this format allows specification in terms of index intervals defined by two heads or one key */
  6    27      dcl	   1 hi_sl_info	      based (info_ptr),	/* structure for list_type = 1 */
  6    28 	     2 common	      like common_sl_info,
  6    29 	     2 interval	      (1:sl_array_limit refer (hi_sl_info.array_limit)),
  6    30 	       3 first_head,
  6    31 	         4 length	      fixed,
  6    32 	         4 kptr	      ptr unal,
  6    33 	       3 last_head,
  6    34 	         4 length	      fixed,		/* if negative, this interval is defined by match with key */
  6    35 	         4 kptr	      ptr unal;
  6    36 
  6    37 /* format for specification in terms of an array of descriptors */
  6    38      dcl	   1 da_sl_info	      based (info_ptr),	/* list_type=2 */
  6    39 	     2 common	      like common_sl_info,
  6    40 	     2 desc_array	      (1:sl_array_limit refer (da_sl_info.array_limit)) fixed (35);
  6    41 
  6    42      dcl	   sl_array_limit	      fixed;
  6    43      dcl	   sl_info_version_0      static options (constant) internal fixed init (0);
  6    44 
  6    45 /* list_type=0 denotes reselection of a single, previously defined subset (no tail structure) */
      474 
      475 
  7     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  7     2 
  7     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  7     4 
  7     5 /* This include file contains branch and link structures returned by
  7     6*   hcs_$status_ and hcs_$status_long. */
  7     7 
  7     8 dcl 1 status_branch aligned based (status_ptr),
  7     9     2 short aligned,
  7    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  7    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  7    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  7    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  7    14       3 dtu bit (36) unaligned,			/* date/time last used */
  7    15       3 mode bit (5) unaligned,			/* caller's effective access */
  7    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  7    17       3 pad1 bit (8) unaligned,
  7    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  7    19 
  7    20 /* Limit of information returned by hcs_$status_ */
  7    21 
  7    22     2 long aligned,
  7    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  7    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  7    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  7    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  7    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  7    28       3 pad2 bit (8) unaligned,
  7    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  7    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  7    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  7    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  7    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  7    34       3 pad3 bit (5) unaligned,
  7    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  7    36       3 uid bit (36) unaligned;			/* unique ID */
  7    37 
  7    38 dcl 1 status_link aligned based (status_ptr),
  7    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  7    40     2 nnames fixed bin (16) unaligned unsigned,
  7    41     2 names_relp bit (18) unaligned,
  7    42     2 dtem bit (36) unaligned,
  7    43     2 dtd bit (36) unaligned,
  7    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  7    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  7    46 
  7    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  7    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  7    49 						/* array of names returned */
  7    50      status_pathname character (status_link.pathname_length) aligned
  7    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  7    52 						/* link target path */
  7    53      status_area_ptr pointer,
  7    54      status_ptr pointer;
  7    55 
  7    56 dcl (Link initial (0),
  7    57      Segment initial (1),
  7    58      Directory initial (2)) fixed bin internal static options (constant);
  7    59 						/* values for type fields declared above */
  7    60 
  7    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      476 
      477 
      478 
      479 
      480    end tolts_util_;
      481 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/09/86  1521.6  tolts_util_.pl1                   >special_ldd>install>MR12.0-1235>tolts_util_.pl1
376          1    05/08/81  1853.6  config_deck.incl.pl1              >ldd>include>config_deck.incl.pl1
466          2    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
468          3    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
470          4    06/09/83  1430.8  opr_query_info.incl.pl1           >ldd>include>opr_query_info.incl.pl1
472          5    07/19/79  1547.0  rs_info.incl.pl1                  >ldd>include>rs_info.incl.pl1
474          6    07/31/81  1818.2  select_info.incl.pl1              >ldd>include>select_info.incl.pl1
476          7    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Model                                  parameter       fixed bin(17,0)          dcl 449 ref 446 460
NL                              003757 constant        char(1)                  initial unaligned dcl 128 ref 201
NP                              003756 constant        char(1)                  initial unaligned dcl 130 ref 198
WS                                     constant        char(2)                  initial unaligned dcl 127 ref 157 159 211
a_iocbp                                parameter       pointer                  dcl 74 set ref 225 229 258* 267 270 280* 285*
addr                                                   builtin function         dcl 108 ref 144 144 272 292 293 293 304 310 310 321
                                                                                  321 346 346 366 366 380 384 402 402 430 430 435
                                                                                  435
addrel                                                 builtin function         dcl 108 ref 382 387
ak_header                              based           structure                level 1 unaligned dcl 2-10
alt                       4     001076 automatic       char(8)                  level 2 dcl 4-8 set ref 427*
answer                    6     001076 automatic       varying char(80)         level 2 dcl 4-8 set ref 431*
array_limit               1            based           fixed bin(17,0)          level 2 dcl 6-8 set ref 289* 319*
bc                              000200 automatic       fixed bin(24,0)          dcl 91 set ref 401* 402*
bcd_to_ascii                    000052 constant        char(64)                 initial unaligned dcl 123 ref 208
bci_len                                parameter       fixed bin(17,0)          dcl 78 ref 184 189
before                                                 builtin function         dcl 108 ref 351
bit_cnt                         000335 automatic       fixed bin(24,0)          dcl 101 set ref 234* 235* 237* 241
c_args                                 parameter       varying char(28)         array dcl 70 set ref 136 139* 156 160*
c_cnt                           000472 automatic       fixed bin(17,0)          dcl 418 set ref 423*
c_len                                  parameter       fixed bin(17,0)          dcl 73 set ref 136 150* 225 228* 241* 260*
c_name                                 parameter       char(32)                 unaligned dcl 79 ref 225 230 267 271
c_ptr                                  parameter       pointer                  dcl 74 set ref 225 227* 240* 259* 267 303 315
c_string                        000430 automatic       char(132)                dcl 417 set ref 423* 424 430 430 435 435
cardp                                  parameter       pointer                  dcl 1-3 set ref 374 380 380* 382* 382 384 385 387*
                                                                                  387 389*
cargs                           000473 automatic       varying char(28)         array dcl 419 set ref 423*
cata_info                              based           structure                level 1 dcl 115
cata_keys                 1            based           char(24)                 array level 2 dcl 115 set ref 315*
cc                              000323 automatic       char(1)                  unaligned dcl 98 set ref 208* 210 210 215
cd_model_info                          based           structure                level 1 dcl 451
cdp                                    parameter       pointer                  dcl 450 ref 446 459 460 460 462
clen                            000471 automatic       fixed bin(17,0)          dcl 418 set ref 423* 424 429 429* 430 430 435 435
cmd_cnt                                parameter       fixed bin(17,0)          dcl 72 set ref 136 138* 163*
code                            000336 automatic       fixed bin(35,0)          dcl 102 set ref 144* 145 146* 234* 235* 237* 249 251
                                                                                  252 257 262 276 278 279 293* 294 295 298* 299 300
                                                                                  310* 311 312 321* 333* 338* 339 341* 342 346* 347
                                                                                  349* 362* 363 366* 401* 402*
codeptr                                                builtin function         dcl 108 ref 399
com_err_                        000040 constant        entry                    external dcl 50 ref 146
com_string                             parameter       char(132)                dcl 68 set ref 136 143* 144 144 144 144 149* 157 159
                                                                                  160
common_sl_info                         based           structure                level 1 unaligned dcl 6-8
compile_time             32     000100 automatic       fixed bin(71,0)          level 2 dcl 86 set ref 403*
config_card                            based           structure                level 1 dcl 1-13
config_card_type_word                  based           structure                level 1 dcl 1-18
config_deck$                    000064 external static fixed bin(17,0)          dcl 1-7 set ref 380
config_deck_end                        based           fixed bin(17,0)          dcl 378 ref 384
config_name                            parameter       char(4)                  unaligned dcl 75 ref 374 385
count                                  based           fixed bin(17,0)          level 2 in structure "cd_model_info" dcl 451
                                                                                  in procedure "tolts_util_" ref 459 460
count                     3            based           fixed bin(34,0)          level 2 in structure "common_sl_info" dcl 6-8
                                                                                  in procedure "tolts_util_" ref 303 308
cur_char                        000334 automatic       bit(6)                   unaligned dcl 100 set ref 190* 193 196 205 208
d                               000426 automatic       fixed bin(71,0)          initial dcl 416 set ref 416*
date                                                   builtin function         dcl 108 ref 176 176
deckfile_dir                    001176 automatic       char(168)                unaligned dcl 329 set ref 349* 351 351*
decode_clock_value_             000014 constant        entry                    external dcl 44 ref 403
desc_array                             based           fixed bin(17,0)          array dcl 6-24 ref 309
desc_arrayp               4            based           pointer                  level 2 dcl 6-8 set ref 290* 309 320*
descrip                   1            based           fixed bin(35,0)          level 3 dcl 2-41 set ref 309*
dev_0_valid               4            based           bit(1)                   array level 3 dcl 451 ref 462
dir                                    parameter       char(168)                unaligned dcl 330 set ref 327 333* 338
divide                                                 builtin function         dcl 108 ref 241 260
dom                             000167 automatic       fixed bin(17,0)          dcl 87 set ref 403* 405 405*
dow                             000171 automatic       fixed bin(17,0)          dcl 87 set ref 403*
ename                           000310 automatic       char(32)                 unaligned dcl 96 set ref 230* 234* 235* 237* 271*
                                                                                  291 292 361
escape_cnt                      000205 automatic       fixed bin(17,0)          dcl 93 set ref 187* 191 193* 193 195 203* 205* 216*
exec                                   parameter       char(6)                  unaligned dcl 80 set ref 169 176*
first_head                6            based           structure                array level 3 unaligned dcl 6-27
fixed                                                  builtin function         dcl 108 ref 196 208
flags                                  based           structure                level 3 in structure "gk_info" dcl 2-41 in procedure
                                                                                  "tolts_util_"
flags                                  based           structure                level 2 in structure "common_sl_info" dcl 6-8
                                                                                  in procedure "tolts_util_"
get_default_wdir_               000020 constant        entry                    external dcl 45 ref 235
get_wdir_                       000016 constant        entry                    external dcl 45 ref 234 248 275
gk_header                              based           structure                level 1 unaligned dcl 2-46
gk_info                                based           structure                level 1 unaligned dcl 2-41
gk_info_ptr                     001074 automatic       pointer                  dcl 2-63 set ref 304* 306 307 309 315
gki                             000363 automatic       bit(36)                  array unaligned dcl 104 set ref 304 305* 310 310
hbound                                                 builtin function         dcl 108 ref 156
hcs_$fs_get_path_name           000022 constant        entry                    external dcl 46 ref 349
hcs_$initiate_count             000024 constant        entry                    external dcl 47 ref 234 235 237
hcs_$status_minf                000026 constant        entry                    external dcl 48 ref 333
hcs_$status_mins                000030 constant        entry                    external dcl 49 ref 401
header                                 based           structure                level 2 unaligned dcl 2-41
hi_sl_info                             based           structure                level 1 unaligned dcl 6-27
i                               000202 automatic       fixed bin(17,0)          dcl 93 set ref 156* 160* 163 189* 190* 308* 309 315*
                                                                                  405* 460* 460* 462
in                                     parameter       bit                      unaligned dcl 76 ref 184 190
info                            000337 automatic       bit(36)                  array unaligned dcl 103 set ref 272 273* 293 293 321
                                                                                  321
info_ptr                        000326 automatic       pointer                  dcl 99 set ref 272* 286 287 288 289 290 291 291 292
                                                                                  292 303 308 309 317 318 319 320
input_desc                0(01)        based           bit(1)                   level 4 packed unaligned dcl 2-41 set ref 306*
interval                  6            based           structure                array level 2 unaligned dcl 6-27
ioa_                            000032 constant        entry                    external dcl 50 ref 176 351 422 431
ioa_$nnl                        000034 constant        entry                    external dcl 50 ref 140
ioa_$rsnnl                      000036 constant        entry                    external dcl 50 ref 405
iocbp                           000332 automatic       pointer                  dcl 99 set ref 229* 247 258 270* 274 280 280 285
                                                                                  293* 298* 310* 321* 338* 341* 346* 362* 366*
iox_$attach_name                000044 constant        entry                    external dcl 52 ref 338
iox_$control                    000050 constant        entry                    external dcl 54 ref 293 310 321 346 366
iox_$get_line                   000042 constant        entry                    external dcl 51 ref 144
iox_$open                       000046 constant        entry                    external dcl 53 ref 341
iox_$position                   000052 constant        entry                    external dcl 55 ref 298
iox_$seek_key                   000054 constant        entry                    external dcl 56 ref 362
iox_$user_input                 000062 external static pointer                  dcl 63 set ref 144*
j                               000203 automatic       fixed bin(17,0)          dcl 93 set ref 157* 158 159* 160 161 200* 211* 212
                                                                                  212
key                       3            based           char                     level 2 packed unaligned dcl 2-41 ref 315
key_len                   2            based           fixed bin(17,0)          level 3 dcl 2-41 ref 315
kptr                      7            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  unaligned dcl 6-27 in procedure "tolts_util_" set
                                                                                  ref 292*
kptr                     11            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  unaligned dcl 6-27 in procedure "tolts_util_" set
                                                                                  ref 292*
last_head                10            based           structure                array level 3 unaligned dcl 6-27
length                    6            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 6-27
                                                                                  in procedure "tolts_util_" set ref 291*
length                                                 builtin function         dcl 108 in procedure "tolts_util_" ref 140 144 144
                                                                                  157 212 291
length                   10            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 6-27
                                                                                  in procedure "tolts_util_" set ref 291*
lib_dir                         000000 constant        char(168)                initial unaligned dcl 125 set ref 237* 249* 276* 351
list_type                              based           fixed bin(3,0)           level 3 packed unaligned dcl 6-8 set ref 287* 317*
lp                              000204 automatic       fixed bin(17,0)          dcl 93 set ref 155* 156 157 158* 158 159 160 161*
                                                                                  161 196* 197 197* 198 200
ltrim                                                  builtin function         dcl 108 ref 157
mess                                   parameter       char                     unaligned dcl 69 set ref 136 140 140*
model                     1            based           fixed bin(17,0)          array level 3 dcl 451 ref 460
month                           000166 automatic       fixed bin(17,0)          dcl 87 set ref 403* 405 405*
n_keys                                 based           fixed bin(17,0)          level 2 dcl 115 set ref 303*
names                     1            based           structure                array level 2 dcl 451
nnames                          001073 automatic       fixed bin(17,0)          dcl 449 set ref 459*
null                                                   builtin function         dcl 108 ref 227 235 237 239 247 274 280 290 320 338
                                                                                  338 380 389
o_info                          000100 automatic       structure                level 1 unaligned dcl 86 set ref 402 402
object_info                            based           structure                level 1 dcl 3-6
object_info_$display            000056 constant        entry                    external dcl 57 ref 402
opn_ksi                         000135 constant        fixed bin(17,0)          initial dcl 122 set ref 341*
opr_query_                      000060 constant        entry                    external dcl 58 ref 430 435
opr_query_info                  001076 automatic       structure                level 1 dcl 4-8 set ref 430 430 435 435
out                                    parameter       varying char             dcl 77 set ref 184 186* 198* 198 201* 201 211 212*
                                                                                  212 212 215* 215
output_descriptors        0(05)        based           bit(1)                   level 3 packed unaligned dcl 6-8 set ref 288*
prim                      2     001076 automatic       char(8)                  level 2 dcl 4-8 set ref 426*
ptr                                                    builtin function         dcl 108 ref 399
q_sw                      1     001076 automatic       bit(1)                   level 2 dcl 4-8 set ref 425* 434*
r_comment                33     001076 automatic       char(64)                 level 2 dcl 4-8 set ref 428*
rcode                                  parameter       fixed bin(35,0)          dcl 71 set ref 225 228* 252* 262* 267 269* 279* 295*
                                                                                  300* 312*
rec_len                         000206 automatic       fixed bin(21,0)          dcl 94 set ref 144* 149 150 151 156 157 158 362*
record_length             2     000410 automatic       fixed bin(21,0)          level 2 dcl 113 set ref 260
record_ptr                4     000410 automatic       pointer                  level 2 dcl 113 set ref 259 349*
reset_pos                 0(18)        based           bit(1)                   level 4 packed unaligned dcl 2-41 set ref 307*
reverse                                                builtin function         dcl 108 ref 211
rk_header                              based           structure                level 1 unaligned dcl 2-26
rs_info                                based           structure                level 1 dcl 5-6
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 5-44 ref 345 365
rsi                             000410 automatic       structure                level 1 dcl 113 set ref 344* 346 346 364* 366 366
rtrim                                                  builtin function         dcl 108 ref 140 291 338
search                                                 builtin function         dcl 108 ref 159
seek_key                        000207 automatic       varying char(256)        dcl 95 set ref 361* 362*
seg_name                               parameter       entry variable           dcl 67 ref 395 399
seg_ptr                         000330 automatic       pointer                  dcl 99 set ref 399* 401* 402*
sl_info_version_0                      constant        fixed bin(17,0)          initial dcl 6-43 ref 286
state                                  parameter       char(3)                  unaligned dcl 81 set ref 169 176*
subset_no                 2            based           fixed bin(17,0)          level 2 dcl 6-8 set ref 318*
substr                                                 builtin function         dcl 108 set ref 149* 157 159 160 176 176 190 208 212
                                                                                  424 430 430 435 435
temp_ptr                        000324 automatic       pointer                  dcl 99 set ref 227* 234* 235 235* 237 237* 239 240
tim                             000320 automatic       char(12)                 unaligned dcl 97 set ref 172* 176 176
time                                                   builtin function         dcl 108 ref 172
tod                             000172 automatic       fixed bin(71,0)          dcl 88 set ref 403*
tolts_util_$query               000066 constant        entry                    external dcl 415 ref 423
ttl                             000176 automatic       char(6)                  unaligned dcl 90 set ref 405* 406
ttl_date                               parameter       char(6)                  unaligned dcl 82 set ref 169 176* 395 406*
type                            000201 automatic       fixed bin(2,0)           dcl 92 in procedure "tolts_util_" set ref 401*
type                            001250 automatic       fixed bin(2,0)           initial dcl 331 in procedure "find_deckfile" set ref
                                                                                  331* 333* 334
unspec                                                 builtin function         dcl 108 set ref 273* 305* 344* 364*
verify                                                 builtin function         dcl 108 ref 211
version                         000410 automatic       fixed bin(17,0)          level 2 in structure "rsi" dcl 113 in procedure
                                                                                  "tolts_util_" set ref 345* 365*
version                   0(18)        based           fixed bin(17,0)          level 3 in structure "common_sl_info" packed
                                                                                  unaligned dcl 6-8 in procedure "tolts_util_" set
                                                                                  ref 286*
version_number                  000100 automatic       fixed bin(17,0)          level 2 dcl 86 set ref 400*
word                                   based           char(4)                  level 2 dcl 1-13 set ref 384 385
year                            000170 automatic       fixed bin(17,0)          dcl 87 set ref 403* 404* 404 405*
zone                            000174 automatic       char(3)                  unaligned dcl 89 set ref 403*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONFIG_DECIMAL_TYPE                    internal static bit(2)                   initial dcl 1-23
CONFIG_OCTAL_TYPE                      internal static bit(2)                   initial dcl 1-23
CONFIG_SINGLE_CHAR_TYPE                internal static bit(2)                   initial dcl 1-23
CONFIG_STRING_TYPE                     internal static bit(2)                   initial dcl 1-23
Directory                              internal static fixed bin(17,0)          initial dcl 7-56
EMPTY_FIELD                            internal static bit(36)                  initial dcl 1-34
FREE_CARD_WORD                         internal static char(4)                  initial dcl 1-29
Link                                   internal static fixed bin(17,0)          initial dcl 7-56
Segment                                internal static fixed bin(17,0)          initial dcl 7-56
VALID_CARD_WORD_CHARACTERS             internal static char(38)                 initial unaligned dcl 1-31
ZERO_CARD_WORD                         internal static char(4)                  initial dcl 1-28
ak_info                                based           structure                level 1 unaligned dcl 2-6
ak_info_ptr                            automatic       pointer                  dcl 2-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 2-19
config_deck                            based           structure                level 1 dcl 1-9
config_max_cards                       automatic       fixed bin(17,0)          dcl 1-5
config_n_cards                         automatic       fixed bin(17,0)          dcl 1-4
configp                                automatic       pointer                  dcl 1-3
da_sl_info                             based           structure                level 1 unaligned dcl 6-38
gk_info_version_0                      internal static fixed bin(17,0)          initial dcl 2-66
gk_key_len                             automatic       fixed bin(17,0)          dcl 2-64
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 3-60
rk_info                                based           structure                level 1 unaligned dcl 2-22
rk_info_ptr                            automatic       pointer                  dcl 2-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 2-38
rs_desc                                based           structure                level 1 packed unaligned dcl 5-32
rs_info_ptr                            automatic       pointer                  dcl 5-5
rs_info_version_1                      internal static fixed bin(17,0)          initial dcl 5-43
seq_desc                               based           structure                level 1 packed unaligned dcl 5-37
sl_array_limit                         automatic       fixed bin(17,0)          dcl 6-42
status_area_ptr                        automatic       pointer                  dcl 7-47
status_branch                          based           structure                level 1 dcl 7-8
status_entry_names                     based           char(32)                 array dcl 7-47
status_link                            based           structure                level 1 dcl 7-38
status_pathname                        based           char                     dcl 7-47
status_ptr                             automatic       pointer                  dcl 7-47

NAMES DECLARED BY EXPLICIT CONTEXT.
bci_to_ascii                    000753 constant        entry                    external dcl 184
cata_sel                        001524 constant        entry                    external dcl 267
dev0_valid                      002637 constant        entry                    external dcl 446
find_card                       002137 constant        entry                    external dcl 374
find_deckfile                   002726 constant        entry                    internal dcl 327 ref 248 249 275 276
find_record                     003256 constant        entry                    internal dcl 359 ref 256
get_ttl_date                    002227 constant        entry                    external dcl 395
m_retry                         000361 constant        label                    dcl 140 ref 147
on_off                          000634 constant        entry                    external dcl 169
opr_msg                         002426 constant        entry                    external dcl 413
query                           000322 constant        entry                    external dcl 136
search                          001171 constant        entry                    external dcl 225
tolts_util_                     000304 constant        entry                    external dcl 39
use_char                        001102 constant        label                    dcl 208 set ref 191

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4320        4410    3762        4330
Length      5004    3762        70         357     335           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tolts_util_                         898 external procedure  is an external procedure.  
find_deckfile                           internal procedure  shares stack frame of external procedure tolts_util_.  
find_record                             internal procedure  shares stack frame of external procedure tolts_util_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tolts_util_              000100 o_info                      tolts_util_
                         000166 month                       tolts_util_
                         000167 dom                         tolts_util_
                         000170 year                        tolts_util_
                         000171 dow                         tolts_util_
                         000172 tod                         tolts_util_
                         000174 zone                        tolts_util_
                         000176 ttl                         tolts_util_
                         000200 bc                          tolts_util_
                         000201 type                        tolts_util_
                         000202 i                           tolts_util_
                         000203 j                           tolts_util_
                         000204 lp                          tolts_util_
                         000205 escape_cnt                  tolts_util_
                         000206 rec_len                     tolts_util_
                         000207 seek_key                    tolts_util_
                         000310 ename                       tolts_util_
                         000320 tim                         tolts_util_
                         000323 cc                          tolts_util_
                         000324 temp_ptr                    tolts_util_
                         000326 info_ptr                    tolts_util_
                         000330 seg_ptr                     tolts_util_
                         000332 iocbp                       tolts_util_
                         000334 cur_char                    tolts_util_
                         000335 bit_cnt                     tolts_util_
                         000336 code                        tolts_util_
                         000337 info                        tolts_util_
                         000363 gki                         tolts_util_
                         000410 rsi                         tolts_util_
                         000426 d                           tolts_util_
                         000430 c_string                    tolts_util_
                         000471 clen                        tolts_util_
                         000472 c_cnt                       tolts_util_
                         000473 cargs                       tolts_util_
                         001073 nnames                      tolts_util_
                         001074 gk_info_ptr                 tolts_util_
                         001076 opr_query_info              tolts_util_
                         001176 deckfile_dir                find_deckfile
                         001250 type                        find_deckfile

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
signal_op           shorten_stack       ext_entry           ext_entry_desc      set_chars_eis       index_before_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      decode_clock_value_           get_default_wdir_             get_wdir_
hcs_$fs_get_path_name         hcs_$initiate_count           hcs_$status_minf              hcs_$status_mins
ioa_                          ioa_$nnl                      ioa_$rsnnl                    iox_$attach_name
iox_$control                  iox_$get_line                 iox_$open                     iox_$position
iox_$seek_key                 object_info_$display          opr_query_                    pl1_date_
pl1_time_                     tolts_util_$query

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
config_deck$                  iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    416 000277        39 000303       136 000314       138 000343       139 000345       140 000361       143 000410
    144 000415       145 000440       146 000442       147 000471       149 000472       150 000505       151 000507
    155 000520       156 000522       157 000532       158 000547       159 000552       160 000572       161 000610
    162 000613       163 000615       164 000621       169 000630       172 000647       176 000656       179 000740
    184 000747       186 000776       187 001001       189 001002       190 001011       191 001020       193 001023
    195 001030       196 001032       197 001034       198 001040       200 001053       201 001061       202 001072
    203 001074       204 001075       205 001076       208 001102       210 001110       211 001115       212 001131
    215 001142       216 001152       218 001153       220 001155       225 001164       227 001206       228 001212
    229 001214       230 001217       234 001223       235 001274       237 001351       239 001417       240 001423
    241 001426       242 001431       247 001440       248 001444       249 001455       251 001461       252 001463
    253 001464       256 001473       257 001474       258 001476       259 001501       260 001503       261 001506
    262 001507       263 001510       267 001517       269 001537       270 001540       271 001544       272 001550
    273 001552       274 001555       275 001561       276 001572       278 001576       279 001600       280 001601
    282 001610       285 001617       286 001622       287 001625       288 001631       289 001633       290 001636
    291 001640       292 001653       293 001657       294 001707       295 001711       296 001712       298 001721
    299 001741       300 001743       301 001744       303 001753       304 001760       305 001762       306 001765
    307 001767       308 001771       309 001777       310 002004       311 002034       312 002036       313 002037
    315 002046       316 002061       317 002063       318 002067       319 002071       320 002072       321 002074
    322 002124       374 002133       380 002147       382 002160       384 002164       385 002171       387 002206
    388 002211       389 002212       390 002214       395 002223       399 002242       400 002247       401 002251
    402 002267       403 002306       404 002331       405 002333       406 002412       407 002416       413 002425
    422 002436       423 002452       424 002504       425 002511       426 002513       427 002515       428 002516
    429 002521       430 002526       431 002553       432 002573       434 002574       435 002575       436 002623
    437 002624       446 002633       459 002646       460 002652       461 002670       462 002672       463 002713
    327 002726       331 002730       333 002731       334 002777       338 003002       339 003100       341 003104
    342 003123       344 003126       345 003131       346 003133       347 003167       349 003172       351 003224
    355 003255       359 003256       361 003257       362 003264       363 003301       364 003303       365 003306
    366 003310       369 003344


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
