	COMPILATION LISTING OF SEGMENT dfm_util_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/21/92  1020.2 mdt Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1989                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        8*        *                                                         *
        9*        *********************************************************** */
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-08-21,Fakoury), approve(86-08-21,MCR7515),
       13*     audit(87-01-07,Farley), install(87-01-08,MR12.0-1263):
       14*     Originally coded 0682 by Rick Fakoury for MR12.
       15*  2) change(87-01-13,Fakoury), approve(87-01-13,MCR7515),
       16*     audit(87-01-14,Martinson), install(87-01-14,MR12.0-1278):
       17*     PBF to correct a missing blank else statement in ck_applic.
       18*  3) change(87-01-22,Fakoury), approve(87-01-22,MCR7515),
       19*     audit(87-01-22,Martinson), install(87-01-23,MR12.0-1291):
       20*     Fixed a problem encountered merging a deckfile that contained a patch.
       21*  4) change(88-05-30,Fakoury), approve(90-10-03,MCR8147),
       22*     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
       23*     to Fixed a bug in the merging of a deleted file.
       24*  5) change(89-02-06,Fakoury), approve(90-10-03,MCR8147),
       25*     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
       26*     to to increase block count size and to allow a tape copy to be run
       27*     without using a deck_file or list segment.
       28*  6) change(89-06-01,Fakoury), approve(90-10-03,MCR8147),
       29*     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
       30*     to to increase the size of att_desc from 64 to 181 for TR21336.
       31*  7) change(90-10-30,Fakoury), approve(90-11-28,MCR8219),
       32*     audit(90-11-28,Schroth), install(90-11-28,MR12.4-1051):
       33*     PBF correction to previous installation: correct and cleanup logic in
       34*     ck_applic internal proc.
       35*                                                   END HISTORY COMMENTS */
       36 
       37 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
       38 dfm_util_: proc ();
       39 
       40       return;					/* not a valid entry */
       41 
       42 
       43 /* AUTOMATIC */
       44 
       45 dcl  at_bot bit (1);
       46 dcl  att_desc char (181);
       47 dcl  bcard bit (540);				/* binary card */
       48 dcl  bcnt fixed bin (18);				/* block count */
       49 dcl  bcwp ptr;					/* block cont word p */
       50 dcl  bit_count fixed bin (24);
       51 dcl  c_rtrycnt fixed bin;				/* copy retry count */
       52 dcl  cbcwp ptr;					/* current block cont word ptr */
       53 dcl  cden char (5);					/* copy density */
       54 dcl  code fixed bin (35);
       55 dcl  cx fixed bin;					/* catalog index */
       56 dcl  cvp ptr;					/* convert ptr */
       57 dcl  cvp1 ptr;					/* cpnvert ptr hold */
       58 dcl  dk_end bit (1);
       59 dcl  dk_type char (6);
       60 dcl  dkend_card char (80);
       61 dcl  ename char (32);				/* entry name */
       62 dcl  file_found bit (1);
       63 dcl  first_patch bit (1);
       64 dcl  first_rcd bit (1);				/* first record */
       65 dcl  glrp ptr;					/* gcos log rec ptr */
       66 dcl  glrbp ptr;					/* gcos logical record block ptr */
       67 dcl  gki (20) bit (36);
       68 dcl  gprp ptr;					/* gcos physical record ptr */
       69 dcl  header_key char (24) varying;
       70 dcl  hbuff_len fixed bin (21);			/* header buffer length */
       71 dcl  i fixed bin;
       72 dcl  id_ld bit (1);
       73 dcl  ident_buf (40) bit (36) aligned;			/* load buffer */
       74 dcl  info (20) bit (36);
       75 dcl  info_ptr ptr;
       76 dcl  iocbp ptr;
       77 dcl  j fixed bin;
       78 dcl  k fixed bin;
       79 dcl  lbuff_len fixed bin (21);			/* line buffer length */
       80 dcl  line_count fixed bin;
       81 dcl  lx fixed bin;					/* load index */
       82 dcl  m fixed bin;
       83 dcl  merge_key char (24) varying;
       84 dcl  mode fixed bin;
       85 dcl  mvp ptr;					/* move ptr */
       86 dcl  nbcwp ptr;					/* new blk cont wrd ptr */
       87 dcl  new_iocbp ptr;
       88 dcl  npatches fixed bin;				/* num of patches */
       89 dcl  nwds fixed bin;				/* num of words */
       90 dcl  obj_card_found bit (1);
       91 dcl  ocardp ptr;					/* octal card ptr */
       92 dcl  old_iocbp ptr;
       93 dcl  patch_key char (24) varying;
       94 dcl  pbuf_size fixed bin (21);			/* patch buffer size */
       95 dcl  pptr ptr;					/* patch ptr */
       96 dcl  psz fixed bin;					/* pad size */
       97 dcl  px fixed bin;					/* patch index */
       98 dcl  rcode fixed bin (35);
       99 dcl  rec_len fixed bin (21);
      100 dcl  rtrycnt fixed bin;
      101 dcl  scode fixed bin (35);
      102 dcl  segp ptr;
      103 dcl  svp ptr;
      104 dcl  sw_name char (64);
      105 dcl  t_stat bit (12) aligned;
      106 dcl  term bit (1);
      107 dcl  type fixed bin (2);
      108 dcl  user_access fixed bin (5);
      109 dcl  v_patch bit (1);				/* valid patch */
      110 dcl  wcatp ptr;
      111 dcl  wksp ptr;
      112 dcl  work_key char (24) varying;
      113 dcl  yes_sw bit (1);
      114 
      115 
      116 /* BUILTINS */
      117 
      118 dcl  addr builtin;
      119 dcl  addrel builtin;
      120 dcl  after builtin;
      121 dcl  before builtin;
      122 dcl  bin builtin;
      123 dcl  char builtin;
      124 dcl  convert builtin;
      125 dcl  currentsize builtin;
      126 dcl  fixed builtin;
      127 dcl  index builtin;
      128 dcl  hbound builtin;
      129 dcl  lbound builtin;
      130 dcl  length builtin;
      131 dcl  ltrim builtin;
      132 dcl  null builtin;
      133 dcl  ptr builtin;
      134 dcl  rel builtin;
      135 dcl  rtrim builtin;
      136 dcl  string builtin;
      137 dcl  substr builtin;
      138 dcl  translate builtin;
      139 dcl  unspec builtin;
      140 dcl  verify builtin;
      141 
      142 
      143 /* CONSTANTS */
      144 
      145 dcl  bcd_dkend bit (72) int static options (constant) init
      146       ("532020202020202442254524"b3);			/* "$      dkend" in bcd */
      147 dcl  bcd_media_code fixed bin (4) int static options (constant) init (2);
      148 dcl  bcd_obj bit (78) int static options (constant) init
      149       ("53202020202020462241252363"b3);			/* "$      object" in bcd */
      150 dcl  binary_media_code fixed bin (4) int static options (constant) init (1);
      151 dcl  bof fixed bin int static options (constant) init (-1); /* beginning of file */
      152 dcl  buf_size fixed bin (21) int static options (constant) init (4 * 1024); /* 1k buffer is plenty */
      153 dcl  current_ring fixed bin int static options (constant) init (-1);
      154 dcl  density (5) char (5) int static options (constant) init
      155       ("d6250", "d1600", "d800", "d556", "d200");
      156 
      157 dcl  false bit (1) int static options (constant) init ("0"b);
      158 dcl  fnp_355_edit_name char (4) int static options (constant) init ("0300");
      159 dcl  fnp_355_type char (4) int static options (constant) init ("6600");
      160 dcl  fnp_18x_edit_name char (4) int static options (constant) init ("2000");
      161 dcl  fnp_6670_type char (4) int static options (constant) init ("6670");
      162 dcl  fmt1 char (53) int static options (constant) init
      163       ("^[^5-^12s^; ^[^6x^1s^;^6a^]  ^4a  ^4a  ^2a/^2a/^2a  ");
      164 dcl  fmt2 char (33) int static options (constant) init
      165       ("^[^6a  ^6a   ^2a^s^;^3s^4a^2-^]^]");
      166 dcl  fmt3 char (62) int static options (constant) init
      167       ("^-^[    ^[^;^[yes^;no ^]^]^;^2s^64t^24a   ^2d   ^6o    ^8d^]^/");
      168 dcl  g_label bit (72) int static options (constant) init	/* = "ge  600 btl " in bcd */
      169       ("272520200600002022634320"b3);
      170 
      171 dcl  hdra char (18) int static options (constant) init ("Edit  Deck    Assm");
      172 dcl  hdrb char (42) int static options (constant) init
      173       ("N__a_m_e  T__y_p_e    D__a_t_e");
      174 dcl  hdra1 char (5) int static options (constant) init ("Ident");
      175 dcl  hdrb1 char (46) int static options (constant) init
      176       ("C__o_d_e    M__o_d_e_l   R__e_v._");
      177 dcl  hdrb2 char (12) int static options (constant) init ("T__y_p_e");
      178 dcl  hdrb3 char (111) int static options (constant) init
      179       ("S__e_a_r_c_h K__e_y         C__o_m_p  O__f_f_s_e_t  L__e_n_g_t_h (_B__y_t_e_s)_");
      180 dcl  hdra2 char (2) int static options (constant) init ("SS");
      181 dcl  hdra3 char (40) int static options (constant) init
      182       ("Record             Location       Record");
      183 dcl  hdra4 char (7) int static options (constant) init ("Multics");
      184 dcl  hdrb4 char (30) int static options (constant) init
      185       ("A__p_p_l_i_c_a_b_l_e");
      186 
      187 dcl  max_retrys fixed bin int static options (constant) init (10);
      188 dcl  mpcbot bit (36) int static options (constant) init ("444723224663"b3);
      189 
      190 dcl  NL char (1) int static options (constant) init ("
      191 ");
      192 dcl  no_chase_sw fixed bin (1) int static options (constant) init (0);
      193 dcl  no_type fixed bin (2) int static options (constant) init (-1);
      194 
      195 dcl  print bit (1) int static options (constant) init ("0"b);
      196 dcl  rec_cont_wrd bit (36) int static options (constant) init
      197       ("000016000200"b3);
      198 dcl  sys_dir char (21) int static options (constant) init
      199       (">system_library_tandd");
      200 dcl  true bit (1) int static options (constant) init ("1"b);
      201 
      202 dcl  whitespace char (2) int static options (constant) init /* TAB and SPACE */
      203       ("	 ");
      204 dcl  wrapup bit (1) int static options (constant) init ("1"b);
      205 
      206 
      207 /* BASED and STRUCTURES */
      208 
      209 
      210 dcl  1 bcw based (bcwp) aligned,
      211        (2 bsn fixed bin (18),
      212        2 blk_size fixed bin (18)) unsigned unaligned;
      213 
      214 dcl  bit_buf bit (rec_len * 9) based (gprp);
      215 
      216 dcl  1 cur_bcw like bcw aligned based (cbcwp);
      217 
      218 dcl  data_move char (dfm_data.dlen * 4) based (dfm_data.bptr);
      219 
      220 dcl  1 catalog based (c_ptr) aligned,
      221        2 n_entries fixed bin,
      222        2 key (1 refer (catalog.n_entries)) char (24);
      223 
      224 dcl  free_area area based (get_system_free_area_ ());
      225 
      226 dcl  1 glr based (glrp) aligned like gc_log_rec;
      227 
      228 dcl  glrb bit (glr.rcw.rsize * 36) based (glrbp);
      229 
      230 dcl  1 gpr based (gprp) aligned like gc_phy_rec;
      231 
      232 
      233 dcl  id_bbuf bit (108) based (cvp);
      234 
      235 
      236 dcl  1 new_bcw like bcw aligned based (nbcwp);
      237 
      238 dcl  1 o_card based (ocardp) aligned,			/* template for an object card */
      239        (2 pad1 char (15),
      240        2 library char (6),				/* col 16 - either "hmpcj1" or "htnd  " */
      241        2 ld_type char (1),				/* col 22, module type */
      242        2 ss_type char (1),				/* col 23, subsystem type */
      243        2 pad2 char (3),
      244        2 m_applic char (1),				/* Multics applicability, non blank means not applicable */
      245        2 pad3 char (15),
      246        2 model char (6),				/* for hmpcj1 decks, controller model # */
      247        2 version char (6),				/* for hmpcj1 decks, model version # */
      248        2 pad4 char (5),
      249        2 assem char (1),				/* "m" for mpc assembler, "g" for gmap */
      250        2 call_name char (6),				/* module call name, or gecall name */
      251        2 ttl_date char (6),				/* date module assembled */
      252        2 edit_name char (4),				/* module edit name */
      253        2 pad5 char (4)) unaligned;
      254 
      255 
      256 
      257 dcl  1 p_blk aligned int static,			/* patch card image storage */
      258        2 p_cnt fixed bin,				/* number of valid patches */
      259        2 p_card (200) char (80);			/* patch card image */
      260 
      261 dcl  1 r_card based (dfm_data.cptr) aligned,		/* template for a binary card image */
      262        (2 type bit (12),				/* card type */
      263        2 count fixed bin (5),				/* number of wds controlled */
      264        2 ld_add bit (18),				/* loading address */
      265        2 pad (psz) bit (36),
      266        2 data (r_card.count) bit (36),
      267        2 nxt_c_wd bit (36)) unaligned;			/* to get nxt control wd */
      268 
      269 dcl  1 rsi like rs_info aligned;			/* auto copy of record status info */
      270 
      271 dcl  1 wcata based (wcatp),				/* working catalog */
      272        2 n_entries fixed bin,				/* number of catalog entries */
      273        2 key (1 refer (wcata.n_entries)) char (24);
      274 						/* entry search keys */
      275 
      276 
      277 /* EXTERNAL ENTRIES */
      278 
      279 dcl  add_char_offset_ entry (ptr, fixed bin (21)) returns (ptr) reducible;
      280 dcl  bcd_to_ascii_ entry options (variable);
      281 dcl  command_query_$yes_no entry () options (variable);
      282 dcl  dfm_$complain entry () options (variable);
      283 dcl  get_system_free_area_ entry () returns (ptr);
      284 dcl  gload_ entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
      285 dcl  gload_$allow_zero_checksums entry entry (char (*), char (*), char (*), ptr, ptr, fixed bin (18), ptr, fixed bin (35));
      286 dcl  hcs_$get_link_target entry (char (*), char (*), char (*), char (*), fixed bin (35));
      287 dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
      288 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      289 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      290 dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
      291 dcl  hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
      292 dcl  (ioa_, ioa_$ioa_switch, ioa_$rs) entry () options (variable);
      293 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      294 dcl  iox_$close entry (ptr, fixed bin (35));
      295 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      296 dcl  iox_$delete_record entry (ptr, fixed bin (35));
      297 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      298 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      299 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      300 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      301 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      302 dcl  iox_$rewrite_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      303 dcl  iox_$seek_key entry entry options (variable);
      304 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      305 dcl  mca_$attach_mca entry (char (*), fixed bin (71), fixed bin, fixed bin (35));
      306 dcl  mca_$detach_mca entry (fixed bin, fixed bin (35));
      307 dcl  mca_$diskette_read entry (fixed bin, char (*), fixed bin, ptr, fixed bin (21), fixed bin (21), bit (72), fixed bin (35));
      308 dcl  mca_$read_data entry (fixed bin, ptr, fixed bin (21), fixed bin (21), bit (72), fixed bin (35));
      309 dcl  opr_query_ entry () options (variable);
      310 dcl  tolts_alm_util_$ascii_to_bcd_ entry (char (*), bit (*));
      311 
      312 /* EXTERNAL */
      313 
      314 dcl  error_table_$fatal_error fixed bin (35) ext static;
      315 dcl  error_table_$noentry fixed bin (35) ext static;
      316 dcl  error_table_$no_file fixed bin (35) ext static;
      317 dcl  error_table_$no_record fixed bin (35) ext static;
      318 dcl  error_table_$end_of_info fixed bin (35) ext static;
      319 dcl  error_table_$tape_error fixed bin (35) ext static;
      320 
      321 /* PARAMETERS */
      322 
      323 dcl  P_dfm_datap ptr;
      324 
      325 
      326 
      327 
      328 /* ck_applic - entry to check for current deck Multics Applicability. If a deck is appicable, "1"b is returned.
      329*   If deck is the first deck of an "itr" a catalog build is begun */
      330 
      331 ck_applic: entry (P_dfm_datap) returns (bit (1));
      332 
      333 
      334       dfm_datap = P_dfm_datap;
      335 
      336       ocardp = addr (dfm_data.obj_card);
      337       if o_card.m_applic ^= " " then do;		/* only take deck if Multics applicable */
      338          if o_card.library = "hmpcj1" then		/* if itr deck */
      339 	  if id_blk.type = "itr" then			/* space to nxt file */
      340 	     call space_file ();			/* space to nxt file */
      341 	  else if o_card.ss_type = "h" then		/* space over heals files */
      342 	     call space_file ();			/* space to nxt file */
      343          return (false);				/* return false */
      344       end;
      345       else do;					/* Multics applicable */
      346          if o_card.library = "hmpcj1" then do;		/* if itr, mdr or firmware deck */
      347 	  if id_blk.type = "mdr" then			/* if current deck an mdr */
      348 	     if dfm_data.firmware_sw & ^dfm_data.deckfile_sw then do;
      349 	        dfm_data.eot = true;			/* and we are only loading firmware, thats it */
      350 	        return (false);
      351 	     end;
      352 	     else ;
      353 	  else if id_blk.type ^= "itr"		/* else if firmware deck */
      354 	   & dfm_data.firmware_sw then		/* and not just loading deckfile */
      355 	     call ld_fw_deck (dfm_data.bptr);		/* go load core image for BOS */
      356 	  if ^dfm_data.first_deck then do;		/* if first deck of current file */
      357 	     dfm_data.cat_build, dfm_data.first_deck = true; /* set flag so we don't come back */
      358 	     cata.n_entries = 0;			/* reset number of catalog entries */
      359 	     dfm_data.cat_key = id_blk.type || ".";	/* form suffix part of catalog key */
      360 	     if id_blk.type = "mdr" then do;		/* if building mdr catalog */
      361 	        if o_card.ss_type = "t" then dfm_data.sstype = "tape "; /* tape catalog */
      362 	        else if o_card.ss_type = "p" then dfm_data.sstype = "print"; /* printer catalog */
      363 	        else if o_card.ss_type = "c" then dfm_data.sstype = "card "; /* card catalog */
      364 	        else if o_card.ss_type = "d" then dfm_data.sstype = "disk "; /* disk catalog */
      365 	        else do;
      366 		 call dfm_$complain (dfm_datap, print, 0, /* unknown type */
      367 		  "Unknown subsystem type (col 23) on $ object card ^/Last $ object card image is: ^/""^a""",
      368 		  dfm_data.obj_card);
      369 
      370 		 dfm_data.first_deck = false;		/* check next $ object card */
      371 		 return (true);
      372 	        end;
      373 	        dfm_data.cat_key = rtrim (dfm_data.cat_key) || dfm_data.sstype; /* complete mdr catalog key */
      374 	     end;
      375 	  end;
      376          end;
      377       end;
      378       return (true);				/* return true */
      379 
      380 
      381 
      382 
      383 /* copy_eof - entry to write end of file mark on copy tape */
      384 
      385 copy_eof: entry (P_dfm_datap);
      386 
      387 
      388       dfm_datap = P_dfm_datap;
      389 
      390       call iox_$control (dfm_data.ciocb_ptr, "write_eof", null, code);
      391       dfm_data.copy_at_eof = true;			/* set copy eof flag */
      392 
      393       return;
      394 
      395 
      396 
      397 
      398 
      399 /* delete_deck - entry to delete a deck in the T & D deckfile */
      400 
      401 
      402 delete_deck: entry (P_dfm_datap, work_key, rcode);
      403 
      404 
      405       dfm_datap = P_dfm_datap;
      406 
      407       rcode = 0;					/* reset abort flag */
      408 
      409       call iox_$seek_key (dfm_data.fiocb_ptr, work_key, rec_len, code); /* set key for deletion */
      410       if code ^= 0 then do;
      411          rcode = code;
      412          return;
      413       end;
      414 
      415       call iox_$delete_record (dfm_data.fiocb_ptr, code);
      416       if code ^= 0 then do;
      417          rcode = code;
      418          return;
      419       end;
      420 
      421       term = false;
      422       allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      423       lbuff = "";
      424       dfm_data.list_key = "ls." || rtrim (work_key);
      425       call iox_$seek_key (dfm_data.fiocb_ptr, dfm_data.list_key, rec_len, code);
      426       if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
      427 	"attempting to seek key ^a ", dfm_data.list_key);
      428       call iox_$read_record (dfm_data.fiocb_ptr, dfm_data.lbuff_p, rec_len, lbuff_len, code);
      429       if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
      430 	"attempting to read a keyed record ^a", dfm_data.list_key);
      431 
      432       call ioa_$rs ("^a^86t^7a ^14a^/", lbuff, lbuff_len,
      433        substr (lbuff, 1, index (lbuff, rtrim (work_key)) + length (rtrim (work_key))),
      434        "DELETED", substr (dfm_data.time_string, 1, 14));
      435 
      436       call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p, lbuff_len, (dfm_data.list_key));
      437       free dfm_data.lbuff_p -> lbuff in (free_area);
      438       dfm_data.lbuff_p = null;
      439       return;
      440 
      441 
      442 
      443 /* detach_file -  entry to close and  detach file */
      444 
      445 detach_file: entry (P_dfm_datap, iocb_ptr);
      446 
      447 dcl  iocb_ptr ptr;
      448 
      449       dfm_datap = P_dfm_datap;
      450 
      451       call iox_$close (iocb_ptr, code);
      452       call iox_$detach_iocb (iocb_ptr, code);
      453       iocb_ptr = null;
      454 
      455 
      456       return;
      457 
      458 
      459 
      460 /* find_dkend - entry to find either a $deckend card or a patch card */
      461 
      462 find_dkend: entry (P_dfm_datap, work_key, pptr, npatches, rcode);
      463 
      464 
      465       dfm_datap = P_dfm_datap;
      466 
      467       abort, dk_end, end_file, first_rcd, first_patch = false; /* reset flags */
      468       id_ld, obj_card_found = false;
      469       p_blk.p_cnt = 0;				/* initialize patch count */
      470       cvp, cvp1 = null;
      471 
      472       call iox_$seek_key (dfm_data.fiocb_ptr, work_key, rec_len, code);
      473       if code ^= 0 then do;
      474          rcode = 0;
      475          return;
      476       end;
      477       unspec (rsi) = "0"b;
      478       rsi.version = rs_info_version_2;
      479       call iox_$control (dfm_data.fiocb_ptr, "record_status", addr (rsi), code);
      480       if code ^= 0 then do;
      481          rcode = 0;
      482          return;
      483       end;
      484       bcwp, gprp, mvp = rsi.record_ptr;
      485       cbcwp = dfm_data.bptr;
      486       pbuf_size = rec_len;
      487 
      488       do while (^dk_end);				/* loop until entire deck is read in */
      489          if ^first_rcd then do;			/* if first record of deck */
      490 	  bcnt = gpr.bcw.bsn;			/* load block serial number */
      491 	  first_rcd = true;
      492          end;
      493          else do;					/* if not first record, check BSN */
      494 	  bcnt = bcnt + 1;				/* increment our block count */
      495 	  if gpr.bcw.bsn ^= bcnt then			/* something wrong here */
      496 	     call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
      497 	      "Block serial number error at record ^d, file ^d ^/Block serial number was ^d, S/B ^d",
      498 	      dfm_data.crec, dfm_data.cfile, gpr.bcw.bsn, bcnt);
      499          end;
      500          glrp = addr (gpr.gc_phy_rec_data (1));		/* get pointer to first logical record */
      501          nwds = 0;
      502 
      503          do while (nwds < gpr.bcw.blk_size);		/* iterate through all logical records */
      504 
      505 	  if glr.rcw.media_code = 2 then do;		/* bcd card image */
      506 	     glrbp = addr (glr.gc_log_rec_data);
      507 
      508 	     if substr (glrb, 1, 78) = bcd_obj then do;	/* object card */
      509 	        call bcd_to_ascii_ (glrb, dfm_data.obj_card); /* convert to ascii */
      510 	        obj_card_found = true;		/* indicate that we have gotten object card */
      511 	        ocardp = addr (dfm_data.obj_card);
      512 	     end;
      513 
      514 	     else do;
      515 	        if o_card.library = "hmpcj1" & ^id_ld then do; /* if hmpcj1 lib and we haven't been here */
      516 		 id_ld = true;			/* set flag so we don't come back */
      517 		 if cvp1 = null then cvp1 = cvp;	/* if only 1 binary card */
      518 		 call load_ident;			/* load ident block */
      519 	        end;
      520 
      521 	        if ck_patch (glrb) then do;		/* go check for patch card */
      522 		 if ^first_patch then do;
      523 		    dfm_data.dlen = fixed (rel (glrp)) - fixed (rel (mvp));
      524 		    data_move = mvp -> data_move;	/* move data from begin to patch */
      525 		    mvp = addrel (mvp, dfm_data.dlen);
      526 		    dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
      527 		    first_patch = true;
      528 		 end;
      529 
      530 		 call command_query_$yes_no (yes_sw, 0, "Patch Deck",
      531 		  "A patch card has been found in the deck. Do you want to retain it?",
      532 		  "Patch: ^/^a^/Found in deck ^a.^/Do you wish to retain it?", dfm_data.ascii_card, work_key);
      533 
      534 		 if yes_sw then do;
      535 		    dfm_data.dlen = glr.rcw.rsize + 1;	/* move the patch */
      536 		    data_move = mvp -> data_move;
      537 		    mvp = addrel (mvp, dfm_data.dlen);
      538 		    dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
      539 		 end;
      540 
      541 		 else do;
      542 		    mvp = addrel (mvp, glr.rcw.rsize + 1); /* adjust the ptr past the patch */
      543 		    call remove_patch;
      544 		 end;
      545 	        end;
      546 
      547 
      548 	        if substr (glrb, 1, 72) = bcd_dkend then do; /* dkend card */
      549 		 call bcd_to_ascii_ (glrb, dkend_card); /* convert to ascii */
      550 		 dk_end = true;
      551 		 if ^first_patch then do;
      552 		    dfm_data.dlen = fixed (rel (glrp)) - fixed (rel (mvp));
      553 		    data_move = mvp -> data_move;
      554 		    mvp = addrel (mvp, dfm_data.dlen);
      555 		    dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
      556 		 end;
      557 		 if npatches > 0 then do i = 1 to npatches;
      558 		    if dfm_data.opatches (i).type = "octal"
      559 		     | dfm_data.opatches (i).type = "mask " then do;
      560 		       dfm_data.opatches (i).dtime = dfm_data.gtime_string;
      561 		       dfm_data.opatches (i).label = o_card.edit_name;
      562 		       call tolts_alm_util_$ascii_to_bcd_ (string (dfm_data.opatches (i)), bcard);
      563 		       if ^ck_patch (bcard) then
      564 			call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
      565 			 "patch: ^/^a^/ is an invalid patch");
      566 		       bcard = rec_cont_wrd || substr (bcard, 1, 504);
      567 		       mvp = addr (bcard);
      568 		       dfm_data.dlen = 15;
      569 		       data_move = mvp -> data_move;
      570 		       dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
      571 		    end;
      572 		    else if substr (dfm_data.hpatches (i).type, 2) = "hex" then do;
      573 		       dfm_data.hpatches (i).dtime = dfm_data.gtime_string;
      574 		       dfm_data.hpatches (i).lbl = o_card.edit_name;
      575 		       dfm_data.hpatches (i).prg_id = string (id_blk.revision);
      576 		       dfm_data.hpatches (i).rev = string (id_blk.revision);
      577 		       dfm_data.hpatches (i).lbl = o_card.edit_name;
      578 		       call tolts_alm_util_$ascii_to_bcd_ (string (dfm_data.hpatches (i)), bcard);
      579 		       if ^ck_patch (bcard) then
      580 			call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
      581 			 "patch: ^/^a^/ is an invalid patch", dfm_data.opatches (i));
      582 		       bcard = rec_cont_wrd || substr (bcard, 1, 504);
      583 		       mvp = addr (bcard);
      584 		       dfm_data.dlen = 15;
      585 		       data_move = mvp -> data_move;
      586 		       dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
      587 		    end;
      588 		 end;
      589 		 substr (dkend_card, 67, 6) = dfm_data.gtime_string;
      590 		 call tolts_alm_util_$ascii_to_bcd_ (dkend_card, bcard);
      591 		 bcard = rec_cont_wrd || substr (bcard, 1, 504);
      592 		 mvp = addr (bcard);
      593 		 dfm_data.dlen = 15;
      594 		 data_move = mvp -> data_move;
      595 		 dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
      596 		 nbcwp = dfm_data.bptr;
      597 		 new_bcw.blk_size = (fixed (rel (dfm_data.bptr)) - 1) - fixed (rel (cbcwp));
      598 		 if new_bcw.blk_size > 308 then do;
      599 		    cur_bcw.blk_size = 308;
      600 		    new_bcw.blk_size = new_bcw.blk_size - 308;
      601 		    new_bcw.bsn = cur_bcw.bsn + 1;
      602 		 end;
      603 		 else cur_bcw.blk_size = new_bcw.blk_size;
      604 		 call insert_deck (dfm_datap, dfm_data.fiocb_ptr,
      605 		  ptr (dfm_data.bptr, 0), fixed (rel (dfm_data.bptr)) * 4, work_key);
      606 		 if o_card.library = "hmpcj1"
      607 		  & id_blk.type ^= "itr" then
      608 		    call ld_fw_deck (ptr (dfm_data.bptr, 0));
      609 		 term = false;
      610 		 dfm_data.list_key = "ls." || rtrim (work_key);
      611 		 allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      612 		 lbuff = "";
      613 		 call iox_$control (dfm_data.fiocb_ptr, "record_status", addr (rsi), code);
      614 		 call iox_$seek_key (dfm_data.fiocb_ptr, rtrim (dfm_data.list_key), rec_len, code);
      615 		 if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
      616 		     "attempting to seek key ^a ", rtrim (dfm_data.list_key));
      617 		 call iox_$read_record (dfm_data.fiocb_ptr, dfm_data.lbuff_p, rec_len, lbuff_len, code);
      618 		 if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
      619 		     "attempting to read a keyed record ^a", rtrim (dfm_data.list_key));
      620 		 call ioa_$rs ("^a^86t^2d^90t^6o^103t^8d^[  PATCHED  ^14a^;^s]^/", lbuff, lbuff_len,
      621 		  substr (lbuff, 1, index (lbuff, rtrim (work_key)) + length (rtrim (work_key))),
      622 		  addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18),
      623 		  rsi.record_length, (p_blk.p_cnt > 0), substr (dfm_data.time_string, 1, 20));
      624 		 call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p,
      625 		  lbuff_len, (dfm_data.list_key));
      626 		 free dfm_data.lbuff_p -> lbuff in (free_area);
      627 		 dfm_data.lbuff_p = null;
      628 		 if p_blk.p_cnt > 0 then
      629 		    call put_patch;
      630 		 term = true;
      631 	        end;
      632 	     end;
      633 	  end;
      634 
      635 	  else if glr.rcw.media_code = 1 then		/* binary card image */
      636 	     if ^obj_card_found then			/* but no $ object card yet */
      637 	        call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
      638 	         "Binary card image preceeds $ object card at record ^d, file ^d",
      639 	         dfm_data.crec, dfm_data.cfile);
      640 
      641 	     else do;
      642 	        cvp1 = cvp;				/* save ptr to last logical record */
      643 	        cvp = glrp;				/* save ptr to current logical record */
      644 	     end;
      645 	  else call dfm_$complain (dfm_datap, wrapup,	/* not a bcd or binary card image */
      646 	        error_table_$fatal_error, "Card type ^o detected at record ^d, file ^d",
      647 	        glr.rcw.media_code, dfm_data.crec, dfm_data.cfile);
      648 	  nwds = nwds + glr.rcw.rsize + 1;		/* increment number of words */
      649 	  glrp = addrel (glrp, currentsize (glr));	/* set next logical record */
      650          end;
      651          dfm_data.crec = dfm_data.crec + 1;		/* increment current record number */
      652          gprp = addrel (gprp, currentsize (gpr));		/* append next block */
      653          cbcwp = addrel (cbcwp, bcw.blk_size + 1);
      654          bcwp = gprp;
      655       end;
      656 
      657       return;
      658 
      659 
      660 
      661 
      662 
      663 /* find_file - entry to find the correct file */
      664 
      665 find_file: entry (P_dfm_datap, d_name, e_name);
      666 
      667 dcl  e_name char (*);
      668 dcl  d_name char (*);
      669 
      670       dfm_datap = P_dfm_datap;
      671 
      672       type = no_type;				/* set to novalid value */
      673       file_found = false;
      674       yes_sw = false;
      675       term = false;
      676 
      677       do while (^term);
      678          call hcs_$status_minf (d_name, e_name, no_chase_sw, type, bit_count, code);
      679          if code ^= 0 then do;			/* err or noentry */
      680 	  if code ^= error_table_$noentry then		/* error */
      681 	     call dfm_$complain (dfm_datap, wrapup, code, "looking for ^a in ^a", e_name, d_name);
      682 	  else do;				/* no entry */
      683 	     if accessible (d_name, "", SMA_ACCESS_BIN) then do; /* dir access? */
      684 	        call command_query_$yes_no (yes_sw, 0, "Find File",
      685 	         "^a does not exist in ^a. Do you wish to create it?",
      686 	         "File ^a does not exist in ^a. ^/Create it? ", e_name, d_name);
      687 	        if yes_sw then do;			/* okey - create */
      688 		 file_found, term = true;
      689 		 if index (ename, ".list") ^= 0 then	/* if creating new list */
      690 		    dfm_data.page_no = 0;
      691 	        end;
      692 
      693 	        else if d_name ^= sys_dir then		/* haven't tried >firmware */
      694 		 d_name = sys_dir;			/* try it */
      695 	        else goto exit_ff_loop;		/* user doesn't want any of these choices */
      696 	     end;
      697 	     else goto exit_ff_loop;			/* not enough access */
      698 	  end;
      699          end;
      700 
      701          else if type = Directory then do;		/* entry exists - dir (msf) */
      702 	  if accessible (d_name, "", SMA_ACCESS_BIN) then /* dir access? */
      703 	     if d_name = sys_dir then			/* sys dir - ask */
      704 	        if accessible (d_name, e_name, RW_ACCESS_BIN)
      705 	         & ^dfm_data.list then do;
      706 		 call command_query_$yes_no (yes_sw, 0, "Find File",
      707 		  "^a does not exist in working dir. Use the one found in ^a?",
      708 		  "You have access to modify ^a in ^a.^/Use it?", e_name, sys_dir);
      709 		 if ^yes_sw then goto exit_ff_loop;
      710 	        end;
      711 	  file_found, term = true;			/* must be ok */
      712          end;
      713 
      714          else if type = Link then do;			/* entry exist & link */
      715 	  call hcs_$get_link_target (d_name, e_name,	/* get dir & entry */
      716 	   d_name, e_name, code);
      717 
      718 	  if code ^= 0 then do;
      719 	     if code ^= error_table_$noentry then	/* error */
      720 	        call dfm_$complain (dfm_datap, wrapup, code,
      721 	         "chasing link to ^a", d_name, e_name);
      722 
      723 	     else if accessible (d_name, "", SMA_ACCESS_BIN) then do;
      724 	        call command_query_$yes_no (yes_sw, 0, "Find File",
      725 	         "^a is a link in your working dir.^/Use the one found in ^a?",
      726 	         "You have access to create ^a in ^a. ^/Create it?", e_name, d_name);
      727 	        if yes_sw then do;			/* okey - got it */
      728 		 file_found, term = true;
      729 		 if index (ename, ".list") ^= 0 then	/* if creating new list */
      730 		    dfm_data.page_no = 0;
      731 	        end;
      732 	        else goto exit_ff_loop;
      733 	     end;
      734 	     else goto exit_ff_loop;			/* need more access */
      735 	  end;
      736 
      737 	  else if accessible (d_name, e_name, RW_ACCESS_BIN)
      738 	   & ^dfm_data.list then do;
      739 	     call command_query_$yes_no (yes_sw, 0, "Find File",
      740 	      "^a is a link in your working dir. ^/Use the one found in ^a?",
      741 	      "You have access to modify ^a in ^a. ^/Use it?", e_name, d_name);
      742 	     if yes_sw then				/* okey - got it */
      743 	        file_found, term = true;
      744 	     else goto exit_ff_loop;			/* suer doesn't want it */
      745 	  end;
      746 	  else file_found, term = true;		/* must be ok */
      747          end;
      748 
      749          else if type = Segment			/* single segment deckfile */
      750 	& index (e_name, ".list") = 0 then do;
      751 	  if d_name = sys_dir then			/* sys dir - ask */
      752 	     if accessible (d_name, e_name, RW_ACCESS_BIN)
      753 	      & ^dfm_data.list then do;
      754 	        call command_query_$yes_no (yes_sw, 0, "Find File",
      755 	         "^a does not exist in working dir. Use the one found in ^a?",
      756 	         "You have access to modify ^a in ^a.^/Use it?", e_name, sys_dir);
      757 	        if ^yes_sw then goto exit_ff_loop;
      758 	     end;
      759 	  file_found, term = true;			/* must be ok */
      760          end;
      761 
      762          else if index (e_name, ".list") ^= 0
      763 	& accessible (d_name, e_name, RW_ACCESS_BIN) then /* must be a listing seg */
      764 
      765 	  file_found, term = true;
      766 
      767          else goto exit_ff_loop;			/* seg not valid */
      768       end;
      769 
      770 exit_ff_loop:
      771       if ^file_found then				/* can't continue */
      772          call dfm_$complain (dfm_datap, wrapup, error_table_$no_file,
      773 	"using ^a>^a", rtrim (d_name), rtrim (e_name));
      774 
      775       if ^dfm_data.bf_sw & file_found then
      776          call dfm_$complain (dfm_datap, print, 0, "using ^a>^a", rtrim (d_name), rtrim (e_name));
      777 
      778       return;
      779 
      780 
      781 
      782 
      783 /* find_key - entry to find all search keys, given search key head */
      784 
      785 find_key: entry (P_dfm_datap, iocbp, c_name, c_ptr, rcode);
      786 
      787 
      788 dcl  c_ptr ptr;
      789 dcl  c_name char (24) varying;
      790 
      791       dfm_datap = P_dfm_datap;
      792 
      793       rcode = 0;
      794       ename = c_name;				/* copy search name */
      795       info_ptr = addr (info);
      796       unspec (info) = "0"b;
      797       common_sl_info.version = sl_info_version_0;
      798       common_sl_info.list_type = 1;			/* set to reuse subset */
      799       common_sl_info.output_descriptors = true;		/* want descriptors */
      800       common_sl_info.array_limit = 1;			/* 1 element array */
      801       common_sl_info.desc_arrayp = null;		/* let vfile_ allocate area for storage */
      802       hi_sl_info.first_head (1).length, hi_sl_info.last_head (1).length = length (rtrim (ename));
      803       hi_sl_info.first_head (1).kptr, hi_sl_info.last_head (1).kptr = addr (ename);
      804       call iox_$control (iocbp, "select", info_ptr, code);	/* get select info */
      805       if code ^= 0 then do;				/* problem with select */
      806          rcode = code;
      807          return;
      808       end;
      809       call iox_$position (iocbp, bof, 0, code);		/* position to beginning of file */
      810 
      811       if code ^= 0 then do;				/* problem with select */
      812          rcode = code;
      813          return;
      814       end;
      815       catalog.n_entries = common_sl_info.count;		/* copy number of descriptors */
      816       gk_info_ptr = addr (gki);			/* set info ptr */
      817       unspec (gki) = "0"b;				/* clear structure first */
      818       gk_info.input_desc = true;			/* using input descriptors */
      819       gk_info.reset_pos = true;			/* don't change position */
      820       do i = 1 to common_sl_info.count;			/* find each key */
      821          gk_info.descrip = desc_array (i);		/* insert each descriptor */
      822          call iox_$control (iocbp, "get_key", gk_info_ptr, code);
      823          if code ^= 0 then do;			/* error */
      824 	  rcode = code;
      825 	  return;
      826          end;
      827          catalog.key (i) = gk_info.key;			/* copy key */
      828       end;
      829       common_sl_info.list_type = 0;			/* set to reuse subset */
      830       common_sl_info.subset_no = 0;
      831       common_sl_info.array_limit = 0;			/* 0 element array */
      832       common_sl_info.desc_arrayp = null;		/* let vfile_ allocate area for storage */
      833       call iox_$control (iocbp, "select", info_ptr, code);	/* reset current subset */
      834       rcode = 0;					/* If we get this far insure 0 code is returned */
      835 
      836       return;					/* thats it folks */
      837 
      838 
      839 
      840 
      841 /* get_cata - entry to search a deckfile for a catalog. If one exists
      842*   it is read out, else a new one is initialized. */
      843 
      844 get_cata: entry (P_dfm_datap, iocbp, cata_name, wcatp, wksp, rcode);
      845 
      846 dcl  rec_length fixed bin (21);
      847 dcl  cata_name char (24) varying;
      848 
      849 
      850       dfm_datap = P_dfm_datap;
      851 
      852       call iox_$seek_key (iocbp, cata_name, rec_length, code);
      853       if code ^= 0 then do;
      854          if code = error_table_$no_record then do;
      855 	  wcata.key = " ";
      856 	  wcata.n_entries = 0;
      857 	  code = 0;
      858          end;
      859       end;
      860       else call iox_$read_record (iocbp, wcatp, rec_length, rec_len, code);
      861       wksp = addr (wcata.key (1));
      862       rcode = code;
      863 
      864       return;
      865 
      866 
      867 
      868 
      869 /* insert_deck - entry to insert current deck into the T & D deckfile */
      870 
      871 insert_deck: entry (P_dfm_datap, iocbp, bufp, buf_len, work_key);
      872 
      873 
      874 dcl  bufp ptr;
      875 dcl  buf_len fixed bin (21);
      876 
      877 
      878       dfm_datap = P_dfm_datap;
      879 
      880       if ^dfm_data.deckfile_sw & ^dfm_data.mdf then return; /* not using a deckfile - return */
      881 
      882       call iox_$seek_key (iocbp, work_key, rec_length, code); /* set key for insertion */
      883       if code ^= error_table_$no_record then do;		/* if record already exists */
      884          if code = 0 then do;				/* check for common itr */
      885 	  call iox_$rewrite_record (iocbp, bufp, buf_len, code); /* write the record */
      886 	  if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, /* fatal error - set abort flag */
      887 	      "attempting to rewrite record whose key is ""^a"" to the ^a>^a",
      888 	      work_key, dfm_data.dir, dfm_data.entry);
      889 	  return;
      890          end;
      891          else if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, /* fatal error - set abort flag */
      892 	   "attempting to rewrite record whose key is ""^a"" to the ^a>^a",
      893 	   work_key, dfm_data.dir, dfm_data.entry);
      894       end;
      895       call iox_$write_record (iocbp, bufp, buf_len, code);	/* write the record */
      896       if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, /* fatal error - set abort flag */
      897 	"attempting to write record whose key is ""^a"" to the ^a>^a",
      898 	work_key, dfm_data.dir, dfm_data.entry);
      899 
      900 
      901       return;
      902 
      903 
      904 
      905 /* make_key - entry to make up a key for insertion into the deckfile based on object card info */
      906 
      907 make_key: entry (P_dfm_datap);
      908 
      909       dfm_datap = P_dfm_datap;
      910       ocardp = addr (dfm_data.obj_card);
      911       dfm_data.current_key = "";			/* initialize key first */
      912 
      913       if dfm_data.fnp_tape then do;			/* make special key for fnp bin deck tapes */
      914          dfm_data.fnp_key = dfm_data.fnp_key + 1;		/* increment fnp key number */
      915          dfm_data.current_key = "fnp." || dfm_data.fnp_type || ".pol." || ltrim (char (dfm_data.fnp_key)) || "." ||
      916 	substr (o_card.edit_name, 1, 2);
      917       end;
      918 
      919       else if lfd then do;
      920          if index (dfm_data.current_filename, "cata.") ^= 0 then do;
      921 	  dfm_data.current_key = rtrim ("cata.nio." || substr (dfm_data.current_filename, 6));
      922 	  if index (dfm_data.current_filename, "mca") = 0
      923 	   & index (mcata_key_string, dfm_data.current_key) = 0 then do;
      924 	     mcata.n_entries = mcata.n_entries + 1;
      925 	     mcata.key (mcata.n_entries) = dfm_data.current_key;
      926 	  end;
      927          end;
      928 
      929          else do;
      930 	  dfm_data.current_key = "nio." || rtrim (dfm_data.current_filename);
      931 	  if index (dcata_key_string, dfm_data.current_key) = 0 then do;
      932 	     dcata.n_entries = dcata.n_entries + 1;
      933 	     dcata.key (dcata.n_entries) = dfm_data.current_key;
      934 	  end;
      935          end;
      936          return;
      937       end;
      938 
      939       else if o_card.library = "hmpcj1" then do;		/* if mpc deck */
      940          if id_blk.type ^= "itr" & id_blk.type ^= "mdr" then/* if firmware deck */
      941 	  dfm_data.current_key = string (id_blk.type_code); /* set firmware identification */
      942          else dfm_data.current_key = id_blk.type;		/* itr or mdr */
      943          dfm_data.current_key = rtrim (dfm_data.current_key) || "." || id_blk.ident;
      944          dfm_data.current_key = rtrim (dfm_data.current_key) || "." || o_card.edit_name;
      945          dfm_data.current_key = rtrim (dfm_data.current_key) || "." || id_blk.rev; /* set revision */
      946       end;
      947 
      948       else do;					/* must be htnd deck */
      949          if o_card.ss_type = "s" then			/* take care of special cases first */
      950 	  dfm_data.current_key = "pas." || substr (o_card.edit_name, 1, 3); /* isolts deck */
      951          else if o_card.ss_type = "u" then		/* utility deck */
      952 	  dfm_data.current_key = "utl." || o_card.call_name;
      953          else dfm_data.current_key = o_card.ss_type || "lt." || o_card.call_name; /* most common case */
      954          return;
      955       end;
      956 
      957       if index (cata_key_string, dfm_data.current_key) = 0 then do;
      958          cata.n_entries = cata.n_entries + 1;		/* increment  number of catalog entries */
      959          cata.key (cata.n_entries) = dfm_data.current_key;	/* and add current entry to catalog */
      960       end;
      961 
      962       return;
      963 
      964 
      965 
      966 
      967 /* mca_attach - entry to attach an MCA for diskette reads */
      968 
      969 mca_attach: entry (P_dfm_datap, mca_id);
      970 
      971 dcl  mca_id char (4);
      972 
      973 
      974       dfm_datap = P_dfm_datap;
      975 
      976       if dfm_data.m_attached then return;
      977       call mca_$attach_mca (mca_id, 0, dfm_data.mca_ioi_idx, code);
      978       if code ^= 0 then
      979          call dfm_$complain (dfm_datap, wrapup, code, "Attempting to attach mca ^a", mca_id);
      980       dfm_data.m_attached = true;
      981       return;
      982 
      983 
      984 
      985 
      986 
      987 /* mca_detach - entry to detach an MCA */
      988 
      989 mca_detach: entry (P_dfm_datap);
      990 
      991 
      992       dfm_datap = P_dfm_datap;
      993 
      994       if ^dfm_data.m_attached then return;
      995       call mca_$detach_mca (dfm_data.mca_ioi_idx, code);
      996       if code ^= 0 then
      997          call dfm_$complain (dfm_datap, print, code, "Attempting to detach the mca", "");
      998       dfm_data.m_attached = false;
      999 
     1000       return;
     1001 
     1002 
     1003 
     1004 
     1005 
     1006 /* merge deckfiles - entry to merge two deckfiles */
     1007 
     1008 merge_files: entry (P_dfm_datap, old_iocbp, new_iocbp);
     1009 
     1010 
     1011       dfm_datap = P_dfm_datap;
     1012 
     1013       unspec (rsi) = "0"b;
     1014       rsi.version = rs_info_version_2;
     1015       allocate lbuff in (free_area) set (dfm_data.lbuff_p);
     1016       lbuff = "";
     1017 
     1018       do i = lbound (list_types, 1) to hbound (list_types, 1);
     1019          dfm_data.list_key = list_types (i);
     1020          call find_key (dfm_datap, old_iocbp, (dfm_data.list_key), dfm_data.lcatp, code);
     1021          if code ^= 0 then dfm_data.list_key = "";
     1022          if dfm_data.list_key ^= "" then do;
     1023 	  call get_cata (dfm_datap, old_iocbp, dfm_data.list_key, dfm_data.lcatp, dfm_data.lksp, code);
     1024 	  if code ^= 0 then
     1025 	     call dfm_$complain (dfm_datap, wrapup, code, "attempting to find catalog for ^a", dfm_data.list_key);
     1026 	  do j = 1 to lcata.n_entries;
     1027 	     call iox_$seek_key (old_iocbp,		/* get the ls. key entry */
     1028 	      rtrim (lcata.key (j)), rec_len, code);
     1029 	     if code ^= 0 then
     1030 	        call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek key ^a ", lcata.key (j));
     1031 	     call iox_$read_record (old_iocbp, dfm_data.lbuff_p, rec_len, lbuff_len, code);
     1032 	     if code ^= 0 then
     1033 	        call dfm_$complain (dfm_datap, wrapup, code, "attempting to read a keyed record ^a", lcata.key (j));
     1034 
     1035 	     if index (lbuff, "DELETED") = 0
     1036 	      & index (lcata.key (j), ".hdr") = 0	/* if not hdr */
     1037 	      & index (lcata.key (j), ".P.") = 0 then do; /* or patch headr move data */
     1038 	        merge_key = substr (lcata.key (j), verify (lcata.key (j), "ls."));
     1039 
     1040 	        call iox_$seek_key (old_iocbp, merge_key, rec_length, code);
     1041 	        if code ^= 0 then
     1042 		 call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek key ^a ", merge_key);
     1043 	        call iox_$read_record (old_iocbp, dfm_data.bptr, rec_length, rec_len, code);
     1044 	        if code ^= 0 then
     1045 		 call dfm_$complain (dfm_datap, wrapup, code, "attempting to read a keyed record ^a", merge_key);
     1046 	        call insert_deck (dfm_datap, new_iocbp, dfm_data.bptr, rec_len, merge_key);
     1047 	        call iox_$control (new_iocbp, "record_status", addr (rsi), code); /* get record position */
     1048 	        call ioa_$rs ("^a^86t^2d^5x^6o^4x^8d^/", lbuff, lbuff_len,
     1049 	         substr (lbuff, 1, index (lbuff, rtrim (merge_key)) + length (rtrim (merge_key))),
     1050 	         addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18), rsi.record_length);
     1051 	     end;
     1052 	     else do;				/* update time & pathname */
     1053 	        if after (lcata.key (j), ".hdr") = "1" then /* time */
     1054 		 call ioa_$rs ("^a^61tTime - ^a", lbuff, lbuff_len,
     1055 		  before (lbuff, "Time"), dfm_data.time_string);
     1056 	        else if after (lcata.key (j), ".hdr") = "2" then /* pathname */
     1057 		 call ioa_$rs ("^a^51tStored in ^a>^a", lbuff, lbuff_len,
     1058 		  before (lbuff, "Stored"), dfm_data.dir, dfm_data.entry);
     1059 	     end;
     1060 
     1061 	     call insert_deck (dfm_datap, new_iocbp,	/* write the ls entry */
     1062 	      dfm_data.lbuff_p, lbuff_len, (lcata.key (j)));
     1063 	  end;
     1064 	  call insert_deck (dfm_datap, new_iocbp, dfm_data.lcatp, length (unspec (lcata)), dfm_data.list_key);
     1065          end;
     1066       end;
     1067       free dfm_data.lbuff_p -> lbuff in (free_area);
     1068       dfm_data.lbuff_p = null;
     1069 
     1070       return;
     1071 
     1072 
     1073 
     1074 
     1075 /* mount diskette - entry to instruct the operator to mount an MCA diskette */
     1076 
     1077 mount_diskette: entry (P_dfm_datap, diskette_name, header_ptr) returns (bit (1));
     1078 
     1079 dcl  diskette_name char (8) varying;
     1080 
     1081 
     1082       dfm_datap = P_dfm_datap;
     1083 
     1084       opr_query_info.prim = "0 or 1";
     1085       opr_query_info.alt = "unable";
     1086       opr_query_info.r_comment = "";
     1087 
     1088       term = false;
     1089       do i = 0 to 1 while (^term);
     1090          dfm_data.disk_num = i;
     1091 read_diskette_hdr:
     1092          call read_diskette (dfm_datap, "HDR", header_ptr, rec_len, "0"b, code);
     1093          if code = 0 then do;
     1094 	  if substr (header.unique_id, 1, 3) = substr (diskette_name, 1, 3) then do;
     1095 	     term = true;
     1096 	     opr_query_info.q_sw = false;
     1097 	     call opr_query_ (addr (opr_query_info),
     1098 	      "Reading diskette ^a on drive ^d", header.unique_id, dfm_data.disk_num);
     1099 	     return (true);
     1100 	  end;
     1101          end;
     1102       end;
     1103 
     1104 
     1105       if ^term then do;
     1106 ask_opr: call ioa_ ("requesting mount of ^a", diskette_name);
     1107          opr_query_info.q_sw = true;
     1108          opr_query_info.r_comment = "disk # used or unable";
     1109          call opr_query_ (addr (opr_query_info),
     1110 	"Please mount diskette ^a and reply with", diskette_name);
     1111          if opr_query_info.answer = "unable" then do;
     1112 	  call ioa_ ("unable to mount MCA diskette ^a", diskette_name);
     1113 	  return (false);
     1114          end;
     1115          else do;
     1116 	  dfm_data.disk_num = convert (dfm_data.disk_num, opr_query_info.answer);
     1117 	  if disk_num < 0 | dfm_data.disk_num > 1 then do;
     1118 	     call ioa_ ("operator returned incorrect reply - retrying");
     1119 	     goto ask_opr;
     1120 	  end;
     1121 	  else goto read_diskette_hdr;		/* read hdr and display message */
     1122          end;
     1123       end;
     1124 
     1125       return (false);				/* should never happen */
     1126 
     1127 
     1128 
     1129 
     1130 /* open_file - entry to attach and open files */
     1131 
     1132 open_file: entry (P_dfm_datap, sw_name, att_desc, mode, iocbp);
     1133 
     1134 
     1135       dfm_datap = P_dfm_datap;
     1136 
     1137       call iox_$attach_name (sw_name, iocbp, att_desc, null, code);
     1138       if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, "attaching ^a", sw_name);
     1139 
     1140       call iox_$open (iocbp, mode, "0"b, code);		/* open per mode */
     1141       if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, "opening ^a for ^a", sw_name, iox_modes (mode));
     1142 
     1143       return;
     1144 
     1145 
     1146 
     1147 /* print_list - entry to generate a listing of the contents of a deckfile */
     1148 
     1149 print_list: entry (P_dfm_datap, iocbp, work_key);
     1150 
     1151 
     1152       dfm_datap = P_dfm_datap;
     1153 
     1154       if ^dfm_data.deckfile_sw & ^dfm_data.mdf then return;
     1155 
     1156       call iox_$position (iocbp, bof, 0, code);		/* position to beginning of file */
     1157       if index (work_key, ".list") = 0 then
     1158          call find_key (dfm_datap, iocbp, (dfm_data.list_key), dfm_data.lcatp, code);
     1159       else call get_cata (dfm_datap, iocbp, work_key, dfm_data.lcatp, dfm_data.lksp, code);
     1160       if code ^= 0 then
     1161          call dfm_$complain (dfm_datap, wrapup, code, "attempting to find keys for ^a", work_key);
     1162 
     1163       k = 1;
     1164       line_count = 0;
     1165       allocate hbuff in (free_area) set (dfm_data.hbuff_p);
     1166       allocate lbuff in (free_area) set (dfm_data.lbuff_p);
     1167       hbuff = "";
     1168 
     1169       do j = 1 to lcata.n_entries;
     1170          lbuff = "";
     1171          call iox_$seek_key (iocbp, rtrim (lcata.key (j)), rec_len, code);
     1172          if code ^= 0 then
     1173 	  call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek key ^a ", lcata.key (j));
     1174 
     1175          call iox_$read_record (iocbp, dfm_data.lbuff_p, rec_len, lbuff_len, code);
     1176          if code ^= 0 then
     1177 	  call dfm_$complain (dfm_datap, wrapup, code, "attempting to read a keyed record");
     1178 
     1179          if index (lcata.key (j), ".hdr") ^= 0 then do;
     1180 	  hbuff (k) = "";
     1181 	  if k = 1 then do;				/* Need to add page# */
     1182 	     dfm_data.page_no = dfm_data.page_no + 1;
     1183 	     line_count = 1;
     1184 	     call ioa_$rs ("^a,  Page - ^d", lbuff, lbuff_len,
     1185 	      before (lbuff, NL), dfm_data.page_no);
     1186 	  end;
     1187 
     1188 	  hbuff (k) = rtrim (lbuff);
     1189 	  k = k + 1;
     1190          end;
     1191          if dfm_data.terminal_out then lbuff = substr (lbuff, verify (lbuff, whitespace));
     1192          call iox_$put_chars (dfm_data.liocb_ptr, dfm_data.lbuff_p, length (rtrim (lbuff)), code);
     1193          if code ^= 0 then
     1194 	  call dfm_$complain (dfm_datap, wrapup, code,
     1195 	   "attempting to ^[add to the deckfile.list^;display list output^]",
     1196 	   ^dfm_data.terminal_out);
     1197 
     1198          if k = hbound (hbuff, 1) + 1 then do;
     1199 	  call ioa_$ioa_switch (dfm_data.liocb_ptr, "^/");
     1200 	  k = 1;
     1201          end;
     1202 
     1203          line_count = line_count + 1;
     1204          if j < lcata.n_entries
     1205 	& lcata.n_entries > 1 then
     1206 	  if index (lcata.key (j + 1), ".hdr") = 0
     1207 	   & (index (lbuff, "cata") ^= 0 | line_count > 25) then do;
     1208 	     line_count = 0;
     1209 	     dfm_data.page_no = dfm_data.page_no + 1;
     1210 	     call ioa_$rs ("^a,  Page - ^d", hbuff (1), hbuff_len,
     1211 	      before (before (hbuff (1), NL), ",  Page"), dfm_data.page_no);
     1212 
     1213 	     do i = lbound (hbuff, 1) to hbound (hbuff, 1);
     1214 	        call iox_$put_chars (dfm_data.liocb_ptr, addr (hbuff (i)), length (rtrim (hbuff (i))), code);
     1215 	        if code ^= 0 then
     1216 		 call dfm_$complain (dfm_datap, wrapup, code,
     1217 		  "attempting to ^[write list data^;display list output^]",
     1218 		  ^dfm_data.terminal_out);
     1219 	     end;
     1220 	     call ioa_$ioa_switch (dfm_data.liocb_ptr, "^/");
     1221 	  end;
     1222       end;
     1223       free dfm_data.lbuff_p -> lbuff in (free_area);
     1224       dfm_data.lbuff_p = null;
     1225       free dfm_data.hbuff_p -> hbuff in (free_area);
     1226       dfm_data.hbuff_p = null;
     1227 
     1228       return;
     1229 
     1230 
     1231 
     1232 /* read_deck - entry to read in the next sequential object deck from the tape */
     1233 
     1234 read_deck: entry (P_dfm_datap, end_file, abort);
     1235 
     1236 
     1237 dcl  (end_file, abort) bit (1);
     1238 
     1239 
     1240       dfm_datap = P_dfm_datap;
     1241 
     1242       at_bot = true;				/* initialize flags */
     1243       abort, dk_end, end_file = false;
     1244       first_rcd, id_ld, obj_card_found = false;
     1245       p_blk.p_cnt = 0;				/* initialize patch count */
     1246       if dfm_data.pfile < dfm_data.cfile then
     1247          dfm_data.pfile = dfm_data.cfile;		/* update listing file designator if necessary */
     1248 
     1249 
     1250       gprp = dfm_data.bptr;				/* set initial blk ptr to base of tape buff */
     1251       cvp, cvp1 = null;
     1252 
     1253       do while (^dk_end);				/* loop until entire deck is read in */
     1254          rtrycnt = 0;				/* reset retries */
     1255 retry_rd:
     1256          call iox_$read_record (dfm_data.tiocb_ptr, gprp, buf_size, rec_len, code);
     1257          if code ^= 0 then do;
     1258 	  if code ^= error_table_$end_of_info then	/* if not end of file */
     1259 	     if code = error_table_$tape_error then do;
     1260 	        if at_bot then do;			/* still at bot probably wrong density */
     1261 		 dfm_data.denno = dfm_data.denno + 1;	/* increment density number */
     1262 		 if dfm_data.denno > hbound (density, 1) then /* can't set it so abort */
     1263 		    go to get_stat;
     1264 		 call iox_$control (dfm_data.tiocb_ptr, "rewind", null, code);
     1265 		 call iox_$control (dfm_data.tiocb_ptr, density (dfm_data.denno), null, code); /* set density */
     1266 		 go to retry_rd;			/* and go try again */
     1267 	        end;
     1268 	        rtrycnt = rtrycnt + 1;		/* increment retry count */
     1269 	        if rtrycnt > max_retrys then do;	/* if we have retried max number of times */
     1270 get_stat:
     1271 		 call iox_$control (dfm_data.tiocb_ptr, "saved_status", addr (t_stat), scode);
     1272 		 call dfm_$complain (dfm_datap, wrapup, code,
     1273 		  "Tape status = ^4.3b, while reading record ^d, file ^d after 10 retries",
     1274 		  t_stat, dfm_data.crec, dfm_data.cfile); /* set abort indicator */
     1275 	        end;
     1276 	        call iox_$control (dfm_data.tiocb_ptr, "backspace_record", null, code);
     1277 	        go to retry_rd;
     1278 	     end;
     1279 	     else call dfm_$complain (dfm_datap, wrapup, code, /* not a tape error report it and abort */
     1280 		 "While reading record ^d, file ^d", dfm_data.crec, dfm_data.cfile);
     1281 
     1282 	  else do;				/* end of file */
     1283 	     end_file = true;			/* set eof indicator */
     1284 	     dfm_data.cfile = dfm_data.cfile + 1;	/* increment position indicators */
     1285 	     dfm_data.crec = 0;
     1286 	     return;
     1287 	  end;
     1288          end;
     1289          if rec_len = 56 then				/* check for partial hdr label (GCOS EOV) */
     1290 	  if substr (bit_buf, 1, 72) = g_label then
     1291 	     if substr (bit_buf, 145, 216) = "0"b then do;/* if true, partial hdr label */
     1292 	        dfm_data.eot = true;			/* set EOV flags */
     1293 	        return;
     1294 	     end;
     1295          if ^first_rcd then do;			/* if first record of deck */
     1296 	  bcnt = gpr.bcw.bsn;			/* load block serial number */
     1297 	  first_rcd = true;
     1298          end;
     1299          else do;					/* if not first record, check BSN */
     1300 	  bcnt = bcnt + 1;				/* increment our block count */
     1301 	  if gpr.bcw.bsn ^= bcnt then			/* something wrong here */
     1302 	     call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
     1303 	      "Block serial number error at record ^d, file ^d^/Block serial number was ^d, S/B ^d",
     1304 	      dfm_data.crec, dfm_data.cfile, gpr.bcw.bsn, bcnt); /* set abort flag */
     1305 
     1306          end;
     1307          glrp = addr (gpr.gc_phy_rec_data (1));		/* get pointer to first logical record */
     1308          nwds = 0;
     1309 
     1310          do while (nwds < gpr.bcw.blk_size);		/* iterate through all logical records */
     1311 	  if glr.rcw.media_code = bcd_media_code then do; /* bcd card image */
     1312 	     glrbp = addr (glr.gc_log_rec_data);
     1313 	     if substr (glrb, 1, 78) = bcd_obj then do;	/* object card */
     1314 	        call bcd_to_ascii_ (glrb, dfm_data.obj_card); /* convert to ascii */
     1315 	        obj_card_found = true;		/* indicate that we have gotten object card */
     1316 	        ocardp = addr (dfm_data.obj_card);
     1317 	        if (o_card.edit_name = fnp_18x_edit_name
     1318 	         | o_card.edit_name = fnp_355_edit_name)
     1319 	         & at_bot then do;			/* get set to build  fnp catalog key */
     1320 		 if o_card.edit_name = fnp_18x_edit_name then /* is this an 18x fnp */
     1321 		    dfm_data.fnp_type = fnp_6670_type;	/* yes, set type */
     1322 		 else if o_card.edit_name = fnp_355_edit_name then /* is it a 355 fnp */
     1323 		    dfm_data.fnp_type = fnp_355_type;
     1324 		 else call dfm_$complain (dfm_datap, wrapup,
     1325 		       error_table_$fatal_error,	/* neither one, can't be fnp tape */
     1326 		       "First object deck image has an edit name ^a which is not a valid first deck a binary deck tape",
     1327 		       o_card.edit_name);
     1328 		 dfm_data.fnp_tape = true;
     1329 		 dfm_data.cat_key = "fnp.pol." || dfm_data.fnp_type; /* start catalog key */
     1330 		 dfm_data.l_att_desc = rtrim (dfm_data.l_att_desc) || ".fnp." || dfm_data.fnp_type;
     1331 	        end;
     1332 
     1333 	     end;
     1334 	     else do;				/* must be dkend or patch card */
     1335 	        if o_card.library = "hmpcj1" & ^id_ld then do; /* if hmpcj1 lib and we haven't been here */
     1336 		 id_ld = true;			/* set flag so we don't come back */
     1337 		 if cvp1 = null then		/* if only 1 binary card */
     1338 		    cvp1 = cvp;
     1339 		 call load_ident;			/* load ident block */
     1340 	        end;
     1341 	        if substr (glrb, 1, 72) = bcd_dkend then	/* dkend card */
     1342 		 dk_end = true;			/* set terminate condition */
     1343 	        else if ^ck_patch (glrb) then		/* go check for patch card */
     1344 		 call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
     1345 		  "BCD card image at record ^d, file ^d is not $ object, $ dkend, or valid patch card:^/""^a""",
     1346 		  dfm_data.crec, dfm_data.cfile, dfm_data.ascii_card); /* if error, get out */
     1347 	     end;
     1348 	  end;
     1349 	  else if glr.rcw.media_code = binary_media_code then /* binary card image */
     1350 	     if ^obj_card_found then			/* but no $ object card yet */
     1351 	        call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
     1352 	         "Binary card image preceeds $ object card at record ^d, file ^d", dfm_data.crec, dfm_data.cfile);
     1353 	     else do;
     1354 	        cvp1 = cvp;				/* save ptr to last logical record */
     1355 	        cvp = glrp;				/* save ptr to current logical record */
     1356 	     end;
     1357 	  else call dfm_$complain (dfm_datap, wrapup,
     1358 	        error_table_$fatal_error,		/* not a bcd or binary card image */
     1359 	        "Card type ^o detected at record ^d, file ^d", glr.rcw.media_code, dfm_data.crec, dfm_data.cfile);
     1360 
     1361 	  at_bot = false;
     1362 	  nwds = nwds + glr.rcw.rsize + 1;		/* increment number of words */
     1363 	  glrp = addrel (glrp, currentsize (glr));	/* set next logical record */
     1364          end;
     1365          dfm_data.crec = dfm_data.crec + 1;		/* increment current record number */
     1366          gprp = addrel (gprp, currentsize (gpr));		/* append next block */
     1367       end;
     1368       dfm_data.dlen = fixed (rel (gprp)) + 1;		/* set total deck length in words */
     1369 
     1370       return;
     1371 
     1372 
     1373 
     1374 /* read_diskette - entry to read a specified diskette file */
     1375 
     1376 read_diskette: entry (P_dfm_datap, filename, data_bufp, total_chars, mstat, rcode);
     1377 
     1378 
     1379 dcl  mca_buf_size fixed bin (21) init (16 * 1024);
     1380 dcl  (current_ptr, data_bufp) ptr;
     1381 dcl  filename char (*);
     1382 dcl  mstat bit (72);
     1383 dcl  ret_len fixed bin (21);
     1384 dcl  total_chars fixed bin (21);
     1385 
     1386 
     1387       dfm_datap = P_dfm_datap;
     1388 
     1389       ret_len, total_chars = 0;
     1390       code = 0;
     1391       current_ptr = data_bufp;
     1392       call mca_$diskette_read (dfm_data.mca_ioi_idx, filename,
     1393        dfm_data.disk_num, current_ptr, mca_buf_size, ret_len, mstat, code);
     1394 rd_loop:
     1395       rcode = code;
     1396       dfm_data.statp = addr (mstat);
     1397       dfm_data.sub_ptr = addr (mca_status.sub);
     1398       if code ^= 0 then do;
     1399          if mca_status.maj = "0"b & mca_sub.data_p then
     1400 	  call mca_$read_data (dfm_data.mca_ioi_idx, current_ptr, mca_buf_size, ret_len, "0"b, 0);
     1401          return;
     1402       end;
     1403       current_ptr = add_char_offset_ (current_ptr, ret_len);
     1404       total_chars = total_chars + ret_len;
     1405       if mca_sub.data_p then do;
     1406          call mca_$read_data (dfm_data.mca_ioi_idx, current_ptr, mca_buf_size, ret_len, mstat, code);
     1407          goto rd_loop;
     1408       end;
     1409 
     1410       else return;
     1411 
     1412 
     1413 
     1414 /* update_list - entry to add current deck entry to listing file */
     1415 
     1416 update_list: entry (P_dfm_datap, ltype);
     1417 
     1418 
     1419 dcl  ltype fixed bin (2);
     1420 
     1421 
     1422       dfm_datap = P_dfm_datap;
     1423       ocardp = addr (dfm_data.obj_card);
     1424       unspec (rsi) = "0"b;
     1425       rsi.version = rs_info_version_2;
     1426       dfm_data.lib = false;				/* reset lib <switch */
     1427       dfm_data.dtype, dfm_data.sstype = "";
     1428 
     1429       if dfm_data.fnp_tape then do;			/* if loading fnp bin. deck tape */
     1430          dfm_data.sstype = "pol ";			/* this stands for Partial OnLine */
     1431          dfm_data.dtype = "fnp ";
     1432       end;
     1433       else if dfm_data.lfd then do;
     1434          dfm_data.sstype = "nio";
     1435          dfm_data.dtype = substr (translate (dfm_data.current_disk_name, lc, uc), 1, 3);
     1436       end;
     1437 
     1438 
     1439       else if o_card.library = "hmpcj1" then do;		/* mpc library */
     1440          dfm_data.lib = true;				/* set lib switch */
     1441          dfm_data.sstype = substr (o_card.library, 1, 5);
     1442          if id_blk.type ^= "itr" & id_blk.type ^= "mdr" then/* if firmware */
     1443 	  dfm_data.dtype = " fw ";
     1444          else substr (dfm_data.dtype, 2, 3) = id_blk.type;	/* set itr or mdr type */
     1445          if dk_type = " fw " & id_blk.type = "mdr" then dfm_data.hdr_sw = true;
     1446          dk_type = dfm_data.dtype;
     1447       end;
     1448 
     1449       else do;					/* must be htnd library */
     1450          if o_card.ld_type = "m" then dfm_data.dtype = "mast"; /* pas2 master deck */
     1451          else if o_card.ld_type = "s" then dfm_data.dtype = "slav";
     1452          else if o_card.ld_type = "p" then dfm_data.dtype = "prog"; /* program deck */
     1453          else if o_card.ld_type = "r" then dfm_data.dtype = "rloc"; /* relocatable deck */
     1454          else dfm_data.dtype = "data";
     1455          if o_card.ss_type = "p" then dfm_data.sstype = "polt";
     1456          else if o_card.ss_type = "m" then dfm_data.sstype = "molt";
     1457 
     1458          else if o_card.ss_type = "c" then dfm_data.sstype = "colt";
     1459          else if o_card.ss_type = "h" then dfm_data.sstype = "heal";
     1460          else if o_card.ss_type = "u" then dfm_data.sstype = "util";
     1461          else if o_card.ss_type = "s" then
     1462 	  if o_card.m_applic = " " then dfm_data.sstype = "isol";
     1463 	  else dfm_data.sstype = "solt";
     1464       end;
     1465       if ^dfm_data.list then				/* if just producing a listing, don't bother */
     1466          call iox_$control (dfm_data.fiocb_ptr, "record_status", addr (rsi), code); /* get record position */
     1467 
     1468       if dfm_data.lfd then dfm_data.ls_type = "mca";
     1469       else if dfm_data.fnp_tape then dfm_data.ls_type = "fnp";
     1470       else dfm_data.ls_type = "ifad";
     1471 
     1472       if dfm_data.lib_type ^= dfm_data.sstype then do;
     1473          dfm_data.lib_type = dfm_data.sstype;
     1474          dfm_data.hdr_sw = true;
     1475       end;
     1476 
     1477       if dfm_data.hdr_sw then call put_hdr ();		/* if we need a header then put it out */
     1478       allocate lbuff in (free_area) set (dfm_data.lbuff_p);
     1479       lbuff = "";
     1480 
     1481       if dfm_data.lfd then do;
     1482          if index (dfm_data.current_filename, "DIR") ^= 0 then
     1483 	  dfm_data.current_filename = substr (dfm_data.current_filename, 6, 8);
     1484          else if index (dfm_data.current_filename, "HDR") ^= 0 then
     1485 	  dfm_data.current_filename = substr (dfm_data.current_filename, 1, 7);
     1486          else dfm_data.current_filename = substr (dfm_data.current_filename, 1, 8);
     1487          call ioa_$rs ("^12t ^a ^31t ^a ^42t ^a ^58t ^21a ^86t  ^2d     ^6o    ^8d^/",
     1488 	lbuff, lbuff_len, dfm_data.current_filename, dfm_data.edit_date, dfm_data.sstype, dfm_data.current_key,
     1489 	addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18), rsi.record_length);
     1490       end;
     1491 
     1492 
     1493       else call ioa_$rs (fmt1 || fmt2 || fmt3, lbuff, lbuff_len,
     1494 	  (ltype = cata_list_type), dfm_data.fnp_tape, o_card.call_name,
     1495 	  o_card.edit_name, dfm_data.dtype, substr (o_card.ttl_date, 1, 2),
     1496 	  substr (o_card.ttl_date, 3, 2), substr (o_card.ttl_date, 5, 2),
     1497 	  dfm_data.lib, id_blk.ident, o_card.model, id_blk.rev, dfm_data.sstype,
     1498 	  dfm_data.list, dfm_data.fnp_tape, (o_card.m_applic = " "), dfm_data.current_key,
     1499 	  addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18), rsi.record_length);
     1500 
     1501       dfm_data.list_key = "ls." || rtrim (dfm_data.current_key);
     1502 
     1503       if index (lcata_key_string, dfm_data.list_key) = 0	/* entry not in the cata */
     1504        | lib then do;				/* mpc cata build */
     1505          lcata.n_entries = lcata.n_entries + 1;
     1506          lcata.key (lcata.n_entries) = dfm_data.list_key;
     1507       end;
     1508 
     1509 
     1510       call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p, lbuff_len, dfm_data.list_key);
     1511       free dfm_data.lbuff_p -> lbuff in (free_area);
     1512       dfm_data.lbuff_p = null;
     1513       if p_blk.p_cnt ^= 0 then			/* if patches exist... */
     1514          call put_patch;				/* list them too */
     1515       if dfm_data.attach_copy then			/* if we are writing copy tape */
     1516          if ltype ^= cata_list_type then		/* and this is not a catalog record */
     1517 	  call write_copy ();			/* copy this deck too */
     1518 
     1519       return;
     1520 
     1521 
     1522 
     1523 /* valid_diskette - entry to verify a diskette as a valid diskette type */
     1524 
     1525 valid_diskette: entry (P_dfm_datap, diskette) returns (bit (1));
     1526 
     1527 
     1528 dcl  diskette char (8) varying;
     1529 
     1530 
     1531       dfm_datap = P_dfm_datap;
     1532 
     1533       if index (string (valid_diskettes), substr (translate (diskette, lc, uc), 1, 3)) > 0 then return (true);
     1534 
     1535       else return (false);
     1536 
     1537 
     1538 
     1539 /* accessible - int function that will check the user's access to system gates & data bases */
     1540 
     1541 accessible: proc (dir, entry, lowest_access) returns (bit (1));
     1542 
     1543 dcl  dir char (*);
     1544 dcl  entry char (*);
     1545 dcl  lowest_access fixed bin (5);
     1546 
     1547       call hcs_$get_user_effmode (dir, entry, "", current_ring, user_access, code);
     1548       if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
     1549 	"attemping to get user access to ^a>^a.", dir, entry);
     1550 
     1551       if user_access >= lowest_access then return (true);
     1552 
     1553       else return (false);				/* if we made it - all ok */
     1554 
     1555    end accessible;
     1556 
     1557 
     1558 
     1559 
     1560 /* ck_patch - int proc to check a bcd card image for a valid patch card */
     1561 
     1562 ck_patch: proc (bcd_card) returns (bit (1));
     1563 
     1564 dcl  bcd_card bit (*);
     1565 
     1566 
     1567       call bcd_to_ascii_ (bcd_card, dfm_data.ascii_card);
     1568       ascii_cardp = addr (dfm_data.ascii_card);
     1569       v_patch = false;				/* reset patch flag */
     1570 
     1571       if h_patch.type = "chex"
     1572        | h_patch.type = "rhex" then			/* for cs or r/w mem */
     1573          if o_card.assem = "m" then			/* and deck produced with mpc assembler */
     1574 	  if h_patch.lbl = o_card.edit_name then	/* if label matches */
     1575 	     if h_patch.rev = string (id_blk.revision) then /* and rev matches */
     1576 	        v_patch = true;			/* valid hex patch */
     1577       if ^v_patch then				/* if  it wasn't hex patch */
     1578          if o_patch.type = "octal" | o_patch.type = "mask" then
     1579 	  v_patch = true;				/* valid octal patch */
     1580       if v_patch then do;				/* if one of the above */
     1581          p_blk.p_cnt = p_blk.p_cnt + 1;			/* increment patch count */
     1582 
     1583          p_blk.p_card (p_blk.p_cnt) = dfm_data.ascii_card;	/* copy image */
     1584       end;
     1585 
     1586       return (v_patch);
     1587 
     1588    end ck_patch;
     1589 
     1590 
     1591 
     1592 
     1593 /* ld_fw_deck - int proc to load core image of firmware deck into
     1594*   a segment named "fw.<ident>.<pgm_name>.<rev>" */
     1595 
     1596 ld_fw_deck: proc (fw_dkp);
     1597 
     1598 dcl  fw_dkp ptr;
     1599 
     1600       ename = "fw." || id_blk.ident || "." || o_card.edit_name ||
     1601        "." || id_blk.rev;				/* form firmware seg name */
     1602       call hcs_$initiate (dfm_data.dir, ename, "", 0, 0, segp, code); /* attempt to initiate seg */
     1603       if segp = null then do;				/* seg does not exist, create it */
     1604          call hcs_$make_seg (dfm_data.dir, ename, "", 01010b, segp, code);
     1605          if segp = null then				/*  error creating segment */
     1606 	  call dfm_$complain (dfm_datap, wrapup, code,
     1607 	   "Unable to create ^a>^a", dfm_data.dir, ename);
     1608       end;
     1609       if dfm_data.allow_0_cksum then call gload_$allow_zero_checksums
     1610 	("dfm_util_", dfm_data.dir, ename, fw_dkp, segp, 0,
     1611 	addr (gload_data), code);			/* load the core image */
     1612       else call gload_ (fw_dkp, segp, 0, addr (gload_data), code); /* load the core image */
     1613       if code ^= 0 then				/* loading error */
     1614          call dfm_$complain (dfm_datap, wrapup, code,
     1615 	"^a^/attempting to load core image of ^a>^a", gload_data.diagnostic, dfm_data.dir, ename);
     1616 
     1617       call hcs_$set_bc_seg (segp, fixed (gload_data.text_len) * 36, code); /* set bit count of fw seg */
     1618       if code ^= 0 then				/* error setting bit count */
     1619          call dfm_$complain (dfm_datap, wrapup, code, "Unable to set bit count of ^a>^a", dfm_data.dir, ename);
     1620 
     1621    end ld_fw_deck;
     1622 
     1623 
     1624 
     1625 /* load_ident - int proc to load last 2 binary card images of hmpcj1 deck and extract the ident block */
     1626 
     1627 load_ident: proc;
     1628 
     1629 
     1630       lx = 0;					/* set initial load index */
     1631       ident_buf = ""b;
     1632       svp = glrp;
     1633       glrp = cvp1;
     1634 
     1635       do while (glr.rcw.media_code = 1);		/* process only binary cards */
     1636          dfm_data.cptr = addrel (glrp, 1);
     1637          psz = 4;					/* set initial pad size to 4 */
     1638          m = r_card.count;				/* set initial count */
     1639          term = false;
     1640 
     1641          do while (^term);				/* load all words on card */
     1642 
     1643 	  do i = 1 to r_card.count;
     1644 	     ident_buf (lx + i) = r_card.data (i);	/* copy data */
     1645 	  end;
     1646 	  lx = lx + r_card.count;			/* update load index */
     1647 	  if substr (r_card.nxt_c_wd, 1, 12) ^= "2005"b3
     1648 	   | m = glr.rcw.rsize - 8 then term = true;	/* all done */
     1649 
     1650 	  else do;
     1651 	     dfm_data.cptr = addr (r_card.nxt_c_wd);	/* set for nxt control word */
     1652 	     psz = 0;				/* pad size = 0 */
     1653 	     m = m + r_card.count;			/* increment counter */
     1654 	  end;
     1655          end;
     1656 
     1657          glrp = addrel (glrp, currentsize (glr));		/* set next logical record */
     1658          if glr.rcw.media_code ^= binary_media_code
     1659 	& glr.rcw.media_code ^= bcd_media_code then	/* ck for new blk */
     1660 	  if glrp -> gpr.bcw.bsn = bcnt then		/* if looks like bcw */
     1661 	     glrp = addrel (glrp, 1);			/* go to nxt word */
     1662       end;
     1663 
     1664 /* we have all of the ident block loaded, now lets find the words we are interested in */
     1665 
     1666       term = false;
     1667 
     1668       do i = lbound (ident_buf, 1) to hbound (ident_buf, 1) while (^term);
     1669          if ident_buf (i) = mpcbot then			/* if word = "mpcbot" in bcd */
     1670 	  term = true;
     1671       end;
     1672 
     1673       cvp = addr (ident_buf (i - 10));			/* cvp pts to beginning of ident block */
     1674       call bcd_to_ascii_ (id_bbuf, dfm_data.id_buf);	/* convert ident block to ascii */
     1675       glrp = svp;
     1676 
     1677    end load_ident;
     1678 
     1679 
     1680 
     1681 
     1682 
     1683 /* put_hdr - int proc to output a listing page header */
     1684 
     1685 put_hdr: proc ();
     1686 
     1687       if lcata.n_entries = 0 & (dfm_data.deckfile_sw | dfm_data.mdf) then do;
     1688          call get_cata (dfm_datap, dfm_data.fiocb_ptr,
     1689 	"ls.cata." || dfm_data.ls_type || ".list", dfm_data.lcatp, dfm_data.lksp, code);
     1690          if code ^= 0 then
     1691 	  call dfm_$complain (dfm_datap, wrapup, code, "can't get list catalog", "");
     1692       end;
     1693 
     1694       allocate hbuff in (free_area) set (dfm_data.hbuff_p);
     1695       hbuff = "";
     1696 
     1697       if dfm_data.lfd then do;
     1698 
     1699          call ioa_$rs ("^| ^- Library - MCA ^61tTime - ^a", /* page# added during output */
     1700 	hbuff (1), hbuff_len, dfm_data.time_string);
     1701 
     1702          call ioa_$rs ("^10t Contents of MCA Diskette - ^a^51tStored in ^a>^a ",
     1703 	hbuff (2), hbuff_len, dfm_data.current_disk_name, dfm_data.dir, dfm_data.entry);
     1704 
     1705          call ioa_$rs ("^9t File ^24t DATE ^45t SS ^66t Record ^87t Location ^96t Record", hbuff (3), hbuff_len);
     1706 
     1707          call ioa_$rs ("^9t N__a_m_e ^20t M__o_d_i_f_i_e_d ^32t _t_y_p_e ^65t S__e_a_r_c_h K__e_y ^82t C__o_m_p      O__f_f_s_e_t    L__e_n_g_t_h (B__y_t_e_s)",
     1708 	hbuff (4), hbuff_len);
     1709       end;
     1710 
     1711       else do;
     1712          call ioa_$rs ("^|^-^a ^[POL^s^;^a ^] ^61tTime - ^a", /* page# added during output */
     1713 	hbuff (1), hbuff_len, "Library -", dfm_data.fnp_tape, o_card.library, dfm_data.time_string);
     1714 
     1715          call ioa_$rs ("^a ^[FNP ^a ^a^1s^;^2s^a^] ^a^51tStored in ^a>^a",
     1716 	hbuff (2), hbuff_len, "Contents of", dfm_data.fnp_tape, dfm_data.fnp_type, "Binary Deck Tape",
     1717 	"ITR, Firmware And Diagnostic (IFAD) Tape", dfm_data.tape_name, dfm_data.dir, dfm_data.entry);
     1718 
     1719          call ioa_$rs (" ^[ Call^;     ^]   ^a     ^[^a^2-^s^;^s ^a^2-^]^-^[ ^[^a^]^;^2s      ^a^]",
     1720 	hbuff (3), hbuff_len, (o_card.call_name ^= "" & ^dfm_data.fnp_tape), hdra,
     1721 	dfm_data.lib, hdra1, hdra2, dfm_data.list, ^dfm_data.fnp_tape, hdra4, hdra3);
     1722 
     1723 
     1724          call ioa_$rs (" ^[ N__a_m_e^;     ^]   ^a    ^[^a^s^;^s^a^2-^]^-^[^[^a^]^;^2s    ^a^]",
     1725 	hbuff (4), hbuff_len, (o_card.call_name ^= "" & ^dfm_data.fnp_tape), hdrb,
     1726 	dfm_data.lib, hdrb1, hdrb2, dfm_data.list, ^dfm_data.fnp_tape, hdrb4, hdrb3);
     1727       end;
     1728 
     1729       if dfm_data.deckfile_sw | dfm_data.mdf then do i = lbound (hbuff, 1) to hbound (hbuff, 1);
     1730          header_key = "ls." || rtrim (dfm_data.lib_type) || "." || rtrim (dfm_data.dtype) || ".hdr" || ltrim (char (i));
     1731          call insert_deck (dfm_datap, dfm_data.fiocb_ptr, addr (hbuff (i)),
     1732 	length (rtrim (hbuff (i))), header_key);
     1733          if index (lcata_key_string, header_key) = 0 then do;
     1734 	  lcata.n_entries = lcata.n_entries + 1;
     1735 	  lcata.key (lcata.n_entries) = header_key;
     1736          end;
     1737       end;
     1738 
     1739       free dfm_data.hbuff_p -> hbuff in (free_area);
     1740       dfm_data.hbuff_p = null;
     1741       dfm_data.hdr_sw = false;			/* do header only once */
     1742 
     1743    end put_hdr;
     1744 
     1745 
     1746 
     1747 /* put_patch - int proc to add patch card images to listing file */
     1748 
     1749 put_patch: proc;
     1750 
     1751 
     1752       allocate lbuff in (free_area) set (dfm_data.lbuff_p);
     1753       lbuff = "";
     1754       call ioa_$rs ("^/The following patch cards are contained in the above deck:^/", lbuff, lbuff_len);
     1755       patch_key = "ls." || rtrim (work_key) || ".P.0";
     1756 
     1757       do i = 0 to p_blk.p_cnt;			/* output all patches */
     1758          cx = index (lcata_key_string, rtrim (patch_key)) / 24 + 1; /* see if patch exists */
     1759          if cx = 1 then do;				/* no patch found */
     1760 
     1761 	  cx = index (lcata_key_string, rtrim (work_key)) / 24 + 1; /* find entry for deck */
     1762 	  lcata.n_entries = lcata.n_entries + 1;	/* bump total */
     1763 	  do j = lcata.n_entries to cx + i + 1 by -1;	/* make a slot */
     1764 	     lcata.key (j) = lcata.key (j - 1);
     1765 	  end;
     1766 	  lcata.key (cx + i + 1) = rtrim (patch_key);	/* insert new key in slot */
     1767          end;
     1768          else lcata.key (cx) = rtrim (patch_key);		/* key there - overwrite it */
     1769          call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p,
     1770 	length (rtrim (lbuff)), rtrim (patch_key));
     1771 
     1772          if i < p_blk.p_cnt then do;			/* set up for next patch */
     1773 	  call ioa_$rs ("^5t^a^/", lbuff, lbuff_len, rtrim (p_blk.p_card (i + 1)));
     1774 	  patch_key = "ls." || rtrim (work_key) || ".P." || ltrim (char (i + 1));
     1775          end;
     1776       end;
     1777 
     1778       free dfm_data.lbuff_p -> lbuff in (free_area);
     1779       dfm_data.lbuff_p = null;
     1780       p_blk.p_cnt = 0;				/* initialize count */
     1781 
     1782    end put_patch;
     1783 
     1784 
     1785 
     1786 
     1787 /* remove_patch - int proc to remove a patch from deckfile */
     1788 
     1789 remove_patch: proc ();
     1790 
     1791       px = p_blk.p_cnt;
     1792 
     1793       do i = 1 to px;				/* now remove the patch */
     1794          p_blk.p_card (i) = p_blk.p_card (i + 1);
     1795       end;
     1796 
     1797       p_blk.p_cnt = p_blk.p_cnt - 1;			/* from patch block */
     1798       patch_key = "ls." || rtrim (work_key) || ".P.1";
     1799 
     1800 dl_patch:
     1801       cx = index (lcata_key_string, rtrim (patch_key)) / 24;
     1802 
     1803       do i = 1 to lcata.n_entries - 1 - cx;		/* move all entries down */
     1804          lcata.key (cx + i) = lcata.key (cx + 1 + i);
     1805       end;
     1806 
     1807       lcata.key (lcata.n_entries) = "";
     1808       lcata.n_entries = lcata.n_entries - 1;
     1809 
     1810       if index (patch_key, ".P.0") = 0 & p_blk.p_cnt > 0 then
     1811          do i = 1 to px;				/* change the key names */
     1812          lcata.key (cx + i) = lcata.key (cx + i);
     1813          lcata.key (cx + i) = "ls." || rtrim (work_key) || ".P." || ltrim (char (i));
     1814       end;
     1815 
     1816       call iox_$seek_key (dfm_data.fiocb_ptr, patch_key, rec_len, code); /* set key for deletion */
     1817       if code ^= 0 then
     1818          call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek ^a", patch_key);
     1819 
     1820       call iox_$delete_record (dfm_data.fiocb_ptr, code);
     1821       if code ^= 0 then
     1822          call dfm_$complain (dfm_datap, wrapup, code, "attempting to delete ^a", patch_key);
     1823 
     1824       if p_blk.p_cnt = 0 & index (patch_key, ".P.0") = 0 then do; /* cnt = 0 patch key not header */
     1825          patch_key = "ls." || rtrim (work_key) || ".P.0";
     1826          goto dl_patch;
     1827       end;
     1828 
     1829    end remove_patch;
     1830 
     1831 
     1832 
     1833 
     1834 /* space_file - int proc to formward space to nxt tape file */
     1835 
     1836 space_file: proc ();
     1837 
     1838       call iox_$control (dfm_data.tiocb_ptr, "forward_file", null, code);
     1839       if code ^= 0 then
     1840          call dfm_$complain (dfm_datap, wrapup, code, "while spacing a tape file", "");
     1841       dfm_data.cfile = dfm_data.cfile + 1;		/* set correct position */
     1842       dfm_data.crec = 0;
     1843       dfm_data.one_eof = true;			/* set eof flag */
     1844 
     1845    end space_file;
     1846 
     1847 
     1848 
     1849 /* write_copy - int proc to write current deck to copy tape */
     1850 
     1851 write_copy: proc ();
     1852 
     1853       if ^dfm_data.first_write then do;			/* if this is the first time thru, set density */
     1854          dfm_data.first_write = true;			/* set flag so we don't come back */
     1855 
     1856          if dfm_data.cd_sw | dfm_data.denno ^= 0 then do;	/* if user specified density */
     1857 	  if dfm_data.denno ^= 0 & ^dfm_data.cd_sw then	/* if master tape not standard density */
     1858 	     cden = density (dfm_data.denno);		/* set copy to same  (if not user specified) */
     1859 	  call iox_$control (dfm_data.ciocb_ptr, cden, null, code);
     1860 	  if code ^= 0 then
     1861 	     call dfm_$complain (dfm_datap, wrapup, code, "while setting copy tape density", "");
     1862          end;
     1863       end;
     1864 
     1865       gprp = dfm_data.bptr;				/* set block ptr to first phy. record */
     1866 
     1867       do while (bin (rel (gprp)) < dfm_data.dlen - 1 & ^dfm_data.eot); /* wrt entire deck */
     1868          c_rtrycnt = 0;				/* initialize retry count */
     1869 retry_cp:
     1870          call iox_$write_record (dfm_data.ciocb_ptr, gprp, (gpr.bcw.blk_size + 1) * 4, code);
     1871          if code ^= 0 then				/* if error */
     1872 
     1873 	  if code = error_table_$tape_error then do;	/* if write error */
     1874 	     c_rtrycnt = c_rtrycnt + 1;		/* increment retry count */
     1875 
     1876 	     if c_rtrycnt > max_retrys then do;		/* exceeded error threshold */
     1877 	        call iox_$control (dfm_data.ciocb_ptr, "saved_status", addr (t_stat), scode);
     1878 	        call dfm_$complain (dfm_datap, print, code,
     1879 	         "Tape status = ^4.3b, while writing copy tape after 10 retrys", t_stat);
     1880 	        dfm_data.eot = true;
     1881 	     end;
     1882 
     1883 	     else do;
     1884 	        call iox_$control (dfm_data.ciocb_ptr, "backspace_record", null, scode);
     1885 	        call iox_$control (dfm_data.ciocb_ptr, "erase", null, scode);
     1886 	        go to retry_cp;
     1887 	     end;
     1888 	  end;
     1889 
     1890 	  else do;				/* not a tape error */
     1891 	     call dfm_$complain (dfm_datap, print, code, "while writing copy tape", "");
     1892 	     dfm_data.eot = true;			/* set abort flag */
     1893 	  end;
     1894          else gprp = addrel (gprp, currentsize (gpr));	/* no error advance to next block */
     1895       end;
     1896       dfm_data.copy_at_eof = false;			/* we are no longer at an eof mark */
     1897 
     1898    end write_copy;
     1899 
     1900 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1901 
     1902 
  2     1 /* ak_info -- include file for info structures used by the following vfile_
  2     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  2     3*   Created by M. Asherman 3/23/76
  2     4*   Modified 5/13/77 to add separate gk_info structure */
  2     5 
  2     6      dcl	   1 ak_info	      based (ak_info_ptr),
  2     7 	     2 header	      like ak_header,
  2     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  2     9 
  2    10      dcl	   1 ak_header	      based (ak_info_ptr),
  2    11 	     2 flags	      aligned,
  2    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  2    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  2    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  2    15 	     2 descrip	      fixed (35),		/* record designator */
  2    16 	     2 key_len	      fixed;
  2    17 
  2    18      dcl	   ak_info_ptr	      ptr;
  2    19      dcl	   ak_key_len	      fixed;
  2    20 
  2    21 
  2    22      dcl	   1 rk_info	      based (rk_info_ptr),
  2    23 	     2 header	      like rk_header,
  2    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  2    25 
  2    26      dcl	   1 rk_header	      based (rk_info_ptr),
  2    27 	     2 flags	      aligned,
  2    28 	       3 input_key	      bit (1) unal,		/* same as above */
  2    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  2    30*						   given by old_descrip */
  2    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  2    32 	       3 mbz	      bit (33) unal,
  2    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  2    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  2    35 	     2 key_len	      fixed;
  2    36 
  2    37      dcl	   rk_info_ptr	      ptr;
  2    38      dcl	   rk_key_len	      fixed;
  2    39 
  2    40 
  2    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  2    42 	     2 header	      like gk_header,
  2    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  2    44 						/* may be Input as well as Output */
  2    45 
  2    46      dcl	   1 gk_header	      based (gk_info_ptr),
  2    47 	     2 flags	      aligned,
  2    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  2    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  2    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  2    51 	       3 position_specification
  2    52 			      unal,
  2    53 	         4 current	      bit (1) unal,		/* otherwise next */
  2    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  2    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  2    56 						/* size of head for initial seek */
  2    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  2    58 	       3 pad	      bit (8) unal,
  2    59 	       3 version	      fixed (8) unal,
  2    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  2    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  2    62 
  2    63      dcl	   gk_info_ptr	      ptr;
  2    64      dcl	   gk_key_len	      fixed;
  2    65 
  2    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  2    67 
  2    68 /* end ak_info.incl.pl1 */
     1903 
     1904 
  3     1 /*  START OF:	dfm_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-08-21,Fakoury), approve(86-08-21,MCR7515),
  3     6*     audit(87-01-07,Farley), install(87-01-08,MR12.0-1263):
  3     7*     Originally coded 0782 dfm_data.by Rick Fakoury for MR12.
  3     8*  2) change(88-06-10,Fakoury), approve(90-10-03,MCR8147),
  3     9*     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
  3    10*     Modified to add new diskettes to valid diskettes.
  3    11*  3) change(89-02-06,Fakoury), approve(90-10-03,MCR8147),
  3    12*     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
  3    13*     to to increase the size of att_desc from 64 to 181 for TR21336.
  3    14*                                                   END HISTORY COMMENTS */
  3    15 
  3    16 
  3    17 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
  3    18 
  3    19 
  3    20 
  3    21 dcl  dfm_datap ptr;
  3    22 
  3    23 dcl  1 dfm_data based (dfm_datap),
  3    24        2 allow_0_cksum bit (1),
  3    25        2 ascii_card char (80) aligned,
  3    26        2 attach_copy bit (1),
  3    27        2 bf_sw bit (1),				/* flag to suppress informative messages */
  3    28        2 bptr ptr,					/* data buffer ptr */
  3    29        2 catp ptr,					/* catalog ptr */
  3    30        2 cat_build bit (1),
  3    31        2 cat_key char (24),				/* catalog key */
  3    32        2 cd_sw bit (1),				/* user set copy tape density */
  3    33        2 cfile fixed bin,				/* copy file number */
  3    34        2 ciocb_ptr ptr,				/* copy iocb ptr */
  3    35        2 cksp ptr,					/* cata key string ptr */
  3    36        2 copy_at_eof bit (1),				/* copy tape at eot */
  3    37        2 cptr ptr,					/* card ptr */
  3    38        2 crec fixed bin,				/* record number */
  3    39        2 current_disk_name char (8),
  3    40        2 current_filename char (20) varying,
  3    41        2 current_key char (24) varying,
  3    42        2 dcatp ptr,					/* diskette catalog ptr */
  3    43        2 dd bit (1),				/* delete deck flag */
  3    44        2 deckfile_sw bit (1),
  3    45        2 denno fixed bin,				/* tape density number */
  3    46        2 dfkp ptr,
  3    47        2 dkf_iocbp (3) ptr,
  3    48        2 dir char (168),
  3    49        2 disk_num fixed bin,
  3    50        2 dksp ptr,					/* diskette key string ptr */
  3    51        2 dlen fixed bin (21),				/* data move length */
  3    52        2 dtype char (4),				/* deck type */
  3    53        2 edit_date char (6),
  3    54        2 eot bit (1),				/* end of tape flag */
  3    55        2 entry char (32),
  3    56        2 fiocb_ptr ptr,				/* deck file iocb ptr */
  3    57        2 finished bit (1),				/* request active */
  3    58        2 firmware_sw bit (1),				/* just loading firmware */
  3    59        2 first_deck bit (1),
  3    60        2 first_write bit (1),
  3    61        2 fnp_key fixed bin,
  3    62        2 fnp_tape bit (1),
  3    63        2 fnp_type char (4),
  3    64        2 gtime_string char (6),			/* GCOS time format */
  3    65        2 hbuff_p ptr,				/* pointer to a header buffer */
  3    66        2 hdr_sw bit (1),				/* listing header required */
  3    67        2 hpatches (10) like h_patch aligned,		/* hex patches */
  3    68        2 id_buf char (18) aligned,			/* buffer to hold current ident block image */
  3    69        2 infop ptr,					/* backward ptr to dfm_info structure */
  3    70        2 l_att_desc char (181),			/* listing file attach description */
  3    71        2 lbuff_p ptr,				/* ptr to a line buffer */
  3    72        2 lcatp ptr,					/* listing catalog ptr */
  3    73        2 lksp ptr,					/* listing key string pointer */
  3    74        2 lfd bit (1),				/* load from diskette flag */
  3    75        2 lft bit (1),				/* load from tape flag */
  3    76        2 lib bit (1),				/* mpc library */
  3    77        2 lib_type char (6),
  3    78        2 liocb_ptr ptr,				/* listing iocb ptr */
  3    79        2 list bit (1),				/* creating a listing */
  3    80        2 list_key char (24) varying,
  3    81        2 ls_type char (10) varying,			/* list type fnp, ifad, mca */
  3    82        2 m_attached bit (1),				/* mca attached */
  3    83        2 mca_ioi_idx fixed bin,
  3    84        2 mca_wksp ptr,				/* ptr to the mca workspace */
  3    85        2 mcatp ptr,					/* mca catalog ptr */
  3    86        2 mdf bit (1),				/* merge deckfile request active */
  3    87        2 mksp ptr,					/* mca key string ptr */
  3    88        2 obj_card char (80) aligned,			/* buffer to hold current object card image */
  3    89        2 of_iocbp ptr,				/* deckfile iocb ptr for merge deckfile */
  3    90        2 one_eof bit (1),
  3    91        2 opatches (10) like o_patch aligned,		/* octal patches */
  3    92        2 page_no fixed bin,
  3    93        2 pd bit (1),				/* patch deck active */
  3    94        2 pfile fixed bin,				/* file number */
  3    95        2 sci_ptr ptr,				/* save here for use by the utilities */
  3    96        2 sstype char (5),				/* subsytem type */
  3    97        2 statp ptr,					/* status ptr */
  3    98        2 sub_ptr ptr,				/* substatus ptr */
  3    99        2 t_att_desc char (181),			/* tape attach description */
  3   100        2 tape_name char (16),
  3   101        2 terminal_out bit (1),			/* output listing on terminal */
  3   102        2 tiocb_ptr ptr,				/* tape iocb ptr */
  3   103        2 time_string char (24);			/* Current date and time */
  3   104 
  3   105 
  3   106 
  3   107 /* CONSTANTS */
  3   108 
  3   109 dcl  cata_list_type fixed bin (2) int static options (constant) init (2);
  3   110 
  3   111 dcl  data_list_type fixed bin (2) int static options (constant) init (1);
  3   112 
  3   113 dcl  lc char (26) int static options (constant) init
  3   114       ("abcdefghijklmnopqrstuvwxyz");
  3   115 
  3   116 dcl  list_types (3) char (17) int static options (constant) init
  3   117       ("ls.cata.fnp.list", "ls.cata.ifad.list", "ls.cata.mca.list");
  3   118 
  3   119 dcl  max_words_to_rd fixed bin (21) int static options (constant) init (16 * 1024);
  3   120 dcl  uc char (26) int static options (constant) init
  3   121       ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  3   122 
  3   123 dcl  valid_diskettes (14) char (5) static options (constant) init
  3   124       ("con..", "fip..", "hsh..", "idpm.", "imu..", "mhlp.", "ndi..",
  3   125            "psa..", "psi..", "pt1..", "pt2..", "sel..", "urd..", "urp..");
  3   126 
  3   127 
  3   128 /* STRUCTURES and BASED VARIABLES */
  3   129 
  3   130 dcl  1 cata based (dfm_data.catp) aligned,		/* template for itr or mdr catalog */
  3   131        2 n_entries fixed bin,				/* number of catalog entries */
  3   132        2 key (1 refer (cata.n_entries)) char (24);	/* entry search keys */
  3   133 
  3   134 dcl  1 dcata based (dfm_data.dcatp) aligned,		/* template for a diskette catalog */
  3   135        2 n_entries fixed bin,				/* number of catalog entries */
  3   136        2 key (1 refer (dcata.n_entries)) char (24);	/* entry search keys */
  3   137 
  3   138 dcl  hbuff (4) char (300) based (dfm_data.hbuff_p);
  3   139 
  3   140 dcl  lbuff char (300) based (dfm_data.lbuff_p);
  3   141 
  3   142 
  3   143 
  3   144 dcl  1 lcata based (dfm_data.lcatp) aligned,		/* template for a list catalog */
  3   145        2 n_entries fixed bin,				/* number of catalog entries */
  3   146        2 key (1 refer (lcata.n_entries)) char (24);	/* entry search keys */
  3   147 
  3   148 dcl  1 mcata based (dfm_data.mcatp) aligned,		/* template for a MCA catalog */
  3   149        2 n_entries fixed bin,				/* number of catalog entries */
  3   150        2 key (1 refer (mcata.n_entries)) char (24);	/* entry search keys */
  3   151 
  3   152 dcl  cata_key_string char (cata.n_entries * 24) based (dfm_data.cksp);
  3   153 
  3   154 dcl  dcata_key_string char (dcata.n_entries * 24) based (dfm_data.dksp);
  3   155 
  3   156 dcl  lcata_key_string char (lcata.n_entries * 24) based (dfm_data.lksp);
  3   157 
  3   158 dcl  mcata_key_string char (mcata.n_entries * 24) based (dfm_data.mksp);
  3   159 
  3   160 dcl  ascii_cardp ptr;
  3   161 
  3   162 dcl  1 h_patch based (ascii_cardp) aligned,		/* template for hex patch card */
  3   163        (2 add char (4),				/* (c1) hex patch address */
  3   164        2 blk1 char (2),
  3   165        2 type char (4),				/* (c7) = "c" for cs, "r" for r/w mem  hex */
  3   166        2 blk2 char (5),
  3   167        2 inst char (4),				/* (c16) 2 - 4 hex digit instructions */
  3   168        2 blk3 char (23),
  3   169        2 prg_id char (12),				/* (c43) should equal word 2 of deck id block */
  3   170        2 blk4 char (5),
  3   171        2 dtime char (6),				/* (c60) date time of patch */
  3   172        2 blk5 char (1),
  3   173        2 rev char (6),				/* (c67) revision of dkend */
  3   174        2 lbl char (4),				/* (c73) = deck edit name */
  3   175        2 blk6 char (4)) unaligned;			/*  complete card format */
  3   176 
  3   177 dcl  1 id_blk based (addr (dfm_data.id_buf)) aligned,	/* template for ident block */
  3   178          (2 ident char (6),				/* module identification */
  3   179        2 revision,
  3   180          3 rev_dot char (4),				/* char string "rev." */
  3   181          3 rev char (2),				/* alpa-numeric revision */
  3   182        2 type_code,
  3   183          3 pad char (3),
  3   184          3 type char (3)) unaligned;			/* module type (itr, mdr or firmware) */
  3   185 
  3   186 dcl  1 mca_status based (dfm_data.statp),
  3   187        2 pad bit (2) unal,
  3   188        2 maj bit (4) unal,
  3   189        2 sub bit (4) unal,
  3   190        2 pad2 bit (62) unal;
  3   191 
  3   192 dcl  1 mca_sub based (dfm_data.sub_ptr) unal,
  3   193        2 data_p bit (1) unal,
  3   194        2 mbz bit (3) unal,
  3   195        2 term_state bit (2) unal;
  3   196 
  3   197 dcl  1 o_patch based (ascii_cardp) aligned,		/* template for octal patch card */
  3   198        (2 add char (6),				/* (c1) patch address */
  3   199        2 blk1 char (1),
  3   200        2 type char (5),				/* (c8) = "octal" | "mask " */
  3   201        2 blk2 char (3),
  3   202        2 p_fld char (51),				/* (c16) variable fieled (patch data) */
  3   203        2 dtime char (6),				/* (c67) date of patch */
  3   204        2 label char (6),				/* (c73) dk label */
  3   205        2 blk3 char (2)) unaligned;			/* to finish off card */
  3   206 
  3   207 
  3   208 
  4     1 /* include file for info structure used with record_status control order
  4     2*   created by M. Asherman 1/6/76 */
  4     3 /* modified 6/15/77 to support stationary type records */
  4     4 
  4     5      dcl	   rs_info_ptr	      ptr;
  4     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
  4     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
  4     8 	     2 flags	      aligned,
  4     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
  4    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
  4    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
  4    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
  4    13*						   located outside the index by descrip, or created without key */
  4    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
  4    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
  4    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
  4    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
  4    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
  4    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
  4    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
  4    21*						   Input if create_sw is set--overrides min_block_size in effect */
  4    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
  4    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
  4    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
  4    25 	     2 time_last_modified fixed (71),		/* Output */
  4    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
  4    27 	     2 block_ptr	      ptr unal,		/* Output */
  4    28 	     2 last_image_modifier
  4    29 			      fixed (35),
  4    30 	     2 mbz2	      fixed;
  4    31 
  4    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
  4    33 						/* record block descriptor structure */
  4    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
  4    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
  4    36 
  4    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
  4    38 						/* for sequential files */
  4    39 	     2 bitno	      bit (6) unal,
  4    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
  4    41 	     2 wordno	      bit (18) unal;	/* word offset */
  4    42 
  4    43      dcl	   rs_info_version_1      static internal fixed init (1);
  4    44      dcl	   rs_info_version_2      static internal fixed init (2);
  4    45 
  3   209 
  3   210 
  3   211 
  3   212 /*  END OF:	dfm_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1905 
     1906 
  5     1 
  5     2 /* BEGIN INCLUDE FILE: gcos_ssf_records.incl.pl1 */
  5     3 
  5     4 /* Created by J. A. Bush 05/07/80 */
  5     5 
  5     6 dcl  prptr ptr;					/* GCOS physical record pointer */
  5     7 dcl  lrptr ptr;					/* GCOS logical record pointer */
  5     8 
  5     9 dcl 1 gc_phy_rec based (prptr) aligned,			/* GCOS ssf format (physical record) */
  5    10     2 bcw unaligned,				/* block control word */
  5    11      (3 bsn fixed bin (18),				/* block serial number */
  5    12       3 blk_size fixed bin (18)) unsigned,		/* block size (-bcw) */
  5    13     2 gc_phy_rec_data (0 refer (gc_phy_rec.bcw.blk_size)) bit (36);
  5    14 
  5    15 dcl 1 gc_log_rec based (lrptr) aligned,			/* GCOS ssf logical record format */
  5    16     2 rcw unaligned,				/* record control word */
  5    17      (3 rsize fixed bin (18),				/* size of rcd (-rcw) */
  5    18       3 nchar_used fixed bin (2),			/* characters used in last word */
  5    19       3 file_mark fixed bin (4),			/* file mark if rsize = 0 */
  5    20       3 mbz1 fixed bin (2),
  5    21       3 media_code fixed bin (4),			/* file media code */
  5    22       3 report_code fixed bin (6)) unsigned,		/* report code */
  5    23     2 gc_log_rec_data (0 refer (gc_log_rec.rcw.rsize)) bit (36); /* logical record data */
  5    24 
  5    25 dcl  gc_phy_rec_bits bit (gc_phy_rec.bcw.blk_size * 36) based (addr (gc_phy_rec.gc_phy_rec_data));
  5    26 dcl  gc_log_rec_bits bit (gc_log_rec.rcw.rsize * 36) based (addr (gc_log_rec.gc_log_rec_data));
  5    27 
  5    28 /* END INCLUDE FILE: gcos_ssf_records.incl.pl1 */
     1907 
     1908 
  6     1 
  6     2 /* BEGIN INCLUDE FILE gload_data.incl.pl1 */
  6     3 /* created 9/29/78 by James A. Bush */
  6     4 
  6     5 dcl 1 gload_data aligned,				/* pertinent info  generated from gload_ */
  6     6    (2 deck_name char (4),				/* name from columns 73-76 of $ object card */
  6     7     2 deck_type bit (1),				/* "0"b = absolute, "1"b = relocatable */
  6     8     2 sym_cnt fixed bin (16),				/* count of valid symbols */
  6     9     2 text_len bit (18),				/* length in words including load offset */
  6    10     2 checksum bit (36),				/* checksum of loaded deck */
  6    11     2 diagnostic char (200),				/* loader diagnostic */
  6    12     2 definition (128),				/* array of definitions */
  6    13       3 symbol char (6),				/* symbol name */
  6    14       3 pad1 bit (18),
  6    15       3 offset bit (18),				/* symbol offset in text */
  6    16       3 pad2 bit (14),
  6    17       3 sym_type fixed bin (3)) unaligned;		/* type of symbol (0 - 7) */
  6    18 
  6    19 /* END INCLUDE FILE gload_data.incl.pl1 */
  6    20 
     1909 
     1910 
  7     1 /* Begin include file ..... iox_modes.incl.pl1 */
  7     2 
  7     3 /* Written by C. D. Tavares, 03/17/75 */
  7     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  7     5 
  7     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  7     7     ("stream_input", "stream_output", "stream_input_output",
  7     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  7     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  7    10      "direct_input", "direct_output", "direct_update");
  7    11 
  7    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  7    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  7    14 
  7    15 dcl (Stream_input initial (1),
  7    16      Stream_output initial (2),
  7    17      Stream_input_output initial (3),
  7    18      Sequential_input initial (4),
  7    19      Sequential_output initial (5),
  7    20      Sequential_input_output initial (6),
  7    21      Sequential_update initial (7),
  7    22      Keyed_sequential_input initial (8),
  7    23      Keyed_sequential_output initial (9),
  7    24      Keyed_sequential_update initial (10),
  7    25      Direct_input initial (11),
  7    26      Direct_output initial (12),
  7    27      Direct_update initial (13)) fixed bin int static options (constant);
  7    28 
  7    29 /* End include file ..... iox_modes.incl.pl1 */
     1911 
     1912 
  8     1 /* Begin mca_area.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
  8     6*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
  8     7*     This is the structure returned to the user after IO completion.
  8     8*                                                   END HISTORY COMMENTS */
  8     9 
  8    10 dcl  1 mca_area aligned based (mca_area_ptr),
  8    11        2 version char (8),                 /* version of structure */
  8    12        2 io_outstanding bit (1) aligned,   /* true if section is not complete */
  8    13        2 mca_attach_state fixed bin (17),  /* State of the attachment process, refer to mca_data.incl.pl1 */
  8    14        2 mca_status bit (72),		   /* status from io */
  8    15        2 ret_len fixed bin (21);	   /* length in characters of data returned */
  8    16 
  8    17 dcl  mca_area_ptr ptr;
  8    18 
  8    19 dcl  MCA_area_version_1 char (8) int static options
  8    20 	(constant) init ("MCA00001");     /* current version */
  8    21 
  8    22 
  8    23 /* End mca_area.incl.pl1 */
     1914 
  9     1 /* Begin mca_config_file.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
  9     6*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
  9     7*     This is used to view the configuration file obtained from the MCA.
  9     8*                                                   END HISTORY COMMENTS */
  9     9 
  9    10 /* Created by R. A. Fawcett Sept 1984 based on data obtained from
  9    11*   "EPS-1 Dipper Firmware Loading" Rev B   (July 05x 1983)
  9    12*   section 3.5.1 starting on sheet 25 */
  9    13 
  9    14 dcl  mca_config_file_ptr ptr;
  9    15 
  9    16 dcl 1 mca_config_file based (mca_config_file_ptr),
  9    17     2 diskette_data,				/* total of 20 chars (bytes) */
  9    18       3 unique_id char (8),				/* User ID assiged to diskette from which FW was loaded */
  9    19       3 date_created char (6),			/* MMDDYY */
  9    20       3 date_late_changed char (6),			/* MMDDYY */
  9    21     2 iioc_data,					/* total of 31 chars (bytes) */
  9    22       3 iioc_config char (8),				/* mca path_name of file used to load from */
  9    23       3 iioc_state_control,
  9    24         4 will_be_zero_1 bit (1),			/* zero because of 8 bit-byte to 9 bit-byte */
  9    25         4 state_counter fixed bin (5) unsigned unal,	/* values are not defined */
  9    26 						/* control bits ??? */
  9    27         4 RFU_1 bit (1),
  9    28         4 RFU_2 bit (1),
  9    29         4 write_protect_ptw_sw bit (1),
  9    30       3 operating_system fixed bin (9) unal unsigned,	/* better be a value equal to Multics */
  9    31       3 iioc_num fixed bin (9) unal unsigned,		/* the number of the imu  */
  9    32       3 iioc_disk_tab fixed bin (9) unal unsigned,
  9    33 						/* The value of the TAB number of the Diskette_Product_Set
  9    34*						   containing the proper revision of diagnostics for IIOC */
  9    35       3 p_s_disk_tab fixed bin (9) unal unsigned,
  9    36 						/* same as iioc_disk_tab only for the Port Select */
  9    37       3 port_select_state fixed bin (9) unal unsigned,
  9    38 						/* State counter values will exists which uniquely define:
  9    39*						   o P. S. not loaded
  9    40*						   o Single port
  9    41*						   o Load failed
  9    42*						   o Read failed
  9    43*						   o Verify failed
  9    44*						   o P. S. loaded */
  9    45       3 config_valid char (1),			/* ascii number of drive this config was read from. if value = "000"b3 drive door has been opened. */
  9    46       3 iioc_rfu char (2),
  9    47     2 bootstrap_data,				/* total of 15 chars (bytes) */
  9    48       3 control fixed bin (9) unal unsigned,
  9    49 						/* 0 = bootstrap not configured
  9    50*						   1 = bootstrap allowed
  9    51*						   2 = auto boot at power up  */
  9    52       3 imu_port_at_scu fixed bin (9) unal unsigned,	/* port number for bootstrap (0 to 7) */
  9    53       3 chan_num fixed bin (9) unal unsigned,		/* bootstrap channel number (8 to 63) */
  9    54       3 dev_num fixed bin (9) unal unsigned,		/* bootstrap device number (1 to 63) */
  9    55       3 int_base char (4),
  9    56       3 mb_base char (4),
  9    57       3 boot_src fixed bin (9) unal unsigned,		/* bootstrap source 1=card, 2=tape, 3=disk */
  9    58       3 unatt_op fixed bin (9) unal unsigned,		/* 1 = unattended operation */
  9    59       3 boot_rfu bit (9),
  9    60     2 port_data (0:3),				/* total 28 chars (bytes) */
  9    61       3 enable fixed bin (9) unal unsigned,		/* 1 = port enable */
  9    62       3 init fixed bin (9) unal unsigned,		/* 1 = init allowed */
  9    63       3 ilace char (1),				/* no interlace = "000"b3, A,B,C,D = the other port for interlace */
  9    64       3 port_size,
  9    65         4 msb_ign1 bit (1),
  9    66         4 msb bit (8),
  9    67         4 lsb_ign1 bit (1),
  9    68         4 lsb bit (8),
  9    69       3 disk_tab fixed bin (9) unal unsigned,		/* value of TAB number of the
  9    70*						   D_P_S containing the proper revision of diagnostics
  9    71*						   for port adapter. */
  9    72       3 assignment fixed bin (9) unal unsigned,		/* (0 - 3) */
  9    73     2 channel_data (0:15),				/* total of 160 bytes */
  9    74       3 lvl_1_state fixed bin (9) unal unsigned,		/* State counter valuse define:
  9    75*						   = No config present
  9    76*						   = Not configured
  9    77*						   = Phyically not present
  9    78*						   = Basic ROM test failed (mico IPCs only)
  9    79*						   = Jam test failed (mico IPCs only)
  9    80*						   = Self test failed  (mico IPCs only)
  9    81*						   = HW ID does not match config ID
  9    82*						   = Console set up failed (console only)
  9    83*						   = RSO failed (PSIA only)
  9    84*						   = FW not found on diskette (FW loadable IPCS only)
  9    85*						   = Alter file not found
  9    86*						   = Alter load failed
  9    87*						   = FW execute failed (FW loadable IPCS only)
  9    88*						   = Operational
  9    89*						   = Stop On condition occured
  9    90*						   */
  9    91       3 lvl_1_ctl_att,
  9    92         4 ctl_ign1 bit (1),
  9    93         4 ctl1 bit (1),				/* if master console true = rmt_maint
  9    94*						   else true = RSO required at init */
  9    95         4 ctl2 bit (1),				/* if master console true = master
  9    96*						   else reserved of future use */
  9    97         4 ctl3 bit (1),				/* if master console true = active/slave
  9    98*						   else true = 18X */
  9    99         4 ctl_p2 bit (5),
  9   100       3 disk_tab fixed bin (9) unal unsigned,
  9   101 						/* Tab number of the D_P_S containing the proper revision of diagnostics for this adapter */
  9   102       3 fw_id_ign1 bit (1),
  9   103       3 fw_id bit (8),				/* this will become the 8th char in path_name???? */
  9   104       3 lvl_1_id_ign1 bit (1),
  9   105       3 no_lev_2 bit (1),				/* true = Do not ask for lvl-2 info. */
  9   106       3 micro_ctl bit (1),				/* true = micro-procesor controled */
  9   107       3 fbus_latch bit (1),				/* true = F-Bus Disable Latch is true */
  9   108       3 lvl_1_id_type fixed bin (5) unsigned unal,	/* unique Lvl-1 type */
  9   109       3 fw_rev char (1),
  9   110       3 prim_ch_num fixed bin (9) unal unsigned,		/* primary channel number (8 to 63) */
  9   111       3 num_of_log_ch fixed bin (9) unal unsigned,	/* number of logical channels */
  9   112       3 num_of_busses fixed bin (9) unal unsigned,	/* number of data busses */
  9   113       3 cont_byte_ign1 bit (1),
  9   114       3 cont_byte_rfu bit (5),
  9   115       3 cont_byte_soc bit (1),			/* true = Stop-On-Condition present */
  9   116       3 cont_byte_mpfp bit (1),			/* true = maint. panel fuction present */
  9   117       3 cont_byte_mc bit (1),				/* true = has been set to Master Console */
  9   118     2 adapter_data (0:15, 0:7),
  9   119       3 lvl_2_state fixed bin (9) unal unsigned,
  9   120       3 lvl_2_clt_att fixed bin (9) unal unsigned,
  9   121       3 disk_tab fixed bin (9) unal unsigned,
  9   122       3 fw_idfixed bin (9) unal unsigned,
  9   123       3 lvl_2_id fixed bin (9) unal unsigned,
  9   124       3 fw_rev_ign1 bit (1),
  9   125       3 fw_rev bit (8),
  9   126       3 rfu bit (1),
  9   127  2 uses_less_data char (200);
  9   128 	
  9   129 
  9   130 /* End mca_config_file.incl.pl1 */
     1915 
     1916 
 10     1 /* Begin mca_constants.incl.pl1 */
 10     2 
 10     3 
 10     4 
 10     5 
 10     6 /****^  HISTORY COMMENTS:
 10     7*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
 10     8*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
 10     9*     Constants used for values returned from MCA.
 10    10*                                                   END HISTORY COMMENTS */
 10    11 
 10    12 dcl  NO_CONFIG_PRESENT fixed bin init (0) static options (constant);
 10    13 dcl  NOT_CONFIGED fixed bin init (1) static options (constant);
 10    14 dcl  PH_NOT_PRESENT fixed bin init (2) static options (constant);
 10    15 dcl  BASIC_ROM_FAILED fixed bin init (3) static options (constant);
 10    16 dcl  JAM_FAILED fixed bin init (4) static options (constant);
 10    17 dcl  SELF_FAILED fixed bin init (5) static options (constant);
 10    18 dcl  HW_ID_NO_MATCH fixed bin init (6) static options (constant);
 10    19 dcl  CON_SET_UP_FAILED fixed bin init (7) static options (constant);
 10    20 dcl  RSO_FAILED fixed bin init (8) static options (constant);
 10    21 dcl  FW_NOT_FOUND fixed bin init (9) static options (constant);
 10    22 dcl  FW_LOAD_FAILED fixed bin init (10) static options (constant);
 10    23 dcl  ALTER_NOT_FOUND fixed bin init (11) static options (constant);
 10    24 dcl  ALTER_LOAD_FAILED fixed bin init (12) static options (constant);
 10    25 dcl  FW_EXEC_FAILED fixed bin init (13) static options (constant);
 10    26 dcl  OPERATIONAL fixed bin init (14) static options (constant);
 10    27 dcl  STOP_ON_COND fixed bin init (15) static options (constant);
 10    28 
 10    29 dcl  PSIA_2_TRIP fixed bin init (1) static options (constant);
 10    30 dcl  IPC_PDSI fixed bin init (2) static options (constant);
 10    31 dcl  IPC_CONS_2 fixed bin init (3) static options (constant);
 10    32 dcl  IPC_DAI fixed bin init (4) static options (constant);
 10    33 dcl  IPC_IDI fixed bin init (5) static options (constant);
 10    34 dcl  IPC_TAPE_FIPS fixed bin init (6) static options (constant);
 10    35 dcl  IPC_DISK_FIPS fixed bin init (7) static options (constant);
 10    36 dcl  NDIC fixed bin init (9) static options (constant);
 10    37 dcl  PSIA_4_TRIP fixed bin init (15) static options (constant);
 10    38  
 10    39 dcl TYPE (0:15) char (9) init ("N/A","psia_2","ur-pdsi","cons_2","ur-dai",
 10    40 			"idi","fips","fips","N/A","ndic",
 10    41 			"N/A","N/A","N/A","N/A","N/A","psia_4");
 10    42 	
 10    43 
 10    44 /* End mca_constants.incl.pl1 */
     1918 
 11     1 /* Begin mca_data_area.incl.pl1 */
 11     2 
 11     3 /****^  HISTORY COMMENTS:
 11     4*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
 11     5*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
 11     6*     Created for control of the MCA. This is a template for the ioi workspace
 11     7*     needed for the MCA communications.
 11     8*                                                   END HISTORY COMMENTS */
 11     9 
 11    10 /* Created Sept 84 by R. A. Fawcett from information in
 11    11*   "EPS-1 DIPPER Maintainability" REV A (MAY 3, 1983) */
 11    12 
 11    13 
 11    14 
 11    15 dcl  data_header_ptr ptr;
 11    16 
 11    17 dcl  (data_size_1, data_size_2) fixed bin (21) init (0);
 11    18 
 11    19 dcl  io_param_blk_ptr ptr;
 11    20 
 11    21 dcl  mca_dcw_list_ptr ptr;
 11    22 
 11    23 dcl  mca_work_space_ptr ptr;
 11    24 
 11    25 dcl  1 mca_work_space based (mca_work_space_ptr),
 11    26        2 list_of_dcw like mca_dcw_list,
 11    27        2 status_area like istat,
 11    28 
 11    29        2 data_header_1 aligned like data_header,
 11    30        2 data_1 char (data_size_1),
 11    31        2 data_header_2 aligned like data_header,
 11    32        2 data_2 char (data_size_2);
 11    33 
 11    34 
 11    35 dcl  1 data_header based (data_header_ptr) aligned,
 11    36        2 type bit (9) unal,				/* must be equal to "000"b3 (MBZ) */
 11    37        2 definer fixed bin (9) unal unsigned,		/* defines type of info in header */
 11    38        2 ctl_sw bit (18) unal,			/* "currently undfined" mbz  = "000000"b3 */
 11    39 
 11    40        2 host_sts_ign1 bit (1) unal,
 11    41        2 host_sts_msb bit (8) unal,
 11    42        2 host_sts_ign2 bit (1) unal,
 11    43        2 host_sts_lsb bit (8) unal,
 11    44 
 11    45        2 rd_flpy fixed bin (9) unal unsigned,		/* 0 = data files from host */
 11    46 						/* 1 = data files from flopy */
 11    47        2 io_param_blk like io_parameter_block unal;
 11    48 
 11    49 
 11    50 dcl  1 io_parameter_block based (io_param_blk_ptr) unal,
 11    51        2 open fixed bin (9) unal unsigned,
 11    52        2 cmd bit (18),
 11    53        2 sts_ptr bit (18),				/* Unused */
 11    54        2 file_name char (8),				/* file name for this request */
 11    55        2 options bit (18),				/* Unused */
 11    56        2 source_ptr bit (18),				/* Unused */
 11    57        2 source_len,
 11    58 						/* data_size = source_len_msb||source_len_lsb MCA to HOST */
 11    59          3 source_len_ign1 bit (1),
 11    60          3 source_len_msb bit (8),
 11    61          3 source_len_ign2 bit (1),
 11    62          3 source_len_lsb bit (8),
 11    63        2 dest_ptr bit (18),				/* Unused */
 11    64        2 blk_ct,
 11    65 						/* if MCA to HOST blk_ct_msb||blk_ct_lsb = MAX number of 256 byte BLOCKS  */
 11    66 						/* else not used */
 11    67          3 blk_ct_ign1 bit (1),
 11    68          3 blk_ct_msb bit (8),
 11    69          3 blk_ct_ign2 bit (1),
 11    70          3 blk_ct_lsb bit (8),
 11    71        2 dest_len,
 11    72 						/* supplied by host as the number of bytes in data_field max value is 16128 */
 11    73 						/* dest_len_msb = substr(unspec(data_size),21,8) */
 11    74 						/* dest_len_lsb = substr(unspec(data_size),29,8) */
 11    75          3 dest_len_ign1 bit (1),
 11    76          3 dest_len_msb bit (8),
 11    77          3 dest_len_ign2 bit (1),
 11    78          3 dest_len_lsb bit (8);
 11    79 
 11    80 
 11    81 dcl  1 mca_dcw_list based (mca_dcw_list_ptr),
 11    82        2 idcw1 like idcw,
 11    83        2 dcw1 like dcw,
 11    84        2 idcw2 like idcw,
 11    85        2 dcw2 like dcw;
 11    86 
 11    87 
 12     1 
 12     2 /* Begin include file ...... iom_dcw.incl.pl1 */
 12     3 
 12     4 dcl  dcwp ptr,					/* pointer to DCW */
 12     5      tdcwp ptr;					/* pointer to TDCW */
 12     6 
 12     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
 12     8      (2 address bit (18),				/* address for data transfer */
 12     9       2 char_pos bit (3),				/* character position */
 12    10       2 m64 bit (1),				/* non-zero for mod 64 address */
 12    11       2 type bit (2),				/* DCW type */
 12    12       2 tally bit (12)) unal;				/* tally for data transfer */
 12    13 
 12    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
 12    15      (2 address bit (18),				/* address to transfer to */
 12    16       2 mbz1 bit (4),
 12    17       2 type bit (2),				/* should be "10"b for TDCW */
 12    18       2 mbz2 bit (9),
 12    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
 12    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
 12    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
 12    22 
 12    23 /* End of include file ...... iom_dcw.incl.pl1 */
 12    24 
 11    88 




 11    89 
 13     1 
 13     2 /* Begin include file ...... iom_pcw.incl.pl1 */
 13     3 
 13     4 dcl  pcwp ptr;					/* pointer to PCW */
 13     5 
 13     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
 13     7      (2 command bit (6),				/* device command */
 13     8       2 device bit (6),				/* device code */
 13     9       2 ext bit (6),				/* address extension */
 13    10       2 code bit (3),				/* should be "111"b for PCW */
 13    11       2 mask bit (1),				/* channel mask bit */
 13    12       2 control bit (2),				/* terminate/proceed and marker control bits */
 13    13       2 chan_cmd bit (6),				/* type of I/O operation */
 13    14       2 count bit (6),				/* record count or control character */
 13    15       2 mbz1 bit (3),
 13    16       2 channel bit (6),				/* channel number */
 13    17       2 mbz2 bit (27)) unal;
 13    18 
 13    19 dcl  idcwp ptr;					/* pointer to IDCW */
 13    20 
 13    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
 13    22      (2 command bit (6),				/* device command */
 13    23       2 device bit (6),				/* device code */
 13    24       2 ext bit (6),				/* address extension */
 13    25       2 code bit (3),				/* should be "111"b for PCW */
 13    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
 13    27       2 control bit (2),				/* terminate/proceed and marker control bits */
 13    28       2 chan_cmd bit (6),				/* type of I/O operation */
 13    29       2 count bit (6)) unal;				/* record count or control character */
 13    30 
 13    31 /* End include file ...... iom_pcw.incl.pl1 */
 13    32 
 11    90 




 11    91 
 14     1 
 14     2 /* Begin include file ...... ioi_stat.incl.pl1 */
 14     3 /* Last modified 3/24/75 by Noel I. Morris */
 14     4 
 14     5 dcl  isp ptr;					/* pointer to status structure */
 14     6 
 14     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
 14     8     2 completion,					/* completion flags */
 14     9      (3 st bit (1),					/* "1"b if status returned */
 14    10       3 er bit (1),					/* "1"b if status indicates error condition */
 14    11       3 run bit (1),				/* "1"b if channel still running */
 14    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
 14    13     2 level fixed bin (3),				/* IOM interrupt level */
 14    14     2 offset fixed bin (18),				/* DCW list offset */
 14    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
 14    16     2 iom_stat bit (72),				/* IOM status */
 14    17     2 lpw bit (72);					/* LPW residue */
 14    18 
 14    19 dcl  imp ptr;					/* pointer to message structure */
 14    20 
 14    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
 14    22    (2 completion like istat.completion,			/* completion flags */
 14    23     2 pad bit (11),
 14    24     2 level bit (3),				/* interrupt level */
 14    25     2 offset bit (18),				/* DCW list offset */
 14    26     2 status bit (36)) unal;				/* first 36 bits of status */
 14    27 
 14    28 /* End of include file ...... ioi_stat.incl.pl1 */
 14    29 
 11    92 




 11    93 
 11    94 /* Constants used for data_header.definer */
 11    95 
 11    96 dcl  DATA_FROM_HOST
 11    97 	fixed bin (9) unsigned init (0) static options (constant);
 11    98 dcl  WRITE_CONSOLE
 11    99 	fixed bin (9) unsigned init (1) static options (constant);
 11   100 dcl  WRITE_READ_CONSOLE
 11   101 	fixed bin (9) unsigned init (2) static options (constant);
 11   102 dcl  DATA_FROM_MCA
 11   103 	fixed bin (9) unsigned init (3) static options (constant);
 11   104 dcl  REQ_DATA_FROM_HOST
 11   105 	fixed bin (9) unsigned init (4) static options (constant);
 11   106 dcl  STATUS_FROM_MCA
 11   107 	fixed bin (9) unsigned init (5) static options (constant);
 11   108 dcl  SEEK
 11   109 	fixed bin (9) unsigned init (6) static options (constant);
 11   110 dcl  CON_DATA_FROM_HOST
 11   111 	fixed bin (9) unsigned init (7) static options (constant);
 11   112 dcl  BIN_DATA_FROM_HOST
 11   113 	fixed bin (9) unsigned init (8) static options (constant);
 11   114 dcl  ABORT_SES_FROM_HOST
 11   115 	fixed bin (9) unsigned init (9) static options (constant);
 11   116 
 11   117 
 11   118 /* End mca_data_area.incl.pl1 */
 11   119 
     1919 
     1920 
 15     1 /* Begin  mca_diskette.incl.pl1 */
 15     2 
 15     3 
 15     4 
 15     5 /****^  HISTORY COMMENTS:
 15     6*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
 15     7*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
 15     8*     Created for users to view the contents of the MCA diskettes
 15     9*                                                   END HISTORY COMMENTS */
 15    10 
 15    11 dcl header_ptr ptr;
 15    12 
 15    13 
 15    14 dcl 1 header based (header_ptr),
 15    15     2 copyright char (55),
 15    16     2 title char (8),
 15    17     2 unique_id char (8),
 15    18     2 date_created char (6),
 15    19     2 date_changed char (6),
 15    20     2 space_adr bit (18) unal,
 15    21     2 space_x bit (18) unal,
 15    22     2 space_size bit (18) unal,
 15    23     2 dir_adr bit (18) unal,
 15    24     2 dir_x bit (18) unal,
 15    25     2 dir_size like two_byte,
 15    26     2 config_name char (8),
 15    27     2 config_count fixed bin (9) unal unsigned,
 15    28     2 disk_type fixed bin (9) unal unsigned,
 15    29     2 val fixed bin (9) unal unsigned,
 15    30     2 equip_type char (4),
 15    31     2 ipi_num char (12),
 15    32     2 disk_dwg_num char (12),
 15    33     2 prod_num_tab char (3),
 15    34     2 x_of_n bit (18) unal;
 15    35 
 15    36 dcl dir_ptr ptr;
 15    37 dcl dire_ptr ptr;
 15    38 dcl dir_number fixed bin;
 15    39     
 15    40 dcl 1 directory based (dir_ptr),
 15    41     2 array (dir_number) like dire;
 15    42 
 15    43 dcl two_byte_ptr ptr;
 15    44 
 15    45 dcl 1 two_byte based (two_byte_ptr) unal,
 15    46       2 pad1 bit (1) unal,
 15    47       2 lsb bit (8) unal,
 15    48       2 pad2 bit (1) unal,
 15    49       2 msb bit (8) unal;
 15    50 	
 15    51 
 15    52     
 15    53 dcl 1 dire based (dire_ptr),
 15    54     2 path_name char (8),
 15    55     2 sector_address like two_byte,
 15    56     2 file_size like two_byte,
 15    57     2 rfu like two_byte,
 15    58     2 attributes bit (8) unal,
 15    59     2 deleted bit (1) unal,
 15    60     2 rfu1 char (1);
 15    61 
 15    62 dcl file_ptr ptr;
 15    63 dcl file_size fixed bin (21);
 15    64 dcl 1 hex_file based (file_ptr),
 15    65     2 hex_data (file_size) like two_byte;
 15    66     
 15    67 
 15    68 	
 15    69       
 15    70 
 15    71    
 15    72 
 15    73 /* End  mca_diskette.incl.pl1 */
     1922 
 16     1 
 16     2 /* BEGIN INCLUDE FILE opr_query_info.incl.pl1 */
 16     3 
 16     4 /* created 10/20/78 by J. A. Bush. 
 16     5*   Modified by Rick Fakoury to increase size of the allowable answer.
 16     6**/
 16     7 
 16     8 dcl 1 opr_query_info aligned,				/* info structure for the opr_query_ subroutine */
 16     9     2 version fixed bin,				/* version of this structure, currently = to 1 */
 16    10     2 q_sw bit (1) aligned,				/* = "1"b if aswer is expected from operator */
 16    11     2 prim char (8),				/* primary expected operators response */
 16    12     2 alt char (8),					/* alternate expected operator response */
 16    13     2 answer char (80) varying,				/* operators answer */
 16    14     2 r_comment char (64),				/* comment to be output with respond message */
 16    15     2 err_code fixed bin (35);			/* standard system status code */
 16    16 
 16    17 /* END INCLUDE FILE opr_query_info.incl.pl1 */
 16    18 
     1923 
     1924 
 17     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
 17     2 
 17     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
 17     4 
 17     5 /* This include file contains branch and link structures returned by
 17     6*   hcs_$status_ and hcs_$status_long. */
 17     7 
 17     8 dcl 1 status_branch aligned based (status_ptr),
 17     9     2 short aligned,
 17    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
 17    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
 17    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
 17    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
 17    14       3 dtu bit (36) unaligned,			/* date/time last used */
 17    15       3 mode bit (5) unaligned,			/* caller's effective access */
 17    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
 17    17       3 pad1 bit (8) unaligned,
 17    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
 17    19 
 17    20 /* Limit of information returned by hcs_$status_ */
 17    21 
 17    22     2 long aligned,
 17    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
 17    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
 17    25       3 lvid bit (36) unaligned,			/* logical volume ID */
 17    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
 17    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
 17    28       3 pad2 bit (8) unaligned,
 17    29       3 copy_switch bit (1) unaligned,			/* copy switch */
 17    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
 17    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
 17    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
 17    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
 17    34       3 pad3 bit (5) unaligned,
 17    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
 17    36       3 uid bit (36) unaligned;			/* unique ID */
 17    37 
 17    38 dcl 1 status_link aligned based (status_ptr),
 17    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
 17    40     2 nnames fixed bin (16) unaligned unsigned,
 17    41     2 names_relp bit (18) unaligned,
 17    42     2 dtem bit (36) unaligned,
 17    43     2 dtd bit (36) unaligned,
 17    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
 17    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
 17    46 
 17    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
 17    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
 17    49 						/* array of names returned */
 17    50      status_pathname character (status_link.pathname_length) aligned
 17    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
 17    52 						/* link target path */
 17    53      status_area_ptr pointer,
 17    54      status_ptr pointer;
 17    55 
 17    56 dcl (Link initial (0),
 17    57      Segment initial (1),
 17    58      Directory initial (2)) fixed bin internal static options (constant);
 17    59 						/* values for type fields declared above */
 17    60 
 17    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
     1925 
     1926 
 18     1 /* Include file for vfile_ control orders dealing with key ranges in indexed files */
 18     2 /* created by M. Asherman 4/7/77
 18     3*Modified:
 18     4*12/18/80  by  Lindsey Spratt: Add the delete_old_subsets bit.
 18     5**/
 18     6 
 18     7 /* format: style2 */
 18     8      dcl	   1 common_sl_info	      based (info_ptr),	/* info structure for select and exclude orders */
 18     9 	     2 flags	      aligned,		/* Input */
 18    10 	       3 list_type	      fixed (3) unal,	/* code identifies format of tail structure */
 18    11 	       3 status_only      bit (1) unal,		/* if set, subset info is returned, but current subset stays the same */
 18    12 	       3 output_descriptors
 18    13 			      bit (1) unal,		/* if set, resulting descriptor list is returned */
 18    14 	       3 delete_old_subsets
 18    15 			      bit (1) unal,		/* if set, causes all of the existing subsets on this switch to be deleted. */
 18    16 	       3 mbz	      bit (11) unal,	/* must be zero--in case of extensions */
 18    17 	       3 version	      fixed (17) unal,	/* current info version */
 18    18 	     2 array_limit	      fixed,		/* upper bound of array in tail of info structure */
 18    19 	     2 subset_no	      fixed,		/* identifies temporary subset-- Output */
 18    20 	     2 count	      fixed (34),		/* Output--number of distinct descrips */
 18    21 	     2 desc_arrayp	      ptr;		/* pointer to resulting array of descriptors */
 18    22 
 18    23 /* descriptor array generated if requested */
 18    24      dcl	   desc_array	      (1:common_sl_info.count) based (common_sl_info.desc_arrayp);
 18    25 
 18    26 /* this format allows specification in terms of index intervals defined by two heads or one key */
 18    27      dcl	   1 hi_sl_info	      based (info_ptr),	/* structure for list_type = 1 */
 18    28 	     2 common	      like common_sl_info,
 18    29 	     2 interval	      (1:sl_array_limit refer (hi_sl_info.array_limit)),
 18    30 	       3 first_head,
 18    31 	         4 length	      fixed,
 18    32 	         4 kptr	      ptr unal,
 18    33 	       3 last_head,
 18    34 	         4 length	      fixed,		/* if negative, this interval is defined by match with key */
 18    35 	         4 kptr	      ptr unal;
 18    36 
 18    37 /* format for specification in terms of an array of descriptors */
 18    38      dcl	   1 da_sl_info	      based (info_ptr),	/* list_type=2 */
 18    39 	     2 common	      like common_sl_info,
 18    40 	     2 desc_array	      (1:sl_array_limit refer (da_sl_info.array_limit)) fixed (35);
 18    41 
 18    42      dcl	   sl_array_limit	      fixed;
 18    43      dcl	   sl_info_version_0      static options (constant) internal fixed init (0);
 18    44 
 18    45 /* list_type=0 denotes reselection of a single, previously defined subset (no tail structure) */
     1927 
     1928 
     1929 
     1930 
     1931 
     1932    end dfm_util_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/21/92  1020.2  dfm_util_.pl1                     >spec>install>1031>dfm_util_.pl1
1901         1    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1903         2    07/19/79  1647.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
1905         3    10/25/90  1013.9  dfm_data.incl.pl1                 >ldd>include>dfm_data.incl.pl1
3-209        4    07/19/79  1647.0  rs_info.incl.pl1                  >ldd>include>rs_info.incl.pl1
1907         5    03/27/82  0537.1  gcos_ssf_records.incl.pl1         >ldd>include>gcos_ssf_records.incl.pl1
1909         6    05/23/79  1712.1  gload_data.incl.pl1               >ldd>include>gload_data.incl.pl1
1911         7    02/02/78  1329.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1913         8    09/18/86  1417.5  mca_area.incl.pl1                 >ldd>include>mca_area.incl.pl1
1915         9    09/18/86  1417.5  mca_config_file.incl.pl1          >ldd>include>mca_config_file.incl.pl1
1917        10    09/18/86  1417.5  mca_constants.incl.pl1            >ldd>include>mca_constants.incl.pl1
1919        11    09/18/86  1417.5  mca_data_area.incl.pl1            >ldd>include>mca_data_area.incl.pl1
11-88       12    11/12/74  1650.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
11-90       13    05/06/74  1842.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
11-92       14    08/17/79  2315.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
1921        15    09/18/86  1417.5  mca_diskette.incl.pl1             >ldd>include>mca_diskette.incl.pl1
1923        16    06/09/83  1530.8  opr_query_info.incl.pl1           >ldd>include>opr_query_info.incl.pl1
1925        17    11/22/82  1055.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
1927        18    07/31/81  1918.2  select_info.incl.pl1              >ldd>include>select_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Directory                              constant        fixed bin(17,0)          initial dcl 17-56 ref 701
Link                                   constant        fixed bin(17,0)          initial dcl 17-56 ref 714
NL                                     constant        char(1)                  initial packed unaligned dcl 190 ref 1184 1184 1210
                                                                                  1210
P_dfm_datap                            parameter       pointer                  dcl 323 ref 331 334 385 388 402 405 445 449 462 465
                                                                                  665 670 785 791 844 850 871 878 907 909 969 974
                                                                                  989 992 1008 1011 1077 1082 1132 1135 1149 1152
                                                                                  1234 1240 1376 1387 1416 1422 1525 1531
RW_ACCESS_BIN                   000624 constant        fixed bin(5,0)           initial dcl 1-36 set ref 702* 737* 751* 762*
SMA_ACCESS_BIN                  000173 constant        fixed bin(5,0)           initial dcl 1-36 set ref 683* 702* 723*
Segment                                constant        fixed bin(17,0)          initial dcl 17-56 ref 749
TYPE                            001343 automatic       char(9)                  initial array packed unaligned dcl 10-39 set ref
                                                                                  10-39* 10-39* 10-39* 10-39* 10-39* 10-39* 10-39*
                                                                                  10-39* 10-39* 10-39* 10-39* 10-39* 10-39* 10-39*
                                                                                  10-39* 10-39*
abort                                  parameter       bit(1)                   packed unaligned dcl 1237 set ref 467* 1234 1243*
add_char_offset_                007652 constant        entry                    external dcl 279 ref 1403
addr                                                   builtin function         dcl 118 ref 336 338 347 353 359 360 479 479 500 506
                                                                                  511 567 575 576 583 592 606 613 613 620 795 803
                                                                                  816 861 910 940 940 940 942 943 945 1047 1047 1048
                                                                                  1097 1097 1109 1109 1214 1214 1270 1270 1307 1312
                                                                                  1316 1396 1397 1423 1442 1442 1444 1445 1465 1465
                                                                                  1487 1493 1493 1493 1568 1571 1600 1600 1609 1609
                                                                                  1612 1612 1651 1673 1731 1731 1877 1877
addrel                                                 builtin function         dcl 119 ref 525 526 537 538 542 554 555 570 586 595
                                                                                  649 652 653 1363 1366 1636 1657 1658 1894
after                                                  builtin function         dcl 120 ref 1053 1056
ak_header                              based           structure                level 1 unaligned dcl 2-10
allow_0_cksum                          based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 1609
alt                       4     001411 automatic       char(8)                  level 2 dcl 16-8 set ref 1085*
answer                    6     001411 automatic       varying char(80)         level 2 dcl 16-8 set ref 1111 1116
array_limit               1            based           fixed bin(17,0)          level 2 dcl 18-8 set ref 800* 831*
ascii_card                1            based           char(80)                 level 2 dcl 3-23 set ref 530* 1343* 1567* 1568 1583
ascii_cardp                     000454 automatic       pointer                  dcl 3-160 set ref 1568* 1571 1571 1571 1571 1577
                                                                                  1577
assem                    16(27)        based           char(1)                  level 2 packed packed unaligned dcl 238 ref 1571
at_bot                          000100 automatic       bit(1)                   packed unaligned dcl 45 set ref 1242* 1260 1317
                                                                                  1361*
att_desc                               parameter       char(181)                packed unaligned dcl 46 set ref 1132 1137*
attach_copy              25            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 1515
bcard                           000101 automatic       bit(540)                 packed unaligned dcl 47 set ref 562* 563* 566* 566
                                                                                  567 578* 579* 582* 582 583 590* 591* 591 592
bcd_card                               parameter       bit                      packed unaligned dcl 1564 set ref 1562 1567*
bcd_dkend                       000420 constant        bit(72)                  initial packed unaligned dcl 145 ref 548 1341
bcd_media_code                         constant        fixed bin(4,0)           initial dcl 147 ref 1311 1658
bcd_obj                         000415 constant        bit(78)                  initial packed unaligned dcl 148 ref 508 1313
bcd_to_ascii_                   007654 constant        entry                    external dcl 280 ref 509 549 1314 1567 1674
bcnt                            000120 automatic       fixed bin(18,0)          dcl 48 set ref 490* 494* 494 495 495* 1296* 1300*
                                                                                  1300 1301 1301* 1658
bcw                                    based           structure                level 2 in structure "gpr" packed packed unaligned
                                                                                  dcl 230 in procedure "dfm_util_"
bcw                                    based           structure                level 1 dcl 210 in procedure "dfm_util_"
bcw                                    based           structure                level 2 in structure "gc_phy_rec" packed packed
                                                                                  unaligned dcl 5-9 in procedure "dfm_util_"
bcwp                            000122 automatic       pointer                  dcl 49 set ref 484* 653 654*
before                                                 builtin function         dcl 121 ref 1053 1053 1056 1056 1184 1184 1210 1210
                                                                                  1210 1210
bf_sw                    25(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 775
bin                                                    builtin function         dcl 122 ref 1867
binary_media_code                      constant        fixed bin(4,0)           initial dcl 150 ref 1349 1658
bit_buf                                based           bit                      packed unaligned dcl 214 ref 1289 1289
bit_count                       000124 automatic       fixed bin(24,0)          dcl 50 set ref 678*
blk_size                  0(18)        based           fixed bin(18,0)          level 3 in structure "gpr" packed packed unsigned
                                                                                  unaligned dcl 230 in procedure "dfm_util_" ref 503
                                                                                  1310 1869
blk_size                  0(18)        based           fixed bin(18,0)          level 2 in structure "cur_bcw" packed packed
                                                                                  unsigned unaligned dcl 216 in procedure
                                                                                  "dfm_util_" set ref 599* 603*
blk_size                  0(18)        based           fixed bin(18,0)          level 2 in structure "new_bcw" packed packed
                                                                                  unsigned unaligned dcl 236 in procedure
                                                                                  "dfm_util_" set ref 597* 598 600* 600 603
blk_size                  0(18)        based           fixed bin(18,0)          level 3 in structure "gc_phy_rec" packed packed
                                                                                  unsigned unaligned dcl 5-9 in procedure
                                                                                  "dfm_util_" ref 652 1366 1894
blk_size                  0(18)        based           fixed bin(18,0)          level 2 in structure "bcw" packed packed unsigned
                                                                                  unaligned dcl 210 in procedure "dfm_util_" ref 653
bof                             000546 constant        fixed bin(17,0)          initial dcl 151 set ref 809* 1156*
bptr                     26            based           pointer                  level 2 dcl 3-23 set ref 353* 485 524 526* 526 536
                                                                                  538* 538 553 555* 555 569 570* 570 585 586* 586
                                                                                  594 595* 595 596 597 604 604 604 606 606 1043*
                                                                                  1046* 1250 1865
bsn                                    based           fixed bin(18,0)          level 2 in structure "cur_bcw" packed packed
                                                                                  unsigned unaligned dcl 216 in procedure
                                                                                  "dfm_util_" ref 601
bsn                                    based           fixed bin(18,0)          level 2 in structure "new_bcw" packed packed
                                                                                  unsigned unaligned dcl 236 in procedure
                                                                                  "dfm_util_" set ref 601*
bsn                                    based           fixed bin(18,0)          level 3 in structure "gpr" packed packed unsigned
                                                                                  unaligned dcl 230 in procedure "dfm_util_" set ref
                                                                                  490 495 495* 1296 1301 1301* 1658
buf_len                                parameter       fixed bin(21,0)          dcl 875 set ref 871 885* 895*
buf_size                        000414 constant        fixed bin(21,0)          initial dcl 152 set ref 1255*
bufp                                   parameter       pointer                  dcl 874 set ref 871 885* 895*
c_name                                 parameter       varying char(24)         dcl 789 ref 785 794
c_ptr                                  parameter       pointer                  dcl 788 ref 785 815 827
c_rtrycnt                       000125 automatic       fixed bin(17,0)          dcl 51 set ref 1868* 1874* 1874 1876
call_name                17            based           char(6)                  level 2 packed packed unaligned dcl 238 set ref 951
                                                                                  953 1493* 1719 1724
cat_build                32            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  357*
cat_key                  32(09)        based           char(24)                 level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  359* 373* 373 1329*
cata                                   based           structure                level 1 dcl 3-130
cata_key_string                        based           char                     packed unaligned dcl 3-152 ref 957
cata_list_type                         constant        fixed bin(2,0)           initial dcl 3-109 ref 1493 1515
cata_name                              parameter       varying char(24)         dcl 847 set ref 844 852*
catalog                                based           structure                level 1 dcl 220
catp                     30            based           pointer                  level 2 dcl 3-23 ref 358 957 958 958 959 959
cbcwp                           000126 automatic       pointer                  dcl 52 set ref 485* 597 599 601 603 653* 653
cd_sw                    40(09)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 1856
                                                                                  1857
cden                            000130 automatic       char(5)                  packed unaligned dcl 53 set ref 1857* 1859*
cfile                    41            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 495* 635* 645* 1246 1246
                                                                                  1272* 1279* 1284* 1284 1301* 1343* 1349* 1357*
                                                                                  1841* 1841
char                                                   builtin function         dcl 123 ref 915 1730 1774 1813
ciocb_ptr                42            based           pointer                  level 2 dcl 3-23 set ref 390* 1859* 1869* 1877*
                                                                                  1884* 1885*
cksp                     44            based           pointer                  level 2 dcl 3-23 ref 957
code                            000132 automatic       fixed bin(35,0)          dcl 54 set ref 390* 409* 410 411 415* 416 417 425*
                                                                                  426 426* 428* 429 429* 451* 452* 472* 473 479* 480
                                                                                  613* 614* 615 615* 617* 618 618* 678* 679 680 680*
                                                                                  715* 718 719 719* 804* 805 806 809* 811 812 822*
                                                                                  823 824 833* 852* 853 854 857* 860* 862 882* 883
                                                                                  884 885* 886 886* 891 891* 895* 896 896* 977* 978
                                                                                  978* 995* 996 996* 1020* 1021 1023* 1024 1024*
                                                                                  1027* 1029 1029* 1031* 1032 1032* 1040* 1041 1041*
                                                                                  1043* 1044 1044* 1047* 1091* 1093 1137* 1138 1138*
                                                                                  1140* 1141 1141* 1156* 1157* 1159* 1160 1160*
                                                                                  1171* 1172 1172* 1175* 1176 1176* 1192* 1193 1193*
                                                                                  1214* 1215 1215* 1255* 1257 1258 1258 1264* 1265*
                                                                                  1272* 1276* 1279* 1390* 1392* 1394 1398 1406*
                                                                                  1465* 1547* 1548 1548* 1602* 1604* 1605* 1609*
                                                                                  1612* 1613 1613* 1617* 1618 1618* 1688* 1690 1690*
                                                                                  1816* 1817 1817* 1820* 1821 1821* 1838* 1839 1839*
                                                                                  1859* 1860 1860* 1869* 1871 1871 1878* 1891*
command_query_$yes_no           007656 constant        entry                    external dcl 281 ref 530 684 706 724 739 754
common_sl_info                         based           structure                level 1 unaligned dcl 18-8
comp_num                               based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-32 set ref
                                                                                  620* 1048* 1487* 1493*
completion                             based           structure                level 2 in structure "istat" dcl 14-7 in procedure
                                                                                  "dfm_util_"
completion                4            based           structure                level 3 in structure "mca_work_space" packed packed
                                                                                  unaligned dcl 11-25 in procedure "dfm_util_"
convert                                                builtin function         dcl 124 ref 1116
copy_at_eof              46            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  391* 1896*
count                     3            based           fixed bin(34,0)          level 2 in structure "common_sl_info" dcl 18-8
                                                                                  in procedure "dfm_util_" ref 815 820
count                     0(12)        based           fixed bin(5,0)           level 2 in structure "r_card" packed packed
                                                                                  unaligned dcl 261 in procedure "dfm_util_" ref
                                                                                  1638 1643 1646 1647 1651 1653
cptr                     50            based           pointer                  level 2 dcl 3-23 set ref 1636* 1638 1643 1644 1646
                                                                                  1647 1647 1651* 1651 1651 1653
crec                     52            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 495* 635* 645* 651* 651
                                                                                  1272* 1279* 1285* 1301* 1343* 1349* 1357* 1365*
                                                                                  1365 1842*
cur_bcw                                based           structure                level 1 dcl 216
current_disk_name        53            based           char(8)                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1435 1702*
current_filename         55            based           varying char(20)         level 2 dcl 3-23 set ref 920 921 922 930 1482 1482*
                                                                                  1482 1484 1484* 1484 1486* 1486 1487*
current_key              63            based           varying char(24)         level 2 dcl 3-23 set ref 911* 915* 921* 922 925 930*
                                                                                  931 933 940* 942* 943* 943 944* 944 945* 945 949*
                                                                                  951* 953* 957 959 1487* 1493* 1501
current_ptr                     000444 automatic       pointer                  dcl 1380 set ref 1391* 1392* 1399* 1403* 1403* 1406*
current_ring                    000546 constant        fixed bin(17,0)          initial dcl 153 set ref 1547*
currentsize                                            builtin function         dcl 125 ref 649 652 1363 1366 1657 1894
cvp                             000134 automatic       pointer                  dcl 56 set ref 470* 517 642 643* 1251* 1337 1354
                                                                                  1355* 1673* 1674
cvp1                            000136 automatic       pointer                  dcl 57 set ref 470* 517 517* 642* 1251* 1337 1337*
                                                                                  1354* 1633
cx                              000133 automatic       fixed bin(17,0)          dcl 55 set ref 1758* 1759 1761* 1763 1766 1768 1800*
                                                                                  1803 1804 1804 1812 1812 1813
d_name                                 parameter       char                     packed unaligned dcl 668 set ref 665 678* 680* 683*
                                                                                  684* 693 693* 702* 702 702* 715* 715* 719* 723*
                                                                                  724* 737* 739* 751 751* 762* 770 770 775 775
data                                   based           bit(36)                  array level 2 packed packed unaligned dcl 261 ref
                                                                                  1644
data_bufp                              parameter       pointer                  dcl 1380 ref 1376 1391
data_header                            based           structure                level 1 dcl 11-35
data_move                              based           char                     packed unaligned dcl 218 set ref 524* 524 536* 536
                                                                                  553* 553 569* 569 585* 585 594* 594
data_p                                 based           bit(1)                   level 2 packed packed unaligned dcl 3-192 ref 1399
                                                                                  1405
data_size_1                     001407 automatic       fixed bin(21,0)          initial dcl 11-17 set ref 11-17*
data_size_2                     001410 automatic       fixed bin(21,0)          initial dcl 11-17 set ref 11-17*
dcata                                  based           structure                level 1 dcl 3-134
dcata_key_string                       based           char                     packed unaligned dcl 3-154 ref 931
dcatp                    72            based           pointer                  level 2 dcl 3-23 ref 931 932 932 933 933
dcw                                    based           structure                level 1 dcl 12-7
deckfile_sw              74(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 347 880
                                                                                  1154 1687 1729
denno                    75            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 1261* 1261 1262 1265 1856
                                                                                  1857 1857
density                         000405 constant        char(5)                  initial array packed unaligned dcl 154 set ref 1262
                                                                                  1265* 1857
desc_array                             based           fixed bin(17,0)          array dcl 18-24 ref 821
desc_arrayp               4            based           pointer                  level 2 dcl 18-8 set ref 801* 821 832*
descrip                   1            based           fixed bin(35,0)          level 3 dcl 2-41 set ref 821*
descriptor                6     000424 automatic       fixed bin(35,0)          level 2 dcl 269 set ref 620 1048 1487 1493
dfm_$complain                   007660 constant        entry                    external dcl 282 ref 366 426 429 495 563 579 615 618
                                                                                  635 645 680 719 770 775 886 891 896 978 996 1024
                                                                                  1029 1032 1041 1044 1138 1141 1160 1172 1176 1193
                                                                                  1215 1272 1279 1301 1324 1343 1349 1357 1548 1605
                                                                                  1613 1618 1690 1817 1821 1839 1860 1878 1891
dfm_data                               based           structure                level 1 unaligned dcl 3-23
dfm_datap                       000452 automatic       pointer                  dcl 3-21 set ref 334* 336 338 347 347 347 349 353
                                                                                  353 353 356 357 357 358 359 359 360 361 362 363
                                                                                  364 366* 366 370 373 373 373 388* 390 391 405* 409
                                                                                  415 422 423 424 425 425 426* 426 428 428 429* 429
                                                                                  432 432 432 432 432 432 432 436* 436 436 436 437
                                                                                  438 449* 465* 472 479 485 495* 495 495 509 511 523
                                                                                  524 524 524 525 526 526 526 530 535 536 536 536
                                                                                  537 538 538 538 552 553 553 553 554 555 555 555
                                                                                  558 558 560 560 561 562 562 563* 568 569 569 569
                                                                                  570 570 570 572 573 573 574 575 575 576 576 577
                                                                                  578 578 579* 579 584 585 585 585 586 586 586 589
                                                                                  593 594 594 594 595 595 595 596 597 604* 604 604
                                                                                  604 604 606 606 606 610 611 612 613 614 614 614
                                                                                  615* 615 615 617 617 618* 618 618 620 620 620 620
                                                                                  620 620 620 624* 624 624 624 626 627 635* 635 635
                                                                                  645* 645 645 651 651 670* 680* 689 702 719* 729
                                                                                  737 751 770* 775 775* 791* 850* 878* 880 880 886*
                                                                                  886 886 891* 891 891 896* 896 896 909* 910 911 913
                                                                                  914 914 915 915 915 919 920 921 921 922 922 922
                                                                                  922 924 924 925 925 925 930 930 931 931 931 932
                                                                                  932 933 933 933 940 940 940 940 942 942 943 943
                                                                                  943 944 944 945 945 945 949 951 953 957 957 957
                                                                                  958 958 959 959 959 974* 976 977 978* 980 992* 994
                                                                                  995 996* 998 1011* 1015 1016 1019 1020* 1020 1020
                                                                                  1021 1022 1023* 1023 1023 1023 1024* 1024 1026
                                                                                  1027 1027 1029* 1029 1031 1032* 1032 1035 1035
                                                                                  1035 1038 1038 1041* 1043 1044* 1046* 1046 1048
                                                                                  1048 1048 1048 1048 1053 1053 1053 1053 1053 1056
                                                                                  1056 1056 1056 1056 1056 1061* 1061 1061 1064*
                                                                                  1064 1064 1064 1064 1067 1068 1082* 1090 1091*
                                                                                  1097 1116 1116 1117 1117 1135* 1138* 1141* 1152*
                                                                                  1154 1154 1157* 1157 1157 1159* 1159 1159 1160*
                                                                                  1165 1166 1167 1169 1170 1171 1171 1172* 1172 1175
                                                                                  1176* 1179 1180 1182 1182 1184 1184 1184 1184 1188
                                                                                  1188 1191 1191 1191 1191 1192 1192 1192 1192 1193*
                                                                                  1193 1198 1199 1204 1204 1204 1204 1209 1209 1210
                                                                                  1210 1210 1210 1213 1213 1214 1214 1214 1214 1214
                                                                                  1215* 1215 1220 1223 1224 1225 1226 1240* 1246
                                                                                  1246 1246 1246 1250 1255 1261 1261 1262 1264 1265
                                                                                  1265 1270 1272* 1272 1272 1276 1279* 1279 1279
                                                                                  1284 1284 1285 1292 1301* 1301 1301 1314 1316 1320
                                                                                  1322 1324* 1328 1329 1329 1330 1330 1330 1343*
                                                                                  1343 1343 1343 1349* 1349 1349 1357* 1357 1357
                                                                                  1365 1365 1368 1387* 1392 1392 1396 1397 1397 1399
                                                                                  1399 1399 1405 1406 1422* 1423 1426 1427 1427 1429
                                                                                  1430 1431 1433 1434 1435 1435 1440 1441 1442 1442
                                                                                  1442 1444 1444 1445 1445 1446 1450 1451 1452 1453
                                                                                  1454 1455 1456 1458 1459 1460 1461 1463 1465 1465
                                                                                  1468 1468 1469 1469 1470 1472 1472 1473 1473 1474
                                                                                  1477 1478 1479 1481 1482 1482 1482 1484 1484 1484
                                                                                  1486 1486 1487 1487 1487 1487 1487 1493 1493 1493
                                                                                  1493 1493 1493 1493 1493 1493 1493 1501 1501 1503
                                                                                  1503 1503 1503 1505 1505 1506 1506 1506 1510* 1510
                                                                                  1510 1510 1511 1512 1515 1531* 1548* 1567 1568
                                                                                  1571 1583 1600 1600 1602 1604 1605* 1605 1609 1609
                                                                                  1613* 1613 1618* 1618 1636 1638 1643 1644 1646
                                                                                  1647 1647 1651 1651 1651 1653 1674 1687 1687 1687
                                                                                  1688* 1688 1688 1688 1688 1690* 1694 1695 1697
                                                                                  1699 1699 1702 1702 1702 1702 1705 1707 1712 1712
                                                                                  1712 1715 1715 1715 1715 1715 1715 1719 1719 1719
                                                                                  1719 1719 1724 1724 1724 1724 1724 1729 1729 1729
                                                                                  1729 1730 1730 1731* 1731 1731 1731 1731 1731 1733
                                                                                  1733 1734 1734 1735 1735 1739 1740 1741 1752 1753
                                                                                  1754 1758 1758 1761 1761 1762 1762 1763 1764 1764
                                                                                  1766 1768 1769* 1769 1769 1769 1769 1773 1778 1779
                                                                                  1800 1800 1803 1804 1804 1807 1807 1808 1808 1812
                                                                                  1812 1813 1816 1817* 1820 1821* 1838 1839* 1841
                                                                                  1841 1842 1843 1853 1854 1856 1856 1857 1857 1857
                                                                                  1859 1860* 1865 1867 1867 1869 1877 1878* 1880
                                                                                  1884 1885 1891* 1892 1896
diagnostic                3     000456 automatic       char(200)                level 2 packed packed unaligned dcl 6-5 set ref
                                                                                  1613*
dir                                    parameter       char                     packed unaligned dcl 1543 in procedure "accessible"
                                                                                  set ref 1541 1547* 1548*
dir                     106            based           char(168)                level 2 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 886* 891* 896* 1056* 1602* 1604* 1605* 1609*
                                                                                  1613* 1618* 1702* 1715*
dire                                   based           structure                level 1 packed packed unaligned dcl 15-53
disk_num                160            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 1090* 1097* 1116* 1116 1117
                                                                                  1117 1392*
diskette                               parameter       varying char(8)          dcl 1528 ref 1525 1533
diskette_name                          parameter       varying char(8)          dcl 1079 set ref 1077 1094 1106* 1109* 1112*
dk_end                          000140 automatic       bit(1)                   packed unaligned dcl 58 set ref 467* 488 550* 1243*
                                                                                  1253 1341*
dk_type                         000142 automatic       char(6)                  packed unaligned dcl 59 set ref 1445 1446*
dkend_card                      000144 automatic       char(80)                 packed unaligned dcl 60 set ref 549* 589* 590*
dksp                    162            based           pointer                  level 2 dcl 3-23 ref 931
dlen                    164            based           fixed bin(21,0)          level 2 dcl 3-23 set ref 523* 524 524 525 526 535*
                                                                                  536 536 537 538 552* 553 553 554 555 568* 569 569
                                                                                  570 584* 585 585 586 593* 594 594 595 1368* 1867
dtime                   231(27)        based           char(6)                  array level 3 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 573*
dtime                   717(18)        based           char(6)                  array level 3 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 560*
dtype                   165            based           char(4)                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1427* 1431* 1435* 1442* 1444* 1446 1450* 1451*
                                                                                  1452* 1453* 1454* 1493* 1730
e_name                                 parameter       char                     packed unaligned dcl 667 set ref 665 678* 680* 684*
                                                                                  702* 706* 715* 715* 719* 724* 737* 739* 749 751*
                                                                                  754* 762 762* 770 770 775 775
edit_date               166            based           char(6)                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1487*
edit_name                22            based           char(4)                  level 2 packed packed unaligned dcl 238 set ref 561
                                                                                  574 577 915 944 949 1317 1317 1320 1322 1324*
                                                                                  1493* 1571 1600
ename                           000170 automatic       char(32)                 packed unaligned dcl 61 set ref 689 729 794* 802 803
                                                                                  1600* 1602* 1604* 1605* 1609* 1613* 1618*
end_file                               parameter       bit(1)                   packed unaligned dcl 1237 set ref 467* 1234 1243*
                                                                                  1283*
entry                                  parameter       char                     packed unaligned dcl 1544 in procedure "accessible"
                                                                                  set ref 1541 1547* 1548*
entry                   167(27)        based           char(32)                 level 2 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 886* 891* 896* 1056* 1702* 1715*
eot                     167(18)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  349* 1292* 1867 1880* 1892*
error_table_$end_of_info        007766 external static fixed bin(35,0)          dcl 318 ref 1258
error_table_$fatal_error        007756 external static fixed bin(35,0)          dcl 314 set ref 495* 563* 579* 635* 645* 1301* 1324*
                                                                                  1343* 1349* 1357*
error_table_$no_file            007762 external static fixed bin(35,0)          dcl 316 set ref 770*
error_table_$no_record          007764 external static fixed bin(35,0)          dcl 317 ref 854 883
error_table_$noentry            007760 external static fixed bin(35,0)          dcl 315 ref 680 719
error_table_$tape_error         007770 external static fixed bin(35,0)          dcl 319 ref 1258 1871
false                                  constant        bit(1)                   initial packed unaligned dcl 157 ref 343 350 370 421
                                                                                  467 468 609 673 674 675 998 1088 1096 1113 1125
                                                                                  1243 1244 1361 1426 1535 1553 1569 1639 1666 1741
                                                                                  1896
file_found                      000200 automatic       bit(1)                   packed unaligned dcl 62 set ref 673* 688* 711* 728*
                                                                                  742* 746* 759* 762* 770 775
filename                               parameter       char                     packed unaligned dcl 1381 set ref 1376 1392*
fiocb_ptr               200            based           pointer                  level 2 dcl 3-23 set ref 409* 415* 425* 428* 436*
                                                                                  472* 479* 604* 613* 614* 617* 624* 1465* 1510*
                                                                                  1688* 1731* 1769* 1816* 1820*
firmware_sw             202(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 347 353
first_deck              202(02)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref 356
                                                                                  357* 370*
first_head                6            based           structure                array level 3 unaligned dcl 18-27
first_patch                     000201 automatic       bit(1)                   packed unaligned dcl 63 set ref 467* 522 527* 551
first_rcd                       000202 automatic       bit(1)                   packed unaligned dcl 64 set ref 467* 489 491* 1244*
                                                                                  1295 1297*
first_write             202(03)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1853 1854*
fixed                                                  builtin function         dcl 126 ref 523 523 552 552 597 597 604 620 620 1048
                                                                                  1048 1368 1487 1487 1493 1493 1617
flags                                  based           structure                level 3 in structure "gk_info" dcl 2-41 in procedure
                                                                                  "dfm_util_"
flags                                  based           structure                level 2 in structure "common_sl_info" dcl 18-8
                                                                                  in procedure "dfm_util_"
fmt1                            000363 constant        char(53)                 initial packed unaligned dcl 162 ref 1493
fmt2                            000352 constant        char(33)                 initial packed unaligned dcl 164 ref 1493
fmt3                            000332 constant        char(62)                 initial packed unaligned dcl 166 ref 1493
fnp_18x_edit_name               000402 constant        char(4)                  initial packed unaligned dcl 160 ref 1317 1320
fnp_355_edit_name               000404 constant        char(4)                  initial packed unaligned dcl 158 ref 1317 1322
fnp_355_type                    000403 constant        char(4)                  initial packed unaligned dcl 159 ref 1322
fnp_6670_type                   000401 constant        char(4)                  initial packed unaligned dcl 161 ref 1320
fnp_key                 203            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 914* 914 915
fnp_tape                204            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref 913
                                                                                  1328* 1429 1469 1493* 1493* 1712* 1715* 1719 1719
                                                                                  1724 1724
fnp_type                204(09)        based           char(4)                  level 2 packed packed unaligned dcl 3-23 set ref 915
                                                                                  1320* 1322* 1329 1330 1715*
free_area                              based           area(1024)               dcl 224 ref 422 437 611 626 1015 1067 1165 1166 1223
                                                                                  1225 1478 1511 1694 1739 1752 1778
fw_dkp                                 parameter       pointer                  dcl 1598 set ref 1596 1609* 1612*
g_label                         000330 constant        bit(72)                  initial packed unaligned dcl 168 ref 1289
gc_log_rec                             based           structure                level 1 dcl 5-15
gc_log_rec_data           1            based           bit(36)                  array level 2 dcl 226 set ref 506 1312
gc_phy_rec                             based           structure                level 1 dcl 5-9
gc_phy_rec_data           1            based           bit(36)                  array level 2 dcl 230 set ref 500 1307
get_system_free_area_           007662 constant        entry                    external dcl 283 ref 422 437 611 626 1015 1067 1165
                                                                                  1166 1223 1225 1478 1511 1694 1739 1752 1778
gk_header                              based           structure                level 1 unaligned dcl 2-46
gk_info                                based           structure                level 1 unaligned dcl 2-41
gk_info_ptr                     000450 automatic       pointer                  dcl 2-63 set ref 816* 818 819 821 822* 827
gki                             000210 automatic       bit(36)                  array packed unaligned dcl 67 set ref 816 817*
gload_                          007664 constant        entry                    external dcl 284 ref 1612
gload_$allow_zero_checksums     007666 constant        entry                    external dcl 285 ref 1609
gload_data                      000456 automatic       structure                level 1 dcl 6-5 set ref 1609 1609 1612 1612
glr                                    based           structure                level 1 dcl 226 set ref 649 1363 1657
glrb                                   based           bit                      packed unaligned dcl 228 set ref 508 509* 521* 548
                                                                                  549* 1313 1314* 1341 1343*
glrbp                           000206 automatic       pointer                  dcl 66 set ref 506* 508 509 521 548 549 1312* 1313
                                                                                  1314 1341 1343
glrp                            000204 automatic       pointer                  dcl 65 set ref 500* 505 506 508 509 509 521 521 523
                                                                                  535 542 548 549 549 552 635 643 645 648 649* 649
                                                                                  649 1307* 1311 1312 1313 1314 1314 1341 1343 1343
                                                                                  1349 1355 1357 1362 1363* 1363 1363 1632 1633*
                                                                                  1635 1636 1647 1657* 1657 1657 1658 1658 1658
                                                                                  1658* 1658 1675*
gpr                                    based           structure                level 1 dcl 230 set ref 652 1366 1894
gprp                            000234 automatic       pointer                  dcl 68 set ref 484* 490 495 495 500 503 652* 652 652
                                                                                  654 1250* 1255* 1289 1289 1296 1301 1301 1307 1310
                                                                                  1366* 1366 1366 1368 1865* 1867 1869* 1869 1894*
                                                                                  1894 1894
gtime_string            205(09)        based           char(6)                  level 2 packed packed unaligned dcl 3-23 ref 560 573
                                                                                  589
h_patch                                based           structure                level 1 dcl 3-162
hbound                                                 builtin function         dcl 128 ref 1018 1198 1213 1262 1668 1729
hbuff                                  based           char(300)                array packed unaligned dcl 3-138 set ref 1165 1167*
                                                                                  1180* 1188* 1198 1210* 1210 1210 1213 1213 1214
                                                                                  1214 1214 1214 1225 1694 1695* 1699* 1702* 1705*
                                                                                  1707* 1712* 1715* 1719* 1724* 1729 1729 1731 1731
                                                                                  1731 1731 1739
hbuff_len                       000245 automatic       fixed bin(21,0)          dcl 70 set ref 1210* 1699* 1702* 1705* 1707* 1712*
                                                                                  1715* 1719* 1724*
hbuff_p                 210            based           pointer                  level 2 dcl 3-23 set ref 1165* 1167 1180 1188 1198
                                                                                  1210 1210 1210 1213 1213 1214 1214 1214 1214 1225
                                                                                  1226* 1694* 1695 1699 1702 1705 1707 1712 1715
                                                                                  1719 1724 1729 1729 1731 1731 1731 1731 1739 1740*
hcs_$get_link_target            007670 constant        entry                    external dcl 286 ref 715
hcs_$get_user_effmode           007672 constant        entry                    external dcl 287 ref 1547
hcs_$initiate                   007674 constant        entry                    external dcl 288 ref 1602
hcs_$make_seg                   007676 constant        entry                    external dcl 289 ref 1604
hcs_$set_bc_seg                 007700 constant        entry                    external dcl 290 ref 1617
hcs_$status_minf                007702 constant        entry                    external dcl 291 ref 678
hdr_sw                  212            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1445* 1474* 1477 1741*
hdra                            000323 constant        char(18)                 initial packed unaligned dcl 171 set ref 1719*
hdra1                           000306 constant        char(5)                  initial packed unaligned dcl 174 set ref 1719*
hdra2                           000232 constant        char(2)                  initial packed unaligned dcl 180 set ref 1719*
hdra3                           000220 constant        char(40)                 initial packed unaligned dcl 181 set ref 1719*
hdra4                           000216 constant        char(7)                  initial packed unaligned dcl 183 set ref 1719*
hdrb                            000310 constant        char(42)                 initial packed unaligned dcl 172 set ref 1724*
hdrb1                           000272 constant        char(46)                 initial packed unaligned dcl 175 set ref 1724*
hdrb2                           000267 constant        char(12)                 initial packed unaligned dcl 177 set ref 1724*
hdrb3                           000233 constant        char(111)                initial packed unaligned dcl 178 set ref 1724*
hdrb4                           000205 constant        char(30)                 initial packed unaligned dcl 184 set ref 1724*
header                                 based           structure                level 2 in structure "gk_info" unaligned dcl 2-41
                                                                                  in procedure "dfm_util_"
header                                 based           structure                level 1 packed packed unaligned dcl 15-14
                                                                                  in procedure "dfm_util_"
header_key                      000236 automatic       varying char(24)         dcl 69 set ref 1730* 1731* 1733 1735
header_ptr                             parameter       pointer                  dcl 15-11 set ref 1077 1091* 1094 1097
hi_sl_info                             based           structure                level 1 unaligned dcl 18-27
hpatches                213            based           structure                array level 2 dcl 3-23 set ref 578 578
i                               000246 automatic       fixed bin(17,0)          dcl 71 set ref 557* 558 558 560 561 562 562 572 573
                                                                                  574 575 576 577 578 578 579* 820* 821 827* 1018*
                                                                                  1019* 1089* 1090* 1213* 1214 1214 1214 1214* 1643*
                                                                                  1644 1644* 1668* 1669* 1673 1729* 1730 1731 1731
                                                                                  1731 1731* 1757* 1763 1766 1772 1773 1773 1774*
                                                                                  1793* 1794 1794* 1803* 1804 1804* 1810* 1812 1812
                                                                                  1813 1813*
id_bbuf                                based           bit(108)                 packed unaligned dcl 233 set ref 1674*
id_blk                                 based           structure                level 1 dcl 3-177
id_buf                  523            based           char(18)                 level 2 dcl 3-23 set ref 338 347 353 359 360 575 576
                                                                                  606 940 940 940 942 943 945 1442 1442 1444 1445
                                                                                  1493 1493 1571 1600 1600 1674*
id_ld                           000247 automatic       bit(1)                   packed unaligned dcl 72 set ref 468* 515 516* 1244*
                                                                                  1335 1336*
idcw                                   based           structure                level 1 dcl 13-21
ident                                  based           char(6)                  level 2 packed packed unaligned dcl 3-177 set ref
                                                                                  943 1493* 1600
ident_buf                       000250 automatic       bit(36)                  array dcl 73 set ref 1631* 1644* 1668 1668 1669 1673
index                                                  builtin function         dcl 127 ref 432 432 620 620 689 729 749 762 920 922
                                                                                  922 931 957 1035 1035 1035 1048 1048 1157 1179
                                                                                  1204 1204 1482 1484 1503 1533 1733 1758 1761 1800
                                                                                  1810 1824
info                            000320 automatic       bit(36)                  array packed unaligned dcl 74 set ref 795 796*
info_ptr                        000344 automatic       pointer                  dcl 75 set ref 795* 797 798 799 800 801 802 802 803
                                                                                  803 804* 815 820 821 829 830 831 832 833*
input_desc                0(01)        based           bit(1)                   level 4 packed packed unaligned dcl 2-41 set ref
                                                                                  818*
interval                  6            based           structure                array level 2 unaligned dcl 18-27
io_parameter_block                     based           structure                level 1 packed packed unaligned dcl 11-50
ioa_                            007704 constant        entry                    external dcl 292 ref 1106 1112 1118
ioa_$ioa_switch                 007706 constant        entry                    external dcl 292 ref 1199 1220
ioa_$rs                         007710 constant        entry                    external dcl 292 ref 432 620 1048 1053 1056 1184
                                                                                  1210 1487 1493 1699 1702 1705 1707 1712 1715 1719
                                                                                  1724 1754 1773
iocb_ptr                               parameter       pointer                  dcl 447 set ref 445 451* 452* 453*
iocbp                                  parameter       pointer                  dcl 76 set ref 785 804* 809* 822* 833* 844 852* 860*
                                                                                  871 882* 885* 895* 1132 1137* 1140* 1149 1156*
                                                                                  1157* 1159* 1171* 1175*
iox_$attach_name                007712 constant        entry                    external dcl 293 ref 1137
iox_$close                      007714 constant        entry                    external dcl 294 ref 451
iox_$control                    007716 constant        entry                    external dcl 295 ref 390 479 613 804 822 833 1047
                                                                                  1264 1265 1270 1276 1465 1838 1859 1877 1884 1885
iox_$delete_record              007720 constant        entry                    external dcl 296 ref 415 1820
iox_$detach_iocb                007722 constant        entry                    external dcl 297 ref 452
iox_$open                       007724 constant        entry                    external dcl 298 ref 1140
iox_$position                   007726 constant        entry                    external dcl 299 ref 809 1156
iox_$put_chars                  007730 constant        entry                    external dcl 300 ref 1192 1214
iox_$read_record                007732 constant        entry                    external dcl 301 ref 428 617 860 1031 1043 1175 1255
iox_$rewrite_record             007734 constant        entry                    external dcl 302 ref 885
iox_$seek_key                   007736 constant        entry                    external dcl 303 ref 409 425 472 614 852 882 1027
                                                                                  1040 1171 1816
iox_$write_record               007740 constant        entry                    external dcl 304 ref 895 1869
iox_modes                       000000 constant        char(24)                 initial array dcl 7-6 set ref 1141*
istat                                  based           structure                level 1 dcl 14-7
j                               000346 automatic       fixed bin(17,0)          dcl 77 set ref 1026* 1027 1027 1029 1032 1035 1035
                                                                                  1038 1038 1053 1056 1061* 1169* 1171 1171 1172
                                                                                  1179 1204 1204* 1763* 1764 1764*
k                               000347 automatic       fixed bin(17,0)          dcl 78 set ref 1163* 1180 1181 1188 1189* 1189 1198
                                                                                  1200*
key                       1            based           char(24)                 array level 2 in structure "mcata" dcl 3-148
                                                                                  in procedure "dfm_util_" set ref 925*
key                       3            based           char                     level 2 in structure "gk_info" packed packed
                                                                                  unaligned dcl 2-41 in procedure "dfm_util_" ref
                                                                                  827
key                       1            based           char(24)                 array level 2 in structure "cata" dcl 3-130
                                                                                  in procedure "dfm_util_" set ref 959*
key                       1            based           char(24)                 array level 2 in structure "wcata" packed packed
                                                                                  unaligned dcl 271 in procedure "dfm_util_" set ref
                                                                                  855* 861
key                       1            based           char(24)                 array level 2 in structure "lcata" dcl 3-144
                                                                                  in procedure "dfm_util_" set ref 1027 1027 1029*
                                                                                  1032* 1035 1035 1038 1038 1053 1056 1061 1171 1171
                                                                                  1172* 1179 1204 1506* 1735* 1764* 1764 1766* 1768*
                                                                                  1804* 1804 1807* 1812* 1812 1813*
key                       1            based           char(24)                 array level 2 in structure "dcata" dcl 3-134
                                                                                  in procedure "dfm_util_" set ref 933*
key                       1            based           char(24)                 array level 2 in structure "catalog" dcl 220
                                                                                  in procedure "dfm_util_" set ref 827*
key_len                   2            based           fixed bin(17,0)          level 3 dcl 2-41 ref 827
kptr                      7            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  packed unaligned dcl 18-27 in procedure
                                                                                  "dfm_util_" set ref 803*
kptr                     11            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  packed unaligned dcl 18-27 in procedure
                                                                                  "dfm_util_" set ref 803*
l_att_desc              532            based           char(181)                level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1330* 1330
label                   721            based           char(6)                  array level 3 packed packed unaligned dcl 3-23 set
                                                                                  ref 561*
last_head                10            based           structure                array level 3 unaligned dcl 18-27
lbl                     235            based           char(4)                  array level 3 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 574* 577*
lbl                      22            based           char(4)                  level 2 in structure "h_patch" packed packed
                                                                                  unaligned dcl 3-162 in procedure "dfm_util_" ref
                                                                                  1571
lbound                                                 builtin function         dcl 129 ref 1018 1213 1668 1729
lbuff                                  based           char(300)                packed unaligned dcl 3-140 set ref 422 423* 432* 432
                                                                                  432 432 432 437 611 612* 620* 620 620 620 620 626
                                                                                  1015 1016* 1035 1048* 1048 1048 1048 1048 1053*
                                                                                  1053 1053 1056* 1056 1056 1067 1166 1170* 1184*
                                                                                  1184 1184 1188 1191* 1191 1191 1192 1192 1204 1223
                                                                                  1478 1479* 1487* 1493* 1511 1752 1753* 1754* 1769
                                                                                  1769 1773* 1778
lbuff_len                       000350 automatic       fixed bin(21,0)          dcl 79 set ref 428* 432* 436* 617* 620* 624* 1031*
                                                                                  1048* 1053* 1056* 1061* 1175* 1184* 1487* 1493*
                                                                                  1510* 1754* 1773*
lbuff_p                 610            based           pointer                  level 2 dcl 3-23 set ref 422* 423 428* 432 432 432
                                                                                  432 432 436* 437 438* 611* 612 617* 620 620 620
                                                                                  620 620 624* 626 627* 1015* 1016 1031* 1035 1048
                                                                                  1048 1048 1048 1048 1053 1053 1053 1056 1056 1056
                                                                                  1061* 1067 1068* 1166* 1170 1175* 1184 1184 1184
                                                                                  1188 1191 1191 1191 1192* 1192 1192 1204 1223
                                                                                  1224* 1478* 1479 1487 1493 1510* 1511 1512* 1752*
                                                                                  1753 1754 1769* 1769 1769 1773 1778 1779*
lc                              000164 constant        char(26)                 initial packed unaligned dcl 3-113 ref 1435 1533
lcata                                  based           structure                level 1 dcl 3-144 set ref 1064 1064
lcata_key_string                       based           char                     packed unaligned dcl 3-156 ref 1503 1733 1758 1761
                                                                                  1800
lcatp                   612            based           pointer                  level 2 dcl 3-23 set ref 1020* 1023* 1026 1027 1027
                                                                                  1029 1032 1035 1035 1038 1038 1053 1056 1061 1064*
                                                                                  1064 1064 1157* 1159* 1169 1171 1171 1172 1179
                                                                                  1204 1204 1204 1503 1505 1505 1506 1506 1687 1688*
                                                                                  1733 1734 1734 1735 1735 1758 1761 1762 1762 1763
                                                                                  1764 1764 1766 1768 1800 1803 1804 1804 1807 1807
                                                                                  1808 1808 1812 1812 1813
ld_type                   5(09)        based           char(1)                  level 2 packed packed unaligned dcl 238 ref 1450
                                                                                  1451 1452 1453
length                   10            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 18-27
                                                                                  in procedure "dfm_util_" set ref 802*
length                                                 builtin function         dcl 130 in procedure "dfm_util_" ref 432 432 620 620
                                                                                  802 1048 1048 1064 1064 1192 1192 1214 1214 1731
                                                                                  1731 1769 1769
length                    6            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 18-27
                                                                                  in procedure "dfm_util_" set ref 802*
lfd                     616            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 919
                                                                                  1433 1468 1481 1697
lib                     616(02)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1426* 1440* 1493* 1503 1719* 1724*
lib_type                616(09)        based           char(6)                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1472 1473* 1730
library                   3(27)        based           char(6)                  level 2 packed packed unaligned dcl 238 set ref 338
                                                                                  346 515 606 939 1335 1439 1441 1712*
line_count                      000351 automatic       fixed bin(17,0)          dcl 80 set ref 1164* 1183* 1203* 1203 1204 1208*
liocb_ptr               620            based           pointer                  level 2 dcl 3-23 set ref 1192* 1199* 1214* 1220*
list                    622            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref 702
                                                                                  737 751 1465 1493* 1719* 1724*
list_key                623            based           varying char(24)         level 2 dcl 3-23 set ref 424* 425* 426* 429* 436
                                                                                  610* 614 614 615 615 618 618 624 1019* 1020 1021*
                                                                                  1022 1023* 1024* 1064* 1157 1501* 1503 1506 1510*
list_type                              based           fixed bin(3,0)           level 3 packed packed unaligned dcl 18-8 set ref
                                                                                  798* 829*
list_types                      000147 constant        char(17)                 initial array packed unaligned dcl 3-116 ref 1018
                                                                                  1018 1019
lksp                    614            based           pointer                  level 2 dcl 3-23 set ref 1023* 1159* 1503 1688* 1733
                                                                                  1758 1761 1800
lowest_access                          parameter       fixed bin(5,0)           dcl 1545 ref 1541 1551
ls_type                 632            based           varying char(10)         level 2 dcl 3-23 set ref 1468* 1469* 1470* 1688
ltrim                                                  builtin function         dcl 131 ref 915 1730 1774 1813
ltype                                  parameter       fixed bin(2,0)           dcl 1419 ref 1416 1493 1515
lx                              000352 automatic       fixed bin(17,0)          dcl 81 set ref 1630* 1644 1646* 1646
m                               000353 automatic       fixed bin(17,0)          dcl 82 set ref 1638* 1647 1653* 1653
m_applic                  6(18)        based           char(1)                  level 2 packed packed unaligned dcl 238 ref 337 1461
                                                                                  1493
m_attached              636            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref 976
                                                                                  980* 994 998*
maj                       0(02)        based           bit(4)                   level 2 packed packed unaligned dcl 3-186 ref 1399
max_retrys                             constant        fixed bin(17,0)          initial dcl 187 ref 1269 1876
mca_$attach_mca                 007742 constant        entry                    external dcl 305 ref 977
mca_$detach_mca                 007744 constant        entry                    external dcl 306 ref 995
mca_$diskette_read              007746 constant        entry                    external dcl 307 ref 1392
mca_$read_data                  007750 constant        entry                    external dcl 308 ref 1399 1406
mca_buf_size                    000443 automatic       fixed bin(21,0)          initial dcl 1379 set ref 1379* 1392* 1399* 1406*
mca_dcw_list                           based           structure                level 1 packed packed unaligned dcl 11-81
mca_id                                 parameter       char(4)                  packed unaligned dcl 971 set ref 969 977* 978*
mca_ioi_idx             637            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 977* 995* 1392* 1399* 1406*
mca_status                             based           structure                level 1 packed packed unaligned dcl 3-186
mca_sub                                based           structure                level 1 packed packed unaligned dcl 3-192
mcata                                  based           structure                level 1 dcl 3-148
mcata_key_string                       based           char                     packed unaligned dcl 3-158 ref 922
mcatp                   642            based           pointer                  level 2 dcl 3-23 ref 922 924 924 925 925
mdf                     644            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 880
                                                                                  1154 1687 1729
media_code                0(26)        based           fixed bin(4,0)           level 3 packed packed unsigned unaligned dcl 226 set
                                                                                  ref 505 635 645* 1311 1349 1357* 1635 1658 1658
merge_key                       000354 automatic       varying char(24)         dcl 83 set ref 1038* 1040* 1041* 1044* 1046* 1048
                                                                                  1048 1048 1048
mksp                    646            based           pointer                  level 2 dcl 3-23 ref 922
mode                                   parameter       fixed bin(17,0)          dcl 84 set ref 1132 1140* 1141
model                    12(18)        based           char(6)                  level 2 packed packed unaligned dcl 238 set ref
                                                                                  1493*
mpcbot                          000204 constant        bit(36)                  initial packed unaligned dcl 188 ref 1669
mstat                                  parameter       bit(72)                  packed unaligned dcl 1382 set ref 1376 1392* 1396
                                                                                  1406*
mvp                             000364 automatic       pointer                  dcl 85 set ref 484* 523 524 525* 525 536 537* 537
                                                                                  542* 542 552 553 554* 554 567* 569 583* 585 592*
                                                                                  594
n_entries                              based           fixed bin(17,0)          level 2 in structure "dcata" dcl 3-134 in procedure
                                                                                  "dfm_util_" set ref 931 932* 932 933
n_entries                              based           fixed bin(17,0)          level 2 in structure "lcata" dcl 3-144 in procedure
                                                                                  "dfm_util_" set ref 1026 1064 1064 1169 1204 1204
                                                                                  1503 1505* 1505 1506 1687 1733 1734* 1734 1735
                                                                                  1758 1761 1762* 1762 1763 1800 1803 1807 1808*
                                                                                  1808
n_entries                              based           fixed bin(17,0)          level 2 in structure "catalog" dcl 220 in procedure
                                                                                  "dfm_util_" set ref 815*
n_entries                              based           fixed bin(17,0)          level 2 in structure "wcata" dcl 271 in procedure
                                                                                  "dfm_util_" set ref 855 856*
n_entries                              based           fixed bin(17,0)          level 2 in structure "cata" dcl 3-130 in procedure
                                                                                  "dfm_util_" set ref 358* 957 958* 958 959
n_entries                              based           fixed bin(17,0)          level 2 in structure "mcata" dcl 3-148 in procedure
                                                                                  "dfm_util_" set ref 922 924* 924 925
nbcwp                           000366 automatic       pointer                  dcl 86 set ref 596* 597 598 600 600 601 603
new_bcw                                based           structure                level 1 dcl 236
new_iocbp                              parameter       pointer                  dcl 87 set ref 1008 1046* 1047* 1061* 1064*
no_chase_sw                     000630 constant        fixed bin(1,0)           initial dcl 192 set ref 678*
no_type                                constant        fixed bin(2,0)           initial dcl 193 ref 672
npatches                               parameter       fixed bin(17,0)          dcl 88 ref 462 557 557
null                                                   builtin function         dcl 132 ref 390 390 438 453 470 517 627 801 832 1068
                                                                                  1137 1137 1224 1226 1251 1264 1264 1265 1265 1276
                                                                                  1276 1337 1512 1603 1605 1740 1779 1838 1838 1859
                                                                                  1859 1884 1884 1885 1885
nwds                            000370 automatic       fixed bin(17,0)          dcl 89 set ref 501* 503 648* 648 1308* 1310 1362*
                                                                                  1362
nxt_c_wd                               based           bit(36)                  level 2 packed packed unaligned dcl 261 set ref 1647
                                                                                  1651
o_card                                 based           structure                level 1 dcl 238
o_patch                                based           structure                level 1 dcl 3-197
obj_card                650            based           char(80)                 level 2 dcl 3-23 set ref 336 366* 509* 511 910 1314*
                                                                                  1316 1423
obj_card_found                  000371 automatic       bit(1)                   packed unaligned dcl 90 set ref 468* 510* 635 1244*
                                                                                  1315* 1349
ocardp                          000372 automatic       pointer                  dcl 91 set ref 336* 337 338 341 346 361 362 363 364
                                                                                  511* 515 561 574 577 606 910* 915 939 944 949 949
                                                                                  951 951 953 953 1316* 1317 1317 1320 1322 1324
                                                                                  1335 1423* 1439 1441 1450 1451 1452 1453 1455 1456
                                                                                  1458 1459 1460 1461 1461 1493 1493 1493 1493 1493
                                                                                  1493 1493 1493 1493 1493 1571 1571 1600 1712 1719
                                                                                  1724
old_iocbp                              parameter       pointer                  dcl 92 set ref 1008 1020* 1023* 1027* 1031* 1040*
                                                                                  1043*
one_eof                 676            based           bit(1)                   level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1843*
opatches                677            based           structure                array level 2 dcl 3-23 set ref 562 562 579*
opr_query_                      007752 constant        entry                    external dcl 309 ref 1097 1109
opr_query_info                  001411 automatic       structure                level 1 dcl 16-8 set ref 1097 1097 1109 1109
output_descriptors        0(05)        based           bit(1)                   level 3 packed packed unaligned dcl 18-8 set ref
                                                                                  799*
p_blk                           000010 internal static structure                level 1 dcl 257
p_card                    1     000010 internal static char(80)                 array level 2 dcl 257 set ref 1583* 1773 1773 1794*
                                                                                  1794
p_cnt                           000010 internal static fixed bin(17,0)          level 2 dcl 257 set ref 469* 620 628 1245* 1513
                                                                                  1581* 1581 1583 1757 1772 1780* 1791 1797* 1797
                                                                                  1810 1824
page_no                1207            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 689* 729* 1182* 1182 1184*
                                                                                  1209* 1209 1210*
patch_key                       000374 automatic       varying char(24)         dcl 93 set ref 1755* 1758 1766 1768 1769 1769 1774*
                                                                                  1798* 1800 1810 1816* 1817* 1821* 1824 1825*
pbuf_size                       000403 automatic       fixed bin(21,0)          dcl 94 set ref 486*
pfile                  1211            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 1246 1246*
pptr                                   parameter       pointer                  dcl 95 ref 462
prg_id                  225(18)        based           char(12)                 array level 3 packed packed unaligned dcl 3-23 set
                                                                                  ref 575*
prim                      2     001411 automatic       char(8)                  level 2 dcl 16-8 set ref 1084*
print                           000630 constant        bit(1)                   initial packed unaligned dcl 195 set ref 366* 775*
                                                                                  996* 1878* 1891*
psz                             000404 automatic       fixed bin(17,0)          dcl 96 set ref 1637* 1644 1647 1651 1652*
ptr                                                    builtin function         dcl 133 ref 604 604 606 606
px                              000405 automatic       fixed bin(17,0)          dcl 97 set ref 1791* 1793 1810
q_sw                      1     001411 automatic       bit(1)                   level 2 dcl 16-8 set ref 1096* 1107*
r_card                                 based           structure                level 1 dcl 261
r_comment                33     001411 automatic       char(64)                 level 2 dcl 16-8 set ref 1086* 1108*
rcode                                  parameter       fixed bin(35,0)          dcl 98 set ref 402 407* 411* 417* 462 474* 481* 785
                                                                                  793* 806* 812* 824* 834* 844 862* 1376 1394*
rcw                                    based           structure                level 2 in structure "gc_log_rec" packed packed
                                                                                  unaligned dcl 5-15 in procedure "dfm_util_"
rcw                                    based           structure                level 2 in structure "glr" packed packed unaligned
                                                                                  dcl 226 in procedure "dfm_util_"
rec_cont_wrd                    000203 constant        bit(36)                  initial packed unaligned dcl 196 ref 566 582 591
rec_len                         000406 automatic       fixed bin(21,0)          dcl 99 set ref 409* 425* 428* 472* 486 614* 617*
                                                                                  860* 1027* 1031* 1043* 1046* 1091* 1171* 1175*
                                                                                  1255* 1289 1289 1289 1816*
rec_length                      000442 automatic       fixed bin(21,0)          dcl 846 set ref 852* 860* 882* 1040* 1043*
record_length             2     000424 automatic       fixed bin(21,0)          level 2 dcl 269 set ref 620* 1048* 1487* 1493*
record_ptr                4     000424 automatic       pointer                  level 2 dcl 269 set ref 484 620 620 1048 1048 1487
                                                                                  1487 1493 1493
rel                                                    builtin function         dcl 134 ref 523 523 552 552 597 597 604 620 620 1048
                                                                                  1048 1368 1487 1487 1493 1493 1867
reset_pos                 0(18)        based           bit(1)                   level 4 packed packed unaligned dcl 2-41 set ref
                                                                                  819*
ret_len                         000446 automatic       fixed bin(21,0)          dcl 1383 set ref 1389* 1392* 1399* 1403* 1404 1406*
rev                       2(18)        based           char(2)                  level 3 in structure "id_blk" packed packed
                                                                                  unaligned dcl 3-177 in procedure "dfm_util_" set
                                                                                  ref 945 1493* 1600
rev                     233(18)        based           char(6)                  array level 3 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 576*
rev                      20(18)        based           char(6)                  level 2 in structure "h_patch" packed packed
                                                                                  unaligned dcl 3-162 in procedure "dfm_util_" ref
                                                                                  1571
revision                  1(18)        based           structure                level 2 packed packed unaligned dcl 3-177 set ref
                                                                                  575 576 1571
rk_header                              based           structure                level 1 unaligned dcl 2-26
rs_desc                                based           structure                level 1 packed packed unaligned dcl 4-32
rs_info                                based           structure                level 1 dcl 4-6
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 4-44 ref 478 1014 1425
rsi                             000424 automatic       structure                level 1 dcl 269 set ref 477* 479 479 613 613 1013*
                                                                                  1047 1047 1424* 1465 1465
rsize                                  based           fixed bin(18,0)          level 3 in structure "gc_log_rec" packed packed
                                                                                  unsigned unaligned dcl 5-15 in procedure
                                                                                  "dfm_util_" ref 649 1363 1657
rsize                                  based           fixed bin(18,0)          level 3 in structure "glr" packed packed unsigned
                                                                                  unaligned dcl 226 in procedure "dfm_util_" ref 508
                                                                                  509 509 521 521 535 542 548 549 549 648 1313 1314
                                                                                  1314 1341 1343 1343 1362 1647
rtrim                                                  builtin function         dcl 135 ref 373 424 432 432 432 432 610 614 614 615
                                                                                  615 618 618 620 620 620 620 770 770 770 770 775
                                                                                  775 775 775 802 921 930 943 944 945 1027 1027 1048
                                                                                  1048 1048 1048 1171 1171 1188 1192 1192 1214 1214
                                                                                  1330 1501 1730 1730 1731 1731 1755 1758 1761 1766
                                                                                  1768 1769 1769 1769 1769 1773 1773 1774 1798 1800
                                                                                  1813 1825
rtrycnt                         000407 automatic       fixed bin(17,0)          dcl 100 set ref 1254* 1268* 1268 1269
scode                           000410 automatic       fixed bin(35,0)          dcl 101 set ref 1270* 1877* 1884* 1885*
segp                            000412 automatic       pointer                  dcl 102 set ref 1602* 1603 1604* 1605 1609* 1612*
                                                                                  1617*
sl_info_version_0                      constant        fixed bin(17,0)          initial dcl 18-43 ref 797
ss_type                   5(18)        based           char(1)                  level 2 packed packed unaligned dcl 238 ref 341 361
                                                                                  362 363 364 949 951 953 1455 1456 1458 1459 1460
                                                                                  1461
sstype                 1214            based           char(5)                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  361* 362* 363* 364* 373 1427* 1430* 1434* 1441*
                                                                                  1455* 1456* 1458* 1459* 1460* 1461* 1463* 1472
                                                                                  1473 1487* 1493*
statp                  1216            based           pointer                  level 2 dcl 3-23 set ref 1396* 1397 1399
string                                                 builtin function         dcl 136 ref 562 562 575 576 578 578 940 1533 1571
sub                       0(06)        based           bit(4)                   level 2 packed packed unaligned dcl 3-186 set ref
                                                                                  1397
sub_ptr                1220            based           pointer                  level 2 dcl 3-23 set ref 1397* 1399 1405
subset_no                 2            based           fixed bin(17,0)          level 2 dcl 18-8 set ref 830*
substr                                                 builtin function         dcl 137 set ref 432 432 432 432 508 548 566 572 582
                                                                                  589* 591 620 620 620 620 915 921 949 1038 1048
                                                                                  1048 1094 1094 1191 1289 1289 1313 1341 1435 1441
                                                                                  1444* 1482 1484 1486 1493 1493 1493 1493 1493 1493
                                                                                  1533 1647
svp                             000414 automatic       pointer                  dcl 103 set ref 1632* 1675
sw_name                                parameter       char(64)                 packed unaligned dcl 104 set ref 1132 1137* 1138*
                                                                                  1141*
sys_dir                         000175 constant        char(21)                 initial packed unaligned dcl 198 set ref 693 693 702
                                                                                  706* 751 754*
t_stat                          000416 automatic       bit(12)                  dcl 105 set ref 1270 1270 1272* 1877 1877 1878*
tape_name              1277(09)        based           char(16)                 level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  1715*
term                            000417 automatic       bit(1)                   packed unaligned dcl 106 set ref 421* 609* 630* 675*
                                                                                  677 688* 711* 728* 742* 746* 759* 762* 1088* 1089
                                                                                  1095* 1105 1639* 1641 1647* 1666* 1668 1669*
terminal_out           1303(09)        based           bit(1)                   level 2 packed packed unaligned dcl 3-23 ref 1191
                                                                                  1193 1215
text_len                  1(18) 000456 automatic       bit(18)                  level 2 packed packed unaligned dcl 6-5 set ref 1617
time_string            1306            based           char(24)                 level 2 packed packed unaligned dcl 3-23 set ref 432
                                                                                  432 620 620 1053* 1699* 1712*
tiocb_ptr              1304            based           pointer                  level 2 dcl 3-23 set ref 1255* 1264* 1265* 1270*
                                                                                  1276* 1838*
tolts_alm_util_$ascii_to_bcd_   007754 constant        entry                    external dcl 310 ref 562 578 590
total_chars                            parameter       fixed bin(21,0)          dcl 1384 set ref 1376 1389* 1404* 1404
translate                                              builtin function         dcl 138 ref 1435 1533
true                            000174 constant        bit(1)                   initial packed unaligned dcl 200 ref 349 357 371 378
                                                                                  391 491 510 516 527 550 630 688 711 728 742 746
                                                                                  759 762 799 818 819 980 1095 1099 1107 1242 1283
                                                                                  1292 1297 1315 1328 1336 1341 1440 1445 1474 1533
                                                                                  1551 1571 1577 1647 1669 1843 1854 1880 1892
ttl_date                 20(18)        based           char(6)                  level 2 packed packed unaligned dcl 238 ref 1493
                                                                                  1493 1493 1493 1493 1493
two_byte                               based           structure                level 1 packed packed unaligned dcl 15-45
type                            000420 automatic       fixed bin(2,0)           dcl 107 in procedure "dfm_util_" set ref 672* 678*
                                                                                  701 714 749
type                      1(27)        based           char(5)                  level 2 in structure "o_patch" packed packed
                                                                                  unaligned dcl 3-197 in procedure "dfm_util_" ref
                                                                                  1577 1577
type                      1(18)        based           char(4)                  level 2 in structure "h_patch" packed packed
                                                                                  unaligned dcl 3-162 in procedure "dfm_util_" ref
                                                                                  1571 1571
type                    700(27)        based           char(5)                  array level 3 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" set
                                                                                  ref 558 558
type                      3(27)        based           char(3)                  level 3 in structure "id_blk" packed packed
                                                                                  unaligned dcl 3-177 in procedure "dfm_util_" ref
                                                                                  338 347 353 359 360 606 940 940 942 1442 1442 1444
                                                                                  1445
type                    214(18)        based           char(4)                  array level 3 in structure "dfm_data" packed packed
                                                                                  unaligned dcl 3-23 in procedure "dfm_util_" ref
                                                                                  572
type_code                 3            based           structure                level 2 packed packed unaligned dcl 3-177 ref 940
uc                              000140 constant        char(26)                 initial packed unaligned dcl 3-120 ref 1435 1533
unique_id                17(27)        based           char(8)                  level 2 packed packed unaligned dcl 15-14 set ref
                                                                                  1094 1097*
unspec                                                 builtin function         dcl 139 set ref 477* 796* 817* 1013* 1064 1064 1424*
user_access                     000421 automatic       fixed bin(5,0)           dcl 108 set ref 1547* 1551
v_patch                         000422 automatic       bit(1)                   packed unaligned dcl 109 set ref 1569* 1571* 1577
                                                                                  1577* 1580 1586
valid_diskettes                 000116 constant        char(5)                  initial array packed unaligned dcl 3-123 ref 1533
verify                                                 builtin function         dcl 140 ref 1038 1191
version                         000424 automatic       fixed bin(17,0)          level 2 in structure "rsi" dcl 269 in procedure
                                                                                  "dfm_util_" set ref 478* 1014* 1425*
version                   0(18)        based           fixed bin(17,0)          level 3 in structure "common_sl_info" packed packed
                                                                                  unaligned dcl 18-8 in procedure "dfm_util_" set
                                                                                  ref 797*
wcata                                  based           structure                level 1 unaligned dcl 271
wcatp                                  parameter       pointer                  dcl 110 set ref 844 855 856 860* 861
whitespace                             constant        char(2)                  initial packed unaligned dcl 202 ref 1191
wksp                                   parameter       pointer                  dcl 111 set ref 844 861*
work_key                               parameter       varying char(24)         dcl 112 set ref 402 409* 424 432 432 432 432 462
                                                                                  472* 530* 604* 610 620 620 620 620 871 882* 886*
                                                                                  891* 896* 1149 1157 1159* 1160* 1755 1761 1774
                                                                                  1798 1813 1825
wrapup                          000174 constant        bit(1)                   initial packed unaligned dcl 204 set ref 426* 429*
                                                                                  495* 563* 579* 615* 618* 635* 645* 680* 719* 770*
                                                                                  886* 891* 896* 978* 1024* 1029* 1032* 1041* 1044*
                                                                                  1138* 1141* 1160* 1172* 1176* 1193* 1215* 1272*
                                                                                  1279* 1301* 1324* 1343* 1349* 1357* 1548* 1605*
                                                                                  1613* 1618* 1690* 1817* 1821* 1839* 1860*
yes_sw                          000423 automatic       bit(1)                   packed unaligned dcl 113 set ref 530* 534 674* 684*
                                                                                  687 706* 709 724* 727 739* 742 754* 757

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABORT_SES_FROM_HOST                    internal static fixed bin(9,0)           initial unsigned dcl 11-114
ALTER_LOAD_FAILED                      internal static fixed bin(17,0)          initial dcl 10-24
ALTER_NOT_FOUND                        internal static fixed bin(17,0)          initial dcl 10-23
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
BASIC_ROM_FAILED                       internal static fixed bin(17,0)          initial dcl 10-15
BIN_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 11-112
CON_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 11-110
CON_SET_UP_FAILED                      internal static fixed bin(17,0)          initial dcl 10-19
DATA_FROM_HOST                         internal static fixed bin(9,0)           initial unsigned dcl 11-96
DATA_FROM_MCA                          internal static fixed bin(9,0)           initial unsigned dcl 11-102
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 7-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 7-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 7-15
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
FW_EXEC_FAILED                         internal static fixed bin(17,0)          initial dcl 10-25
FW_LOAD_FAILED                         internal static fixed bin(17,0)          initial dcl 10-22
FW_NOT_FOUND                           internal static fixed bin(17,0)          initial dcl 10-21
HW_ID_NO_MATCH                         internal static fixed bin(17,0)          initial dcl 10-18
IPC_CONS_2                             internal static fixed bin(17,0)          initial dcl 10-31
IPC_DAI                                internal static fixed bin(17,0)          initial dcl 10-32
IPC_DISK_FIPS                          internal static fixed bin(17,0)          initial dcl 10-35
IPC_IDI                                internal static fixed bin(17,0)          initial dcl 10-33
IPC_PDSI                               internal static fixed bin(17,0)          initial dcl 10-30
IPC_TAPE_FIPS                          internal static fixed bin(17,0)          initial dcl 10-34
JAM_FAILED                             internal static fixed bin(17,0)          initial dcl 10-16
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 7-15
MCA_area_version_1                     internal static char(8)                  initial packed unaligned dcl 8-19
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
NDIC                                   internal static fixed bin(17,0)          initial dcl 10-36
NOT_CONFIGED                           internal static fixed bin(17,0)          initial dcl 10-13
NO_CONFIG_PRESENT                      internal static fixed bin(17,0)          initial dcl 10-12
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
OPERATIONAL                            internal static fixed bin(17,0)          initial dcl 10-26
PH_NOT_PRESENT                         internal static fixed bin(17,0)          initial dcl 10-14
PSIA_2_TRIP                            internal static fixed bin(17,0)          initial dcl 10-29
PSIA_4_TRIP                            internal static fixed bin(17,0)          initial dcl 10-37
REQ_DATA_FROM_HOST                     internal static fixed bin(9,0)           initial unsigned dcl 11-104
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RSO_FAILED                             internal static fixed bin(17,0)          initial dcl 10-20
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEEK                                   internal static fixed bin(9,0)           initial unsigned dcl 11-108
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SELF_FAILED                            internal static fixed bin(17,0)          initial dcl 10-17
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
STATUS_FROM_MCA                        internal static fixed bin(9,0)           initial unsigned dcl 11-106
STOP_ON_COND                           internal static fixed bin(17,0)          initial dcl 10-27
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 7-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 7-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 7-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 7-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 7-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 7-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 7-15
WRITE_CONSOLE                          internal static fixed bin(9,0)           initial unsigned dcl 11-98
WRITE_READ_CONSOLE                     internal static fixed bin(9,0)           initial unsigned dcl 11-100
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
ak_info                                based           structure                level 1 unaligned dcl 2-6
ak_info_ptr                            automatic       pointer                  dcl 2-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 2-19
da_sl_info                             based           structure                level 1 unaligned dcl 18-38
data_header_ptr                        automatic       pointer                  dcl 11-15
data_list_type                         internal static fixed bin(2,0)           initial dcl 3-111
dcwp                                   automatic       pointer                  dcl 12-4
dir_number                             automatic       fixed bin(17,0)          dcl 15-38
dir_ptr                                automatic       pointer                  dcl 15-36
dire_ptr                               automatic       pointer                  dcl 15-37
directory                              based           structure                level 1 packed packed unaligned dcl 15-40
file_ptr                               automatic       pointer                  dcl 15-62
file_size                              automatic       fixed bin(21,0)          dcl 15-63
gc_log_rec_bits                        based           bit                      packed unaligned dcl 5-26
gc_phy_rec_bits                        based           bit                      packed unaligned dcl 5-25
gk_info_version_0                      internal static fixed bin(17,0)          initial dcl 2-66
gk_key_len                             automatic       fixed bin(17,0)          dcl 2-64
hex_file                               based           structure                level 1 packed packed unaligned dcl 15-64
idcwp                                  automatic       pointer                  dcl 13-19
imess                                  based           structure                level 1 dcl 14-21
imp                                    automatic       pointer                  dcl 14-19
io_param_blk_ptr                       automatic       pointer                  dcl 11-19
isp                                    automatic       pointer                  dcl 14-5
lrptr                                  automatic       pointer                  dcl 5-7
max_words_to_rd                        internal static fixed bin(21,0)          initial dcl 3-119
mca_area                               based           structure                level 1 dcl 8-10
mca_area_ptr                           automatic       pointer                  dcl 8-17
mca_config_file                        based           structure                level 1 packed packed unaligned dcl 9-16
mca_config_file_ptr                    automatic       pointer                  dcl 9-14
mca_dcw_list_ptr                       automatic       pointer                  dcl 11-21
mca_work_space                         based           structure                level 1 unaligned dcl 11-25
mca_work_space_ptr                     automatic       pointer                  dcl 11-23
pcw                                    based           structure                level 1 dcl 13-6
pcwp                                   automatic       pointer                  dcl 13-4
prptr                                  automatic       pointer                  dcl 5-6
rk_info                                based           structure                level 1 unaligned dcl 2-22
rk_info_ptr                            automatic       pointer                  dcl 2-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 2-38
rs_info_ptr                            automatic       pointer                  dcl 4-5
rs_info_version_1                      internal static fixed bin(17,0)          initial dcl 4-43
seq_desc                               based           structure                level 1 packed packed unaligned dcl 4-37
short_iox_modes                        internal static char(4)                  initial array dcl 7-12
sl_array_limit                         automatic       fixed bin(17,0)          dcl 18-42
status_area_ptr                        automatic       pointer                  dcl 17-47
status_branch                          based           structure                level 1 dcl 17-8
status_entry_names                     based           char(32)                 array dcl 17-47
status_link                            based           structure                level 1 dcl 17-38
status_pathname                        based           char                     dcl 17-47
status_ptr                             automatic       pointer                  dcl 17-47
tdcw                                   based           structure                level 1 dcl 12-14
tdcwp                                  automatic       pointer                  dcl 12-4
two_byte_ptr                           automatic       pointer                  dcl 15-43

NAMES DECLARED BY EXPLICIT CONTEXT.
accessible                      020676 constant        entry                    internal dcl 1541 ref 683 702 702 723 737 751 762
ask_opr                         014064 constant        label                    dcl 1106 set ref 1119
ck_applic                       002715 constant        entry                    external dcl 331
ck_patch                        021035 constant        entry                    internal dcl 1562 ref 521 563 579 1343
copy_eof                        003266 constant        entry                    external dcl 385
delete_deck                     003352 constant        entry                    external dcl 402
detach_file                     004064 constant        entry                    external dcl 445
dfm_util_                       002672 constant        entry                    external dcl 38
dl_patch                        024176 constant        label                    dcl 1800 ref 1826
exit_ff_loop                    007720 constant        label                    dcl 770 ref 683 693 709 723 727 742 757 762
find_dkend                      004142 constant        entry                    external dcl 462
find_file                       006426 constant        entry                    external dcl 665
find_key                        010165 constant        entry                    external dcl 785 ref 1020 1157
get_cata                        010530 constant        entry                    external dcl 844 ref 1023 1159 1688
get_stat                        016166 constant        label                    dcl 1270 set ref 1262
insert_deck                     010671 constant        entry                    external dcl 871 ref 436 604 624 1046 1061 1064 1510
                                                                                  1731 1769
ld_fw_deck                      021167 constant        entry                    internal dcl 1596 ref 353 606
load_ident                      021652 constant        entry                    internal dcl 1627 ref 518 1339
make_key                        011225 constant        entry                    external dcl 907
mca_attach                      012074 constant        entry                    external dcl 969
mca_detach                      012223 constant        entry                    external dcl 989
merge_files                     012334 constant        entry                    external dcl 1008
mount_diskette                  013672 constant        entry                    external dcl 1077
open_file                       014260 constant        entry                    external dcl 1132
print_list                      014472 constant        entry                    external dcl 1149
put_hdr                         022065 constant        entry                    internal dcl 1685 ref 1477
put_patch                       023316 constant        entry                    internal dcl 1749 ref 628 1513
rd_loop                         017345 constant        label                    dcl 1394 set ref 1407
read_deck                       015765 constant        entry                    external dcl 1234
read_diskette                   017246 constant        entry                    external dcl 1376 ref 1091
read_diskette_hdr               013733 constant        label                    dcl 1091 ref 1117
remove_patch                    024103 constant        entry                    internal dcl 1789 ref 543
retry_cp                        025116 constant        label                    dcl 1869 ref 1886
retry_rd                        016041 constant        label                    dcl 1255 ref 1266 1277
space_file                      024655 constant        entry                    internal dcl 1836 ref 338 341
update_list                     017505 constant        entry                    external dcl 1416
valid_diskette                  020611 constant        entry                    external dcl 1525
write_copy                      024755 constant        entry                    internal dcl 1851 ref 1515

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     27106       37100   26253       27116
Length     40114   26253      7772        1000     632        7642

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dfm_util_                          1822 external procedure  is an external procedure.  
accessible                              internal procedure  shares stack frame of external procedure dfm_util_.  
ck_patch                                internal procedure  shares stack frame of external procedure dfm_util_.  
ld_fw_deck                              internal procedure  shares stack frame of external procedure dfm_util_.  
load_ident                              internal procedure  shares stack frame of external procedure dfm_util_.  
put_hdr                                 internal procedure  shares stack frame of external procedure dfm_util_.  
put_patch                               internal procedure  shares stack frame of external procedure dfm_util_.  
remove_patch                            internal procedure  shares stack frame of external procedure dfm_util_.  
space_file                              internal procedure  shares stack frame of external procedure dfm_util_.  
write_copy                              internal procedure  shares stack frame of external procedure dfm_util_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 p_blk                       dfm_util_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dfm_util_                000100 at_bot                      dfm_util_
                         000101 bcard                       dfm_util_
                         000120 bcnt                        dfm_util_
                         000122 bcwp                        dfm_util_
                         000124 bit_count                   dfm_util_
                         000125 c_rtrycnt                   dfm_util_
                         000126 cbcwp                       dfm_util_
                         000130 cden                        dfm_util_
                         000132 code                        dfm_util_
                         000133 cx                          dfm_util_
                         000134 cvp                         dfm_util_
                         000136 cvp1                        dfm_util_
                         000140 dk_end                      dfm_util_
                         000142 dk_type                     dfm_util_
                         000144 dkend_card                  dfm_util_
                         000170 ename                       dfm_util_
                         000200 file_found                  dfm_util_
                         000201 first_patch                 dfm_util_
                         000202 first_rcd                   dfm_util_
                         000204 glrp                        dfm_util_
                         000206 glrbp                       dfm_util_
                         000210 gki                         dfm_util_
                         000234 gprp                        dfm_util_
                         000236 header_key                  dfm_util_
                         000245 hbuff_len                   dfm_util_
                         000246 i                           dfm_util_
                         000247 id_ld                       dfm_util_
                         000250 ident_buf                   dfm_util_
                         000320 info                        dfm_util_
                         000344 info_ptr                    dfm_util_
                         000346 j                           dfm_util_
                         000347 k                           dfm_util_
                         000350 lbuff_len                   dfm_util_
                         000351 line_count                  dfm_util_
                         000352 lx                          dfm_util_
                         000353 m                           dfm_util_
                         000354 merge_key                   dfm_util_
                         000364 mvp                         dfm_util_
                         000366 nbcwp                       dfm_util_
                         000370 nwds                        dfm_util_
                         000371 obj_card_found              dfm_util_
                         000372 ocardp                      dfm_util_
                         000374 patch_key                   dfm_util_
                         000403 pbuf_size                   dfm_util_
                         000404 psz                         dfm_util_
                         000405 px                          dfm_util_
                         000406 rec_len                     dfm_util_
                         000407 rtrycnt                     dfm_util_
                         000410 scode                       dfm_util_
                         000412 segp                        dfm_util_
                         000414 svp                         dfm_util_
                         000416 t_stat                      dfm_util_
                         000417 term                        dfm_util_
                         000420 type                        dfm_util_
                         000421 user_access                 dfm_util_
                         000422 v_patch                     dfm_util_
                         000423 yes_sw                      dfm_util_
                         000424 rsi                         dfm_util_
                         000442 rec_length                  dfm_util_
                         000443 mca_buf_size                dfm_util_
                         000444 current_ptr                 dfm_util_
                         000446 ret_len                     dfm_util_
                         000450 gk_info_ptr                 dfm_util_
                         000452 dfm_datap                   dfm_util_
                         000454 ascii_cardp                 dfm_util_
                         000456 gload_data                  dfm_util_
                         001343 TYPE                        dfm_util_
                         001407 data_size_1                 dfm_util_
                         001410 data_size_2                 dfm_util_
                         001411 opr_query_info              dfm_util_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     alloc_bit_temp      cat_realloc_chars
call_ext_in_desc    call_ext_in         call_ext_out_desc   call_ext_out        return_mac          mpfx2
signal_op           shorten_stack       ext_entry           ext_entry_desc      trunc_fx2           set_chars_eis
index_chars_eis     any_to_any_truncate_divide_fx1          op_alloc_           op_freen_           index_before_cs
index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              bcd_to_ascii_                 command_query_$yes_no         dfm_$complain
get_system_free_area_         gload_                        gload_$allow_zero_checksums   hcs_$get_link_target
hcs_$get_user_effmode         hcs_$initiate                 hcs_$make_seg                 hcs_$set_bc_seg
hcs_$status_minf              ioa_                          ioa_$ioa_switch               ioa_$rs
iox_$attach_name              iox_$close                    iox_$control                  iox_$delete_record
iox_$detach_iocb              iox_$open                     iox_$position                 iox_$put_chars
iox_$read_record              iox_$rewrite_record           iox_$seek_key                 iox_$write_record
mca_$attach_mca               mca_$detach_mca               mca_$diskette_read            mca_$read_data
opr_query_                    tolts_alm_util_$ascii_to_bcd_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$fatal_error      error_table_$no_file          error_table_$no_record
error_table_$noentry          error_table_$tape_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   1379 002521   10   39 002523   11   17 002665        38 002671        40 002702       331 002711       334 002727
    336 002733       337 002735       338 002742       341 002756       343 002764       346 002777       347 003003
    349 003020       350 003022       352 003035       353 003036       356 003051       357 003055       358 003067
    359 003070       360 003103       361 003111       362 003124       363 003132       364 003140       366 003146
    370 003203       371 003206       373 003221       374 003247       378 003250       385 003263       388 003276
    390 003302       391 003334       393 003337       402 003346       405 003367       407 003373       409 003374
    410 003421       411 003423       412 003424       415 003433       416 003445       417 003447       418 003450
    421 003457       422 003460       423 003475       424 003500       425 003534       426 003562       428 003621
    429 003641       432 003700       436 004007       437 004034       438 004046       439 004051       445 004060
    449 004074       451 004100       452 004111       453 004123       456 004126       462 004135       465 004157
    467 004163       468 004200       469 004202       470 004204       472 004207       473 004234       474 004236
    475 004237       477 004246       478 004251       479 004253       480 004310       481 004312       482 004313
    484 004322       485 004326       486 004331       488 004333       489 004336       490 004340       491 004343
    492 004345       494 004346       495 004347       500 004423       501 004426       503 004427       505 004434
    506 004442       508 004445       509 004451       510 004475       511 004477       512 004502       515 004503
    516 004512       517 004514       518 004522       521 004523       522 004550       523 004552       524 004562
    525 004570       526 004573       527 004575       530 004577       534 004655       535 004660       536 004665
    537 004673       538 004676       539 004700       542 004701       543 004707       548 004710       549 004715
    550 004740       551 004742       552 004744       553 004754       554 004762       555 004765       557 004767
    558 005001       560 005014       561 005023       562 005032       563 005053       566 005111       567 005124
    568 005127       569 005132       570 005137       571 005142       572 005143       573 005152       574 005160
    575 005163       576 005170       577 005175       578 005177       579 005220       582 005265       583 005300
    584 005303       585 005306       586 005313       588 005316       589 005320       590 005326       591 005343
    592 005356       593 005361       594 005364       595 005371       596 005374       597 005375       598 005411
    599 005414       600 005417       601 005424       602 005432       603 005433       604 005435       606 005461
    609 005501       610 005502       611 005537       612 005555       613 005560       614 005614       615 005663
    617 005744       618 005765       620 006045       624 006166       626 006213       627 006225       628 006230
    630 006234       633 006236       635 006237       642 006304       643 006306       644 006310       645 006311
    648 006357       649 006364       650 006372       651 006373       652 006375       653 006403       654 006411
    655 006412       657 006413       665 006422       670 006451       672 006455       673 006457       674 006460
    675 006462       677 006463       678 006466       679 006525       680 006527       683 006574       684 006625
    687 006703       688 006706       689 006711       691 006722       693 006723       699 006735       701 006736
    702 006741       706 007037       709 007115       711 007120       712 007123       714 007124       715 007126
    718 007161       719 007163       723 007233       724 007264       727 007342       728 007345       729 007350
    735 007361       737 007362       739 007421       742 007477       745 007505       746 007506       747 007511
    749 007512       751 007527       754 007573       757 007651       759 007654       760 007657       762 007660
    768 007717       770 007720       775 010031       778 010150       785 010160       791 010202       793 010206
    794 010207       795 010214       796 010216       797 010221       798 010223       799 010227       800 010231
    801 010233       802 010235       803 010250       804 010254       805 010302       806 010304       807 010305
    809 010314       811 010332       812 010334       813 010335       815 010344       816 010351       817 010353
    818 010356       819 010360       820 010362       821 010371       822 010376       823 010424       824 010426
    825 010427       827 010436       828 010451       829 010453       830 010457       831 010461       832 010462
    833 010464       834 010512       836 010513       844 010522       850 010545       852 010551       853 010576
    854 010600       855 010603       856 010623       857 010624       859 010625       860 010626       861 010646
    862 010653       864 010655       871 010664       878 010706       880 010712       882 010726       883 010753
    884 010757       885 010761       886 010776       889 011047       891 011056       895 011125       896 011143
    901 011214       907 011223       909 011235       910 011241       911 011243       913 011244       914 011247
    915 011250       917 011347       919 011351       920 011354       921 011363       922 011420       924 011440
    925 011441       927 011451       930 011452       931 011505       932 011516       933 011517       936 011527
    939 011536       940 011542       942 011565       943 011570       944 011634       945 011701       946 011747
    949 011751       951 011770       953 012007       954 012030       957 012040       958 012050       959 012051
    962 012061       969 012070       974 012104       976 012110       977 012121       978 012150       980 012207
    981 012212       989 012221       992 012233       994 012237       995 012250       996 012261       998 012317
   1000 012321      1008 012330      1011 012344      1013 012350      1014 012353      1015 012355      1016 012372
   1018 012375      1019 012403      1020 012413      1021 012437      1022 012443      1023 012451      1024 012472
   1026 012531      1027 012541      1029 012620      1031 012665      1032 012706      1035 012752      1038 013005
   1040 013036      1041 013064      1043 013122      1044 013143      1046 013201      1047 013221      1048 013256
   1051 013362      1053 013364      1056 013466      1059 013556      1061 013557      1063 013610      1064 013612
   1066 013637      1067 013641      1068 013653      1070 013656      1077 013665      1082 013704      1084 013710
   1085 013713      1086 013716      1088 013721      1089 013722      1090 013731      1091 013733      1093 013773
   1094 013775      1095 014005      1096 014007      1097 014010      1099 014045      1102 014060      1105 014062
   1106 014064      1107 014110      1108 014112      1109 014115      1111 014144      1112 014151      1113 014172
   1116 014205      1117 014216      1118 014223      1119 014237      1125 014240      1132 014253      1135 014273
   1137 014277      1138 014331      1140 014372      1141 014412      1143 014457      1149 014466      1152 014507
   1154 014513      1156 014527      1157 014545      1159 014602      1160 014623      1163 014661      1164 014663
   1165 014664      1166 014701      1167 014716      1169 014734      1170 014745      1171 014752      1172 015027
   1175 015074      1176 015114      1179 015146      1180 015163      1181 015172      1182 015176      1183 015177
   1184 015201      1186 015255      1188 015256      1189 015277      1191 015300      1192 015326      1193 015356
   1198 015422      1199 015425      1200 015445      1203 015447      1204 015450      1208 015502      1209 015503
   1210 015504      1213 015565      1214 015573      1215 015630      1219 015674      1220 015676      1222 015716
   1223 015720      1224 015732      1225 015735      1226 015747      1228 015752      1234 015761      1240 015775
   1242 016001      1243 016003      1244 016016      1245 016021      1246 016023      1250 016030      1251 016032
   1253 016035      1254 016040      1255 016041      1257 016061      1258 016063      1260 016070      1261 016072
   1262 016074      1264 016077      1265 016126      1266 016161      1268 016162      1269 016163      1270 016166
   1272 016220      1276 016264      1277 016321      1279 016322      1283 016362      1284 016367      1285 016371
   1286 016372      1289 016401      1292 016415      1293 016420      1295 016427      1296 016431      1297 016434
   1298 016436      1300 016437      1301 016440      1307 016514      1308 016517      1310 016520      1311 016524
   1312 016532      1313 016535      1314 016541      1315 016565      1316 016567      1317 016572      1320 016601
   1322 016611      1324 016620      1328 016654      1329 016657      1330 016672      1331 016732      1333 016733
   1335 016734      1336 016743      1337 016745      1339 016753      1341 016754      1343 016764      1348 017055
   1349 017056      1354 017123      1355 017125      1356 017127      1357 017130      1361 017176      1362 017177
   1363 017204      1364 017212      1365 017213      1366 017215      1367 017223      1368 017224      1370 017231
   1376 017240      1387 017267      1389 017273      1390 017275      1391 017276      1392 017301      1394 017345
   1396 017347      1397 017353      1398 017356      1399 017360      1401 017415      1403 017424      1404 017437
   1405 017442      1406 017450      1407 017471      1410 017472      1416 017501      1422 017515      1423 017521
   1424 017523      1425 017526      1426 017530      1427 017532      1429 017537      1430 017542      1431 017545
   1432 017547      1433 017550      1434 017553      1435 017556      1436 017566      1439 017567      1440 017573
   1441 017575      1442 017602      1444 017620      1445 017622      1446 017640      1447 017645      1450 017646
   1451 017657      1452 017664      1453 017671      1454 017676      1455 017700      1456 017712      1458 017720
   1459 017726      1460 017734      1461 017742      1463 017755      1465 017760      1468 020017      1469 020030
   1470 020040      1472 020044      1473 020061      1474 020066      1477 020070      1478 020073      1479 020110
   1481 020113      1482 020116      1484 020133      1486 020152      1487 020160      1490 020242      1493 020243
   1501 020444      1503 020501      1505 020515      1506 020516      1510 020526      1511 020544      1512 020556
   1513 020561      1515 020565      1519 020576      1525 020605      1531 020623      1533 020627      1535 020663
   1541 020676      1547 020714      1548 020753      1551 021017      1553 021030      1562 021035      1567 021046
   1568 021066      1569 021071      1571 021072      1577 021126      1580 021146      1581 021150      1583 021152
   1586 021161      1596 021167      1600 021171      1602 021232      1603 021276      1604 021302      1605 021342
   1609 021412      1612 021472      1613 021515      1617 021564      1618 021606      1621 021651      1627 021652
   1630 021653      1631 021654      1632 021664      1633 021666      1635 021670      1636 021675      1637 021701
   1638 021703      1639 021707      1641 021710      1643 021712      1644 021725      1645 021736      1646 021740
   1647 021745      1651 021766      1652 021771      1653 021772      1655 021776      1657 021777      1658 022005
   1662 022022      1666 022023      1668 022024      1669 022033      1671 022040      1673 022042      1674 022044
   1675 022062      1677 022064      1685 022065      1687 022066      1688 022076      1690 022150      1694 022212
   1695 022227      1697 022246      1699 022252      1702 022302      1705 022346      1707 022374      1709 022422
   1712 022423      1715 022476      1719 022607      1724 022725      1729 023043      1730 023057      1731 023213
   1733 023252      1734 023263      1735 023264      1737 023274      1739 023276      1740 023310      1741 023313
   1743 023315      1749 023316      1752 023317      1753 023334      1754 023337      1755 023363      1757 023430
   1758 023441      1759 023477      1761 023501      1762 023534      1763 023535      1764 023545      1765 023556
   1766 023561      1767 023606      1768 023607      1769 023616      1772 023671      1773 023675      1774 023752
   1775 024060      1776 024061      1778 024063      1779 024075      1780 024100      1782 024102      1789 024103
   1791 024104      1793 024107      1794 024115      1795 024124      1797 024126      1798 024131      1800 024176
   1803 024230      1804 024241      1805 024260      1807 024262      1808 024272      1810 024274      1812 024315
   1813 024327      1814 024426      1816 024431      1817 024457      1820 024520      1821 024532      1824 024573
   1825 024605      1826 024652      1829 024654      1836 024655      1838 024656      1839 024711      1841 024747
   1842 024751      1843 024752      1845 024754      1851 024755      1853 024756      1854 024762      1856 024764
   1857 024776      1859 025010      1860 025036      1865 025074      1867 025077      1868 025115      1869 025116
   1871 025141      1874 025146      1876 025147      1877 025152      1878 025204      1880 025240      1881 025243
   1884 025244      1885 025300      1886 025331      1888 025332      1891 025333      1892 025371      1893 025374
   1894 025375      1895 025403      1896 025404      1898 025405


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
