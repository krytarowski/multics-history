	COMPILATION LISTING OF SEGMENT get_spooling_data_
	Compiled by: Multics PL/I Compiler, Release 32e, of September 22, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 10/03/89  0953.9 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(89-06-15,Brunelle), approve(89-09-18,MCR8129),
       17*     audit(89-09-29,Beattie), install(89-10-03,MR12.3-1083):
       18*     Change parse_command_ call, which was replaced in MR12.2, with
       19*     iodd_parse_$command.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 get_spooling_data_: proc;
       24 
       25 	return;
       26 
       27 /* GET_SPOOLING_DATA_ -- the operator interface for the Multics Spooling IO Module.
       28*   This routine reads from "user_input" and parses for: tape volume-ids,
       29*   optional density, optional spooling line-length, and optional spooling limits  (lines and files).
       30*   There is an entry point for updating the spooling volume list and
       31*   an entry point for updating the spooling limits.
       32*
       33*   0)  Created 10/74 by Janice B. Phillipps as part of the Multics Spooling DIM.
       34*   1)  Updated 7/75 by J.Phillipps for new printer dim.
       35*   2)  Updated 10/75 by J.Phillipps to add optional density specification.
       36*   3)  Re-written 1/31/78 by J. C. Whitmore while adding new printer features to spooldim.
       37**/
       38 
  1     1 /* BEGIN INCLUDE FILE ... spooling_info.incl.pl1 */
  1     2 /* Spooling IO Module control structure. Created 11/4/74 by Janice Phillipps */
  1     3 /* Modified 1/25/78 by J. C. Whitmore during spool driver update */
  1     4 
  1     5 dcl  sip ptr;					/* pointer to spooling info structure */
  1     6 
  1     7 dcl 1 spooling_info based (sip) aligned,		/* spooling info structure */
  1     8     2 version fixed bin,				/* version of structure  */
  1     9     2 pad1 fixed bin,				/* space broken for ptr allocation */
  1    10     2 iocbp ptr,					/* ptr to io control block used by tape_ansi_ */
  1    11     2 switch_name char (32),				/* name of io switch attached to tape_ansi_ */
  1    12     2 nvols fixed bin,				/* number of tape volumes requested */
  1    13     2 density char (4),
  1    14     2 block_lnth char (4),
  1    15     2 volids (3) char (6),				/* array of tape volume ids */
  1    16     2 filesetid char (6),				/* name of current ansi file set */
  1    17     2 comment char (64),				/* comment to operator at mount */
  1    18     2 phys_line_length fixed bin,
  1    19     2 phys_page_length fixed bin,
  1    20     2 filenumber fixed bin,				/* number of current file on tape */
  1    21     2 static_number char (6) aligned,
  1    22     2 flgs,
  1    23       3 fst_call bit (1) unaligned,			/* indicates first time thru attach code */
  1    24       3 lst_call bit (1) unaligned,			/* indicates spooling tape will be detached */
  1    25       3 io_sw bit (1) unaligned,			/* = "1"b if ring in tape */
  1    26       3 vol_mount bit (1) unaligned,
  1    27       3 pad1 bit (32) unaligned,
  1    28     2 spooling_limits,
  1    29       3 spool_file_limit_sw fixed bin,			/* = 1 when reached specified spooling file limit */
  1    30       3 spool_line_limit_sw fixed bin,			/* = 1 when reached specifid spooling line limit */
  1    31       3 file_limit fixed bin (35),			/* count of files to spool until */
  1    32       3 line_limit fixed bin (35),			/* count of lines to spool until */
  1    33     2 spooling_file_count fixed bin (35),		/* count of files spooled so far */
  1    34     2 spooling_line_count fixed bin (35);		/* count of lines spooled so far */
  1    35 
  1    36 dcl  spooling_info_version_4 fixed bin int static init (4) options (constant);
  1    37 
  1    38 
  1    39 /* END INCLUDE FILE ... spooling_info.incl.pl1  */
       39 
       40 dcl (addr, length, substr, convert, rtrim, string, translate) builtin;
       41 dcl  conversion condition;
       42 
       43 dcl  a_sip ptr,
       44      arg_no fixed bin,
       45      code fixed bin (35),
       46      comment char (64),
       47      density char (4) aligned,
       48      ec fixed bin (35),
       49      file_limit fixed bin (21),
       50      i fixed bin,
       51      init_flg bit (1) aligned,
       52      input_line char (120) aligned,
       53      input_lnth fixed bin,				/* length of input line (nelemt) */
       54      key fixed bin,
       55      line_limit fixed bin (21),
       56      number fixed bin,
       57      nxt_vol_flg bit (1) aligned,
       58      op_msg char (80),
       59      opt char (*),
       60      renew_flg bit (1) aligned,
       61      temp_arg char (64),
       62      try_again bit (1) aligned;
       63 
       64 dcl 1 arg_list aligned,
       65     2 max_args fixed bin init (20),			/* don't expect more than 20 tokens per line */
       66     2 nargs fixed bin,
       67     2 arg (20) char (64) var;				/* array of tokens from input line */
       68 
       69 dcl 1 flags unaligned,				/* control flags */
       70    (2 error_flag,
       71     2 vol_flag,
       72     2 files_flag,
       73     2 lines_flag,
       74     2 den_flag,
       75     2 int_flag,
       76     2 comm_flag) bit (1) unal;
       77 
       78 dcl  vol_id (3) char (8) var;
       79 dcl  n_vols fixed bin;
       80 
       81 dcl  error_table_$device_end fixed bin (35) ext static;
       82 dcl  error_table_$noarg fixed bin (35) ext static;
       83 dcl  error_table_$fatal_error fixed bin (35) ext static;
       84 
       85 dcl  ioa_ entry options (variable);
       86 dcl  iodd_parse_$command entry (char(*), ptr, fixed bin(35));
       87 dcl  iox_$get_line entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
       88 dcl  iox_$user_input ext ptr;
       89 
       90 
       91 initial:	entry (a_sip, opt, code);
       92 
       93 	sip = a_sip;
       94 	opt = "";
       95 
       96 	call init (code);				/* set things up */
       97 	if code ^= 0 then return;			/* wrong info version */
       98 
       99 	spooling_info.line_limit = 0;
      100 	spooling_info.file_limit = 0;
      101 	spooling_info.density = "";
      102 	spooling_info.block_lnth = "";
      103 	spooling_info.spool_file_limit_sw = 0;
      104 	spooling_info.spool_line_limit_sw = 0;
      105 	spooling_info.nvols = 0;
      106 	spooling_info.volids (*) = "";		/* initialize the volume list */
      107 
      108 	init_flg = "1"b;				/* initial entry flag */
      109 	nxt_vol_flg = "0"b;				/* next volume entry flag */
      110 	renew_flg = "0"b;				/* renew limits entry flag */
      111 
      112 	if spooling_info.flgs.io_sw then
      113 	     op_msg = "Enter volids and optional tape data or limits:";
      114 	else op_msg = "Enter volid and optional limits:";
      115 join:
      116 	call ioa_ (op_msg);
      117 
      118 read:	input_line = "";				/* clear any junk */
      119 
      120 	call iox_$get_line (iox_$user_input, addr (input_line), 120, input_lnth, ec); /* read operator's input  */
      121 
      122 	call iodd_parse_$command (substr (input_line, 1, input_lnth), addr (arg_list), ec);
      123 	if ec ^= 0 then do;
      124 	     if ec = error_table_$noarg then go to read;	/* null line */
      125 	     call report ("Error in  command line.");
      126 	     go to join;
      127 	end;
      128 
      129 	if arg (1) = "detach" then do;
      130 	     if nargs ^= 1 then do;
      131 		call report ("Invalid detach command.");
      132 		go to join;
      133 	     end;
      134 	     opt = "det";				/* tell caller to detach tape */
      135 	     code = error_table_$device_end;		/* all done */
      136 	     return;
      137 	end;
      138 
      139 	if arg (1) = "help" then do;			/* operator is confused */
      140 	     call ioa_ ("Options:  -vol <tape_numbers (3)> -fl <limit> -ln <limit> -den <density> -int or ""detach""");
      141 	     go to join;
      142 	end;
      143 
      144 	on conversion begin;
      145 	     call report ("Argument conversion error.");
      146 	     error_flag = "1"b;
      147 	     go to next_key;
      148 	end;
      149 
      150 	key = 1;					/* next key to process is the first one */
      151 
      152 next_key:
      153 
      154 	if key > nargs then go to finish;		/* go see what happened */
      155 
      156 	if arg (key) = "-volid" | arg (key) = "-vol" then go to volume_key;
      157 	if arg (key) = "-files" | arg (key) = "-fl" then go to files_key;
      158 	if arg (key) = "-lines" | arg (key) = "-ln" then go to lines_key;
      159 	if arg (key) = "-density" | arg (key) = "-den" then go to density_key;
      160 	if arg (key) = "-interchange" | arg (key) = "-int" then go to interchange_key;
      161 	if arg (key) = "-comment" | arg (key) = "-com" then go to comment_key;
      162 
      163 	error_flag = "1"b;				/* be sure to verify final values */
      164 	call ioa_ ("*** Unrecognized keyword: ^a^/Keyword ignored.", arg (key));
      165 
      166 	do key = key + 1 to nargs;
      167 	     if substr (arg (key), 1, 1) = "-" then go to next_key;
      168 	end;
      169 
      170 	go to finish;				/* no more keywords */
      171 
      172 
      173 volume_key:
      174 
      175 	number = 0;				/* init the arg count */
      176 	arg_no = key + 1;				/* the first arg for this key */
      177 
      178 	do key = key + 1 to nargs while (substr (arg (key), 1, 1) ^= "-"); /* find all values */
      179 	     number = number + 1;			/* increment the arg counter */
      180 	end;
      181 
      182 	if renew_flg then do;			/* just want limits */
      183 	     call report ("The -volid keyword is invalid when looking for limits.");
      184 	     go to next_key;
      185 	end;
      186 
      187 	if number = 0 then do;			/* we must have at least one volume name */
      188 	     error_flag = "1"b;			/* give the summary */
      189 	     call report ("Volume id has been omitted.");
      190 	     go to next_key;
      191 	end;
      192 
      193 	if number > 3 then do;			/* too many volume names */
      194 	     call report ("Only 3 volume ids can be entered.");
      195 	     error_flag = "1"b;
      196 	     go to next_key;
      197 	end;
      198 
      199 	do i = arg_no to key -1;			/* check out each volid given as args */
      200 	     if length (arg (i)) ^= 6 then do;
      201 		call report ("Bad volume id: " || arg (i) || " Each must have six characters.");
      202 		error_flag = "1"b;
      203 		go to next_key;
      204 	     end;
      205 	end;
      206 	vol_id (*) = "";				/* clear the old values */
      207 	n_vols = 0;				/* clear the vol counter */
      208 
      209 	do i = arg_no to key - 1;			/* pick up the new vol ids */
      210 	     n_vols = n_vols + 1;			/* increment the count (index) */
      211 	     vol_id (n_vols) = arg (i);		/* copy the volid */
      212 	end;
      213 
      214 	vol_flag = "1"b;				/* got some good volume ids */
      215 	go to next_key;
      216 
      217 files_key:					/* set file count for spooling limits */
      218 
      219 	number = 0;				/* check the number of values for this key */
      220 
      221 	do key = key + 1 to nargs while (substr (arg (key), 1, 1) ^= "-");
      222 	     number = number + 1;			/* count the limits given */
      223 	     temp_arg = arg (key);			/* save the limit value */
      224 	end;
      225 
      226 	if number = 0 then do;			/* must have some limit given */
      227 	     call report ("Unspecified file limit count.");
      228 	     error_flag = "1"b;
      229 	     go to next_key;
      230 	end;
      231 
      232 	if number > 1 then do;			/* we can only use one limit value, which? */
      233 	     call report ("Only one file limit can be accepted.");
      234 	     error_flag = "1"b;
      235 	     go to next_key;
      236 	end;
      237 
      238 	if temp_arg = "reset" then do;
      239 	     file_limit = -1;			/* in case he wants to change his mind */
      240 	end;
      241 	else do;
      242 	     file_limit = convert (file_limit, temp_arg);
      243 	     if file_limit < 0 | file_limit > 999999 then do;
      244 		error_flag = "1"b;
      245 		call report ("Bad file limit.");
      246 		go to next_key;
      247 	     end;
      248 	end;
      249 	files_flag = "1"b;				/* report a change if needed */
      250 	go to next_key;
      251 
      252 lines_key:					/* set line count for spooling limits */
      253 
      254 	number = 0;				/* check the number of values for this key */
      255 
      256 	do key = key + 1 to nargs while (substr (arg (key), 1, 1) ^= "-");
      257 	     number = number + 1;			/* count the limits given */
      258 	     temp_arg = arg (key);			/* save the limit value */
      259 	end;
      260 
      261 	if number = 0 then do;			/* must have some limit given */
      262 	     call report ("Unspecified line limit count.");
      263 	     error_flag = "1"b;
      264 	     go to next_key;
      265 	end;
      266 
      267 	if number > 1 then do;			/* we can only use one limit value, which? */
      268 	     call report ("Only one line limit can be accepted.");
      269 	     error_flag = "1"b;
      270 	     go to next_key;
      271 	end;
      272 
      273 	if temp_arg = "reset" then do;
      274 	     line_limit = -1;			/* in case he wants to change his mind */
      275 	end;
      276 	else do;
      277 	     line_limit = convert (line_limit, temp_arg);
      278 	     if line_limit < 0 | line_limit > 999999 then do;
      279 		error_flag = "1"b;
      280 		call report ("Bad line limit.");
      281 		go to next_key;
      282 	     end;
      283 	end;
      284 	lines_flag = "1"b;				/* report a change if needed */
      285 	go to next_key;
      286 
      287 density_key:					/* set density */
      288 
      289 	number = 0;				/* check the number of values for this key */
      290 
      291 	do key = key + 1 to nargs while (substr (arg (key), 1, 1) ^= "-");
      292 	     number = number + 1;			/* count the values given */
      293 	     temp_arg = arg (key);			/* save the value */
      294 	end;
      295 
      296 	if spooling_info.io_sw = "0"b then do;		/* not for reading */
      297 not_input:     call report ("The -density and -interchange keywords are not allowed on input.");
      298 	     go to next_key;
      299 	end;
      300 	if spooling_info.density ^= "" | spooling_info.vol_mount then do;
      301 	     call report ("Cannot change density once file set is attached");
      302 	     go to next_key;
      303 	end;
      304 	if number = 0 then do;
      305 	     call report ("Unspecified recording density.");
      306 	     error_flag = "1"b;			/* a real goof */
      307 	     go to next_key;
      308 	end;
      309 	if number > 1 then do;
      310 	     call report ("Only one density setting may be accepted.");
      311 	     error_flag = "1"b;
      312 	     go to next_key;
      313 	end;
      314 	if ^(temp_arg = "800" | temp_arg = "1600") then do; /* must be a legal value */
      315 	     call report ("Density must be either 800 or 1600 .");
      316 	     error_flag = "1"b;
      317 	     go to next_key;
      318 	end;
      319 	density = substr (temp_arg, 1, length (density)); /* save the new value */
      320 	den_flag = "1"b;				/* mark density as set  */
      321 	int_flag = "0"b;				/* cancel interchange if set */
      322 	go to next_key;
      323 
      324 interchange_key:					/* set interchange density and block size */
      325 
      326 	number = 0;				/* check the number of values for this key */
      327 
      328 	do key = key + 1 to nargs while (substr (arg (key), 1, 1) ^= "-");
      329 	     number = number + 1;			/* count the values given */
      330 	end;
      331 
      332 	if spooling_info.io_sw = "0"b then go to not_input; /* illegal */
      333 
      334 	if spooling_info.density ^= "" | spooling_info.vol_mount then do;
      335 	     call report ("Interchange cannot be specified after volume is attached.");
      336 	     go to next_key;
      337 	end;
      338 	if number ^= 0 then do;
      339 	     call report ("Interchange keyword does not allow arguemnts.");
      340 	     error_flag = "1"b;
      341 	     go to next_key;
      342 	end;
      343 	int_flag = "1"b;				/* mark interchange as set */
      344 	density = "800";				/* force the interchange value */
      345 	den_flag = "0"b;				/* reset  value from density key */
      346 	go to next_key;
      347 
      348 comment_key:
      349 
      350 	number = 0;				/* check the number of values for this key */
      351 
      352 	do key = key + 1 to nargs while (substr (arg (key), 1, 1) ^= "-");
      353 	     number = number + 1;			/* count the limits given */
      354 	     temp_arg = arg (key);			/* save the comment */
      355 	end;
      356 
      357 	if number = 0 then do;
      358 	     call report ("Comment field is missing.");
      359 	     error_flag = "1"b;
      360 	     go to next_key;
      361 	end;
      362 
      363 	if number > 1 then do;
      364 	     call report ("Multiple comments found.  Use quotes if comment includes spaces.");
      365 	     error_flag = "1"b;
      366 	     go to next_key;
      367 	end;
      368 
      369 	comment = translate (rtrim (temp_arg), "_", " 	"); /* make all spaces underscore */
      370 	comm_flag = "1"b;
      371 	go to next_key;
      372 
      373 
      374 
      375 finish:						/* now we see what was set, and maybe return to the caller */
      376 
      377 	try_again = "0"b;				/* see if there was an error in lack of data */
      378 
      379 	if (nxt_vol_flg | init_flg) & ^vol_flag then do;
      380 	     call report ("No volume id given.");
      381 	     try_again = "1"b;
      382 	end;
      383 
      384 	if spooling_info.spool_file_limit_sw = 1 & ^files_flag then do; /* do we need a new file limit? */
      385 	     call report ("A new file limit must be given.");
      386 	     try_again = "1"b;
      387 	end;
      388 
      389 	if spooling_info.spool_line_limit_sw = 1 & ^lines_flag then do; /* do we need a new line limit? */
      390 	     call report ("A new line limit must be given.");
      391 	     try_again = "1"b;
      392 	end;
      393 
      394 	if ^(lines_flag | files_flag) then
      395 	     if init_flg & ^(error_flag | try_again) then do; /* tell op no limits */
      396 		call ioa_ ("No file or line limits have been set.");
      397 		go to ask;			/* make him verify */
      398 	     end;
      399 
      400 	if try_again then go to join;			/* did we pass the tests? */
      401 
      402 	if error_flag then do;			/* if any error occured, show the values we will use */
      403 
      404 	     if vol_flag then
      405 		call ioa_ ("Volume ids: ^a ^a ^a", vol_id (1), vol_id (2), vol_id (3));
      406 
      407 	     if files_flag then
      408 		if file_limit = -1 then call ioa_ ("File limit will be reset.");
      409 		else call ioa_ ("File limit ^d will be added to current limit of ^d",
      410 		     file_limit, spooling_info.file_limit);
      411 
      412 	     if lines_flag then
      413 		if line_limit = -1 then call ioa_ ("Line limit will be reset.");
      414 		else call ioa_ ("Line limit ^d will be added to current limit of ^d",
      415 		     line_limit, spooling_info.line_limit);
      416 
      417 	     if den_flag then
      418 		call ioa_ ("Density: ^a", density);
      419 
      420 	     if int_flag then
      421 		call ioa_ ("Interchange:  density = 800,  block size = 2048");
      422 
      423 	     if comm_flag then
      424 		call ioa_ ("Comment: ^a", comment);
      425 
      426 	     if init_flg & ^(lines_flag | files_flag) then
      427 		call ioa_ ("No file or line limits have been set.");
      428 
      429 ask:	     call ioa_ ("Are these parameters correct?");
      430 
      431 	     input_line = "";
      432 	     call iox_$get_line (iox_$user_input, addr (input_line), 120, input_lnth, ec);
      433 	     input_line = substr (input_line, 1, input_lnth -1); /* drop the new_line char */
      434 	     if input_line = "no" then go to join;
      435 	     if input_line ^= "yes" then do;
      436 		call ioa_ ("Please answer yes or no.");
      437 		go to ask;
      438 	     end;
      439 	end;
      440 
      441 
      442 /*	All OK  -  use the values for real now */
      443 
      444 	if vol_flag then do;
      445 	     do i = 1 to 3;
      446 		spooling_info.volids (i) = vol_id (i);
      447 	     end;
      448 	     spooling_info.nvols = n_vols;
      449 	end;
      450 
      451 	if lines_flag then do;
      452 	     if line_limit = -1 then spooling_info.line_limit = 0;
      453 	     else spooling_info.line_limit = spooling_info.line_limit + line_limit;
      454 	     spooling_info.spool_line_limit_sw = 0;
      455 	end;
      456 
      457 	if files_flag then do;
      458 	     if file_limit = -1 then spooling_info.file_limit = 0;
      459 	     else spooling_info.file_limit = spooling_info.file_limit + file_limit;
      460 	     spooling_info.spool_file_limit_sw = 0;
      461 	end;
      462 
      463 	if den_flag then do;			/* sets density and block size */
      464 	     spooling_info.density = density;
      465 	     spooling_info.block_lnth = "8192";
      466 	end;
      467 
      468 	if int_flag then do;
      469 	     spooling_info.density = "800";
      470 	     spooling_info.block_lnth = "2048";
      471 	end;
      472 
      473 	if comm_flag then spooling_info.comment = comment;
      474 
      475 	if spooling_info.block_lnth = "" then
      476 	     spooling_info.block_lnth = "8192";		/* default is biggest possible */
      477 
      478 	if spooling_info.density = "" then
      479 	     spooling_info.density = "1600";		/* default density  */
      480 
      481 	return;
      482 
      483 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      484 report:	proc (message);
      485 
      486 dcl  message char (*);
      487 
      488 	     call ioa_ ("*** ^a", message);		/* simple format for now */
      489 	     return;
      490 
      491 	end report;
      492 
      493 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      494 init:	proc (ec);
      495 
      496 dcl  ec fixed bin (35);
      497 
      498 	     if spooling_info.version ^= spooling_info_version_4 then do; /* right structure? */
      499 		ec = error_table_$fatal_error;
      500 		call report ("Fatal_error. Incorrect version of info structure.");
      501 		return;
      502 	     end;
      503 	     ec = 0;				/* all well otherwise */
      504 	     file_limit = 0;
      505 	     line_limit = 0;
      506 	     density = "1600";
      507 	     n_vols = 0;
      508 	     vol_id (*) = "";
      509 	     comment = "";
      510 	     string (flags) = ""b;
      511 
      512 	     return;
      513 
      514 	end init;
      515 
      516 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      517 next_volume: entry (a_sip, opt, code);			/* entry to get next volume id to spool onto */
      518 
      519 	sip = a_sip;
      520 	opt = "";
      521 
      522 	call init (code);
      523 	if code ^= 0 then return;
      524 
      525 	spooling_info.volids (*) = "";
      526 	nxt_vol_flg = "1"b;				/* make sure get volid or detach */
      527 	renew_flg = "0"b;				/* wont reset spooling limits */
      528 	init_flg = "0"b;				/* initial entry flag turned off */
      529 
      530 	call ioa_ ("End of spooling volume list;");
      531 
      532 	op_msg = "Enter more volids or ""detach"":";
      533 
      534 	go to join;
      535 
      536 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - */
      537 renew_limits: entry (a_sip, opt, code);
      538 
      539 	sip = a_sip;
      540 	opt = "";
      541 
      542 	call init (code);
      543 	if code ^= 0 then return;
      544 
      545 	nxt_vol_flg = "0"b;				/* wont change volume list */
      546 	renew_flg = "1"b;				/* will renew limits */
      547 	init_flg = "0"b;				/* initial entry flag turned off */
      548 
      549 	call ioa_ ("^/Reached specified spooling limits;");
      550 
      551 	call ioa_ ("^/^-Current file limit is ^d ^/^-Current line limit is ^d",
      552 	     spooling_info.file_limit, spooling_info.line_limit);
      553 
      554 	call ioa_ ("^/^-Current file count is ^d ^/^-Current line count is ^d^/",
      555 	     spooling_info.spooling_file_count, spooling_info.spooling_line_count);
      556 
      557 	op_msg = "Enter new file and/or line limits, or ""detach"":";
      558 
      559 	go to join;
      560 
      561      end get_spooling_data_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/89  0953.9  get_spooling_data_.pl1            >spec>install>1083>get_spooling_data_.pl1
39           1    02/23/78  1619.8  spooling_info.incl.pl1            >ldd>include>spooling_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_sip                                  parameter       pointer                  dcl 43 ref 91 93 517 519 537 539
addr                                                   builtin function         dcl 40 ref 120 120 122 122 432 432
arg                       2     000247 automatic       varying char(64)         array level 2 dcl 64 set ref 129 139 156 156 157 157
                                                                                  158 158 159 159 160 160 161 161 164* 167 178 200
                                                                                  201 211 221 223 256 258 291 293 328 352 354
arg_list                        000247 automatic       structure                level 1 dcl 64 set ref 122 122
arg_no                          000110 automatic       fixed bin(17,0)          dcl 43 set ref 176* 199 209
block_lnth               16            based           char(4)                  level 2 dcl 1-7 set ref 102* 465* 470* 475 475*
code                                   parameter       fixed bin(35,0)          dcl 43 set ref 91 96* 97 135* 517 522* 523 537 542*
                                                                                  543
comm_flag                 0(06) 000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 370*
                                                                                  423 473
comment                         000111 automatic       char(64)                 packed unaligned dcl 43 in procedure
                                                                                  "get_spooling_data_" set ref 369* 423* 473 509*
comment                  27            based           char(64)                 level 2 in structure "spooling_info" dcl 1-7
                                                                                  in procedure "get_spooling_data_" set ref 473*
conversion                      000102 stack reference condition                dcl 41 ref 144
convert                                                builtin function         dcl 40 ref 242 277
den_flag                  0(04) 000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 320*
                                                                                  345* 417 463
density                         000131 automatic       char(4)                  dcl 43 in procedure "get_spooling_data_" set ref
                                                                                  319* 319 344* 417* 464 506*
density                  15            based           char(4)                  level 2 in structure "spooling_info" dcl 1-7
                                                                                  in procedure "get_spooling_data_" set ref 101* 300
                                                                                  334 464* 469* 478 478*
ec                              000132 automatic       fixed bin(35,0)          dcl 43 in procedure "get_spooling_data_" set ref
                                                                                  120* 122* 123 124 432*
ec                                     parameter       fixed bin(35,0)          dcl 496 in procedure "init" set ref 494 499* 503*
error_flag                      000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 146*
                                                                                  163* 188* 195* 202* 228* 234* 244* 263* 269* 279*
                                                                                  306* 311* 316* 340* 359* 365* 394 402
error_table_$device_end         000010 external static fixed bin(35,0)          dcl 81 ref 135
error_table_$fatal_error        000014 external static fixed bin(35,0)          dcl 83 ref 499
error_table_$noarg              000012 external static fixed bin(35,0)          dcl 82 ref 124
file_limit                      000133 automatic       fixed bin(21,0)          dcl 43 in procedure "get_spooling_data_" set ref
                                                                                  239* 242* 242 243 243 407 409* 458 459 504*
file_limit               57            based           fixed bin(35,0)          level 3 in structure "spooling_info" dcl 1-7
                                                                                  in procedure "get_spooling_data_" set ref 100*
                                                                                  409* 458* 459* 459 551*
files_flag                0(02) 000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 249*
                                                                                  384 394 407 426 457
flags                           000775 automatic       structure                level 1 packed packed unaligned dcl 69 set ref 510*
flgs                     54            based           structure                level 2 dcl 1-7
i                               000134 automatic       fixed bin(17,0)          dcl 43 set ref 199* 200 201* 209* 211* 445* 446 446*
init_flg                        000135 automatic       bit(1)                   dcl 43 set ref 108* 379 394 426 528* 547*
input_line                      000136 automatic       char(120)                dcl 43 set ref 118* 120 120 122 122 431* 432 432
                                                                                  433* 433 434 435
input_lnth                      000174 automatic       fixed bin(17,0)          dcl 43 set ref 120* 122 122 432* 433
int_flag                  0(05) 000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 321*
                                                                                  343* 420 468
io_sw                    54(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 ref 112 296
                                                                                  332
ioa_                            000016 constant        entry                    external dcl 85 ref 115 140 164 396 404 407 409 412
                                                                                  414 417 420 423 426 429 436 488 530 549 551 554
iodd_parse_$command             000020 constant        entry                    external dcl 86 ref 122
iox_$get_line                   000022 constant        entry                    external dcl 87 ref 120 432
iox_$user_input                 000024 external static pointer                  dcl 88 set ref 120* 432*
key                             000175 automatic       fixed bin(17,0)          dcl 43 set ref 150* 152 156 156 157 157 158 158 159
                                                                                  159 160 160 161 161 164 166* 166* 167* 176 178*
                                                                                  178 178* 199 209 221* 221 221* 223* 256* 256 256*
                                                                                  258* 291* 291 291* 293* 328* 328 328* 352* 352
                                                                                  352* 354*
length                                                 builtin function         dcl 40 ref 200 319
line_limit                      000176 automatic       fixed bin(21,0)          dcl 43 in procedure "get_spooling_data_" set ref
                                                                                  274* 277* 277 278 278 412 414* 452 453 505*
line_limit               60            based           fixed bin(35,0)          level 3 in structure "spooling_info" dcl 1-7
                                                                                  in procedure "get_spooling_data_" set ref 99* 414*
                                                                                  452* 453* 453 551*
lines_flag                0(03) 000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 284*
                                                                                  389 394 412 426 451
max_args                        000247 automatic       fixed bin(17,0)          initial level 2 dcl 64 set ref 64*
message                                parameter       char                     packed unaligned dcl 486 set ref 484 488*
n_vols                          001007 automatic       fixed bin(17,0)          dcl 79 set ref 207* 210* 210 211 448 507*
nargs                     1     000247 automatic       fixed bin(17,0)          level 2 dcl 64 set ref 130 152 166 178 221 256 291
                                                                                  328 352
number                          000177 automatic       fixed bin(17,0)          dcl 43 set ref 173* 179* 179 187 193 217* 222* 222
                                                                                  226 232 252* 257* 257 261 267 287* 292* 292 304
                                                                                  309 324* 329* 329 338 348* 353* 353 357 363
nvols                    14            based           fixed bin(17,0)          level 2 dcl 1-7 set ref 105* 448*
nxt_vol_flg                     000200 automatic       bit(1)                   dcl 43 set ref 109* 379 526* 545*
op_msg                          000201 automatic       char(80)                 packed unaligned dcl 43 set ref 112* 114* 115* 532*
                                                                                  557*
opt                                    parameter       char                     packed unaligned dcl 43 set ref 91 94* 134* 517 520*
                                                                                  537 540*
renew_flg                       000225 automatic       bit(1)                   dcl 43 set ref 110* 182 527* 546*
rtrim                                                  builtin function         dcl 40 ref 369
sip                             000100 automatic       pointer                  dcl 1-5 set ref 93* 99 100 101 102 103 104 105 106
                                                                                  112 296 300 300 332 334 334 384 389 409 414 446
                                                                                  448 452 453 453 454 458 459 459 460 464 465 469
                                                                                  470 473 475 475 478 478 498 519* 525 539* 551 551
                                                                                  554 554
spool_file_limit_sw      55            based           fixed bin(17,0)          level 3 dcl 1-7 set ref 103* 384 460*
spool_line_limit_sw      56            based           fixed bin(17,0)          level 3 dcl 1-7 set ref 104* 389 454*
spooling_file_count      61            based           fixed bin(35,0)          level 2 dcl 1-7 set ref 554*
spooling_info                          based           structure                level 1 dcl 1-7
spooling_info_version_4                constant        fixed bin(17,0)          initial dcl 1-36 ref 498
spooling_limits          55            based           structure                level 2 dcl 1-7
spooling_line_count      62            based           fixed bin(35,0)          level 2 dcl 1-7 set ref 554*
string                                                 builtin function         dcl 40 set ref 510*
substr                                                 builtin function         dcl 40 ref 122 122 167 178 221 256 291 319 328 352
                                                                                  433
temp_arg                        000226 automatic       char(64)                 packed unaligned dcl 43 set ref 223* 238 242 258*
                                                                                  273 277 293* 314 314 319 354* 369
translate                                              builtin function         dcl 40 ref 369
try_again                       000246 automatic       bit(1)                   dcl 43 set ref 375* 381* 386* 391* 394 400
version                                based           fixed bin(17,0)          level 2 dcl 1-7 ref 498
vol_flag                  0(01) 000775 automatic       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 214*
                                                                                  379 404 444
vol_id                          000776 automatic       varying char(8)          array dcl 78 set ref 206* 211* 404* 404* 404* 446
                                                                                  508*
vol_mount                54(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 ref 300 334
volids                   17            based           char(6)                  array level 2 dcl 1-7 set ref 106* 446* 525*

NAMES DECLARED BY EXPLICIT CONTEXT.
ask                             003310 constant        label                    dcl 429 ref 397 437
comment_key                     002556 constant        label                    dcl 348 ref 161
density_key                     002267 constant        label                    dcl 287 ref 159
files_key                       001777 constant        label                    dcl 217 ref 157
finish                          002671 constant        label                    dcl 375 ref 152 170
get_spooling_data_              001023 constant        entry                    external dcl 23
init                            004037 constant        entry                    internal dcl 494 ref 96 522 542
initial                         001036 constant        entry                    external dcl 91
interchange_key                 002457 constant        label                    dcl 324 ref 160
join                            001141 constant        label                    dcl 115 ref 126 132 141 400 434 534 559
lines_key                       002133 constant        label                    dcl 252 ref 158
next_key                        001402 constant        label                    dcl 152 ref 147 167 184 190 196 203 215 229 235 246
                                                                                  250 264 270 281 285 298 302 307 312 317 322 336
                                                                                  341 346 360 366 371
next_volume                     003547 constant        entry                    external dcl 517
not_input                       002322 constant        label                    dcl 297 ref 332
read                            001152 constant        label                    dcl 118 ref 124
renew_limits                    003651 constant        entry                    external dcl 537
report                          004004 constant        entry                    internal dcl 484 ref 125 131 145 183 189 194 201 227
                                                                                  233 245 262 268 280 297 301 305 310 315 335 339
                                                                                  358 364 380 385 390 500
volume_key                      001545 constant        label                    dcl 173 ref 156

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4462        4510    4316        4472
Length      4732    4316        26         205     144           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_spooling_data_                  782 external procedure  is an external procedure.  
on unit on line 144                  80 on unit               
report                               78 internal procedure  is called during a stack extension.  
init                                    internal procedure  shares stack frame of external procedure get_spooling_data_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_spooling_data_       000100 sip                         get_spooling_data_
                         000110 arg_no                      get_spooling_data_
                         000111 comment                     get_spooling_data_
                         000131 density                     get_spooling_data_
                         000132 ec                          get_spooling_data_
                         000133 file_limit                  get_spooling_data_
                         000134 i                           get_spooling_data_
                         000135 init_flg                    get_spooling_data_
                         000136 input_line                  get_spooling_data_
                         000174 input_lnth                  get_spooling_data_
                         000175 key                         get_spooling_data_
                         000176 line_limit                  get_spooling_data_
                         000177 number                      get_spooling_data_
                         000200 nxt_vol_flg                 get_spooling_data_
                         000201 op_msg                      get_spooling_data_
                         000225 renew_flg                   get_spooling_data_
                         000226 temp_arg                    get_spooling_data_
                         000246 try_again                   get_spooling_data_
                         000247 arg_list                    get_spooling_data_
                         000775 flags                       get_spooling_data_
                         000776 vol_id                      get_spooling_data_
                         001007 n_vols                      get_spooling_data_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           int_entry_desc      any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          iodd_parse_$command           iox_$get_line

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$device_end       error_table_$fatal_error      error_table_$noarg            iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     64 001016        23 001022        25 001031        91 001032        93 001052        94 001056        96 001063
     97 001071        99 001074       100 001076       101 001077       102 001101       103 001102       104 001103
    105 001104       106 001105       108 001123       109 001125       110 001126       112 001127       114 001136
    115 001141       118 001152       120 001155       122 001200       123 001232       124 001235       125 001240
    126 001256       129 001257       130 001264       131 001267       132 001305       134 001306       135 001314
    136 001317       139 001320       140 001325       141 001341       144 001342       145 001356       146 001372
    147 001375       150 001400       152 001402       156 001405       157 001422       158 001434       159 001446
    160 001460       161 001472       163 001504       164 001506       166 001526       167 001535       168 001542
    170 001544       173 001545       176 001546       178 001551       179 001564       180 001565       182 001567
    183 001571       184 001604       187 001605       188 001607       189 001611       190 001624       193 001625
    194 001627       195 001642       196 001644       199 001645       200 001655       201 001662       202 001720
    203 001723       205 001724       206 001726       207 001737       209 001740       210 001751       211 001752
    212 001772       214 001774       215 001776       217 001777       221 002000       222 002015       223 002016
    224 002024       226 002026       227 002030       228 002043       229 002045       232 002046       233 002050
    234 002063       235 002065       238 002066       239 002072       240 002074       242 002075       243 002105
    244 002111       245 002113       246 002127       249 002130       250 002132       252 002133       256 002134
    257 002151       258 002152       259 002160       261 002162       262 002164       263 002177       264 002201
    267 002202       268 002204       269 002217       270 002221       273 002222       274 002226       275 002230
    277 002231       278 002241       279 002245       280 002247       281 002263       284 002264       285 002266
    287 002267       291 002270       292 002305       293 002306       294 002314       296 002316       297 002322
    298 002335       300 002336       301 002346       302 002361       304 002362       305 002364       306 002377
    307 002401       309 002402       310 002404       311 002417       312 002421       314 002422       315 002432
    316 002445       317 002447       319 002450       320 002452       321 002454       322 002456       324 002457
    328 002460       329 002474       330 002475       332 002477       334 002503       335 002513       336 002526
    338 002527       339 002531       340 002544       341 002546       343 002547       344 002551       345 002553
    346 002555       348 002556       352 002557       353 002573       354 002574       355 002602       357 002604
    358 002606       359 002621       360 002623       363 002624       364 002626       365 002641       366 002643
    369 002644       370 002665       371 002670       375 002671       379 002672       380 002701       381 002714
    384 002716       385 002725       386 002740       389 002742       390 002751       391 002764       394 002766
    396 003000       397 003014       400 003015       402 003017       404 003022       407 003057       409 003102
    412 003127       414 003152       417 003177       420 003224       423 003243       426 003267       429 003310
    431 003324       432 003327       433 003352       434 003357       435 003363       436 003367       437 003406
    444 003407       445 003412       446 003417       447 003433       448 003435       451 003440       452 003443
    453 003451       454 003456       457 003457       458 003462       459 003470       460 003475       463 003476
    464 003501       465 003504       468 003506       469 003511       470 003514       473 003516       475 003525
    478 003535       481 003544       517 003545       519 003563       520 003567       522 003574       523 003602
    525 003605       526 003623       527 003625       528 003626       530 003627       532 003643       534 003646
    537 003647       539 003665       540 003671       542 003676       543 003704       545 003707       546 003710
    547 003712       549 003713       551 003727       554 003753       557 003777       559 004002       484 004003
    488 004017       489 004036       494 004037       498 004041       499 004044       500 004047       501 004062
    503 004063       504 004064       505 004065       506 004066       507 004070       508 004071       509 004103
    510 004106       512 004110


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
