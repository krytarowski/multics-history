	COMPILATION LISTING OF SEGMENT list_err
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1633.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 list_err:       proc;
       12 /*  This program will scan the error file and list, by user within group  */
       13 /*  which programs MULTICS was not able to access for backup purposes.    */
       14 
       15 
       16 
       17 dcl erfil char(32);
       18 dcl argptr ptr;
       19 dcl arglen fixed bin;
       20 dcl arg_string char (arglen) based (argptr);
       21 
       22 
       23 /*  ios_declarations  */
       24 
       25 dcl ios_$attach           entry (char(*), char(*), char(*), char(*), bit(72) aligned);
       26 dcl hcs_$status_          entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
       27 dcl 1 branch aligned,
       28       (2 type bit(2),
       29        2 nnames bit (16),
       30        2 nrp bit (18),
       31        2 dtm bit (36),
       32        2 dtu bit (36),
       33        2 mode bit (5),
       34        2 pad1 bit (13),
       35        2 records bit (18)) unaligned;
       36 
       37 
       38 dcl ioa_                  entry options (variable);
       39 dcl date_time_$fstime     entry (bit(36), char(*));
       40 dcl ios_$read             entry (char(*), ptr, fixed bin, fixed bin, fixed bin, bit(72) aligned);
       41 dcl ioa_$ioa_stream       entry options (variable);
       42 dcl ios_$detach           entry (char(*), char(*), char(*), bit(72) aligned);
       43 dcl hcs_$status_minf      entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
       44 dcl com_err_              entry options (variable);
       45 dcl get_wdir_             entry returns (char(168));
       46 
       47 dcl cu_$arg_ptr           entry (fixed bin, ptr, fixed bin, fixed bin(35));
       48 dcl expand_path_          entry (ptr, fixed bin(17), ptr, ptr, fixed bin(35));
       49 dcl cu_$arg_count         entry (fixed bin);
       50 
       51 
       52 /*  data items  */
       53 
       54 dcl (tproj, tname, name_hold) char (32) varying,
       55     chase fixed bin(1),
       56     (eptr, nreap) ptr,
       57     string char(24),
       58 
       59 
       60 nargs fixed bin,
       61 
       62     (tprog, namep) char(168),
       63     dirctp char(168) aligned,
       64 
       65      real_proj char (tp_len) based (addr (tproj)),
       66      real_name char (tn_len) based (addr (tname)),
       67     (tp_len, tn_len, tleng, str_len, entree) fixed bin (8),
       68     (msg_start, msg_end, msg_length, line_len) fixed bin (8),
       69     (scode, code) fixed bin (35),
       70           fulpath char(168),
       71      sp_line char (120),
       72     (die, ab) fixed bin (1),
       73     (bufptr, pnamep, dirp, enamep) ptr,
       74      nl char (1) aligned static init ("
       75 "),
       76      nareap fixed bin (24),
       77      pnamel fixed bin (17),
       78      working_dir char (168),
       79     (stch1, stch2, stch3) fixed bin,			/* used to segment the input line */
       80      EOF bit (1),					/* end of file indicator          */
       81      chstr char (4) aligned,				/* check for a normal line        */
       82      outstr char (168) aligned init ("OUT"),
       83      error_table_$noentry external fixed bin (35),
       84      error_table_$no_dir  external fixed bin (35),
       85     (tmesg, tpath) char (168),
       86     (status, ostatus) bit (72) aligned,			/* did the read or write go OK? */
       87      nelemt fixed bin (17),				/* number of elements read in     */
       88     (temp1, temp2, temp3) char (100),			/* line segmentation areas        */
       89      lin char (400) aligned;				/* input line                     */
       90 
       91 
       92 /*  built in functions  */
       93 
       94 dcl (addr, init, null, before, fixed, length, index, substr) builtin;
       95 
       96 
       97 /*  I/O status bits  */
       98 
       99 dcl 1 sbits aligned based (addr (status)),
      100     (2 code bit (36),
      101     2 pad bit (9),
      102     2 eof bit (1),					/* end of file bit                */
      103     2 pd2 bit (29)) unal;
      104 
      105 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      106 /*                                                                                                           */
      107 /*  Initialize the end-of-file switch to zero.  Check the number of arguments passed.  If this number is     */
      108 /*  greater or less than one, the wrong no. of arguments have been passed to this program.  In this case     */
      109 /*  an error message is sent and the program suicides.                                                       */
      110 /*									                   */
      111 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      112 
      113 
      114 
      115 setup:
      116 	name_hold = "";
      117           EOF = "0"b;
      118           call cu_$arg_count (nargs);
      119           if nargs ^= 1 then do;
      120                call ioa_ ("list_err:  Wrong number of arguments.");
      121                return;
      122           end;
      123           call cu_$arg_ptr (1, argptr, arglen, code);
      124           erfil = arg_string;
      125 
      126 
      127 
      128 
      129 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      130 /*                                                                                                           */
      131 /*  Set up the parameters for a call to expand_path_:  a ptr to the path name, the path name length,         */
      132 /*  a ptr to a place to put the expanded directory name, and a ptr to a place to put the expanded entry name.*/
      133 /*  Set up the buffer ptr for ios_$read, set off the "strange_line" switch and blank out the temporary       */
      134 /*  storage areas for the message and the path name.                                                         */
      135 /*							                                       */
      136 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      137 
      138 
      139 
      140           pnamep = addr (erfil);
      141           pnamel = length (erfil);
      142 	dirp = addr (dirctp);
      143 	enamep = addr (namep);
      144 	bufptr = addr (lin);
      145 	ab = 0;
      146 	tmesg = " ";
      147 	tpath = " ";
      148           erfil = before (erfil, " ");
      149           fulpath = (">udd>SysDaemon>error_file>"||erfil);
      150           fulpath = before (fulpath, " ");
      151 
      152 
      153 
      154 
      155 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      156 /*                                                                                                           */
      157 /*  Attempt to expand the path name of the erfil to an absolute path name.  If the attempt fails, a request  */
      158 /*  is sent to the user to check the path name and try again and the program suicides.                       */
      159 /*                                                                                                           */
      160 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      161 
      162           call expand_path_ (pnamep, pnamel, dirp, enamep, code);
      163           if code ^= 0 then do;
      164                call com_err_ (code, "list_err", "Error in input file name.");
      165                return;
      166           end;
      167 
      168           fulpath = (before (dirctp, " ")||">"||erfil);
      169 
      170 
      171 
      172 
      173 
      174 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      175 /*                                                                                                           */
      176 /*  Using the absolute path name, attempt to attach a stream in order to read the erfil.  If the attach fails*/
      177 /*  then the processing cannot continue and the program suicides, issuing the appropriate message.           */
      178 /*                                                                                                           */
      179 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      180 
      181 
      182 
      183 
      184           call ios_$attach ("my_input", "file_", fulpath, "r", status);
      185 	if sbits.code ^= "0"b then do;
      186 	     code = fixed (sbits.code);
      187                call com_err_ (code, "list_err", "Attach failed.");
      188 	     go to suicide;
      189 	end;
      190 
      191 
      192 
      193 
      194 
      195 
      196 
      197 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      198 /*                                                                                                           */
      199 /*  THIS IS THE START OF THE MAIN LOOP WHICH CYCLES THROUGH THE ERFIL, PROCESSING ONE ENTRY AT A TIME.       */
      200 /*                                                                                                           */
      201 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      202 
      203 
      204 
      205           do while (EOF = "0"b);
      206 
      207 
      208 
      209 
      210 
      211 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      212 /*                                                                                                           */
      213 /*  Blank out the buffer which holds the input line and read a new input line into it.  If there was an      */
      214 /*  error in the read, put out an IO error message and try the next one.  Otherwise pick up the line length  */
      215 /*  from the nelemt parameter of ios_$read.                                                                  */
      216 /*                                                                                                           */
      217 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      218 
      219 
      220 
      221 read:          lin = " ";
      222                call ios_$read ("my_input", bufptr, 0, 168, nelemt, status);
      223                EOF = sbits.eof;
      224                if sbits.code ^= "0"b & EOF = "0"b then do;
      225                     code = fixed (sbits.code);
      226                     call com_err_ (code, "list_err", "IO error.  Please retry.");
      227                     go to suicide;
      228                end;
      229                line_len = nelemt;
      230 
      231 
      232 
      233 
      234 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      235 /*                                                                                                           */
      236 /*  Divide the input line into the message and the path name.  If the message is Entry not found, ignore     */
      237 /*  this particular line and go to get the next one.  If there is a different message, save it in tmesg then */
      238 /*  pick up the path name and save it in tpath.                                                              */
      239 /*                                                                                                           */
      240 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      241 
      242 
      243 
      244 line_div:      entree = index (lin, "Entry not found.");
      245                if entree = 0 then do;
      246                     msg_start = index (lin, ":");
      247                     msg_end = index (lin, ">");
      248                     if msg_start ^= 0 then do;
      249                          msg_length = (msg_end - msg_start) -3;
      250                          tmesg = substr (lin, (msg_start + 2), msg_length);
      251                          tpath = substr (lin, msg_end, (line_len - msg_end));
      252                     end;
      253 
      254 
      255 
      256 
      257 
      258 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      259 /*                                                                                                           */
      260 /*  Check the directory for the standard user_dir_dir.  If this is some other directory, then we don't       */
      261 /*  know what to do with it and the whole line will be written unparsed into a segment called strange line.  */
      262 /*  If, however this is a user_dir_dir directory, we will pick out the user and the project names and put    */
      263 /*  them in tname and tproj respectively.                                                                    */
      264 /*                                                                                                           */
      265 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      266 
      267 
      268 
      269                     chstr = substr (tpath, 2, 4);
      270                     if chstr = "user" then do;
      271 norm:                    tleng = length (tpath);
      272                          temp1 = substr (tpath, 15, (tleng - 14));
      273                          stch1 = index (temp1, ">");
      274 		     if stch1 = 0 then do;
      275 			stch1 = index (temp1, " ");
      276 			tproj = substr (temp1, 1, (stch1-1));
      277 			tname = "no_userid";
      278 		     end;
      279 		     else do;
      280                          tproj = substr (temp1, 1, (stch1 - 1));
      281                          str_len = length (temp1);
      282                          temp2 = substr (temp1, (stch1 + 1), (str_len - (stch1 + 1)));
      283                          stch2 = index (temp2, ">");
      284                          if stch2 = 0 then stch2 = index (temp2, " ");
      285                          tname = substr (temp2, 1, (stch2 - 1));
      286 		     end;
      287                     end;
      288                     else do;
      289                          tname = "strange";
      290                          tproj = "line";
      291                          ab = 1;
      292                     end;
      293 
      294 
      295 
      296 
      297 
      298 
      299 
      300 
      301 
      302 
      303 
      304 
      305 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      306 /*                                                                                                           */
      307 /*  If the current name is different from the previous one, detach the stream of the current                 */
      308 /*  output segment.  Pick up the length of the new name and project and adjust the size of the               */
      309 /*  name and project variables accordingly.                                                                  */
      310 /*                                                                                                           */
      311 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      312 
      313 
      314 
      315 		if tname ^= name_hold then do;
      316 old_seg:                 call ios_$detach ("outstr", "", "", ostatus);
      317 new_seg:		     tp_len = index (tproj, " ");
      318 
      319 
      320 
      321 
      322 
      323 
      324 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      325 /*                                                                                                           */
      326 /*  Attempt to attach a stream for processing this segment.  If the attach is successful, see if this        */
      327 /*  segment is being attached for the first time.  If it is a new segment, output as the first line, a       */
      328 /*  header explaining that the system was unable to backup the segment.  If this is an old segment, bypass   */
      329 /*  header output.  If the attempt to attach failed, go to get the next erfil entry for processing.          */
      330 /*                                                                                                           */
      331 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      332 
      333 
      334 
      335                                     working_dir = ">udd>SysDaemon>error_file";
      336                                     call hcs_$status_minf (working_dir, ("EF."||tname||"."||tproj), 1b, 01b,
      337                                          nareap, scode);
      338                                     if scode = error_table_$no_dir then do;
      339                                          call com_err_ (scode, "list_err", "No directory >udd>SysDaemon>error_file.");
      340                                          return;
      341                                     end;
      342                                     call ios_$attach
      343                                      ("outstr", "file_", (">udd>SysDaemon>error_file>"||"EF."||tname||"."
      344                                       ||tproj), "w", status);
      345                                     if sbits.code ^= "0"b then do;
      346                                          call com_err_ (ostatus, "list_err", "Attach failed ^a ^a", tname, tproj);
      347                                          return;
      348                                     end;
      349                          if ab ^= 1 then do;
      350                               nreap = null;
      351                               chase = 0;
      352                               eptr = addr(branch);
      353                               call hcs_$status_ (">udd>SysDaemon>error_file", erfil, chase, eptr, nreap, code);
      354 
      355                               call date_time_$fstime (branch.dtm, string);
      356                               call ioa_$ioa_stream
      357                           ("outstr", "The system was unable to access these entries for backup at ^a.", string);
      358                      end; 
      359                     end; 
      360 
      361 
      362 
      363 
      364 
      365 
      366 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      367 /*                                                                                                           */
      368 /*  Set up an output buffer containing the full line in case it is needed.  If the strange line switch is on */
      369 /*  output the full line in the segment called strange^line.  Otherwise, output the name, proj, message and  */
      370 /*  path name in that order.  Set off the strange line switch.  Store the current name in name_hold for      */
      371 /*  comparison with the next name picked up in tname.                                                        */
      372 /*                                                                                                           */
      373 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      374 
      375 
      376 
      377 line_out: 	sp_line = substr (lin, 1, 120);
      378 		if ab = 1 then call ioa_$ioa_stream ("outstr", sp_line);
      379                     else call ioa_$ioa_stream ("outstr", "^a^x^a", tmesg, tpath);
      380                     ab = 0;
      381                     name_hold = tname;
      382 
      383 
      384 
      385 
      386 
      387 
      388 
      389 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      390 /*                                                                                                           */
      391 /*  THIS IS THE END OF THE MAIN LOOP.                                                                        */
      392 /*                                                                                                           */
      393 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      394 
      395 
      396 
      397 	     end;
      398 
      399 
      400 
      401 
      402 
      403 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      404 /*                                                                                                           */
      405 /*  Clear all the work areas in preparation for the next line to be processed.                               */ 
      406 /*                                                                                                           */
      407 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      408 
      409 
      410 
      411 re_init:       temp1 = " ";
      412 	     temp2 = " ";
      413 	     temp3 = " ";
      414 	     tprog = " ";
      415 	     tname = " ";
      416 	     tproj = " ";
      417 	     tmesg = " ";
      418 	     tpath = " ";
      419 	     sbits.eof = "0"b;
      420 	end;
      421 
      422 
      423 
      424 
      425 
      426 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      427 /*                                                                                                           */
      428 /*  Make sure that both the input and the output streams are detached before quitting and then quit.         */
      429 /*                                                                                                           */
      430 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      431 
      432 
      433 
      434 cleanup:  call ios_$detach ("my_input", "", "", status);
      435           call ios_$detach ("outstr", "", "", ostatus);
      436 suicide:  end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1505.2  list_err.pl1                      >dumps>old>recomp>list_err.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EOF                             000576 automatic       bit(1)                   unaligned dcl 54 set ref 117* 205 223* 224
ab                              000507 automatic       fixed bin(1,0)           dcl 54 set ref 145* 291* 349 378 380*
addr                                                   builtin function         dcl 94 ref 140 142 143 144 185 186 223 224 225 345
                                                                                  352 419
arg_string                             based           char                     unaligned dcl 20 ref 124
arglen                          000112 automatic       fixed bin(17,0)          dcl 19 set ref 123* 124
argptr                          000110 automatic       pointer                  dcl 18 set ref 123* 124
before                                                 builtin function         dcl 94 ref 148 150 168
branch                          000113 automatic       structure                level 1 dcl 27 set ref 352
bufptr                          000510 automatic       pointer                  dcl 54 set ref 144* 222*
chase                           000152 automatic       fixed bin(1,0)           dcl 54 set ref 351* 353*
chstr                           000577 automatic       char(4)                  dcl 54 set ref 269* 270
code                                   based           bit(36)                  level 2 in structure "sbits" packed unaligned dcl 99
                                                                                  in procedure "list_err" ref 185 186 224 225 345
code                            000376 automatic       fixed bin(35,0)          dcl 54 in procedure "list_err" set ref 123* 162* 163
                                                                                  164* 186* 187* 225* 226* 353*
com_err_                        000030 constant        entry                    external dcl 44 ref 164 187 226 339 346
cu_$arg_count                   000036 constant        entry                    external dcl 49 ref 118
cu_$arg_ptr                     000032 constant        entry                    external dcl 47 ref 123
date_time_$fstime               000016 constant        entry                    external dcl 39 ref 355
dirctp                          000313 automatic       char(168)                dcl 54 set ref 142 168
dirp                            000514 automatic       pointer                  dcl 54 set ref 142* 162*
dtm                       1     000113 automatic       bit(36)                  level 2 packed unaligned dcl 27 set ref 355*
enamep                          000516 automatic       pointer                  dcl 54 set ref 143* 162*
entree                          000370 automatic       fixed bin(8,0)           dcl 54 set ref 244* 245
eof                       1(09)        based           bit(1)                   level 2 packed unaligned dcl 99 set ref 223 419*
eptr                            000154 automatic       pointer                  dcl 54 set ref 352* 353*
erfil                           000100 automatic       char(32)                 unaligned dcl 17 set ref 124* 140 141 148* 148 149
                                                                                  168 353*
error_table_$no_dir             000040 external static fixed bin(35,0)          dcl 54 ref 338
expand_path_                    000034 constant        entry                    external dcl 48 ref 162
fixed                                                  builtin function         dcl 94 ref 186 225
fulpath                         000377 automatic       char(168)                unaligned dcl 54 set ref 149* 150* 150 168* 184*
hcs_$status_                    000012 constant        entry                    external dcl 26 ref 353
hcs_$status_minf                000026 constant        entry                    external dcl 43 ref 336
index                                                  builtin function         dcl 94 ref 244 246 247 273 275 283 284 317
ioa_                            000014 constant        entry                    external dcl 38 ref 120
ioa_$ioa_stream                 000022 constant        entry                    external dcl 41 ref 356 378 379
ios_$attach                     000010 constant        entry                    external dcl 25 ref 184 342
ios_$detach                     000024 constant        entry                    external dcl 42 ref 316 434 435
ios_$read                       000020 constant        entry                    external dcl 40 ref 222
length                                                 builtin function         dcl 94 ref 141 271 281
lin                             001116 automatic       char(400)                dcl 54 set ref 144 221* 244 246 247 250 251 377
line_len                        000374 automatic       fixed bin(8,0)           dcl 54 set ref 229* 251
msg_end                         000372 automatic       fixed bin(8,0)           dcl 54 set ref 247* 249 251 251
msg_length                      000373 automatic       fixed bin(8,0)           dcl 54 set ref 249* 250
msg_start                       000371 automatic       fixed bin(8,0)           dcl 54 set ref 246* 248 249 250
name_hold                       000141 automatic       varying char(32)         dcl 54 set ref 115* 315 381*
namep                           000241 automatic       char(168)                unaligned dcl 54 set ref 143
nareap                          000520 automatic       fixed bin(24,0)          dcl 54 set ref 336*
nargs                           000166 automatic       fixed bin(17,0)          dcl 54 set ref 118* 119
nelemt                          001002 automatic       fixed bin(17,0)          dcl 54 set ref 222* 229
nreap                           000156 automatic       pointer                  dcl 54 set ref 350* 353*
null                                                   builtin function         dcl 94 ref 350
ostatus                         001000 automatic       bit(72)                  dcl 54 set ref 316* 346* 435*
outstr                          000600 automatic       char(168)                initial dcl 54 set ref 54*
pnamel                          000521 automatic       fixed bin(17,0)          dcl 54 set ref 141* 162*
pnamep                          000512 automatic       pointer                  dcl 54 set ref 140* 162*
sbits                                  based           structure                level 1 dcl 99
scode                           000375 automatic       fixed bin(35,0)          dcl 54 set ref 336* 338 339*
sp_line                         000451 automatic       char(120)                unaligned dcl 54 set ref 377* 378*
status                          000776 automatic       bit(72)                  dcl 54 set ref 184* 185 186 222* 223 224 225 342*
                                                                                  345 419 434*
stch1                           000574 automatic       fixed bin(17,0)          dcl 54 set ref 273* 274 275* 276 280 282 282
stch2                           000575 automatic       fixed bin(17,0)          dcl 54 set ref 283* 284 284* 285
str_len                         000367 automatic       fixed bin(8,0)           dcl 54 set ref 281* 282
string                          000160 automatic       char(24)                 unaligned dcl 54 set ref 355* 356*
substr                                                 builtin function         dcl 94 ref 250 251 269 272 276 280 282 285 377
temp1                           001003 automatic       char(100)                unaligned dcl 54 set ref 272* 273 275 276 280 281
                                                                                  282 411*
temp2                           001034 automatic       char(100)                unaligned dcl 54 set ref 282* 283 284 285 412*
temp3                           001065 automatic       char(100)                unaligned dcl 54 set ref 413*
tleng                           000366 automatic       fixed bin(8,0)           dcl 54 set ref 271* 272
tmesg                           000652 automatic       char(168)                unaligned dcl 54 set ref 146* 250* 379* 417*
tname                           000130 automatic       varying char(32)         dcl 54 set ref 277* 285* 289* 315 336 342 346* 381
                                                                                  415*
tp_len                          000365 automatic       fixed bin(8,0)           dcl 54 set ref 317*
tpath                           000724 automatic       char(168)                unaligned dcl 54 set ref 147* 251* 269 271 272 379*
                                                                                  418*
tprog                           000167 automatic       char(168)                unaligned dcl 54 set ref 414*
tproj                           000117 automatic       varying char(32)         dcl 54 set ref 276* 280* 290* 317 336 342 346* 416*
working_dir                     000522 automatic       char(168)                unaligned dcl 54 set ref 335* 336*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
die                                    automatic       fixed bin(1,0)           dcl 54
error_table_$noentry                   external static fixed bin(35,0)          dcl 54
get_wdir_                       000000 constant        entry                    external dcl 45
init                                                   builtin function         dcl 94
nl                                     internal static char(1)                  initial dcl 54
real_name                              based           char                     unaligned dcl 54
real_proj                              based           char                     unaligned dcl 54
stch3                                  automatic       fixed bin(17,0)          dcl 54
tn_len                                 automatic       fixed bin(8,0)           dcl 54

NAMES DECLARED BY EXPLICIT CONTEXT.
cleanup                         001675 constant        label                    dcl 434
line_div                        000663 constant        label                    dcl 244
line_out                        001557 constant        label                    dcl 377
list_err                        000202 constant        entry                    external dcl 11
new_seg                         001137 constant        label                    dcl 317
norm                            000742 constant        label                    dcl 271
old_seg                         001111 constant        label                    dcl 316
re_init                         001642 constant        label                    dcl 411
read                            000550 constant        label                    dcl 221
setup                           000212 constant        label                    dcl 115
suicide                         001751 constant        label                    dcl 436 ref 188 227

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2124        2166    1755        2134
Length      2354    1755        42         151     147           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
list_err                            794 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
list_err                 000100 erfil                       list_err
                         000110 argptr                      list_err
                         000112 arglen                      list_err
                         000113 branch                      list_err
                         000117 tproj                       list_err
                         000130 tname                       list_err
                         000141 name_hold                   list_err
                         000152 chase                       list_err
                         000154 eptr                        list_err
                         000156 nreap                       list_err
                         000160 string                      list_err
                         000166 nargs                       list_err
                         000167 tprog                       list_err
                         000241 namep                       list_err
                         000313 dirctp                      list_err
                         000365 tp_len                      list_err
                         000366 tleng                       list_err
                         000367 str_len                     list_err
                         000370 entree                      list_err
                         000371 msg_start                   list_err
                         000372 msg_end                     list_err
                         000373 msg_length                  list_err
                         000374 line_len                    list_err
                         000375 scode                       list_err
                         000376 code                        list_err
                         000377 fulpath                     list_err
                         000451 sp_line                     list_err
                         000507 ab                          list_err
                         000510 bufptr                      list_err
                         000512 pnamep                      list_err
                         000514 dirp                        list_err
                         000516 enamep                      list_err
                         000520 nareap                      list_err
                         000521 pnamel                      list_err
                         000522 working_dir                 list_err
                         000574 stch1                       list_err
                         000575 stch2                       list_err
                         000576 EOF                         list_err
                         000577 chstr                       list_err
                         000600 outstr                      list_err
                         000652 tmesg                       list_err
                         000724 tpath                       list_err
                         000776 status                      list_err
                         001000 ostatus                     list_err
                         001002 nelemt                      list_err
                         001003 temp1                       list_err
                         001034 temp2                       list_err
                         001065 temp3                       list_err
                         001116 lin                         list_err

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return              shorten_stack
ext_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   date_time_$fstime
expand_path_                  hcs_$status_                  hcs_$status_minf              ioa_
ioa_$ioa_stream               ios_$attach                   ios_$detach                   ios_$read

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_dir




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000201        54 000207       115 000212       117 000213       118 000214       119 000222       120 000225
    121 000241       123 000242       124 000261       140 000266       141 000270       142 000272       143 000274
    144 000276       145 000300       146 000301       147 000304       148 000307       149 000317       150 000332
    162 000343       163 000362       164 000364       165 000413       168 000414       184 000447       185 000507
    186 000511       187 000513       188 000545       205 000546       221 000550       222 000553       223 000613
    224 000617       225 000623       226 000626       227 000660       229 000661       244 000663       245 000672
    246 000673       247 000704       248 000715       249 000717       250 000723       251 000727       269 000735
    270 000740       271 000742       272 000744       273 000750       274 000761       275 000762       276 000773
    277 001003       278 001010       280 001011       281 001021       282 001023       283 001034       284 001045
    285 001057       287 001067       289 001070       290 001075       291 001101       315 001103       316 001111
    317 001137       335 001151       336 001154       338 001253       339 001260       340 001306       342 001307
    345 001403       346 001406       347 001444       349 001445       350 001450       351 001452       352 001453
    353 001455       355 001514       356 001531       377 001557       378 001562       379 001605       380 001634
    381 001635       411 001642       412 001645       413 001650       414 001653       415 001656       416 001662
    417 001664       418 001667       419 001672       420 001674       434 001675       435 001723       436 001751


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
