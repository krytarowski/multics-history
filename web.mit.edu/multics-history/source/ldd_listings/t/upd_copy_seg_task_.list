	COMPILATION LISTING OF SEGMENT upd_copy_seg_task_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1722.4 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 upd_copy_seg_task_:	procedure (ctlw, areap, parentp, acode, asev, taskp, seqno, dir, seg, msgseg, uid, 
       12 			 ndir, nseg, nmsgseg, nuid, max_length, entry_bound, recover);
       13 
       14 
       15 /*
       16*
       17*	This procedure implements the copy_seg task function for the Multics
       18*	Installation System.  Segment dir>seg (with unique id "uid") is copied into
       19*	ndir>nseg; the new segment's unique id is returned in "nuid".  This
       20*	procedure is restartable; if ndir>nseg already exists, it is compared
       21*	with dir>seg, and if found to be identical, is assumed to have been
       22*	in the process of being copied at the time of a process or system
       23*	failure.  If "nuid" is non-zero on input in this case, it is verified
       24*	as well.  "acode", "asev", and "taskp" should be initialized to "0",
       25*	"0", and "null" respectively.
       26*
       27*	If "recover" is on, then this task is reversible.
       28*
       29*	P. Bos, May 1972
       30*
       31*	Modified: May 1974 P. B. Kelley
       32*		turns the safety switch on for all segments.
       33*	Modified: Nov 1974 P. B. Kelley
       34*		sets the maximum length attribute on all segments with optional
       35*		user specification.
       36*	Modified: Mar 1981 E. N. Kittlitz
       37*		sets entry bound if one exists in object map.
       38*
       39**/
       40 
       41      dcl	ctlw			bit(36) aligned,	/* updater control word */
       42 	areap			ptr,		/* caller area pointer */
       43 	parentp			ptr,		/* pointer to parent arglist */
       44 	acode			fixed bin(35),	/* status code */
       45 	asev			fixed bin,	/* severity code */
       46 	taskp			ptr,		/* task pointer */
       47 	seqno			fixed bin,	/* task sequence no. */
       48 	dir			char(168),	/* dirname of source segment */
       49 	seg			char(32),		/* entryname of source segment */
       50 	msgseg			char(32),		/* entryname of source segment used in messages */
       51 	uid			bit(36) aligned,	/* unique id of source segment */
       52 	ndir			char(168),	/* dirname of target segment */
       53 	nseg			char(32),		/* entryname of target segment */
       54 	nmsgseg			char(32),		/* entryname of target segment used in messages */
       55 	nuid			bit(36) aligned,	/* unique id of target segment (output) */
       56 	max_length		fixed bin(18),	/* max length attribute of target segment */
       57 	entry_bound		fixed bin (14),	/* entry bound */
       58 	recover			bit(1);		/* on if segment should be deleted when "run" */
       59 						/* in "reverse" mode. */
       60 
       61      dcl	condition_		entry (char(*), entry),
       62 	cu_$arg_list_ptr		entry (ptr),
       63 	hcs_$append_branch		entry (char(*), char(*), fixed bin(5), fixed bin(35)),
       64 	hcs_$delentry_file		entry (char(*), char(*), fixed bin(35)),
       65 	hcs_$initiate		entry (char(*), char(*), char(*), fixed bin(1), fixed bin(2), ptr, fixed bin(35)),
       66 	hcs_$set_bc		entry (char(*), char(*), fixed bin(24), fixed bin(35)),
       67 	hcs_$set_entry_bound	entry (char (*), char (*), fixed bin (14), fixed bin (35)),
       68 	hcs_$set_max_length		entry (char(*), char(*), fixed bin(18), fixed bin(35)),
       69 	hcs_$set_safety_sw		entry (char(*), char(*), bit(1), fixed bin(35)),
       70 	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
       71 	ioa_$ioa_stream		entry options (variable),
       72 	reversion_		entry (char(*)),
       73 	upd_add_task_		entry (char(*), ptr),
       74 	upd_print_err_		entry options (variable),
       75 	upd_status_$long		entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35)),
       76 	upd_task_err_		entry options (variable);
       77 
       78      dcl (addr, divide, fixed, null)	builtin;
       79 
       80      dcl (error_table_$badcall,
       81 	error_table_$namedup,
       82 	error_table_$non_matching_uid,
       83 	error_table_$rqover,
       84 	error_table_$segknown,
       85 	error_table_$zero_length_seg)	ext fixed bin(35),
       86 	sys_info$page_size		fixed bin (35) ext static,	/* no words per page. */
       87 	sys_info$max_seg_size	ext fixed bin;		/* max seg size */
       88 
       89      dcl	argp			ptr,		/* arglist pointer for alloc_task, task_err_ */
       90 	cp			ptr,		/* control word pointer */
       91 	dp			ptr,		/* baseptr for "bdir" */
       92 	msp			ptr,		/* baseptr for "bmsgseg" */
       93          (p, q)			ptr,		/* random */
       94 	sp			ptr;		/* baseptr for "bseg" */
       95 
       96      dcl	bc			fixed bin(24),	/* bitcount */
       97 	code			fixed bin(35),	/* status code for outward calls */
       98 	data (n)			fixed bin(35) based (p), /* used to copy segment */
       99 	bits 			 bit (bc) based,
      100 	err_label			label local,	/* error branch vector. */
      101 	maxl			fixed bin(18),	/* length for max length setting */
      102 	n			fixed bin(35),	/* no. of words to copy */
      103 	tbc			fixed bin(24),	/* temp bitcount for copy */
      104 	tcode			fixed bin(35),	/* temp status code */
      105 	tn			fixed bin,	/* copy of "n" for source segment */
      106 	sev			fixed bin init (3);	/* nornal severity code. */
      107 
      108      dcl	bdir			char(168) based (dp),
      109 	bmsgseg			char(32) based (msp),
      110 	bseg			char(32) based (sp);
      111 
      112      dcl (dupsw			bit(1),		/* non-zero if namedup on append_branch call */
      113 	logsw			bit(1),		/* non-zero if printing */
      114 	nsw			bit(1),		/* non-zero if error refers to target seg */
      115 	runsw			bit(1)) aligned;	/* non-zero if to process */
      116 
      117      dcl	1 c			aligned based (cp),	/* exploded control word */
      118 	 (2 rsw			bit(1),		/* non-zero if in reverse mode */
      119 	  2 tasksw		bit(1),		/* non-zero if to set up task */
      120 	  2 compsw		bit(1),		/* non-zero if compile-only task */
      121 	  2 runsw			bit(1),		/* non-zero if call to be processed immediately */
      122 	  2 trunsw		bit(1),		/* non-zero if subtask list to be processed */
      123 	  2 logsw			bit(1),		/* non-zero if in print mode */
      124 	  2 errsw			bit(1)) unal;	/* non-zero if to print error tasks only */
      125 
      126      dcl	1 stat			aligned,		/* data structure for status_ */
      127 	 (2 type			bit(2),		/* entry type */
      128 	  2 nnames		bit(16),		/* number of names returned */
      129 	  2 nrp			bit(18),		/* rel pointer to name array */
      130 	  2 dtm			bit(36),		/* date/time modified */
      131 	  2 dtu			bit(36),		/* date/time used */
      132 	  2 mode			bit(5),		/* t, r, e, w, a */
      133 	  2 pad			bit(13),		/* unused */
      134 	  2 recs			bit(18),		/* pages used */
      135 	  2 dtd			bit(36),		/* date/time dumped */
      136 	  2 dtem			bit(36),		/* date/time entry modified */
      137 	  2 acct			bit(36),		/* accounting data */
      138 	  2 curlen		bit(12),		/* length of segment */
      139 	  2 bitcnt		bit(24),		/* bitcount of segment */
      140 	  2 did			bit(4),		/* device id */
      141 	  2 mdid			bit(4),		/* ? */
      142 	  2 copysw		bit(1),		/* segment copy switch */
      143 	  2 pad2			bit(9),		/* unused */
      144 	  2 rbs (0:2)		bit(6),		/* ring brackets */
      145 	  2 uid			bit(36)) unal;	/* unique id */
      146 
      147 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      148 /*  */
      149 	call cu_$arg_list_ptr (argp);			/* get arglist pointer for alloc_task_, task_err_ */
      150 	cp = addr (ctlw);				/* get control word pointer */
      151 	if c.rsw then if ^recover then		/* this task doesn't run in reverse mode */
      152 	     return;				/* unless caller specified full recovery */
      153 						/* for the segment being copied. */
      154 	if c.tasksw then				/* are we to allocate a task? */
      155 	     call upd_add_task_("upd_copy_seg_task_", argp);
      156 	logsw = c.logsw;				/* non-zero if to print */
      157 	if c.errsw then if asev = 0 then		/* error tasks only? */
      158 	     logsw = "0"b;				/* turn it off if no error */
      159 	runsw = c.runsw | c.trunsw;			/* non-zero if to process */
      160 	if logsw then do;				/* user wants to know what happened */
      161 						/* print path name of source segment */
      162 	     if seg = msgseg then
      163 		call ioa_$ioa_stream ("installation_list_", "^5x^RCopy^B^2-^a>^a", dir, seg);
      164 	     else
      165 		call ioa_$ioa_stream ("installation_list_", "^5x^RCopy^B^2-^a>^a  (^a)", dir, seg, msgseg);
      166 	     if nseg = nmsgseg then			/* print path name of target segment */
      167 		call ioa_$ioa_stream ("installation_list_", "^-^Rto^B^-^a>^a", ndir, nseg);
      168 	     else
      169 		call ioa_$ioa_stream ("installation_list_", "^-^Rto^B^-^a>^a  (^a)", ndir, nseg, nmsgseg);
      170 	     if asev ^= 0 then			/* was there an error? */
      171 		call upd_print_err_(acode, asev);	/* yes, tell user */
      172 	     end;
      173 	if ^runsw then				/* if not in process mode, */
      174 	     go to prtuid;				/* go away */
      175 
      176 	p, q = null;				/* zap segment pointers */
      177 
      178 	if c.rsw then				/* in "reverse" */
      179 	     go to delete;
      180 						/* ******************************* */
      181 						/*   FORWARD		     */
      182 						/* ******************************* */
      183 	nsw = "0"b;				/* any error now refers to source seg */
      184 	err_label = return;				/* most are fatal errors. */
      185 	call upd_status_$long (dir, seg, 1, addr(stat), null, code);
      186 	if code ^= 0 then				/* error? */
      187 	     go to err;				/* skip if so */
      188 	if uid ^= ""b then if uid ^= stat.uid then do;	/* verify unique id */
      189 	     code = error_table_$non_matching_uid;	/* no match, set error code */
      190 	     go to err;				/* and exit */
      191 	     end;
      192 	n, tn, maxl = fixed (stat.curlen) * sys_info$page_size; /* get word count for segment */
      193 	if n = 0 then do;				/* zero length segment is error */
      194 	     code = error_table_$zero_length_seg;	/* set error code */
      195 	     go to err;				/* skip */
      196 	     end;
      197 	call hcs_$initiate (dir, seg, "", 0, 0, p, code);	/* initiate source segment */
      198 	if code ^= 0 then if code ^= error_table_$segknown then
      199 	     go to err;				/* exit on error */
      200 	bc = fixed (stat.bitcnt);			/* fix bitcount */
      201 	nsw = "1"b;				/* errors from here on are for target seg */
      202 	call hcs_$append_branch (ndir, nseg, 01010b, code);	/* add entry for new segment */
      203 	if code ^= 0 then				/* oops */
      204 	     if code = error_table_$namedup then	/* segment already exists */
      205 		dupsw = "1"b;			/* might be ok, though */
      206 	     else					/* any other error is fatal */
      207 		go to err;			/* skip */
      208 	else					/* code = 0 */
      209 	     dupsw = "0"b;				/* reset switch */
      210 	call upd_status_$long (ndir, nseg, 1, addr(stat), null, code);
      211 	if code ^= 0 then				/* hard to believe... */
      212 	     go to err;				/* skip */
      213 	if nuid = ""b then				/* if uid has not been set in previous invocation */
      214 	     nuid = stat.uid;			/* .. which was interrupted, set it now */
      215 	else if nuid ^= stat.uid then do;		/* uid has been set, compare it */
      216 	     if dupsw then				/* if segment existed prior to call, */
      217 dup:		code = error_table_$namedup;		/* namedup error */
      218 	     else					/* if not, caller forgot to initialize args */
      219 		code = error_table_$badcall;		/* tell him so */
      220 	     go to err;				/* exit */
      221 	     end;
      222 	call hcs_$initiate (ndir, nseg, "", 0, 0, q, code); /* initiate copy */
      223 	if code ^= 0 then if code ^= error_table_$segknown then
      224 	     go to err;
      225 	if dupsw then do;				/* segment may have been partially copied */
      226 	     if bc ^= 0 then if q -> bits ^= p -> bits then	/* compare segment with original */
      227 		go to dup;			/* again namedup error */
      228 	     if n = tn then do;			/* segments are identical */
      229 		tbc = fixed (stat.bitcnt);		/* get bitcount of copy */
      230 		if tbc = bc then			/* was it already set? */
      231 		     go to exit;			/* yes, skip set_bc call */
      232 		go to setbc;			/* go set bitcount */
      233 		end;
      234 	     n = tn;				/* was partially copied; get length & do it again */
      235 	     end;
      236 	call condition_ ("record_quota_overflow", record_quota_overflow);
      237 						/* handle record quota overflows during copy. */
      238 	q -> data = p -> data;			/* copy segment */
      239 	call reversion_ ("record_quota_overflow");	/* disable rqover handler, after copy complete. */
      240 	go to setbc;
      241 rqover:	call reversion_ ("record_quota_overflow");	/* don't handle them any more. */
      242 	if nseg = nmsgseg then
      243 	     call upd_task_err_ (error_table_$rqover, 4, argp, "upd_copy_seg_task_",
      244 		"^/Referencing ^R^a>^a^B .", ndir, nseg);
      245 	else
      246 	     call upd_task_err_ (error_table_$rqover, 4, argp, "upd_copy_seg_task_",
      247 		"^/Referencing ^R^a>^a^B^/(^a>^a).", ndir, nseg, ndir, nmsgseg);
      248 
      249 setbc:	if q -> bits ^= p -> bits then do;		/* make sure the hardware did what it's supposed to!!! */
      250 	     if nseg = nmsgseg then			/* CSL's used to fail.  Here we're testing the MLR */
      251 		call upd_task_err_ ( 0, 4, argp, "upd_copy_seg_task_",
      252 		     "Segment not copied correctly:  ^R^a>^a^B^/Please re-initiate and try again.", ndir, nseg );
      253 	     else
      254 		call upd_task_err_ ( 0, 4, argp, "upd_copy_seg_task_",
      255 		     "Segment not copied correctly:  ^R^a>^a^B^/(^R^a>^a^B)^/Please re-initiate and try again.",
      256 			ndir, nseg, ndir, nmsgseg );
      257 	     end;
      258 
      259 						/* ******************************* */
      260 						/* SET BIT COUNT		     */
      261 	call hcs_$set_bc (ndir, nseg, bc, code);	/* ******************************* */
      262 	if code ^= 0 then				/* can't do it */
      263 	     if nseg = nmsgseg then
      264 		call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      265 		     "^/Unable to set bit count on ^R^a>^a^B .", ndir, nseg);
      266 	     else
      267 		call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      268 		     "^/Unable to set bit count on ^R^a>^a^B^/(^a>^a).", ndir, nseg, ndir, nmsgseg);
      269 exit:						/* always set max length, safety switch & entry bound */
      270 	if max_length > sys_info$max_seg_size then	/* can't set it to > max segment length */
      271 	     maxl = sys_info$max_seg_size;
      272 	else if max_length = 0 then			/* set to current length (maxl) */
      273 	     go to sml;
      274 	else if max_length < maxl then;		/* can't set it less than current length */
      275 	else do;					/* guess value of max_length looks ok */
      276 	     maxl = (divide((max_length + 1023), 1024, 35, 0)) * 1024; /* set temporary to nearest upper page boundary */
      277 	     go to sml;				/* xfer to call */
      278 	     end;
      279 	if nseg = nmsgseg then			/* errors fall thru to here */
      280 	     call upd_task_err_ ( 0, 1, argp, "upd_copy_seg_task_",
      281 		"Attempt to set illegal maximum length on ^R^a>^a^B.", ndir, nseg);
      282 	else
      283 	     call upd_task_err_ ( 0, 1, argp, "upd_copy_seg_task_",
      284 		"Attempt to set illegal maximum length on ^R^a>^a^B.^/(^a>^a).",
      285 		ndir, nseg, ndir, nmsgseg);
      286 						/* if task_err_ call returns, then continue */
      287 	call upd_print_err_ (0, 0, "", "", "Warning", "", "Maximum length will be set to ^d words.", maxl);
      288 
      289 						/* ******************************* */
      290 						/* SET MAX LENGTH		     */
      291 sml:	call hcs_$set_max_length ( ndir, nseg, maxl, code);/* ****************************** */
      292 	if code ^= 0 then
      293 	     if nseg = nmsgseg then
      294 		call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      295 		     "^/Unable to set the maximum length of ^R^a>^a^B.", ndir, nseg);
      296 	     else
      297 		call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      298 		     "^/Unable to set the maximum length of ^R^a>^a^B (^a>^a).",
      299 		     ndir, nseg, ndir, nmsgseg);
      300 						/* ******************************* */
      301 						/* SET SAFETY SWITCH	     */
      302 	call hcs_$set_safety_sw ( ndir, nseg, "1"b, code);/* ******************************* */
      303 	if code ^= 0 then
      304 	     if nseg = nmsgseg then
      305 		call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      306 		     "^/Unable to set the safety switch on ^R^a>^a^B .", ndir, nseg );
      307 	     else
      308 		call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      309 		     "^/Unable to set the safety switch on ^R^a>^a^B^/(^a>^a).", ndir, nseg, ndir, nmsgseg);
      310 
      311 	if entry_bound > 0				/* ******************************* */
      312 	     then do;				/* SET ENTRY BOUND                 */
      313 						/* ******************************* */
      314 		call hcs_$set_entry_bound (ndir, nseg, entry_bound, code);	
      315 		if code ^= 0 then do;
      316 		     if nseg = nmsgseg then
      317 		          call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      318 		               "^/Unable to set entry bound on ^R^a>^a^B .", ndir, nseg);
      319 		     else
      320 		          call upd_task_err_ (code, 2, argp, "upd_copy_seg_task_",
      321 		               "^/Unable to set entry bound on ^R^a>^a^B^/(^a>^a).", ndir, nseg, ndir, nmsgseg);
      322 		end;
      323 	     end;
      324 
      325 	call hcs_$terminate_noname (p, code);		/* terminate source segment */
      326 	call hcs_$terminate_noname (q, code);		/* terminate target segment */
      327 
      328 prtuid:	if logsw then if nuid ^= ""b then		/* user wants to know */
      329 	     call ioa_$ioa_stream ("installation_list_", "^-target seg unique id = ^w", nuid);/* tell him */
      330 	return;					/* and finally exit */
      331 /*  */
      332 						/* ****************************** */
      333 						/*   REVERSE		    */
      334 						/* ****************************** */
      335 delete:	nsw = "1"b;				/* errors refer to  new segment. */
      336 	err_label = del_err;			/* these errors can be non-fatal. */
      337 	sev = 1;					/* all errors here are severity 1 */
      338 	call upd_status_$long (ndir, nseg, 1, addr(stat), null, code);
      339 	if code ^= 0 then				/* error ? */
      340 	     go to err;				/* We tried. Tell user. He may want to continue. */
      341 	if nuid ^= ""b then if nuid ^= stat.uid then do;	/* verify unique id to prevent deletion */
      342 	     code = error_table_$non_matching_uid;	/* of the wrong segment. */
      343 	     go to err;
      344 	     end;
      345 	call hcs_$set_safety_sw ( ndir, nseg, "0"b, code); /* turn safety switch off */
      346 						/* we'll find out if successful by next call */
      347 	call hcs_$delentry_file (ndir, nseg, code);	/* delete the segment. */
      348 	if code ^= 0 then				/* oops, an error. */
      349 	     go to err;
      350 del_err:	nuid = ""b;				/* clear out our variables. */
      351 	return;
      352 
      353 err:	if p ^= null then				/* if source segment was initiated, */
      354 	     call hcs_$terminate_noname (p, tcode);	/* terminate it */
      355 	if q ^= null then				/* same for target segment */
      356 	     call hcs_$terminate_noname (q, tcode);	/* ignore error codes returned */
      357 	if ^nsw then do;				/* decide which name to use in message */
      358 	     dp = addr (dir);			/* source segment name */
      359 	     sp = addr (seg);
      360 	     msp = addr (msgseg);
      361 	     end;
      362 	else do;
      363 	     dp = addr (ndir);			/* target segment name */
      364 	     sp = addr (nseg);
      365 	     msp = addr (nmsgseg);
      366 	     end;
      367 	if bseg = bmsgseg then
      368 	     call upd_task_err_ (code, sev, argp, "upd_copy_seg_task_",
      369 		"^/Referencing ^R^a>^a^B .", bdir, bseg);
      370 	else
      371 	     call upd_task_err_ (code, sev, argp, "upd_copy_seg_task_",
      372 		"^/Referencing ^R^a>^a^B^/(^a>^a).", bdir, bseg, bdir, bmsgseg);
      373 	go to err_label;				/* all done, back to the shadows */
      374 return:	return;					/* return point from errors. */
      375 
      376 
      377 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      378 
      379 
      380 record_quota_overflow:	procedure;		/* handler for record quota overflows. */
      381 
      382 	go to rqover;
      383 
      384 	end record_quota_overflow;
      385 
      386 
      387 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      388 
      389 	end upd_copy_seg_task_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1513.4  upd_copy_seg_task_.pl1            >dumps>old>recomp>upd_copy_seg_task_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acode                                  parameter       fixed bin(35,0)          dcl 41 set ref 11 170*
addr                                                   builtin function         dcl 78 ref 150 185 185 210 210 338 338 358 359 360
                                                                                  363 364 365
areap                                  parameter       pointer                  dcl 41 ref 11
argp                            000100 automatic       pointer                  dcl 89 set ref 149* 154* 242* 245* 250* 253* 262*
                                                                                  266* 279* 282* 292* 296* 303* 307* 316* 319* 367*
                                                                                  370*
asev                                   parameter       fixed bin(17,0)          dcl 41 set ref 11 157 170 170*
bc                              000116 automatic       fixed bin(24,0)          dcl 96 set ref 200* 226 226 226 230 249 249 261*
bdir                                   based           char(168)                unaligned dcl 108 set ref 367* 370* 370*
bitcnt                    7(12) 000136 automatic       bit(24)                  level 2 packed unaligned dcl 126 set ref 200 229
bits                                   based           bit                      unaligned dcl 96 ref 226 226 249 249
bmsgseg                                based           char(32)                 unaligned dcl 108 set ref 367 370*
bseg                                   based           char(32)                 unaligned dcl 108 set ref 367 367* 370*
c                                      based           structure                level 1 dcl 117
code                            000117 automatic       fixed bin(35,0)          dcl 96 set ref 185* 186 189* 194* 197* 198 198 202*
                                                                                  203 203 210* 211 216* 218* 222* 223 223 261* 262
                                                                                  262* 266* 291* 292 292* 296* 302* 303 303* 307*
                                                                                  314* 315 316* 319* 325* 326* 338* 339 342* 345*
                                                                                  347* 348 367* 370*
condition_                      000010 constant        entry                    external dcl 61 ref 236
cp                              000102 automatic       pointer                  dcl 89 set ref 150* 151 154 156 157 159 159 178
ctlw                                   parameter       bit(36)                  dcl 41 set ref 11 150
cu_$arg_list_ptr                000012 constant        entry                    external dcl 61 ref 149
curlen                    7     000136 automatic       bit(12)                  level 2 packed unaligned dcl 126 set ref 192
data                                   based           fixed bin(35,0)          array dcl 96 set ref 238* 238
dir                                    parameter       char(168)                unaligned dcl 41 set ref 11 162* 164* 185* 197* 358
divide                                                 builtin function         dcl 78 ref 276
dp                              000104 automatic       pointer                  dcl 89 set ref 358* 363* 367 370 370
dupsw                           000132 automatic       bit(1)                   dcl 112 set ref 203* 208* 216 225
entry_bound                            parameter       fixed bin(14,0)          dcl 41 set ref 11 311 314*
err_label                       000120 automatic       label variable           local dcl 96 set ref 184* 336* 373
error_table_$badcall            000050 external static fixed bin(35,0)          dcl 80 ref 218
error_table_$namedup            000052 external static fixed bin(35,0)          dcl 80 ref 203 216
error_table_$non_matching_uid   000054 external static fixed bin(35,0)          dcl 80 ref 189 342
error_table_$rqover             000056 external static fixed bin(35,0)          dcl 80 set ref 242* 245*
error_table_$segknown           000060 external static fixed bin(35,0)          dcl 80 ref 198 223
error_table_$zero_length_seg    000062 external static fixed bin(35,0)          dcl 80 ref 194
errsw                     0(06)        based           bit(1)                   level 2 packed unaligned dcl 117 ref 157
fixed                                                  builtin function         dcl 78 ref 192 200 229
hcs_$append_branch              000014 constant        entry                    external dcl 61 ref 202
hcs_$delentry_file              000016 constant        entry                    external dcl 61 ref 347
hcs_$initiate                   000020 constant        entry                    external dcl 61 ref 197 222
hcs_$set_bc                     000022 constant        entry                    external dcl 61 ref 261
hcs_$set_entry_bound            000024 constant        entry                    external dcl 61 ref 314
hcs_$set_max_length             000026 constant        entry                    external dcl 61 ref 291
hcs_$set_safety_sw              000030 constant        entry                    external dcl 61 ref 302 345
hcs_$terminate_noname           000032 constant        entry                    external dcl 61 ref 325 326 353 355
ioa_$ioa_stream                 000034 constant        entry                    external dcl 61 ref 162 164 166 168 328
logsw                           000133 automatic       bit(1)                   dcl 112 in procedure "upd_copy_seg_task_" set ref
                                                                                  156* 157* 160 328
logsw                     0(05)        based           bit(1)                   level 2 in structure "c" packed unaligned dcl 117
                                                                                  in procedure "upd_copy_seg_task_" ref 156
max_length                             parameter       fixed bin(18,0)          dcl 41 ref 11 269 272 274 276
maxl                            000124 automatic       fixed bin(18,0)          dcl 96 set ref 192* 269* 274 276* 287* 291*
msgseg                                 parameter       char(32)                 unaligned dcl 41 set ref 11 162 164* 360
msp                             000106 automatic       pointer                  dcl 89 set ref 360* 365* 367 370
n                               000125 automatic       fixed bin(35,0)          dcl 96 set ref 192* 193 228 234* 238
ndir                                   parameter       char(168)                unaligned dcl 41 set ref 11 166* 168* 202* 210* 222*
                                                                                  242* 245* 245* 250* 253* 253* 261* 262* 266* 266*
                                                                                  279* 282* 282* 291* 292* 296* 296* 302* 303* 307*
                                                                                  307* 314* 316* 319* 319* 338* 345* 347* 363
nmsgseg                                parameter       char(32)                 unaligned dcl 41 set ref 11 166 168* 242 245* 250
                                                                                  253* 262 266* 279 282* 292 296* 303 307* 316 319*
                                                                                  365
nseg                                   parameter       char(32)                 unaligned dcl 41 set ref 11 166 166* 168* 202* 210*
                                                                                  222* 242 242* 245* 250 250* 253* 261* 262 262*
                                                                                  266* 279 279* 282* 291* 292 292* 296* 302* 303
                                                                                  303* 307* 314* 316 316* 319* 338* 345* 347* 364
nsw                             000134 automatic       bit(1)                   dcl 112 set ref 183* 201* 335* 357
nuid                                   parameter       bit(36)                  dcl 41 set ref 11 213 213* 215 328 328* 341 341 350*
null                                                   builtin function         dcl 78 ref 176 185 185 210 210 338 338 353 355
p                               000110 automatic       pointer                  dcl 89 set ref 176* 197* 226 238 249 325* 353 353*
parentp                                parameter       pointer                  dcl 41 ref 11
q                               000112 automatic       pointer                  dcl 89 set ref 176* 222* 226 238 249 326* 355 355*
recover                                parameter       bit(1)                   unaligned dcl 41 ref 11 151
reversion_                      000036 constant        entry                    external dcl 61 ref 239 241
rsw                                    based           bit(1)                   level 2 packed unaligned dcl 117 ref 151 178
runsw                     0(03)        based           bit(1)                   level 2 in structure "c" packed unaligned dcl 117
                                                                                  in procedure "upd_copy_seg_task_" ref 159
runsw                           000135 automatic       bit(1)                   dcl 112 in procedure "upd_copy_seg_task_" set ref
                                                                                  159* 173
seg                                    parameter       char(32)                 unaligned dcl 41 set ref 11 162 162* 164* 185* 197*
                                                                                  359
seqno                                  parameter       fixed bin(17,0)          dcl 41 ref 11
sev                             000131 automatic       fixed bin(17,0)          initial dcl 96 set ref 96* 337* 367* 370*
sp                              000114 automatic       pointer                  dcl 89 set ref 359* 364* 367 367 370
stat                            000136 automatic       structure                level 1 dcl 126 set ref 185 185 210 210 338 338
sys_info$max_seg_size           000066 external static fixed bin(17,0)          dcl 80 ref 269 269
sys_info$page_size              000064 external static fixed bin(35,0)          dcl 80 ref 192
taskp                                  parameter       pointer                  dcl 41 ref 11
tasksw                    0(01)        based           bit(1)                   level 2 packed unaligned dcl 117 ref 154
tbc                             000126 automatic       fixed bin(24,0)          dcl 96 set ref 229* 230
tcode                           000127 automatic       fixed bin(35,0)          dcl 96 set ref 353* 355*
tn                              000130 automatic       fixed bin(17,0)          dcl 96 set ref 192* 228 234
trunsw                    0(04)        based           bit(1)                   level 2 packed unaligned dcl 117 ref 159
uid                      11     000136 automatic       bit(36)                  level 2 in structure "stat" packed unaligned dcl 126
                                                                                  in procedure "upd_copy_seg_task_" set ref 188 213
                                                                                  215 341
uid                                    parameter       bit(36)                  dcl 41 in procedure "upd_copy_seg_task_" ref 11 188
                                                                                  188
upd_add_task_                   000040 constant        entry                    external dcl 61 ref 154
upd_print_err_                  000042 constant        entry                    external dcl 61 ref 170 287
upd_status_$long                000044 constant        entry                    external dcl 61 ref 185 210 338
upd_task_err_                   000046 constant        entry                    external dcl 61 ref 242 245 250 253 262 266 279 282
                                                                                  292 296 303 307 316 319 367 370

NAMES DECLARED BY EXPLICIT CONTEXT.
del_err                         003463 constant        label                    dcl 350 ref 336
delete                          003323 constant        label                    dcl 335 ref 178
dup                             001277 constant        label                    dcl 216 ref 226
err                             003466 constant        label                    dcl 353 ref 186 190 195 198 203 211 220 223 339 343
                                                                                  348
exit                            002210 constant        label                    dcl 269 ref 230
prtuid                          003266 constant        label                    dcl 328 ref 173
record_quota_overflow           003704 constant        entry                    internal dcl 380 ref 236 236
return                          003702 constant        label                    dcl 374 ref 184
rqover                          001453 constant        label                    dcl 241 set ref 382
setbc                           001635 constant        label                    dcl 249 ref 232 240
sml                             002446 constant        label                    dcl 291 ref 272 277
upd_copy_seg_task_              000441 constant        entry                    external dcl 11

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4224        4314    3714        4234
Length      4552    3714        70         222     310           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
upd_copy_seg_task_                  266 external procedure  is an external procedure.  
record_quota_overflow                64 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
upd_copy_seg_task_       000100 argp                        upd_copy_seg_task_
                         000102 cp                          upd_copy_seg_task_
                         000104 dp                          upd_copy_seg_task_
                         000106 msp                         upd_copy_seg_task_
                         000110 p                           upd_copy_seg_task_
                         000112 q                           upd_copy_seg_task_
                         000114 sp                          upd_copy_seg_task_
                         000116 bc                          upd_copy_seg_task_
                         000117 code                        upd_copy_seg_task_
                         000120 err_label                   upd_copy_seg_task_
                         000124 maxl                        upd_copy_seg_task_
                         000125 n                           upd_copy_seg_task_
                         000126 tbc                         upd_copy_seg_task_
                         000127 tcode                       upd_copy_seg_task_
                         000130 tn                          upd_copy_seg_task_
                         000131 sev                         upd_copy_seg_task_
                         000132 dupsw                       upd_copy_seg_task_
                         000133 logsw                       upd_copy_seg_task_
                         000134 nsw                         upd_copy_seg_task_
                         000135 runsw                       upd_copy_seg_task_
                         000136 stat                        upd_copy_seg_task_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              tra_ext             mpfx2               ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_                    cu_$arg_list_ptr              hcs_$append_branch            hcs_$delentry_file
hcs_$initiate                 hcs_$set_bc                   hcs_$set_entry_bound          hcs_$set_max_length
hcs_$set_safety_sw            hcs_$terminate_noname         ioa_$ioa_stream               reversion_
upd_add_task_                 upd_print_err_                upd_status_$long              upd_task_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badcall          error_table_$namedup          error_table_$non_matching_uid error_table_$rqover
error_table_$segknown         error_table_$zero_length_seg  sys_info$max_seg_size         sys_info$page_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000425        96 000446       149 000450       150 000456       151 000461       154 000471       156 000517
    157 000523       159 000532       160 000543       162 000545       164 000613       166 000651       168 000715
    170 000753       173 000773       176 000775       178 001000       183 001003       184 001004       185 001007
    186 001052       188 001054       189 001061       190 001064       192 001065       193 001077       194 001100
    195 001102       197 001103       198 001145       200 001152       201 001155       202 001157       203 001207
    208 001217       210 001220       211 001263       213 001265       215 001273       216 001275       218 001303
    220 001306       222 001307       223 001352       225 001357       226 001361       228 001371       229 001374
    230 001377       232 001401       234 001402       236 001404       238 001427       239 001436       240 001452
    241 001453       242 001467       245 001553       249 001635       250 001644       253 001730       261 002012
    262 002040       266 002126       269 002210       272 002220       274 002222       276 002225       277 002231
    279 002232       282 002314       287 002375       291 002446       292 002474       296 002562       302 002644
    303 002674       307 002762       311 003044       314 003047       315 003074       316 003076       319 003162
    325 003244       326 003255       328 003266       330 003322       335 003323       336 003325       337 003330
    338 003332       339 003375       341 003377       342 003404       343 003407       345 003410       347 003437
    348 003461       350 003463       351 003465       353 003466       355 003503       357 003520       358 003522
    359 003525       360 003527       361 003531       363 003532       364 003535       365 003537       367 003541
    370 003621       373 003701       374 003702       380 003703       382 003711


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
