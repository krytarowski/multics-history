	COMPILATION LISTING OF SEGMENT absentee_utility_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1028.4 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       14*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
       15*     Correct error message documentation.
       16*  2) change(86-05-20,Gilcrease), approve(86-05-22,MCR7370),
       17*     audit(86-07-07,Fawcett), install(86-06-30,MR12.0-1082):
       18*               Implement -truncate absout files, SCP6296.
       19*  3) change(86-05-20,Lippard), approve(85-12-30,MCR7326),
       20*     audit(86-10-27,GDixon), install(86-10-28,MR12.0-1200):
       21*     Modified on 7 November 1985 (above date given to satisfy picky hcom)
       22*     by Jim Lippard to add check_queue_access.
       23*  4) change(87-04-26,GDixon), approve(87-07-12,MCR7741),
       24*     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
       25*      A) Upgraded for change to answer_table.incl.pl1 and
       26*         user_table_entry.incl.pl1.
       27*      B) Replace calls to lg_ctl_$reset with user_table_mgr_$reset. (dsa 214)
       28*  5) change(87-05-14,GDixon), approve(87-07-12,MCR7741),
       29*     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
       30*     Use constants to set ute.tag.
       31*  6) change(87-05-20,Lippard), approve(87-07-12,MCR7709),
       32*     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
       33*     Modified to null adp after termination.
       34*  7) change(87-07-12,GDixon), approve(87-07-12,MCR7741),
       35*     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
       36*      A) Change cleanup handler to reset the UTE, rather than just freeing
       37*         args associated with it.  The user_table_mgr_$reset will free the
       38*         args.
       39*      B) Remove cleanup window when allocating the args by storing ptr to arg
       40*         storage directly in the UTE.
       41*      C) Change abs_run proc to reset the UTE if the operator-specified job
       42*         is not found.
       43*      D) Since user_table_mgr_$reset now does the arg freeing, remove the
       44*         free_args proc.
       45*  8) change(87-07-28,GDixon), approve(87-07-28,MCR7741),
       46*     audit(87-07-28,Brunelle), install(87-08-04,MR12.1-1055):
       47*     Remove hardcoded SysDaemon & SysAdmin access to submit proxy abs jobs.
       48*     (phx19578)
       49*  9) change(88-02-11,Parisek), approve(88-02-11,MCR7849),
       50*     audit(88-03-23,Lippard), install(88-07-13,MR12.2-1047):
       51*     Add code for filling in UTE elements for new absentee request structure
       52*     elements (version 6) SCP6367.
       53*                                                   END HISTORY COMMENTS */
       54 
       55 /* format: style4 */
       56 absentee_utility_: proc (up, a_arg_ptr, a_code);
       57 
       58 /* ABSENTEE_UTILITY_ - utility procedure for the absentee user manager.
       59*
       60*   This program is the only answering service program which manipulates the absentee message segments.
       61*   Its main entry point is called from absentee_user_manager_ (AUM) to attempt to start another absentee.
       62*
       63*   This program maintains a database (absentee_data) in the system directory, listing all requests read from
       64*   the queues and not yet disposed of. These include running requests, and those that have been deferred for any reason.
       65*   Comments at the beginning of abs_data.incl.pl1 describe the structure of this database,
       66*   and the management of it by this program.
       67*
       68*   As of the MR7.0 rewrite, this procedure consists of the following sections, in the order shown:
       69*   - declarations
       70*   - main entry point
       71*   - additional entry points, in alphabetic order
       72*   - internal procedures, in alphabetic order
       73*   - include files, in alphabetic order
       74*   - message documentation 
       75*
       76*
       77*   Modified 3/22/72 by Dennis Capps
       78*   Modified 750404 by PG for AIM checks
       79*   Modified August 1977 by D. Vinograd to fix proxy bug and by T. Casey to get it to compile with the new improved compiler.
       80*   Modified April 1978 by T. Casey for new absentee request format, and many new features.
       81*   Modified November 1978 by T. Casey for MR7.0 absentee control parameters. An extensive rewrite was required.
       82*   Modified March 1979 by T. Casey for MR7.0a to deal with suspended absentee jobs.
       83*   Modified March 1980 by Tom Casey to add metering.
       84*   Modified January 1981 by Benson I Margulies for user proxy acs.
       85*   Modified February 1981 by Tom Casey to un-format_pl1 Benson's changes. Please, nobody ever do that again...
       86*   Modified June 1981 by T. Casey for MR9.0 to make absentee load control more efficient,
       87*   .   by remembering group and UserID in absentee_data, and not trying to log in any more jobs
       88*   .   from a group, project, or user, whose job was just deferred by load control.
       89*   Modified Spetember 1981 by E. N. Kittlitz to remove User_proxy.acs support.
       90*   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
       91*   Modified December 1981, E. N. Kittlitz.  put defer_channel into absentee_user_table
       92*   Modified April 1982, E. N. Kittlitz.  New AS initialization. bugfixes.
       93*   Modified 1985-01-15 by E. Swenson for new location of admin acs segments.
       94*   Modified 1985-04-19 by E. Swenson to fix any other handler.
       95**/
       96 
       97 
       98 /* parameters */
       99 dcl  a_code fixed bin (35);
      100 dcl  up ptr;					/* parameter - pointer to absentee user table entry */
      101 dcl  a_arg_ptr ptr;					/* pointer to abs_args structure, used by abs command */
      102 dcl  a_asr_sender_ptr ptr;				/* pointer to access info for process cancelling request */
      103 dcl  a_ute_ptr ptr;					/* pointer to user table entry */
      104 
      105 /* based */
      106 
      107 dcl  system_area area (1048) based (areap);
      108 dcl  lengths (number_of_arguments) based fixed bin aligned; /* lens of args to abs */
      109 dcl  xstring char (length_of_arguments) based aligned;	/* string of args to abs */
      110 
      111 
      112 
      113 /* automatic */
      114 
      115 dcl  search_code fixed bin (35);			/* used by main loop. do not use anywhere else */
      116 dcl  code fixed bin (35);				/* error code for internal use */
      117 dcl  lc_code fixed bin (35);				/* load_ctl_'s reason for deferring a job */
      118 dcl  queue_index fixed bin;				/* index of current message segment */
      119 dcl  queue fixed bin;				/* number of queue now being processed */
      120 dcl  list_searched fixed bin;				/* list being searched: cput, ready, or queue */
      121 dcl  aix fixed bin;					/* index of current list entry */
      122 dcl  next_aix fixed bin;				/* index of next entry on list */
      123 dcl  ii fixed bin;					/* A temporary */
      124 dcl  time_now fixed bin (71);				/* current time */
      125 dcl  length_of_arguments fixed bin;			/* information on arguments from request */
      126 dcl  number_of_arguments fixed bin;
      127 dcl  request_found bit (1) aligned;			/* turned on if we find a request that can be logged in */
      128 dcl  abort_label automatic label variable;		/* where to go if infinite loop in list searching */
      129 dcl  loop_limit fixed bin;				/* counter to detect infinite loops in list searching */
      130 dcl  ev_calls_masked bit (1) aligned;			/* remember if we need to unmask ev calls on cleanup */
      131 dcl  ctl_wakeup bit (1) aligned;			/* to remember which kind of wakeup to send: login or aum_ctl */
      132 
      133 dcl  p ptr;					/* not used, but required by compiler to avoid warning msg */
      134 
      135 dcl  has_access bit (1) aligned;			/* if user has access to bump absentee */
      136 dcl  ext_mode bit (36) aligned;			/* user's extended access on queue */
      137 dcl  has_o_permission bit (1) aligned;			/* user has own on queue */
      138 dcl  has_d_permission bit (1) aligned;			/* user has delete on queue */
      139 dcl  has_ring1_priv bit (1) aligned;			/* user has ring1 privilege */
      140 dcl  user char (32);				/* user ID */
      141 dcl  person char (22);				/* person ID */
      142 dcl  project char (9);				/* project ID */
      143 dcl  authorization bit (72) aligned;			/* AIM authorization */
      144 dcl  anonymous_user bit (1) aligned;			/* an anonymous user */
      145 
      146 dcl  abs_arg_ptr ptr;				/* copy of a_arg_ptr, pointer to abs command arg structure */
      147 
      148 dcl  found bit (1) aligned;				/* on if found a request in defer list when timer goes off */
      149 
      150 dcl  1 return_args aligned,
      151        2 reqp ptr aligned,				/* pointer to message which is put in area */
      152        2 len fixed bin (18) aligned,			/* length of message in bits */
      153        2 sender char (32) aligned,			/* process group id of sender of message */
      154        2 ring fixed bin aligned,			/* validation level of sender */
      155        2 mess_id bit (72) aligned,			/* message id */
      156        2 sender_authorization bit (72) aligned,
      157        2 access_class bit (72) aligned;
      158 
      159 dcl  1 acl (3) aligned,				/* structure used to set access */
      160        2 access_name char (32),
      161        2 access bit (36),
      162        2 ex_access bit (36),
      163        2 status fixed bin (35);
      164 
      165 dcl  based_mess_id fixed bin (71) based (addr (cur_message_id)); /* for date_time_ call */
      166 
      167 dcl  cur_message_id bit (72) aligned;			/* id of current msg, for incremental read */
      168 
      169 /* Stuff used for remembering that there was an error in a request, and sending the user a message about it */
      170 
      171 dcl  date char (16);				/* room for yy/mm/dd hhmm.m */
      172 dcl  rqid char (19);
      173 dcl  short char (8);
      174 dcl  long char (100);
      175 dcl  reason char (160) varying;
      176 dcl  user_message char (200);
      177 
      178 dcl  message_in_error bit (1) aligned;			/* on if any error found in request */
      179 dcl  error (10) bit (1) aligned;
      180 dcl  message_error_code fixed bin (35);
      181 
      182 /* Conditions */
      183 
      184 dcl  any_other condition;
      185 dcl  cleanup condition;
      186 
      187 /* entries, in alphabetic order */
      188 
      189 dcl  as_any_other_handler_$no_cleanup entry (char (*), label);
      190 dcl  (as_meter_$enter, as_meter_$exit) entry (fixed bin);
      191 dcl  absentee_utility_$timer_rang entry;
      192 dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      193 dcl  aim_check_$equal entry (bit(72) aligned, bit(72) aligned) returns(bit(1) aligned);
      194 dcl  as_dump_ entry (char (*));
      195 dcl  available_slots_ entry (fixed bin, fixed bin, (4) fixed bin, (4) fixed bin) returns (fixed bin);
      196 dcl  convert_status_code_ entry (fixed bin (35), char (8), char (100));
      197 dcl  date_time_ entry (fixed bin (71), char (*));
      198 dcl  freen_ entry (ptr);
      199 dcl  get_system_free_area_ entry () returns (ptr);
      200 dcl  hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      201 dcl  hcs_$get_user_access_modes entry (char (*), char (*), char (*), fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (35));
      202 dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
      203 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      204 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      205 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      206 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
      207 dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      208 dcl  ioa_$rsnnl entry options (variable);
      209 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
      210 dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
      211 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
      212 dcl  ipc_$mask_ev_calls entry (fixed bin (35));
      213 dcl  ipc_$unmask_ev_calls entry (fixed bin (35));
      214 dcl  match_request_id_ entry (fixed bin (71), char (*)) returns (bit (1) aligned);
      215 dcl  match_star_name_ entry (char (*), char (*), fixed bin (35));
      216 dcl  message_segment_$close entry (fixed bin, fixed bin (35));
      217 dcl  message_segment_$create entry (char (*), char (*), fixed bin (35));
      218 dcl  message_segment_$delete_index entry (fixed bin, bit (72) aligned, fixed bin (35));
      219 dcl  message_segment_$incremental_read_index entry (fixed bin, ptr, bit (2) aligned, bit (72) aligned, ptr, fixed bin (35));
      220 dcl  message_segment_$ms_acl_add entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      221 dcl  message_segment_$open entry (char (*), char (*), fixed bin, fixed bin (35));
      222 dcl  message_segment_$read_index entry (fixed bin, ptr, bit (1) aligned, ptr, fixed bin (35));
      223 dcl  message_segment_$update_message_index entry (fixed bin, fixed bin (18) aligned, bit (72) aligned, ptr, fixed bin (35));
      224 dcl  parse_resource_desc_ entry (char (*) aligned, ptr, ptr, ptr, fixed bin (35));
      225 dcl  rcp_sys_$cancel_id entry (fixed bin (71), char (*), fixed bin (35));
      226 dcl  request_id_ entry (fixed bin (71)) returns (char (19));
      227 dcl  resource_control_$reserve entry (ptr, ptr, bit (72) aligned, bit (1) aligned, fixed bin (35));
      228 dcl  send_mail_$access_class entry (char (*), char (*), ptr, bit (72), fixed bin (35));
      229 dcl  sys_log_ entry options (variable);
      230 dcl  sys_log_$error_log entry options (variable);
      231 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
      232 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      233 dcl  user_table_mgr_$reset entry (ptr);
      234 
      235 /* builtins */
      236 
      237 dcl  (addr, after, before, bit, clock, copy, currentsize, divide, hbound, index, lbound, length,
      238      max, null, rtrim, string, substr, unspec, verify) builtin;
      239 
      240 /* external static */
      241 
      242 dcl  as_error_table_$proj_max ext fixed bin (35);
      243 dcl  error_table_$bad_segment ext fixed bin (35);
      244 dcl  error_table_$device_limit_exceeded ext fixed bin (35);
      245 dcl  error_table_$messages_deferred ext fixed bin (35);
      246 dcl  error_table_$messages_off ext fixed bin (35);
      247 dcl  error_table_$no_e_permission fixed bin (35) ext static;
      248 dcl  error_table_$no_message ext fixed bin (35);
      249 dcl  error_table_$reservation_failed ext fixed bin (35);
      250 dcl  error_table_$resource_unknown ext fixed bin (35);
      251 dcl  sys_info$max_seg_size ext fixed bin (35);
      252 
      253 /* internal static variables */
      254 
      255 dcl  absentee_ename (-1:4) char (32) int static;		/* entry names of absentee message segments */
      256 dcl  adp ptr int static init (null);			/* pointer to absentee data */
      257 dcl  areap ptr int static init (null);			/* ptr to area that requests are read into */
      258 dcl  queue_indices (-1:4) fixed bin int static init ((6) 0);/* indices of message segments containing abs requests */
      259 dcl  resource_timer_set bit (1) aligned int static init (""b); /* "1"b if timer is for resource rather than deferred job */
      260 dcl  static_alarm_time fixed bin (71) int static init (0);	/* time when alarm timer is set to go off */
      261 
      262 /* internal static constants */
      263 
      264 dcl  ABS_VER_4 fixed bin (17) init (4) static options (constant);
      265 						/* a request_version of 4 means that this abs was queued under MR11. */
      266 						/* Any abs queued under MR12 will be version 5. */
      267 dcl  ABS_VER_5 fixed bin (17) init (5) static options (constant);
      268 						/* a request_version of 5 means that this abs was queued under MR12.1 */
      269 						/* Any abs queued under MR12.2 will be version 6. */
      270 dcl  QERR_MAX fixed bin int static options (constant) init (3); /* drop queue after 3 consecutive read errors */
      271 dcl  MAX_QUEUE fixed bin int static options (constant) init (4); /* Maximum abs queue. PDT must change to make bigger */
      272 dcl  const1 fixed bin (35) int static options (constant) init (59999999); /* constants used for rounding */
      273 dcl  const2 fixed bin (35) int static options (constant) init (60000000); /* time up to nearest minute */
      274 dcl  LEGAL char (95) int static options (constant) init	/* Printables except PAD, semicolon, but with BS */
      275 	(" !""#$%&'()*+,-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
      276 dcl  NEVER fixed bin (71) int static options (constant) init (1f52b); /* one more than largest possible clock value */
      277 dcl  NO_QUEUE fixed bin int static options (constant) init (-9); /* used as q number argument when no current q is defined */
      278 
      279 dcl  err_msg (2:10) char (28) int static options (constant) init (
      280 	"invalid request version",			/* 2 */
      281 	"no proxy permission",			/* 3 */
      282 	"invalid person name",			/* 4 */
      283 	"invalid project name",			/* 5 */
      284 	"invalid absin pathname",			/* 6 */
      285 	"invalid absout pathname",			/* 7 */
      286 	"invalid resource description",		/* 8 */
      287 	"invalid argument string",			/* 9 */
      288 	"inconsistent request format");		/* 10 */
      289 
      290 dcl  deferral_reasons (7) char (24) int static options (constant) init (
      291 	"by operator",
      292 	"indefinitely by operator",
      293 	"- resources unavailable",
      294 	"because of cputime limit",
      295 	"because of queue limit",
      296 	"because of user limit",
      297 	"by load control");
      298 
      299 dcl  FORWARD bit (2) aligned int static options (constant) init ("01"b);
      300 dcl  REREAD bit (2) aligned int static options (constant) init ("00"b);
      301 dcl  BACKWARD bit (2) aligned int static options (constant) init ("10"b);
      302 
      303 dcl  absentee_data_base char (32) int static options (constant) init
      304 	("absentee_data");				/* name of segment used for internal table */
      305 dcl  name char (17) int static options (constant) init
      306 	("absentee_utility_");			/* name of procedure - for error messages */
      307 dcl  CPUT_LIST fixed bin int static options (constant) init (1); /* values for list_searched */
      308 dcl  READY_LIST fixed bin int static options (constant) init (2);
      309 dcl  QUEUE_LIST fixed bin int static options (constant) init (3);
      310 dcl  ONE fixed bin int static options (constant) init (1);
      311 dcl  MANY fixed bin int static options (constant) init (2);
      312 dcl  DEFER fixed bin int static options (constant) init (1);
      313 dcl  RELEASE fixed bin int static options (constant) init (2);
      314 dcl  RUN fixed bin int static options (constant) init (3);
      315 dcl  USER_LIMIT fixed bin int static options (constant) init (1);
      316 dcl  PROJECT_LIMIT fixed bin int static options (constant) init (2);
      317 dcl  GROUP_LIMIT fixed bin int static options (constant) init (3);
      318 dcl  TRUE bit (1) aligned int static options (constant) init ("1"b);
      319 dcl  FALSE bit (1) aligned int static options (constant) init (""b);
      320 
      321 /* INCLUDE FILES are at the end, after all the code, but before the message documentation */
      322 
      323 /* MAIN ENTRY POINT absentee_utility_ proc (up, a_arg_ptr, a_code)  MAIN ENTRY POINT */
      324 
      325 /* Initialize */
      326 
      327           call setup;				/* init automatic variables */
      328 	abort_label = au_abort;			/* where to go if fault, or infinite loop in list searching */
      329 	call as_meter_$enter (AU_METER);		/* meter the cpu time and paging used by this procedure */
      330 	lc_code = a_code;				/* load control deferral reaosn might be in a_code */
      331 	a_code = 0;				/* clear any garbage from return code */
      332 	utep = up;				/* copy pointer to absentee user table entry */
      333 	abs_arg_ptr = a_arg_ptr;			/* and ptr to argument structure */
      334 	time_now = clock ();			/* get current time, to decide whether to run deferred requests */
      335 	resource_desc_ptr, resource_res_ptr = null;	/* declared in reservation include file, not init (null) */
      336 	on cleanup call cleaner_up;			/* to free allocated storage in case of problems */
      337 
      338 /* Decide whether this is a continuation of a sequence of calls from AUM, in which case we should resume
      339*   our search for a request that can log in, from the point where we left off in the last call,
      340*   or whether this is the beginning of a new sequence, in which case we should start our search from the top. */
      341 
      342 	if ^ute.abs_run then			/* unless we're here because of an operator abs run command,
      343*						   in which case this has nothing to do with a sequence */
      344 	     if ^autbl.aum_ctl then do;		/* if AUM wants us to start from the top */
      345 		absentee_data.last_rsc (*) = 0;	/* clear saved resource list indices */
      346 						/* see comment in find_eligible_ready for further explanation */
      347 		absentee_data.rebuilding = ""b;	/* clear it, in case it was turned on by a rebuild */
      348 		autbl.aum_ctl = "1"b;		/* AUM turns it off when going blocked with no more work to do */
      349 	     end;
      350 
      351 /* First, see if AUM is returning a job to us because load control said "not now" to it. */
      352 
      353 	if ute.login_result = 2 then do;		/* 2 means "not now, but try again later" to an absentee job */
      354 	     call search_skip_for_aute (code);		/* locate skip list entry for request described by aute */
      355 	     if code = 0 then do;			/* if we found it */
      356 		call thread_resource;		/* thread it into the resource list */
      357 		abs_info.waiting_for_load_ctl = "1"b;	/* remember which kind of resource it's waiting for */
      358 		abs_info.deferral_logged = ute.uflags.deferral_logged; /* remember if we've logged the deferral once */
      359 
      360 		abs_info.group = ute.group;		/* remember group, for lc list */
      361 		if ute.failure_reason = 1 then	/* lg_ctl_ said no */
      362 		     abs_info.lc_reason = USER_LIMIT;	/* remember deferral reason, for lc_list */
      363 		else				/* load_ctl_ said no */
      364 		     if lc_code = as_error_table_$proj_max then /* could be either project limit */
      365 		     abs_info.lc_reason = PROJECT_LIMIT;
      366 		else abs_info.lc_reason = GROUP_LIMIT;	/* or group limit */
      367 		call thread_lc;			/* thread entry onto end of lc list */
      368 
      369 		if ute.reservation_id ^= 0 then do;	/* if it had a resource reservation, cancel it */
      370 		     call rcp_sys_$cancel_id (ute.reservation_id,
      371 			rtrim (ute.person) || "." || rtrim (ute.project) || ".*", code);
      372 		     if code ^= 0 then
      373 			call sys_log_$error_log (SL_LOG_SILENT, code, name, "Attempting to cancel reservation ^a for ^a.^a (^a)",
      374 			     request_id_ (ute.reservation_id), ute.person, ute.project, ute.input_seg);
      375 		end;
      376 
      377 /* Rewrite message in queue to inform user of deferral and reason for it. */
      378 
      379 		call read_msg (REREAD, ute.message_id, code);
      380 		if code = 0 then do;
      381 		     request.state = STATE_DEFERRED;
      382 		     unspec (request.abs_status_flags) = ""b; /* clear any previous flags */
      383 		     if ute.failure_reason = 3 then	/* 3 means load_ctl_ said no */
      384 			request.load_control = "1"b;
      385 		     else if ute.failure_reason = 1 then/* 1 means lg_ctl_ said no */
      386 			request.user_limit = "1"b;	/* and he only says no if user limit would be exceeded */
      387 		     call rewrite_msg;
      388 		     call notify_deferral;		/* send user a message if so requested and we haven't already */
      389 		     call free_req;			/* free storage that request was read into */
      390 		end;
      391 		else call sys_log_$error_log (SL_LOG_SILENT, code, name,
      392 			"While reading message ^24.3b from ^a.^a (^a) to be rewritten.",
      393 			ute.message_id, ute.person, ute.project, ute.input_seg);
      394 	     end;
      395 	     else call sys_log_$error_log (SL_LOG_SILENT, code, name, "Searching queue ^d skip list for ^a.^a (^a)",
      396 		     queue, ute.person, ute.project, ute.input_seg);
      397 
      398 	     call user_table_mgr_$reset (utep);		/* clear out the user table entry before re-using it */
      399 	end;
      400 
      401 /* Now, try to find a job to log in */
      402 
      403 	request_found = ""b;			/* gets turned on if we find one */
      404 
      405 	if ute.abs_run then				/* if we were told which job to run */
      406 	     call abs_run;				/* go find it */
      407 	else do queue = -1 to autbl.last_queue_searched	/* else search all active queues */
      408 		while (^request_found);		/* until we find a request to run */
      409 
      410 	     call setup_queue;			/* see if we really want to search this one;
      411*						   if we do, set up for it */
      412 	     search_code = 0;
      413 	     if queue_index > 0 then			/* if the setup of the queue succeeded */
      414 		do while (^request_found & search_code = 0); /* search queue until we find a request or hit end of it */
      415 		call get_next_request (search_code);	/* get next request from this queue */
      416 		if search_code = 0 then		/* if there was one */
      417 		     call decode_request;		/* see if it is suitable for logging in now */
      418 		if ^request_found then		/* if it is, request_found is turned on */
      419 		     call user_table_mgr_$reset (utep);	/* if it isn't, clear user table entry before re-using it */
      420 	     end;					/* end inner loop thru one queue */
      421 	end;					/* end outer loop over all queues */
      422 
      423 	if ^request_found then			/* if there's no job that can be run now */
      424 au_abort:
      425 	     a_code = error_table_$no_message;		/* tell AUM */
      426 
      427 	abort_label = au_return;
      428 	call as_meter_$exit (AU_METER);		/* turn off the meter before we return */
      429 au_return:
      430 	return;					/* THIS IS THE ONLY RETURN FROM THE MAIN ENTRY POINT */
      431 
      432 /* ADDITIONAL ENTRY POINTS, IN ALPHABETIC ORDER */
      433 
      434 
      435 abs_defer: entry (up);				/* called by operator command abs defer */
      436 
      437 	call setup;				/* init automatic variables */
      438 	abort_label = abs_defer_abort;		/* where to go if fault, or infinite loop in skip list search */
      439 	abs_arg_ptr = up;
      440 	call search_queues (MANY, DEFER);
      441 abs_defer_abort:
      442 	return;
      443 
      444 /* ***** ***** */
      445 
      446 abs_release: entry (up, release_count);			/* called by operator command abs release */
      447 
      448 	call setup;				/* init automatic variables */
      449 dcl  release_count fixed bin;
      450 
      451 	abort_label = abs_release_abort;		/* where to go if fault, or infinite loop in skip list search */
      452 	abs_arg_ptr = up;
      453 	call search_queues (MANY, RELEASE);
      454 abs_release_abort:
      455 	return;
      456 
      457 /* ***** ***** */
      458 
      459 au_send_ctl_wakeup: entry;				/* to send "aum_ctl" wakeup */
      460 
      461 	ctl_wakeup = "1"b;				/* set switch (which is init (""b)) and fall thru to next entry */
      462 
      463 au_send_wakeup: entry;				/* to allow other procs to call our send_abs_wakeup subroutine */
      464 
      465 	call setup;				/* init automatic variables */
      466 	abort_label = au_send_wakeup_abort;		/* where to go if fault, or infinite loop in list searching */
      467 	call send_abs_wakeup;
      468 au_send_wakeup_abort:
      469 	return;
      470 
      471 check_queue_access: entry (a_ute_ptr, a_asr_sender_ptr) returns (bit (1) aligned);
      472 
      473 /* This entry is called by AUM to make sure a user has appropriate access
      474*   to an absentee queue in order to bump a running absentee. */
      475 
      476 	call setup;				/* init automatic variables */
      477 	utep = a_ute_ptr;
      478 	as_request_sender_ptr = a_asr_sender_ptr;
      479 
      480 	has_access = "0"b;
      481 
      482 	call search_skip_for_aute (code);
      483 	if code ^= 0 then do;
      484 	     call sys_log_$error_log (SL_LOG_SILENT, code, name, "Searching queue ^d skip list for ^a.^a (^a)",
      485 		queue, ute.person, ute.project, ute.input_seg);
      486 	     return ("0"b);
      487 	end;
      488 
      489 /* Check the user's access. */
      490 	if queue_index ^= 0 then do;
      491 	     user = as_request_sender.group_id;
      492 	     call hcs_$get_user_access_modes (sysdir, absentee_ename (queue), user,
      493 		(as_request_sender.validation_level), (""b), ext_mode, code);
      494 
      495 /* If the code is ^= 0, something must be wrong, so we just don't let the user
      496*   have access. */
      497 	     if code = 0 then do;
      498 		has_d_permission = ((MSEG_D_ACCESS & ext_mode) ^= ""b);
      499 		has_o_permission = ((MSEG_O_ACCESS & ext_mode) ^= ""b);
      500 
      501 /* We allow the bump if:
      502*   a) the bumper has "d" permission on the absentee queue and is at the
      503*   same AIM authorization (or has ring1 priv).
      504*   b) the bumper is the same person or proxy person as the absentee
      505*   (and same project or proxy project for anonymous users), at
      506*   the same AIM authorization (or has ring1 priv), and has "o" permission
      507*   on the queue. */
      508 
      509 		person = before (user, ".");
      510 		project = before (after (user, "."), ".");
      511 		authorization = as_request_sender.authorization;
      512 		has_ring1_priv = addr (as_request_sender.authorization) -> aim_template.ring1;
      513 
      514 		anonymous_user = (person = "anonymous");
      515 
      516 /* case a */
      517 		if has_d_permission then
      518 		     if aim_check_$equal (authorization, ute.process_authorization)
      519 			| has_ring1_priv
      520 		     then has_access = "1"b;
      521 		     else ;
      522 
      523 /* case b */
      524 		else
      525 		     if has_o_permission then
      526 		     if (person = ute.person | person = ute.proxy_person
      527 			  | (anonymous_user & (ute.anonymous = 1)))
      528 			& (^anonymous_user | (project = ute.project | project = ute.proxy_project))
      529 			& ((aim_check_$equal (authorization, ute.process_authorization)) | has_ring1_priv)
      530 		     then has_access = "1"b;
      531 	     end;
      532 	end;
      533 
      534 	return (has_access);
      535 
      536 clear_lc_list: entry;
      537 
      538 /* This entry is called by AUM to clear the load control list, when AUM decides that it is time to
      539*   allow all requests deferred by load control to have another chance to try logging in.
      540*
      541*   The purpose of the lc list, and the logic that decides when to clear it, is to allow requests to log in
      542*   as soon as possible, but minimize the overhead involved in repeatedly trying to log requests in,
      543*   only to have them deferred by load control.
      544*
      545*   When a request is deferred because of a user limit, or a group or project limit, we know that other requests
      546*   from the same user, group, or project would also be deferred, and there is no use trying to log them in.
      547*
      548*   We put the first deferred request from a particular user, group, or project on the lc list.
      549*   Thus, the lc list serves as a list of users, groups, and projects whose requests can't log in now.
      550*
      551*   We put other requests from those users, groups, and projects on the resource list immediately, without trying
      552*   to log them in. They do have their lc_reason set, but they do not get put on the lc list.
      553*
      554*   In the initial implementation of the lc list (June 1981 for MR9.0), we clear the lc list
      555*   when we are no longer sure that it is valid. This happens whenever an absentee process logs out,
      556*   and whenever AUM gets a login wakeup with the "aum_ctl" switch off.
      557*   (See comments in AUM for an explanation of that switch.)
      558*
      559*   This policy is biased in the direction of incurring some extra overhead, in the form of
      560*   unsuccessful login attempts, in order to avoid delaying requests that could log in.
      561*
      562*   If this policy results in an insufficient reduction in overhead, a closer cooperation between load_ctl_
      563*   and the maintainer of the lc list can be implemented in a future release.
      564*   The ABS_TRYLOG meter will show the number and cost of login attempts, both successful and unsuccessful. */
      565 
      566           call setup;				/* init automatic variables */
      567 	abort_label = clear_lc_abort;			/* place to go if fault or infinite loop in list search */
      568 	loop_limit = 0;				/* initialize loop detector */
      569 
      570 	aix = absentee_data.head_lc;			/* start at head of list */
      571 	do while (aix ^= 0);			/* and stop after last one */
      572 	     aip = addr (absentee_data.entry (aix));	/* get pointer to entry */
      573 	     aix = abs_info.next_lc;			/* save index of next entry
      574*						   (will be zero if this is last entry) */
      575 	     abs_info.lc_list = ""b;			/* clear lc list indicator bit */
      576 	     abs_info.prev_lc, abs_info.next_lc = 0;	/* zero the lc threads */
      577 
      578 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
      579 	     if loop_limit > absentee_data.last then
      580 		call loop_error ("clear_lc_list", "lc", NO_QUEUE); /* goes to abort_label instead of returning */
      581 	end;
      582 
      583 	absentee_data.head_lc, absentee_data.tail_lc = 0; /* zero head and tail threads */
      584 
      585 	autbl.lc_list = ""b;			/* tell AUM that the list is empty */
      586 
      587 clear_lc_abort:
      588 	return;
      589 
      590 delete_message: entry (up);
      591 
      592 /* This entry is called whenever a running absentee job has completed. The message requesting that it be
      593*   run will be deleted from the message segment and information concerning it will be deleted from an
      594*   internal list of running jobs */
      595 
      596 
      597           call setup;				/* init automatic variables */
      598 	abort_label = dm_abort;			/* where to go if fault, or infinite loop in list searching */
      599 	utep = up;				/* copy pointer to absentee user table entry */
      600 
      601 	call search_skip_for_aute (code);		/* search skip list for this request */
      602 	if code = 0 then				/* if request was found in skip list */
      603 	     call delete_skip;			/* delete it from the list */
      604 	else call sys_log_$error_log (SL_LOG_SILENT, code, name, "Searching queue ^d skip list for ^a.^a (^a)",
      605 		queue, ute.person, ute.project, ute.input_seg);
      606 dm_abort:						/* even if the skip list search aborted */
      607 	if queue_index > 0 then			/* if we know the queue */
      608 	     call delete_msg (ute.message_id);		/* Try to delete the message */
      609 	else call sys_log_ (SL_LOG_SILENT, "^a: Unable to delete request for ^a.^a (^a); queue: ^d; index: ^d",
      610 		name, ute.person, ute.project, ute.input_seg, queue, queue_index);
      611 	return;
      612 
      613 init_au: entry (a_code);				/* initialization entry point */
      614 
      615           call setup;				/* init automatic variables */
      616 	a_code = 0;				/* clear error code to be returned */
      617 	areap = get_system_free_area_ ();		/* initialize static area pointer */
      618 
      619 	do queue = -1 to MAX_QUEUE;			/* initiate absentee message segments */
      620 
      621 /* construct name of absentee message segment */
      622 
      623 	     if queue = -1 then
      624 		absentee_ename (queue) = "absentee_foreground.ms";
      625 	     else call ioa_$rsnnl ("absentee_^d.ms", absentee_ename (queue), (0), queue);
      626 
      627 	     call message_segment_$open (sysdir, absentee_ename (queue), queue_indices (queue), code);
      628 
      629 /* if can't initiate it, try to create it - assume it got deleted */
      630 	     if code ^= 0 then do;
      631 		call sys_log_$error_log (SL_LOG, code, name, "Creating new ^a>^a", sysdir, absentee_ename (queue));
      632 
      633 		call message_segment_$create (sysdir, absentee_ename (queue), code);
      634 
      635 		if code ^= 0 then do;
      636 		     call sys_log_$error_log (SL_LOG, code, name, "Unable to create ^a>^a",
      637 			sysdir, absentee_ename (queue));
      638 		     go to setup_next_queue;
      639 		end;
      640 
      641 		acl.access_name (1) = "*.SysAdmin.*";	/* set 3 extended acls */
      642 		acl.access_name (2) = "*.SysDaemon.*";	/* in addition to *.sys_control.a set in creation */
      643 		acl.access_name (3) = "*.*.*";
      644 
      645 		acl.access (1),
      646 		     acl.access (2),
      647 		     acl.access (3) = "111"b;		/* set real modes */
      648 
      649 		acl.ex_access (1),			/* add, delete, read, own, status for */
      650 		     acl.ex_access (2) = "11111"b;	/* SysAdmin & SysDaemon */
      651 
      652 		if queue ^= 0 then			/* except for queue 0 */
      653 		     acl.ex_access (3) = "10011"b;	/* add, own, status for everyone else */
      654 		else acl.ex_access (3) = "00011"b;	/* but everyone else is denied add permission on Q 0 */
      655 
      656 /* set extended access */
      657 		call message_segment_$ms_acl_add (sysdir, absentee_ename (queue), addr (acl), 3, code);
      658 		if code ^= 0 then do;
      659 		     call sys_log_$error_log (SL_LOG, code, name, "Unable to set extended access on ^a>^a",
      660 			sysdir, absentee_ename (queue));
      661 		     go to setup_next_queue;
      662 		end;
      663 
      664 /* now try to open abs message segment */
      665 		call message_segment_$open (sysdir, absentee_ename (queue), queue_indices (queue), code);
      666 		if code ^= 0 then do;		/* give up */
      667 		     call sys_log_$error_log (SL_LOG, code, name, "Unable to open new ^a>^a",
      668 			sysdir, absentee_ename (queue));
      669 		     go to setup_next_queue;
      670 		end;
      671 	     end;
      672 setup_next_queue:
      673 	end;
      674 
      675 	call ipc_$create_ev_chn (autbl.defer_channel, code); /* create an event call channel */
      676 	if code = 0 then
      677 	     call ipc_$decl_ev_call_chn (autbl.defer_channel, absentee_utility_$timer_rang, (null), ABS_DEFER_PRIO, code);
      678 	if code ^= 0 then do;
      679 	     call sys_log_$error_log (SL_LOG_BEEP, code, name, "Error in creating defer event channel");
      680 	     a_code = code;
      681 	     return;
      682 	end;
      683 	call hcs_$initiate (sysdir, absentee_data_base, "", 0, 1, adp, code);
      684 	if adp = null then do;
      685 	     call sys_log_$error_log (SL_LOG, code, name, "Creating new ^a>^a", sysdir, absentee_data_base);
      686 	     call hcs_$make_seg (sysdir, absentee_data_base, "", 01011b, adp, code);
      687 	     if adp = null then do;			/* Something is wrong */
      688 		call sys_log_$error_log (SL_LOG_BEEP, code, name, "Unable to create ^a>^a",
      689 		     sysdir, absentee_data_base);
      690 		a_code = code;
      691 		return;
      692 	     end;
      693 
      694 	     acl (1).access_name = "*.SysDaemon.*";
      695 	     acl (1).access = "1011"b;
      696 	     acl (1).ex_access = "0"b;
      697 	     acl (2).access_name = "*.*.*";
      698 	     acl (2).access = "0"b;
      699 	     acl (2).ex_access = "0"b;
      700 	     call hcs_$add_acl_entries (sysdir, absentee_data_base, addr (acl), 2, code);
      701 	     if code ^= 0 then do;
      702 		call sys_log_$error_log (SL_LOG, code, name, "Unable to set access on ^a>^a",
      703 		     sysdir, absentee_data_base);
      704 		a_code = code;
      705 	     end;
      706 	end;
      707 	call hcs_$truncate_seg (adp, 0, code);		/* truncate absentee data - zeroing out previous abs data */
      708 	if code ^= 0 then a_code = code;
      709 
      710 	absentee_data.version = ABS_DATA_version_2;	/* set current structure version */
      711 
      712 	return;
      713 
      714 mark_request_running: entry (up);
      715 
      716 /* This entry is called by AUM after a request is logged in, to rewrite the request, changing its state to running. */
      717 
      718           call setup;				/* init automatic variables */
      719 	utep = up;				/* copy ptr to user table entry */
      720 
      721 	call get_queue_from_aute;			/* get queue number from aute */
      722 
      723 	if queue_index ^= 0 then do;			/* if queue information is ok, continue */
      724 
      725 	     call read_msg (REREAD, ute.message_id, code);
      726 	     if code = 0 then do;
      727 		request.state = STATE_RUNNING;
      728 		unspec (request.abs_status_flags) = ""b;
      729 		call rewrite_msg;			/* rewrite message with new state and reason */
      730 		call free_req;			/* free storage that request was read into */
      731 	     end;
      732 	     else call sys_log_$error_log (SL_LOG_SILENT, code, name, "While reading message ^24.3b to be rewritten.", ute.message_id);
      733 	end;
      734 
      735 	return;
      736 
      737 set_resource_timer: entry;
      738 
      739 /* entry point called by absentee_user_manager_ to tell us that there are slots available
      740*   to the jobs waiting for resources, and we should set a timer and check periodically
      741*   to see if those resources have become available, even though we are not logging
      742*   jobs in and out at the moment. */
      743 
      744 	if resource_timer_set then			/* if the resource timer is already set */
      745 	     return;				/* leav it - don't reset it for a later time */
      746           call setup;				/* init automatic variables */
      747 	time_now = clock ();
      748 	call set_rsc_timer (time_now + installation_parms.rsc_timer_seconds * 1000000);
      749 
      750 	return;
      751 
      752 term_au: entry;					/* entry point which terminates absentee message segments */
      753 
      754           call setup;				/* init automatic variables */
      755 	do queue = -1 to MAX_QUEUE;			/* terminate absentee message segments */
      756 	     if queue_indices (queue) ^= 0 then do;
      757 		call message_segment_$close (queue_indices (queue), code);
      758 		if code ^= 0 then call sys_log_$error_log (SL_LOG, code, name,
      759 			"Closing ^a>^a", sysdir, absentee_ename (queue));
      760 		queue_indices (queue) = 0;
      761 	     end;
      762 	end;
      763 
      764 	call reset_alarm_timer;			/* reset deferred request alarm timer */
      765 	call ipc_$delete_ev_chn (autbl.defer_channel, code); /* delete timer event channel */
      766 	if adp ^= null then do;
      767 	     call hcs_$terminate_noname (adp, code);	/* terminate absentee data base */
      768 	     if code ^= 0 then
      769 		call sys_log_$error_log (SL_LOG, code, name, "Unable to terminate ^a>^a",
      770 		     sysdir, absentee_data_base);
      771 	     else adp = null;
      772 	end;
      773 	return;
      774 
      775 timer_rang: entry;					/* called when the deferred-request timer goes off */
      776 
      777           call setup;				/* init automatic variables */
      778 dcl  was_rsc_timer bit (1) aligned;
      779 
      780 	abort_label = tr_abort;			/* where to go if fault, or infinite loop in list searching */
      781 	call as_meter_$enter (AU_METER);
      782 	resource_desc_ptr, resource_res_ptr = null;	/* so cleanup handler won't try to free what they point to */
      783 
      784 	on condition (cleanup)
      785 	     call cleaner_up;			/* establish cleanup handler */
      786 
      787 	on condition (any_other)
      788 	     call as_any_other_handler_$no_cleanup ("absentee_utility_",
      789 		abort_label);
      790 
      791 	was_rsc_timer = resource_timer_set;		/* remember which kind of timer it was */
      792 	static_alarm_time = 0;			/* there is currently no timer set, since it just went off */
      793 	call ipc_$mask_ev_calls (code);		/* mask event calls until list is updated */
      794 	ev_calls_masked = "1"b;			/* remember that we did this, in case of cleanup */
      795 	found = "0"b;				/* to see if we find any request whose time has arrived */
      796 	time_now = clock ();			/* read clock only once */
      797 
      798 	loop_limit = 0;
      799 	do aix = absentee_data.head_defer		/* start at head of defer list */
      800 	     repeat next_aix			/* and keep going */
      801 	     while (aix ^= 0			/* until we hit the end of the list */
      802 	     & absentee_data.entry (aix).time <= time_now); /* or find an entry whose time is in the future */
      803 	     aip = addr (absentee_data.entry (aix));	/* get pointer to entry whose time has arrived */
      804 	     found = "1"b;				/* remember that we found one */
      805 	     next_aix = abs_info.next_defer;		/* remember index of next entry on defer list */
      806 	     queue = abs_info.queue;			/* pull queue info out of list entry, for convenient reference */
      807 	     queue_index = queue_indices (queue);
      808 	     call thread_ready;			/* put request on ready list */
      809 	     call delete_defer;			/* and delete it from defer list */
      810 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
      811 	     if loop_limit > absentee_data.last then
      812 		call loop_error ("timer_rang", "defer", NO_QUEUE); /* goes to abort_label instead of returning */
      813 	end;
      814 
      815 	if aix ^= 0 then				/* if there are still deferred requests */
      816 	     call set_defer_timer (absentee_data.entry (aix).time); /* set timer for first one */
      817 
      818 	if found | was_rsc_timer then			/* if we found a request or we need to try for a resource */
      819 	     call send_abs_wakeup;			/* send a wakeup to AUM */
      820 	else call sys_log_ (SL_LOG_SILENT, "^a: Timer rang and no deferred request found.", name);
      821 tr_abort: call ipc_$unmask_ev_calls (code);		/* let event calls take hold again */
      822 	abort_label = tr_return;
      823 	call as_meter_$exit (AU_METER);
      824 tr_return:
      825 	return;
      826 
      827 /* INTERNAL PROCEDURES, IN ALPHABETIC ORDER */
      828 
      829 abs_run: proc;
      830 
      831 /* find request specified by abs_args, decode it, and return it to the main loop */
      832 
      833 	call search_queues (ONE, RUN);		/* search the queues for it */
      834 
      835 	if request_found then do;			/* if we found it */
      836 	     request_found = ""b;			/* gets turned back on if we decide to run it */
      837 	     call search_skip_for_queue (code);		/* see if it has a skip list entry */
      838 	     if code = 0 then do;			/* if it does, investigate further */
      839 		if abs_info.cput_list then call delete_cput;
      840 		else if abs_info.ready_list then call delete_ready;
      841 		else if abs_info.defer_list then call delete_defer;
      842 		else do;				/* it must be running */
      843 		     call sys_log_ (SL_TYPE, "abs_run: request ^a>^a ^a is already running,",
      844 			request.dirname, request.ename, request_id_ (request.msg_time));
      845 		     call free_req;			/* free the storage we read the request into */
      846 		     return;			/* return with request_found off */
      847 		end;
      848 	     end;
      849 	     else call create_run;			/* not on skip list; put on run list (beginning of skip list) */
      850 
      851 	     call decode_request;			/* decode the request and turn on request_found if it's ok */
      852 
      853 	     if ^request_found then
      854 	        call user_table_mgr_$reset (utep);
      855 
      856 	end;
      857 
      858 	return;
      859 
      860      end abs_run;
      861 
      862 check_for_badseg: proc (ec, repeat_sw, caller);
      863 
      864 /* Check error code returned by the message segment primitives.
      865*   Report all errors to operator. Count consecutive errors on each queue and drop queue if too many.
      866*   Tell caller to retry the operation if the code indicates that the message segment just got salvaged. */
      867 
      868 dcl  ec fixed bin (35);
      869 dcl  repeat_sw bit (1) aligned;
      870 dcl  caller char (*);
      871 
      872 	repeat_sw = ""b;
      873 	if ec = 0 | ec = error_table_$no_message then
      874 	     autbl.qerr (queue) = 0;			/* clear count of consecutive errors */
      875 
      876 	else do;
      877 	     if queue < -1 | queue > MAX_QUEUE then
      878 		if autbl.debugging = 1 then		/* makeshift debugging switch */
      879 		     call as_dump_ ("absentee_utility_: software error in queue selection.");
      880 	     autbl.qerr (queue) = autbl.qerr (queue) + 1; /* count consecutive errors */
      881 	     if autbl.qerr (queue) > QERR_MAX then do;	/* > QERR_MAX consecutive errors causes queue to be dropped */
      882 		call sys_log_$error_log (SL_LOG_BEEP, ec, caller, "Dropping queue ^d ^a>^a due to ^d consecutive errors",
      883 		     queue, sysdir, absentee_ename (queue), autbl.qerr (queue));
      884 		autbl.queue_dropped (queue) = "1"b;
      885 	     end;
      886 
      887 	     else do;
      888 		call sys_log_$error_log (SL_LOG, ec, caller, "queue ^d ^a>^a", queue, sysdir, absentee_ename (queue));
      889 		if ec = error_table_$bad_segment then	/* tell caller to try again if q was salvaged */
      890 		     repeat_sw = "1"b;
      891 	     end;
      892 	     call free_req;				/* free any storage allocated by ring1 before error occurred */
      893 	end;
      894 
      895 	return;
      896 
      897      end check_for_badseg;
      898 
      899 cleaner_up: proc;
      900 
      901 /* Cleanup handler. Free allocated storage in UTE, and in local structures, and
      902*   unmask event calls if we masked them. */
      903 
      904 	call user_table_mgr_$reset (utep);
      905 	call free_req;
      906 	call free_rsc;
      907 	if ev_calls_masked then do;
      908 	     call ipc_$unmask_ev_calls (code);
      909 	     ev_calls_masked = ""b;
      910 	end;
      911 
      912 	return;
      913 
      914      end cleaner_up;
      915 
      916 create_skip: proc;
      917 
      918 /* Procedure to add an entry to the skip list. An entry is taken from the
      919*   free list, or a new one is created at the end of the array.
      920*   Input arguments: queue and cur_message_id.
      921*   Output arguments: aix is index of new entry; aip is ptr to it. */
      922 
      923 dcl  run_sw bit (1) aligned init (""b);
      924 
      925 	goto create_skip_common;
      926 
      927 create_run: entry;					/* put new entry on run list (beginning of skip list) */
      928 
      929 	run_sw = "1"b;
      930 
      931 create_skip_common:
      932 
      933 	if absentee_data.tail_free ^= 0 then do;	/* free entry exists */
      934 	     aix = absentee_data.tail_free;
      935 	     aip = addr (absentee_data.entry (aix));	/* use it */
      936 	     absentee_data.tail_free = abs_info.prev_free;/* define new tail of free list */
      937 	     abs_info.prev_free = 0;			/* clear thread value in used entry */
      938 	     abs_info.free_list = ""b;
      939 	end;
      940 
      941 	else do;					/* if no free entry exists */
      942 	     aix,
      943 		absentee_data.last = absentee_data.last + 1; /* create new one */
      944 	     if currentsize (absentee_data) > sys_info$max_seg_size then do;
      945 		call sys_log_ (SL_LOG_BEEP, "^a: ^a>^a has overflowed its limit of ^d entries.",
      946 		     name, sysdir, absentee_data_base, absentee_data.last - 1);
      947 		call suspend_absentee_processing;	/* DOES NOT RETURN */
      948 	     end;
      949 	     aip = addr (absentee_data.entry (aix));
      950 	end;
      951 
      952 	abs_info.queue = queue;			/* fill in queue and message id */
      953 	abs_info.message_id = cur_message_id;
      954 	abs_info.request_id = request.msg_time;		/* and request id */
      955 	abs_info.skip_list = "1"b;
      956 	abs_info.group = "";			/* stays blank unless request gets deferred by load_ctl_ */
      957 
      958 
      959 /* Set back thread to last entry on run or ready list. */
      960 
      961 	if run_sw then do;
      962 	     abs_info.run_list = "1"b;
      963 	     abs_info.prev_skip = absentee_data.queue_data (queue).tail_run;
      964 	end;
      965 	else abs_info.prev_skip = absentee_data.queue_data (queue).tail_skip;
      966 
      967 /* Set the forward thread, and then thread the previous entry to this one. */
      968 
      969 	if abs_info.prev_skip > 0 then do;		/* if there was a previous entry */
      970 	     abs_info.next_skip = absentee_data.entry (abs_info.prev_skip).next_skip; /* copy its forward thread */
      971 	     absentee_data.entry (abs_info.prev_skip).next_skip = aix; /* point its forward thread at this entry */
      972 	end;
      973 	else do;					/* no previous entry, so copy the head-of-list thread */
      974 	     abs_info.next_skip = absentee_data.queue_data (queue).head_skip;
      975 	     absentee_data.queue_data (queue).head_skip = aix; /* then point head of list at this entry */
      976 	end;
      977 
      978 /* Now, thread following entry to this one */
      979 
      980 	if abs_info.next_skip > 0 then		/* if following entry exists (only possible for run list) */
      981 	     absentee_data.entry (abs_info.next_skip).prev_skip = aix; /* point its back thread at current entry */
      982 
      983 /* We are threading onto the tail of one of the lists. Set the appropriate tail thread(s). */
      984 
      985 	if run_sw then
      986 	     absentee_data.queue_data (queue).tail_run = aix;
      987 	if ^run_sw | absentee_data.queue_data (queue).tail_skip = 0 then
      988 	     absentee_data.queue_data (queue).tail_skip = aix;
      989 
      990      end create_skip;
      991 
      992 decode_lc_ineligible: proc returns (bit (1) aligned);
      993 
      994 /* This procedure is called by decode_request to see if the request will be rejected by load control.
      995*   The load control test is made by another procedure (lc_will_reject) which is called by this one.
      996*   The purpose of this procedure is to detect a request that has already passed the load control test,
      997*   and return FALSE immediately, avoiding the overhead of repeating the test. Such a request can be
      998*   identified by its non-zero lc_reason field, which indicates that it was deferred by load control in the past.
      999*   We know that it would only get un-deferred and passed to decode_request if it had passed the load control test. */
     1000 
     1001 	if abs_info.lc_reason > 0 then		/* if it was previously deferred by load control */
     1002 	     return (FALSE);			/* we know it has already passed the test */
     1003 
     1004 	return (lc_will_reject ());			/* return whatever lc_will_reject returns to us */
     1005 
     1006      end decode_lc_ineligible;
     1007 
     1008 decode_request: proc;
     1009 
     1010 /* decode message and fill in structure to be returned */
     1011 
     1012 	ute.real_queue,
     1013 	     ute.queue = queue;			/* Set queue number. This is the abs flag because > 0 */
     1014 	if queue <= 0 then do;			/* if queue zero or foreground queue */
     1015 	     ute.queue = ute.queue + 1;		/* 0 => 1 since Q 0 is logically the front of Q 1;
     1016*						   -1 => 0 since foreground Q contains "interactive" jobs */
     1017 	     ute.adjust_abs_q_no = "1"b;		/* remember what we just did */
     1018 	     if queue = -1 then			/* if foreground queue */
     1019 		ute.foreground_job = "1"b;		/* remember it even more explicitly */
     1020 	end;
     1021 
     1022 	ute.uflags.deferral_logged = abs_info.deferral_logged; /* note if request's deferral was already logged */
     1023 	ute.outer_module = as_data_$abs_dim;		/* Set outer module to be used. */
     1024 	ute.message_id = cur_message_id;		/* record message id */
     1025 
     1026 /* The absentee request contains variables with refer extents.
     1027*   A request with garbage values for the extents could cause the initializer process to take faults.
     1028*   So we check the extents for validity before referencing any of those variables. */
     1029 
     1030 /* First check version of request */
     1031 
     1032 	if request.hdr_version ^= queue_msg_hdr_version_1 /* Allow old version 4 */
     1033 	     | (request.request_version ^= abs_message_version_6 & request.request_version ^= ABS_VER_5 & request.request_version ^= ABS_VER_4) then
     1034 	     call message_error (2);			/* 2 = invalid request version */
     1035 
     1036 	else do;					/* if version ok, check extents */
     1037 	     ii = divide (return_args.len + 35, 36, 17, 0); /* number of words returned from message segment */
     1038 	     if ii ^= currentsize (request)
     1039 		| ii ^= request.std_length then
     1040 		call message_error (10);		/* 10 = inconsistent request format */
     1041 	end;
     1042 
     1043 /* Fill in project name from sender's project */
     1044 
     1045 	ute.project = before (after (return_args.sender, "."), ".");
     1046 
     1047 /* Fill in person name */
     1048 
     1049 	if before (return_args.sender, ".") ^= "anonymous" then do; /* if normal user -
     1050*						   login_name from return_args.sender's name */
     1051 	     ute.person = before (return_args.sender, ".");
     1052 	     ute.anonymous = 0;
     1053 	end;
     1054 
     1055 	else do;					/* if anonymous user - login_name from message */
     1056 	     if ^message_in_error then
     1057 		ute.person = request.name;
     1058 	     ute.anonymous = 1;
     1059 	end;
     1060 
     1061 /* Copy and validate various other items from the request */
     1062 
     1063 	ute.sender = request.sender;
     1064 	ute.notify = request.notify;
     1065 	string (ute.abs_attributes) = string (request.abs_attributes);
     1066 	ute.uflags.foreground_secondary_ok = ute.abs_attributes.secondary_ok;
     1067 
     1068 	ute.tag = TAG_ABSENTEE;			/* validate_proxy will change to "p" if proxy */
     1069 
     1070 	if ute.abs_attributes.proxy & ^message_in_error then /* Submitted for someone else? */
     1071 	     call validate_proxy;			/* this will call message_error if it is bad */
     1072 
     1073 	abs_info.person = substr (ute.person, 1, length (abs_info.person)); /* copy UserID into abs_info entry */
     1074 	abs_info.project = substr (ute.project, 1, length (abs_info.project)); /* (must be done after proxy processing) */
     1075 
     1076 	if verify (ute.person, LEGAL) ^= 0 then call message_error (4); /* 4 = invalid person name */
     1077 	if verify (ute.project, LEGAL) ^= 0 then call message_error (5); /* 5 = invalid project name */
     1078 	ute.input_seg = rtrim (request.dirname) || ">" || rtrim (request.ename); /* pathname of absin segment */
     1079 	if substr (ute.input_seg, 1, 1) ^= ">" then call message_error (6); /* 6 = invalid absin pathname */
     1080 	else if verify (ute.input_seg, LEGAL) ^= 0 then call message_error (6); /* ditto */
     1081 
     1082 	if request.len_output > 0 & ^message_in_error then do; /* fill in output segment name if any given */
     1083 	     ute.output_seg = request.output_file;
     1084 	     if substr (ute.output_seg, 1, 1) ^= ">" then call message_error (7); /* 7 = invalid absout pathname */
     1085 	     else if verify (ute.output_seg, LEGAL) ^= 0 then call message_error (7); /* ditto */
     1086 	end;
     1087 	else ute.output_seg = "";
     1088 
     1089 	ute.request_id = request.msg_time;
     1090 
     1091 /* Validate the authorization that the request is to be run at. It must be
     1092*   greater than or equal to the authorization of the sender.
     1093*   If it isn't, then "upgrade" it to the authorization of the sender */
     1094 
     1095 	if ^aim_check_$greater_or_equal (request.requested_authorization,
     1096 	     return_args.sender_authorization)
     1097 	then request.requested_authorization = return_args.sender_authorization;
     1098 
     1099 	ute.process_authorization = request.requested_authorization;
     1100 
     1101 /* Fill in information on arguments */
     1102 
     1103 	number_of_arguments = request.arg_count;
     1104 	ute.arg_count = number_of_arguments;
     1105 	ute.arg_lengths_ptr = null;
     1106 	ute.args_ptr = null;
     1107 	ute.ln_args = 0;
     1108 	if number_of_arguments > 0 & ^message_in_error then do; /* If there are any */
     1109 	     length_of_arguments = request.len_args;
     1110 	     ute.ln_args = length_of_arguments;
     1111 
     1112 	     if number_of_arguments > length_of_arguments
     1113 		| length_of_arguments > (4 * request.std_length) then
     1114 		call message_error (9);		/* 9 = invalid argument string */
     1115 	     else do;
     1116 
     1117 /* Get storage for the array of arg lengths and fill it in */
     1118 		allocate lengths in (system_area) set(ute.arg_lengths_ptr);
     1119 		do ii = 1 to number_of_arguments;
     1120 		     ute.arg_lengths_ptr -> lengths (ii) =
     1121 		          request.arg_lengths (ii);
     1122 		end;
     1123 
     1124 /* Get storage for string of arguments and fill it in */
     1125 
     1126 		allocate xstring in (system_area) set (ute.args_ptr);
     1127 		ute.args_ptr -> xstring = request.args;
     1128 	     end;					/* end allocate args */
     1129 	end;					/* end there are args */
     1130 
     1131 /* Copy cpu time and deferred time */
     1132 
     1133 	ute.max_cpu_time = max (0, request.max_cpu_time); /* Validate user-specified cpu limit */
     1134 	if ute.max_cpu_time = 0 then			/* if user didn't set a limit */
     1135 	     if ute.queue > 0 then			/* if not foreground queue */
     1136 		ute.max_cpu_time = installation_parms.abs_cpu_default_limit (ute.queue); /* use background dflt */
     1137 	     else ute.max_cpu_time = installation_parms.foreground_cpu_default_limit; /* else use foreground dflt */
     1138 
     1139 	ute.deferred_time = divide (request.deferred_time + const1, /* fill in deferred time, */
     1140 	     const2, 63, 0) * const2;			/* rounded up to next minute * */
     1141 
     1142 /* Now fill in request version 6 elements; home_dir, init_proc & initial_ring */
     1143 
     1144 	if request.request_version > ABS_VER_5 then do;	/* version 6 elements */
     1145 	     if request.len_homedir > 0 & ^message_in_error then
     1146 		ute.home_dir = substr (request.home_dir, 1, request.len_homedir);
     1147 	     if request.len_initproc > 0 & ^message_in_error then do;
     1148 		ute.uflags.ip_given = "1"b;		/* initial proc given */
     1149 		ute.ip_len = request.len_initproc;
     1150 		ute.init_proc = substr (request.init_proc, 1, request.len_initproc);
     1151 	     end;
     1152 	     if request.initial_ring ^= -1 then ute.initial_ring = request.initial_ring;
     1153 						/* specified initial ring value */
     1154 	     if request.abs_attributes.no_start_up then do;
     1155 						/* specfied no_start_up */
     1156 		ute.at.nostartup = "1"b;
     1157 		ute.ur_at.nostartup = "1"b;
     1158 	     end;
     1159 	end;
     1160 		
     1161 /* Now, decide if request can run or must be deferred */
     1162 
     1163 	if ^message_in_error then do;			/* but skip it if bad request */
     1164 	     if ^ute.abs_run then do;			/* if not being ordered to run the job, treat it normally */
     1165 		if ute.deferred_time > time_now then do;
     1166 		     call defer_request_until_time;	/* put into deferred list according to its time */
     1167 		     call mark_request_deferred (""b);
     1168 		end;
     1169 		else if (request.user_deferred_indefinitely | request.operator_deferred_indefinitely) then do;
     1170 		     call defer_request_indefinitely;	/* put at end of defer list */
     1171 		     call mark_request_deferred (unspec (request.abs_status_flags));
     1172 		end;
     1173 		else if ute.queue > 0 & ute.max_cpu_time > autbl.cpu_limit (max (1, ute.queue)) then do;
     1174 		     call thread_cput;		/* put at end of cpu time list */
     1175 		     call mark_request_deferred ("0001"b);
     1176 		end;
     1177 		else if decode_lc_ineligible () then do;/* if load control won't let this one run now */
     1178 		     call thread_resource;		/* put it on the resource list */
     1179 		     abs_info.waiting_for_load_ctl = "1"b; /* the resource is load control */
     1180 		     if abs_info.lc_reason = USER_LIMIT then /* put reason into request */
     1181 			request.user_limit = "1"b;
     1182 		     else request.load_control = "1"b;
     1183 		     request.state = STATE_DEFERRED;
     1184 		     call rewrite_msg;		/* rewrite request in queue so lar will show deferral reason */
     1185 		     call notify_deferral;		/* send user a message if so requested and we haven't already */
     1186 		end;
     1187 		else if rsc_reservation_unavailable () then do;
     1188 		     call thread_resource;
     1189 		     abs_info.waiting_for_resources = "1"b;
     1190 		     call mark_request_deferred ("001"b);
     1191 		end;
     1192 		else if ^message_in_error then	/* resource reservation attempt can detect error in message */
     1193 		     request_found = "1"b;
     1194 	     end;					/* end not abs run */
     1195 
     1196 	     else do;				/* job selected by abs run */
     1197 		if rsc_reservation_unavailable () then
     1198 		     call sys_log_ (SL_LOG,
     1199 			"^a (abs run): Request ^a ^a will be run in spite of unavailable resource(s): ^a",
     1200 			name, ute.input_seg, request_id_ (ute.request_id), request.resource);
     1201 		if ^message_in_error then		/* unless error detected during resource processing */
     1202 		     request_found = "1"b;		/* confirm that we found the request and can run it */
     1203 	     end;
     1204 	end;
     1205 
     1206 /* No matter what is going to happen to this request, allow any formerly-deferred requests waiting behind it
     1207*   in the ready list to go ahead. See comments in thread_resource (thread_ready entry point) for further explanation. */
     1208 
     1209 	call update_ready;
     1210 
     1211 /* Now, do some final bookkeeping */
     1212 
     1213 	if message_in_error then do;			/* if bad msg, delete it and tell user and operator */
     1214 	     call delete_msg (cur_message_id);		/* delete bad msg from queue */
     1215 	     call delete_skip;			/* delete its skip list entry */
     1216 	     call notify_user;			/* format error message (reason); mail it to user if possible */
     1217 						/* then tell operator, printing request id if known,
     1218*						   else date-time entered */
     1219 	     call sys_log_ (SL_LOG,
     1220 		"^a: rejected request^[^x^a^;^s^] (^a) in ^[queue ^d^;^sforeground queue^] from ^a^[^x(entered ^a)^;^s^]: ^a",
     1221 		name, (rqid ^= ""), rqid, ute.input_seg, (queue > 0), queue,
     1222 		return_args.sender, (rqid = ""), date, reason);
     1223 	     message_in_error = ""b;			/* clear error flag before reading next request */
     1224 	     error (*) = ""b;			/* ditto for individual flags */
     1225 	end;					/* end bad message */
     1226 
     1227 	if request_found then do;			/* we are returning a request to AUM to be logged in */
     1228 	     request.state = STATE_TRANSITION;		/* state will be changing momentarily */
     1229 	     call rewrite_msg;			/* mark the request in the queue */
     1230 	end;
     1231 
     1232 	call free_req;				/* in all cases, free storage occupied by request */
     1233 
     1234 	return;
     1235 
     1236      end decode_request;
     1237 
     1238 defer_request_indefinitely: proc;
     1239 
     1240 	abs_info.defer_list = "1"b;
     1241 	abs_info.time = NEVER;			/* very long time in future */
     1242 	abs_info.next_defer = 0;			/* next entry is tail of defer list */
     1243 	abs_info.prev_defer = absentee_data.tail_defer;	/* previous entry used to be last in list */
     1244 	if abs_info.prev_defer > 0 then		/* if there was a previous entry */
     1245 	     absentee_data.entry (abs_info.prev_defer).next_defer = aix; /* point it at this one */
     1246 	else absentee_data.head_defer = aix;		/* else point head of list at this entry */
     1247 	absentee_data.tail_defer = aix;		/* this is the last entry in the list */
     1248 	return;
     1249 
     1250      end defer_request_indefinitely;
     1251 
     1252 defer_request_until_time: proc;
     1253 
     1254 dcl  ix fixed bin;
     1255 dcl  loop_limit fixed bin;
     1256 
     1257 	abs_info.defer_list = "1"b;			/* identify entry as being on defer list */
     1258 	abs_info.time = ute.deferred_time;		/* copy deferred time into list entry */
     1259 	loop_limit = 0;
     1260 	do ix = absentee_data.head_defer		/* start at head of defer list */
     1261 	     repeat absentee_data.entry (ix).next_defer	/* and go thru the list */
     1262 	     while (ix ^= 0				/* until we hit the end of it */
     1263 	     & absentee_data.entry (ix).time <= abs_info.time); /* or find one with time > this one's */
     1264 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
     1265 	     if loop_limit > absentee_data.last then
     1266 		call loop_error ("defer_request", "defer", NO_QUEUE); /* DOES NOT RETURN */
     1267 	end;
     1268 
     1269 /* Now, ix is the index of the first entry with a time after the current one.
     1270*   We will thread the current one in just before it. */
     1271 
     1272 /* First set threads in entry being added */
     1273 
     1274 	abs_info.next_defer = ix;
     1275 
     1276 	if ix > 0 then				/* if ix points to a real entry */
     1277 	     abs_info.prev_defer = absentee_data.entry (ix).prev_defer; /* copy its back thread */
     1278 	else					/* if ix is zero, either it points to the tail of the list,
     1279*						   or the list is empty */
     1280 	     abs_info.prev_defer = absentee_data.tail_defer; /* and this does the right thing in either case */
     1281 
     1282 /* Then set threads in previous and following entries */
     1283 
     1284 	if abs_info.prev_defer > 0 then		/* if previous entry exists */
     1285 	     absentee_data.entry (abs_info.prev_defer).next_defer = aix; /* make it point to current entry */
     1286 	else do;
     1287 	     absentee_data.head_defer = aix;		/* else make head of list point to it */
     1288 	     call set_defer_timer (abs_info.time);	/* and set new timer since there's a new first deferred request */
     1289 	end;
     1290 	if ix > 0 then				/* if next entry exists */
     1291 	     absentee_data.entry (ix).prev_defer = aix;	/* make it point back to current entry */
     1292 	else absentee_data.tail_defer = aix;		/* else make tail of list point back to it */
     1293 
     1294 	return;
     1295 
     1296      end defer_request_until_time;
     1297 
     1298 delete_cput: proc;
     1299 
     1300 /* Unthread entry from cput list.
     1301*   Input arguments: aip (on which abs_info is based) points to entry to be unthreaded, queue is queue it is from. */
     1302 
     1303 /* First, thread previous and following entries together. */
     1304 
     1305 	if abs_info.prev_cput > 0 then		/* if there is a previous entry */
     1306 	     absentee_data.entry (abs_info.prev_cput).next_cput = abs_info.next_cput; /* set its forward thread */
     1307 	else absentee_data.queue_data (queue).head_cput = abs_info.next_cput; /* else set head of list */
     1308 
     1309 	if abs_info.next_cput > 0 then		/* if there is a following entry */
     1310 	     absentee_data.entry (abs_info.next_cput).prev_cput = abs_info.prev_cput; /* set its back thread */
     1311 	else absentee_data.queue_data (queue).tail_cput = abs_info.prev_cput; /* else set tail of list */
     1312 
     1313 /* Then clear cput list information out of current entry */
     1314 
     1315 	abs_info.prev_cput = 0;
     1316 	abs_info.next_cput = 0;
     1317 	abs_info.cpu_limit = 0;
     1318 	abs_info.cput_list = ""b;
     1319 
     1320 	return;
     1321 
     1322      end delete_cput;
     1323 
     1324 delete_defer: proc;
     1325 
     1326 /* Unthread entry from defer list. Input arguments: aip (on which abs_info is based) points to entry to be unthreaded. */
     1327 
     1328 /* First, thread previous and following entries together. */
     1329 
     1330 	if abs_info.prev_defer > 0 then		/* if previous entry exists */
     1331 	     absentee_data.entry (abs_info.prev_defer).next_defer = abs_info.next_defer; /* set its forward thread */
     1332 	else absentee_data.head_defer = abs_info.next_defer; /* else set head of list */
     1333 
     1334 	if abs_info.next_defer > 0 then		/* if following entry exists */
     1335 	     absentee_data.entry (abs_info.next_defer).prev_defer = abs_info.prev_defer; /* set its back thread */
     1336 	else absentee_data.tail_defer = abs_info.prev_defer; /* else set tail of list */
     1337 
     1338 /* Then clear defer list information out of current entry */
     1339 
     1340 	abs_info.next_defer = 0;			/* blank out defer items */
     1341 	abs_info.prev_defer = 0;
     1342 	abs_info.time = 0;
     1343 	abs_info.defer_list = ""b;
     1344 
     1345 	return;
     1346 
     1347      end delete_defer;
     1348 
     1349 delete_lc: proc;
     1350 
     1351 /* Unthread entry from lc list.
     1352*   Input arguments: aip (on which abs_info is based) points to entry to be unthreaded. */
     1353 
     1354 /* First, thread previous and following entries together. */
     1355 
     1356 	if abs_info.prev_lc > 0 then			/* if previous entry exists */
     1357 	     absentee_data.entry (abs_info.prev_lc).next_lc = abs_info.next_lc; /* set its forward thread */
     1358 	else absentee_data.head_lc = abs_info.next_lc;	/* else set head of list */
     1359 
     1360 	if abs_info.next_lc > 0 then			/* if next entry exists */
     1361 	     absentee_data.entry (abs_info.next_lc).prev_lc = abs_info.prev_lc; /* set its backthread */
     1362 	else absentee_data.tail_lc = abs_info.prev_lc;	/* else set tail of list */
     1363 
     1364 /* Then clear lc list info out of this entry */
     1365 
     1366 	abs_info.prev_lc, abs_info.next_lc = 0;		/* threads */
     1367 	abs_info.lc_list = ""b;			/* lc list indicator */
     1368 						/* we deliberately leave lc_reason set */
     1369 
     1370 	return;
     1371 
     1372      end delete_lc;
     1373 
     1374 delete_msg: proc (msg_id);
     1375 
     1376 /* Procedure to delete a message from the queue. Calls message_segment_$delete_index, and deals with a nonzero return code. */
     1377 
     1378 dcl  msg_id bit (72) aligned;
     1379 dcl  ec fixed bin (35);
     1380 dcl  repeat bit (1) aligned;
     1381 
     1382 	repeat = "1"b;				/* do the delete at least once */
     1383 	do while (repeat);				/* repeat it if queue gets salvaged */
     1384 	     call as_meter_$enter (ABSQ_METER);
     1385 	     call message_segment_$delete_index (queue_index, msg_id, ec);
     1386 	     call as_meter_$exit (ABSQ_METER);
     1387 	     call check_for_badseg (ec, repeat, "absentee_utility_ (delete_msg)");
     1388 	end;
     1389 	return;
     1390 
     1391      end delete_msg;
     1392 
     1393 delete_ready: proc;
     1394 
     1395 /* Unthread entry from ready list. It might be on the resource list, which is a subset of the ready list.
     1396*   Input arguments: aip (on which abs_info is based) points to entry to be unthreaded; queue is queue it is from. */
     1397 
     1398 /* First, thread previous and following entries back together. */
     1399 
     1400 	if abs_info.prev_ready > 0 then		/* if previous entry exists */
     1401 	     absentee_data.entry (abs_info.prev_ready).next_ready = abs_info.next_ready; /* set its forward thread */
     1402 	else absentee_data.queue_data (queue).head_ready = abs_info.next_ready; /* else set head of list */
     1403 
     1404 	if abs_info.next_ready > 0 then		/* if following entry exists */
     1405 	     absentee_data.entry (abs_info.next_ready).prev_ready = abs_info.prev_ready; /* set its back thread */
     1406 	else absentee_data.queue_data (queue).tail_ready = abs_info.prev_ready; /* else set tail of list */
     1407 
     1408 	if absentee_data.queue_data (queue).tail_resource = aix then /* if this was tail of resource list */
     1409 	     absentee_data.queue_data (queue).tail_resource = abs_info.prev_ready; /* previous entry is now the tail */
     1410 
     1411 /* Then, clear ready list information out of current entry. */
     1412 
     1413 	abs_info.prev_ready = 0;
     1414 	abs_info.next_ready = 0;
     1415 	abs_info.can_run = "0"b;
     1416 	abs_info.last_message_id = (72)"0"b;
     1417 	if abs_info.resource_list then do;
     1418 	     autbl.rsc_waiting (queue) = autbl.rsc_waiting (queue) - 1;
     1419 	     abs_info.waiting_for_resources = ""b;
     1420 	     abs_info.waiting_for_load_ctl = ""b;
     1421 	     abs_info.resource_list = ""b;
     1422 	end;
     1423 	abs_info.ready_list = ""b;
     1424 
     1425 /* Finally, if it is on the lc list, go unthread it from that list. */
     1426 
     1427 	if abs_info.lc_list then call delete_lc;
     1428 
     1429 	return;
     1430 
     1431      end delete_ready;
     1432 
     1433 delete_skip: proc;
     1434 
     1435 /* Procedure to delete an entry from the skip list. The entry gets zeroed out and put into the free list.
     1436*   Input arguments: aix is index of entry to be deleted; aip is ptr to it; queue is queue it came from. */
     1437 
     1438 /* First, thread previous and following entries together. */
     1439 
     1440 	if abs_info.prev_skip > 0 then		/* if previous entry exists */
     1441 	     absentee_data.entry (abs_info.prev_skip).next_skip = abs_info.next_skip; /* set its forward thread */
     1442 	else absentee_data.queue_data (queue).head_skip = abs_info.next_skip; /* else set head of list */
     1443 
     1444 	if abs_info.next_skip > 0 then		/* if following entry exists */
     1445 	     absentee_data.entry (abs_info.next_skip).prev_skip = abs_info.prev_skip; /* set its back thread */
     1446 	else absentee_data.queue_data (queue).tail_skip = abs_info.prev_skip; /* else set tail of list */
     1447 
     1448 	if absentee_data.queue_data (queue).tail_run = aix then /* if this was tail of run list */
     1449 	     absentee_data.queue_data (queue).tail_run = abs_info.prev_skip; /* previous entry is now the tail */
     1450 
     1451 /* Then clear the entry completely and thread it onto the free list */
     1452 
     1453 	unspec (abs_info) = ""b;			/* zero out entry */
     1454 	abs_info.prev_free = absentee_data.tail_free;	/* thread in new free entry */
     1455 	absentee_data.tail_free = aix;		/* define new tail of free list */
     1456 	abs_info.free_list = "1"b;
     1457 
     1458 	return;
     1459 
     1460      end delete_skip;
     1461 
     1462 find_eligible_cput: proc (ec);
     1463 
     1464 /* Find the first entry on the cput list whose time limit does not exceed the current
     1465*   upper limit for its queue. There might not be one.
     1466*   Input arguments: queue is queue whose cput list should be searched;
     1467*   aix and next_aix are indices of current and next cput list entries;
     1468*   they allow us to come back to the same place in the cput list, if the first
     1469*   entry we select can not be run for some reason other than cpu time. */
     1470 
     1471 dcl  ec fixed bin (35);
     1472 dcl  loop_limit fixed bin;
     1473 
     1474 	ec = error_table_$no_message;			/* be pessimistic; we zero it if we find one */
     1475 
     1476 	if aix = 0 then				/* if we just started searching the cput list */
     1477 	     aix, next_aix = absentee_data.queue_data (queue).head_cput; /* pick up head of list */
     1478 	loop_limit = 0;
     1479 
     1480 	do while (aix ^= 0 & ec ^= 0);		/* repeat until we hit the end or find one */
     1481 
     1482 	     do aix = next_aix			/* start where we left off last time */
     1483 		repeat absentee_data.entry (aix).next_cput /* and step thru the cput list */
     1484 		while (aix ^= 0			/* until we hit the end, or find one with low enough limit */
     1485 		& absentee_data.entry (aix).cpu_limit > autbl.cpu_limit (max (1, queue)));
     1486 		loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
     1487 		if loop_limit > absentee_data.last then
     1488 		     call loop_error ("find_eligible_cput", "cput", queue); /* does not return */
     1489 	     end;
     1490 
     1491 	     if aix > 0 then do;			/* if we found one with a low limit, see if it's still in queue */
     1492 		aip = addr (absentee_data.entry (aix)); /* get ptr to entry, for convenient referencing */
     1493 		next_aix = abs_info.next_cput;	/* save index of next one, since we delete this one */
     1494 		call read_msg (REREAD, abs_info.message_id, ec); /* read request from queue */
     1495 		call delete_cput;			/* delete it from cput list */
     1496 		if ec = error_table_$no_message then	/* if user or operator deleted request */
     1497 		     call delete_skip;		/* clear it off our records */
     1498 		else cur_message_id = return_args.mess_id; /* else remember message id in global variable */
     1499 	     end;
     1500 
     1501 	end;
     1502 
     1503 	return;
     1504 
     1505      end find_eligible_cput;
     1506 
     1507 find_eligible_ready: proc (ec);
     1508 
     1509 /* Find an entry on the ready list that can run now. Because of the way the ready list
     1510*   is built up from deferred requests as their times arrive, it is always true that the
     1511*   first N requests on the list can run (where N can be zero), and all the rest can't.
     1512*   So we always start at the head of the list and quit as soon as we find one that can't run.
     1513*
     1514*   (The above is true only of the non-resource part of the ready list. Read on.)
     1515*
     1516*   The resource list is the first part of the ready list. It contains requests waiting for either
     1517*   a resource reservation or a load control slot. We want to try logging these requests in periodically,
     1518*   but we must avoid the overhead of trying too often. And of course we must avoid attempting
     1519*   to log in the resource list entries repeatedly in an infinite loop. Since requests are
     1520*   taken from the head of the resource list, and put back onto its tail if they can't log in,
     1521*   an infinite loop would result if we did not do something to avoid it.
     1522*
     1523*   We want to make only one pass thru the resource list each time AUM starts a new sequence of calls to AU.
     1524*   When a new sequence starts, AUM turns off the aum_ctl bit in the AUT header. When we find that bit off,
     1525*   upon entry to the main loop of AU, we turn it on and clear our saved resource list indices.
     1526*   As long as it remains on, we know we're still in the same sequence.
     1527*
     1528*   Then, the first time thereafter that we add an entry to each queue's resource list,
     1529*   we save its index. Thus, when searching the resource list, if we come to an entry whose index
     1530*   is equal to the saved index, we know we've completed one pass thru the resource list,
     1531*   so we skip to the second part of the list, which is the "real" ready list.
     1532*
     1533*   As a further optimization, requests on the resource list that are waiting for load control are checked against the lc list,
     1534*   and rethreaded immediately to the tail of the resource list if it looks like they would not be allowed to log in now.
     1535*
     1536*   Input argument: queue is the queue whose ready list should be searched. */
     1537 
     1538 dcl  ec fixed bin (35);
     1539 dcl  loop_limit fixed bin;
     1540 dcl  found bit (1) aligned init (""b);
     1541 
     1542 	ec = error_table_$no_message;			/* gets zeroed if we find one */
     1543 
     1544 	next_aix = absentee_data.queue_data (queue).head_ready; /* pick up head of ready list */
     1545 	call check_last_rsc;			/* check for end of pass thru resource list */
     1546 	loop_limit = 0;
     1547 
     1548 	do aix = next_aix repeat next_aix		/* step thru ready list */
     1549 	     while (aix ^= 0 & ec ^= 0);		/* until we hit end or find one that can or can't run (really!) */
     1550 	     aip = addr (absentee_data.entry (aix));	/* get ptr to entry */
     1551 	     next_aix = abs_info.next_ready;		/* save index of next one, in case we delete this one */
     1552 	     call check_last_rsc;			/* check for end of pass thru resource list */
     1553 	     if ^abs_info.can_run then do;		/* if request waiting behind another one */
     1554 		call read_msg (REREAD, abs_info.last_message_id, ec); /* see if it's still there */
     1555 		if ec = error_table_$no_message then	/* if it's not */
     1556 		     abs_info.can_run = "1"b;		/* the one behind it can run */
     1557 		else do;				/* it is still in the queue */
     1558 		     call free_req;			/* free the storage we read it into */
     1559 		     ec = 0;			/* we found one that can't run; be sure to get out of the loop */
     1560 		     next_aix = aix;		/* SLOPPY BUG FIX: loop bumps aix one time too many */
     1561 		end;				/* (we want to exit the loop with aix at its current value,
     1562*						   but the loop will set it to next_aix
     1563*						   before doing the while tests and exiting) */
     1564 	     end;
     1565 
     1566 	     if abs_info.can_run then do;		/* if current request not held behind another */
     1567 		if ready_lc_ineligible () then	/* if it's going to be deferred by load control,
     1568*						   avoid the overhead of reading it from the queue,
     1569*						   decoding it, and trying to log it in */
     1570 		     call rethread_resource_head_to_tail; /* but simulate the effect of all that on the list */
     1571 
     1572 		else do;				/* it's all right with load control - treat it normally */
     1573 		     call delete_ready;		/* delete it from ready list */
     1574 		     call read_msg (REREAD, abs_info.message_id, ec); /* read it from queue */
     1575 		     if ec = error_table_$no_message then /* if user or operator deleted it */
     1576 			call delete_skip;		/* clear it from our records, and stay in the loop */
     1577 		     else do;
     1578 			found = "1"b;		/* remember that we found one */
     1579 			cur_message_id = return_args.mess_id; /* remember its message id in global variable */
     1580 			next_aix = aix;		/* SLOPPY BUG FIX: loop bumps aix one time too many */
     1581 		     end;				/* end we found one still in the queue */
     1582 		end;				/* end it's all right with load control */
     1583 	     end;					/* end request not held behind another */
     1584 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
     1585 	     if loop_limit > absentee_data.last then
     1586 		call loop_error ("find_eligible_ready", "ready", queue); /* does not return */
     1587 	end;
     1588 
     1589 	if ^found then ec = error_table_$no_message;	/* tell caller if we didn't find one */
     1590 	return;
     1591 
     1592 /* ---------- */
     1593 
     1594 check_last_rsc: proc;
     1595 
     1596 /* See if next entry is a resource list entry that we have already looked at during this wakeup. */
     1597 
     1598 	     if next_aix > 0 then
     1599 		if next_aix = absentee_data.last_rsc (queue) then /* if it is */
     1600 		     next_aix = absentee_data.entry (absentee_data.queue_data (queue).tail_resource).next_ready;
     1601 	     return;				/* skip over the resource list to the "real" ready list */
     1602 
     1603 	end check_last_rsc;
     1604 
     1605      end find_eligible_ready;
     1606 
     1607 find_next_queue_entry: proc (ec);
     1608 
     1609 /* Find a request in the queue. It will be decoded and either run now or
     1610*   deferred, as appropriate. In either case, it will stay on the skip list (unless
     1611*   it is a bad request and gets deleted from both the queue and the skip list).
     1612*   So we always want to read the request after the last one in the skip list (or
     1613*   the first one in the queue, if the skip list is empty).
     1614*
     1615*   When reading requests from the queue, we might find one whose state is RUNNING.
     1616*   Either it was running when the system crashed, and we want to rerun it only if it
     1617*   is restartable, or it is running now, and we are rebuilding the lists in absentee_data.
     1618*   Another possibility is that it was started early by the abs run command, and we just
     1619*   got to its spot in the queue. In this case, we want to skip it and read the next message. */
     1620 
     1621 dcl  ec fixed bin (35);
     1622 dcl  repeat bit (1) aligned;
     1623 
     1624 /* Get the index of the last skip list entry, if the list is non-empty.
     1625*   If the skip list contains only entries that are on the run list, pretend the skip list is empty.
     1626*   If the skip list is empty (or we are pretending it is), read the first message in the queue.
     1627*   Otherwise, read the message after the last one in the skip list. */
     1628 
     1629 	aix = absentee_data.queue_data (queue).tail_skip; /* get index of last entry on skip list */
     1630 	if aix = absentee_data.queue_data (queue).tail_run then /* if it is on the run list */
     1631 	     aix = 0;				/* pretend the skip list is empty */
     1632 	if aix ^= 0 then				/* if the non-run skip list section is non-empty */
     1633 	     cur_message_id = absentee_data.entry (aix).message_id; /* read the request after it in the queue */
     1634 	else cur_message_id = ""b;			/* else read first request in queue */
     1635 
     1636 	ec = 0;					/* initialize do group controls */
     1637 	repeat = "1"b;
     1638 	do while (repeat & ec = 0);			/* read msgs 'til suitable msg found, or no more left */
     1639 	     call read_msg (FORWARD, cur_message_id, ec); /* read either first msg in Q or first after last skip */
     1640 	     if ec = 0 then do;			/* if read worked */
     1641 		cur_message_id = return_args.mess_id;	/* remember message id in global variable */
     1642 		call create_skip;			/* put request onto skip list right away */
     1643 		repeat = check_for_running ();	/* if request.state = RUNNING, maybe read another request */
     1644 	     end;
     1645 	end;
     1646 
     1647 	return;
     1648 
     1649 /* ---------- */
     1650 
     1651 check_for_running: proc returns (bit (1) aligned);
     1652 
     1653 /* The following possibilities exist:
     1654*   *  state ^= RUNNING			Case I: normal; try to run the job.
     1655*   *  state = RUNNING
     1656*   *    not rebuilding absentee_data
     1657*   *       job is on run list			Case I.5: skip over job started by abs run
     1658*   *      system crashed while job was running
     1659*   *       job is restartable			Case II: rerun the job.
     1660*   *       job not restartable		Case III: delete job and read next request.
     1661*   *    rebuilding absentee_data		Case IV: job is now running: put it on skip list and read next request.
     1662**/
     1663 	     if request.state ^= STATE_RUNNING then return (""b); /* Case I - run job */
     1664 
     1665 	     do ii = absentee_data.queue_data (queue).tail_run /* search run list for this request */
     1666 		repeat absentee_data.entry (ii).prev_skip
     1667 		while (ii > 0);			/* fails immediately with ii=0 if run list is empty */
     1668 		if absentee_data.entry (ii).message_id = abs_info.message_id then do; /* found it */
     1669 		     call free_req;			/* it was started by abs run; free its storage */
     1670 		     call delete_skip;		/* delete the duplicate skip list entry we created */
     1671 		     return ("1"b);			/* tell caller to read next message */
     1672 		end;
     1673 	     end;
     1674 
     1675 	     if request.restartable & ^absentee_data.rebuilding then do;
     1676 		if request.request_version > ABS_VER_4 then do; /* Only version 5 & above requests */
     1677 		     request.restarted = "1"b;	/* flag as restarted */
     1678 		     call rewrite_msg;
     1679 		end;
     1680 		return (""b);			/* Case II - rerun the job */
     1681 	     end;
     1682 
     1683 	     call free_req;				/* Cases III and IV both want to read next request,
     1684*						   so free this one's storage */
     1685 	     if ^absentee_data.rebuilding then do;	/* Case III - delete job */
     1686 		call delete_msg (cur_message_id);
     1687 		call delete_skip;			/* since we had already put it on the skip list */
     1688 	     end;
     1689 
     1690 	     return ("1"b);				/* tell caller to read next message */
     1691 
     1692 	end check_for_running;
     1693 
     1694      end find_next_queue_entry;
     1695 
     1696 free_req: proc;
     1697 
     1698 	if return_args.reqp ^= null then call freen_ (return_args.reqp);
     1699 
     1700 	return;
     1701 
     1702      end free_req;
     1703 
     1704 free_rsc: proc;
     1705 	if resource_desc_ptr ^= null then call freen_ (resource_desc_ptr);
     1706 	if resource_res_ptr ^= null then call freen_ (resource_res_ptr);
     1707 
     1708 	return;
     1709 
     1710      end free_rsc;
     1711 
     1712 get_effmode:
     1713      procedure (dir, entry, user, ring, code) returns (bit (36));
     1714 
     1715 declare  (dir, entry, user) character (*);
     1716 declare  code fixed bin (35);
     1717 declare  ring fixed bin;
     1718 declare  mode fixed bin (5);
     1719 
     1720 	call hcs_$get_user_effmode (dir, entry, user, ring, mode, code);
     1721 	if code ^= 0
     1722 	then return (""b);
     1723 	else return (substr (bit (mode, 5), 2, 3) || copy ("0"b, 33));
     1724      end get_effmode;
     1725 
     1726 get_next_request: proc (ec);
     1727 
     1728 /* Get "the next" request. It will be decoded and either logged in or deferred.
     1729*   If the request we return gets deferred, we will be called again, and we want to
     1730*   resume our search with the request "after" the one we returned before. The
     1731*   search sequence that defines "the next" request, and the one "after" the one we returned
     1732*   is the following: the cput list, the ready list, and finally the queue itself,
     1733*   starting with the request after the last one on the skip list.
     1734*   This sequence is followed as long as we keep returning requests to the main
     1735*   loop and having them deferred. The search sequence is restarted from the beginning
     1736*   whenever we switch to the next queue, or whenever AU returns to AUM and gets called again. */
     1737 
     1738 dcl  ec fixed bin (35);
     1739 
     1740 	ec = 0;					/* gets set nonzero if there is no next request */
     1741 
     1742 	if list_searched = CPUT_LIST then do;
     1743 	     call find_eligible_cput (ec);
     1744 	     if ec ^= 0 then			/* if no eligible request on cput list, try ready list */
     1745 		list_searched = READY_LIST;
     1746 	end;
     1747 
     1748 	if list_searched = READY_LIST then do;
     1749 	     call find_eligible_ready (ec);
     1750 	     if ec ^= 0 then			/* if no eligible request on ready list, try the queue */
     1751 		list_searched = QUEUE_LIST;
     1752 	end;
     1753 
     1754 	if list_searched = QUEUE_LIST then
     1755 	     call find_next_queue_entry (ec);
     1756 
     1757 	return;
     1758 
     1759      end get_next_request;
     1760 
     1761 get_queue_from_aute: proc;
     1762 
     1763 /* Get queue number out of aute, and check it for legal value */
     1764 
     1765 	queue = ute.real_queue;			/* set queue number */
     1766 
     1767 	if queue >= -1 & queue <= MAX_QUEUE then	/* be sure queue has legal value */
     1768 	     queue_index = queue_indices (queue);	/* if it does, pick up its message segment index */
     1769 	else do;					/* if not, log the error for debugging */
     1770 	     call sys_log_ (SL_LOG_SILENT, "^a: Illegal queue number (^d) for ^a.^a (^a)",
     1771 		name, queue, ute.person, ute.project, ute.input_seg);
     1772 	     queue_index = 0;			/* don't try to read or write from some random queue */
     1773 	end;
     1774 
     1775 	return;
     1776 
     1777      end get_queue_from_aute;
     1778 
     1779 lc_will_reject: proc returns (bit (1) aligned);
     1780 
     1781 /* This procedure predicts the deferral of a request by load control, by searching the load control list
     1782*   for a request from the same user, project, or load control group. The purpose of this is to avoid the overhead of
     1783*   repeatedly trying to log in all the requests deferred by load control, just to see if they can log in now.
     1784*   It often happens that there are a lot of requests from one user, or from one group, and as soon as one
     1785*   of them is deferred by load control, we know that all the rest would also be deferred, at least until someone logs out.
     1786*
     1787*   If we aren't sure the request will be deferred by load control, we return FALSE and let the login attempt proceed.
     1788*
     1789*   The load control list is made up of requests that have actually been deferred by load_ctl_.
     1790*   Requests deferred by the test we are about to make are not on the lc list, although they are
     1791*   placed on the resource list, and they do have their lc_reason set.
     1792*
     1793*   The list is cleared and rebuilt periodically, at least as often as every absentee logout. */
     1794 
     1795 dcl  ix fixed bin;
     1796 dcl  loop_limit fixed bin init (0);
     1797 
     1798 	do ix = absentee_data.head_lc			/* start at head of list */
     1799 	     repeat (absentee_data.entry (ix).next_lc)	/* and look at each entry */
     1800 	     while (ix ^= 0);			/* until we hit the end */
     1801 
     1802 	     if absentee_data.entry (ix).project	/* if project of list entry */
     1803 		= abs_info.project then do;		/* equals project of current entry */
     1804 
     1805 		if absentee_data.entry (ix).lc_reason = PROJECT_LIMIT /* if list entry deferred for project limit */
     1806 		then goto return_true;		/* then this one will be deferred too */
     1807 
     1808 		if absentee_data.entry (ix).person	/* if person is equal as well as project */
     1809 		     = abs_info.person		/* then this request will be deferred for the same reason */
     1810 		then goto return_true;		/* whatever the reason - think about it - you'll see it */
     1811 	     end;					/* end projects the same */
     1812 
     1813 	     if absentee_data.entry (ix).lc_reason = GROUP_LIMIT /* if list entry's group was full */
     1814 	     then if absentee_data.entry (ix).group	/* and the full group */
     1815 		     = abs_info.group		/* is the one the current entry is in */
     1816 		then goto return_true;		/* then this request would be deferred */
     1817 
     1818 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
     1819 	     if loop_limit > absentee_data.last then
     1820 		call loop_error ("lc_will_reject", "lc", NO_QUEUE); /* DOES NOT RETURN */
     1821 	end;					/* end loop thru lc list */
     1822 
     1823 	return (FALSE);				/* we have no reason to think it will be deferred,
     1824*						   so we'll try logging it in, and let load_ctl_ decide */
     1825 
     1826 return_true:
     1827 	abs_info.lc_reason = absentee_data.entry (ix).lc_reason; /* copy deferral reason from list entry */
     1828 	return (TRUE);
     1829 
     1830      end lc_will_reject;
     1831 
     1832 loop_error: proc (proc_name, list_name, queue_number);
     1833 
     1834 dcl  (proc_name, list_name) char (*);
     1835 dcl  queue_number fixed bin;
     1836 
     1837 	call sys_log_ (SL_LOG, "^a: Loop in ^a, searching ^a list^[^xfor queue ^d^].",
     1838 	     name, proc_name, list_name, (queue_number ^= NO_QUEUE), queue_number);
     1839 
     1840 	if absentee_data.rebuilding then do;		/* if it has happened twice in a row */
     1841 	     call sys_log_ (SL_LOG_BEEP, "^a: Loop occurred while rebuilding ^a>^a after previous loop.",
     1842 		name, sysdir, absentee_data_base);
     1843 	     call suspend_absentee_processing;		/* does not return */
     1844 	end;
     1845 
     1846 	else do;
     1847 	     call sys_log_ (SL_LOG, "^a: ^a>^a will be rebuilt", name, sysdir, absentee_data_base);
     1848 	     call reset_alarm_timer;			/* first reset deferred-request timer */
     1849 	     call hcs_$truncate_seg (adp, (0), code);
     1850 	     if code ^= 0 then do;
     1851 		call sys_log_$error_log (SL_LOG_BEEP, code, name, "Truncating ^a>^a", sysdir, absentee_data_base);
     1852 		call suspend_absentee_processing;	/* does not return */
     1853 	     end;
     1854 	     absentee_data.rebuilding = "1"b;		/* avoid infinite loop of rebuild attempts */
     1855 	     absentee_data.version = ABS_DATA_version_2;	/* set current structure version */
     1856 	     call send_abs_wakeup;			/* send wakeup to AU to get the rebuild started again */
     1857 	end;
     1858 
     1859 	goto abort_label;				/* abort whatever was happening, and return to caller of AUM */
     1860 
     1861      end loop_error;
     1862 
     1863 mark_request_deferred: proc (status_flags);
     1864 
     1865 dcl  status_flags bit (36);
     1866 
     1867 	request.state = STATE_DEFERRED;
     1868 	unspec (request.abs_status_flags) = status_flags;
     1869 	call rewrite_msg;
     1870 	if status_flags then			/* if deferred for an unexpected reason */
     1871 	     call notify_deferral;			/* send user a message if so requested and not already done */
     1872 	return;
     1873 
     1874      end mark_request_deferred;
     1875 
     1876 message_error: proc (ec);
     1877 
     1878 /* Procedure to remember errors in request, so user and operator can be notified. */
     1879 
     1880 dcl  ec fixed bin;					/* 1 = reservation error,
     1881*						   2 = invalid request version,
     1882*						   3 = no proxy permission,
     1883*						   4 = invalid login name,
     1884*						   5 = invalid project,
     1885*						   6 = invalid absin pathname,
     1886*						   7 = invalid absout pathname,
     1887*						   8 = invalid resource description,
     1888*						   9 = invalid argument string,
     1889*						   10= inconsistent request format. */
     1890 
     1891 	message_in_error = "1"b;			/* remember that there was an error */
     1892 	error (ec) = "1"b;				/* and remember which one(s) occurred */
     1893 	if ec = 1 then				/* if reservation error */
     1894 	     message_error_code = code;		/* remember what the reserver said */
     1895 	return;
     1896 
     1897      end message_error;
     1898 
     1899 notify_deferral: proc;
     1900 
     1901 /* notify user if he so requested and we haven't already done it once */
     1902 
     1903 dcl  already_notified bit (1) aligned init (""b);
     1904 
     1905 	if aip ^= null then				/* if request has skip list entry */
     1906 	     already_notified = abs_info.deferral_notified; /* see if we already sent a deferral message */
     1907 
     1908 	ii = index (unspec (request.abs_status_flags), "1"b); /* find reason for deferral */
     1909 
     1910 	if request.notify & ^already_notified
     1911 	     & ii >= lbound (deferral_reasons, 1) & ii <= hbound (deferral_reasons, 1) then do;
     1912 	     call ioa_$rsnnl ("Absentee job ^a>^a ^a deferred ^a", user_message, (0),
     1913 		request.dirname, request.ename, request_id_ (request.msg_time), deferral_reasons (ii));
     1914 	     call send_user_message;
     1915 	     if aip ^= null then			/* avoid fault in abs defer command */
     1916 		abs_info.deferral_notified = "1"b;
     1917 	end;
     1918 	return;
     1919 
     1920      end notify_deferral;
     1921 
     1922 notify_user: proc;
     1923 
     1924 /* Called if there were errors in the request. Construct message describing error, to send to both user and operator */
     1925 
     1926 	reason = "";
     1927 	if error (1) then do;			/* reservation error */
     1928 	     call convert_status_code_ (message_error_code, short, long);
     1929 	     reason = "reservation error: " || rtrim (long) || ", ";
     1930 	end;
     1931 
     1932 	if substr (reason, length (reason) - 2, 3) = "., " then /* "., " looks dumb */
     1933 	     reason = substr (reason, 1, length (reason) - 3) || ", ";
     1934 
     1935 	do ii = 2 to hbound (err_msg, 1);
     1936 	     if error (ii) then do;
     1937 		reason = reason || rtrim (err_msg (ii));
     1938 		reason = reason || ", ";
     1939 	     end;
     1940 	end;
     1941 
     1942 	reason = substr (reason, 1, length (reason) - 2) || ".";
     1943 
     1944 /* Format request id or date-time of submission. We only use latter if former is unavailable due to incorrect version. */
     1945 
     1946 	if error (2) then do;			/* if incorrect version, format date */
     1947 	     call date_time_ (based_mess_id, date);
     1948 	     rqid = "";				/* and remember that we don't have the request id */
     1949 	end;
     1950 
     1951 	else rqid = request_id_ (ute.request_id);
     1952 
     1953 /* If we don't have the user's name and project, we can't notify him, so just tell the operator */
     1954 
     1955 	if error (4) | error (5) | ((error (2) | error (10)) & ute.proxy) then return;
     1956 
     1957 
     1958 	call ioa_$rsnnl
     1959 	     ("rejected request^[^x^a^;^s^] (^a) in ^[queue ^d^;^sforeground queue^]^[^x(entered ^a)^;^s^]: ^a",
     1960 	     user_message, (0), (rqid ^= ""), rqid, ute.input_seg, (queue > 0), queue, (rqid = ""), date, reason);
     1961 
     1962 	call send_user_message;
     1963 
     1964 	return;
     1965 
     1966      end notify_user;
     1967 
     1968 read_msg: proc (direction, msg_id, ec);
     1969 
     1970 /* Procedure to read a request from a queue, check for errors, reread if necessary, and drop queue if too many errors.
     1971*   The following global variables are used:
     1972*   queue_index	index of already-opened message segment to read request from
     1973*   areap		pointer to free area into which request is read
     1974*   return_args	structure in which information about the message is returned
     1975**/
     1976 
     1977 dcl  direction bit (2) aligned;			/* direction in which to read, relative to msg_id:
     1978*						   "01"b = forward, or head of queue;
     1979*						   "10"b = backward, or tail of queue;
     1980*						   "00"b = reread the specified message. */
     1981 dcl  msg_id bit (72) aligned;				/* read this msg, or one before or after it
     1982*						   (0 means head or tail of queue) */
     1983 dcl  ec fixed bin (35);				/* set to zero if a message is returned to caller */
     1984 dcl  repeat bit (1) aligned;
     1985 
     1986 	repeat = "1"b;				/* do the read at least once */
     1987 	do while (repeat);				/* retry the read if queue gets salvaged */
     1988 	     call as_meter_$enter (ABSQ_METER);
     1989 	     if msg_id ^= ""b then			/* if message id given, read relative to it */
     1990 		call message_segment_$incremental_read_index
     1991 		     (queue_index, areap, direction, msg_id, addr (return_args), ec);
     1992 	     else					/* otherwise read first or last message in queue */
     1993 		call message_segment_$read_index (queue_index, areap, substr (direction, 1, 1), addr (return_args), ec);
     1994 	     call as_meter_$exit (ABSQ_METER);
     1995 	     call check_for_badseg (ec, repeat, "absentee_utility_ (read_msg)"); /* check ec, report any error,
     1996*						   turn on repeat if salvaged, drop queue if too may errors */
     1997 	end;
     1998 
     1999 	return;
     2000 
     2001      end read_msg;
     2002 
     2003 ready_lc_ineligible: proc returns (bit (1) aligned);
     2004 
     2005 /* This procedure is called by find_eligible_ready, to check for a request that is on the resource list,
     2006*   was deferred by load control, and still can't run because other requests from the same user or group have
     2007*   recently been deferred by load control and it is certain that this one would also be deferred.
     2008*
     2009*   The load control test is made by another procedure (lc_will_reject), which is called by this one.
     2010*   The purpose of this procedure is to separate out requests deferred by load control in the past from those deferred
     2011*   for want of other resources, and those in the non-resource part of the ready list, and only
     2012*   make the test for the first of those categories.
     2013*
     2014*   Requests in the other two categories might also end up being deferred by load control, but that decision
     2015*   will be made later, when decode_request calls decode_lc_ineligible. The logic involved in moving requests
     2016*   in the other categories into the first category, at this point in the processing, would be too complicated to be worth it.
     2017*
     2018*   The purpose of special-casing requests in the first category is to minimize the overhead involved in processing
     2019*   a large number of requests from a single user or load control group, a few at a time, governed by load control.
     2020*   When we detect a request that has already been deferred by load control once, we see if it is going to
     2021*   be deferred again, and if it is, we don't bother reading it from the queue and decoding it. */
     2022 
     2023 	if ^abs_info.waiting_for_load_ctl		/* if this request was not deferred by load control in the past */
     2024 	then return (FALSE);			/* handle it normally */
     2025 
     2026 	return (lc_will_reject ());			/* return whatever lc_will_reject returns to us */
     2027 
     2028      end ready_lc_ineligible;
     2029 
     2030 reset_alarm_timer: proc;
     2031 
     2032 /* Internal procedure to reset the alarm timer and remember that we did so */
     2033 
     2034 	call timer_manager_$reset_alarm_wakeup (autbl.defer_channel);
     2035 	static_alarm_time = 0;			/* remember that no timer is set */
     2036 	resource_timer_set = ""b;
     2037 	return;
     2038 
     2039      end reset_alarm_timer;
     2040 
     2041 rethread_resource_head_to_tail: proc;
     2042 
     2043 /* This procedure rethreads the current entry from the head of the resource list to the tail of that list.
     2044*   (If the current entry is not the one at the head of the resource list, then there is a serious logic design flaw,
     2045*   so we print a message with an audible alarm, and return without doing any rethreading. We hope that never happens.)
     2046*
     2047*   This procedure is called by find_eligible_ready, when the request it just found is certain to be deferred by load control.
     2048*   Rethreading it simulates the effect of unthreading it from the head of the list, going and trying to log it in,
     2049*   having it deferred by load control, coming back and threading it onto the tail of the list,
     2050*   and going on to the next request (which is now at the head of the list). Doing it this way avoids a lot of overhead.
     2051*
     2052*   Input arguments: aix is index of entry; aip (on which abs_info is based) points to it; queue is its queue. */
     2053 
     2054 	if absentee_data.queue_data (queue).head_ready ^= aix then do; /* if entry not at head */
     2055 	     call sys_log_ (SL_LOG_BEEP, "^a: BUG: lc ineligible (^d) not at head of resource list", name, aix);
     2056 	     return;
     2057 	end;
     2058 
     2059 	if absentee_data.queue_data (queue).tail_ready = aix then /* if current entry is also last in list */
     2060 	     return;				/* its's silly to rethread a one-element list */
     2061 
     2062 /* First, unthread it from head, by threading following entry (which we know exists) to the head. */
     2063 
     2064 	absentee_data.queue_data (queue).head_ready = abs_info.next_ready; /* point head at next entry */
     2065 	absentee_data.entry (abs_info.next_ready).prev_ready = 0; /* point next entry's backthread to head */
     2066 
     2067 /* Now that the current entry has been unthreaded from the head, we want to thread it onto the tail. thread_resource will do that for us. */
     2068 
     2069 	call thread_resource;
     2070 
     2071 /* The only thing thread_resource does wrong in this case is to increment the counter of requests in the resource list.
     2072*   Since this entry was already on the resource list, and already counted, we have to decrement the counter. */
     2073 
     2074 	autbl.rsc_waiting (queue) = autbl.rsc_waiting (queue) - 1;
     2075 
     2076 	return;
     2077 
     2078      end rethread_resource_head_to_tail;
     2079 
     2080 rsc_reservation_unavailable: proc returns (bit (1) aligned);
     2081 
     2082 /* Check for resource requirements and try to reserve them */
     2083 
     2084 	if request.len_resource > 0 & ^message_in_error then do; /* if there are resources required */
     2085 	     call parse_resource_desc_ (request.resource, areap, resource_desc_ptr, resource_res_ptr, code);
     2086 	     if code = 0 then do;			/* if resource description is ok */
     2087 		reservation_description.reserved_for,
     2088 		     reservation_description.reserved_by =
     2089 		     rtrim (ute.person) || "." || rtrim (ute.project) || ".*";
     2090 		reservation_description.flags.auto_expire = "1"b;
     2091 		call resource_control_$reserve
     2092 		     (resource_desc_ptr, resource_res_ptr, ute.process_authorization, ("1"b), code);
     2093 		if code ^= 0 then do;		/* we did not get the reservation */
     2094 		     if code = error_table_$device_limit_exceeded /* if we never will get it */
     2095 			| code = error_table_$resource_unknown then
     2096 			call message_error (1);	/* 1 = reservation error */
     2097 		     else do;			/* otherwise assume we will eventually get it */
     2098 			if code ^= error_table_$reservation_failed then
     2099 						/* but if code is not "wait awhile", complain */
     2100 			     call sys_log_$error_log (SL_LOG_BEEP, code, name, "Attempting to reserve ^a for ^a.^a (^a)",
     2101 				request.resource, ute.person, ute.project, request_id_ (ute.request_id));
     2102 
     2103 			call free_rsc;		/* free storage used by resource reservation structures */
     2104 			return ("1"b);		/* tell caller to put this one on the resource list */
     2105 
     2106 		     end;				/* end wait for resources */
     2107 		end;				/* end resources not available */
     2108 
     2109 		else do;				/* resources available. run the job */
     2110 		     ute.reservation_id = reservation_description.reservation_id;
     2111 		     call free_rsc;			/* free storage used by resource reservation structures */
     2112 		end;
     2113 
     2114 	     end;					/* end resource description ok */
     2115 	     else call message_error (8);		/* 8 = invalid resource description */
     2116 	end;					/* end resources required */
     2117 
     2118 	else ute.reservation_id = 0;			/* positive indication that no resources are required */
     2119 
     2120 	return (""b);				/* tell caller not to put this one on the resource list */
     2121 
     2122      end rsc_reservation_unavailable;
     2123 
     2124 rewrite_msg: proc;
     2125 
     2126 /* Procedure to rewrite a message in the queue. (We want to do that to update its state so the user can see how it's coming.)
     2127*   Calls message_segment_$update_message_index and deals with a nonzero return code.
     2128*   Input arguments: queue_index is index of message segment; return_args and request structures are assumed
     2129*   to contain data on, and the contents of, the message to be rewritten, respectively. */
     2130 
     2131 dcl  repeat bit (1) aligned;
     2132 
     2133 	repeat = "1"b;				/* do the rewrite at least once */
     2134 	do while (repeat);				/* repeat the rewrite if queue gets salvaged */
     2135 	     call as_meter_$enter (ABSQ_METER);
     2136 	     call message_segment_$update_message_index (queue_index, return_args.len,
     2137 		return_args.mess_id, return_args.reqp, code);
     2138 	     call as_meter_$exit (ABSQ_METER);
     2139 	     call check_for_badseg (code, repeat, "absentee_utility_ (rewrite_msg)");
     2140 	end;
     2141 
     2142 	return;
     2143 
     2144      end rewrite_msg;
     2145 
     2146 search_queues: proc (howmany, what);			/* search queues for howmany jobs, and do what to them */
     2147 
     2148 dcl  howmany fixed bin;				/* how many jobs we want: ONE or MANY */
     2149 dcl  what fixed bin;				/* what to do to it (RUN) or them (DEFER, RELEASE) */
     2150 
     2151 dcl  match_count fixed bin init (0);			/* count of jobs that matched args */
     2152 dcl  match_queue fixed bin;				/* queue that ONE job was found in */
     2153 dcl  match_message_id bit (72) aligned;			/* id of ONE job */
     2154 dcl  ec fixed bin (35);				/* temp error code, for subroutine calls */
     2155 dcl  (fq, lq) fixed bin;				/* first and last queue(s) to be searched */
     2156 
     2157 /* Decide which queues to search */
     2158 
     2159 	if abs_args.queue_sw then do;			/* if operator supplied queue number */
     2160 	     if abs_args.queue = 1 then do;		/* Q 0 is treated as first part of Q 1 */
     2161 		fq = 0;
     2162 		lq = 1;
     2163 	     end;
     2164 	     else fq, lq = abs_args.queue;
     2165 	end;
     2166 	else do;					/* search all queues */
     2167 	     fq = -1;
     2168 	     lq = 4;
     2169 	end;
     2170 
     2171 /* Search those queues */
     2172 
     2173 	do queue = fq to lq;
     2174 	     ec = 0;
     2175 	     cur_message_id = ""b;
     2176 	     queue_index = queue_indices (queue);	/* get message segment index */
     2177 	     if queue_index > 0 then			/* avoid errors on unopened segments */
     2178 		do while (ec = 0);			/* keep reading from this queue until no more */
     2179 		call read_msg (FORWARD, cur_message_id, ec);
     2180 		if ec = 0 then do;			/* if we got a message, look at it */
     2181 		     cur_message_id = return_args.mess_id; /* copy its id for use in incremental read of next one */
     2182 
     2183 /* See if request matches arguments */
     2184 
     2185 		     if request.hdr_version ^= queue_msg_hdr_version_1 then
     2186 			goto sq_nomatch;		/* avoid faults if bad request format */
     2187 		     if (request.request_version ^= abs_message_version_6 &
     2188 			request.request_version ^= ABS_VER_5 &
     2189 			request.request_version ^= ABS_VER_4) then goto sq_nomatch;
     2190 		     ii = divide (return_args.len + 35, 36, 17, 0);
     2191 		     if ii ^= currentsize (request) then goto sq_nomatch;
     2192 		     if ii ^= request.std_length then goto sq_nomatch;
     2193 
     2194 		     if abs_args.user_sw then do;	/* check user name if given */
     2195 			if abs_args.person ^= "*" then do; /* * matches all persons so don't bother checking */
     2196 			     if abs_args.person ^= before (return_args.sender, ".") then do;
     2197 				if ^request.proxy then goto sq_nomatch;
     2198 				if abs_args.person ^= before (request.proxy_name, ".") then goto sq_nomatch;
     2199 			     end;
     2200 			end;
     2201 			if abs_args.project ^= "*" then do;
     2202 			     if abs_args.project ^= before (after (return_args.sender, "."), ".") then do;
     2203 				if ^request.proxy then goto sq_nomatch;
     2204 				if abs_args.project ^= before (after (return_args.sender, "."), ".") then
     2205 				     goto sq_nomatch;
     2206 			     end;
     2207 			end;
     2208 		     end;
     2209 
     2210 		     if abs_args.id_sw then
     2211 			if ^match_request_id_ (request.msg_time, (abs_args.request_id_string)) then
     2212 			     goto sq_nomatch;
     2213 
     2214 		     if abs_args.path_sw then
     2215 			if abs_args.dirname ^= request.dirname then goto sq_nomatch;
     2216 
     2217 		     if abs_args.path_sw | abs_args.entry_sw then do;
     2218 			call match_star_name_ ((request.ename), (abs_args.ename), code);
     2219 			if code ^= 0 then goto sq_nomatch;
     2220 		     end;
     2221 
     2222 		     if abs_args.sender_sw then do;
     2223 			call match_star_name_ ((request.sender), (abs_args.sender), code);
     2224 			if code ^= 0 then goto sq_nomatch;
     2225 		     end;
     2226 
     2227 /* Job matches all arguments given. Now decide what to do with it */
     2228 
     2229 		     if howmany = ONE then do;	/* if we want one job, count them and save Q and ID of first */
     2230 			match_count = match_count + 1;
     2231 			if match_count = 1 then do;	/* if the first */
     2232 			     match_queue = queue;	/* save queue and ID */
     2233 			     match_message_id = cur_message_id;
     2234 			end;
     2235 		     end;
     2236 
     2237 		     else do;			/* we want MANY jobs, and we'll do what to them */
     2238 
     2239 			call search_skip_for_queue (ec); /* see if it already has a skip list entry */
     2240 			if ec = 0 & request.state = STATE_RUNNING then /* if it does, and it's running */
     2241 			     goto sq_nomatch;	/* we don't want to do anything to it */
     2242 
     2243 			if what = DEFER then do;
     2244 			     match_count = match_count + 1;
     2245 			     call mark_request_deferred ("01"b); /* rewrite queue entry */
     2246 			     if ec = 0 then do;	/* if it has a skip list entry, rethread it */
     2247 				if abs_info.cput_list then call delete_cput;
     2248 				else if abs_info.ready_list then call delete_ready;
     2249 				else if abs_info.defer_list then call delete_defer;
     2250 				call defer_request_indefinitely;
     2251 			     end;
     2252 			end;
     2253 
     2254 			else if what = RELEASE then do;
     2255 			     if (request.user_deferred_indefinitely |
     2256 				request.operator_deferred_indefinitely) then do;
     2257 				match_count = match_count + 1; /* only release deferred-indefinitely requests */
     2258 				unspec (request.abs_status_flags) = ""b;
     2259 				request.user_deferred_indefinitely = ""b;
     2260 				request.state = STATE_ELIGIBLE;
     2261 				call rewrite_msg;
     2262 				if ec = 0 then do;	/* if it has a skip list entry */
     2263 				     call delete_defer; /* it can only be on the defer list */
     2264 				     call thread_ready;
     2265 				end;		/* end on skip list */
     2266 			     end;			/* end deferred-indefinitely */
     2267 			end;			/* end what = RELEASE */
     2268 
     2269 			ec = 0;			/* clear out code from skip list search */
     2270 		     end;				/* end howmany = MANY */
     2271 
     2272 sq_nomatch:
     2273 		     call free_req;			/* free storage that request was read into */
     2274 		end;				/* end request was read from queue */
     2275 	     end;					/* end do while there are more requests in queue */
     2276 	end;					/* end loop thru all queues */
     2277 
     2278 /* Having gone thru the queues, see what we found */
     2279 
     2280 	if howmany = MANY then do;
     2281 	     call sys_log_ (SL_LOG,
     2282 		"abs ^[defer^;release^]: ^[^sno^;^d^] ^[^;deferred^x^]request^[s^] ^[deferr^;releas^]ed.",
     2283 		what, (match_count = 0), match_count, what, (match_count ^= 1), what);
     2284 	     if what = RELEASE then do;		/* if release */
     2285 		release_count = match_count;		/* return count of jobs released */
     2286 		if match_count > 0 then		/* if count is nonzero */
     2287 		     call send_abs_wakeup;		/* make sure we try immediately to log them in */
     2288 	     end;
     2289 	end;
     2290 
     2291 	else do;					/* we wanted one request */
     2292 	     if match_count = 1 then do;		/* if that's what we got */
     2293 		queue = match_queue;		/* go back to its queue */
     2294 		queue_index = queue_indices (queue);
     2295 		cur_message_id = match_message_id;	/* and to that message */
     2296 		call read_msg (REREAD, cur_message_id, ec); /* and read it in again */
     2297 		if ec ^= 0 then			/* must have gotten cancelled out from under us */
     2298 		     match_count = 0;		/* so pretend we never saw it */
     2299 		else request_found = "1"b;		/* if it's still there, tell caller we found it */
     2300 	     end;
     2301 
     2302 	     if match_count ^= 1 then
     2303 		call sys_log_ (SL_TYPE,
     2304 		     "abs run: job selection arguments matched ^[^sno^;^d^] requests^[; be more specific^].",
     2305 		     (match_count = 0), match_count, (match_count > 1));
     2306 	     else request_found = "1"b;		/* tell caller we found one */
     2307 	end;					/* end one request wanted */
     2308 
     2309 	return;
     2310 
     2311      end search_queues;
     2312 
     2313 search_skip_for_aute: proc (ec);
     2314 
     2315 /* Procedure to search skip list for entry belonging to job described in aute. */
     2316 
     2317 dcl  ec fixed bin (35);
     2318 dcl  loop_limit fixed bin;
     2319 
     2320 	cur_message_id = ute.message_id;		/* copy id of message whose skip list entry we seek */
     2321 
     2322 /* Get queue number out of aute. */
     2323 
     2324 	call get_queue_from_aute;
     2325 
     2326 
     2327 search_skip_for_queue: entry (ec);			/* queue, queue_index, and cur_message_id were set by caller */
     2328 
     2329 	ec = error_table_$no_message;			/* be pessimistic; zero it if we find the request */
     2330 	aip = null;				/* gets set if we find the request */
     2331 	if queue_index = 0 then return;		/* if bad queue number, which skip list would we search? */
     2332 
     2333 /* Search skip list belonging to specified queue */
     2334 
     2335 	loop_limit = 0;
     2336 	do aix = absentee_data.queue_data (queue).tail_skip /* go thru skip list from tail */
     2337 	     repeat absentee_data.entry (aix).prev_skip	/* backwards */
     2338 	     while (aix ^= 0			/* until we hit the end or find the one we want */
     2339 	     & absentee_data.entry (aix).message_id ^= cur_message_id);
     2340 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
     2341 	     if loop_limit > absentee_data.last then
     2342 		call loop_error ("search_skip", "skip", queue); /* does not return */
     2343 	end;
     2344 
     2345 	if aix > 0 then do;				/* if we found it */
     2346 	     ec = 0;				/* tell caller we found it */
     2347 	     aip = addr (absentee_data.entry (aix));	/* return ptr to it in global variable */
     2348 	end;
     2349 
     2350 	return;
     2351 
     2352      end search_skip_for_aute;
     2353 
     2354 send_abs_wakeup: proc;
     2355 
     2356 dcl  mess char (8) aligned,				/* contents of wakeup message sent to AUM */
     2357      event fixed bin (71) based (addr (mess));		/* overlay signal with variable that hcs_$wakeup will accept  */
     2358 
     2359 	if ctl_wakeup then mess = "aum_ctl";		/* special case: AUM is sending itself an "aum_ctl" wakeup */
     2360 	else mess = "login   ";			/* normal case: somebody is sending AUM a "login" wakeup */
     2361 	call hcs_$wakeup (whotab.abs_procid, whotab.abs_event, event, code);
     2362 	if code ^= 0 then
     2363 	     call sys_log_$error_log (SL_LOG_SILENT, code, name, "Sending ^a wakeup to ^12.3b (^24.3b)",
     2364 		mess, whotab.abs_procid, unspec (whotab.abs_event));
     2365 
     2366 	return;
     2367 
     2368      end send_abs_wakeup;
     2369 
     2370 send_user_message: proc;
     2371 
     2372 /* Send message to user. Arguments: user_message, return_args.sender, return_args.sender_authorization. */
     2373 
     2374 	unspec (send_mail_info) = ""b;
     2375 	send_mail_info.version = send_mail_info_version_2;
     2376 	send_mail_info.wakeup = "1"b;
     2377 	send_mail_info.always_add = "1"b;
     2378 	send_mail_info.sent_from = "absentee";
     2379 	call send_mail_$access_class (substr (rtrim (return_args.sender), 1, length (rtrim (return_args.sender)) - 2),
     2380 	     rtrim (user_message), addr (send_mail_info), (return_args.sender_authorization), code);
     2381 	if code ^= 0
     2382 	     & code ^= error_table_$messages_off
     2383 	     & code ^= error_table_$messages_deferred
     2384 	then call sys_log_$error_log (SL_LOG_SILENT, code, name, "Unable to notify user ^a of absentee event.",
     2385 		return_args.sender);
     2386 
     2387 	return;
     2388 
     2389      end send_user_message;
     2390 
     2391 set_defer_timer: proc (time);
     2392 
     2393 /* Internal procedure to set the alarm timer for both deferred requests and
     2394*   requests waiting for resources, and remember which, and when it is set for. */
     2395 
     2396 dcl  time fixed bin (71);
     2397 dcl  rsc_sw bit (1) aligned;				/* "1"b if called to set the resource timer */
     2398 
     2399 	if time >= NEVER then return;			/* if accidentally called for a deferred-indefinitely request */
     2400 	rsc_sw = ""b;
     2401 	goto set_timer_common;
     2402 
     2403 /* ---------- */
     2404 
     2405 set_rsc_timer: entry (time);
     2406 
     2407 	rsc_sw = "1"b;
     2408 
     2409 set_timer_common:
     2410 
     2411 	if static_alarm_time = 0 |			/* if there is no current timer */
     2412 	     time < static_alarm_time then do;		/* or new time is before current timer */
     2413 	     if static_alarm_time > 0 then		/* if there is a current timer */
     2414 		call timer_manager_$reset_alarm_wakeup (autbl.defer_channel); /* reset it */
     2415 	     if time <= time_now then do;		/* trap bug */
     2416 		call sys_log_ (SL_LOG_SILENT,
     2417 		     "^a: Attempt to set defer timer to time in past (^24.3b). Setting it to a minute from now.",
     2418 		     name, unspec (time));
     2419 		static_alarm_time = time_now + 1000000; /* one million microseconds from now */
     2420 	     end;
     2421 	     else static_alarm_time = time;		/* remember when the timer is set for */
     2422 	     call timer_manager_$alarm_wakeup (static_alarm_time, "00"b, autbl.defer_channel);
     2423 	     resource_timer_set = rsc_sw;		/* remember if it was for the resource timer */
     2424 	end;
     2425 
     2426 	return;
     2427 
     2428      end set_defer_timer;
     2429 
     2430 setup_queue: proc;
     2431 
     2432 /* See if we want to search current queue; if so, initialize for the search */
     2433 
     2434 	if queue >= -1 & queue <= MAX_QUEUE then	/* TRAP BUG */
     2435 	     queue_index = queue_indices (queue);	/* get its message segment index */
     2436 
     2437 	else do;					/* THE BUG HAS OCCURRED */
     2438 	     queue_index = 0;			/* don't try to read from nonexistent queue */
     2439 	     call sys_log_ (SL_LOG_BEEP, "^a (setup_queue): Invalid queue number: ^d", name, queue);
     2440 	     if autbl.debugging = 1 then		/* makeshift debugging switch */
     2441 		call as_dump_ ("absentee_utility_: invalid queue number.");
     2442 	end;
     2443 
     2444 	if queue_index > 0 then do;			/* if queue was opened successfully */
     2445 	     if autbl.queue_dropped (queue) then	/* if queue has been dropped */
     2446 		queue_index = 0;			/* tell caller to skip it */
     2447 	     else do;
     2448 		if queue >= 0 then			/* if not foreground queue, which isn't bound by reserved slots */
     2449 		     if available_slots_ (max (queue, 1), autbl.max_abs_users, (autbl.qres), (autbl.n_abs)) <= 0
     2450 		     then queue_index = 0;		/* if no slots available to this queue, tell caller to skip it */
     2451 	     end;
     2452 
     2453 	     if queue_index > 0 then do;		/* if we're going to search this queue */
     2454 		list_searched = CPUT_LIST;		/* start search at beginning of cput list */
     2455 		aix = 0;				/* there is no current list entry */
     2456 		cur_message_id = ""b;		/* and no current message */
     2457 	     end;
     2458 	end;
     2459 
     2460 	return;
     2461 
     2462      end setup_queue;
     2463 
     2464 suspend_absentee_processing: proc;
     2465 
     2466 	do queue = -1 to MAX_QUEUE;			/* drop all queues */
     2467 	     autbl.queue_dropped (queue) = "1"b;
     2468 	end;
     2469 	call reset_alarm_timer;			/* make sure we don't get any alarm wakeups */
     2470 	call as_dump_ ("absentee_utility_: absentee processing suspended.");
     2471 	call sys_log_ (SL_LOG_BEEP, "^a: Absentee processing suspended. Contact system programmer.", name);
     2472 	goto abort_label;
     2473 
     2474      end suspend_absentee_processing;
     2475 
     2476 thread_cput: proc;
     2477 
     2478 /* Thread request onto end of cput list.
     2479*   Input arguments: aix is index of entry to be threaded; aip is ptr to it; queue is queue it is from. */
     2480 
     2481 	abs_info.cput_list = "1"b;			/* identify entry as being on cput list */
     2482 	abs_info.cpu_limit = ute.max_cpu_time;		/* remember how high a limit this one needs */
     2483 
     2484 	abs_info.next_cput = 0;			/* next entry is tail of list */
     2485 	abs_info.prev_cput = absentee_data.queue_data (queue).tail_cput; /* previous request was last in list */
     2486 
     2487 	if abs_info.prev_cput > 0 then		/* if previous entry exists */
     2488 	     absentee_data.entry (abs_info.prev_cput).next_cput = aix; /* set its forward thread */
     2489 	else absentee_data.queue_data (queue).head_cput = aix; /* else set head of list */
     2490 	absentee_data.queue_data (queue).tail_cput = aix; /* this is the new last entry in list */
     2491 
     2492 	return;
     2493 
     2494      end thread_cput;
     2495 
     2496 thread_lc: proc;
     2497 
     2498 /* Thread request onto end of lc list.
     2499*   Input arguments: aix is index of entry to be threaded; aip (on which abs_info is based) is ptr to it. */
     2500 
     2501 	autbl.lc_list = "1"b;			/* tell AUM that the lc list is non-empty */
     2502 	abs_info.lc_list = "1"b;			/* identify entry as being on lc list */
     2503 
     2504 /* first set threads in entry being added */
     2505 
     2506 	abs_info.prev_lc = absentee_data.tail_lc;	/* point backthread at former last entry */
     2507 	abs_info.next_lc = 0;			/* point forward thread at tail of list */
     2508 
     2509 /* then set threads in previous entry and tail */
     2510 
     2511 	if abs_info.prev_lc > 0 then			/* if there is a previous entry */
     2512 	     absentee_data.entry (abs_info.prev_lc).next_lc = aix; /* point its forward thread to this one */
     2513 	else absentee_data.head_lc = aix;		/* else point head of list to this one */
     2514 
     2515 	absentee_data.tail_lc = aix;			/* point tail of list at this entry */
     2516 
     2517 	return;
     2518 
     2519      end thread_lc;
     2520 
     2521 thread_resource: proc;
     2522 
     2523 /* Procedure to thread an entry onto the end of either the ready list or the resource list
     2524*   (which is the first section of the ready list).
     2525*   Input arguments: aix is index of entry to be threaded; aip is ptr to it; queue is which queue it is from. */
     2526 
     2527 	abs_info.resource_list = "1"b;		/* this also tells us which entry point we came in at */
     2528 	abs_info.can_run = "1"b;			/* requests waiting for resources are always eligible. See below
     2529*						   for explanation of eligibility and the can_run switch. */
     2530 	autbl.rsc_waiting (queue) = autbl.rsc_waiting (queue) + 1; /* remember how many of these we have, for each queue */
     2531 	abs_info.prev_ready = absentee_data.queue_data (queue).tail_resource; /* thread onto end of resource list */
     2532 
     2533 /* ---------- */
     2534 
     2535 thread_ready: entry;				/* enter here to thread entry onto end of ready list */
     2536 
     2537 	abs_info.ready_list = "1"b;			/* set this switch no matter which entry we came in at */
     2538 
     2539 	if ^abs_info.resource_list then		/* if we did not enter at thread_resource */
     2540 	     abs_info.prev_ready = absentee_data.queue_data (queue).tail_ready; /* thread onto end of ready list */
     2541 
     2542 /* The current entry's back thread is now set. Set the forward thread, and then thread the previous entry to this one. */
     2543 
     2544 	if abs_info.prev_ready > 0 then do;		/* if previous entry exists */
     2545 	     abs_info.next_ready = absentee_data.entry (abs_info.prev_ready).next_ready; /* copy its forward thread */
     2546 	     absentee_data.entry (abs_info.prev_ready).next_ready = aix; /* and then point it at this entry */
     2547 	end;
     2548 	else do;
     2549 	     abs_info.next_ready = absentee_data.queue_data (queue).head_ready; /* else copy head-of-list thread */
     2550 	     absentee_data.queue_data (queue).head_ready = aix; /* and then point it at this entry */
     2551 	end;
     2552 
     2553 /* Now thread following entry to this one */
     2554 
     2555 	if abs_info.next_ready > 0 then		/* if following entry exists (only possible for resource list) */
     2556 	     absentee_data.entry (abs_info.next_ready).prev_ready = aix; /* point its back thread at current entry */
     2557 	else absentee_data.queue_data (queue).tail_ready = aix; /* else point tail thread at this entry */
     2558 
     2559 /* If we are threading onto the resource list, set its tail thread, and flag the entry if it's the first in this wakeup */
     2560 
     2561 	if abs_info.resource_list then do;
     2562 	     absentee_data.queue_data (queue).tail_resource = aix;
     2563 	     if absentee_data.last_rsc (queue) = 0 then	/* if this is first addition to resource list in this wakeup */
     2564 		absentee_data.last_rsc (queue) = aix;	/* save its index to tell when to stop resource list search */
     2565 	end;
     2566 
     2567 /* Now, if this is a ready list entry, for a request whose time has just arrived, we want to treat it as if
     2568*   it had just been entered in the queue, so we mark it as to be run after the one that's currently last in the queue.
     2569*   There are several complications to this: since we might defer the last request for any one of a number of reasons
     2570*   when we finally get around to processing it, we want to delay this new ready request only until we get to the last request
     2571*   in the queue and put it in the skip list, whether we run it then or not. It follows from this that if the
     2572*   last request in the queue is already in the skip list, we don't want to delay the new ready request at all,
     2573*   so we mark it as eligible to run immediately. */
     2574 
     2575 	if ^abs_info.resource_list then do;		/* if ready list */
     2576 
     2577 	     call read_msg (BACKWARD, (""b), code);	/* read last message in queue */
     2578 	     if code ^= 0 then			/* if we can't read a request */
     2579 		abs_info.can_run = "1"b;		/* we can't hold the current one behind it */
     2580 	     else do;				/* we did read a request */
     2581 		if absentee_data.queue_data (queue).tail_skip > 0 then /* if there is a last skip list entry */
     2582 		     if absentee_data.entry (absentee_data.queue_data (queue).tail_skip).message_id
     2583 			>= return_args.mess_id then
     2584 			abs_info.can_run = "1"b;	/* if last request is on skip list, let current one run */
     2585 
     2586 		if ^abs_info.can_run then		/* otherwise delay it until last request in queue is processed */
     2587 		     abs_info.last_message_id = return_args.mess_id;
     2588 
     2589 		call free_req;			/* free storage that request was read into */
     2590 	     end;
     2591 	end;
     2592 
     2593 	return;
     2594 
     2595      end thread_resource;
     2596 
     2597 update_ready: proc;
     2598 
     2599 /* Procedure to search ready list for requests that can not be run until
     2600*   after the current one, and mark them as now free to run. Since several requests
     2601*   could have the same deferred time, it is possible that we will find more than
     2602*   one request to mark as free to run.
     2603*
     2604*   Input argument: cur_message_id identifies the current request.
     2605*
     2606**/
     2607 
     2608 dcl  loop_limit fixed bin;
     2609 dcl  ix fixed bin;
     2610 dcl  found_one bit (1) aligned init (""b);
     2611 
     2612 /* Pick up index of first ready list entry that is not part of resource list */
     2613 
     2614 	if absentee_data.queue_data (queue).tail_resource > 0 then /* if resource list is non-empty */
     2615 	     ix = absentee_data.entry (absentee_data.queue_data (queue).tail_resource).next_ready;
     2616 						/* pick up index of first entry after resource list */
     2617 	else ix = absentee_data.queue_data (queue).head_ready; /* else pick up index of first ready list entry */
     2618 
     2619 /* Look at all entries from there to the end of the list. */
     2620 
     2621 	loop_limit = 0;
     2622 	do while (ix ^= 0);
     2623 	     if absentee_data.entry (ix).last_message_id = cur_message_id then
     2624 						/* if this request held behind current one */
     2625 		absentee_data.entry (ix).can_run,	/* it is now eligible to run */
     2626 		     found_one = "1"b;		/* and remember to send a login wakeup later */
     2627 	     ix = absentee_data.entry (ix).next_ready;	/* get index of next ready list entry */
     2628 	     loop_limit = loop_limit + 1;		/* avoid infinite loop if list damaged */
     2629 	     if loop_limit > absentee_data.last then
     2630 		call loop_error ("update_ready", "ready", queue); /* does not return */
     2631 	end;
     2632 
     2633 	if found_one then				/* if we found any requests that can run now */
     2634 	     call send_abs_wakeup;			/* make sure we try to log them in immediately */
     2635 
     2636 	return;
     2637 
     2638      end update_ready;
     2639 
     2640 validate_proxy:
     2641      procedure;
     2642 declare  code fixed bin (35);
     2643 declare  (
     2644          proxy_sender,
     2645          desired_project varying,
     2646          desired_person varying
     2647          ) character (32);
     2648 
     2649 	proxy_sender = request.proxy_name;		/* copy name of proxy for efficiency */
     2650 	desired_project = rtrim (before (after (proxy_sender, "."), "."));
     2651 	desired_person = rtrim (before (proxy_sender, "."));
     2652 
     2653 	if ^valid_proxy (code)
     2654 	then do;
     2655 	     call sys_log_$error_log (SL_LOG, code, name, "Illegal proxy for ^a from ^a for job ^a>^a", proxy_sender,
     2656 		return_args.sender, request.dirname, request.ename);
     2657 	     call message_error (3);			/* 3 = no proxy permission */
     2658 	     return;
     2659 	end;
     2660 	ute.proxy_person = ute.person;		/* save userid of user who actually entered the job */
     2661 	ute.proxy_project = substr (ute.project, 1, length (ute.proxy_project));
     2662 
     2663 	ute.project = desired_project;
     2664 	ute.person = desired_person;
     2665 	ute.tag = TAG_PROXY;
     2666 
     2667 valid_proxy:
     2668 	procedure (code) returns (bit (1));
     2669 
     2670 declare  code fixed bin (35);
     2671 declare  modes bit (36);
     2672 
     2673 dcl  Absentee_proxy_dot_acs
     2674 	character (32) initial ("absentee_proxy.acs")
     2675 	internal static options (constant);
     2676 
     2677 /* Check the acs controlling proxy access */
     2678 
     2679 	     modes =
     2680 		get_effmode (as_data_$acsdir, Absentee_proxy_dot_acs, (return_args.sender),
     2681 		return_args.ring, code);
     2682 
     2683 	     if code = 0
     2684 	     then if (modes & "010"b) ^= ""b
     2685 		then return ("1"b);
     2686 		else code = error_table_$no_e_permission;
     2687 
     2688 /* here ==> no proxy permission and code set to a reason */
     2689 /* no go nowhere. Return code for system acs. */
     2690 
     2691 	     return (""b);
     2692 
     2693 	end valid_proxy;
     2694      end validate_proxy;
     2695 
     2696 setup:
     2697 						/* initialize automatic variables */
     2698           procedure;
     2699      
     2700 	autp = as_data_$autp;			/* absentee_user_table pointer */
     2701 	ev_calls_masked, ctl_wakeup = ""b;
     2702 	p = null;
     2703 	return_args.reqp = null;
     2704 	message_in_error = ""b;
     2705 	error (*) = ""b;
     2706    end setup;
     2707 
     2708 /* format: off */
     2709  /* BEGIN INCLUDE FILE abs_args.incl.pl1 */
  1     2 
  1     3 /* This include file defines a structure to hold the job selection arguments used by the operator abs command.
  1     4*
  1     5*   Written by T. Casey, January 1979
  1     6*   September 1981, E. N. Kittlitz, made character strings unaligned.
  1     7*
  1     8**/
  1     9 
  1    10 dcl 1 abs_args aligned based (abs_arg_ptr),		/* ptr to be dcl-ed in procedures that use structure */
  1    11     2 arg_switches,
  1    12       3 user_sw bit (1) unal,
  1    13       3 id_sw bit (1) unal,
  1    14       3 path_sw bit (1) unal,
  1    15       3 entry_sw bit (1) unal,
  1    16       3 sender_sw bit (1) unal,
  1    17       3 queue_sw bit (1) unal,
  1    18       3 absn_sw bit (1) unal,
  1    19       3 abs_star_sw bit (1) unal,
  1    20     2 person char (28) unal,
  1    21     2 project char (9) unal,
  1    22     2 request_id_string char (32) unal,
  1    23     2 dirname char (168) unal,
  1    24     2 ename char (32) unal,
  1    25     2 sender char (32) unal,
  1    26     2 aut_index fixed bin,
  1    27     2 queue fixed bin,
  1    28     2 request_id fixed bin (71);
  1    29 
  1    30 /* END INCLUDE FILE abs_args.incl.pl1 */
     2709 
     2710  /* BEGIN INCLUDE FILE abs_data.incl.pl1 */
  2     2 
  2     3 /* Absentee data is an array of entries that are threaded into a number of
  2     4*   different lists. The skip list is the only "real" list, in the sense that all
  2     5*   non-free entries are threaded into it, and the other lists (the defer, ready, cputime,
  2     6*   lc, and resource lists) each consist of subsets of the skip list. (The free list
  2     7*   does not count, as far as the logic goes, since it is just a list of free array
  2     8*   entries that can be used when a new entry is to be added to the skip list. If
  2     9*   there are no free entries, a new one is made at the end of the array.)
  2    10*
  2    11*   The skip, cputime, and readys are actually sixs, one per queue. The defer
  2    12*   list contains requests from all six queues, ordered by their deferred times. When
  2    13*   a deferred request reaches the head of the defer list, and then its time arrives,
  2    14*   it is moved to the tail of the ready list for its queue. Then it is marked as to
  2    15*   be run after the request which is currently at the end of its queue. The
  2    16*   intention is that when a request's deferred time arrives, it will be treated as
  2    17*   if it had just been entered. Requests in the ready list are ordered by their
  2    18*   deferred time, so when a request is found whose "position" in the queue (i.e.,
  2    19*   the job it must be run after) has not yet reached the head of the queue, it
  2    20*   is known that none after it can be run either. A request that is deferred indefinitely
  2    21*   is placed at the end of the defer list, and when the operator releases it, it is
  2    22*   moved into the ready list as if its time had just arrived.
  2    23*
  2    24*   The resource list, although logically a separate list, is implemented as the
  2    25*   first part of the ready list, so the two can be searched as one continuous
  2    26*   list. It contains requests waiting for resource reservations. They are ordered
  2    27*   by their original queue positions, and they are each free to run as soon as
  2    28*   their required resources become available. A request refused login by load control
  2    29*   is waiting for a "resource" - namely a free slot in its load control group.
  2    30*   Thus it is held in the resource list.
  2    31*
  2    32*   Requests in the cputime list are deferred because their cpu time limits are higher
  2    33*   than their queue's max limit for the current shift. These requests are ordered by
  2    34*   their original queue positions. Whenever the max limit for any queue is raised,
  2    35*   the cputime list for that queue is scanned from the beginning for requests that
  2    36*   can now be run, and those requests are run before any more requests are taken
  2    37*   from the queue.
  2    38*
  2    39*   Requests in the skip list but in none of the others are jobs that are running
  2    40*   now, and should be deleted from the queue after they log out.
  2    41*
  2    42*   The run list is the first part of the skip list. It exists so that jobs started by
  2    43*   the abs run operator command can have skip list entries. Such jobs can not be put
  2    44*   at the tail of the skip list, because they have been taken from an arbitrary spot
  2    45*   in the queue, for immediate running, and the last skip list entry serves as an
  2    46*   indicator of where in the queue to read the next job from.
  2    47*
  2    48*   The load control list (lc list) is a single list (i.e., not one per queue),
  2    49*   made up of entries that are on the resource list for some queue. Entries
  2    50*   are placed in this list when they are deferred by load control. The purpose of this
  2    51*   list is to remember what users, projects, and groups are having their jobs deferred
  2    52*   by load control, so we can avoid trying to log in other jobs from the same
  2    53*   users, projects, or groups, when it is certian that they will also be deferred.
  2    54*   This list is built up as we try to find a job that can log in, and it is
  2    55*   destroyed just before we go blocked with no more work to do; it is NOT
  2    56*   destroyed when we go blocked with more work to do, after sending ourselves
  2    57*   an "aum_ctl" wakeup.
  2    58*
  2    59*   This segment is maintained by absentee_utility_ and dumped by dump_abs_data.
  2    60*
  2    61*   The padding is deliberately arranged to make the header 100 octal words long,
  2    62*   and each entry 40 octal words long, for convenient reading of octal dumps.
  2    63*
  2    64*   The segment is truncated and rebuilt at each answering service startup,
  2    65*   so there is no need to maintain compatibility with old versions of the structure.
  2    66*
  2    67*   Modified by T. Casey, May 1978, for resource reservations.
  2    68*   Modified by T. Casey, November 1978, for MR7.0, adding cputime list, and queues zero and foreground.
  2    69*   Modified by T. Casey, April 1979, for MR7.0a, to add deferral_logged bit.
  2    70*   Modified by T. Casey, June 1981, for MR9.0, to add group, person, project, and lc list variables.
  2    71*
  2    72**/
  2    73 
  2    74 dcl  ABS_DATA_version_2 fixed bin int static options (constant) init (2); /* version number of this declaration */
  2    75 
  2    76 dcl 1 absentee_data aligned based (adp),		/* template of internal storage area */
  2    77 						/* adp is declared (static or automatic) by users of this file */
  2    78 
  2    79     2 version fixed bin,				/* version of this structure */
  2    80     2 last fixed bin,				/* current number of entries */
  2    81     2 tail_free fixed bin,				/* index of last free entry - if zero no free entry */
  2    82     2 head_defer fixed bin,				/* index of first deferred request */
  2    83     2 tail_defer fixed bin,				/* index of last deferred request */
  2    84     2 head_lc fixed bin,				/* index of first entry on lc list */
  2    85     2 tail_lc fixed bin,				/* index of last entry on lc list */
  2    86     2 rebuilding bit (1) unaligned,			/* on if lists being rebuilt following loop in list search */
  2    87     2 asd_pad1 bit (35) unaligned,
  2    88     2 last_rsc (-1:4) fixed bin,			/* to detect when one pass thru resource list is done */
  2    89     2 asd_pad2 (2) fixed bin,				/* pad to end of 2nd 8-word block */
  2    90 						/* begin 6-element array of 8-word blocks */
  2    91     2 queue_data (-1:4) aligned,
  2    92       3 head_ready fixed bin,				/* index of first ready request in queue */
  2    93       3 tail_ready fixed bin,				/* ........ last ready ................. */
  2    94       3 head_skip fixed bin,
  2    95       3 tail_skip fixed bin,				/* ........ last skip .................. */
  2    96       3 tail_run fixed bin,
  2    97       3 tail_resource fixed bin,
  2    98       3 head_cput fixed bin,
  2    99       3 tail_cput fixed bin,
  2   100 
  2   101 /* end of 8th 8-word block - the header is 64 words long and the entries begin at 100 octal */
  2   102 
  2   103     2 entry (0 refer (absentee_data.last)) aligned like abs_info; /* entries are 32 words long (40 octal) */
  2   104 
  2   105 dcl  aip ptr init (null);
  2   106 
  2   107 dcl 1 abs_info aligned based (aip),			/* description of each entry */
  2   108     2 next_skip fixed bin,
  2   109     2 prev_skip fixed bin,
  2   110     2 next_defer fixed bin,
  2   111     2 prev_defer fixed bin,
  2   112     2 next_ready fixed bin,
  2   113     2 prev_ready fixed bin,
  2   114     2 next_cput fixed bin,
  2   115     2 prev_cput fixed bin,
  2   116 
  2   117 /* 10 octal */
  2   118     2 prev_free fixed bin,				/* index of previous free entry in free list */
  2   119     2 queue fixed bin,
  2   120     2 switches,
  2   121       3 can_run bit (1) unaligned,			/* part of ready list - if on can run */
  2   122       3 waiting_for_resources bit (1) unaligned,		/* part of resource list */
  2   123       3 waiting_for_load_ctl bit (1) unaligned,
  2   124       3 free_list bit (1) unaligned,
  2   125       3 skip_list bit (1) unaligned,
  2   126       3 defer_list bit (1) unaligned,
  2   127       3 ready_list bit (1) unaligned,
  2   128       3 resource_list bit (1) unaligned,
  2   129       3 cput_list bit (1) unaligned,
  2   130       3 run_list bit (1) unaligned,
  2   131       3 deferral_notified bit (1) unaligned,
  2   132       3 deferral_logged bit (1) unaligned,
  2   133       3 lc_list bit (1) unaligned,			/* entry is in lc list */
  2   134     2 lc_reason fixed bin (2) unsigned unaligned,		/* 1=user limit; 2=project limit; 3=group limit */
  2   135     2 asd_pad3 bit (21) unaligned,
  2   136     2 cpu_limit fixed bin,				/* time limit, if on cput list */
  2   137     2 time fixed bin (71),				/* part of defer list - deferred time */
  2   138     2 message_id bit (72) aligned,			/* id of this request in the queue message segment */
  2   139 
  2   140 /* 20 octal */
  2   141     2 last_message_id bit (72) aligned,			/* request which must be run before this request can */
  2   142     2 request_id fixed bin (71),			/* request id of this request */
  2   143     2 group char (8),
  2   144     2 prev_lc fixed bin,				/* index of previous entry on load control (lc) list */
  2   145     2 next_lc fixed bin,				/* index of next entry on lc list */
  2   146 
  2   147 /* 30 octal */
  2   148     2 person char (22) unaligned,
  2   149     2 asd_pad4 char (1) unaligned,
  2   150     2 project char (9) unaligned;
  2   151 						/* an entry is 40 octal words long */
  2   152 
  2   153 /* END INCLUDE FILE ... abs_data.incl.pl1 */
     2710 
     2711  /* BEGIN INCLUDE FILE ... abs_message_format.incl.pl1 */
  3     2 
  3     3 /* Requires user_attributes.incl.pl1 */
  3     4 
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-03-01,Gilcrease), approve(86-03-27,MCR7370),
  3     8*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
  3     9*     Modified 740723 by PG to add AIM info
  3    10*     Modified April 1978 by T. Casey to add much new info and change version number to 4
  3    11*     Modified November 1978 by T. Casey to add secondary_ok
  3    12*     Modified June 1981 by T. Casey for MR9.0 to make max_cpu_time fixed bin (35) (was fixed bin (17) aligned)
  3    13*  2) change(86-03-27,Gilcrease), approve(86-03-27,MCR7370),
  3    14*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
  3    15*     Add truncate_absout and restarted bits for -truncate absout. SCP 6297.
  3    16*  3) change(86-12-08,GDixon), approve(87-07-16,MCR7741),
  3    17*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  3    18*     Changed structure under request.abs_attributes to use like structure in
  3    19*     abs_attributes.incl.pl1.  This allows the same attributes to be used
  3    20*     in pit.incl.pl1 and user_table_entry.incl.pl1 as well as this include
  3    21*     file.
  3    22*  4) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  3    23*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  3    24*     Added the version 6 elements: home_dir, init_proc, initial_ring,
  3    25*     len_homedir, len_initproc. SCP6367
  3    26*  5) change(88-07-29,Parisek), approve(88-07-29,PBF7849),
  3    27*     audit(88-07-29,Lippard), install(88-08-01,MR12.2-1072):
  3    28*     Place the elements "home_dir", and "init_proc" before the varying length
  3    29*     element "args" in the stucture.  Since "args" length can grow varyingly,
  3    30*     it should remain at the bottom of the structure.
  3    31*                                                   END HISTORY COMMENTS */
  3    32 
  3    33 
  3    34 dcl  abs_message_version_6 fixed bin int static options (constant) init (6);
  3    35 
  3    36 dcl 1 request aligned based (reqp),			/* format of absentee request */
  3    37 						/* the pointer, reqp, must be declared in the including program */
  3    38     2 request_header like queue_msg_hdr,		/* 62 words */
  3    39     2 request_version fixed bin,			/* identification of version of abs request */
  3    40     2 len_name fixed bin,				/* length of name */
  3    41     2 arg_count fixed bin,				/* number of arguments to input segment */
  3    42     2 len_args fixed bin,				/* length of string containing arguments to input segment */
  3    43     2 len_output fixed bin,				/* length of output pathname */
  3    44     2 len_proxy fixed bin,				/* length of proxy name */
  3    45     2 len_resource fixed bin,				/* length of resource description */
  3    46     2 len_sender fixed bin,				/* length of sender */
  3    47     2 len_comment fixed bin,				/* length of comment */
  3    48     2 len_vpad fixed bin,				/* length of spare variable length string */
  3    49     2 initial_ring fixed bin,				/* initial ring number request */
  3    50     2 len_homedir fixed bin,				/* length of home_dir */
  3    51     2 len_initproc fixed bin,				/* length of login responder string */
  3    52     2 request_pad (5) fixed bin,			/* leave room for stuff we did not think of this time */
  3    53     2 deferred_time fixed bin (71),			/* clock time until which this request should be held + not run */
  3    54     2 max_cpu_time fixed bin (35),			/* user given cpu limit in seconds */
  3    55     2 requested_authorization bit (72),			/* request should be run at this authorization */
  3    56     2 abs_attributes aligned like user_abs_attributes,	/* include user_abs_attributes.incl.pl1 */
  3    57     2 abs_status_flags,				/* bits giving reasons for job's status */
  3    58       3 operator_deferred_until_time bit (1) unaligned,
  3    59       3 operator_deferred_indefinitely bit (1) unaligned,
  3    60       3 resources_unavailable bit (1) unaligned,
  3    61       3 cpu_time_limit bit (1) unaligned,
  3    62       3 queue_limit bit (1) unaligned,
  3    63       3 user_limit bit (1) unaligned,
  3    64       3 load_control bit (1) unaligned,
  3    65       3 status_pad bit (29) unaligned,
  3    66  
  3    67     2 name char (0 refer (request.len_name)) aligned,	/* personal name of requestor */
  3    68     2 output_file char (0 refer (request.len_output)) aligned, /* absolute pathname of output file */
  3    69     2 proxy_name char (0 refer (request.len_proxy)) aligned, /* name of user for whom submitted */
  3    70     2 resource char (0 refer (request.len_resource)) aligned, /* resource description */
  3    71     2 sender char (0 refer (request.len_sender)) aligned,	/* name of RJE station or other sender */
  3    72     2 comment char (0 refer (request.len_comment)) aligned, /* message to operator, or anything else user puts in it */
  3    73     2 home_dir char (0 refer (request.len_homedir)) aligned,/* initial home dir */
  3    74     2 init_proc char (0 refer (request.len_initproc)) aligned,
  3    75 						/* name of login responder */
  3    76     2 vpad char (0 refer (request.len_vpad)) aligned,	/* for the thing we didn't think of this time */
  3    77     2 arg_lengths (0 refer (request.arg_count)) fixed bin,	/* array of argument lengths */
  3    78     2 args char (0 refer (request.len_args)) aligned;	/* string containing arguments to control segment */
  3    79 
  3    80 /* END INCLUDE FILE ... abs_message_format.incl.pl1 */
     2711 
     2712  /* BEGIN INCLUDE FILE ... absentee_user_table.incl.pl1 */
  4     2 
  4     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 /*							       */
  4     5 /* The absentee user table is the control data base for the absentee	       */
  4     6 /* facility.  It has a header, with scheduling parameters, then one user     */
  4     7 /* table entry for each logged-in absentee job.			       */
  4     8 /*							       */
  4     9 /* Programs which use this table must also include		       */
  4    10 /* user_table_header.incl.pl1 and user_table_entry.incl.pl1.	       */
  4    11 /*							       */
  4    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    13 
  4    14 
  4    15 /****^  HISTORY COMMENTS:
  4    16*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  4    17*     Replace abs_user_tab.incl.pl1.
  4    18*  2) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  4    19*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4    20*     Use ut_header common to all user control tables.
  4    21*                                                   END HISTORY COMMENTS */
  4    22 
  4    23 
  4    24 dcl  AUTBL_version_4 fixed bin int static options (constant) init (4);
  4    25 
  4    26 dcl  autp ptr automatic init (null);
  4    27 
  4    28 dcl 1 autbl based (autp) aligned,			/* a per system table to store info on absentee processes */
  4    29     2 header like ut_header,				/* Header common to all user tables. */
  4    30 
  4    31 /* Counter elements */
  4    32     2 n_abs_run fixed bin,				/* actual number of absentee processes current */
  4    33     2 max_abs_users fixed bin,			/* max number of background absentee processes permitted */
  4    34     2 n_background_abs fixed bin,			/* number of absentee processes not from foreground queue */
  4    35     2 n_sec_fg fixed bin,				/* number of secondary foreground absentee jobs */
  4    36     2 idle_units fixed bin,				/* used in adjusting abs_maxu dynamically */
  4    37     2 abs_units fixed bin,				/* part of anstbl.n_units used by background absentees */
  4    38     2 n_abs (4) fixed bin,				/* number of processes from each background queue */
  4    39     2 qres (4) fixed bin,				/* number of slots reserved for each background queue */
  4    40     2 rsc_waiting (-1:4) fixed bin,			/* number of requests waiting for resources, from each queue */
  4    41     2 qerr (-1:4) fixed bin,				/* number of consecutive errors for q (dropped if > QERR_MAX) */
  4    42     2 cpu_limit (4) fixed bin (35),			/* current per-queue cpu time limits */
  4    43 
  4    44 /* absentee user manager values. */
  4    45     2 defer_channel fixed bin (71),			/* IPC for time-defered queue entries */
  4    46     2 absentee_rq_chn fixed bin (71),			/* IPC channel for absentee requests */
  4    47     2 last_queue_searched fixed bin,			/* highest queue looked at by scheduler */
  4    48     2 debugging fixed bin,				/* take asdumps at strategic places */
  4    49     2 control,					/* see also whotab.incl.pl1 */
  4    50       3 mnbz bit (1) unal,				/* must not be zero */
  4    51       3 abs_maxu_auto bit (1) unal,			/* 1 if abs maxu has not been set by operator command */
  4    52       3 abs_maxq_auto bit (1) unal,			/* 1 if abs maxq has not been set by operator command */
  4    53       3 abs_qres_auto bit (1) unal,			/* 1 if abs qres has not been set by operator command */
  4    54       3 abs_cpu_limit_auto bit (1) unal,		/* 1 if abs cpu_limit has not been set by operator command */
  4    55       3 queue_dropped (-1:4) bit (1) unal,		/* 1 if queue has been dropped because of errors */
  4    56       3 abs_up bit (1) unal,				/* 1 if absentee facility is running */
  4    57       3 abs_stopped bit (1) unal,			/* 1 if abs stop command was issued */
  4    58 						/* both 1 if we're waiting for the last jobs to log out */
  4    59       3 aum_ctl bit (1) unal,				/* for AUM to tell AU to start a new sequence */
  4    60       3 lc_list bit (1) unal,				/* for AU to tell AUM that the lc list is non-empty */
  4    61 						/* comments in AU and AUM explain aum_ctl and lc_list */
  4    62       3 control_pad (21) bit (1) unal,			/* fill out rest of word */
  4    63     2 aum_pad fixed bin,
  4    64 
  4    65     2 entry_pad (80) fixed bin,			/*  pad table header to 128 words */
  4    66     2 entry (0 refer (autbl.current_size)) like ute;
  4    67 
  4    68 dcl AUTBL_CONTROL_NAMES (15) char(20) varying int static options(constant) init(
  4    69 	"mnbz",
  4    70 	"abs_maxu_auto",
  4    71 	"abs_maxq_auto",
  4    72 	"abs_qres_auto",
  4    73 	"abs_cpu_limit_auto",
  4    74 	"queue_dropped(-1)",
  4    75 	"queue_dropped( 0)",
  4    76 	"queue_dropped( 1)",
  4    77 	"queue_dropped( 2)",
  4    78 	"queue_dropped( 3)",
  4    79 	"queue_dropped( 4)",
  4    80 	"abs_up",
  4    81 	"abs_stopped",
  4    82 	"aum_ctl",
  4    83 	"lc_list");
  4    84 
  4    85 /* END INCLUDE FILE ... absentee_user_table.incl.pl1 */
     2712 
     2713  /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  5     2 
  5     3 /* Created 740723 by PG */
  5     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  5     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  5     6 
  5     7 /* This structure defines the components of both an access
  5     8*   class and an access authorization as interpreted by the
  5     9*   Access Isolation Mechanism. */
  5    10 
  5    11 
  5    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  5    13        2 categories bit (36),				/* access categories */
  5    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  5    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  5    16         (3 ipc,					/* interprocess communication privilege */
  5    17          3 dir,					/* directory privilege */
  5    18          3 seg,					/* segment privilege */
  5    19          3 soos,					/* security out-of-service privilege */
  5    20          3 ring1,					/* ring 1 access privilege */
  5    21          3 rcp,					/* RCP resource access privilege */
  5    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  5    23          3 pad bit (11);
  5    24 
  5    25 
  5    26 /* END INCLUDE FILE aim_template.incl.pl1 */
     2713 
     2714  /* BEGIN INCLUDE FILE ... as_data_.incl.pl1 ... */
  6     2 
  6     3 /* format: style4 */
  6     4 
  6     5 /* This file must be kept in sync with as_data_.alm */
  6     6 
  6     7 /****^  HISTORY COMMENTS:
  6     8*  1) change(86-09-21,Beattie), approve(86-09-22,MCR7542),
  6     9*     audit(86-10-31,Brunelle), install(86-11-12,MR12.0-1211):
  6    10*     Remove references to the 963 and 029 preaccess commands and remove support
  6    11*     for ARDS, 202_ETX, 2741 and 1050 in system interfaces.
  6    12*  2) change(86-09-25,Swenson), approve(87-07-20,MCR7737),
  6    13*     audit(87-07-20,GDixon), install(87-08-04,MR12.1-1056):
  6    14*     Add references to as_data_ entrypoints added for Login Server.
  6    15*  3) change(87-03-03,Brunelle), approve(87-07-20,MCR7697),
  6    16*     audit(87-07-20,GDixon), install(87-08-04,MR12.1-1056):
  6    17*     Added new user signal field of inacrcvd (14) to handle inactivity response
  6    18*     from user.
  6    19*                                                   END HISTORY COMMENTS */
  6    20 
  6    21 dcl  as_data_$BS char (1) aligned ext static;		/* BACKSPACE character */
  6    22 dcl  as_data_$CR char (1) aligned ext static;		/* CARRIAGE RETURN character */
  6    23 dcl  as_data_$abs_dim char (32) ext static;		/* absentee DIM */
  6    24 dcl  as_data_$acct_update_priority fixed bin ext static;	/* accounting update IPC priority */
  6    25 dcl  as_data_$acsdir char (168) ext static;		/* Access Control Segment directory */
  6    26 dcl  as_data_$ansp ptr ext static;			/* answer_table */
  6    27 dcl  as_data_$as_procid bit (36) aligned ext static;	/* Answering Service process id */
  6    28 dcl  as_data_$as_ring fixed bin (3) ext static;		/* AS operating ring */
  6    29 dcl  as_data_$as_tty char (6);			/* AS master tty channel */
  6    30 dcl  as_data_$asmtp ptr ext static;			/* AS meter table */
  6    31 dcl  as_data_$autp ptr ext static;			/* absentee_user_table */
  6    32 dcl  as_data_$buzzardp ptr ext static;			/* dpg_ list of buteo processes */
  6    33 dcl  as_data_$cdtp ptr ext static;			/* CDT */
  6    34 dcl  as_data_$default_weight fixed bin (35) ext;		/* default user process load control weight */
  6    35 dcl  as_data_$devtabp ptr ext static;			/* device_table */
  6    36 dcl  as_data_$dft_user_ring fixed bin (3) ext static;	/* default user ring */
  6    37 dcl  as_data_$dutp ptr ext static;			/* daemon_user_table */
  6    38 dcl  as_data_$g115_dim char (32) ext static;
  6    39 dcl  as_data_$lct_initialized bit (1) aligned ext static;	/* LCT allocated in ring 0 */
  6    40 dcl  as_data_$lct_size fixed bin ext static;		/* CDT tty channels + spares */
  6    41 dcl  as_data_$max_user_ring fixed bin (3) ext static;	/* maximum user ring */
  6    42 dcl  as_data_$mgtp ptr ext static;			/* master group table */
  6    43 dcl  as_data_$mrd_dim char (32) ext static;		/* daemon's message routing DIM */
  6    44 dcl  as_data_$ntty_dim char (32) ext static;		/* network connection DIM */
  6    45 dcl  as_data_$pdtdir char (168) ext static;		/* PDT directory */
  6    46 dcl  as_data_$pit_ptr ptr ext static;			/* pit_temp_ */
  6    47 dcl  as_data_$rcpdir char (168) ext static;		/* RCP directory */
  6    48 dcl  as_data_$request_priority fixed bin ext static;
  6    49 dcl  as_data_$rs_ptrs (0:9) ptr ext static;		/* rate_structures */
  6    50 dcl  as_data_$rtdtp ptr ext static;			/* RTDT */
  6    51 dcl  as_data_$sat_htp ptr ext static;			/* SAT hash table */
  6    52 dcl  as_data_$satp ptr ext static;			/* SAT */
  6    53 dcl  as_data_$suffix (0:9) char (2) unaligned ext static;
  6    54 dcl  as_data_$sysdir char (168) ext static;		/* system control directory */
  6    55 dcl  as_data_$teens_suffix (10:19) char (2) unaligned ext static;
  6    56 dcl  as_data_$terminet_tabs_string char (144) varying ext static;
  6    57 dcl  as_data_$tty_dim char (32) ext static;		/* standard interactive DIM */
  6    58 dcl  as_data_$update_priority fixed bin ext static;	/* ??? */
  6    59 dcl  as_data_$version char (8) ext static;		/* AS version */
  6    60 dcl  as_data_$whoptr ptr ext static;			/* whotab */
  6    61 
  6    62 dcl  1 as_data_$login_args aligned ext static,		/* control arguments for login */
  6    63        2 n_login_args fixed bin,
  6    64        2 pad fixed bin,
  6    65        2 login_args (55 /* as_data_$login_args.n_login_args */) char (24) unaligned;
  6    66 
  6    67 dcl  1 as_data_$signal_types ext static aligned,		/* IPC process control signals */
  6    68        2 n_signals fixed bin,
  6    69        2 pad fixed bin,
  6    70        2 signals (14 /* as_data_$signal_types.n_signals */) char (8) unaligned;
  6    71 
  6    72 dcl  1 as_data_$system_signal_types ext static aligned,	/* IPC process control signals */
  6    73        2 n_system_signals fixed bin,
  6    74        2 pad fixed bin,
  6    75        2 system_signals (10 /* as_data_$system_signal_types.n_system_signals */) char (8) unaligned;
  6    76 
  6    77 dcl  as_data_$login_words fixed bin ext static aligned,
  6    78 						/* interactive login words */
  6    79      1 as_data_login_words aligned based (addr (as_data_$login_words)),
  6    80        2 n_words fixed bin,
  6    81        2 pad fixed bin,
  6    82        2 words (0 refer (as_data_login_words.n_words)) char (16) unaligned;
  6    83 
  6    84 dcl  as_data_$debug_flag bit (1) aligned external static;
  6    85 dcl  as_data_$ls_request_server_info_ptr ptr external static;
  6    86 dcl  as_data_$ls_message_buffer_cur_lth fixed bin (18) external static;
  6    87 dcl  as_data_$ls_message_buffer_max_lth fixed bin (18) external static;
  6    88 dcl  as_data_$ls_message_buffer_ptr ptr external static;
  6    89 
  6    90 /* END INCLUDE FILE ... as_data_.incl.pl1 ... */
     2714 
     2715  /* BEGIN INCLUDE FILE ... as_data_definitions_.incl.pl1 ... */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  7     6*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7     7*     Removed ansp, autp and dutp from this include file, adding them to
  7     8*     answer_table.incl.pl1, absentee_user_table.incl.pl1 and
  7     9*     daemon_user_table.incl.pl1.
  7    10*                                                   END HISTORY COMMENTS */
  7    11 
  7    12 
  7    13 /* This include file requires as_data_.incl.pl1 */
  7    14 
  7    15 /* format: style4 */
  7    16 
  7    17 dcl  as_procid bit (36) aligned defined (as_data_$as_procid);
  7    18 dcl  as_tty char (6) based (addr (as_data_$as_tty));
  7    19 dcl  asmtp ptr defined (as_data_$asmtp);
  7    20 dcl  devtabp ptr defined (as_data_$devtabp);
  7    21 dcl  ip ptr defined (as_data_$rs_ptrs (0));
  7    22 dcl  mgtp ptr defined (as_data_$mgtp);
  7    23 dcl  pdtdir char (168) based (addr (as_data_$pdtdir));
  7    24 dcl  rs_ptrs (0:9) ptr based (addr (as_data_$rs_ptrs (0)));
  7    25 dcl  sat_htp ptr defined (as_data_$sat_htp);
  7    26 dcl  satp ptr defined (as_data_$satp);
  7    27 dcl  scdtp ptr defined (as_data_$cdtp);
  7    28 dcl  sysdir char (168) defined (as_data_$sysdir);
  7    29 dcl  whoptr ptr defined (as_data_$whoptr);
  7    30 
  7    31 /* END INCLUDE FILE ... as_data_definitions_.incl.pl1 ... */
     2715 
     2716  /* BEGIN INCLUDE FILE as_meter_numbers.incl.pl1 */
  8     2 
  8     3 /* These are the names and numbers of the slots in as_meter_table 
  8     4*   (see as_meter_table.incl.pl1).
  8     5*
  8     6*   Written March 1980 by Tom Casey
  8     7*   Modified June 1981 by T. Casey for MR9.0 to add ABS_TRYLOG_METER.
  8     8**/
  8     9 
  8    10 
  8    11 /****^  HISTORY COMMENTS:
  8    12*  1) change(86-01-31,Herbst), approve(87-07-21,MCR7694),
  8    13*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1056):
  8    14*      A) Add NETUP_METER.
  8    15*      B) Add AS_METER_NAMES array.
  8    16*                                                   END HISTORY COMMENTS */
  8    17 
  8    18 
  8    19 dcl  ASINIT_METER fixed bin int static options (constant) init (1); /* as_init_, parts 1 and 2 */
  8    20 dcl  DIALUP_METER fixed bin int static options (constant) init (2); /* dialup_ */
  8    21 dcl  DUM_METER fixed bin int static options (constant) init (3); /* daemon_user_manager_ */
  8    22 dcl  AUM_METER fixed bin int static options (constant) init (4); /* absentee_user_manager_ */
  8    23 dcl  AU_METER fixed bin int static options (constant) init (5); /* absentee_utility_ */
  8    24 dcl  CPG_METER fixed bin int static options (constant) init (6); /* cpg_ */
  8    25 dcl  DPG_METER fixed bin int static options (constant) init (7); /* dpg_ */
  8    26 dcl  ACCTUP_METER fixed bin int static options (constant) init (8); /* accounting updates */
  8    27 dcl  INSTALL_METER fixed bin int static options (constant) init (9); /* installs (up_sysctl_) */
  8    28 dcl  ABSQ_METER fixed bin int static options (constant) init (10); /* absentee queue reads and writes */
  8    29 dcl  MSGCORD_METER fixed bin int static options (constant) init (11); /* message coordinator */
  8    30 dcl  COMMAND_METER fixed bin int static options (constant) init (12); /* operator commands, other than admin */
  8    31 dcl  SAC_METER fixed bin int static options (constant) init (13); /* sac (send_admin_command handling) */
  8    32 dcl  ADMIN_METER fixed bin int static options (constant) init (14); /* admin mode */
  8    33 dcl  SSU_METER fixed bin int static options (constant) init (15); /* system_start_up.ec, parts 1, 2, and 3 */
  8    34 dcl  FIXPDT_METER fixed bin int static options (constant) init (16); /* cleanup of PDTs after crash (act_ctl_$init) */
  8    35 dcl  ABS_TRYLOG_METER fixed bin int static options (constant) init (17); /* attempts to login absentees via call lg_ctl_
  8    36*						   (the attempts might fail because of load control limits) */
  8    37 dcl  NETUP_METER fixed bin int static options (constant) init (18); /* a call to network_accounting_update_ */
  8    38 
  8    39 dcl  recursion_possible bit (18) int static options (constant) init ("000000000011000000"b); /* 11 & 12 (MSGCORD and COMMAND) */
  8    40 
  8    41 /* Bit length of recursion_possible equals highest slot number given above.  */
  8    42 
  8    43 dcl  AS_METER_NAMES (18) char (8) int static options (constant) init (
  8    44      "ASINIT",  "DIALUP",   "DUM",    "AUM",     "AU",
  8    45      "CPG",     "DPG",      "ACCTUP", "INSTALL", "ABSQ",
  8    46      "MSGCORD", "COMMAND",  "SAC",    "ADMIN",   "SSU",
  8    47      "FIXPDT",  "TRYABSLG", "NETUP");
  8    48 
  8    49 /* END INCLUDE FILE as_meter_numbers.incl.pl1 */
     2716 
     2717  /* Begin include file as_request_sender_.incl.pl1 84-06-06 BIM */
  9     2 
  9     3 /****^  HISTORY COMMENTS:
  9     4*  1) change(86-10-14,Lippard), approve(85-12-30,MCR7326),
  9     5*     audit(86-10-24,GDixon), install(86-10-28,MR12.0-1200):
  9     6*      Added max_authorization and audit_flags.
  9     7*                                                   END HISTORY COMMENTS */
  9     8 
  9     9 /* Structure passed from as_request_server_ to the various
  9    10*   requests to identify requester. */
  9    11 /* format: style3,indcomtxt */
  9    12 
  9    13 declare	as_request_sender_ptr
  9    14 			pointer;
  9    15 declare	1 as_request_sender aligned based (as_request_sender_ptr),
  9    16 	  2 version	char (8) aligned,
  9    17 	  2 reply_message	fixed bin (71),
  9    18 	  2 group_id	char (32) unaligned,
  9    19 	  2 process_id	bit (36),
  9    20 	  2 validation_level
  9    21 			fixed bin (3),
  9    22 	  2 authorization	bit (72),
  9    23 	  2 max_authorization
  9    24 			bit (72),
  9    25 	  2 audit_flags	bit (36);
  9    26 
  9    27 declare	AS_REQUEST_SENDER_VERSION_2
  9    28 			char (8) init ("asrqs002") internal static options (constant);
  9    29 
  9    30 /* End include file as_request_sender_.incl.pl1 */
     2717 
     2718  /* BEGIN INCLUDE FILE as_wakeup_priorities.incl.pl1 */
 10     2 
 10     3 /* This include file defines the priorities of all of the event channels used by the answering service.
 10     4*
 10     5*   They are declared as named constants. They are used in calls to ipc_$decl_ev_call_chn.
 10     6*   The names correspond to the functions of the event call handlers.
 10     7*   For brevity in names, MC means message coordinator, and LOGIN includes logout as well.
 10     8*
 10     9*   The comment on each constant lists the procedure(s) that use it to set event channel priorities.
 10    10*   See the code in those procedures for information on the handlers themselves
 10    11*   (which are entry variables in some cases, and thus could not be documented in this file).
 10    12*
 10    13*   The priorities range from zero (highest) to 22 (lowest used by the answering service).
 10    14*
 10    15*   The event wait channel on which the A.S. goes blocked awaiting input on the initializer console has highest
 10    16*   of all priorities, set by as_init_ calling ipc_$set_wait_prior.
 10    17*
 10    18*   Written June 1981 by T. Casey for MR9.0
 10    19*   Modified 1984-10-15 BIM for sac -> as_request.
 10    20*	  as_request is above login, since sac is important and
 10    21*	  dial requests for already logged in users can take
 10    22*	  first dibs over new logins.
 10    23**/
 10    24 
 10    25 dcl  MC_PRIO fixed bin int static options (constant) init (1); /* mc_commands_, mc_con_rec_, mc_util_, mrd_tester */
 10    26 dcl  SYSERR_COPY_PRIO fixed bin int static options (constant) init (2); /* syserr_log_man_ */
 10    27 dcl  SHUTDOWN_PRIO fixed bin int static options (constant) init (3); /* admin */
 10    28 dcl  ACCT_UPDATE_PRIO fixed bin int static options (constant) init (4); /* act_ctl_ */
 10    29 dcl  DAEMON_LOGIN_PRIO fixed bin int static options (constant) init (8); /* daemon_user_manager_ */
 10    30 dcl  AS_REQUEST_PRIO fixed bin int static options (constant) init (7); /* as_request_ */
 10    31 dcl  INSTALL_PRIO fixed bin int static options (constant) init (8); /* up_sysctl_ */
 10    32 dcl  INT_LOGIN_PRIO fixed bin int static options (constant) init (8); /* asu_, dialup_, ftp_dialup_ */
 10    33 dcl  MPX_LOAD_PRIO fixed bin int static options (constant) init (11);
 10    34 						/* as_vip7760_mpx_, as_mcs_mpx_, as_ibm3270_mpx_, as_hasp_mpx_ */
 10    35 dcl  ABS_DEFER_PRIO fixed bin int static options (constant) init (19); /* absentee_utility_ */
 10    36 dcl  ABS_LOGIN_PRIO fixed bin int static options (constant) init (20); /* abentee_user_manager_ */
 10    37 dcl  CORE_FLUSH_PRIO fixed bin int static options (constant) init (22); /* as_meter_ */
 10    38 
 10    39 /* END INCLUDE FILE as_wakeup_priorities.incl.pl1 */
     2718 
     2719  /* BEGIN INCLUDE FILE ... dialup_values.incl.pl1 */
 11     2 
 11     3 /* format: style4 */
 11     4 
 11     5 /* Values for "cdte.tra_vec" used by dialup_ and others. */
 11     6 
 11     7 /* Modified by T. Casey April 1976 to add WAIT_NEW_PASSWORD
 11     8*   -		in 1977 and 1978 to add WAIT_(GREETING_MSG DELETE_CHANNEL)
 11     9*   -		and in October 1979 to add WAIT_CONNECT_REQUEST
 11    10*   Modified by Robert Coren in May 1981 to add TANDD_ATTACH values and 
 11    11*		WAIT_DISCARD_WAKEUP
 11    12*   Modified by T. Casey, July 1981, for MR9.0, to add WAIT_BEFORE_HANGUP.
 11    13*   Modified by E. N. Kittlitz, July 1982, to add TTY_MASKED.
 11    14**/
 11    15 
 11    16 /****^  HISTORY COMMENTS:
 11    17*  1) change(87-04-20,GDixon), approve(87-07-13,MCR7741),
 11    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    19*     Add constant arrays naming cdte.state, cdte.tra_vec and ute.active values.
 11    20*  2) change(87-05-11,GDixon), approve(87-07-13,MCR7741),
 11    21*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    22*     Add named constants for instance tags.
 11    23*                                                   END HISTORY COMMENTS */
 11    24 
 11    25 dcl  (WAIT_DIALUP init (1),				/* Channel waiting for dialup. */
 11    26      WAIT_ANSWERBACK initial (2),			/* WRU sent, waiting for reply */
 11    27      WAIT_LOGIN_LINE init (3),			/* Greeting typed, wait for login command. */
 11    28      WAIT_LOGIN_ARGS init (4),			/* Want rest of login line */
 11    29      WAIT_OLD_PASSWORD init (5),			/* "-cpw" was specified. Wait for old password. */
 11    30      WAIT_PASSWORD init (6),				/* Waiting for password. (If "-cpw", repeat of new one.) */
 11    31      WAIT_NEW_PASSWORD init (7),			/* "-cpw" was specified. Wait for new password */
 11    32      WAIT_LOGOUT_SIG init (8),			/* Channel is hooked up. Wait for logout. */
 11    33      WAIT_LOGOUT init (9),				/* A logout has been requested. Wait for process to die */
 11    34      WAIT_LOGOUT_HOLD init (10),			/* As above but don't hang up when it dies. */
 11    35      WAIT_DETACH init (11),				/* As above but ignore channel afterwards. */
 11    36      WAIT_NEW_PROC init (12),				/* As above but make new process and continue. */
 11    37      WAIT_REMOVE init (13),				/* As above but completely expunge channel. */
 11    38      WAIT_FIN_PRIV_ATTACH init (14),			/* When channel dials up, connect it to user */
 11    39      WAIT_DIAL_RELEASE init (15),			/* Waiting for master process to release. */
 11    40      WAIT_DIAL_OUT init (16),				/* Waiting for auto call to complete */
 11    41      WAIT_HANGUP init (17),				/* Wait for the hangup event to occur for a channel */
 11    42      WAIT_SLAVE_REQUEST init (18),			/* Ignore line until someone asks */
 11    43      WAIT_GREETING_MSG init (19),			/* Print greeting message and wait for login line */
 11    44      WAIT_DELETE_CHANNEL init (20),			/* Channel deleted - mark cdte after process is destroyed */
 11    45      WAIT_CONNECT_REQUEST init (21),			/* logged in; awaiting request re disconnected processes */
 11    46      WAIT_TANDD_HANGUP init (22),			/* when channel hangs up, proceed with t & d attachment */
 11    47      WAIT_FIN_TANDD_ATTACH init (23),			/* when channel dials up, finish t & d attachment */
 11    48      WAIT_DISCARD_WAKEUPS init (24),			/* disregard all wakeups on channel */
 11    49      WAIT_BEFORE_HANGUP init (25),			/* allow output to print before hanging up */
 11    50      WAIT_DESTROY_REQUEST init (26),			/* waiting to continue with destroy request after process has destroyed itself */
 11    51      WAIT_NEW_PROC_REQUEST init (27)			/* waiting to continue with new_proc request after process has destroyed itself */
 11    52      ) fixed bin internal static options (constant);
 11    53 
 11    54 dcl  TRA_VEC_VALUES (0:13) char (32) aligned int static options (constant) init
 11    55 						/* names of ute.destroy_flag values */
 11    56 	("", "wait dialup", "wait answerback", "wait login line", /*  0-3  */
 11    57 	"wait login args", "wait old password", "wait password",  /*  4-6  */
 11    58 	"wait new password", "wait logout signal", "wait logout", /*  7-9  */
 11    59 	"wait logout hold", "wait detach", "wait new proc",       /* 10-12 */
 11    60 	"wait remove");				        /*   -13 */
 11    61 
 11    62 /* Values for "cdte.state", typewriter state. */
 11    63 
 11    64 dcl  (TTY_MASKED init (-1),				/* Terminal channel is there, but masked by MCS */
 11    65      TTY_HUNG init (1),				/* Terminal channel is there, but dead. */
 11    66      TTY_KNOWN init (2),				/* Channel being "listened" to, awaiting dialup. */
 11    67      TTY_DIALED init (5)				/* Channel is dialed up. This is normal state. */
 11    68      ) fixed bin internal static options (constant);
 11    69 
 11    70 dcl  STATE_VALUES (-1:5) char (15) aligned int static options (constant) init
 11    71 						/* names of cdte.state values */
 11    72 	("masked", "dead", "hung up", "listening", "", "", "dialed up");
 11    73 
 11    74 /* Values for "cdte.in_use" and "ate.active" */
 11    75 
 11    76 dcl  (NOW_FREE init (0),				/* Entry is empty. */
 11    77      NOW_HUNG_UP init (1),				/* Entry is usable but tty is hung up. */
 11    78      NOW_LISTENING init (2),				/* Entry is waiting for phone call. */
 11    79      NOW_DIALED init (3),				/* Entry is connected but login not complete. */
 11    80      NOW_LOGGED_IN init (4),				/* Entry is logged in but no process. */
 11    81      NOW_HAS_PROCESS init (5),			/* Entry has a valid process. */
 11    82      NOW_DIALING init (6),				/* Entry (auto_call line) is dialing */
 11    83      NOW_DIALED_OUT init (7)				/* Entry (auto_call line) is in use */
 11    84      ) fixed bin internal static options (constant);
 11    85 
 11    86 dcl  ACTIVE_VALUES (0:5) char (18) aligned int static options (constant) init
 11    87 						/* names of ute.active values */
 11    88 	("free", "hung-up", "listening", "dialed", "logged in, no proc", "logged in & proc");
 11    89 
 11    90 
 11    91 /**** Values for ute.tag */
 11    92 
 11    93 dcl (TAG_INTERACTIVE init("a"),
 11    94      TAG_UFT init("f"),
 11    95      TAG_ABSENTEE init("m"),
 11    96      TAG_PROXY init("p"),
 11    97      TAG_DAEMON init("z")
 11    98      ) char(1) int static options(constant);
 11    99 
 11   100 
 11   101 /**** Following are constants used to indicate to the process termination
 11   102*      handler the reason for the process termination.  They are used by
 11   103*      uc_proc_term_handler_, as well as uc_ls_new_proc_request_ and
 11   104*      uc_ls_destroy_request_. */
 11   105 
 11   106 dcl  (
 11   107      PT_FPE initial (1),
 11   108      PT_LOGOUT initial (4),
 11   109      PT_NEW_PROC_AUTH initial (13),
 11   110      PT_HANGUP initial (20),
 11   111      PT_SHUTDOWN initial (21),
 11   112      PT_BUMP initial (22),
 11   113      PT_ALARM initial (23),
 11   114      PT_DETACH initial (24),
 11   115      PT_UNBUMP initial (25),
 11   116      PT_OPERATOR_TERMINATE initial (27),
 11   117      PT_DESTROY_REQUEST initial (30),
 11   118      PT_NEW_PROC_REQUEST initial (31)
 11   119      ) fixed bin (17) internal static options (constant);
 11   120 
 11   121 /**** Values for ute.preempted:
 11   122*  -1  user unbumped after term signal sent
 11   123*   0  user unbumped; ignore alarm___
 11   124*   1  value internally used in load_ctl_
 11   125*   2  user bumped; when alarm___ comes in, send term signal
 11   126*   3  term signal sent; destroy process if termsgnl, alarm___, or cpulimit 
 11   127*      signals come in
 11   128*   4  user bumped; process sick, so destroy without sending term signal
 11   129*   5  trm_ signal sent, termsgnl received; (if still 3, we never got the 
 11   130*      termsgnl).						       */
 11   131 
 11   132 dcl  (
 11   133      PREEMPT_UNBUMP initial (-1),
 11   134      PREEMPT_UNBUMP_IGNORE_ALARM initial (0),
 11   135      PREEMPT_LOAD_CTL initial (1),
 11   136      PREEMPT_BUMPED initial (2),
 11   137      PREEMPT_TERM_SENT initial (3),
 11   138      PREEMPT_BUMPED_NO_TERM initial (4),
 11   139      PREEMPT_TERMSGNL_RECEIVED initial (5)
 11   140      ) fixed bin (17) internal static options(constant);
 11   141 
 11   142 dcl  PREEMPT_VALUES (-1:5) char(28) varying int static options(constant) init(
 11   143 	"unbumped",
 11   144 	"not bumped, ignore alarm___",
 11   145 	"load_ctl_",
 11   146 	"bumped",
 11   147 	"bumped, trm_ sent",
 11   148 	"bumped without trm_",
 11   149 	"bumped, termsgnl received");
 11   150 
 11   151 /* END INCLUDE FILE ... dialup_values.incl.pl1 */
     2719 
     2720  /* BEGIN INCLUDE FILE ... installation_parms.incl.pl1 */
 12     2 
 12     3 /* Modified 740723 by PG to add short AIM access names */
 12     4 /* Modified Fall 1977 by T. Casey to add fatal loop and trm_ signal parameters */
 12     5 /* Modified 04/03/78 by CDT to add rcp_init_flags structure */
 12     6 /* Modified May 1978 by T. Casey to add resource timer and resource price list parameters */
 12     7 /* Modified November 1978 by T. Casey for MR7.0, to add absentee control parameters */
 12     8 /* Modified 17 September 1980 by G. Palter to add default absentee queue */
 12     9 /* Modified April 1981 by E. N. Kittlitz for chn_wakeup_error_loop, chn_wakeup_error_count */
 12    10 /* Modified June 1981 by E. N. Kittlitz for nrates/rate_structures UNCA rate_structure support.
 12    11*     Version, expand foregound_cpu_default_limit and abs_cpu_max_limit to fixed bin (35) fields.
 12    12*     nrscp & resource array moved from offset 2064 (octal) to 2400 (octal). */
 12    13 /* Modified 1984-06-19 BIM to remove obsolete fields, and add 
 12    14*		       strict_trusted_path. */
 12    15 /* Modified 1984-10-24 BIM for default_pdir_quota. */
 12    16 /* Modified 1984-12-05 BIM for require_operator_login. */
 12    17 /* Modified 1985-03-01 by E. Swenson for password flags. */
 12    18 
 12    19 
 12    20 /****^  HISTORY COMMENTS:
 12    21*  1) change(86-01-27,MSharpe), approve(87-05-25,MCR7690),
 12    22*     audit(87-03-29,GDixon), install(87-08-04,MR12.1-1056):
 12    23*     added vchn_requires_accept parameter.
 12    24*  2) change(87-02-17,GDixon), approve(87-05-25,MCR7680),
 12    25*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 12    26*     Correct formatting problems.
 12    27*                                                   END HISTORY COMMENTS */
 12    28 
 12    29 
 12    30 /* NOTE: rate_structure.incl.pl1 uses these declarations */
 12    31 
 12    32 
 12    33 dcl 1 installation_parms based (ip) aligned,		/* describes installation parameters */
 12    34     2 part_1 like installation_parms_part_1 aligned,
 12    35     2 resource (0 refer (installation_parms.nrscp)) like installation_parms_resource_array_part aligned;
 12    36 
 12    37 dcl  installation_parms_version_1 fixed bin init (1) static internal options (constant);
 12    38 dcl  installation_parms_version_2 fixed bin init (2) static internal options (constant);
 12    39 
 12    40 dcl 1 installation_parms_part_1 based aligned,		/* Used only by installation_parms and rate_structure */
 12    41     2 installation_id char (32),			/* Name printed at dialup and in who */
 12    42     2 company char (64),				/* company name */
 12    43     2 department char (64),				/* department */
 12    44     2 companyds char (120),				/* company, double spaced */
 12    45     2 departmentds char (120),			/* dpeartment double spaced */
 12    46     2 shifttab (336) bit (3) unal,			/* half-hrs from 0000 Mon, value is shift no */
 12    47     2 cpu_price (0: 7) float bin,			/* price for cpu hour, by shift */
 12    48     2 log_base_price (0: 7) float bin,			/* price for log hour, by shift */
 12    49     2 io_ops_price (0: 7) float bin,			/* price per 1000 terminal io ops */
 12    50     2 core_price (0: 7) float bin,			/* price for core page-hour, by shift */
 12    51     2 ndevices fixed bin,				/* number of devices to charge */
 12    52     2 devtab (16),					/* Maximum 16 */
 12    53       3 device_id char (8),				/* Name of device */
 12    54       3 device_price (0: 7) float bin,			/* Price by shift */
 12    55     2 inactive_time fixed bin,			/* seconds of inactivity permitted */
 12    56     2 warning_time fixed bin,				/* seconds from warning to logout */
 12    57     2 login_time fixed bin,				/* seconds in which to complete login */
 12    58     2 acct_update fixed bin,				/* seconds between acct update */
 12    59     2 login_tries fixed bin,				/* number of login tries allowed */
 12    60     2 disk_price float bin,				/* disk rate, in $/page-sec */
 12    61     2 registration_price float bin,			/* fee per month per user */
 12    62     2 dolsign char (1),				/* "dollar sign" */
 12    63     2 abs_cpu_price (4) float bin,			/* price for absentee cpu by queue */
 12    64     2 abs_mem_price (4) float bin,			/* Absentee memory charge */
 12    65     2 iod_rec_price (4) float bin,			/* price for io daemon lines, per K, by queue */
 12    66     2 abs_timax (4) fixed bin (35),			/* Absentee TIMAX parameter */
 12    67     2 abs_cpu_default_limit (4) fixed bin (35),		/* default absentee cpu limit in seconds (changed from usec.) */
 12    68     2 syserr_log_copy_threshold fixed bin (9),		/* Threshold (in PAGES) at which the
 12    69*						   Initializer will copy the syserr_log */
 12    70     2 default_pdir_seg_quota fixed bin (17) unaligned,	/* if system and project say 0 */
 12    71     2 default_pdir_dir_quota fixed bin (17) unaligned,       /* Always used */
 12    72     2 fatal_error_loop_count fixed bin (17) unaligned,
 12    73     2 fatal_error_loop_seconds fixed bin (17) unaligned,
 12    74     2 term_real_time_seconds fixed bin (17) unaligned,
 12    75     2 term_cpu_time_seconds fixed bin (17) unaligned,
 12    76     2 rcp_init_flags like rcp_init_flags aligned,		/* one word long */
 12    77     2 rsc_timer_seconds fixed bin (17) unaligned,		/* time interval at which to check for resource availability */
 12    78     2 pad_old_fg_cpu_default_limit bit (18) unaligned,
 12    79     2 foreground_queue_position fixed bin (17) unal,	/* queue that foreground queue comes after */
 12    80     2 idle_time_constant_seconds fixed bin (17) unal,	/* how far back to maintain moving average of load */
 12    81     2 sus_cpu_time_seconds fixed bin (17) unal,		/* allow suspended process this much cpu time */
 12    82     2 sus_real_time_seconds fixed bin (17) unal,		/* and this much real time, before bumping it */
 12    83     2 foreground_cpu_default_limit fixed bin (35),	/* default cpu time limit (sec) for foreground absentee jobs */
 12    84     2 access_authorization_ceiling bit (72),		/* "System high" access authorization. */
 12    85     2 level_names (0:7) char (32),			/* Names for security levels. */
 12    86     2 category_names (18) char (32),			/* Names for security categories. */
 12    87     2 short_level_names (0:7) char (8),			/* Abbreviated level names. */
 12    88     2 short_category_names (18) char (8),		/* Abbreviated category names. */
 12    89     2 ncon fixed bin,				/* Number of config elements. */
 12    90     2 cona (51),					/* each entry is 5 words long */
 12    91       3 cpu fixed bin (5) unal,			/* Number of CPU's */
 12    92       3 shift fixed bin (5) unal,			/* Shift number */
 12    93       3 x1 fixed bin (23) unal,
 12    94       3 kmem fixed bin (17) unal,			/* Memory size */
 12    95       3 kbulk fixed bin (17) unal,			/* Bulk store size */
 12    96       3 x2 fixed bin (17) unal,
 12    97       3 maxa fixed bin (11) unal,			/* Max abs users */
 12    98       3 maxq fixed bin (5) unal,			/* Max abs q */
 12    99       3 maxu_base fixed bin (17) unal,
 12   100       3 response_high fixed bin (17) unal,
 12   101       3 response_low fixed bin (17) unal,
 12   102       3 x3 fixed bin (17) unal,
 12   103 
 12   104 /* Absentee control parameters. New for MR7.0 */
 12   105 
 12   106     2 max_abs (0:7) fixed bin (17) unal,		/* per-shift upper limit on abs_maxu */
 12   107     2 min_abs (0:7) fixed bin (17) unal,		/* per-shift lower limit on abs_maxu */
 12   108     2 pct_abs (0:7) fixed bin (17) unal,		/* abs_maxu is this pct (per-shift) of idle units */
 12   109 
 12   110     2 max_qres (0:7, 4) fixed bin (17) unal,		/* per-shift-and-queue upper limit on reserved slots */
 12   111     2 min_qres (0:7, 4) fixed bin (17) unal,		/* per-shift-and-queue lower limit on reserved slots */
 12   112     2 pct_qres (0:7, 4) fixed bin (17) unal,		/* reserved slots are these pcts of abs_maxu */
 12   113 
 12   114     2 abs_cpu_max_limit (0:7, 4) fixed bin (35),		/* per-shift-and-queue upper limit (sec) on jobs' cpu times */
 12   115 
 12   116     2 default_absentee_queue fixed binary (17) unaligned,	/* default absentee queue for ear, etc. */
 12   117 
 12   118     2 chn_wakeup_error_loop_count fixed bin (17) unaligned, /* maximum number of channel wakeups in following interval */
 12   119     2 chn_wakeup_error_loop_seconds fixed bin (17) unaligned, /* works like fatal_error_loop_count/seconds */
 12   120     2 rate_structure_number fixed bin (17) unaligned,	/* rate_structure number of this RS */
 12   121     2 version fixed bin (35),				/* must be 2 */
 12   122     2 nrates fixed bin,				/* number of rate structures */
 12   123     2 rate_structures (0:9) char (32),			/* names of rate_structures */
 12   124     2 trusted_path_login bit (1) aligned,		/* forbid logout -hold and new_proc -auth */
 12   125     2 require_operator_login bit (1) aligned,		/* just what it says */
 12   126     2 operator_inactive_time fixed bin,			/* seconds between commands --> not logged in. */
 12   127     2 validate_daemon_commands bit (1) aligned,		/* force existence and adequate access to 
 12   128*						   mcacs segments for operators */
 12   129     2 password_min_length fixed bin,			/* minimum length of passwords */
 12   130     2 password_gpw_length fixed bin,			/* length of generated passwords */
 12   131     2 password_change_interval fixed bin,		/* number of days until must change */
 12   132     2 password_expiration_interval fixed bin,		/* number of days that a password may remain unused */
 12   133     2 vchn_requires_accept bit (1) aligned,		/* "login personid -op -vchn foo" must be
 12   134*						   "accepted" by operator if personid is not 
 12   135*						   signed on system console */
 12   136     2 end_pad (219) bit (36) aligned,			/* leave plenty of pad before the variable length price list */
 12   137     2 nrscp fixed bin;				/* length of resource price array; must have offset 2400 (octal),
 12   138*						   or someone miscounted when using part of pad2 */
 12   139 
 12   140 
 12   141 /* Entries in the following array may be accessed via system_info_$resource_price.
 12   142*   This array should not be accessed directly, since its format will change in subsequent releases of Multics. */
 12   143 
 12   144 dcl 1 installation_parms_resource_array_part (0 refer (installation_parms.nrscp)) based,
 12   145       2 name char (32),
 12   146       2 price float bin;
 12   147 
 13     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
 13     2 
 13     3 /* Created on 04/24/78 by Michael R. Jordan */
 13     4 /* Modified 04/10/79 by C. D. Tavares */
 13     5 
 13     6 dcl  rifp ptr;
 13     7 
 13     8 dcl 1 rcp_init_flags based (rifp),
 13     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
 13    10     2 pad1 bit (2) unaligned,				/* obsolete */
 13    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
 13    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
 13    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
 13    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
 13    15 
 13    16 dcl (No_authentication initial (0),
 13    17      Nominal_authentication initial (1),
 13    18      Automatic_authentication initial (2),
 13    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
 13    20 
 13    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
 13    22     ("none", "nominal", "automatic", "manual");
 13    23 
 13    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
 12   148 
 12   149 
 12   150 /* END INCLUDE FILE ... installation_parms.incl.pl1 */
     2720 
     2721  /* BEGIN INCLUDE FILE ... mseg_access_mode_values.incl.pl1 */
 14     2 
 14     3 
 14     4 /****^  HISTORY COMMENTS:
 14     5*  1) change(85-04-01,Palter), approve(), audit(), install():
 14     6*     Initial coding.
 14     7*  2) change(87-04-08,GDixon), approve(87-07-14,MCR7706),
 14     8*     audit(87-07-14,Parisek), install(87-08-04,MR12.1-1056):
 14     9*     Add mseg queue access values for queue users and administrators.
 14    10*                                                   END HISTORY COMMENTS */
 14    11 
 14    12 
 14    13 /* format: style3,linecom */
 14    14 
 14    15 /* Definition of the extended access modes implemented by the message segment primitives (mseg_) */
 14    16 
 14    17 declare	(
 14    18      /*** The individual modes */
 14    19 	MSEG_A_ACCESS	initial ("400000000000"b3),	/* add a message */
 14    20 	MSEG_D_ACCESS	initial ("200000000000"b3),	/* delete/update any message, accept wakeups, etc. */
 14    21 	MSEG_R_ACCESS	initial ("100000000000"b3),	/* read any message */
 14    22 	MSEG_O_ACCESS	initial ("040000000000"b3),	/* read/delete your own messages */
 14    23 	MSEG_S_ACCESS	initial ("020000000000"b3),	/* get the message count, salvaged flag, etc. */
 14    24 	MSEG_W_ACCESS	initial ("010000000000"b3),	/* send a normal wakeup when adding a message */
 14    25 	MSEG_U_ACCESS	initial ("004000000000"b3)	/* send an urgent wakeup when adding a message */
 14    26 	)		bit (36) aligned static options (constant);
 14    27 
 14    28 declare	(
 14    29      /*** Common combinations of the modes */
 14    30 	MSEG_NULL_ACCESS	initial ("000000000000"b3),	/* no access at all */
 14    31 	MSEG_FULL_ACCESS	initial ("774000000000"b3)	/* all possible access */
 14    32 	)		bit (36) aligned static options (constant);
 14    33 
 14    34 /* format: idind40 */
 14    35 
 14    36 declare	(
 14    37      /*** Initial extended access modes of a newly created mailbox -- The following constants yield the following ACL:
 14    38*	     adrosw  Person_id.*.*  (or anonymous.Project_id.*)
 14    39*	     aow	   *.SysDaemon.*
 14    40*	     aow	   *.*.*		*/
 14    41 	MSEG_MBX_INITIAL_ACL		dimension (3) static options (constant)
 14    42 					initial ("770000000000"b3, "450000000000"b3, "450000000000"b3),
 14    43 	MSEG_MBX_CREATOR_INITIAL_ACCESS	defined (MSEG_MBX_INITIAL_ACL (1)),
 14    44 	MSEG_MBX_SYSDAEMON_INITIAL_ACCESS	defined (MSEG_MBX_INITIAL_ACL (2)),
 14    45 	MSEG_MBX_OTHERS_INITIAL_ACCESS	defined (MSEG_MBX_INITIAL_ACL (3))
 14    46 	)				bit (36) aligned;
 14    47 
 14    48 declare	(
 14    49      /*** Initial extended access modes of a newly created queue message segment -- The following constants yield the
 14    50*	following ACL:
 14    51*	     adros   Person_id.*.*  (or anonymous.Project_id.*)
 14    52*	     ao	   *.SysDaemon.*
 14    53*	     null	   *.*.*		*/
 14    54 	MSEG_QUEUE_INITIAL_ACL		dimension (3) static options (constant)
 14    55 					initial ("760000000000"b3, "440000000000"b3, "000000000000"b3),
 14    56 	MSEG_QUEUE_CREATOR_INITIAL_ACCESS	defined (MSEG_QUEUE_INITIAL_ACL (1)),
 14    57 	MSEG_QUEUE_SYSDAEMON_INITIAL_ACCESS	defined (MSEG_QUEUE_INITIAL_ACL (2)),
 14    58 	MSEG_QUEUE_OTHERS_INITIAL_ACCESS	defined (MSEG_QUEUE_INITIAL_ACL (3))
 14    59 	)				bit (36) aligned;
 14    60 
 14    61 declare   (
 14    62      /*** Extended access modes of queue segment users and administrators:
 14    63*	    ao	Queue_User.*.*
 14    64*	    aros  Queue_Admin.*.*     */
 14    65 	MSEG_QUEUE_USER_ACCESS		initial ("440000000000"b3),
 14    66 	MSEG_QUEUE_ADMIN_ACCESS		initial ("560000000000"b3))
 14    67 					bit (36) aligned int static options(constant);
 14    68 
 14    69 /* END INCLUDE FILE ... mseg_access_mode_values.incl.pl1 */
     2721 
     2722  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
 15     2 
 15     3 /* This is the message header used for standard system queue messages, namely:
 15     4*   IO daemon requests, absentee requests, retrieval requests.
 15     5**/
 15     6 
 15     7 /* Written by Jerry Whitmore, Spring 1978.
 15     8*   Modified by T. Casey, November 1978, to add values for state.
 15     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
 15    10**/
 15    11 
 15    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
 15    13     2 msg_time fixed bin (71),			/* date and time of request */
 15    14     2 hdr_version fixed bin,				/* version of this declaration */
 15    15     2 dirname char (168),				/* directory name */
 15    16     2 ename char (32),				/* entry name of file requested */
 15    17     2 message_type fixed bin,				/* message format descriptor   */
 15    18 						/* 0 = absentee request        */
 15    19 						/* 1 = print request           */
 15    20 						/* 2 = punch request           */
 15    21 						/* 3 = tape request            */
 15    22 						/* 4 = retrieval request       */
 15    23     2 bit_flags,
 15    24       3 delete_sw bit (1) unal,			/* delete file when done */
 15    25       3 notify bit (1) unal,				/* user wants to be notified */
 15    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
 15    27       3 padding bit (33) unal,
 15    28     2 state fixed bin,				/* stage of processing after being queued:
 15    29*						   0 = initial unprocessed state, 1 = deferred,
 15    30*						   2 = in state transition, 3 = eligible, 4 = running,
 15    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
 15    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
 15    33     2 std_length fixed bin,				/* length of std msg for this type */
 15    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
 15    35     2 hdr_pad (3) fixed bin;
 15    36 
 15    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
 15    38 
 15    39 /* Values for queue_msg_hdr.state */
 15    40 
 15    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
 15    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
 15    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
 15    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
 15    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
 15    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
 15    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
 15    48 
 15    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
     2722 
     2723  /* --------------- BEGIN include file resource_control_desc.incl.pl1 --------------- */
 16     2 
 16     3 /* Written by R.J.C. Kissel 3/78. */
 16     4 /* Modified 09/28/78 by C. D. Tavares */
 16     5 
 16     6 dcl 1 resource_descriptions based (resource_desc_ptr) aligned,
 16     7     2 version_no fixed bin,				/* caller must set this to resource_desc_version_1 */
 16     8     2 n_items fixed bin,				/* Number of resources described by this structure. */
 16     9     2 item (Resource_count refer (resource_descriptions.n_items)) aligned,
 16    10       3 type char (32),				/* e.g., "tape_drive" */
 16    11       3 name char (32),				/* e.g., "tapa_03" */
 16    12       3 uid bit (36),				/* The resource unique id. */
 16    13       3 potential_attributes bit (72),			/* resource's permissible attributes */
 16    14       3 attributes (2) bit (72),			/* RCP attribute description (output) */
 16    15       3 desired_attributes (4) bit (72),		/* desired attributes (input) */
 16    16       3 potential_aim_range (2) bit (72),		/* Lowest and highest possible AIM bounds for resource */
 16    17       3 aim_range (2) bit (72),			/* Current AIM range */
 16    18       3 owner char (32),				/* e.g., "Smith.Project" */
 16    19       3 acs_path char (168),				/* Access control segment pathname. */
 16    20       3 location char (168),				/* String describing location in unusual cases */
 16    21       3 comment char (168),				/* User-settable comment string */
 16    22       3 charge_type char (32),			/* accounting identifier for this resource */
 16    23       3 rew bit (3) unaligned,			/* user's effective access to resource */
 16    24       3 (usage_lock,				/* This resource may not be acquired or used. */
 16    25          release_lock,				/* The owner is not allowed to release the resource. */
 16    26          awaiting_clear,				/* Resource awaiting manual clear */
 16    27          user_alloc) bit (1) unaligned,			/* User claims volume contains useful data */
 16    28       3 pad2 bit (29) unaligned,			/* Ignored field. */
 16    29       3 given aligned,				/* each of these bits says the corresponding */
 16    30 						/* item is significant on input */
 16    31        (4 (name,
 16    32 	 uid,
 16    33 	 potential_attributes,
 16    34 	 desired_attributes,
 16    35 	 potential_aim_range,
 16    36 	 aim_range,
 16    37 	 owner,
 16    38 	 acs_path,
 16    39 	 location,
 16    40 	 comment,
 16    41 	 charge_type,
 16    42 	 usage_lock,
 16    43 	 release_lock,
 16    44 	 user_alloc) bit (1),
 16    45         4 pad1 bit (22)) unaligned,
 16    46       3 state bit (36) aligned,			/* For use of resource_control_ only */
 16    47       3 status_code fixed bin (35);			/* Standard system status code for this resource. */
 16    48 
 16    49 
 16    50 /* Note that the reservation description must always be used with a resource
 16    51*   description structure.  When they are used together the two structures must
 16    52*   have the same number of entries, i.e. Resource_count is the same for both. */
 16    53 
 16    54 
 16    55 dcl 1 reservation_description based (resource_res_ptr) aligned,
 16    56     2 version_no fixed bin,				/* The version number for this structure. */
 16    57     2 reserved_for char (32),				/* Group id of reserved for process. */
 16    58     2 reserved_by char (32),				/* Group id of reserved by process. */
 16    59     2 reservation_id fixed bin (71),			/* Reservation id of this reservation group. */
 16    60     2 group_starting_time fixed bin (71),		/* Starting time for this reservation group. */
 16    61     2 asap_duration fixed bin (71),			/* Duration after which as soon as possible is no longer good. */
 16    62     2 flags aligned,
 16    63      (3 auto_expire bit (1),				/* Should reservation expire when this process terminates. */
 16    64       3 asap bit (1),				/* Make this reservation group as soon as possible. */
 16    65       3 rel bit (1),				/* Times are relative/absolute. */
 16    66       3 sec bit (1)) unaligned,			/* Times are in sec/microsec. */
 16    67     2 n_items fixed bin,				/* Number of resources reserved in this group. */
 16    68     2 reservation_group (Resource_count refer (reservation_description.n_items)),
 16    69       3 starting_time fixed bin (71),			/* When this resource res. starts in the group. */
 16    70       3 duration fixed bin (71);			/* Duration of this resource res. in the group. */
 16    71 
 16    72 dcl (resource_desc_ptr,
 16    73      resource_res_ptr) pointer;
 16    74 
 16    75 dcl (resource_desc_version_1 initial (1),
 16    76      resource_res_version_1 initial (1)) internal static options (constant);
 16    77 
 16    78 dcl  Resource_count fixed bin;			/* The number of resources described in the structures. */
 16    79 
 16    80 /* ---------------- END include file resource_control_desc.incl.pl1 ---------------- */
     2723 
     2724  /*  BEGIN:   sc_stat_.incl.pl1			  *  *  *  *  *  */
 17     2 
 17     3 
 17     4 /****^  HISTORY COMMENTS:
 17     5*  1) change(87-02-04,GDixon), approve(87-05-25,MCR7690),
 17     6*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 17     7*     Add sc_stat_$vchn_requires_accept in support of DSA virtual channels.
 17     8*  2) change(87-02-04,GDixon), approve(87-05-25,MCR7680),
 17     9*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 17    10*     Reorganized by type of data to improve readability.
 17    11*                                                   END HISTORY COMMENTS */
 17    12 
 17    13 
 17    14 			      /* ACCESS NAMES		       */
 17    15 dcl (
 17    16  sc_stat_$exec_access_name,	      /* check MC access in an exec request    */
 17    17  sc_stat_$unidentified_access_name  /* check access if no one is logged in.  */
 17    18     ) char(32) ext static;
 17    19 
 17    20 		        /* PATHNAMES			       */
 17    21 dcl (
 17    22  sc_stat_$info_dir,	        /* admin info segs directory		       */
 17    23  sc_stat_$log_dir,	        /* as log segs directory		       */
 17    24  sc_stat_$mc_acs_dir,       /* message coordinator ACS segments (.mcacs) dir */
 17    25  sc_stat_$sysdir	        /* system control directory		       */
 17    26     ) char(168) ext static;
 17    27 
 17    28 		        /* OTHER CHAR STRINGS			       */
 17    29 dcl (
 17    30  sc_stat_$master_channel    /* Master TTY channel.		       */
 17    31     )  char(6) aligned ext static;
 17    32 
 17    33 			       /* LABELS			       */
 17    34 dcl (
 17    35  sc_stat_$admin_listener_exit_label, /* GO here to exit admin mode.  Set to  */
 17    36 			       /*    ssu_$null_label unless 	       */
 17    37 			       /*	   admin_listener is active.	       */
 17    38  sc_stat_$master_abort_label,	       /* GO here after fault that is not      */
 17    39 			       /*    attributable to a particular      */
 17    40 			       /*	   command.		       */
 17    41  sc_stat_$system_shutdown_label      /* GO here to shut down system	       */
 17    42     ) label variable ext static;
 17    43 
 17    44 			 /* POINTERS TO			       */
 17    45 dcl (
 17    46  sc_stat_$admin_log_iocb,	 /* IOCB for admin log		       */
 17    47  sc_stat_$admin_log_write_ptr, /* DATA for log_write_ calls on the admin log */
 17    48  sc_stat_$admin_sci_ptr,	 /* DATA ssu_ for terminal currently executing */
 17    49  sc_stat_$as_log_write_ptr,	 /* DATA for log_write_ calls on as log, used  */
 17    50 			 /*      by sys_log_.		       */
 17    51  sc_stat_$initzer_ttyp,	 /* ENT  mc_ate for initializer terminal       */
 17    52  sc_stat_$master_iocb,	 /* IOCB for "master_i/o"		       */
 17    53  sc_stat_$master_sci_ptr,	 /* DATA ssu_ (permanent) for system control   */
 17    54  sc_stat_$mc_ansp,		 /* HEAD of mc_anstbl		       */
 17    55  sc_stat_$mc_iocb,		 /* IOCB ptr for "mc_i/o"		       */
 17    56  sc_stat_$sv1_iocb,		 /* IOCB ptr for "severity1"		       */
 17    57  sc_stat_$sv2_iocb,		 /* IOCB ptr for "severity2"		       */
 17    58  sc_stat_$sv3_iocb		 /* IOCB ptr for "severity3"		       */
 17    59     ) ptr ext static;
 17    60 
 17    61 			   /* SWITCHES			       */
 17    62 dcl (
 17    63  sc_stat_$Go,		   /* TRUE after answering service is listening*/
 17    64  sc_stat_$Go_typed,		   /* TRUE immediately after 'go' is typed     */
 17    65  sc_stat_$Multics,		   /* TRUE after answering service started     */
 17    66  sc_stat_$Multics_typed,	   /* TRUE immediately after 'mult' is typed   */
 17    67  sc_stat_$Star_typed,	   /* TRUE if 'mult' and 'go' came from 'star' */
 17    68  sc_stat_$admin_listener_switch, /* TRUE if in the admin listener	       */
 17    69  sc_stat_$did_part1,	   /* TRUE if part 1 of system startup ec done */
 17    70  sc_stat_$did_part2,	   /* TRUE if part 2 of system startup ec done */
 17    71  sc_stat_$did_part3,	   /* TRUE if part 3 of system startup ec done */
 17    72  sc_stat_$mc_is_on,		   /* TRUE if message coordinator running      */
 17    73  sc_stat_$no_operator_login,	   /* TRUE if operator login not required, or  */
 17    74 			   /*	 if PNT not yet available.	       */
 17    75  sc_stat_$shutdown_typed,	   /* TRUE if 'shutdown' command in progress.  */
 17    76  sc_stat_$test_mode,	   /* TRUE if in test environment	       */
 17    77  sc_stat_$vchn_requires_accept   /* TRUE if vchn may only be used if accepted*/
 17    78 			   /*      by operator signed on system console*/
 17    79     ) bit(1) aligned ext static;
 17    80 
 17    81 
 17    82 /*  END OF:  sc_stat_.incl.pl1			  *  *  *  *  *  */
     2724 
     2725  /*  BEGIN  send_mail_info include file */
 18     2 
 18     3 dcl send_mail_info_version_2 fixed bin init(2);
 18     4 
 18     5 dcl 1 send_mail_info aligned,
 18     6      2 version fixed bin,  /* = 2 */
 18     7      2 sent_from char(32) aligned,
 18     8      2 switches,
 18     9       3 wakeup bit(1) unal,
 18    10       3 mbz1 bit(1) unal,
 18    11       3 always_add bit(1) unal,
 18    12       3 never_add bit(1) unal,
 18    13       3 notify bit(1) unal,
 18    14       3 acknowledge bit(1) unal,
 18    15       3 mbz bit(30) unal;
 18    16 
 18    17 /*  END  send_mail_info include file */
     2725 
     2726  /* BEGIN INCLUDE FILE sys_log_constants.incl.pl1 ... 82-09-24 E. N. Kittlitz */
 19     2 
 19     3 
 19     4 /****^  HISTORY COMMENTS:
 19     5*  1) change(87-04-22,GDixon), approve(87-06-10,MCR7708),
 19     6*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 19     7*     Added sl_info structure and associated named constants for use in calling
 19     8*     sys_log_$general.
 19     9*                                                   END HISTORY COMMENTS */
 19    10 
 19    11 
 19    12 /* format: style4 */
 19    13 
 19    14 dcl  (
 19    15      SL_TYPE_CRASH init (-3),				/* type message with banner & kill system */
 19    16      SL_TYPE_BEEP init (-2),				/* type message with banner */
 19    17      SL_TYPE init (-1),				/* type message */
 19    18      SL_LOG_SILENT init (0),				/* log message */
 19    19      SL_LOG init (1),				/* log & type message */
 19    20      SL_LOG_BEEP init (2),				/* log & type message with banner */
 19    21      SL_LOG_CRASH init (3)				/* log & type message with banner & kill system */
 19    22      ) fixed bin internal static options (constant);
 19    23 
 19    24 dcl  1 sl_info aligned automatic,
 19    25        2 version char(8),			/* structure version       */
 19    26        2 arg_list_ptr ptr,			/* arg_list with values    */
 19    27        2 loc,
 19    28          3 (mode, severity, code, caller, data, class, ioa_msg) fixed bin,
 19    29            /* These flags control where the corresponding data item is found.*/
 19    30 	 /*  -1: data appears in the corresponding structure element below */
 19    31 	 /*   0: data is not present anywhere			       */
 19    32 	 /*  +N: data is Nth item in argument list pointed to by 	       */
 19    33 	 /*      sl_info.arg_list_ptr.  Upon return, data copied into      */
 19    34 	 /*      corresponding structure element.		       */
 19    35 	 /*  if data = +N:					       */
 19    36 	 /*      argN is data_ptr, argN+1 is data_len		       */
 19    37 	 /*  if ioa_msg = +N:				       */
 19    38 	 /*      argN+1, ... argLAST are arguments substituted into the    */
 19    39 	 /*      ioa_msg control string.  The formatted msg is returned.   */
 19    40        2 flags,
 19    41          3 ioa_msg_is_error_code bit(1) unal,	/* ioa_ctl is error code.  */
 19    42          3 flags_pad bit(35) unal,
 19    43        2 mode fixed bin,			/* as-mode, command-mode   */
 19    44        2 severity fixed bin,			/* error severity	       */
 19    45        2 code fixed bin(35),			/* error table code        */
 19    46        2 caller char(65) varying,		/* caller refname$entryname*/
 19    47        2 data,				/* binary data ptr/length  */
 19    48          3 data_ptr ptr,
 19    49          3 data_lth fixed bin(21),
 19    50        2 class char(10) varying,		/* binary data class       */
 19    51        2 ioa_msg char(500) varying;		/* formatted message text  */
 19    52 
 19    53 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 19    54 /*							       */
 19    55 /* If data values (eg, sl_info.caller) are passed in the argument list,      */
 19    56 /* their data types should be as shown in the structure above, except that   */
 19    57 /* character strings should be char(*) nonvarying.		       */
 19    58 /*							       */
 19    59 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 19    60 
 19    61 /* value for sl_info.version */
 19    62 dcl  SL_INFO_version_1 char (8) int static options(constant) init("sl_info1");
 19    63 
 19    64 /* values for sl_info.mode */
 19    65 dcl (SL_INFO_as_mode init(1),
 19    66      SL_INFO_command_mode init(2)) fixed bin int static options(constant);
 19    67 
 19    68 /* values for sl_info.loc.(severity code caller data class ioa_ctl arg) */
 19    69 dcl (SL_INFO_arg_given_in_structure init(-1),
 19    70      SL_INFO_arg_not_given init(0)) fixed bin int static options(constant);
 19    71 
 19    72 
 19    73 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 19    74 /*							       */
 19    75 /* The following static structures are commonly used in the Login Server     */
 19    76 /* user control software.					       */
 19    77 /*							       */
 19    78 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 19    79 
 19    80 /* Syntax: call Abort (severity, code, ioa_ctl, args);		       */
 19    81 
 19    82 dcl  1 sl_info_sev_code_msg		aligned int static options(constant),
 19    83        2 version char(8)		init ("sl_info1"),
 19    84        2 arg_list_ptr ptr		init (null),
 19    85        2 loc,
 19    86          3 (mode			init (-1),
 19    87 	  severity  		init ( 1),
 19    88 	  code 			init ( 2),
 19    89 	  caller 			init (-1),
 19    90 	  data 			init ( 0),
 19    91 	  class 			init ( 0),
 19    92 	  ioa_msg			init ( 3)) fixed bin,
 19    93        2 flags,
 19    94          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 19    95          3 flags_pad bit(35) unal	init ("0"b),
 19    96        2 mode fixed bin		init ( 1),
 19    97        2 severity fixed bin		init ( 0),
 19    98        2 code fixed bin(35)		init ( 0),
 19    99        2 caller char(65) varying	init (""),
 19   100        2 data,
 19   101          3 data_ptr ptr		init (null),
 19   102          3 data_lth fixed bin(21)	init ( 0),
 19   103        2 class char(10) varying	init (""),
 19   104        2 ioa_msg char(500) varying	init ("");
 19   105 
 19   106 /* Syntax: call Abort (severity, ioa_ctl, args);			       */
 19   107 
 19   108 dcl  1 sl_info_sev_msg		aligned int static options(constant),
 19   109        2 version char(8)		init ("sl_info1"),
 19   110        2 arg_list_ptr ptr		init (null),
 19   111        2 loc,
 19   112          3 (mode			init (-1),
 19   113 	  severity  		init ( 1),
 19   114 	  code 			init ( 0),
 19   115 	  caller 			init (-1),
 19   116 	  data 			init ( 0),
 19   117 	  class 			init ( 0),
 19   118 	  ioa_msg			init ( 2)) fixed bin,
 19   119        2 flags,
 19   120          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 19   121          3 flags_pad bit(35) unal	init ("0"b),
 19   122        2 mode fixed bin		init ( 1),
 19   123        2 severity fixed bin		init ( 0),
 19   124        2 code fixed bin(35)		init ( 0),
 19   125        2 caller char(65) varying	init (""),
 19   126        2 data,
 19   127          3 data_ptr ptr		init (null),
 19   128          3 data_lth fixed bin(21)	init ( 0),
 19   129        2 class char(10) varying	init (""),
 19   130        2 ioa_msg char(500) varying	init ("");
 19   131 
 19   132 /* Syntax: call Abort (severity, ioa_ctl_as_error_code, args);	       */
 19   133 
 19   134 dcl  1 sl_info_sev_coded_msg		aligned int static options(constant),
 19   135        2 version char(8)		init ("sl_info1"),
 19   136        2 arg_list_ptr ptr		init (null),
 19   137        2 loc,
 19   138          3 (mode			init (-1),
 19   139 	  severity  		init ( 1),
 19   140 	  code 			init ( 0),
 19   141 	  caller 			init (-1),
 19   142 	  data 			init ( 0),
 19   143 	  class 			init ( 0),
 19   144 	  ioa_msg			init ( 2)) fixed bin,
 19   145        2 flags,
 19   146          3 ioa_msg_is_error_code bit(1) unal init ("1"b),
 19   147          3 flags_pad bit(35) unal	init ("0"b),
 19   148        2 mode fixed bin		init ( 1),
 19   149        2 severity fixed bin		init ( 0),
 19   150        2 code fixed bin(35)		init ( 0),
 19   151        2 caller char(65) varying	init (""),
 19   152        2 data,
 19   153          3 data_ptr ptr		init (null),
 19   154          3 data_lth fixed bin(21)	init ( 0),
 19   155        2 class char(10) varying	init (""),
 19   156        2 ioa_msg char(500) varying	init ("");
 19   157 
 19   158 
 19   159 /* Syntax: call Abort (severity, code, error_return_label, ioa_ctl, args);   */
 19   160 
 19   161 dcl  1 sl_info_sev_code_label_msg	aligned int static options(constant),
 19   162        2 version char(8)		init ("sl_info1"),
 19   163        2 arg_list_ptr ptr		init (null),
 19   164        2 loc,
 19   165          3 (mode			init (-1),
 19   166 	  severity  		init ( 1),
 19   167 	  code 			init ( 2),
 19   168 	  caller 			init (-1),
 19   169 	  data 			init ( 0),
 19   170 	  class 			init ( 0),
 19   171 	  ioa_msg			init ( 4)) fixed bin,
 19   172        2 flags,
 19   173          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 19   174          3 flags_pad bit(35) unal	init ("0"b),
 19   175        2 mode fixed bin		init ( 1),
 19   176        2 severity fixed bin		init ( 0),
 19   177        2 code fixed bin(35)		init ( 0),
 19   178        2 caller char(65) varying	init (""),
 19   179        2 data,
 19   180          3 data_ptr ptr		init (null),
 19   181          3 data_lth fixed bin(21)	init ( 0),
 19   182        2 class char(10) varying	init (""),
 19   183        2 ioa_msg char(500) varying	init ("");
 19   184 
 19   185 /* Syntax:  call Log_error (code, ioa_ctl, args);			       */
 19   186 
 19   187 dcl  1 sl_info_code_msg		aligned int static options(constant),
 19   188        2 version char(8)		init ("sl_info1"),
 19   189        2 arg_list_ptr ptr		init (null),
 19   190        2 loc,
 19   191          3 (mode			init (-1),
 19   192 	  severity  		init (-1),
 19   193 	  code 			init ( 1),
 19   194 	  caller 			init (-1),
 19   195 	  data 			init ( 0),
 19   196 	  class 			init ( 0),
 19   197 	  ioa_msg			init ( 2)) fixed bin,
 19   198        2 flags,
 19   199          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 19   200          3 flags_pad bit(35) unal	init ("0"b),
 19   201        2 mode fixed bin		init ( 1),
 19   202        2 severity fixed bin		init ( 0),
 19   203        2 code fixed bin(35)		init ( 0),
 19   204        2 caller char(65) varying	init (""),
 19   205        2 data,
 19   206          3 data_ptr ptr		init (null),
 19   207          3 data_lth fixed bin(21)	init ( 0),
 19   208        2 class char(10) varying	init (""),
 19   209        2 ioa_msg char(500) varying	init ("");
 19   210 
 19   211 
 19   212 /* Syntax:  call Trace (ioa_ctl, args);				       */
 19   213 
 19   214 dcl  1 sl_info_msg			aligned int static options(constant),
 19   215        2 version char(8)		init ("sl_info1"),
 19   216        2 arg_list_ptr ptr		init (null),
 19   217        2 loc,
 19   218          3 (mode			init (-1),
 19   219 	  severity  		init (-1),
 19   220 	  code 			init ( 0),
 19   221 	  caller 			init (-1),
 19   222 	  data 			init ( 0),
 19   223 	  class 			init ( 0),
 19   224 	  ioa_msg			init ( 1)) fixed bin,
 19   225        2 flags,
 19   226          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
 19   227          3 flags_pad bit(35) unal	init ("0"b),
 19   228        2 mode fixed bin		init ( 1),
 19   229        2 severity fixed bin		init ( 0),
 19   230        2 code fixed bin(35)		init ( 0),
 19   231        2 caller char(65) varying	init (""),
 19   232        2 data,
 19   233          3 data_ptr ptr		init (null),
 19   234          3 data_lth fixed bin(21)	init ( 0),
 19   235        2 class char(10) varying	init (""),
 19   236        2 ioa_msg char(500) varying	init ("");
 19   237 
 19   238 /* END INCLUDE FILE sys_log_constants.incl.pl1 */
     2726 
     2727  /*  BEGIN INCLUDE FILE ... user_table_entry.incl.pl1 */
 20     2 
 20     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 20     4 /*							       */
 20     5 /* This include file requires that the user include		       */
 20     6 /* user_attributes.incl.pl1 as well.  It also includes		       */
 20     7 /* abs_attributes.incl.pl1 itself.				       */
 20     8 /*							       */
 20     9 /* This include file must be included to use absentee_user_table.incl.pl1,   */
 20    10 /* answer_table.incl.pl1, and daemon_user_table.incl.pl1.		       */
 20    11 /*							       */
 20    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 20    13 
 20    14 /****^  HISTORY COMMENTS:
 20    15*  1) change(81-12-21,Gilcrease), approve(86-03-27,MCR7370),
 20    16*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
 20    17*     This comment for hcom.
 20    18*     81-12-21  E. N. Kittlitz. derived from abs_user_tab.incl.pl1,
 20    19*     anstbl.incl.pl1, and dutbl.incl.pl1.
 20    20*     82-01-02 E. N. Kittlitz. user_attributes.incl.pl1 changes
 20    21*     84-04-04 BIM added privileged_dial_server and dial_server_ring
 20    22*     84-07-12 BIM added min_process_authorization
 20    23*     84-12-31 Keith Loepere added pdir_dir_quota
 20    24*     85-01-16 by E. Swenson to add ute.session_uid
 20    25*  2) change(85-11-16,Swenson), approve(87-07-13,MCR7737),
 20    26*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
 20    27*     Added fields for DSA login server support.
 20    28*  3) change(86-03-27,Gilcrease), approve(86-03-27,MCR7370),
 20    29*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
 20    30*     Add truncate_absout and restarted bit for -truncate absout, SCP6297.
 20    31*  4) change(86-04-09,Herbst), approve(87-07-13,MCR7697),
 20    32*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
 20    33*     Added disconnection_rel_minutes.
 20    34*  5) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
 20    35*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 20    36*     Changed structure under ute.abs_attributes to use like structure in
 20    37*     abs_attributes.incl.pl1.  This allows the same attributes to be used
 20    38*     in abs_message_format.incl.pl1 and pit.incl.pl1 as well as this include
 20    39*     file.
 20    40*  6) change(87-04-14,GDixon), approve(87-07-13,MCR7741),
 20    41*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 20    42*     Move constants for ute.pw_flags.mask_ctl from answer_table.incl.pl1.
 20    43*  7) change(87-04-16,GDixon), approve(87-07-13,MCR7741),
 20    44*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 20    45*      A) Global reorganization to locate things by type of data.
 20    46*      B) Eliminate ute.uflags.logged_in.
 20    47*  8) change(87-05-10,GDixon), approve(87-07-13,MCR7741),
 20    48*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 20    49*      A) Reduced overlength person and project fields to proper length.
 20    50*      B) Adjusted dialed-console section to begin on even word boundary.
 20    51*  9) change(87-05-13,GDixon), approve(87-07-13,MCR7741),
 20    52*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 20    53*     Add ute.line_type.
 20    54* 10) change(87-11-19,Parisek), approve(88-02-11,MCR7849),
 20    55*     audit(88-02-23,Lippard), install(88-07-13,MR12.2-1047):
 20    56*     Added the lowest_ring element. Used the upper half of ute.highest_ring
 20    57*     for the storage.  SCP6367
 20    58*                                                   END HISTORY COMMENTS */
 20    59 
 20    60 /* format: style4 */
 20    61 
 20    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 20    63 /*							       */
 20    64 /* Each of the named sections below defines a type of data.  Typing comes    */
 20    65 /* from data associated with the ute entry itself, with the person, with     */
 20    66 /* login argument data, from the main user of the data (eg, dialup_,	       */
 20    67 /* load_ctl_, login server).  Each section begins on a double-word boundary  */
 20    68 /* and is an even number of words long.  The total structure is 300 decimal  */
 20    69 /* words long.						       */
 20    70 /*							       */
 20    71 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 20    72 
 20    73 
 20    74 dcl  UTE_version_4 fixed bin internal static options (constant) init (4);
 20    75 
 20    76 dcl  utep pointer automatic init (null);
 20    77 
 20    78 dcl  1 ute based (utep) aligned,			/* individual entry in one of the user control tables */
 20    79 
 20    80 /* Variables which give state of this entry */
 20    81        2 active fixed bin,				/* state of entry. 0=>free. see dialup_values.incl.pl1 */
 20    82        2 process_type fixed bin,			/* 1=interactive, 2=absentee, 3=daemon */
 20    83        2 ute_index fixed bin,				/* index of ute in (anstbl autbl dutbl).entry array */
 20    84        2 next_free fixed bin,				/* points to previous free entry */
 20    85 
 20    86 /* Information user gave about person_id associated with this entry. */
 20    87        2 person char (24) unal,			/* user's name */
 20    88        2 project char (12) unal,			/* project of absentee user */
 20    89        2 tag char (1) unal,				/* instance tag - someday will be generated */
 20    90        2 tag_pad bit (27) unal,
 20    91        2 anonymous fixed bin,				/* 1 if anonymous, otherwise 0 */
 20    92        2 login_flags,				/* flags for login data */
 20    93          3 cpw bit (1) unal,				/* flag for wish to change password */
 20    94          3 generate_pw bit (1) unal,			/* flag meaning -generate_pw (-gpw) was used. */
 20    95          3 special_pw unal,				/* dial or slave */
 20    96 	 4 dial_pw bit (1) unal,			/* true if dial -user */
 20    97 	 4 slave_pw bit (1) unal,			/* true if slave -user */
 20    98          3 cdp bit (1) unal,				/* flag for wish to change default project */
 20    99          3 cda bit (1) unal,				/* flag to change default authorization */
 20   100          3 auth_given bit (1) unal,			/* flag to mean -authorization was used. */
 20   101          3 noprint bit (1) unal,			/* used at logout. inhibits printing. */
 20   102          3 operator bit (1) unaligned,			/* user specified -operator on login command line */
 20   103          3 pw_pad bit (25) unal,			/* spare parts */
 20   104          3 mask_ctl bit (2) unal,			/* bits controlling pw mask. See constants, below */
 20   105 						/* Must remain last in pw_flags so it does not */
 20   106 						/* appear in PW_FLAG_VALUES array below. */
 20   107        2 generated_pw char (8) unal,			/* user must type this as new password */
 20   108        2 old_password char (8) unal,			/* must match user's previous password (value scrambled) */
 20   109        2 process_authorization bit (72),		/* access_authorization of this process */
 20   110 
 20   111 /* Information user gave about process associated with this entry. */
 20   112        2 outer_module char (32) unal,			/* Name of console dim */
 20   113        2 home_dir char (64) unal,			/* initial home directory */
 20   114        2 init_proc char (64) unal,			/* name of login responder */
 20   115        2 ip_len fixed bin (17) unal,			/* length of initproc string */
 20   116        2 ss_len fixed bin (17) unal,			/* length of subsystem string */
 20   117        2 ur_at like user_attributes aligned,		/* bits on means attributes given by user */
 20   118        2 at like user_attributes aligned,		/* bits on means attribute is on */
 20   119        2 initial_ring fixed bin,			/* ring process will be started in */
 20   120        2 arg_count fixed bin,				/* number of arguments to absentee control segment */
 20   121        2 ln_args fixed bin,				/* length of string containing arguments */
 20   122        2 arg_lengths_ptr ptr,				/* pointer to array of argument lengths */
 20   123        2 args_ptr ptr,				/* pointer to arguments to absentee control segment */
 20   124 
 20   125 /* Most of the following information is relevant only to absentee processes */
 20   126        2 input_seg char (168) unal,			/* pathname of absentee control segment */
 20   127        2 output_seg char (168) unal,			/* pathname of absentee output file */
 20   128        2 request_id fixed bin (71),			/* time request was entered - used as uid of request */
 20   129        2 reservation_id fixed bin (71),			/* nonzero if job has a resource reservation */
 20   130        2 message_id bit (72),				/* message segment id assoc with absentee request */
 20   131        2 deferred_time fixed bin (71),			/* time at which absentee process should be created */
 20   132        2 max_cpu_time fixed bin (35),			/* maximum number of seconds this process can run */
 20   133        2 queue fixed bin,				/* -1=daemon;0=interactive or foreground;>0=queue no.
 20   134*						   (but see uflags.adjust_abs_q_no). */
 20   135        2 real_queue fixed bin,			/* real queue number; ute.queue gets fudged sometimes */
 20   136        2 abs_attributes aligned like user_abs_attributes,	/* include abs_attributes.incl.pl1 */
 20   137        2 abs_flags,
 20   138          3 abs_run bit (1) unal,			/* on if job was started by abs run command */
 20   139          3 notify bit (1) unal,			/* on if user wants notification at login and logout */
 20   140          3 abs_flags_pad bit (34) unal,
 20   141        2 abs_group char (8) unal,			/* original group before load_ctl_ moves it to absentee group */
 20   142        2 sender char (32) unal,			/* name of RJE station that job is from */
 20   143        2 proxy_person char (28) unal,			/* name of user who actually entered the request, if proxy */
 20   144        2 proxy_project char (9) unal,
 20   145        2 proxy_project_pad char (3) unal,
 20   146        2 abs_pad fixed bin,
 20   147 
 20   148 /* Information about process actually created */
 20   149        2 proc_id bit (36),				/* process id of absentee process */
 20   150        2 session_uid fixed bin (35),			/* Unique authentication session id */
 20   151        2 process_authorization_range (2) bit (72) aligned,
 20   152        2 audit bit (36),				/* audit flags for user */
 20   153        2 lot_size fixed bin,				/* Size of linkage offset table */
 20   154        2 kst_size fixed bin,				/* Size of process known segment table */
 20   155        2 cls_size fixed bin,				/* Size of process combined linkage */
 20   156        2 sus_channel fixed bin (71),			/* event channel on which suspended process is blocked */
 20   157        2 lowest_ring fixed bin (17) unal,		/* lowest ring permitted */
 20   158        2 highest_ring fixed bin (17) unal,		/* highest ring permitted */
 20   159        2 pdir_lvix fixed bin (17) unal,			/* index in disk table of lv where pdir is */
 20   160        2 pdir_quota fixed bin (17) unal,		/* process directory quota */
 20   161        2 pdir_dir_quota fixed bin (17) unal,		/* process directory quota for dirs */
 20   162        2 pdir_pad fixed bin(17) unal,
 20   163        2 process_pad fixed bin,
 20   164 
 20   165 /* Information about primary terminal associated with this entry */
 20   166        2 tty_name char (32) unal,			/* absentee=>"abs1", etc.  daemon=>"bk", etc. */
 20   167        2 terminal_type char (32) unaligned,		/* terminal type */
 20   168        2 line_type fixed bin,				/* line type */
 20   169        2 tty_id_code char (4) unal,			/* "none" for absentee */
 20   170        2 network_connection_type fixed bin,		/* see net_event_message.incl.pl1 */
 20   171        2 channel ptr unal,				/* points to CDT entry for user, if any */
 20   172 
 20   173 /* Variables useful for dialed terminals */
 20   174        2 ndialed_consoles fixed bin,			/* if master, number of slaves */
 20   175        2 dial_qualifier char (22) unal,			/* first argument to dial command */
 20   176        2 dial_server_ring fixed bin (3) unsigned unaligned, /* dial server intends to attach dialing in channels at this ring. */
 20   177        2 dial_server_flags,
 20   178          3 registered_dial_server bit (1) unal,		/* process is a registered dial server */
 20   179          3 privileged_dial_server bit (1) unal,		/* "1"b -> serves range of AIM classes */
 20   180          3 dial_server_flags_pad bit (13) unal,		/* fill out the word */
 20   181        2 dial_ev_chn fixed bin (71),			/* if master, control event channel */
 20   182 
 20   183 /* Information about usage/accounting.  Device usage meters are in a
 20   184*   separate segment, "devtab" */
 20   185        2 pdtep ptr,					/* ptr to user's pdt entry, where usage meters live */
 20   186        2 cpu_this_process fixed bin (71),		/* cpu used so far this process */
 20   187        2 cpu_usage fixed bin (71),			/* total cpu time used in this session */
 20   188        2 mem_usage fixed bin (71),			/* memory usage for previous processes in session */
 20   189        2 mem_this_process fixed bin (71),		/* memory usage at last update */
 20   190        2 last_update_time fixed bin (71),		/* time of last account update */
 20   191        2 session_cost float bin,			/* dollar cost of session, for printing in logout messages */
 20   192        2 ndevices fixed bin,				/* Count of attached devices */
 20   193        2 device_head fixed bin,			/* Table index of head of device chain */
 20   194        2 device_tail fixed bin,			/* Table index of tail of device chain */
 20   195        2 rs_number fixed bin (6) unsigned unal,		/* rate structure number */
 20   196        2 rs_number_pad bit(30) unal,
 20   197        2 usage_pad fixed bin,
 20   198 
 20   199 /* Information for dialup_ (control variables). */
 20   200        2 event fixed bin (71),			/* event associated with channel or user manager */
 20   201        2 uprojp ptr,				/* ptr to user project sat entry */
 20   202        2 login_time fixed bin (71),			/* time when absentee user approved by lg_ctl_ */
 20   203        2 cant_bump_until fixed bin (71),		/* bump-protection clock */
 20   204        2 recent_fatal_error_time fixed bin (71),		/* time of first error in the suspected loop */
 20   205        2 recent_fatal_error_count fixed bin,		/* counter to detect fatal process error loops */
 20   206        2 failure_reason fixed bin,			/* why login refused 1=lg_ctl, 2=act_ctl, 3=load_ctl */
 20   207        2 count fixed bin,				/* counter for logins and dialups */
 20   208        2 n_processes fixed bin,			/* number of processes created in this session */
 20   209        2 lock_value fixed bin,			/* number of locks set for this entry */
 20   210        2 login_result fixed bin,			/* 0=logged in;1=hopeless,hang him up;2=allow another attempt */
 20   211        2 login_code char (8) unal,			/* login command from LOGIN line */
 20   212        2 preempted fixed bin,				/* if ^= 0 user preempted (never for abs) */
 20   213        2 destroy_flag fixed bin,			/* >8 when awaiting destroy */
 20   214        2 logout_type char (4) unal,			/* type of logout */
 20   215        2 logout_index fixed bin,			/* to save logout handler index while waiting for termsgnl */
 20   216        2 disconnection_rel_minutes fixed bin (17) unal,	/* disconnected this many minutes after login_time */
 20   217        2 next_disconnected_ate_index fixed bin (17) unal,	/* thread of list of user's disconnected processes */
 20   218        2 work_class fixed bin,			/* work class used by priority scheduler */
 20   219        2 group char (8) unal,				/* party group identifier */
 20   220        2 whotabx fixed bin,				/* index of user's entry in whotab */
 20   221 
 20   222        2 uflags,					/* Miscellaneous flags */
 20   223          3 dont_call_init_admin bit (1) unal,		/* Call overseer directly */
 20   224          3 ip_given bit (1) unal,			/* user gave an initproc arg on login line */
 20   225          3 ss_given bit (1) unal,			/* initial_procedure contains a subsystem name */
 20   226          3 lvs_attached bit (1) unal,			/* set and used by the lv_request_ procedure */
 20   227          3 send_initial_string bit (1) unal,		/* initial string should be sent after login line read */
 20   228          3 adjust_abs_q_no bit (1) unal,		/* this is an absentee job; user_profile.queue is NOT true Q # */
 20   229          3 foreground_secondary_ok bit (1) unal,		/* ok to login foreground absentee job as secondary */
 20   230          3 foreground_job bit (1) unal,			/* job was originally from foreground queue */
 20   231          3 sus_sent bit (1) unal,			/* sus_ ips signal has been sent to process */
 20   232          3 suspended bit (1) unal,			/* process has responded to sus_ signal */
 20   233          3 ignore_cpulimit bit (1) unal,		/* process is released, but timer can't be turned off */
 20   234          3 deferral_logged bit (1) unal,		/* abs job deferral has already been logged once */
 20   235          3 save_if_disconnected bit (1) unal,		/* user wants process preserved across hangups */
 20   236          3 disconnected bit (1) unal,			/* process is disconnected from terminal */
 20   237          3 disconnected_list bit (1) unal,		/* this ate is on a list of disconnected processes */
 20   238          3 proc_create_ok bit (1) unal,			/* lg_ctl_ has set the process creation variables */
 20   239          3 activity_can_unbump bit (1) unal,		/* only bump pending is for inactivity */
 20   240          3 fpe_causes_logout bit (1) unal,		/* "1"b means don't try to new_proc after fatal process error */
 20   241          3 user_specified_immediate bit (1) unal,		/* "1"b -> don't wait around for process destruction. */
 20   242          3 uflags_pad bit (17) unal,
 20   243 
 20   244 /* Information used by load_ctl_ for the process */
 20   245        2 user_weight fixed bin,			/* usually 10 - used in load control */
 20   246        2 standby_line fixed bin,			/* 0=user has primary line, 1=standby user */
 20   247        2 bump_grace fixed bin (71),			/* bump grace in microseconds */
 20   248 
 20   249 
 20   250 /* Information for login server */
 20   251        2 login_server_info,
 20   252          3 our_handle bit (72) aligned,			/* how LS refers to us. */
 20   253          3 his_handle bit (72) aligned,			/* how we talk to LS */
 20   254          3 termination_event_channel fixed bin (71),	/* for process termination notifications to the LS */
 20   255          3 response_event_channel fixed bin (71),		/* for other communications with the LS */
 20   256          3 process_id bit (36) aligned,			/* process_id of login server */
 20   257        2 ls_pad (5) fixed bin;			/* pad to 300 decimal words */
 20   258 
 20   259 /* values for ute.process_type */
 20   260 
 20   261 dcl  (PT_INTERACTIVE initial (1),
 20   262      PT_ABSENTEE initial (2),
 20   263      PT_DAEMON initial (3)) fixed bin internal static options (constant);
 20   264 
 20   265 dcl  PROCESS_TYPE_NAMES (0:3) char(12) varying int static options(constant) init(
 20   266 	"INVALID-TYPE",
 20   267 	"interactive",
 20   268 	"absentee",
 20   269 	"daemon");
 20   270 
 20   271 dcl  TABLE_NAMES (0:3) char(20) int static options(constant) init(
 20   272 	"UNKNOWN-TABLE",
 20   273 	"answer_table",
 20   274 	"absentee_user_table",
 20   275 	"daemon_user_table");
 20   276 
 20   277 
 20   278 /* values for ute.pw_flags.mask_ctl  */
 20   279 
 20   280 dcl  (DO_MASK init ("00"b),
 20   281      DONT_MASK init ("01"b),
 20   282      DERIVE_MASK init ("10"b)) bit (2) internal static options (constant);
 20   283 
 20   284 dcl  MASK_CTL_NAMES (0:3) char(12) varying int static options(constant) init(
 20   285 	"do_mask", "dont_mask", "derive_mask", "");
 20   286 
 20   287 
 20   288 /* names for ute.pw_flags */
 20   289 
 20   290 dcl  PW_FLAG_NAMES (9) char (12) varying int static options(constant) init(
 20   291 	"cpw",
 20   292 	"generate_pw",
 20   293 	"dial_pw",
 20   294 	"slave_pw",
 20   295 	"cdp",
 20   296 	"cda",
 20   297 	"auth_given",
 20   298 	"noprint",
 20   299 	"operator");
 20   300 
 20   301 /* names for ute.uflags */
 20   302 
 20   303 dcl  UFLAG_NAMES (19) char (24) varying int static options (constant) init (
 20   304 	"dont_call_init_admin",
 20   305 	"ip_given",
 20   306 	"ss_given",
 20   307 	"lvs_attached",
 20   308 	"send_initial_string",
 20   309 	"adjust_abs_q_no",
 20   310 	"foreground_secondary_ok",
 20   311 	"foreground_job",
 20   312 	"sus_sent",
 20   313 	"suspended",
 20   314 	"ignore_cpulimit",
 20   315 	"deferral_logged",
 20   316 	"save_if_disconnected",
 20   317 	"disconnected",
 20   318 	"disconnected_list",
 20   319 	"proc_create_ok",
 20   320 	"activity_can_unbump",
 20   321 	"fpe_causes_logout",
 20   322 	"user_specified_immediate");
 20   323 
 20   324 /* names for ute.abs_flags */
 20   325 
 20   326 dcl  ABS_FLAG_NAMES (2) char (8) varying int static options (constant) init (
 20   327 	"abs_run",
 20   328 	"notify");
 20   329 
 20   330 /* names of ute.dial_server_flags */
 20   331 
 20   332 dcl  DIAL_SERVER_FLAG_NAMES (2) char (12) varying int static options (constant) init (
 20   333 	"registered",
 20   334 	"privileged");
 20   335 
 20   336 /* values of ute.login_result */
 20   337 
 20   338 dcl  LOGIN_RESULT_VALUES (0:2) char(24) varying int static options(constant) init(
 20   339 	"logged in",
 20   340 	"login failed, hangup",
 20   341 	"login failed, try again");
 20   342 
 20   343 /*  END INCLUDE FILE ... user_table_entry.incl.pl1 */
     2727 
     2728  /* BEGIN INCLUDE FILE ... user_table_header.incl.pl1 */
 21     2 
 21     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 21     4 /*							       */
 21     5 /* This include file declares the header shared by the answer_table,	       */
 21     6 /* absentee_user_table and daemon_user_table include files.		       */
 21     7 /*							       */
 21     8 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 21     9 
 21    10 /****^  HISTORY COMMENTS:
 21    11*  1) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
 21    12*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 21    13*     Initial coding.
 21    14*                                                   END HISTORY COMMENTS */
 21    15 
 21    16 dcl  1 ut_header			aligned based,	/* header shared by all user control tables. */
 21    17        2 header_version fixed bin,			/* version of the header (3) */
 21    18        2 entry_version fixed bin,			/* version of user table entries */
 21    19        2 user_table_type fixed bin,			/* 1 interactive, 2 absentee, 3 daemon */
 21    20        2 header_length fixed bin,			/* length of the header */
 21    21        2 max_size fixed bin,				/* max number of entries in this table */
 21    22        2 current_size fixed bin,			/* actual size of table (in entries) */
 21    23        2 number_free fixed bin,			/* number of free entries in the table. */
 21    24        2 first_free fixed bin,			/* index of first entry in the free list. */
 21    25        2 as_procid bit (36),				/* process ID of user table manager process */
 21    26        2 ut_header_pad fixed bin;
 21    27 
 21    28 /* END INCLUDE FILE ... user_table_header.incl.pl1 */
     2728 
     2729  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
 22     2 
 22     3 
 22     4 /****^  HISTORY COMMENTS:
 22     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
 22     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
 22     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
 22     8*     attribute switches.
 22     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
 22    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 22    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
 22    12*         be deleted.
 22    13*      B) Add constants identifying attributes that can be changed by user at
 22    14*         login, etc.
 22    15*                                                   END HISTORY COMMENTS */
 22    16 
 22    17 
 22    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
 22    19 
 22    20 /* format: style4 */
 22    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
 22    22        (2 administrator bit (1),			/* 1  system administrator privileges */
 22    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
 22    24        2 nobump bit (1),				/* 2  user cannot be bumped */
 22    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
 22    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
 22    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
 22    28*						   .  of same project (distinct from "nobump") */
 22    29        2 nolist bit (1),				/* 7  don't list user on "who" */
 22    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
 22    31        2 multip bit (1),				/* 9  user may have several processes */
 22    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
 22    33        2 brief bit (1),				/* 11 no login or logout message */
 22    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
 22    35        2 vhomedir bit (1),				/* 13 user may change homedir */
 22    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
 22    37        2 sb_ok bit (1),				/* 15 user may be standby */
 22    38        2 pm_ok bit (1),				/* 16 user may be primary */
 22    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
 22    40        2 daemon bit (1),				/* 18 user may login as daemon */
 22    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
 22    42        2 no_warning bit (1),				/* 20 no warning message */
 22    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
 22    44*						   .  in PDT: this user has an individual load control group */
 22    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
 22    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
 22    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
 22    48        2 pad bit (12)) unaligned;
 22    49 
 22    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
 22    51     ("none",					/* 0 */
 22    52      "administrator",				/* 1 */
 22    53      "primary_line",				/* 2 */
 22    54      "nobump",					/* 3 */
 22    55      "guaranteed_login",				/* 4 */
 22    56      "anonymous",					/* 5 */
 22    57      "nopreempt",					/* 6 */
 22    58      "nolist",					/* 7 */
 22    59      "dialok",					/* 8 */
 22    60      "multip",					/* 9 */
 22    61      "bumping",					/* 10 */
 22    62      "brief",					/* 11 */
 22    63      "vinitproc",					/* 12 */
 22    64      "vhomedir",					/* 13 */
 22    65      "nostartup",					/* 14 */
 22    66      "no_secondary",				/* 15 */
 22    67      "no_prime",					/* 16 */
 22    68      "no_eo",					/* 17 */
 22    69      "daemon",					/* 18 */
 22    70      "",						/* 19 vdim OBSOLETE */
 22    71      "no_warning",					/* 20 */
 22    72      "igroup",					/* 21 */
 22    73      "save_pdir",					/* 22 */
 22    74      "disconnect_ok",				/* 23 */
 22    75      "save_on_disconnect");				/* 24 */
 22    76 
 22    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
 22    78     ("null",					/* 0 */
 22    79      "admin",					/* 1 */
 22    80      "", "",					/* 2 - 3 */
 22    81      "guar",					/* 4 */
 22    82      "anon",					/* 5 */
 22    83      "", "",					/* 6 - 7 */
 22    84      "dial",					/* 8 */
 22    85      "multi_login",					/* 9 */
 22    86      "preempting",					/* 10 */
 22    87      "",						/* 11 */
 22    88      "v_process_overseer",				/* 12 */
 22    89      "v_home_dir",					/* 13 */
 22    90      "no_start_up",					/* 14 */
 22    91      "no_sec",					/* 15 */
 22    92      "no_primary",					/* 16 */
 22    93      "no_edit_only",				/* 17 */
 22    94      "op_login",					/* 18 */
 22    95      "",						/* 19 */
 22    96      "nowarn",					/* 20 */
 22    97      "", "", "",					/* 21 - 23 */
 22    98      "save");					/* 24 */
 22    99 
 22   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
 22   101      options(constant) init("000000000010000000010000000000000000"b);
 22   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
 22   103 
 22   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
 22   105      options(constant) init("000000000010000000010000000000000000"b);
 22   106     /* PDT value for (brief, no_warning) is default */
 22   107 
 22   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
 22   109      options(constant) init("000100000110010000010000000000000000"b);	
 22   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
 22   111 
 23     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
 23     2 
 23     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 23     4 /*							       */
 23     5 /* This include file describes the attributes of an absentee job.  It is     */
 23     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
 23     7 /* and PIT.incl.pl1.   */
 23     8 /*							       */
 23     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 23    10 
 23    11 /****^  HISTORY COMMENTS:
 23    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
 23    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 23    14*     Separated abs_attributes from the request structure
 23    15*     (abs_message_format.incl.pl1) so that the identical structure could be
 23    16*     used in the ute structure (user_table_entry.incl.pl1).
 23    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
 23    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 23    19*     Added ABS_ATTRIBUTE_NAMES array.
 23    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
 23    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
 23    22*     Added the no_start_up flag. SCP6367
 23    23*                                                   END HISTORY COMMENTS */
 23    24 
 23    25 dcl 1 user_abs_attributes		aligned based,
 23    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
 23    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
 23    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
 23    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
 23    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
 23    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
 23    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
 23    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
 23    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
 23    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
 23    36       2 attributes_pad		bit (26) unaligned;
 23    37 
 23    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
 23    39 	"restartable",
 23    40 	"user_deferred_until_time",
 23    41 	"proxy",
 23    42 	"set_bit_cnt",
 23    43 	"time_in_gmt",
 23    44 	"user_deferred_indefinitely",
 23    45 	"secondary_ok",
 23    46 	"truncate_absout",
 23    47 	"restarted",
 23    48 	"no_start_up");
 23    49 
 23    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
 23    51 
 22   112 
 22   113 
 22   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
     2729 
     2730  /* BEGIN INCLUDE FILE ... whotab.incl.pl1 */
 24     2 
 24     3 /* Modified 740723 by PG to add security info */
 24     4 /* Modified April 1976 by T. Casey to add shift and shift start and end times */
 24     5 /* Modified May 1979 by T. Casey for MR7.0a to add foreground absentee variables */
 24     6 /* Modified June 1981 by E. N. Kittlitz to add n_rate_structures. */
 24     7 /* Modified December 1981 by E. N. Kittlitz to expand header. */
 24     8 /* Modified 84-11-14  by E. A. Ranzenbach to add "session" fiedld in  place of obsolete system ID... */
 24     9 
 24    10 dcl 1 whotab based (whoptr) aligned,
 24    11     2 mxusers fixed bin,				/* max. number of users on system */
 24    12     2 n_users fixed bin,				/* current number of users */
 24    13     2 mxunits fixed bin,				/* maximun "load units" allowed */
 24    14     2 n_units fixed bin,				/* current load */
 24    15     2 timeup fixed bin (71),				/* time system was started */
 24    16     2 session char (8),				/* AS state, same as anstbl.session  */
 24    17     2 nextsd fixed bin (71),				/* time we will shutdown */
 24    18     2 until fixed bin (71),				/* projected time we start up again */
 24    19     2 lastsd fixed bin (71),				/* time of last crash or shutdown */
 24    20     2 erfno char (8),				/* if a crash, the error number */
 24    21     2 obsolete_why char (32),				/* reason for last shutdown */
 24    22     2 installation_id char (32),			/* name of installation */
 24    23     2 obsolete_message char (32),			/* message for all users */
 24    24     2 abs_event fixed bin (71),			/* event channel associated with absentee */
 24    25     2 abs_procid bit (36) aligned,			/* process to whom messages about absentee are signalled */
 24    26     2 max_abs_users fixed bin,			/* max number of absentee users */
 24    27     2 abs_users fixed bin,				/* number of absentee users logged-in */
 24    28     2 n_daemons fixed bin,				/* Number of daemon users logged in */
 24    29     2 request_channel fixed bin (71),			/* System master channel for requests to AS. */
 24    30     2 request_process_id bit (36),			/* Process ID of request dispatcher */
 24    31     2 shift fixed bin,				/* current shift (copied from anstbl, for users to see) */
 24    32     2 next_shift_change_time fixed bin (71),		/* time current shift ends */
 24    33     2 last_shift_change_time fixed bin (71),		/* time current shift started */
 24    34     2 fg_abs_users fixed bin (17) unal,			/* number of foreground absentee users */
 24    35     2 n_rate_structures fixed bin (9) unsigned unal,	/* number of rate_structures defined at bootload */
 24    36     2 pad1 bit (9) unal,
 24    37     2 pad (3) fixed bin,
 24    38     2 version fixed bin,				/* structure version */
 24    39     2 header_size fixed bin,				/* length of header in words */
 24    40     2 entry_size fixed bin,				/* length of entry in words */
 24    41 						/* laste_adjust is used only by Answering Service programs */
 24    42     2 laste_adjust fixed bin,				/* count of 32 wd blocks in hdr from header_extension_mbz1 */
 24    43     2 laste fixed bin,				/* index of last entry in use (includes laste_adjust) */
 24    44     2 freep fixed bin (18) unsigned,			/* index of first free entry. chained thru "chain" */
 24    45 
 24    46 /* whotab header extension:  The header is extended from 64 words by
 24    47*   annexing whole user entries from the 'e' array.  Each 'e' entry is 32 words
 24    48*   long. Each annexed block has its first word set to zero, indicating that no user entry is
 24    49*   present.  This allows existing programs to function with old definitions of
 24    50*   whotab.  Obviously no new header field can be more than 31 contiguous words in
 24    51*   length.  In the Answering Service, all programs using whotab must be compiled
 24    52*   with the latest version. Only lg_ctl_ uses laste_adjust. */
 24    53 
 24    54     2 header_extension_mbz1 fixed bin,			/* location 100o */
 24    55     2 n_abs (4) fixed bin,				/* number of processes from each background queue */
 24    56     2 abs_qres (4) fixed bin,				/* number of absentee positions reserved for each queue */
 24    57     2 abs_cpu_limit (4) fixed bin (35),			/* current absentee cpu limits */
 24    58     2 abs_control,					/* see absentee_user_table */
 24    59       3 mnbz bit (1) unal,				/* must not be zero */
 24    60       3 abs_maxu_auto bit (1) unal,			/* 1 if automatic */
 24    61       3 abs_maxq_auto bit (1) unal,			/* 1 if automatic */
 24    62       3 abs_qres_auto bit (1) unal,			/* 1 if automatic */
 24    63       3 abs_cpu_limit_auto bit (1) unal,		/* 1 if automatic */
 24    64       3 queue_dropped (-1:4) bit (1) unal,		/* 1 if queue dropped */
 24    65       3 abs_up bit (1) unal,				/* 1 if absentee facility is running */
 24    66       3 abs_stopped bit (1) unal,			/* 1 if absentee facility is stopped */
 24    67       3 control_pad bit (23) unal,
 24    68     2 installation_request_channel fixed bin (71),	/* IPC channel for install command */
 24    69     2 installation_request_pid bit (36),		/* installation process identifier */
 24    70     2 sysid char (32),				/* current system name */
 24    71     2 header_extension_pad1 (7) fixed bin,		/* pad to size of e element, offset 137o */
 24    72     2 header_extension_mbz2 fixed bin,			/* offset 140o */
 24    73     2 message char (124),				/* message for all users */
 24    74     2 header_extension_mbz3 fixed bin,			/* offset 200o */
 24    75     2 why char (124),				/* reason for last shutdown */
 24    76     2 e (1000),					/* offset 240o */
 24    77       3 active fixed bin,				/* nonzero means logged in */
 24    78       3 person char (28) aligned,			/* person name */
 24    79       3 project char (28),				/* project id */
 24    80       3 anon fixed bin,				/* 1 if anonymous user */
 24    81       3 padding fixed bin (71),
 24    82       3 timeon fixed bin (71),			/* time of login */
 24    83       3 units fixed bin,				/* load units */
 24    84       3 stby fixed bin,				/* 1 if stby */
 24    85       3 idcode char (4),				/* tty id code */
 24    86       3 chain fixed bin (18) unsigned,			/* chain for free list */
 24    87       3 proc_type fixed bin,				/* 1 = interactive, 2 = absentee, 3 = daemon */
 24    88       3 group char (8),				/* party-line group */
 24    89       3 fg_abs bit (1) unal,				/* "1"b if foreground absentee user */
 24    90       3 disconnected bit (1) unaligned,			/* "1"b if process is disconnected */
 24    91       3 suspended bit (1) unaligned,			/* "1"b if process is suspended */
 24    92       3 pad2 bit (33) unal,
 24    93       3 cant_bump_until fixed bin (71),			/* protected from primary bump till here */
 24    94       3 process_authorization bit (72);			/* access authorization of process */
 24    95 
 24    96 dcl  WHOTAB_VERSION_1 fixed bin init (1) static options (constant);
 24    97 
 24    98 /* END INCLUDE FILE ... whotab.incl.pl1 */
     2730 
     2731 
     2732 
     2733 /* BEGIN MESSAGE DOCUMENTATION
     2734*
     2735*   Message:
     2736*   absentee_utility_: Entry not found.  Creating new >sc1>absentee_N.ms
     2737*
     2738*   S:	as (severity1)
     2739*
     2740*   T:	During startup of the absentee facility.
     2741*
     2742*   M:	The absentee message segment for queue N was missing, and
     2743*   a new one has been created.  Any previously submitted absentee jobs
     2744*   in queue N are not executed.
     2745*
     2746*   A:	If the absentee queues never existed or were deliberately deleted or
     2747*   removed, this message should be ignored.  Otherwise,
     2748*   it may be necessary to inform users via the message of the
     2749*   day that the absentee requests for queue N were lost.  Contact the
     2750*   system programming staff for help in recovering the queue.
     2751*
     2752*
     2753*   Message:
     2754*   absentee_utility_: ERROR_MESSAGE.  Unable to create >sc1>absentee_N.ms
     2755*
     2756*   S:	as (severity1)
     2757*
     2758*   T:	During startup of the absentee facility.
     2759*
     2760*   M:	The absentee message segment for queue N cannot be created.
     2761*   Users cannot queue jobs in queue N, and jobs in
     2762*   queue N cannot be executed.
     2763*
     2764*   A:	$inform
     2765*
     2766*
     2767*   Message:
     2768*   absentee_utility_: ERROR_MESSAGE. Unable to set extended access on >sc1>absentee_N.ms
     2769*
     2770*   S:	as (severity1)
     2771*
     2772*   T:	During startup of the absentee facility.
     2773*
     2774*   M:	The absentee message segment for queue N just created cannot be
     2775*   set up so that users can access it properly.  Users will not be
     2776*   able to submit absentee requests.
     2777*
     2778*   A:	$inform
     2779*
     2780*
     2781*   Message:
     2782*   absentee_utility_: ERROR_MESSAGE.  Unable to open new >sc1>absentee_N.ms
     2783*
     2784*   S:	as (severity1)
     2785*
     2786*   T:	During startup of the absentee facility.
     2787*
     2788*   M:	The absentee message segment for queue N just created
     2789*   cannot be found.  No absentee jobs are run.
     2790*
     2791*   A:	$inform
     2792*
     2793*
     2794*   Message:
     2795*   absentee_utility_: ERROR_MESSAGE.  Error in creating defer event channel
     2796*
     2797*   S:	as (severity2)
     2798*
     2799*   T:	During startup of the absentee facility.
     2800*
     2801*   M:	The event channel used in processing absentee requests that
     2802*   are deferred until a later time cannot be created.  No deferred
     2803*   requests are activated.
     2804*
     2805*   A:	Issue an abs stop command and wait until all absentees run
     2806*   to completion.  Then, issue an abs start command.  If this
     2807*   same message recurs, contact the system programming staff.
     2808*
     2809*
     2810*   Message:
     2811*   absentee_utility_: Entry not found.  Creating new >sc1>absentee_data
     2812*
     2813*   S:	as (severity1)
     2814*
     2815*   T:	During startup of the absentee facility.
     2816*
     2817*   M:	The absentee data segment was missing and a new one has been created.
     2818*
     2819*   A:	$note
     2820*
     2821*
     2822*   Message:
     2823*   absentee_utility_: ERROR_MESSAGE.  Unable to create >sc1>absentee_data
     2824*
     2825*   S:	as (severity2)
     2826*
     2827*   T:	During startup of the absentee facility.
     2828*
     2829*   M:	The absentee data segment could not be created.  Faults
     2830*   will probably occur in the absentee facility if the system
     2831*   attempts to run absentee jobs.
     2832*
     2833*   A:	Notify the system programming staff.  Do _n_o_t attempt
     2834*   to run absentee jobs.
     2835*
     2836*
     2837*   Message:
     2838*   absentee_utility_: ERROR_MESSAGE.  Unable to set access on >sc1>absentee_data
     2839*
     2840*   S:	as (severity1)
     2841*
     2842*   T:	During startup of the absentee facility.
     2843*
     2844*   M:	The newly-created segment absentee_data cannot be given
     2845*   correct access.  The system should continue to run.
     2846*
     2847*   A:	$note
     2848*
     2849*
     2850*   Message:
     2851*   absentee_utility_: ERROR_MESSAGE. Closing >sc1>absentee_N.ms
     2852*
     2853*   S:	as (severity1)
     2854*
     2855*   T:	While shutting down the absentee facility.
     2856*
     2857*   M:	A storage system error occurred as part of the processing of
     2858*   "abs stop" while attempting to terminate the absentee message
     2859*   segment for queue N.  Absentee requests for queue N may have been
     2860*   lost.
     2861*
     2862*   A:	If you are shutting down the absentee facility because of some
     2863*   previous message-segment error, contact the system programming staff
     2864*   and do not try to restart the absentee facility.  If this absentee
     2865*   shutdown is a normally scheduled one, notify the system programmers
     2866*   of the message and do not try to restart the absentee facility
     2867*   again until they have looked at the problem.
     2868*
     2869*
     2870*   Message:
     2871*   absentee_utility_: ERROR_MESSAGE.  Unable to terminate >sc1>absentee_data
     2872*
     2873*   S:	as (severity1)
     2874*
     2875*   T:	During shutdown of the absentee facility.
     2876*
     2877*   M:	While shutting down the absentee facility, the system
     2878*   attempted to terminate the segment absentee_data and
     2879*   received an error.  This condition is not serious.
     2880*
     2881*   A:	$note
     2882*
     2883*
     2884*   Message:
     2885*   abs run: request PATH ID is already running.
     2886*
     2887*   S:	as (severity1)
     2888*
     2889*   T:	In response to an abs run command.
     2890*
     2891*   M:	The specified job is already running.
     2892*
     2893*   A:	If a mistake was made, repeat the command, specifying the correct job.
     2894*
     2895*
     2896*   Message:
     2897*   absentee_utility_: ERROR_MESSAGE Dropping queue >sc1>absentee_N.ms due to M consecutive errors
     2898*
     2899*   S:	as (severity2)
     2900*
     2901*   T:	$run
     2902*
     2903*   M:	This message is printed when a series of errors prevents the absentee
     2904*   facility from reading jobs from a given queue.  Absentee requests
     2905*   in queue N are ignored until the absentee facility is
     2906*   stopped and restarted, or the command abs start queue N is used to restart the dropped queue.
     2907*
     2908*   A:	$note
     2909*
     2910*
     2911*   Message:
     2912*   absentee_utility_: ERROR_MESSAGE. queue N >sc1>absentee_N.ms
     2913*
     2914*   S:	as (severity1)
     2915*
     2916*   T:	$run
     2917*
     2918*   M:	An error occurred while reading, rewriting, or deleting a request
     2919*   from queue N. An attempt is made to correct the error and retry the operation.
     2920*   Additional messages are printed if this attempt fails.
     2921*
     2922*   A:	$inform
     2923*
     2924*
     2925*   Message:
     2926*   absentee_utility_: >sc1>absentee_data has overflowed its limit of N entries.
     2927*
     2928*   S:	as (severity2)
     2929*
     2930*   T:	$run
     2931*
     2932*   M:	The absentee facility keeps a list of absentee jobs that are either
     2933*   deferred or currently running. This list has a capacity of
     2934*   about 13,000 entries. It is extremely unlikely that this data area will fill up
     2935*   unless some user program has entered a loop and is submitting requests
     2936*   for jobs faster than the jobs are being run.
     2937*
     2938*   A:	$contact
     2939*
     2940*
     2941*   Message:
     2942*   absentee_utility_: Illegal proxy for NAME.PROJ from NAME1.PROJ1 for job JJJJ
     2943*
     2944*   S:	as (severity1)
     2945*
     2946*   T:	$run
     2947*
     2948*   M:	This message is printed whenever a proxy absentee
     2949*   job is submitted by some user who is not allowed to submit a proxy.
     2950*   User NAME1.PROJ1 submitted job JJJJ to be run with the
     2951*   user ID NAME.PROJ, but the absentee facility will not do so and
     2952*   ignores the request.
     2953*
     2954*   A:	$note
     2955*
     2956*
     2957*   Message:
     2958*   absentee_utility_ (abs run): Request PATH ID will be run in spite of unavailable resource(s): RESOURCE
     2959*
     2960*   S:	as (severity1)
     2961*
     2962*   T:	In response to an abs run command.
     2963*
     2964*   M:	The job selected by the abs run command needs RESOURCE, which is unavailable.
     2965*   The job will be logged in anyway.
     2966*
     2967*   A:	If the job is critical, the resource could be made available by
     2968*   force detaching it from some other process. This is a drastic action,
     2969*   and should not be taken without the System Administrator's approval.
     2970*
     2971*
     2972*   Message:
     2973*   absentee_utility_: rejected request ID (PATH) in queue N from PERS.PROJ: REASON
     2974*
     2975*   S:	as (severity1)
     2976*
     2977*   T:	$run
     2978*
     2979*   M:	This message is printed if a message that appears
     2980*   to be garbled or meaningless is found in absentee queue N.
     2981*   The garbled message is ignored.  This condition may be evidence
     2982*   of damage to absentee queue N, unless REASON indicates otherwise.
     2983*
     2984*   A:	$note
     2985*
     2986*
     2987*   Message:
     2988*   absentee_utility_: Loop in PROC, searching NAME list for queue N.
     2989*
     2990*   S:	as (severity1)
     2991*
     2992*   T:	$run
     2993*
     2994*   M:	A software error has damaged the list of requests in absentee_data.
     2995*   The error was detected by the internal procedure, PROC, while searching
     2996*   the NAME list belonging to queue N. The system makes one attempt to rebuild
     2997*   the list. Additional messages are printed if this attempt fails.
     2998*
     2999*   A:	$inform
     3000*
     3001*
     3002*   Message:
     3003*   absentee_utility_: Loop occurred while rebuilding absentee_data after previous loop.
     3004*
     3005*   S:	as (severity2)
     3006*
     3007*   T:	$run
     3008*
     3009*   M:	The error reported by the previous message occurred while absentee_data
     3010*   was being rebuilt following an earlier error. The rebuild attempt will not be repeated.
     3011*
     3012*   A:	$contact
     3013*
     3014*
     3015*   Message:
     3016*   absentee_utility_: >sc1>absentee_data will be rebuilt.
     3017*
     3018*   S:	as (severity1)
     3019*
     3020*   T:	$run
     3021*
     3022*   M:	An attempt will be made to rebuild the request lists in absentee_data
     3023*   to correct the error reported by the previous message.
     3024*
     3025*   A:	$note
     3026*
     3027*
     3028*   Message:
     3029*   absentee_utility_: ERROR_MESSAGE Truncating absentee_data.
     3030*
     3031*   S:	as (severity2)
     3032*
     3033*   T:	$run
     3034*
     3035*   M:	An error occurred during the attempt to truncate absentee_data
     3036*   prior to rebuilding it. It will not be possible to rebuild it.
     3037*
     3038*   A:	$contact
     3039*
     3040*
     3041*   Message:
     3042*   absentee_utility_: Attempting to reserve RESOURCE for PERS.PROJ (PATH)
     3043*
     3044*   S:	as (severity2)
     3045*
     3046*   T:	$run
     3047*
     3048*   M:	An error occurred during the attempt to reserve a resource for an
     3049*   absentee job. The job is deferred and the attempt to reserve the resource
     3050*   is repeated at some later time. The absentee facility continues to operate.
     3051*   There is something wrong with the resource reservation mechanism or with
     3052*   some other part of RCP.
     3053*
     3054*   A:	$inform
     3055*
     3056*
     3057*   Message:
     3058*   abs ACTION: N requests ACTIONed.
     3059*
     3060*   S:	as (severity1)
     3061*
     3062*   T:	In response to an abs defer or abs release command.
     3063*
     3064*   M:	Indicates success or failure of the command. ACTION can be
     3065*   defer or release, and N can be "no" or the number of requests acted upon.
     3066*
     3067*   A:	Confirm that the expected results were obtained.
     3068*
     3069*
     3070*   Message:
     3071*   abs run: job selection arguments matched N requests; be more specific.
     3072*
     3073*   S:	as (severity1)
     3074*
     3075*   T:	In response to an abs run command.
     3076*
     3077*   M:	The specified arguments matched either zero, or more than one, request,
     3078*   and so no job was run.
     3079*
     3080*   A:	Re-enter the command with correct arguments, to select exactly
     3081*   one job for running.
     3082*
     3083*
     3084*   Message:
     3085*   absentee_utility_: Absentee processing suspended. Contact system programmer.
     3086*
     3087*   S:	as (severity2)
     3088*
     3089*   T:	$run
     3090*
     3091*   M:	Absentee processing has been suspended because of the error described
     3092*   in the previous message. No more jobs will be started, but logged in jobs will
     3093*   continue running. The absentee facility has not been stopped, and an "abs start"
     3094*   command will be rejected. After the error has been corrected, the
     3095*   "abs start queue N" command may be used to resume the processing of requests
     3096*   from queues unaffected by the error.
     3097*
     3098*   A:	$contact
     3099*
     3100*
     3101*   Message:
     3102*   absentee_utility_: BUG: lc ineligible (INDEX) not at head of resource list.
     3103*
     3104*   S:	as (severity2)
     3105*
     3106*   T:	$run
     3107*
     3108*   M:	The current absentee request, which would be deferred by load control, is not at
     3109*   the head of the absentee list.  If this occurs, there is a logic error in absentee_utility_.
     3110*
     3111*   A:	$contact
     3112*
     3113*
     3114*   Message:
     3115*   absentee_utility_ (setup_queue): Invalid queue number: QUEUE
     3116*
     3117*   S:	as (severity2)
     3118*
     3119*   T:	$run
     3120*
     3121*   M:	The internal queue number in absentee_utility_ was invalid when trying to
     3122*   find an absentee to login.  If this occurs, there is a logic error in absentee_utility_.
     3123*
     3124*   A:	$contact
     3125*
     3126*
     3127*   Message:
     3128*   absentee_utility_: ERROR_MESSAGE. Attempting to cancel reservation REQUEST for USER (ABSENTEE)
     3129*
     3130*   S:     $log
     3131*
     3132*   T:     $run
     3133*
     3134*   M:     An error occurred while cancelling an RCP reservation for an
     3135*   absentee being deferred.
     3136*
     3137*   A:     $ignore
     3138*
     3139*
     3140*   Message:
     3141*   absentee_utility_: ERROR_MESSAGE. While reading message MESSAGE from USER (ABSENTEE) to be rewritten.
     3142*
     3143*   S:     $log
     3144*
     3145*   T:     $run
     3146*
     3147*   M:     An error occurred while reading a request from the absentee queue.
     3148*
     3149*   A:     $ignore
     3150*
     3151*
     3152*   Message:
     3153*   absentee_utility_: ERROR_MESSAGE. While reading message MESSAGE to be rewritten.
     3154*
     3155*   S:     $log
     3156*
     3157*   T:     $run
     3158*
     3159*   M:     An error occurred while reading an absentee request to be marked
     3160*   as "running".
     3161*
     3162*   A:     $ignore
     3163*
     3164*
     3165*   Message:
     3166*   absentee_utility_: ERROR_MESSAGE. Searching queue QUEUE skip list for USER (ABSENTEE)
     3167*
     3168*   S:     $log
     3169*
     3170*   T:     $run
     3171*
     3172*   M:     An error occurred while searching the skip list for an absentee request.
     3173*
     3174*   A:     $ignore
     3175*
     3176*
     3177*   Message:
     3178*   absentee_utility_: ERROR_MESSAGE. Searching skip list for USER (ABSENTEE)
     3179*
     3180*   S:     $log
     3181*
     3182*   T:     $run
     3183*
     3184*   M:     An error occurred while searching the skip list for an absentee request.
     3185*
     3186*   A:     $ignore
     3187*
     3188*
     3189*   Message:
     3190*   absentee_utility_: ERROR_MESSAGE. Unable to delete request for USER (ABSENTEE); queue: QUEUE; index: QUEUE_INDEX
     3191*
     3192*   S:     as (severity0)
     3193*
     3194*   T:     $run
     3195*
     3196*   M:     An error occurred while deleting a request from the absentee queue.
     3197*
     3198*   A:     $ignore
     3199*
     3200*
     3201*   Message:
     3202*   absentee_utility_: Timer rang and no deferred request found.
     3203*
     3204*   S:     as (severity0)
     3205*
     3206*   T:     $run
     3207*
     3208*   M:     The deferred request timer went off and no deferred absentee jobs
     3209*   were found.
     3210*
     3211*   A:     $ignore
     3212*
     3213*
     3214*   Message:
     3215*   absentee_utility_: Illegal queue number (QUEUE) for USER (ABSENTEE)
     3216*
     3217*   S:     as (severity0)
     3218*
     3219*   T:     $run
     3220*
     3221*   M:     The queue number specified for the absentee job in the absentee
     3222*   user table has an illegal value.
     3223*
     3224*   A:     $ignore
     3225*
     3226*
     3227*   Message:
     3228*   absentee_utility_: ERROR_MESSAGE. Sending TYPE wakeup to PROCID (ABS-EVENT)
     3229*
     3230*   S:     $log
     3231*
     3232*   T:     $run
     3233*
     3234*   M:     An error occurred while sending an "aum_ctl" or "login" wakeup to
     3235*   the specified absentee process.
     3236*
     3237*   A:     $ignore
     3238*
     3239*
     3240*   Message:
     3241*   absentee_utility_: ERROR_MESSAGE. Unable to notify user USER of absentee event.
     3242*
     3243*   S:     $log
     3244*
     3245*   T:     $run
     3246*
     3247*   M:     An error occurred while sending a message to USER as notification of
     3248*   an absentee event.
     3249*
     3250*
     3251*   Message:
     3252*   absentee_utility_: Attempt to set defer timer to time in past (TIME). Setting it to a minute from now.
     3253*
     3254*   S:     as (severity0)
     3255*
     3256*   T:     $run
     3257*
     3258*   M:     An attempt was made to set the absentee deferred request timer
     3259*   to a time in the past.
     3260*
     3261*   A:     $ignore
     3262*
     3263*
     3264*   END MESSAGE DOCUMENTATION */
     3265 
     3266      end absentee_utility_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1028.4  absentee_utility_.pl1             >spec>install>MR12.2-1072>absentee_utility_.pl1
2709         1    02/02/82  2145.0  abs_args.incl.pl1                 >ldd>include>abs_args.incl.pl1
2710         2    07/23/81  1735.0  abs_data.incl.pl1                 >ldd>include>abs_data.incl.pl1
2711         3    08/01/88  1028.5  abs_message_format.incl.pl1       >spec>install>MR12.2-1072>abs_message_format.incl.pl1
2712         4    08/06/87  0913.4  absentee_user_table.incl.pl1      >ldd>include>absentee_user_table.incl.pl1
2713         5    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
2714         6    08/06/87  0913.4  as_data_.incl.pl1                 >ldd>include>as_data_.incl.pl1
2715         7    08/06/87  0913.4  as_data_definitions_.incl.pl1     >ldd>include>as_data_definitions_.incl.pl1
2716         8    08/06/87  0913.4  as_meter_numbers.incl.pl1         >ldd>include>as_meter_numbers.incl.pl1
2717         9    10/30/86  2010.5  as_request_sender_.incl.pl1       >ldd>include>as_request_sender_.incl.pl1
2718        10    01/21/85  0912.2  as_wakeup_priorities.incl.pl1     >ldd>include>as_wakeup_priorities.incl.pl1
2719        11    08/06/87  0913.4  dialup_values.incl.pl1            >ldd>include>dialup_values.incl.pl1
2720        12    08/06/87  0913.4  installation_parms.incl.pl1       >ldd>include>installation_parms.incl.pl1
12-148      13    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
2721        14    08/06/87  0913.5  mseg_access_mode_values.incl.pl1  >ldd>include>mseg_access_mode_values.incl.pl1
2722        15    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
2723        16    02/13/79  1715.0  resource_control_desc.incl.pl1    >ldd>include>resource_control_desc.incl.pl1
2724        17    08/06/87  0913.5  sc_stat_.incl.pl1                 >ldd>include>sc_stat_.incl.pl1
2725        18    04/27/78  1504.4  send_mail_info.incl.pl1           >ldd>include>send_mail_info.incl.pl1
2726        19    08/06/87  0913.5  sys_log_constants.incl.pl1        >ldd>include>sys_log_constants.incl.pl1
2727        20    07/14/88  2015.0  user_table_entry.incl.pl1         >ldd>include>user_table_entry.incl.pl1
2728        21    08/06/87  0913.6  user_table_header.incl.pl1        >ldd>include>user_table_header.incl.pl1
2729        22    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
22-112      23    07/14/88  2015.0  user_abs_attributes.incl.pl1      >ldd>include>user_abs_attributes.incl.pl1
2730        24    01/18/85  0953.2  whotab.incl.pl1                   >ldd>include>whotab.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSQ_METER                      000346 constant        fixed bin(17,0)          initial dcl 8-28 set ref 1384* 1386* 1988* 1994*
                                                                                  2135* 2138*
ABS_DATA_version_2                     constant        fixed bin(17,0)          initial dcl 2-74 ref 710 1855
ABS_DEFER_PRIO                  000257 constant        fixed bin(17,0)          initial dcl 10-35 set ref 676*
ABS_VER_4                              constant        fixed bin(17,0)          initial dcl 264 ref 1032 1676 2187
ABS_VER_5                              constant        fixed bin(17,0)          initial dcl 267 ref 1032 1144 2187
AU_METER                        000347 constant        fixed bin(17,0)          initial dcl 8-23 set ref 329* 428* 781* 823*
Absentee_proxy_dot_acs          000000 constant        char(32)                 initial packed unaligned dcl 2673 set ref 2679*
BACKWARD                               constant        bit(2)                   initial dcl 301 set ref 2577*
CPUT_LIST                              constant        fixed bin(17,0)          initial dcl 307 ref 1742 2454
DEFER                                  constant        fixed bin(17,0)          initial dcl 312 set ref 440* 2243
FALSE                                  constant        bit(1)                   initial dcl 319 ref 1001 1823 2023
FORWARD                         000247 constant        bit(2)                   initial dcl 299 set ref 1639* 2179*
GROUP_LIMIT                            constant        fixed bin(17,0)          initial dcl 317 ref 366 1813
LEGAL                           000202 constant        char(95)                 initial packed unaligned dcl 274 ref 1076 1077 1080
                                                                                  1085
MANY                                   constant        fixed bin(17,0)          initial dcl 311 set ref 440* 453* 2280
MAX_QUEUE                              constant        fixed bin(17,0)          initial dcl 271 ref 619 755 877 1767 2434 2466
MSEG_D_ACCESS                          constant        bit(36)                  initial dcl 14-17 ref 498
MSEG_O_ACCESS                          constant        bit(36)                  initial dcl 14-17 ref 499
NEVER                           000200 constant        fixed bin(71,0)          initial dcl 276 ref 1241 2399
NO_QUEUE                        000176 constant        fixed bin(17,0)          initial dcl 277 set ref 579* 811* 1265* 1819* 1837
ONE                                    constant        fixed bin(17,0)          initial dcl 310 set ref 833* 2229
PROJECT_LIMIT                          constant        fixed bin(17,0)          initial dcl 316 ref 363 1805
QERR_MAX                               constant        fixed bin(17,0)          initial dcl 270 ref 881
QUEUE_LIST                             constant        fixed bin(17,0)          initial dcl 309 ref 1750 1754
READY_LIST                             constant        fixed bin(17,0)          initial dcl 308 ref 1744 1748
RELEASE                                constant        fixed bin(17,0)          initial dcl 313 set ref 453* 2254 2284
REREAD                          000345 constant        bit(2)                   initial dcl 300 set ref 379* 725* 1494* 1554* 1574*
                                                                                  2296*
RUN                                    constant        fixed bin(17,0)          initial dcl 314 set ref 833*
SL_LOG                          000355 constant        fixed bin(17,0)          initial dcl 19-14 set ref 631* 636* 659* 667* 685*
                                                                                  702* 758* 768* 888* 1197* 1219* 1837* 1847* 2281*
                                                                                  2655*
SL_LOG_BEEP                     000354 constant        fixed bin(17,0)          initial dcl 19-14 set ref 679* 688* 882* 945* 1841*
                                                                                  1851* 2055* 2098* 2439* 2471*
SL_LOG_SILENT                   000345 constant        fixed bin(17,0)          initial dcl 19-14 set ref 372* 391* 395* 484* 604*
                                                                                  609* 732* 820* 1770* 2362* 2381* 2416*
SL_TYPE                         000344 constant        fixed bin(17,0)          initial dcl 19-14 set ref 843* 2302*
STATE_DEFERRED                         constant        fixed bin(17,0)          initial dcl 15-42 ref 381 1183 1867
STATE_ELIGIBLE                         constant        fixed bin(17,0)          initial dcl 15-44 ref 2260
STATE_RUNNING                          constant        fixed bin(17,0)          initial dcl 15-45 ref 727 1663 2240
STATE_TRANSITION                       constant        fixed bin(17,0)          initial dcl 15-43 ref 1228
TAG_ABSENTEE                           constant        char(1)                  initial packed unaligned dcl 11-93 ref 1068
TAG_PROXY                              constant        char(1)                  initial packed unaligned dcl 11-93 ref 2665
TRUE                                   constant        bit(1)                   initial dcl 318 ref 1828
USER_LIMIT                             constant        fixed bin(17,0)          initial dcl 315 ref 361 1180
a_arg_ptr                              parameter       pointer                  dcl 101 ref 56 333
a_asr_sender_ptr                       parameter       pointer                  dcl 102 ref 471 478
a_code                                 parameter       fixed bin(35,0)          dcl 99 set ref 56 330 331* 423* 613 616* 680* 690*
                                                                                  704* 708*
a_ute_ptr                              parameter       pointer                  dcl 103 ref 471 477
abort_label                     000120 automatic       label variable           dcl 128 set ref 328* 427* 438* 451* 466* 567* 598*
                                                                                  780* 787* 822* 1859 2472
abs_arg_ptr                     000164 automatic       pointer                  dcl 146 set ref 333* 439* 452* 2159 2160 2164 2194
                                                                                  2195 2196 2198 2201 2202 2204 2210 2210 2214 2214
                                                                                  2217 2217 2218 2222 2223
abs_args                               based           structure                level 1 dcl 1-10
abs_attributes          125            based           structure                level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" set ref 1065
abs_attributes          247            based           structure                level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1065*
abs_cpu_default_limit
                        531            based           fixed bin(35,0)          array level 3 dcl 12-33 ref 1134
abs_event                50            based           fixed bin(71,0)          level 2 dcl 24-10 set ref 2361* 2362 2362
abs_flags               250            based           structure                level 2 dcl 20-78
abs_info                               based           structure                level 1 dcl 2-107 set ref 1453*
abs_message_version_6                  constant        fixed bin(17,0)          initial dcl 3-34 ref 1032 2187
abs_procid               52            based           bit(36)                  level 2 dcl 24-10 set ref 2361* 2362*
abs_run                 250            based           bit(1)                   level 3 packed packed unaligned dcl 20-78 ref 342
                                                                                  405 1164
abs_status_flags        126            based           structure                level 2 dcl 3-36 set ref 382* 728* 1171 1171 1868*
                                                                                  1908 2258*
absentee_data                          based           structure                level 1 dcl 2-76 set ref 944
absentee_data_base              000015 constant        char(32)                 initial packed unaligned dcl 303 set ref 683* 685*
                                                                                  686* 688* 700* 702* 768* 945* 1841* 1847* 1851*
absentee_ename                  000010 internal static char(32)                 array packed unaligned dcl 255 set ref 492* 623*
                                                                                  625* 627* 631* 633* 636* 657* 659* 665* 667* 758*
                                                                                  882* 888*
absentee_utility_$timer_rang    000114 constant        entry                    external dcl 191 ref 676 676
access                   10     000212 automatic       bit(36)                  array level 2 dcl 159 set ref 645* 645* 645* 695*
                                                                                  698*
access_name                     000212 automatic       char(32)                 array level 2 dcl 159 set ref 641* 642* 643* 694*
                                                                                  697*
acl                             000212 automatic       structure                array level 1 dcl 159 set ref 657 657 700 700
addr                                                   builtin function         dcl 237 ref 512 572 657 657 700 700 803 935 949 1492
                                                                                  1550 1947 1989 1989 1992 1992 2347 2361 2379 2379
adjust_abs_q_no         431(05)        based           bit(1)                   level 3 packed packed unaligned dcl 20-78 set ref
                                                                                  1017*
adp                             000070 internal static pointer                  initial dcl 256 set ref 345 347 570 572 579 583 583
                                                                                  683* 684 686* 687 707* 710 766 767* 771* 799 799
                                                                                  803 811 815 931 934 935 936 942 942 944 945 949
                                                                                  963 965 970 971 974 975 980 985 987 987 1243 1244
                                                                                  1246 1247 1260 1260 1265 1267 1276 1278 1284 1287
                                                                                  1290 1292 1305 1307 1309 1311 1330 1332 1334 1336
                                                                                  1356 1358 1360 1362 1400 1402 1404 1406 1408 1408
                                                                                  1440 1442 1444 1446 1448 1448 1454 1455 1476 1482
                                                                                  1487 1489 1492 1544 1550 1585 1598 1598 1598 1629
                                                                                  1630 1632 1665 1668 1673 1675 1685 1798 1802 1805
                                                                                  1808 1813 1813 1819 1821 1826 1840 1849* 1854 1855
                                                                                  2054 2059 2064 2065 2336 2336 2341 2343 2347 2485
                                                                                  2487 2489 2490 2506 2511 2513 2515 2531 2539 2545
                                                                                  2546 2549 2550 2555 2557 2562 2563 2563 2581 2581
                                                                                  2581 2614 2614 2614 2617 2623 2623 2627 2629
after                                                  builtin function         dcl 237 ref 510 1045 2202 2204 2650
aim_check_$equal                000120 constant        entry                    external dcl 193 ref 517 524
aim_check_$greater_or_equal     000116 constant        entry                    external dcl 192 ref 1095
aim_template                           based           structure                level 1 dcl 5-12
aip                             000510 automatic       pointer                  initial dcl 2-105 set ref 357 358 360 361 363 366
                                                                                  572* 573 575 576 576 803* 805 806 2-105* 839 840
                                                                                  841 935* 936 937 938 949* 952 953 954 955 956 962
                                                                                  963 965 969 970 970 971 974 980 980 1001 1022 1073
                                                                                  1073 1074 1074 1179 1180 1189 1240 1241 1242 1243
                                                                                  1244 1244 1257 1258 1260 1274 1276 1278 1284 1284
                                                                                  1288 1305 1305 1305 1307 1309 1309 1309 1311 1315
                                                                                  1316 1317 1318 1330 1330 1330 1332 1334 1334 1334
                                                                                  1336 1340 1341 1342 1343 1356 1356 1356 1358 1360
                                                                                  1360 1360 1362 1366 1366 1367 1400 1400 1400 1402
                                                                                  1404 1404 1404 1406 1408 1413 1414 1415 1416 1417
                                                                                  1419 1420 1421 1423 1427 1440 1440 1440 1442 1444
                                                                                  1444 1444 1446 1448 1453 1454 1456 1492* 1493 1494
                                                                                  1550* 1551 1553 1554 1555 1566 1574 1668 1802 1808
                                                                                  1813 1826 1905 1905 1915 1915 2023 2064 2065 2247
                                                                                  2248 2249 2330* 2347* 2481 2482 2484 2485 2487
                                                                                  2487 2502 2506 2507 2511 2511 2527 2528 2531 2537
                                                                                  2539 2539 2544 2545 2545 2546 2549 2555 2555 2561
                                                                                  2575 2578 2581 2586 2586
aix                             000106 automatic       fixed bin(17,0)          dcl 121 set ref 570* 571 572 573* 799* 799 799* 803*
                                                                                  815 815 934* 935 942* 949 971 975 980 985 987 1244
                                                                                  1246 1247 1284 1287 1290 1292 1408 1448 1455 1476
                                                                                  1476* 1480 1482* 1482 1482* 1489 1491 1492 1548*
                                                                                  1548* 1550 1560 1580* 1629* 1630 1630* 1632 1632
                                                                                  2054 2055* 2059 2336* 2336 2336* 2343 2345 2347
                                                                                  2455* 2487 2489 2490 2511 2513 2515 2546 2550 2555
                                                                                  2557 2562 2563
already_notified                001026 automatic       bit(1)                   initial dcl 1903 set ref 1903* 1905* 1910
always_add               11(02) 000523 automatic       bit(1)                   level 3 packed packed unaligned dcl 18-5 set ref
                                                                                  2377*
anonymous                16            based           fixed bin(17,0)          level 2 dcl 20-78 set ref 524 1052* 1058*
anonymous_user                  000162 automatic       bit(1)                   dcl 144 set ref 514* 524 524
any_other                       000472 stack reference condition                dcl 184 ref 787
areap                           000072 internal static pointer                  initial dcl 257 set ref 617* 1118 1126 1989* 1992*
                                                                                  2085*
arg_count               102            based           fixed bin(17,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1104*
arg_count               100            based           fixed bin(17,0)          level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1038 1103 1127 2191
arg_lengths                            based           fixed bin(17,0)          array level 2 dcl 3-36 ref 1120
arg_lengths_ptr         104            based           pointer                  level 2 dcl 20-78 set ref 1105* 1118* 1120
arg_switches                           based           structure                level 2 dcl 1-10
args                                   based           char                     level 2 dcl 3-36 ref 1127
args_ptr                106            based           pointer                  level 2 dcl 20-78 set ref 1106* 1126* 1127
as_any_other_handler_$no_cleanup
                                000106 constant        entry                    external dcl 189 ref 787
as_data_$abs_dim                000266 external static char(32)                 packed unaligned dcl 6-23 ref 1023
as_data_$acsdir                 000270 external static char(168)                packed unaligned dcl 6-25 set ref 2679*
as_data_$autp                   000272 external static pointer                  dcl 6-31 ref 2700
as_data_$rs_ptrs                000274 external static pointer                  array dcl 6-49 ref 748 748 1134 1134 1137 1137
as_data_$sysdir                 000276 external static char(168)                packed unaligned dcl 6-54 ref 492 492 627 627 631
                                                                                  631 633 633 636 636 657 657 659 659 665 665 667
                                                                                  667 683 683 685 685 686 686 688 688 700 700 702
                                                                                  702 758 758 768 768 882 882 888 888 945 945 1841
                                                                                  1841 1847 1847 1851 1851
as_data_$whoptr                 000300 external static pointer                  dcl 6-60 ref 2361 2361 2361 2361 2362 2362 2362 2362
                                                                                  2362 2362
as_dump_                        000122 constant        entry                    external dcl 194 ref 877 2440 2470
as_error_table_$proj_max        000242 external static fixed bin(35,0)          dcl 242 ref 363
as_meter_$enter                 000110 constant        entry                    external dcl 190 ref 329 781 1384 1988 2135
as_meter_$exit                  000112 constant        entry                    external dcl 190 ref 428 823 1386 1994 2138
as_request_sender                      based           structure                level 1 dcl 9-15
as_request_sender_ptr           000514 automatic       pointer                  dcl 9-13 set ref 478* 491 492 511 512
at                      100            based           structure                level 2 dcl 20-78
aum_ctl                  56(13)        based           bit(1)                   level 3 packed packed unaligned dcl 4-28 set ref 342
                                                                                  348*
autbl                                  based           structure                level 1 dcl 4-28
authorization                   000160 automatic       bit(72)                  dcl 143 in procedure "absentee_utility_" set ref
                                                                                  511* 517* 524*
authorization            16            based           bit(72)                  level 2 in structure "as_request_sender" dcl 9-15
                                                                                  in procedure "absentee_utility_" set ref 511 512
auto_expire              30            based           bit(1)                   level 3 packed packed unaligned dcl 16-55 set ref
                                                                                  2090*
autp                            000512 automatic       pointer                  initial dcl 4-26 set ref 342 348 407 585 675 676 765
                                                                                  4-26* 873 877 880 880 881 882 884 1173 1418 1418
                                                                                  1482 2034 2074 2074 2413 2422 2440 2445 2448 2448
                                                                                  2448 2467 2501 2530 2530 2700*
available_slots_                000124 constant        entry                    external dcl 195 ref 2448
based_mess_id                          based           fixed bin(71,0)          dcl 165 set ref 1947*
before                                                 builtin function         dcl 237 ref 509 510 1045 1049 1051 2196 2198 2202
                                                                                  2204 2650 2651
bit                                                    builtin function         dcl 237 ref 1723
bit_flags                66            based           structure                level 3 dcl 3-36
caller                                 parameter       char                     packed unaligned dcl 870 set ref 862 882* 888*
can_run                  12            based           bit(1)                   level 3 in structure "abs_info" packed packed
                                                                                  unaligned dcl 2-107 in procedure
                                                                                  "absentee_utility_" set ref 1415* 1553 1555* 1566
                                                                                  2528* 2578* 2581* 2586
can_run                 112            based           bit(1)                   array level 4 in structure "absentee_data" packed
                                                                                  packed unaligned dcl 2-76 in procedure
                                                                                  "absentee_utility_" set ref 2623*
cleanup                         000500 stack reference condition                dcl 185 ref 336 784
clock                                                  builtin function         dcl 237 ref 334 747 796
code                            001242 automatic       fixed bin(35,0)          dcl 2642 in procedure "validate_proxy" set ref 2653*
                                                                                  2655*
code                            000101 automatic       fixed bin(35,0)          dcl 116 in procedure "absentee_utility_" set ref
                                                                                  354* 355 370* 372 372* 379* 380 391* 395* 482* 483
                                                                                  484* 492* 497 601* 602 604* 627* 630 631* 633* 635
                                                                                  636* 657* 658 659* 665* 666 667* 675* 676 676* 678
                                                                                  679* 680 683* 685* 686* 688* 690 700* 701 702* 704
                                                                                  707* 708 708 725* 726 732* 757* 758 758* 765* 767*
                                                                                  768 768* 793* 821* 837* 838 908* 1849* 1850 1851*
                                                                                  1893 2085* 2086 2091* 2093 2094 2094 2098 2098*
                                                                                  2136* 2139* 2218* 2219 2223* 2224 2361* 2362 2362*
                                                                                  2379* 2381 2381 2381 2381* 2577* 2578
code                                   parameter       fixed bin(35,0)          dcl 1716 in procedure "get_effmode" set ref 1712
                                                                                  1720* 1721
code                                   parameter       fixed bin(35,0)          dcl 2670 in procedure "valid_proxy" set ref 2667
                                                                                  2679* 2683 2686*
const1                          000233 constant        fixed bin(35,0)          initial dcl 272 ref 1139
const2                          000232 constant        fixed bin(35,0)          initial dcl 273 ref 1139 1139
control                  56            based           structure                level 2 dcl 4-28
convert_status_code_            000126 constant        entry                    external dcl 196 ref 1928
copy                                                   builtin function         dcl 237 ref 1723
cpu_limit                14            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1317*
                                                                                  2482*
cpu_limit               114            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1482
cpu_limit                44            based           fixed bin(35,0)          array level 2 in structure "autbl" dcl 4-28
                                                                                  in procedure "absentee_utility_" ref 1173 1482
cput_list                12(08)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  839 1318* 2247 2481*
ctl_wakeup                      000126 automatic       bit(1)                   dcl 131 set ref 461* 2359 2701*
cur_message_id                  000254 automatic       bit(72)                  dcl 167 set ref 953 1024 1214* 1498* 1579* 1632*
                                                                                  1634* 1639* 1641* 1686* 1947 2175* 2179* 2181*
                                                                                  2233 2295* 2296* 2320* 2336 2456* 2623
currentsize                                            builtin function         dcl 237 ref 944 1038 2191
date                            000256 automatic       char(16)                 packed unaligned dcl 171 set ref 1219* 1947* 1958*
date_time_                      000130 constant        entry                    external dcl 197 ref 1947
debugging                55            based           fixed bin(17,0)          level 2 dcl 4-28 ref 877 2440
defer_channel            50            based           fixed bin(71,0)          level 2 dcl 4-28 set ref 675* 676* 765* 2034* 2413*
                                                                                  2422*
defer_list               12(05)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  841 1240* 1257* 1343* 2249
deferral_logged         431(11)        based           bit(1)                   level 3 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  358 1022*
deferral_logged          12(11)        based           bit(1)                   level 3 in structure "abs_info" packed packed
                                                                                  unaligned dcl 2-107 in procedure
                                                                                  "absentee_utility_" set ref 358* 1022
deferral_notified        12(10)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  1905 1915*
deferral_reasons                000025 constant        char(24)                 initial array packed unaligned dcl 290 set ref 1910
                                                                                  1910 1912*
deferred_time           120            based           fixed bin(71,0)          level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1139
deferred_time           242            based           fixed bin(71,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1139* 1165 1258
desired_person                  001264 automatic       varying char(32)         dcl 2643 set ref 2651* 2664
desired_project                 001253 automatic       varying char(32)         dcl 2643 set ref 2650* 2663
dir                                    parameter       char                     packed unaligned dcl 1715 set ref 1712 1720*
direction                              parameter       bit(2)                   dcl 1977 set ref 1968 1989* 1992 1992
dirname                  22(09)        based           char(168)                level 2 in structure "abs_args" packed packed
                                                                                  unaligned dcl 1-10 in procedure
                                                                                  "absentee_utility_" ref 2214
dirname                   3            based           char(168)                level 3 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" set ref 843* 1078 1912* 2214
                                                                                  2655*
divide                                                 builtin function         dcl 237 ref 1037 1139 2190
ec                                     parameter       fixed bin(35,0)          dcl 1738 in procedure "get_next_request" set ref
                                                                                  1726 1740* 1743* 1744 1749* 1750 1754*
ec                                     parameter       fixed bin(35,0)          dcl 1471 in procedure "find_eligible_cput" set ref
                                                                                  1462 1474* 1480 1494* 1496
ec                                     parameter       fixed bin(35,0)          dcl 1621 in procedure "find_next_queue_entry" set
                                                                                  ref 1607 1636* 1638 1639* 1640
ec                                     parameter       fixed bin(35,0)          dcl 1538 in procedure "find_eligible_ready" set ref
                                                                                  1507 1542* 1548 1554* 1555 1559* 1574* 1575 1589*
ec                                     parameter       fixed bin(35,0)          dcl 2317 in procedure "search_skip_for_aute" set ref
                                                                                  2313 2327 2329* 2346*
ec                                     parameter       fixed bin(17,0)          dcl 1880 in procedure "message_error" ref 1876 1892
                                                                                  1893
ec                              000660 automatic       fixed bin(35,0)          dcl 1379 in procedure "delete_msg" set ref 1385*
                                                                                  1387*
ec                                     parameter       fixed bin(35,0)          dcl 1983 in procedure "read_msg" set ref 1968 1989*
                                                                                  1992* 1995*
ec                              001120 automatic       fixed bin(35,0)          dcl 2154 in procedure "search_queues" set ref 2174*
                                                                                  2177 2179* 2180 2239* 2240 2246 2262 2269* 2296*
                                                                                  2297
ec                                     parameter       fixed bin(35,0)          dcl 868 in procedure "check_for_badseg" set ref 862
                                                                                  873 873 882* 888* 889
ename                    74(09)        based           char(32)                 level 2 in structure "abs_args" packed packed
                                                                                  unaligned dcl 1-10 in procedure
                                                                                  "absentee_utility_" ref 2218
ename                    55            based           char(32)                 level 3 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" set ref 843* 1078 1912* 2218
                                                                                  2655*
entry                                  parameter       char                     packed unaligned dcl 1715 in procedure "get_effmode"
                                                                                  set ref 1712 1720*
entry                   100            based           structure                array level 2 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 572 803
                                                                                  935 949 1492 1550 2347
entry_sw                  0(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 ref 2217
err_msg                         000077 constant        char(28)                 initial array packed unaligned dcl 279 ref 1935 1937
error                           000457 automatic       bit(1)                   array dcl 179 set ref 1224* 1892* 1927 1936 1946
                                                                                  1955 1955 1955 1955 2705*
error_table_$bad_segment        000244 external static fixed bin(35,0)          dcl 243 ref 889
error_table_$device_limit_exceeded
                                000246 external static fixed bin(35,0)          dcl 244 ref 2094
error_table_$messages_deferred  000250 external static fixed bin(35,0)          dcl 245 ref 2381
error_table_$messages_off       000252 external static fixed bin(35,0)          dcl 246 ref 2381
error_table_$no_e_permission    000254 external static fixed bin(35,0)          dcl 247 ref 2686
error_table_$no_message         000256 external static fixed bin(35,0)          dcl 248 ref 423 873 1474 1496 1542 1555 1575 1589
                                                                                  2329
error_table_$reservation_failed 000260 external static fixed bin(35,0)          dcl 249 ref 2098
error_table_$resource_unknown   000262 external static fixed bin(35,0)          dcl 250 ref 2094
ev_calls_masked                 000125 automatic       bit(1)                   dcl 130 set ref 794* 907 909* 2701*
event                                  based           fixed bin(71,0)          dcl 2356 set ref 2361*
ex_access                11     000212 automatic       bit(36)                  array level 2 dcl 159 set ref 649* 649* 652* 654*
                                                                                  696* 699*
ext_mode                        000133 automatic       bit(36)                  dcl 136 set ref 492* 498 499
failure_reason          411            based           fixed bin(17,0)          level 2 dcl 20-78 ref 361 383 385
flags                    30            based           structure                level 2 dcl 16-55
foreground_cpu_default_limit
                        545            based           fixed bin(35,0)          level 3 dcl 12-33 ref 1137
foreground_job          431(07)        based           bit(1)                   level 3 packed packed unaligned dcl 20-78 set ref
                                                                                  1018*
foreground_secondary_ok
                        431(06)        based           bit(1)                   level 3 packed packed unaligned dcl 20-78 set ref
                                                                                  1066*
found                           000715 automatic       bit(1)                   initial dcl 1540 in procedure "find_eligible_ready"
                                                                                  set ref 1540* 1578* 1589
found                           000166 automatic       bit(1)                   dcl 148 in procedure "absentee_utility_" set ref
                                                                                  795* 804* 818
found_one                       001232 automatic       bit(1)                   initial dcl 2610 set ref 2610* 2623* 2633
fq                              001121 automatic       fixed bin(17,0)          dcl 2155 set ref 2161* 2164* 2167* 2173
free_list                12(03)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  938* 1456*
freen_                          000132 constant        entry                    external dcl 198 ref 1698 1705 1706
get_system_free_area_           000134 constant        entry                    external dcl 199 ref 617
group                   426            based           char(8)                  level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" ref 360
group                   126            based           char(8)                  array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1813
group                    26            based           char(8)                  level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 360* 956*
                                                                                  1813
group_id                  4            based           char(32)                 level 2 packed packed unaligned dcl 9-15 ref 491
has_access                      000132 automatic       bit(1)                   dcl 135 set ref 480* 517* 524* 534
has_d_permission                000135 automatic       bit(1)                   dcl 138 set ref 498* 517
has_o_permission                000134 automatic       bit(1)                   dcl 137 set ref 499* 524
has_ring1_priv                  000136 automatic       bit(1)                   dcl 139 set ref 512* 517 524
hbound                                                 builtin function         dcl 237 ref 1910 1935
hcs_$add_acl_entries            000136 constant        entry                    external dcl 200 ref 700
hcs_$get_user_access_modes      000140 constant        entry                    external dcl 201 ref 492
hcs_$get_user_effmode           000142 constant        entry                    external dcl 202 ref 1720
hcs_$initiate                   000144 constant        entry                    external dcl 203 ref 683
hcs_$make_seg                   000146 constant        entry                    external dcl 204 ref 686
hcs_$terminate_noname           000150 constant        entry                    external dcl 205 ref 767
hcs_$truncate_seg               000152 constant        entry                    external dcl 206 ref 707 1849
hcs_$wakeup                     000154 constant        entry                    external dcl 207 ref 2361
hdr_version               2            based           fixed bin(17,0)          level 3 dcl 3-36 ref 1032 2185
head_cput                26            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 1307* 1476 2489*
head_defer                3            based           fixed bin(17,0)          level 2 dcl 2-76 set ref 799 1246* 1260 1287* 1332*
head_lc                   5            based           fixed bin(17,0)          level 2 dcl 2-76 set ref 570 583* 1358* 1798 2513*
head_ready               20            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 1402* 1544 2054 2064*
                                                                                  2549 2550* 2617
head_skip                22            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 974 975* 1442*
home_dir                               based           char                     level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1145
home_dir                 36            based           char(64)                 level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1145*
howmany                                parameter       fixed bin(17,0)          dcl 2148 ref 2146 2229 2280
id_sw                     0(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 ref 2210
ii                              000110 automatic       fixed bin(17,0)          dcl 123 set ref 1037* 1038 1038 1119* 1120 1120*
                                                                                  1665* 1665* 1668* 1673 1908* 1910 1910 1912 1935*
                                                                                  1936 1937* 2190* 2191 2192
index                                                  builtin function         dcl 237 ref 1908
init_proc                56            based           char(64)                 level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1150*
init_proc                              based           char                     level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1150
initial_ring            101            based           fixed bin(17,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1152*
initial_ring            110            based           fixed bin(17,0)          level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1152 1152
input_seg               110            based           char(168)                level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  372* 391* 395* 484* 604* 609* 1078* 1079 1080
                                                                                  1197* 1219* 1770* 1958*
installation_parms                     based           structure                level 1 dcl 12-33
installation_parms_part_1              based           structure                level 1 dcl 12-40
installation_parms_resource_array_part based           structure                array level 1 unaligned dcl 12-144
ioa_$rsnnl                      000156 constant        entry                    external dcl 208 ref 625 1912 1958
ip                                     defined         pointer                  dcl 7-21 ref 748 1134 1137
ip_given                431(01)        based           bit(1)                   level 3 packed packed unaligned dcl 20-78 set ref
                                                                                  1148*
ip_len                   76            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  1149*
ipc_$create_ev_chn              000160 constant        entry                    external dcl 209 ref 675
ipc_$decl_ev_call_chn           000162 constant        entry                    external dcl 210 ref 676
ipc_$delete_ev_chn              000164 constant        entry                    external dcl 211 ref 765
ipc_$mask_ev_calls              000166 constant        entry                    external dcl 212 ref 793
ipc_$unmask_ev_calls            000170 constant        entry                    external dcl 213 ref 821 908
ix                              000626 automatic       fixed bin(17,0)          dcl 1254 in procedure "defer_request_until_time" set
                                                                                  ref 1260* 1260 1260* 1267 1274 1276 1276 1290 1290
ix                              001231 automatic       fixed bin(17,0)          dcl 2609 in procedure "update_ready" set ref 2614*
                                                                                  2617* 2622 2623 2623 2627* 2627
ix                              000774 automatic       fixed bin(17,0)          dcl 1795 in procedure "lc_will_reject" set ref 1798*
                                                                                  1798* 1802 1805 1808 1813 1813* 1821 1826
last                      1            based           fixed bin(17,0)          level 2 dcl 2-76 set ref 579 811 942 942* 944 945
                                                                                  1265 1487 1585 1819 2341 2629
last_message_id          22            based           bit(72)                  level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1416*
                                                                                  1554* 2586*
last_message_id         122            based           bit(72)                  array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 2623
last_queue_searched      54            based           fixed bin(17,0)          level 2 dcl 4-28 ref 407
last_rsc                 10            based           fixed bin(17,0)          array level 2 dcl 2-76 set ref 345* 1598 2563 2563*
lbound                                                 builtin function         dcl 237 ref 1910
lc_code                         000102 automatic       fixed bin(35,0)          dcl 117 set ref 330* 363
lc_list                  56(14)        based           bit(1)                   level 3 in structure "autbl" packed packed unaligned
                                                                                  dcl 4-28 in procedure "absentee_utility_" set ref
                                                                                  585* 2501*
lc_list                  12(12)        based           bit(1)                   level 3 in structure "abs_info" packed packed
                                                                                  unaligned dcl 2-107 in procedure
                                                                                  "absentee_utility_" set ref 575* 1367* 1427 2502*
lc_reason                13            based           fixed bin(2,0)           level 2 in structure "abs_info" packed packed
                                                                                  unsigned unaligned dcl 2-107 in procedure
                                                                                  "absentee_utility_" set ref 361* 363* 366* 1001
                                                                                  1180 1826*
lc_reason               113            based           fixed bin(2,0)           array level 3 in structure "absentee_data" packed
                                                                                  packed unsigned unaligned dcl 2-76 in procedure
                                                                                  "absentee_utility_" set ref 1805 1813 1826
len                       2     000170 automatic       fixed bin(18,0)          level 2 dcl 150 set ref 1037 2136* 2190
len_args                101            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1109 1127 2191
len_comment             106            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1120 1127 1145 1150 2191
len_homedir             111            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1120 1127 1145 1145 1145
                                                                                  1150 2191
len_initproc            112            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1120 1127 1147 1149 1150
                                                                                  1150 2191
len_name                 77            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1056 1063 1083 1120 1127
                                                                                  1145 1150 1197 2085 2098 2191 2198 2223 2649
len_output              102            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1063 1082 1083 1120 1127
                                                                                  1145 1150 1197 2085 2098 2191 2198 2223 2649
len_proxy               103            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1063 1120 1127 1145 1150
                                                                                  1197 2085 2098 2191 2198 2223 2649
len_resource            104            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1063 1120 1127 1145 1150
                                                                                  1197 1197 2084 2085 2085 2098 2098 2191 2223
len_sender              105            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1063 1120 1127 1145 1150
                                                                                  2191 2223
len_vpad                107            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1038 1120 1127 2191
length                                                 builtin function         dcl 237 ref 1073 1074 1932 1932 1942 2379 2379 2661
length_of_arguments             000114 automatic       fixed bin(17,0)          dcl 125 set ref 1109* 1110 1112 1112 1126 1126 1127
lengths                                based           fixed bin(17,0)          array dcl 108 set ref 1118 1120*
list_name                              parameter       char                     packed unaligned dcl 1834 set ref 1832 1837*
list_searched                   000105 automatic       fixed bin(17,0)          dcl 120 set ref 1742 1744* 1748 1750* 1754 2454*
ln_args                 103            based           fixed bin(17,0)          level 2 dcl 20-78 set ref 1107* 1110*
load_control            126(06)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  383* 1182*
login_result            415            based           fixed bin(17,0)          level 2 dcl 20-78 ref 353
long                            000272 automatic       char(100)                packed unaligned dcl 174 set ref 1928* 1929
loop_limit                      000714 automatic       fixed bin(17,0)          dcl 1539 in procedure "find_eligible_ready" set ref
                                                                                  1546* 1584* 1584 1585
loop_limit                      000124 automatic       fixed bin(17,0)          dcl 129 in procedure "absentee_utility_" set ref
                                                                                  568* 578* 578 579 798* 810* 810 811
loop_limit                      001132 automatic       fixed bin(17,0)          dcl 2318 in procedure "search_skip_for_aute" set ref
                                                                                  2335* 2340* 2340 2341
loop_limit                      001230 automatic       fixed bin(17,0)          dcl 2608 in procedure "update_ready" set ref 2621*
                                                                                  2628* 2628 2629
loop_limit                      000704 automatic       fixed bin(17,0)          dcl 1472 in procedure "find_eligible_cput" set ref
                                                                                  1478* 1486* 1486 1487
loop_limit                      000627 automatic       fixed bin(17,0)          dcl 1255 in procedure "defer_request_until_time" set
                                                                                  ref 1259* 1264* 1264 1265
loop_limit                      000775 automatic       fixed bin(17,0)          initial dcl 1796 in procedure "lc_will_reject" set
                                                                                  ref 1796* 1818* 1818 1819
lq                              001122 automatic       fixed bin(17,0)          dcl 2155 set ref 2162* 2164* 2168* 2173
match_count                     001114 automatic       fixed bin(17,0)          initial dcl 2151 set ref 2151* 2230* 2230 2231 2244*
                                                                                  2244 2257* 2257 2281 2281* 2281 2285 2286 2292
                                                                                  2297* 2302 2302 2302* 2302
match_message_id                001116 automatic       bit(72)                  dcl 2153 set ref 2233* 2295
match_queue                     001115 automatic       fixed bin(17,0)          dcl 2152 set ref 2232* 2293
match_request_id_               000172 constant        entry                    external dcl 214 ref 2210
match_star_name_                000174 constant        entry                    external dcl 215 ref 2218 2223
max                                                    builtin function         dcl 237 ref 1133 1173 1482 2448 2448
max_abs_users            13            based           fixed bin(17,0)          level 2 dcl 4-28 set ref 2448*
max_cpu_time            244            based           fixed bin(35,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1133* 1134 1134* 1137*
                                                                                  1173 2482
max_cpu_time            122            based           fixed bin(35,0)          level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1133
mess                            001142 automatic       char(8)                  dcl 2356 set ref 2359* 2360* 2361 2362*
mess_id                  14     000170 automatic       bit(72)                  level 2 dcl 150 set ref 1498 1579 1641 2136* 2181
                                                                                  2581 2586
message_error_code              000471 automatic       fixed bin(35,0)          dcl 180 set ref 1893* 1928*
message_id               20            based           bit(72)                  level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 953*
                                                                                  1494* 1574* 1668
message_id              240            based           bit(72)                  level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 379* 391* 606* 725*
                                                                                  732* 1024* 2320
message_id              120            based           bit(72)                  array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1632 1668
                                                                                  2336 2581
message_in_error                000456 automatic       bit(1)                   dcl 178 set ref 1056 1070 1082 1108 1145 1147 1163
                                                                                  1192 1201 1213 1223* 1891* 2084 2704*
message_segment_$close          000176 constant        entry                    external dcl 216 ref 757
message_segment_$create         000200 constant        entry                    external dcl 217 ref 633
message_segment_$delete_index   000202 constant        entry                    external dcl 218 ref 1385
message_segment_$incremental_read_index
                                000204 constant        entry                    external dcl 219 ref 1989
message_segment_$ms_acl_add     000206 constant        entry                    external dcl 220 ref 657
message_segment_$open           000210 constant        entry                    external dcl 221 ref 627 665
message_segment_$read_index     000212 constant        entry                    external dcl 222 ref 1992
message_segment_$update_message_index
                                000214 constant        entry                    external dcl 223 ref 2136
mode                            000750 automatic       fixed bin(5,0)           dcl 1718 set ref 1720* 1723
modes                           001304 automatic       bit(36)                  packed unaligned dcl 2671 set ref 2679* 2683
msg_id                                 parameter       bit(72)                  dcl 1378 in procedure "delete_msg" set ref 1374
                                                                                  1385*
msg_id                                 parameter       bit(72)                  dcl 1981 in procedure "read_msg" set ref 1968 1989
                                                                                  1989*
msg_time                               based           fixed bin(71,0)          level 3 dcl 3-36 set ref 843* 843* 954 1089 1912*
                                                                                  1912* 2210*
n_abs                    20            based           fixed bin(17,0)          array level 2 dcl 4-28 ref 2448
name                            000010 constant        char(17)                 initial packed unaligned dcl 305 in procedure
                                                                                  "absentee_utility_" set ref 372* 391* 395* 484*
                                                                                  604* 609* 631* 636* 659* 667* 679* 685* 688* 702*
                                                                                  732* 758* 768* 820* 945* 1197* 1219* 1770* 1837*
                                                                                  1841* 1847* 1851* 2055* 2098* 2362* 2381* 2416*
                                                                                  2439* 2471* 2655*
name                    127            based           char                     level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1056
next_aix                        000107 automatic       fixed bin(17,0)          dcl 122 set ref 805* 813 1476* 1482 1493* 1544* 1548
                                                                                  1551* 1560* 1580* 1587 1598 1598 1598*
next_cput               106            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1305*
                                                                                  1489 2487*
next_cput                 6            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1305 1307
                                                                                  1309 1309 1316* 1493 2484*
next_defer              102            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1244*
                                                                                  1267 1284* 1330*
next_defer                2            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 805 1242*
                                                                                  1274* 1330 1332 1334 1334 1340*
next_lc                 131            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1356*
                                                                                  1821 2511*
next_lc                  31            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 573 576*
                                                                                  1356 1358 1360 1360 1366* 2507*
next_ready                4            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1400 1402
                                                                                  1404 1404 1414* 1551 2064 2065 2545* 2549* 2555
                                                                                  2555
next_ready              104            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1400*
                                                                                  1598 2545 2546* 2614 2627
next_skip               100            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 970 971*
                                                                                  1440*
next_skip                              based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 970* 974*
                                                                                  980 980 1440 1442 1444 1444
no_start_up             125(09)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 ref 1154
nostartup                77(13)        based           bit(1)                   level 3 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1157*
nostartup               100(13)        based           bit(1)                   level 3 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1156*
notify                  250(01)        based           bit(1)                   level 3 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1064*
notify                   66(01)        based           bit(1)                   level 4 in structure "request" packed packed
                                                                                  unaligned dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1064 1910
null                                                   builtin function         dcl 237 ref 335 676 684 687 766 771 782 2-105 4-26
                                                                                  20-76 1105 1106 1698 1705 1706 1905 1915 2330 2702
                                                                                  2703
number_of_arguments             000115 automatic       fixed bin(17,0)          dcl 126 set ref 1103* 1104 1108 1112 1118 1119
operator_deferred_indefinitely
                        126(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  1169 2255
outer_module             26            based           char(32)                 level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  1023*
output_file                            based           char                     level 2 dcl 3-36 ref 1083
output_seg              162            based           char(168)                level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  1083* 1084 1085 1087*
p                               000130 automatic       pointer                  dcl 133 set ref 2702*
parse_resource_desc_            000216 constant        entry                    external dcl 224 ref 2085
part_1                                 based           structure                level 2 dcl 12-33
path_sw                   0(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 ref 2214
                                                                                  2217
person                   32            based           char(22)                 level 2 in structure "abs_info" packed packed
                                                                                  unaligned dcl 2-107 in procedure
                                                                                  "absentee_utility_" set ref 1073* 1073 1808
person                    1            based           char(28)                 level 2 in structure "abs_args" packed packed
                                                                                  unaligned dcl 1-10 in procedure
                                                                                  "absentee_utility_" ref 2195 2196 2198
person                    4            based           char(24)                 level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  370 372* 391* 395* 484* 524 604* 609* 1051* 1056*
                                                                                  1073 1076 1770* 2087 2098* 2660 2664*
person                          000147 automatic       char(22)                 packed unaligned dcl 141 in procedure
                                                                                  "absentee_utility_" set ref 509* 514 524 524
person                  132            based           char(22)                 array level 3 in structure "absentee_data" packed
                                                                                  packed unaligned dcl 2-76 in procedure
                                                                                  "absentee_utility_" set ref 1808
prev_cput               107            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1309*
prev_cput                 7            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1305 1305
                                                                                  1309 1311 1315* 2485* 2487 2487
prev_defer                3            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1243*
                                                                                  1244 1244 1276* 1278* 1284 1284 1330 1330 1334
                                                                                  1336 1341*
prev_defer              103            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1276
                                                                                  1290* 1334*
prev_free                10            based           fixed bin(17,0)          level 2 dcl 2-107 set ref 936 937* 1454*
prev_lc                 130            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1360*
prev_lc                  30            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 576* 1356
                                                                                  1356 1360 1362 1366* 2506* 2511 2511
prev_ready              105            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 1404*
                                                                                  2065* 2555*
prev_ready                5            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1400 1400
                                                                                  1404 1406 1408 1413* 2531* 2539* 2544 2545 2546
prev_skip                 1            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 963* 965*
                                                                                  969 970 971 1440 1440 1444 1446 1448
prev_skip               101            based           fixed bin(17,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 980*
                                                                                  1444* 1673 2343
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 5-12
proc_name                              parameter       char                     packed unaligned dcl 1834 set ref 1832 1837*
process_authorization
                         24            based           bit(72)                  level 2 dcl 20-78 set ref 517* 524* 1099* 2091*
project                  12            based           char(12)                 level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  370 372* 391* 395* 484* 524 604* 609* 1045* 1074
                                                                                  1077 1770* 2087 2098* 2661 2663*
project                  10            based           char(9)                  level 2 in structure "abs_args" packed packed
                                                                                  unaligned dcl 1-10 in procedure
                                                                                  "absentee_utility_" ref 2201 2202 2204
project                         000155 automatic       char(9)                  packed unaligned dcl 142 in procedure
                                                                                  "absentee_utility_" set ref 510* 524 524
project                 137(27)        based           char(9)                  array level 3 in structure "absentee_data" packed
                                                                                  packed unaligned dcl 2-76 in procedure
                                                                                  "absentee_utility_" set ref 1802
project                  37(27)        based           char(9)                  level 2 in structure "abs_info" packed packed
                                                                                  unaligned dcl 2-107 in procedure
                                                                                  "absentee_utility_" set ref 1074* 1074 1802
proxy                   247(02)        based           bit(1)                   level 3 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1070 1955
proxy                   125(02)        based           bit(1)                   level 3 in structure "request" packed packed
                                                                                  unaligned dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 2197 2203
proxy_name                             based           char                     level 2 dcl 3-36 ref 2198 2649
proxy_person            263            based           char(28)                 level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  524 2660*
proxy_project           272            based           char(9)                  level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  524 2661* 2661
proxy_sender                    001243 automatic       char(32)                 packed unaligned dcl 2643 set ref 2649* 2650 2651
                                                                                  2655*
qerr                     36            based           fixed bin(17,0)          array level 2 dcl 4-28 set ref 873* 880* 880 881
                                                                                  882*
qres                     24            based           fixed bin(17,0)          array level 2 dcl 4-28 ref 2448
queue                           000104 automatic       fixed bin(17,0)          dcl 119 in procedure "absentee_utility_" set ref
                                                                                  395* 407* 484* 492 604* 609* 619* 623 623 625 625*
                                                                                  627 627 631 633 636 652 657 659 665 665 667* 755*
                                                                                  756 757 758 760* 806* 807 873 877 877 880 880 881
                                                                                  882* 882 882 884 888* 888 952 963 965 974 975 985
                                                                                  987 987 1012 1014 1018 1219 1219* 1307 1311 1402
                                                                                  1406 1408 1408 1418 1418 1442 1446 1448 1448 1476
                                                                                  1482 1487* 1544 1585* 1598 1598 1629 1630 1665
                                                                                  1765* 1767 1767 1767 1770* 1958 1958* 2054 2059
                                                                                  2064 2074 2074 2173* 2176 2232* 2293* 2294 2336
                                                                                  2341* 2434 2434 2434 2439* 2445 2448 2448 2448
                                                                                  2466* 2467* 2485 2489 2490 2530 2530 2531 2539
                                                                                  2549 2550 2557 2562 2563 2563 2581 2581 2614 2614
                                                                                  2617 2629*
queue                   116            based           fixed bin(17,0)          level 2 in structure "abs_args" dcl 1-10
                                                                                  in procedure "absentee_utility_" ref 2160 2164
queue                    11            based           fixed bin(17,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 806 952*
queue                   245            based           fixed bin(17,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1012* 1015* 1015 1134
                                                                                  1134 1173 1173
queue_data               20            based           structure                array level 2 dcl 2-76
queue_dropped            56(05)        based           bit(1)                   array level 3 packed packed unaligned dcl 4-28 set
                                                                                  ref 884* 2445 2467*
queue_index                     000103 automatic       fixed bin(17,0)          dcl 118 set ref 413 490 606 609* 723 807* 1385*
                                                                                  1767* 1772* 1989* 1992* 2136* 2176* 2177 2294*
                                                                                  2331 2434* 2438* 2444 2445* 2448* 2453
queue_indices                   000074 internal static fixed bin(17,0)          initial array dcl 258 set ref 627* 665* 756 757*
                                                                                  760* 807 1767 2176 2294 2434
queue_msg_hdr                          based           structure                level 1 dcl 15-12
queue_msg_hdr_version_1                constant        fixed bin(17,0)          initial dcl 15-37 ref 1032 2185
queue_number                           parameter       fixed bin(17,0)          dcl 1835 set ref 1832 1837 1837*
queue_sw                  0(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 ref 2159
rcp_init_flags                         based           structure                level 1 packed packed unaligned dcl 13-8
rcp_sys_$cancel_id              000220 constant        entry                    external dcl 225 ref 370
ready_list               12(06)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  840 1423* 2248 2537*
real_queue              246            based           fixed bin(17,0)          level 2 dcl 20-78 set ref 1012* 1765
reason                          000323 automatic       varying char(160)        dcl 175 set ref 1219* 1926* 1929* 1932 1932 1932*
                                                                                  1932 1932 1937* 1937 1938* 1938 1942* 1942 1942
                                                                                  1958*
rebuilding                7            based           bit(1)                   level 2 packed packed unaligned dcl 2-76 set ref
                                                                                  347* 1675 1685 1840 1854*
release_count                          parameter       fixed bin(17,0)          dcl 449 set ref 446 2285*
repeat                          000732 automatic       bit(1)                   dcl 1622 in procedure "find_next_queue_entry" set
                                                                                  ref 1637* 1638 1643*
repeat                          001044 automatic       bit(1)                   dcl 1984 in procedure "read_msg" set ref 1986* 1987
                                                                                  1995*
repeat                          001104 automatic       bit(1)                   dcl 2131 in procedure "rewrite_msg" set ref 2133*
                                                                                  2134 2139*
repeat                          000661 automatic       bit(1)                   dcl 1380 in procedure "delete_msg" set ref 1382*
                                                                                  1383 1387*
repeat_sw                              parameter       bit(1)                   dcl 869 set ref 862 872* 889*
reqp                            000170 automatic       pointer                  level 2 dcl 150 set ref 381 382 383 385 727 728 843
                                                                                  843 843 843 954 1032 1032 1032 1032 1038 1038 1056
                                                                                  1063 1064 1065 1078 1078 1082 1083 1089 1095 1095
                                                                                  1099 1103 1109 1112 1120 1127 1133 1139 1144 1145
                                                                                  1145 1145 1147 1149 1150 1150 1152 1152 1154 1169
                                                                                  1169 1171 1171 1180 1182 1183 1197 1228 1663 1675
                                                                                  1676 1677 1698 1698* 1867 1868 1908 1910 1912 1912
                                                                                  1912 1912 2084 2085 2098 2136* 2185 2187 2187 2187
                                                                                  2191 2192 2197 2198 2203 2210 2214 2218 2223 2240
                                                                                  2255 2255 2258 2259 2260 2649 2655 2655 2703*
request                                based           structure                level 1 dcl 3-36 set ref 1038 2191
request_found                   000116 automatic       bit(1)                   dcl 127 set ref 403* 407 413 418 423 835 836* 853
                                                                                  1192* 1201* 1227 2299* 2306*
request_header                         based           structure                level 2 dcl 3-36
request_id               24            based           fixed bin(71,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 954*
request_id              234            based           fixed bin(71,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 1089* 1197* 1197*
                                                                                  1951* 2098* 2098*
request_id_                     000222 constant        entry                    external dcl 226 ref 372 372 843 843 1197 1197 1912
                                                                                  1912 1951 2098 2098
request_id_string        12(09)        based           char(32)                 level 2 packed packed unaligned dcl 1-10 ref 2210
request_version          76            based           fixed bin(17,0)          level 2 dcl 3-36 ref 1032 1032 1032 1144 1676 2187
                                                                                  2187 2187
requested_authorization
                        123            based           bit(72)                  level 2 dcl 3-36 set ref 1095* 1095* 1099
reservation_description                based           structure                level 1 dcl 16-55
reservation_id           22            based           fixed bin(71,0)          level 2 in structure "reservation_description"
                                                                                  dcl 16-55 in procedure "absentee_utility_" ref
                                                                                  2110
reservation_id          236            based           fixed bin(71,0)          level 2 in structure "ute" dcl 20-78 in procedure
                                                                                  "absentee_utility_" set ref 369 370* 372* 372*
                                                                                  2110* 2118*
reserved_by              11            based           char(32)                 level 2 dcl 16-55 set ref 2087*
reserved_for              1            based           char(32)                 level 2 dcl 16-55 set ref 2087*
resource                               based           char                     level 2 dcl 3-36 set ref 1197* 2085* 2098*
resource_control_$reserve       000224 constant        entry                    external dcl 227 ref 2091
resource_desc_ptr               000516 automatic       pointer                  dcl 16-72 set ref 335* 782* 1705 1705* 2085* 2091*
resource_list            12(07)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  1417 1421* 2527* 2539 2561 2575
resource_res_ptr                000520 automatic       pointer                  dcl 16-72 set ref 335* 782* 1706 1706* 2085* 2087
                                                                                  2087 2090 2091* 2110
resource_timer_set              000102 internal static bit(1)                   initial dcl 259 set ref 744 791 2036* 2423*
restartable             125            based           bit(1)                   level 3 packed packed unaligned dcl 3-36 ref 1675
restarted               125(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  1677*
return_args                     000170 automatic       structure                level 1 dcl 150 set ref 1989 1989 1992 1992
ring                                   parameter       fixed bin(17,0)          dcl 1717 in procedure "get_effmode" set ref 1712
                                                                                  1720*
ring                     13     000170 automatic       fixed bin(17,0)          level 2 in structure "return_args" dcl 150
                                                                                  in procedure "absentee_utility_" set ref 2679*
ring1                     1(22)        based           bit(1)                   level 3 packed packed unaligned dcl 5-12 ref 512
rqid                            000262 automatic       char(19)                 packed unaligned dcl 172 set ref 1219 1219* 1219
                                                                                  1948* 1951* 1958 1958* 1958
rsc_sw                          001160 automatic       bit(1)                   dcl 2397 set ref 2400* 2407* 2423
rsc_timer_seconds       542            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 12-33 ref 748
rsc_waiting              30            based           fixed bin(17,0)          array level 2 dcl 4-28 set ref 1418* 1418 2074* 2074
                                                                                  2530* 2530
rtrim                                                  builtin function         dcl 237 ref 370 370 1078 1078 1929 1937 2087 2087
                                                                                  2379 2379 2379 2379 2379 2379 2650 2651
run_list                 12(09)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  962*
run_sw                          000572 automatic       bit(1)                   initial dcl 923 set ref 923* 929* 961 985 987
search_code                     000100 automatic       fixed bin(35,0)          dcl 115 set ref 412* 413 415* 416
secondary_ok            247(06)        based           bit(1)                   level 3 packed packed unaligned dcl 20-78 set ref
                                                                                  1066
send_mail_$access_class         000226 constant        entry                    external dcl 228 ref 2379
send_mail_info                  000523 automatic       structure                level 1 dcl 18-5 set ref 2374* 2379 2379
send_mail_info_version_2        000522 automatic       fixed bin(17,0)          initial dcl 18-3 set ref 18-3* 2375
sender                  104(09)        based           char(32)                 level 2 in structure "abs_args" packed packed
                                                                                  unaligned dcl 1-10 in procedure
                                                                                  "absentee_utility_" ref 2223
sender                  253            based           char(32)                 level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 20-78 in procedure "absentee_utility_" set ref
                                                                                  1063*
sender                    3     000170 automatic       char(32)                 level 2 in structure "return_args" dcl 150
                                                                                  in procedure "absentee_utility_" set ref 1045 1049
                                                                                  1051 1219* 2196 2202 2204 2379 2379 2379 2379
                                                                                  2381* 2655* 2679
sender                                 based           char                     level 2 in structure "request" dcl 3-36 in procedure
                                                                                  "absentee_utility_" ref 1063 2223
sender_authorization     16     000170 automatic       bit(72)                  level 2 dcl 150 set ref 1095* 1095 2379
sender_sw                 0(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 ref 2222
sent_from                 1     000523 automatic       char(32)                 level 2 dcl 18-5 set ref 2378*
short                           000270 automatic       char(8)                  packed unaligned dcl 173 set ref 1928*
skip_list                12(04)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  955*
state                    67            based           fixed bin(17,0)          level 3 dcl 3-36 set ref 381* 727* 1183* 1228* 1663
                                                                                  1867* 2240 2260*
static_alarm_time               000104 internal static fixed bin(71,0)          initial dcl 260 set ref 792* 2035* 2409 2409 2413
                                                                                  2419* 2421* 2422*
status_flags                           parameter       bit(36)                  packed unaligned dcl 1865 ref 1863 1868 1870
std_length               71            based           fixed bin(17,0)          level 3 dcl 3-36 ref 1038 1112 2192
string                                                 builtin function         dcl 237 set ref 1065* 1065
substr                                                 builtin function         dcl 237 ref 1073 1074 1079 1084 1145 1150 1723 1932
                                                                                  1932 1942 1992 1992 2379 2379 2661
switches                 11     000523 automatic       structure                level 2 in structure "send_mail_info" dcl 18-5
                                                                                  in procedure "absentee_utility_"
switches                 12            based           structure                level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_"
switches                112            based           structure                array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_"
sys_info$max_seg_size           000264 external static fixed bin(35,0)          dcl 251 ref 944
sys_log_                        000230 constant        entry                    external dcl 229 ref 609 820 843 945 1197 1219 1770
                                                                                  1837 1841 1847 2055 2281 2302 2416 2439 2471
sys_log_$error_log              000232 constant        entry                    external dcl 230 ref 372 391 395 484 604 631 636 659
                                                                                  667 679 685 688 702 732 758 768 882 888 1851 2098
                                                                                  2362 2381 2655
sysdir                                 defined         char(168)                packed unaligned dcl 7-28 set ref 492* 627* 631*
                                                                                  633* 636* 657* 659* 665* 667* 683* 685* 686* 688*
                                                                                  700* 702* 758* 768* 882* 888* 945* 1841* 1847*
                                                                                  1851*
system_area                            based           area(1048)               dcl 107 ref 1118 1126
tag                      15            based           char(1)                  level 2 packed packed unaligned dcl 20-78 set ref
                                                                                  1068* 2665*
tail_cput                27            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 1311* 2485 2490*
tail_defer                4            based           fixed bin(17,0)          level 2 dcl 2-76 set ref 1243 1247* 1278 1292* 1336*
tail_free                 2            based           fixed bin(17,0)          level 2 dcl 2-76 set ref 931 934 936* 1454 1455*
tail_lc                   6            based           fixed bin(17,0)          level 2 dcl 2-76 set ref 583* 1362* 2506 2515*
tail_ready               21            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 1406* 2059 2539 2557*
tail_resource            25            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 1408 1408* 1598 2531
                                                                                  2562* 2614 2614
tail_run                 24            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 963 985* 1448 1448*
                                                                                  1630 1665
tail_skip                23            based           fixed bin(17,0)          array level 3 dcl 2-76 set ref 965 987 987* 1446*
                                                                                  1629 2336 2581 2581
time                     16            based           fixed bin(71,0)          level 2 in structure "abs_info" dcl 2-107
                                                                                  in procedure "absentee_utility_" set ref 1241*
                                                                                  1258* 1260 1288* 1342*
time                    116            based           fixed bin(71,0)          array level 3 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 799 815*
                                                                                  1260
time                                   parameter       fixed bin(71,0)          dcl 2396 in procedure "set_defer_timer" ref 2391
                                                                                  2399 2405 2409 2415 2416 2416 2421
time_now                        000112 automatic       fixed bin(71,0)          dcl 124 set ref 334* 747* 748 796* 799 1165 2415
                                                                                  2419
timer_manager_$alarm_wakeup     000234 constant        entry                    external dcl 231 ref 2422
timer_manager_$reset_alarm_wakeup
                                000236 constant        entry                    external dcl 232 ref 2034 2413
uflags                  431            based           structure                level 2 dcl 20-78
unspec                                                 builtin function         dcl 237 set ref 382* 728* 1171 1171 1453* 1868* 1908
                                                                                  2258* 2362 2362 2374* 2416 2416
up                                     parameter       pointer                  dcl 100 ref 56 332 435 439 446 452 590 599 714 719
ur_at                    77            based           structure                level 2 dcl 20-78
user                                   parameter       char                     packed unaligned dcl 1715 in procedure "get_effmode"
                                                                                  set ref 1712 1720*
user                            000137 automatic       char(32)                 packed unaligned dcl 140 in procedure
                                                                                  "absentee_utility_" set ref 491* 492* 509 510
user_abs_attributes                    based           structure                level 1 dcl 23-25
user_attributes                        based           structure                level 1 dcl 22-21
user_deferred_indefinitely
                        125(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  1169 2255 2259*
user_limit              126(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  385* 1180*
user_message                    000374 automatic       char(200)                packed unaligned dcl 176 set ref 1912* 1958* 2379
                                                                                  2379
user_sw                                based           bit(1)                   level 3 packed packed unaligned dcl 1-10 ref 2194
user_table_mgr_$reset           000240 constant        entry                    external dcl 233 ref 398 418 853 904
ut_header                              based           structure                level 1 dcl 21-16
ute                                    based           structure                level 1 dcl 20-78
utep                            000536 automatic       pointer                  initial dcl 20-76 set ref 332* 342 353 358 360 361
                                                                                  369 370 370 370 372 372 372 372 372 379 383 385
                                                                                  391 391 391 391 395 395 395 398* 405 418* 477* 484
                                                                                  484 484 517 524 524 524 524 524 524 599* 604 604
                                                                                  604 606 609 609 609 719* 725 732 20-76* 853* 904*
                                                                                  1012 1012 1015 1015 1017 1018 1022 1023 1024 1045
                                                                                  1051 1052 1056 1058 1063 1064 1065 1066 1066 1068
                                                                                  1070 1073 1074 1076 1077 1078 1079 1080 1083 1084
                                                                                  1085 1087 1089 1099 1104 1105 1106 1107 1110 1118
                                                                                  1120 1126 1127 1133 1134 1134 1134 1134 1137 1139
                                                                                  1145 1148 1149 1150 1152 1156 1157 1164 1165 1173
                                                                                  1173 1173 1197 1197 1197 1219 1258 1765 1770 1770
                                                                                  1770 1951 1955 1958 2087 2087 2091 2098 2098 2098
                                                                                  2098 2110 2118 2320 2482 2660 2660 2661 2661 2661
                                                                                  2663 2664 2665
validation_level         15            based           fixed bin(3,0)           level 2 dcl 9-15 ref 492
verify                                                 builtin function         dcl 237 ref 1076 1077 1080 1085
version                                based           fixed bin(17,0)          level 2 in structure "absentee_data" dcl 2-76
                                                                                  in procedure "absentee_utility_" set ref 710*
                                                                                  1855*
version                         000523 automatic       fixed bin(17,0)          level 2 in structure "send_mail_info" dcl 18-5
                                                                                  in procedure "absentee_utility_" set ref 2375*
waiting_for_load_ctl     12(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  357* 1179* 1420* 2023
waiting_for_resources
                         12(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-107 set ref
                                                                                  1189* 1419*
wakeup                   11     000523 automatic       bit(1)                   level 3 packed packed unaligned dcl 18-5 set ref
                                                                                  2376*
was_rsc_timer                   000506 automatic       bit(1)                   dcl 778 set ref 791* 818
what                                   parameter       fixed bin(17,0)          dcl 2149 set ref 2146 2243 2254 2281* 2281* 2281*
                                                                                  2284
whoptr                                 defined         pointer                  dcl 7-29 ref 2361 2361 2362 2362 2362
whotab                                 based           structure                level 1 dcl 24-10
xstring                                based           char                     dcl 109 set ref 1126 1127*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 23-38
ABS_FLAG_NAMES                         internal static varying char(8)          initial array dcl 20-326
ABS_LOGIN_PRIO                         internal static fixed bin(17,0)          initial dcl 10-36
ABS_TRYLOG_METER                       internal static fixed bin(17,0)          initial dcl 8-35
ACCTUP_METER                           internal static fixed bin(17,0)          initial dcl 8-26
ACCT_UPDATE_PRIO                       internal static fixed bin(17,0)          initial dcl 10-28
ACTIVE_VALUES                          internal static char(18)                 initial array dcl 11-86
ADMIN_METER                            internal static fixed bin(17,0)          initial dcl 8-32
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 22-77
ASINIT_METER                           internal static fixed bin(17,0)          initial dcl 8-19
AS_METER_NAMES                         internal static char(8)                  initial array packed unaligned dcl 8-43
AS_REQUEST_PRIO                        internal static fixed bin(17,0)          initial dcl 10-30
AS_REQUEST_SENDER_VERSION_2            internal static char(8)                  initial packed unaligned dcl 9-27
AUM_METER                              internal static fixed bin(17,0)          initial dcl 8-22
AUTBL_CONTROL_NAMES                    internal static varying char(20)         initial array dcl 4-68
AUTBL_version_4                        internal static fixed bin(17,0)          initial dcl 4-24
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 13-16
COMMAND_METER                          internal static fixed bin(17,0)          initial dcl 8-30
CORE_FLUSH_PRIO                        internal static fixed bin(17,0)          initial dcl 10-37
CPG_METER                              internal static fixed bin(17,0)          initial dcl 8-24
DAEMON_LOGIN_PRIO                      internal static fixed bin(17,0)          initial dcl 10-29
DERIVE_MASK                            internal static bit(2)                   initial packed unaligned dcl 20-280
DIALUP_METER                           internal static fixed bin(17,0)          initial dcl 8-20
DIAL_SERVER_FLAG_NAMES                 internal static varying char(12)         initial array dcl 20-332
DONT_MASK                              internal static bit(2)                   initial packed unaligned dcl 20-280
DO_MASK                                internal static bit(2)                   initial packed unaligned dcl 20-280
DPG_METER                              internal static fixed bin(17,0)          initial dcl 8-25
DUM_METER                              internal static fixed bin(17,0)          initial dcl 8-21
FIXPDT_METER                           internal static fixed bin(17,0)          initial dcl 8-34
INSTALL_METER                          internal static fixed bin(17,0)          initial dcl 8-27
INSTALL_PRIO                           internal static fixed bin(17,0)          initial dcl 10-31
INT_LOGIN_PRIO                         internal static fixed bin(17,0)          initial dcl 10-32
LOGIN_RESULT_VALUES                    internal static varying char(24)         initial array dcl 20-338
MASK_CTL_NAMES                         internal static varying char(12)         initial array dcl 20-284
MC_PRIO                                internal static fixed bin(17,0)          initial dcl 10-25
MPX_LOAD_PRIO                          internal static fixed bin(17,0)          initial dcl 10-33
MSEG_A_ACCESS                          internal static bit(36)                  initial dcl 14-17
MSEG_FULL_ACCESS                       internal static bit(36)                  initial dcl 14-28
MSEG_MBX_CREATOR_INITIAL_ACCESS        defined         bit(36)                  dcl 14-36
MSEG_MBX_INITIAL_ACL                   internal static bit(36)                  initial array dcl 14-36
MSEG_MBX_OTHERS_INITIAL_ACCESS         defined         bit(36)                  dcl 14-36
MSEG_MBX_SYSDAEMON_INITIAL_ACCESS      defined         bit(36)                  dcl 14-36
MSEG_NULL_ACCESS                       internal static bit(36)                  initial dcl 14-28
MSEG_QUEUE_ADMIN_ACCESS                internal static bit(36)                  initial dcl 14-61
MSEG_QUEUE_CREATOR_INITIAL_ACCESS      defined         bit(36)                  dcl 14-48
MSEG_QUEUE_INITIAL_ACL                 internal static bit(36)                  initial array dcl 14-48
MSEG_QUEUE_OTHERS_INITIAL_ACCESS       defined         bit(36)                  dcl 14-48
MSEG_QUEUE_SYSDAEMON_INITIAL_ACCESS    defined         bit(36)                  dcl 14-48
MSEG_QUEUE_USER_ACCESS                 internal static bit(36)                  initial dcl 14-61
MSEG_R_ACCESS                          internal static bit(36)                  initial dcl 14-17
MSEG_S_ACCESS                          internal static bit(36)                  initial dcl 14-17
MSEG_U_ACCESS                          internal static bit(36)                  initial dcl 14-17
MSEG_W_ACCESS                          internal static bit(36)                  initial dcl 14-17
MSGCORD_METER                          internal static fixed bin(17,0)          initial dcl 8-29
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 13-16
NETUP_METER                            internal static fixed bin(17,0)          initial dcl 8-37
NOW_DIALED                             internal static fixed bin(17,0)          initial dcl 11-76
NOW_DIALED_OUT                         internal static fixed bin(17,0)          initial dcl 11-76
NOW_DIALING                            internal static fixed bin(17,0)          initial dcl 11-76
NOW_FREE                               internal static fixed bin(17,0)          initial dcl 11-76
NOW_HAS_PROCESS                        internal static fixed bin(17,0)          initial dcl 11-76
NOW_HUNG_UP                            internal static fixed bin(17,0)          initial dcl 11-76
NOW_LISTENING                          internal static fixed bin(17,0)          initial dcl 11-76
NOW_LOGGED_IN                          internal static fixed bin(17,0)          initial dcl 11-76
No_authentication                      internal static fixed bin(17,0)          initial dcl 13-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 13-16
PREEMPT_BUMPED                         internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_BUMPED_NO_TERM                 internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_LOAD_CTL                       internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_TERMSGNL_RECEIVED              internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_TERM_SENT                      internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_UNBUMP                         internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_UNBUMP_IGNORE_ALARM            internal static fixed bin(17,0)          initial dcl 11-132
PREEMPT_VALUES                         internal static varying char(28)         initial array dcl 11-142
PROCESS_TYPE_NAMES                     internal static varying char(12)         initial array dcl 20-265
PT_ABSENTEE                            internal static fixed bin(17,0)          initial dcl 20-261
PT_ALARM                               internal static fixed bin(17,0)          initial dcl 11-106
PT_BUMP                                internal static fixed bin(17,0)          initial dcl 11-106
PT_DAEMON                              internal static fixed bin(17,0)          initial dcl 20-261
PT_DESTROY_REQUEST                     internal static fixed bin(17,0)          initial dcl 11-106
PT_DETACH                              internal static fixed bin(17,0)          initial dcl 11-106
PT_FPE                                 internal static fixed bin(17,0)          initial dcl 11-106
PT_HANGUP                              internal static fixed bin(17,0)          initial dcl 11-106
PT_INTERACTIVE                         internal static fixed bin(17,0)          initial dcl 20-261
PT_LOGOUT                              internal static fixed bin(17,0)          initial dcl 11-106
PT_NEW_PROC_AUTH                       internal static fixed bin(17,0)          initial dcl 11-106
PT_NEW_PROC_REQUEST                    internal static fixed bin(17,0)          initial dcl 11-106
PT_OPERATOR_TERMINATE                  internal static fixed bin(17,0)          initial dcl 11-106
PT_SHUTDOWN                            internal static fixed bin(17,0)          initial dcl 11-106
PT_UNBUMP                              internal static fixed bin(17,0)          initial dcl 11-106
PW_FLAG_NAMES                          internal static varying char(12)         initial array dcl 20-290
Resource_count                         automatic       fixed bin(17,0)          dcl 16-78
SAC_METER                              internal static fixed bin(17,0)          initial dcl 8-31
SHUTDOWN_PRIO                          internal static fixed bin(17,0)          initial dcl 10-27
SL_INFO_arg_given_in_structure         internal static fixed bin(17,0)          initial dcl 19-69
SL_INFO_arg_not_given                  internal static fixed bin(17,0)          initial dcl 19-69
SL_INFO_as_mode                        internal static fixed bin(17,0)          initial dcl 19-65
SL_INFO_command_mode                   internal static fixed bin(17,0)          initial dcl 19-65
SL_INFO_version_1                      internal static char(8)                  initial packed unaligned dcl 19-62
SL_LOG_CRASH                           internal static fixed bin(17,0)          initial dcl 19-14
SL_TYPE_BEEP                           internal static fixed bin(17,0)          initial dcl 19-14
SL_TYPE_CRASH                          internal static fixed bin(17,0)          initial dcl 19-14
SSU_METER                              internal static fixed bin(17,0)          initial dcl 8-33
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 15-46
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 15-47
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 15-41
STATE_VALUES                           internal static char(15)                 initial array dcl 11-70
SYSERR_COPY_PRIO                       internal static fixed bin(17,0)          initial dcl 10-26
TABLE_NAMES                            internal static char(20)                 initial array packed unaligned dcl 20-271
TAG_DAEMON                             internal static char(1)                  initial packed unaligned dcl 11-93
TAG_INTERACTIVE                        internal static char(1)                  initial packed unaligned dcl 11-93
TAG_UFT                                internal static char(1)                  initial packed unaligned dcl 11-93
TRA_VEC_VALUES                         internal static char(32)                 initial array dcl 11-54
TTY_DIALED                             internal static fixed bin(17,0)          initial dcl 11-64
TTY_HUNG                               internal static fixed bin(17,0)          initial dcl 11-64
TTY_KNOWN                              internal static fixed bin(17,0)          initial dcl 11-64
TTY_MASKED                             internal static fixed bin(17,0)          initial dcl 11-64
UFLAG_NAMES                            internal static varying char(24)         initial array dcl 20-303
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 22-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 22-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 22-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 22-50
UTE_version_4                          internal static fixed bin(17,0)          initial dcl 20-74
WAIT_ANSWERBACK                        internal static fixed bin(17,0)          initial dcl 11-25
WAIT_BEFORE_HANGUP                     internal static fixed bin(17,0)          initial dcl 11-25
WAIT_CONNECT_REQUEST                   internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DELETE_CHANNEL                    internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DESTROY_REQUEST                   internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DETACH                            internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DIALUP                            internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DIAL_OUT                          internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DIAL_RELEASE                      internal static fixed bin(17,0)          initial dcl 11-25
WAIT_DISCARD_WAKEUPS                   internal static fixed bin(17,0)          initial dcl 11-25
WAIT_FIN_PRIV_ATTACH                   internal static fixed bin(17,0)          initial dcl 11-25
WAIT_FIN_TANDD_ATTACH                  internal static fixed bin(17,0)          initial dcl 11-25
WAIT_GREETING_MSG                      internal static fixed bin(17,0)          initial dcl 11-25
WAIT_HANGUP                            internal static fixed bin(17,0)          initial dcl 11-25
WAIT_LOGIN_ARGS                        internal static fixed bin(17,0)          initial dcl 11-25
WAIT_LOGIN_LINE                        internal static fixed bin(17,0)          initial dcl 11-25
WAIT_LOGOUT                            internal static fixed bin(17,0)          initial dcl 11-25
WAIT_LOGOUT_HOLD                       internal static fixed bin(17,0)          initial dcl 11-25
WAIT_LOGOUT_SIG                        internal static fixed bin(17,0)          initial dcl 11-25
WAIT_NEW_PASSWORD                      internal static fixed bin(17,0)          initial dcl 11-25
WAIT_NEW_PROC                          internal static fixed bin(17,0)          initial dcl 11-25
WAIT_NEW_PROC_REQUEST                  internal static fixed bin(17,0)          initial dcl 11-25
WAIT_OLD_PASSWORD                      internal static fixed bin(17,0)          initial dcl 11-25
WAIT_PASSWORD                          internal static fixed bin(17,0)          initial dcl 11-25
WAIT_REMOVE                            internal static fixed bin(17,0)          initial dcl 11-25
WAIT_SLAVE_REQUEST                     internal static fixed bin(17,0)          initial dcl 11-25
WAIT_TANDD_HANGUP                      internal static fixed bin(17,0)          initial dcl 11-25
WHOTAB_VERSION_1                       internal static fixed bin(17,0)          initial dcl 24-96
as_data_$BS                            external static char(1)                  dcl 6-21
as_data_$CR                            external static char(1)                  dcl 6-22
as_data_$acct_update_priority          external static fixed bin(17,0)          dcl 6-24
as_data_$ansp                          external static pointer                  dcl 6-26
as_data_$as_procid                     external static bit(36)                  dcl 6-27
as_data_$as_ring                       external static fixed bin(3,0)           dcl 6-28
as_data_$as_tty                        automatic       char(6)                  packed unaligned dcl 6-29
as_data_$asmtp                         external static pointer                  dcl 6-30
as_data_$buzzardp                      external static pointer                  dcl 6-32
as_data_$cdtp                          external static pointer                  dcl 6-33
as_data_$debug_flag                    external static bit(1)                   dcl 6-84
as_data_$default_weight                external static fixed bin(35,0)          dcl 6-34
as_data_$devtabp                       external static pointer                  dcl 6-35
as_data_$dft_user_ring                 external static fixed bin(3,0)           dcl 6-36
as_data_$dutp                          external static pointer                  dcl 6-37
as_data_$g115_dim                      external static char(32)                 packed unaligned dcl 6-38
as_data_$lct_initialized               external static bit(1)                   dcl 6-39
as_data_$lct_size                      external static fixed bin(17,0)          dcl 6-40
as_data_$login_args                    external static structure                level 1 dcl 6-62
as_data_$login_words                   external static fixed bin(17,0)          dcl 6-77
as_data_$ls_message_buffer_cur_lth     external static fixed bin(18,0)          dcl 6-86
as_data_$ls_message_buffer_max_lth     external static fixed bin(18,0)          dcl 6-87
as_data_$ls_message_buffer_ptr         external static pointer                  dcl 6-88
as_data_$ls_request_server_info_ptr    external static pointer                  dcl 6-85
as_data_$max_user_ring                 external static fixed bin(3,0)           dcl 6-41
as_data_$mgtp                          external static pointer                  dcl 6-42
as_data_$mrd_dim                       external static char(32)                 packed unaligned dcl 6-43
as_data_$ntty_dim                      external static char(32)                 packed unaligned dcl 6-44
as_data_$pdtdir                        external static char(168)                packed unaligned dcl 6-45
as_data_$pit_ptr                       external static pointer                  dcl 6-46
as_data_$rcpdir                        external static char(168)                packed unaligned dcl 6-47
as_data_$request_priority              external static fixed bin(17,0)          dcl 6-48
as_data_$rtdtp                         external static pointer                  dcl 6-50
as_data_$sat_htp                       external static pointer                  dcl 6-51
as_data_$satp                          external static pointer                  dcl 6-52
as_data_$signal_types                  external static structure                level 1 dcl 6-67
as_data_$suffix                        external static char(2)                  array packed unaligned dcl 6-53
as_data_$system_signal_types           external static structure                level 1 dcl 6-72
as_data_$teens_suffix                  external static char(2)                  array packed unaligned dcl 6-55
as_data_$terminet_tabs_string          external static varying char(144)        dcl 6-56
as_data_$tty_dim                       external static char(32)                 packed unaligned dcl 6-57
as_data_$update_priority               external static fixed bin(17,0)          dcl 6-58
as_data_$version                       external static char(8)                  packed unaligned dcl 6-59
as_data_login_words                    based           structure                level 1 dcl 6-77
as_procid                              defined         bit(36)                  dcl 7-17
as_tty                                 based           char(6)                  packed unaligned dcl 7-18
asmtp                                  defined         pointer                  dcl 7-19
authentication_level_names             internal static char(12)                 initial array packed unaligned dcl 13-21
devtabp                                defined         pointer                  dcl 7-20
installation_parms_version_1           internal static fixed bin(17,0)          initial dcl 12-37
installation_parms_version_2           internal static fixed bin(17,0)          initial dcl 12-38
mgtp                                   defined         pointer                  dcl 7-22
pdtdir                                 based           char(168)                packed unaligned dcl 7-23
recursion_possible                     internal static bit(18)                  initial packed unaligned dcl 8-39
resource_desc_version_1                internal static fixed bin(17,0)          initial dcl 16-75
resource_descriptions                  based           structure                level 1 dcl 16-6
resource_res_version_1                 internal static fixed bin(17,0)          initial dcl 16-75
rifp                                   automatic       pointer                  dcl 13-6
rs_ptrs                                based           pointer                  array dcl 7-24
sat_htp                                defined         pointer                  dcl 7-25
satp                                   defined         pointer                  dcl 7-26
sc_stat_$Go                            external static bit(1)                   dcl 17-62
sc_stat_$Go_typed                      external static bit(1)                   dcl 17-62
sc_stat_$Multics                       external static bit(1)                   dcl 17-62
sc_stat_$Multics_typed                 external static bit(1)                   dcl 17-62
sc_stat_$Star_typed                    external static bit(1)                   dcl 17-62
sc_stat_$admin_listener_exit_label     external static label variable           dcl 17-34
sc_stat_$admin_listener_switch         external static bit(1)                   dcl 17-62
sc_stat_$admin_log_iocb                external static pointer                  dcl 17-45
sc_stat_$admin_log_write_ptr           external static pointer                  dcl 17-45
sc_stat_$admin_sci_ptr                 external static pointer                  dcl 17-45
sc_stat_$as_log_write_ptr              external static pointer                  dcl 17-45
sc_stat_$did_part1                     external static bit(1)                   dcl 17-62
sc_stat_$did_part2                     external static bit(1)                   dcl 17-62
sc_stat_$did_part3                     external static bit(1)                   dcl 17-62
sc_stat_$exec_access_name              external static char(32)                 packed unaligned dcl 17-15
sc_stat_$info_dir                      external static char(168)                packed unaligned dcl 17-21
sc_stat_$initzer_ttyp                  external static pointer                  dcl 17-45
sc_stat_$log_dir                       external static char(168)                packed unaligned dcl 17-21
sc_stat_$master_abort_label            external static label variable           dcl 17-34
sc_stat_$master_channel                external static char(6)                  dcl 17-29
sc_stat_$master_iocb                   external static pointer                  dcl 17-45
sc_stat_$master_sci_ptr                external static pointer                  dcl 17-45
sc_stat_$mc_acs_dir                    external static char(168)                packed unaligned dcl 17-21
sc_stat_$mc_ansp                       external static pointer                  dcl 17-45
sc_stat_$mc_iocb                       external static pointer                  dcl 17-45
sc_stat_$mc_is_on                      external static bit(1)                   dcl 17-62
sc_stat_$no_operator_login             external static bit(1)                   dcl 17-62
sc_stat_$shutdown_typed                external static bit(1)                   dcl 17-62
sc_stat_$sv1_iocb                      external static pointer                  dcl 17-45
sc_stat_$sv2_iocb                      external static pointer                  dcl 17-45
sc_stat_$sv3_iocb                      external static pointer                  dcl 17-45
sc_stat_$sysdir                        external static char(168)                packed unaligned dcl 17-21
sc_stat_$system_shutdown_label         external static label variable           dcl 17-34
sc_stat_$test_mode                     external static bit(1)                   dcl 17-62
sc_stat_$unidentified_access_name      external static char(32)                 packed unaligned dcl 17-15
sc_stat_$vchn_requires_accept          external static bit(1)                   dcl 17-62
scdtp                                  defined         pointer                  dcl 7-27
sl_info                                automatic       structure                level 1 dcl 19-24
sl_info_code_msg                       internal static structure                level 1 dcl 19-187
sl_info_msg                            internal static structure                level 1 dcl 19-214
sl_info_sev_code_label_msg             internal static structure                level 1 dcl 19-161
sl_info_sev_code_msg                   internal static structure                level 1 dcl 19-82
sl_info_sev_coded_msg                  internal static structure                level 1 dcl 19-134
sl_info_sev_msg                        internal static structure                level 1 dcl 19-108

NAMES DECLARED BY EXPLICIT CONTEXT.
abs_defer                       002424 constant        entry                    external dcl 435
abs_defer_abort                 002446 constant        label                    dcl 441 ref 438
abs_release                     002461 constant        entry                    external dcl 446
abs_release_abort               002503 constant        label                    dcl 454 ref 451
abs_run                         005564 constant        entry                    internal dcl 829 ref 405
absentee_utility_               001537 constant        entry                    external dcl 56
au_abort                        002375 constant        label                    dcl 423 ref 328
au_return                       002412 constant        label                    dcl 429 ref 427
au_send_ctl_wakeup              002513 constant        entry                    external dcl 459
au_send_wakeup                  002527 constant        entry                    external dcl 463
au_send_wakeup_abort            002544 constant        label                    dcl 468 ref 466
check_for_badseg                005706 constant        entry                    internal dcl 862 ref 1387 1995 2139
check_for_running               011466 constant        entry                    internal dcl 1651 ref 1643
check_last_rsc                  011361 constant        entry                    internal dcl 1594 ref 1545 1552
check_queue_access              002557 constant        entry                    external dcl 471
cleaner_up                      006133 constant        entry                    internal dcl 899 ref 336 784
clear_lc_abort                  003235 constant        label                    dcl 587 ref 567
clear_lc_list                   003151 constant        entry                    external dcl 536
create_run                      006205 constant        entry                    internal dcl 927 ref 849
create_skip                     006202 constant        entry                    internal dcl 916 ref 1642
create_skip_common              006211 constant        label                    dcl 931 ref 925
decode_lc_ineligible            006420 constant        entry                    internal dcl 992 ref 1177
decode_request                  006437 constant        entry                    internal dcl 1008 ref 416 851
defer_request_indefinitely      010257 constant        entry                    internal dcl 1238 ref 1170 2250
defer_request_until_time        010305 constant        entry                    internal dcl 1252 ref 1166
delete_cput                     010435 constant        entry                    internal dcl 1298 ref 839 1495 2247
delete_defer                    010501 constant        entry                    internal dcl 1324 ref 809 841 2249 2263
delete_lc                       010540 constant        entry                    internal dcl 1349 ref 1427
delete_message                  003246 constant        entry                    external dcl 590
delete_msg                      010575 constant        entry                    internal dcl 1374 ref 606 1214 1686
delete_ready                    010647 constant        entry                    internal dcl 1393 ref 840 1573 2248
delete_skip                     010751 constant        entry                    internal dcl 1433 ref 602 1215 1496 1575 1670 1687
dm_abort                        003344 constant        label                    dcl 606 ref 598
find_eligible_cput              011032 constant        entry                    internal dcl 1462 ref 1743
find_eligible_ready             011167 constant        entry                    internal dcl 1507 ref 1749
find_next_queue_entry           011400 constant        entry                    internal dcl 1607 ref 1754
free_req                        011601 constant        entry                    internal dcl 1696 ref 389 730 845 892 905 1232 1558
                                                                                  1669 1683 2272 2589
free_rsc                        011623 constant        entry                    internal dcl 1704 ref 906 2103 2111
get_effmode                     011660 constant        entry                    internal dcl 1712 ref 2679
get_next_request                011777 constant        entry                    internal dcl 1726 ref 415
get_queue_from_aute             012052 constant        entry                    internal dcl 1761 ref 721 2324
init_au                         003437 constant        entry                    external dcl 613
lc_will_reject                  012133 constant        entry                    internal dcl 1779 ref 1004 2026
loop_error                      012251 constant        entry                    internal dcl 1832 ref 579 811 1265 1487 1585 1819
                                                                                  2341 2629
mark_request_deferred           012527 constant        entry                    internal dcl 1863 ref 1167 1171 1175 1190 2245
mark_request_running            004663 constant        entry                    external dcl 714
message_error                   012551 constant        entry                    internal dcl 1876 ref 1032 1038 1076 1077 1079 1080
                                                                                  1084 1085 1112 2094 2115 2657
notify_deferral                 012565 constant        entry                    internal dcl 1899 ref 388 1185 1870
notify_user                     012711 constant        entry                    internal dcl 1922 ref 1216
read_msg                        013301 constant        entry                    internal dcl 1968 ref 379 725 1494 1554 1574 1639
                                                                                  2179 2296 2577
ready_lc_ineligible             013433 constant        entry                    internal dcl 2003 ref 1567
reset_alarm_timer               013452 constant        entry                    internal dcl 2030 ref 764 1848 2469
rethread_resource_head_to_tail  013470 constant        entry                    internal dcl 2041 ref 1567
return_true                     012237 constant        label                    dcl 1826 ref 1805 1808 1813
rewrite_msg                     014125 constant        entry                    internal dcl 2124 ref 387 729 1184 1229 1678 1869
                                                                                  2261
rsc_reservation_unavailable     013551 constant        entry                    internal dcl 2080 ref 1187 1197
search_queues                   014200 constant        entry                    internal dcl 2146 ref 440 453 833
search_skip_for_aute            015162 constant        entry                    internal dcl 2313 ref 354 482 601
search_skip_for_queue           015172 constant        entry                    internal dcl 2327 ref 837 2239
send_abs_wakeup                 015267 constant        entry                    internal dcl 2354 ref 467 818 1856 2286 2633
send_user_message               015372 constant        entry                    internal dcl 2370 ref 1914 1962
set_defer_timer                 015551 constant        entry                    internal dcl 2391 ref 815 1288
set_resource_timer              004777 constant        entry                    external dcl 737
set_rsc_timer                   015561 constant        entry                    internal dcl 2405 ref 748
set_timer_common                015565 constant        label                    dcl 2409 ref 2401
setup                           016777 constant        entry                    internal dcl 2696 ref 327 437 448 465 476 566 597
                                                                                  615 718 746 754 777
setup_next_queue                004157 constant        label                    dcl 672 ref 638 661 669
setup_queue                     015674 constant        entry                    internal dcl 2430 ref 410
sq_nomatch                      014773 constant        label                    dcl 2272 ref 2185 2187 2191 2192 2197 2198 2203 2204
                                                                                  2210 2214 2219 2224 2240
suspend_absentee_processing     016046 constant        entry                    internal dcl 2464 ref 947 1843 1852
term_au                         005046 constant        entry                    external dcl 752
thread_cput                     016131 constant        entry                    internal dcl 2476 ref 1174
thread_lc                       016170 constant        entry                    internal dcl 2496 ref 367
thread_ready                    016240 constant        entry                    internal dcl 2535 ref 808 2264
thread_resource                 016220 constant        entry                    internal dcl 2521 ref 356 1178 1188 2069
timer_rang                      005263 constant        entry                    external dcl 775
tr_abort                        005534 constant        label                    dcl 821 ref 780
tr_return                       005555 constant        label                    dcl 824 ref 822
update_ready                    016410 constant        entry                    internal dcl 2597 ref 1209
valid_proxy                     016711 constant        entry                    internal dcl 2667 ref 2653
validate_proxy                  016476 constant        entry                    internal dcl 2640 ref 1070

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     20770       21272   17634       21000
Length     22544   17634       302        1235    1133          76

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
absentee_utility_                  2110 external procedure  is an external procedure.  
on unit on line 336                  64 on unit               
on unit on line 784                  64 on unit               
on unit on line 787                  80 on unit               
abs_run                                 internal procedure  shares stack frame of external procedure absentee_utility_.  
check_for_badseg                        internal procedure  shares stack frame of external procedure absentee_utility_.  
cleaner_up                           68 internal procedure  is called by several nonquick procedures.  
create_skip                             internal procedure  shares stack frame of external procedure absentee_utility_.  
decode_lc_ineligible                    internal procedure  shares stack frame of external procedure absentee_utility_.  
decode_request                          internal procedure  shares stack frame of external procedure absentee_utility_.  
defer_request_indefinitely              internal procedure  shares stack frame of external procedure absentee_utility_.  
defer_request_until_time                internal procedure  shares stack frame of external procedure absentee_utility_.  
delete_cput                             internal procedure  shares stack frame of external procedure absentee_utility_.  
delete_defer                            internal procedure  shares stack frame of external procedure absentee_utility_.  
delete_lc                               internal procedure  shares stack frame of external procedure absentee_utility_.  
delete_msg                              internal procedure  shares stack frame of external procedure absentee_utility_.  
delete_ready                            internal procedure  shares stack frame of external procedure absentee_utility_.  
delete_skip                             internal procedure  shares stack frame of external procedure absentee_utility_.  
find_eligible_cput                      internal procedure  shares stack frame of external procedure absentee_utility_.  
find_eligible_ready                     internal procedure  shares stack frame of external procedure absentee_utility_.  
check_last_rsc                          internal procedure  shares stack frame of external procedure absentee_utility_.  
find_next_queue_entry                   internal procedure  shares stack frame of external procedure absentee_utility_.  
check_for_running                       internal procedure  shares stack frame of external procedure absentee_utility_.  
free_req                             68 internal procedure  is called by several nonquick procedures.  
free_rsc                             68 internal procedure  is called by several nonquick procedures.  
get_effmode                             internal procedure  shares stack frame of external procedure absentee_utility_.  
get_next_request                        internal procedure  shares stack frame of external procedure absentee_utility_.  
get_queue_from_aute                     internal procedure  shares stack frame of external procedure absentee_utility_.  
lc_will_reject                          internal procedure  shares stack frame of external procedure absentee_utility_.  
loop_error                              internal procedure  shares stack frame of external procedure absentee_utility_.  
mark_request_deferred                   internal procedure  shares stack frame of external procedure absentee_utility_.  
message_error                           internal procedure  shares stack frame of external procedure absentee_utility_.  
notify_deferral                         internal procedure  shares stack frame of external procedure absentee_utility_.  
notify_user                             internal procedure  shares stack frame of external procedure absentee_utility_.  
read_msg                                internal procedure  shares stack frame of external procedure absentee_utility_.  
ready_lc_ineligible                     internal procedure  shares stack frame of external procedure absentee_utility_.  
reset_alarm_timer                       internal procedure  shares stack frame of external procedure absentee_utility_.  
rethread_resource_head_to_tail
                                        internal procedure  shares stack frame of external procedure absentee_utility_.  
rsc_reservation_unavailable             internal procedure  shares stack frame of external procedure absentee_utility_.  
rewrite_msg                             internal procedure  shares stack frame of external procedure absentee_utility_.  
search_queues                           internal procedure  shares stack frame of external procedure absentee_utility_.  
search_skip_for_aute                    internal procedure  shares stack frame of external procedure absentee_utility_.  
send_abs_wakeup                         internal procedure  shares stack frame of external procedure absentee_utility_.  
send_user_message                       internal procedure  shares stack frame of external procedure absentee_utility_.  
set_defer_timer                         internal procedure  shares stack frame of external procedure absentee_utility_.  
setup_queue                             internal procedure  shares stack frame of external procedure absentee_utility_.  
suspend_absentee_processing             internal procedure  shares stack frame of external procedure absentee_utility_.  
thread_cput                             internal procedure  shares stack frame of external procedure absentee_utility_.  
thread_lc                               internal procedure  shares stack frame of external procedure absentee_utility_.  
thread_resource                         internal procedure  shares stack frame of external procedure absentee_utility_.  
update_ready                            internal procedure  shares stack frame of external procedure absentee_utility_.  
validate_proxy                          internal procedure  shares stack frame of external procedure absentee_utility_.  
valid_proxy                             internal procedure  shares stack frame of external procedure absentee_utility_.  
setup                                   internal procedure  shares stack frame of external procedure absentee_utility_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 absentee_ename              absentee_utility_
000070 adp                         absentee_utility_
000072 areap                       absentee_utility_
000074 queue_indices               absentee_utility_
000102 resource_timer_set          absentee_utility_
000104 static_alarm_time           absentee_utility_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
absentee_utility_        000100 search_code                 absentee_utility_
                         000101 code                        absentee_utility_
                         000102 lc_code                     absentee_utility_
                         000103 queue_index                 absentee_utility_
                         000104 queue                       absentee_utility_
                         000105 list_searched               absentee_utility_
                         000106 aix                         absentee_utility_
                         000107 next_aix                    absentee_utility_
                         000110 ii                          absentee_utility_
                         000112 time_now                    absentee_utility_
                         000114 length_of_arguments         absentee_utility_
                         000115 number_of_arguments         absentee_utility_
                         000116 request_found               absentee_utility_
                         000120 abort_label                 absentee_utility_
                         000124 loop_limit                  absentee_utility_
                         000125 ev_calls_masked             absentee_utility_
                         000126 ctl_wakeup                  absentee_utility_
                         000130 p                           absentee_utility_
                         000132 has_access                  absentee_utility_
                         000133 ext_mode                    absentee_utility_
                         000134 has_o_permission            absentee_utility_
                         000135 has_d_permission            absentee_utility_
                         000136 has_ring1_priv              absentee_utility_
                         000137 user                        absentee_utility_
                         000147 person                      absentee_utility_
                         000155 project                     absentee_utility_
                         000160 authorization               absentee_utility_
                         000162 anonymous_user              absentee_utility_
                         000164 abs_arg_ptr                 absentee_utility_
                         000166 found                       absentee_utility_
                         000170 return_args                 absentee_utility_
                         000212 acl                         absentee_utility_
                         000254 cur_message_id              absentee_utility_
                         000256 date                        absentee_utility_
                         000262 rqid                        absentee_utility_
                         000270 short                       absentee_utility_
                         000272 long                        absentee_utility_
                         000323 reason                      absentee_utility_
                         000374 user_message                absentee_utility_
                         000456 message_in_error            absentee_utility_
                         000457 error                       absentee_utility_
                         000471 message_error_code          absentee_utility_
                         000506 was_rsc_timer               absentee_utility_
                         000510 aip                         absentee_utility_
                         000512 autp                        absentee_utility_
                         000514 as_request_sender_ptr       absentee_utility_
                         000516 resource_desc_ptr           absentee_utility_
                         000520 resource_res_ptr            absentee_utility_
                         000522 send_mail_info_version_2    absentee_utility_
                         000523 send_mail_info              absentee_utility_
                         000536 utep                        absentee_utility_
                         000572 run_sw                      create_skip
                         000626 ix                          defer_request_until_time
                         000627 loop_limit                  defer_request_until_time
                         000660 ec                          delete_msg
                         000661 repeat                      delete_msg
                         000704 loop_limit                  find_eligible_cput
                         000714 loop_limit                  find_eligible_ready
                         000715 found                       find_eligible_ready
                         000732 repeat                      find_next_queue_entry
                         000750 mode                        get_effmode
                         000774 ix                          lc_will_reject
                         000775 loop_limit                  lc_will_reject
                         001026 already_notified            notify_deferral
                         001044 repeat                      read_msg
                         001104 repeat                      rewrite_msg
                         001114 match_count                 search_queues
                         001115 match_queue                 search_queues
                         001116 match_message_id            search_queues
                         001120 ec                          search_queues
                         001121 fq                          search_queues
                         001122 lq                          search_queues
                         001132 loop_limit                  search_skip_for_aute
                         001142 mess                        send_abs_wakeup
                         001160 rsc_sw                      set_defer_timer
                         001230 loop_limit                  update_ready
                         001231 ix                          update_ready
                         001232 found_one                   update_ready
                         001242 code                        validate_proxy
                         001243 proxy_sender                validate_proxy
                         001253 desired_project             validate_proxy
                         001264 desired_person              validate_proxy
                         001304 modes                       valid_proxy

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_2           mpfx2
signal_op           enable_op           shorten_stack       ext_entry           int_entry           index_bs_1_eis
divide_fx3          op_alloc_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absentee_utility_$timer_rang  aim_check_$equal              aim_check_$greater_or_equal
as_any_other_handler_$no_cleanup                            as_dump_                      as_meter_$enter
as_meter_$exit                available_slots_              convert_status_code_          date_time_
freen_                        get_system_free_area_         hcs_$add_acl_entries          hcs_$get_user_access_modes
hcs_$get_user_effmode         hcs_$initiate                 hcs_$make_seg                 hcs_$terminate_noname
hcs_$truncate_seg             hcs_$wakeup                   ioa_$rsnnl                    ipc_$create_ev_chn
ipc_$decl_ev_call_chn         ipc_$delete_ev_chn            ipc_$mask_ev_calls            ipc_$unmask_ev_calls
match_request_id_             match_star_name_              message_segment_$close        message_segment_$create
message_segment_$delete_index message_segment_$incremental_read_index                     message_segment_$ms_acl_add
message_segment_$open         message_segment_$read_index   message_segment_$update_message_index
parse_resource_desc_          rcp_sys_$cancel_id            request_id_                   resource_control_$reserve
send_mail_$access_class       sys_log_                      sys_log_$error_log            timer_manager_$alarm_wakeup
timer_manager_$reset_alarm_wakeup                           user_table_mgr_$reset

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
as_data_$abs_dim              as_data_$acsdir               as_data_$autp                 as_data_$rs_ptrs
as_data_$sysdir               as_data_$whoptr               as_error_table_$proj_max      error_table_$bad_segment
error_table_$device_limit_exceeded                          error_table_$messages_deferred
error_table_$messages_off     error_table_$no_e_permission  error_table_$no_message
error_table_$reservation_failed                             error_table_$resource_unknown sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2  105 001522    4   26 001524   18    3 001525   20   76 001527        56 001533       327 001552       328 001553
    329 001556       330 001565       331 001567       332 001570       333 001574       334 001577       335 001601
    336 001604       342 001626       345 001636       347 001650       348 001652       353 001655       354 001661
    355 001663       356 001665       357 001666       358 001671       360 001676       361 001702       363 001712
    366 001723       367 001727       369 001730       370 001733       372 002035       379 002123       380 002136
    381 002140       382 002143       383 002144       385 002153       387 002157       388 002160       389 002161
    390 002165       391 002166       394 002237       395 002240       398 002310       403 002317       405 002320
    407 002326       410 002341       412 002342       413 002343       415 002352       416 002354       418 002357
    420 002370       421 002371       423 002373       427 002400       428 002403       429 002412       435 002421
    437 002434       438 002435       439 002440       440 002444       441 002446       446 002455       448 002471
    451 002472       452 002475       453 002501       454 002503       459 002512       461 002523       463 002525
    465 002537       466 002540       467 002543       468 002544       471 002553       476 002566       477 002567
    478 002573       480 002576       482 002577       483 002601       484 002603       486 002653       490 002664
    491 002666       492 002672       497 002740       498 002742       499 002746       509 002752       510 002762
    511 003005       512 003011       514 003015       517 003022       521 003046       524 003047       534 003136
    536 003150       566 003161       567 003162       568 003165       570 003166       571 003172       572 003174
    573 003201       575 003203       576 003205       578 003207       579 003210       581 003225       583 003226
    585 003232       587 003235       590 003244       597 003256       598 003257       599 003262       601 003266
    602 003270       604 003274       606 003344       609 003356       611 003425       613 003434       615 003452
    616 003453       617 003454       619 003463       623 003473       625 003504       627 003540       630 003570
    631 003572       633 003637       635 003662       636 003664       638 003726       641 003727       642 003732
    643 003735       645 003740       649 003744       652 003747       654 003754       657 003756       658 004015
    659 004017       661 004061       665 004062       666 004112       667 004114       669 004156       672 004157
    675 004161       676 004173       678 004223       679 004225       680 004255       681 004257       683 004266
    684 004332       685 004337       686 004401       687 004440       688 004445       690 004504       691 004506
    694 004515       695 004520       696 004522       697 004523       698 004526       699 004527       700 004530
    701 004564       702 004566       704 004626       707 004630       708 004644       710 004647       712 004652
    714 004661       718 004673       719 004674       721 004700       723 004701       725 004703       726 004716
    727 004720       728 004723       729 004724       730 004725       731 004731       732 004732       735 004767
    737 004776       744 005007       746 005021       747 005022       748 005024       750 005036       752 005045
    754 005056       755 005057       756 005067       757 005072       758 005103       760 005150       762 005153
    764 005155       765 005156       766 005170       767 005175       768 005205       771 005250       773 005253
    775 005262       777 005273       780 005274       781 005277       782 005306       784 005311       787 005333
    791 005370       792 005373       793 005375       794 005403       795 005405       796 005406       798 005410
    799 005411       803 005431       804 005433       805 005435       806 005437       807 005441       808 005443
    809 005444       810 005445       811 005446       813 005464       815 005467       818 005502       820 005510
    821 005534       822 005543       823 005546       824 005555       829 005564       833 005565       835 005567
    836 005571       837 005572       838 005574       839 005576       840 005604       841 005611       843 005616
    845 005664       846 005670       848 005671       849 005672       851 005673       853 005674       858 005705
    862 005706       872 005717       873 005721       877 005732       880 005756       881 005761       882 005765
    884 006037       885 006045       888 006046       889 006116       892 006125       895 006131       899 006132
    904 006140       905 006147       906 006154       907 006161       908 006164       909 006173       912 006175
    923 006177       916 006202       925 006204       927 006205       929 006207       931 006211       934 006215
    935 006216       936 006221       937 006223       938 006224       939 006226       942 006227       944 006233
    945 006237       947 006301       949 006302       952 006310       953 006313       954 006316       955 006320
    956 006322       961 006325       962 006327       963 006331       964 006336       965 006337       969 006344
    970 006346       971 006351       972 006356       974 006357       975 006363       980 006370       985 006376
    987 006405       990 006417       992 006420      1001 006422      1004 006430      1008 006437      1012 006440
   1014 006444      1015 006446      1017 006447      1018 006451      1022 006456      1023 006463      1024 006470
   1032 006473      1037 006513      1038 006517      1045 006612      1049 006636      1051 006650      1052 006653
   1053 006654      1056 006655      1058 006664      1063 006666      1064 006717      1065 006723      1066 006725
   1068 006731      1070 006733      1073 006741      1074 006746      1076 006751      1077 006767      1078 007006
   1079 007062      1080 007074      1082 007112      1083 007117      1084 007130      1085 007141      1086 007157
   1087 007160      1089 007164      1095 007167      1099 007212      1103 007220      1104 007222      1105 007223
   1106 007225      1107 007227      1108 007231      1109 007235      1110 007240      1112 007241      1118 007254
   1119 007263      1120 007273      1122 007356      1126 007360      1127 007371      1133 007455      1134 007464
   1137 007476      1139 007503      1144 007515      1145 007520      1147 007570      1148 007574      1149 007576
   1150 007600      1152 007647      1154 007653      1156 007656      1157 007660      1163 007662      1164 007664
   1165 007667      1166 007672      1167 007673      1168 007677      1169 007700      1170 007706      1171 007707
   1172 007714      1173 007715      1174 007727      1175 007730      1176 007734      1177 007735      1178 007742
   1179 007743      1180 007746      1182 007756      1183 007761      1184 007763      1185 007764      1186 007765
   1187 007766      1188 007773      1189 007774      1190 007777      1191 010003      1192 010004      1194 010010
   1197 010011      1201 010114      1209 010120      1213 010121      1214 010123      1215 010125      1216 010126
   1219 010127      1223 010232      1224 010233      1227 010244      1228 010246      1229 010251      1232 010252
   1234 010256      1238 010257      1240 010260      1241 010263      1242 010265      1243 010266      1244 010272
   1246 010300      1247 010302      1248 010304      1252 010305      1257 010306      1258 010311      1259 010314
   1260 010315      1264 010336      1265 010337      1267 010353      1274 010362      1276 010365      1278 010374
   1284 010400      1287 010407      1288 010411      1290 010417      1292 010430      1294 010434      1298 010435
   1305 010436      1307 010450      1309 010457      1311 010466      1315 010473      1316 010474      1317 010475
   1318 010476      1320 010500      1324 010501      1330 010502      1332 010514      1334 010520      1336 010527
   1340 010531      1341 010532      1342 010533      1343 010535      1345 010537      1349 010540      1356 010541
   1358 010553      1360 010557      1362 010566      1366 010570      1367 010572      1370 010574      1374 010575
   1382 010577      1383 010601      1384 010605      1385 010614      1386 010630      1387 010637      1388 010645
   1389 010646      1393 010647      1400 010650      1402 010662      1404 010671      1406 010700      1408 010705
   1413 010716      1414 010717      1415 010720      1416 010722      1417 010725      1418 010730      1419 010734
   1420 010736      1421 010740      1423 010742      1427 010744      1429 010750      1433 010751      1440 010752
   1442 010764      1444 010773      1446 011002      1448 011007      1453 011020      1454 011023      1455 011025
   1456 011027      1458 011031      1462 011032      1474 011034      1476 011037      1478 011047      1480 011050
   1482 011055      1486 011101      1487 011102      1489 011120      1491 011127      1492 011131      1493 011136
   1494 011140      1495 011153      1496 011154      1498 011163      1501 011165      1503 011166      1507 011167
   1540 011171      1542 011172      1544 011175      1545 011202      1546 011203      1548 011204      1550 011213
   1551 011221      1552 011223      1553 011224      1554 011230      1555 011243      1558 011254      1559 011260
   1560 011262      1566 011264      1567 011270      1573 011277      1574 011300      1575 011314      1578 011323
   1579 011325      1580 011327      1584 011331      1585 011332      1587 011347      1589 011352      1590 011360
   1594 011361      1598 011362      1601 011377      1607 011400      1629 011402      1630 011410      1632 011417
   1634 011426      1636 011430      1637 011431      1638 011433      1639 011442      1640 011454      1641 011457
   1642 011461      1643 011462      1645 011464      1647 011465      1651 011466      1663 011470      1665 011476
   1668 011506      1669 011521      1670 011525      1671 011526      1673 011532      1675 011536      1676 011547
   1677 011552      1678 011554      1680 011555      1683 011560      1685 011564      1686 011571      1687 011573
   1690 011574      1696 011600      1698 011606      1700 011621      1704 011622      1705 011630      1706 011643
   1708 011657      1712 011660      1720 011703      1721 011742      1723 011752      1726 011777      1740 012001
   1742 012002      1743 012005      1744 012013      1748 012020      1749 012023      1750 012032      1754 012037
   1757 012051      1761 012052      1765 012053      1767 012056      1770 012066      1772 012131      1775 012132
   1779 012133      1796 012135      1798 012136      1802 012144      1805 012155      1808 012164      1813 012172
   1818 012210      1819 012211      1821 012225      1823 012234      1826 012237      1828 012245      1832 012251
   1837 012267      1840 012340      1841 012345      1843 012400      1844 012401      1847 012402      1848 012435
   1849 012436      1850 012452      1851 012454      1852 012515      1854 012516      1855 012522      1856 012524
   1859 012525      1863 012527      1867 012531      1868 012534      1869 012540      1870 012541      1872 012550
   1876 012551      1891 012553      1892 012555      1893 012557      1895 012564      1899 012565      1903 012566
   1905 012567      1908 012600      1910 012606      1912 012617      1914 012700      1915 012701      1918 012710
   1922 012711      1926 012712      1927 012713      1928 012715      1929 012730      1930 012773      1932 012774
   1935 013023      1936 013031      1937 013033      1938 013065      1940 013077      1942 013101      1946 013123
   1947 013126      1948 013143      1949 013146      1951 013147      1955 013161      1958 013176      1962 013277
   1964 013300      1968 013301      1986 013303      1987 013305      1988 013311      1989 013320      1992 013352
   1994 013376      1995 013405      1997 013431      1999 013432      2003 013433      2023 013435      2026 013443
   2030 013452      2034 013453      2035 013463      2036 013466      2037 013467      2041 013470      2054 013471
   2055 013501      2056 013527      2059 013530      2064 013535      2065 013540      2069 013543      2074 013544
   2076 013550      2080 013551      2084 013553      2085 013560      2086 013627      2087 013631      2090 013720
   2091 013723      2093 013744      2094 013746      2098 013760      2103 014070      2104 014074      2107 014100
   2110 014101      2111 014105      2114 014111      2115 014112      2116 014116      2118 014117      2120 014122
   2124 014125      2133 014126      2134 014130      2135 014133      2136 014142      2138 014161      2139 014170
   2140 014176      2142 014177      2146 014200      2151 014202      2159 014203      2160 014206      2161 014212
   2162 014213      2163 014215      2164 014216      2165 014220      2167 014221      2168 014223      2173 014225
   2174 014233      2175 014234      2176 014236      2177 014242      2179 014246      2180 014250      2181 014252
   2185 014254      2187 014260      2190 014267      2191 014273      2192 014360      2194 014363      2195 014366
   2196 014373      2197 014404      2198 014407      2201 014427      2202 014433      2203 014460      2204 014463
   2210 014470      2214 014523      2217 014536      2218 014543      2219 014573      2222 014575      2223 014600
   2224 014662      2229 014665      2230 014671      2231 014672      2232 014675      2233 014677      2235 014701
   2239 014702      2240 014704      2243 014712      2244 014716      2245 014717      2246 014723      2247 014725
   2248 014733      2249 014740      2250 014744      2252 014745      2254 014746      2255 014750      2257 014757
   2258 014760      2259 014761      2260 014763      2261 014765      2262 014766      2263 014770      2264 014771
   2269 014772      2272 014773      2275 014777      2276 015000      2280 015002      2281 015006      2284 015057
   2285 015063      2286 015066      2289 015070      2292 015071      2293 015074      2294 015076      2295 015101
   2296 015103      2297 015105      2299 015111      2302 015113      2306 015157      2309 015161      2313 015162
   2320 015164      2324 015170      2327 015171      2329 015174      2330 015200      2331 015202      2335 015205
   2336 015206      2340 015230      2341 015231      2343 015246      2345 015255      2346 015257      2347 015261
   2350 015266      2354 015267      2359 015270      2360 015275      2361 015277      2362 015316      2366 015371
   2370 015372      2374 015373      2375 015376      2376 015400      2377 015402      2378 015404      2379 015407
   2381 015505      2387 015550      2391 015551      2399 015553      2400 015557      2401 015560      2405 015561
   2407 015563      2409 015565      2413 015573      2415 015604      2416 015610      2419 015644      2420 015650
   2421 015651      2422 015653      2423 015670      2426 015673      2430 015674      2434 015675      2438 015706
   2439 015707      2440 015736      2444 015756      2445 015760      2448 015771      2453 016036      2454 016040
   2455 016042      2456 016043      2460 016045      2464 016046      2466 016047      2467 016057      2468 016064
   2469 016066      2470 016067      2471 016103      2472 016127      2476 016131      2481 016132      2482 016135
   2484 016140      2485 016141      2487 016147      2489 016155      2490 016162      2492 016167      2496 016170
   2501 016171      2502 016174      2506 016177      2507 016203      2511 016204      2513 016213      2515 016215
   2517 016217      2521 016220      2527 016221      2528 016224      2530 016226      2531 016231      2535 016237
   2537 016241      2539 016244      2544 016261      2545 016263      2546 016270      2547 016275      2549 016276
   2550 016304      2555 016311      2557 016320      2561 016325      2562 016327      2563 016334      2575 016341
   2577 016343      2578 016347      2581 016355      2586 016374      2589 016403      2593 016407      2597 016410
   2610 016411      2614 016412      2617 016425      2621 016430      2622 016431      2623 016434      2627 016451
   2628 016454      2629 016455      2631 016471      2633 016472      2636 016475      2640 016476      2649 016477
   2650 016516      2651 016557      2653 016605      2655 016612      2657 016662      2658 016666      2660 016667
   2661 016673      2663 016676      2664 016702      2665 016706      2694 016710      2667 016711      2679 016713
   2683 016754      2686 016767      2691 016772      2696 016777      2700 017000      2701 017004      2702 017006
   2703 017010      2704 017011      2705 017012      2706 017022


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
