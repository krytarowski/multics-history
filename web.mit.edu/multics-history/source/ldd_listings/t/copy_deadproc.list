	COMPILATION LISTING OF SEGMENT copy_deadproc
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/12/88  1432.9 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 copy_deadproc: 	proc();
       10 
       11 /* format: off */
       12 
       13 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       14 /*							       */
       15 /* This is a tool to copy dead processes from the >pdd to >dumps>save_pdirs  */
       16 /* directory.						       */
       17 /*							       */
       18 /* Status:						       */
       19 /*							       */
       20 /* 0) Created:     June 1984 by B. Braun			       */
       21 /* 1) Modified:    06 Dec 84 by B. Braun to not set system_privileges when   */
       22 /* 			 getting the access class of the source dir    */
       23 /*			 fails.  Print better error message when       */
       24 /*			 deleting the source dir fails.	       */
       25 /* 2) Modified: 23 Jan 85 by B. Braun to set the 256K switch.	       */
       26 /*							       */
       27 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       28 
       29 /****^  HISTORY COMMENTS:
       30*  1) change(87-07-09,Parisek), approve(87-07-09,MCR7746),
       31*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
       32*     Add the no_copy_delete control functionality.
       33*  2) change(87-07-18,GDixon), approve(88-03-09,MCR7861),
       34*     audit(88-07-08,Farley), install(88-07-12,MR12.2-1055):
       35*      A) Add copy_liveproc command.
       36*      B) Correct problem in cleanup.
       37*  3) change(87-10-26,GDixon), approve(88-03-09,MCR7861),
       38*     audit(88-07-08,Farley), install(88-07-12,MR12.2-1055):
       39*      A) Fix bug in determine_hphcs_need internal subroutine.
       40*                                                   END HISTORY COMMENTS */
       41 
       42 /* External entries */
       43 
       44 dcl aim_check_$equal		entry (bit(72) aligned, bit(72) aligned) returns(bit(1) aligned);
       45 dcl check_gate_access_		entry (char(*), ptr, fixed bin(35));
       46 dcl com_err_			entry() options(variable);
       47 dcl command_query_$yes_no		entry() options(variable);
       48 dcl copy_pdir_$deadproc		entry (char(*), char(*), char(*), char(*), char(*), char(*), bit(1),
       49 				        fixed bin(35));
       50 dcl copy_pdir_$delete		entry (char(*), char(*), char(*), fixed bin(35));
       51 dcl copy_pdir_$liveproc		entry (char(*), char(*), char(*), char(*), char(*), char(*), bit(1),
       52 				        char(*), fixed bin(35));
       53 dcl cu_$arg_count			entry (fixed bin, fixed bin(35));
       54 dcl cu_$arg_ptr			entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
       55 dcl expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35));
       56 dcl get_authorization_		entry returns (bit (72));
       57 dcl get_privileges_			entry() returns(bit(36) aligned);
       58 dcl hcs_$get_access_class		entry (char(*), char(*), bit(72) aligned, fixed bin(35));
       59 dcl hcs_$get_user_effmode       	entry (char(*), char(*), char(*), fixed bin, fixed bin(5), fixed bin(35));
       60 dcl hcs_$set_256K_switch		entry (bit(2) aligned, bit(2) aligned, fixed bin(35));
       61 dcl hcs_$status_minf		entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
       62 dcl pathname_			entry (char(*), char(*)) returns(char(168));
       63 dcl system_privilege_$dir_priv_off	entry (fixed bin(35));
       64 dcl system_privilege_$dir_priv_on	entry (fixed bin(35));
       65 dcl system_privilege_$seg_priv_off	entry (fixed bin(35));
       66 dcl system_privilege_$seg_priv_on	entry (fixed bin(35));
       67 dcl upd_free_name_$retain_suffix	entry (char(*), char(*), char(*), fixed bin(35));
       68 dcl upd_free_name_$restore_with_suffix	entry (char(*), char(*), char(*), fixed bin(35));
       69 
       70 dcl (
       71      error_table_$action_not_performed,
       72      error_table_$badopt,
       73      error_table_$incorrect_access,
       74      error_table_$moderr,
       75      error_table_$no_m_permission,
       76      error_table_$no_s_permission,
       77      error_table_$noarg,
       78      error_table_$noentry,
       79      error_table_$notadir
       80      )		fixed bin(35) ext static;
       81 
       82 /* options constant variables */
       83 
       84 dcl (
       85      DEFAULT_DIR                        char(5) init(">pdd>"),
       86      DIR_TYPE			fixed bin(2) init(2),
       87      FALSE			bit (1) init ("0"b),
       88      PDIR_PATH			char(17) init(">dumps>save_pdirs"),
       89      PDIR_SUFFIX			char(4) init ("pdir"),
       90      TRUE				bit (1) init ("1"b)
       91      )				int static options(constant);
       92 
       93 /* Builtins */
       94 
       95 dcl (addr, before, index, null,
       96      rtrim, search, substr)		builtin;
       97 
       98 /* Condition handlers */
       99 
      100 dcl cleanup			condition;
      101 
      102 /* Based variables */
      103 
      104 dcl arg				char (al) based (ap);
      105 dcl dir_str			char(dir_len) based(dir_ptr);
      106 dcl name_str			char(name_len) based(name_ptr);
      107 dcl 1 privileges			like aim_privileges  based (addr(priv_string));
      108 
      109 /* Automatic */
      110 
      111 dcl al				fixed bin(21);
      112 dcl ap				ptr;
      113 dcl argno				fixed bin;
      114 dcl caller_access_class		bit(72) aligned;
      115 dcl code				fixed bin (35);
      116 dcl delete_sw			bit(1);
      117 dcl deadproc			bit(1);
      118 dcl dir_len			fixed bin(21);
      119 dcl dir_ptr			ptr;
      120 dcl dirname			char(168);
      121 dcl ename				char(32);
      122 dcl ignore			fixed bin(24);
      123 dcl ignore_code			fixed bin(35);
      124 dcl mode				fixed bin(5);
      125 dcl myname			char(13);
      126 dcl name_sw			bit(1);
      127 dcl nargs				fixed bin;
      128 dcl name_len			fixed bin(21);
      129 dcl name_ptr			ptr;
      130 dcl ncd_sw		          bit(1);
      131 dcl need_hphcs			bit(1);
      132 dcl need_priv			bit(1);
      133 dcl no_chase                            fixed bin(1);
      134 dcl old_256k_sw			bit(2) aligned;
      135 dcl owner_sw			bit(1);
      136 dcl parent_access			bit(1);
      137 dcl parent_access_class		bit (72) aligned;    
      138 dcl person_proj			char(32);
      139 dcl pdir_access_class		bit (72) aligned;    
      140 dcl pdir_path			char(168);
      141 dcl pdir_to_create			char(32);
      142 dcl priv_string			bit(36) aligned;
      143 dcl privileges_are_set		bit(1);
      144 dcl restore_names			bit(1);
      145 dcl target_dir			char(168);
      146 dcl target_dirname			char(168);
      147 dcl target_parent			char(168);
      148 dcl tdirname                            char(168);
      149 dcl tename                              char(32);
      150 dcl type				fixed bin(2);
      151 dcl yes_sw bit(1);
      152 
      153     deadproc = TRUE;
      154     myname =  "copy_deadproc";
      155     go to COMMON;
      156 
      157 copy_liveproc:
      158     entry;
      159 
      160     deadproc = FALSE;
      161     myname = "copy_liveproc";
      162     go to COMMON;
      163     
      164 COMMON:
      165     delete_sw, name_sw, ncd_sw, old_256k_sw, owner_sw,
      166        need_hphcs, need_priv, restore_names,
      167        parent_access, privileges_are_set = FALSE;
      168     target_dir =  PDIR_PATH;
      169     name_ptr, dir_ptr = null();
      170     code = 0;
      171     no_chase = 0;
      172 
      173     on cleanup begin;
      174        call clean_up();
      175        end;
      176 	
      177     call cu_$arg_count(nargs, code);
      178     if code ^= 0 then do;
      179        call com_err_(code,myname);
      180        goto EXIT;
      181        end;
      182 
      183     if nargs = 0 then
      184        if deadproc then
      185 	call argument_error (error_table_$noarg,
      186 	"^/A process directory name must be provided.^/^a",
      187 	"Usage: copy_deadproc {deadproc_name} {-ctl_args}", "");
      188        else
      189 	call argument_error (error_table_$noarg,
      190 	"^/A process directory name and user name must be provided.^/^a",
      191 	"Usage: copy_liveproc {live_pdir_name} {user_name} {-ctl_args}", "");
      192 
      193     do argno = 1 to nargs;				/* process args  */
      194        call cu_$arg_ptr(argno, ap, al, (0));
      195 
      196        if deadproc & (arg = "-delete" | arg = "-dl") then delete_sw = TRUE;
      197        else if deadproc & (arg = "-no_delete" | arg = "-ndl") then
      198 	delete_sw = FALSE;
      199        else if deadproc & (arg = "-no_copy_delete" | arg = "-ncd") then
      200 	ncd_sw = TRUE;
      201        else if arg = "-owner" | arg = "-ow" then owner_sw = TRUE;
      202        else if ^deadproc & (arg = "-directory" | arg = "-dir" | arg = "-dr") then do;
      203 	if dir_ptr ^= null then
      204 	   call argument_error (0,
      205 	   "More than one directory was specified. ^a, ^a", dir_str, arg);
      206 	call get_next_arg ("directory name", dir_ptr, dir_len);
      207 	end;
      208        else if arg = "-name" | arg = "-nm" then do;
      209           if name_ptr ^= null() then
      210 	   call argument_error (0, "More than one name is specified. ^a, ^a",
      211 	   name_str, arg);
      212 	if deadproc then
      213 	   call get_next_arg ("deadproc name", name_ptr, name_len);
      214 	else
      215 	   call get_next_arg ("user name", name_ptr, name_len);
      216 	end;
      217        else if substr(arg, 1, 1) ^= "-" then do;		/* assume either */
      218 	if ^deadproc & dir_ptr = null then do;		/*  pdir pathname */
      219 	   dir_len = al;
      220 	   dir_ptr = ap;
      221 	   end;
      222 	else if name_ptr = null() then do;		/*  or deadproc  */
      223 	   name_len = al;				/*  or user name */
      224 	   name_ptr = ap;
      225 	   end;
      226 	else call argument_error (0,
      227 	   "More than one name is specified. ^a, ^a", name_str, arg);
      228 	end;
      229        else call argument_error(error_table_$badopt, " ^a",arg, "");
      230        end;					/* end args loop */
      231 
      232     if deadproc then do;
      233        if name_ptr = null() then
      234 	call argument_error(error_table_$noarg, "A deadproc name must be specified.", "", "");
      235 
      236        if search(name_str, "<>") = 0 then
      237 	pdir_path = DEFAULT_DIR || name_str;   /* process_dir_dir is the default */
      238        else  pdir_path = name_str;
      239        end;
      240     else do;
      241        if dir_ptr = null() then
      242 	call argument_error(error_table_$noarg, "A liveproc directory name must be specified.", "", "");
      243        if name_ptr = null() then
      244 	call argument_error(error_table_$noarg, "A user name must be specified.", "", "");
      245        if search(dir_str, "<>") = 0 then
      246 	pdir_path = DEFAULT_DIR || dir_str;   /* process_dir_dir is the default */
      247        else  pdir_path = dir_str;
      248        end;
      249 
      250     /* need access to phcs_ */
      251     call check_gate_access_ ("phcs_", null(), code);
      252     if code ^= 0 then do;
      253        if code = error_table_$noentry then call report_error(code, "Checking access to the phcs_ gate.", "", "");
      254        else if code = error_table_$moderr then call report_error(code, 
      255 		  "Execute access is required on the phcs_ gate.", "", "");
      256        end;
      257 
      258     /* does the pdir specified exist? */
      259 
      260     call expand_pathname_ (pdir_path, dirname, ename, code);
      261     if code  ^= 0 then call report_error(code, "^a", pathname_(dirname, ename), "");
      262     
      263     /* get access class of source pdir */
      264     call hcs_$get_access_class (dirname, ename, pdir_access_class, code);
      265     if code ^= 0 then call report_error(code, "^a", pathname_(dirname, ename), "");
      266 
      267     caller_access_class = get_authorization_ ();		/*  get the access_class of the process */
      268 
      269     if aim_check_$equal (caller_access_class, pdir_access_class) then;  /* dont need privileges */
      270     else do;   /* need privileges */
      271        if ^(privileges_are_set) then call set_privileges(code);
      272        if code ^= 0 then do;
      273           if code = error_table_$noentry then 
      274 	   call report_error(code, "Checking access to the system_privilege_ gate.", "", "");
      275           else if code = error_table_$moderr then
      276 	   call report_error(code, "Execute access is required on the system_privilege_ gate.", "", "");
      277           else call report_error(code, "^a", pathname_(dirname, ename), "");
      278 	end;
      279        parent_access = TRUE;
      280        end;
      281   
      282     /*  If -owner is specified, then the pdir can only be copied if the access class of the   */
      283     /*  source pdir is equal to the target parent dir.				    */
      284 
      285     if owner_sw then do;
      286        call expand_pathname_ (target_dir, target_dirname, target_parent, code);
      287        if code  ^= 0 then call report_error(code, "^a", pathname_(target_dirname, target_parent), "");
      288 						/* get access class of parent of target dir */
      289        call hcs_$get_access_class (target_dirname, target_parent, parent_access_class, code);
      290        if code ^= 0  then call report_error(code, "^a", pathname_(target_dirname, target_parent), "");
      291 
      292        if pdir_access_class ^= parent_access_class then call report_error (error_table_$action_not_performed, 
      293           "^/When -owner is used, the access class of pdir ^a must equal the access class of the target directory ^a.", 
      294 	 pathname_(dirname, ename), pathname_(target_dirname, target_parent));
      295        end;
      296 
      297     call hcs_$status_minf (dirname, ename, no_chase, type, ignore, code);
      298     if code ^= 0 then call report_error(code, "^a", pathname_(dirname, ename), "");
      299     if type ^= DIR_TYPE then call report_error(error_table_$notadir, "^a", pathname_(dirname, ename), "");
      300     
      301     /* determine access of the pdir to be copied */
      302 
      303     call hcs_$get_user_effmode (dirname, ename, "", -1, mode, code);
      304     if code ^= 0 then  call report_error(code, "^a", pathname_(dirname, ename), "");
      305     if mode ^= SMA_ACCESS_BIN & mode ^= SM_ACCESS_BIN then call report_error(error_table_$moderr, 
      306 			"SM access is required on ^a", pathname_(dirname, ename), "");
      307 
      308     if delete_sw | ncd_sw then do;
      309        /* to delete user needs SM on containing dir */
      310 
      311        call expand_pathname_ (dirname, tdirname, tename, code);
      312        if code  ^= 0 then call report_error(code, "^a", dirname, "");
      313 
      314        call hcs_$get_user_effmode (tdirname, tename, "", -1, mode, code);
      315        if code ^= 0 then  call report_error(code, "^a", dirname, "");
      316 
      317        if mode ^= SMA_ACCESS_BIN & mode ^= SM_ACCESS_BIN then do;
      318 	/* query the user to continue */
      319 	if mode = S_ACCESS_BIN then code = error_table_$no_m_permission;
      320 	else if mode = M_ACCESS_BIN then code = error_table_$no_s_permission;
      321 	else  code = error_table_$incorrect_access; 
      322 
      323 	if ncd_sw then 
      324 	   call report_error (error_table_$incorrect_access,
      325 	      "Modify access is needed on containing dir ^a to delete ^a.",
      326 	      dirname, pathname_(dirname, ename));
      327 
      328 	if delete_sw then call command_query_$yes_no (yes_sw, code, myname, 
      329 "In order to delete the pdir ^a, Modify access is needed on the containing dir ^a.  If you continue, the pdir will be copied but not deleted.", 
      330              "The directory ^a can be copied but not deleted. Do you wish to continue?",
      331              pathname_(dirname, ename), dirname);
      332           if ^(yes_sw) then
      333 	   call report_error(error_table_$action_not_performed,
      334 	   "Copying ^a.", ename, "");
      335           delete_sw = FALSE;				/* continue and  */
      336 	end;					/* dont delete   */
      337        end;
      338 
      339     if deadproc					/* get target dir*/
      340     then call construct_names_from_pdir (ename, pdir_to_create, person_proj);
      341     else do;
      342        pdir_to_create = rtrim(name_str) || "." || PDIR_SUFFIX;
      343        person_proj = name_str;
      344        end;
      345 
      346     if ^ncd_sw then do;
      347        need_hphcs = determine_hphcs_need(dirname, ename, person_proj);
      348        if need_hphcs then do;
      349 	/* To copy the user needs "re" to hphcs_ gate. */
      350 	call check_gate_access_ ("hphcs_", null(), code);
      351 	if code ^= 0 then do;
      352 	   if code = error_table_$noentry then
      353 	      call report_error(code, "Checking access to the hphcs_ gate.",
      354 	      "", "");
      355 	   else if code = error_table_$moderr then
      356 	      call report_error(code,
      357 	      "Execute access is required on the hphcs_ gate.", "", "");
      358 	   end;
      359 	 end;
      360 
      361        if ^deadproc & owner_sw then;
      362        else if owner_sw then do;
      363 	if (person_proj = ename) then
      364 	   call report_error(error_table_$action_not_performed, 
      365 	   "Cannot construct person.project from name given ^a.", ename, "");
      366 	end;
      367        else person_proj = "";				/* only need     */
      368 						/* person.project*/
      369 						/* if owner given*/
      370 
      371 						/* target dir    */
      372 						/* exist already?*/
      373        call hcs_$status_minf (target_dir, pdir_to_create, no_chase, type, ignore,
      374 	code);
      375        if code = 0 then do;				/* yes, rename it*/
      376 	restore_names = TRUE;
      377 	call upd_free_name_$retain_suffix (target_dir, pdir_to_create,
      378 	   "pdir", code);
      379 	if code ^= 0 then
      380 	   call report_error(code, "While renaming the pdir directory ^a", 
      381 	   pathname_(target_dir, pdir_to_create), "");
      382 	end;
      383 
      384 						/* set 256K sw   */
      385 						/* just in case  */
      386        call hcs_$set_256K_switch ( "11"b, old_256k_sw, code);
      387        if code ^= 0 then call com_err_(myname, code, "Warning, unable to set the 256K switch...continuing copying.");
      388 
      389        if deadproc					/* copy the pdir */
      390        then call copy_pdir_$deadproc (myname, dirname, ename,  target_dir, pdir_to_create, person_proj, need_hphcs, code);
      391        else call copy_pdir_$liveproc (myname, dirname, ename,  target_dir, pdir_to_create, person_proj, need_hphcs,
      392 	before(name_str,"."), code);
      393        if code ^= 0 then call report_error(code, "While copying ^a to ^a.",
      394 	pathname_(dirname, ename), pathname_(target_dir, pdir_to_create));
      395 
      396        restore_names = FALSE;    /* successful copy, dont restore */
      397        end;
      398 
      399     if delete_sw | ncd_sw then do;
      400        call copy_pdir_$delete (myname, dirname, ename, code);
      401        if code ^= 0 then
      402 	call report_error(code, "Deleting ^a.", pathname_(dirname, ename),
      403 	"");
      404        end;
      405 
      406 END_COPY:
      407     call clean_up();
      408 
      409 EXIT:
      410     return;
      411 
      412 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      413 /*							       */
      414 /* Reports error messages pertaining to argument processing and aborts the   */
      415 /* command.						       */
      416 /*							       */
      417 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      418 
      419 argument_error: proc(ecode, message, str1, str2);
      420 
      421 dcl ecode				fixed bin(35),
      422     (message, str1, str2)		char(*);
      423  
      424    call com_err_(ecode, myname, message, str1, str2);
      425    goto EXIT;   
      426 
      427 end argument_error;
      428 
      429 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      430 
      431 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      432 
      433 
      434 clean_up:	proc();
      435 
      436 dcl code fixed bin(35);
      437 
      438     code = 0;
      439     if restore_names then
      440        call upd_free_name_$restore_with_suffix (target_dir, pdir_to_create,
      441        "pdir", ignore_code);
      442     restore_names = FALSE;
      443     if privileges_are_set then do;
      444        if ^(privileges.dir) then call system_privilege_$dir_priv_off (ignore_code);
      445        if ^(privileges.seg) then call system_privilege_$seg_priv_off (ignore_code);
      446        end;
      447     call hcs_$set_256K_switch (old_256k_sw, (""b), ignore_code);   
      448 
      449 end clean_up;
      450 
      451 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      452 
      453 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      454 /*							       */
      455 /* Attempts to construct the person.pdir name for the target pdir name and   */
      456 /* the person.project for the owner acl.			       */
      457 /*							       */
      458 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      459 
      460 construct_names_from_pdir:  proc (old_name, new_name, acl_name);
      461 
      462 dcl acl_name char(*);
      463 dcl new_name char(*);
      464 dcl old_name char(*);
      465 
      466 dcl temp_name char(32) var;
      467 dcl temp_idx fixed bin;
      468 
      469 /* old_name is assumed to be at the very least person.project */
      470 
      471     acl_name, new_name = "";
      472     temp_name = rtrim(old_name);
      473 
      474     temp_idx = index(old_name, ".");
      475     if temp_idx ^= 0 then new_name = substr(temp_name, 1, temp_idx-1);
      476     else  /* doesn't appear to be a person.project */
      477        new_name = old_name;   /* return as is */
      478 
      479     new_name = rtrim(new_name) || "." || PDIR_SUFFIX;
      480 
      481 /* To construct person.project, the old name is assumed to be of the form person.project.f.channel */
      482 
      483     temp_idx = index(temp_name, ".f.");
      484     if temp_idx ^= 0 then acl_name = substr(temp_name, 1, temp_idx-1);
      485     else  /* doesn't appear to be a person.project.f.chnl */
      486        acl_name = old_name;   /* return as is */
      487 
      488 end construct_names_from_pdir;
      489 
      490 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      491 
      492 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      493 
      494 
      495 determine_hphcs_need: proc(dirname, ename, person_proj) returns(bit(1));
      496 		  
      497 dcl dirname char(168);
      498 dcl ename char(32);
      499 dcl person_proj char(32);
      500 
      501 dcl code fixed bin(35);
      502 dcl userid char(32);
      503 dcl get_group_id_		entry() returns(char(32));
      504 dcl get_group_id_$tag_star	entry() returns(char(32));
      505 
      506     userid = get_group_id_$tag_star();
      507     if person_proj = substr(userid, 1, index(userid, ".*")-1)
      508     then return("0"b);
      509     else do;
      510        call hcs_$get_user_effmode (dirname, ename, get_group_id_(),
      511 	-1, mode, code);
      512        if code ^= 0 then  call report_error(code, "^a", dirname, "");
      513        if mode = SMA_ACCESS_BIN
      514        then do;
      515 	call hcs_$get_user_effmode (pathname_ (dirname, ename),
      516 	   "pit", get_group_id_(), -1, mode, code);
      517 	if mode = REW_ACCESS_BIN then
      518 	return ("0"b);
      519 	else return ("1"b);
      520 	end;
      521        else return("1"b);
      522        end;
      523 
      524 end determine_hphcs_need;
      525 
      526 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      527 
      528 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      529 /*							       */
      530 /* This guy gets the next argument from the argument string, complaining     */
      531 /* if it's not there.					       */
      532 /*							       */
      533 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      534 
      535 get_next_arg: proc(arg_expected, ap1, al1);
      536 
      537 dcl arg_expected			char(*);
      538 dcl (ap1				ptr,
      539      al1				fixed bin(21),
      540      code                               fixed bin(35));
      541 	    
      542     argno = argno + 1;
      543     if argno > nargs then do;
      544        call argument_error(error_table_$noarg, "A ^a expected after ^a.", arg_expected, arg);
      545        return;
      546        end;
      547 
      548     call cu_$arg_ptr (argno, ap1, al1, code);
      549     if code ^= 0 then call argument_error(code, "get_next_arg", "", "");
      550      
      551 end get_next_arg;
      552 
      553 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      554 
      555 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      556 /*							       */
      557 /* reports error messages and aborts the line.			       */
      558 /*							       */
      559 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      560 
      561 report_error: proc(ecode, message, str1, str2);
      562 
      563 dcl ecode				fixed bin(35),
      564     (message, str1, str2)		char(*);
      565  
      566    call com_err_(ecode, myname, message, str1, str2);
      567    goto END_COPY;
      568 
      569 end report_error;
      570 
      571 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      572 
      573 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      574 
      575 
      576 set_privileges:  proc(code);
      577 
      578 dcl code fixed bin(35);
      579 	       
      580     code = 0;
      581     priv_string =  get_privileges_();
      582 
      583     /* first make sure they have re to system_privileges_ gate */
      584     call check_gate_access_ ("system_privilege_", null(), code);
      585     if code ^= 0 then return;
      586 
      587     if privileges.dir then;   /* caller already has it on */
      588     else call system_privilege_$dir_priv_on (code);
      589     if privileges.seg then;   /* caller already has it on */
      590     else call system_privilege_$seg_priv_on (code);
      591     
      592     privileges_are_set = "1"b;
      593 
      594 end set_privileges;
      595 
      596 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      597 
  2     1 /* Begin include file aim_privileges.incl.pl1  BIM 831206 */
  2     2 /* format: style3 */
  2     3 
  2     4 declare	aim_privileges_ptr	pointer;
  2     5 declare	1 aim_privileges	unaligned based (aim_privileges_ptr),
  2     6 	( 2 ipc,					/** interprocess communication privilege */
  2     7 	  2 dir,					/** directory privilege */
  2     8 	  2 seg,					/** segment privilege */
  2     9 	  2 soos,					/** security out-of-service privilege */
  2    10 	  2 ring1,				/** ring 1 access privilege */
  2    11 	  2 rcp,					/** RCP resource access privilege */
  2    12 	  2 comm					/** communications cross-AIM privilege */
  2    13 	  )		bit (1),
  2    14 	  2 pad		bit (29);
  2    15 
  2    16 declare	(
  2    17 	IPC_PRIVILEGE	init ("1"b),
  2    18 	DIR_PRIVILEGE	init ("01"b),
  2    19 	SEG_PRIVILEGE	init ("001"b),
  2    20 	SOOS_PRIVILEGE	init ("0001"b),
  2    21 	RING1_PRIVILEGE	init ("00001"b),
  2    22 	RCP_PRIVILEGE	init ("000001"b),
  2    23 	COMM_PRIVILEGE	init ("0000001"b),
  2    24 	ALL_PRIVILEGES	init ("1111111"b)
  2    25 	)		bit (36) int static aligned options (constant);
  2    26 
  2    27 
  2    28 /* End include file aim_privileges.incl.pl1 */
      598 
      599 
      600 end copy_deadproc;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/12/88  1432.9  copy_deadproc.pl1                 >spec>install>1055>copy_deadproc.pl1
597          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
598          2    08/19/84  1445.6  aim_privileges.incl.pl1           >ldd>include>aim_privileges.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEFAULT_DIR                     000006 constant        char(5)                  initial packed unaligned dcl 84 ref 236 245
DIR_TYPE                               constant        fixed bin(2,0)           initial dcl 84 ref 299
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 84 ref 160 164 197 335
                                                                                  396 442
M_ACCESS_BIN                           constant        fixed bin(5,0)           initial dcl 1-36 ref 320
PDIR_PATH                       000000 constant        char(17)                 initial packed unaligned dcl 84 ref 168
PDIR_SUFFIX                     000022 constant        char(4)                  initial packed unaligned dcl 84 ref 342 479
REW_ACCESS_BIN                         constant        fixed bin(5,0)           initial dcl 1-36 ref 517
SMA_ACCESS_BIN                         constant        fixed bin(5,0)           initial dcl 1-36 ref 305 317 513
SM_ACCESS_BIN                          constant        fixed bin(5,0)           initial dcl 1-36 ref 305 317
S_ACCESS_BIN                           constant        fixed bin(5,0)           initial dcl 1-36 ref 319
TRUE                                   constant        bit(1)                   initial packed unaligned dcl 84 ref 153 196 199 201
                                                                                  279 376
acl_name                               parameter       char                     packed unaligned dcl 462 set ref 460 471* 484* 485*
addr                                                   builtin function         dcl 95 ref 444 445 587 589
aim_check_$equal                000010 constant        entry                    external dcl 44 ref 269
aim_privileges                         based           structure                level 1 packed packed unaligned dcl 2-5
al                              000106 automatic       fixed bin(21,0)          dcl 111 set ref 194* 196 196 197 197 199 199 201 201
                                                                                  202 202 202 203 203 208 208 209 209 217 219 223
                                                                                  226 226 229 229 544 544
al1                                    parameter       fixed bin(21,0)          dcl 538 set ref 535 548*
ap                              000110 automatic       pointer                  dcl 112 set ref 194* 196 196 197 197 199 199 201 201
                                                                                  202 202 202 203 208 208 209 217 220 224 226 229
                                                                                  544
ap1                                    parameter       pointer                  dcl 538 set ref 535 548*
arg                                    based           char                     packed unaligned dcl 104 set ref 196 196 197 197 199
                                                                                  199 201 201 202 202 202 203* 208 208 209* 217 226*
                                                                                  229* 544*
arg_expected                           parameter       char                     packed unaligned dcl 537 set ref 535 544*
argno                           000112 automatic       fixed bin(17,0)          dcl 113 set ref 193* 194* 542* 542 543 548*
before                                                 builtin function         dcl 95 ref 391 391
caller_access_class             000114 automatic       bit(72)                  dcl 114 set ref 267* 269*
check_gate_access_              000012 constant        entry                    external dcl 45 ref 251 350 584
cleanup                         000100 stack reference condition                dcl 100 ref 173
code                            000652 automatic       fixed bin(35,0)          dcl 501 in procedure "determine_hphcs_need" set ref
                                                                                  510* 512 512* 515*
code                            000116 automatic       fixed bin(35,0)          dcl 115 in procedure "copy_deadproc" set ref 170*
                                                                                  177* 178 179* 251* 252 253 253* 254 254* 260* 261
                                                                                  261* 264* 265 265* 271* 272 273 273* 275 275* 277*
                                                                                  286* 287 287* 289* 290 290* 297* 298 298* 303* 304
                                                                                  304* 311* 312 312* 314* 315 315* 319* 320* 321*
                                                                                  328* 350* 351 352 352* 355 355* 373* 375 377* 379
                                                                                  379* 386* 387 387* 389* 391* 393 393* 400* 401
                                                                                  401*
code                            000100 automatic       fixed bin(35,0)          dcl 436 in procedure "clean_up" set ref 438*
code                                   parameter       fixed bin(35,0)          dcl 578 in procedure "set_privileges" set ref 576
                                                                                  580* 584* 585 588* 590*
code                            000672 automatic       fixed bin(35,0)          dcl 538 in procedure "get_next_arg" set ref 548* 549
                                                                                  549*
com_err_                        000014 constant        entry                    external dcl 46 ref 179 387 424 566
command_query_$yes_no           000016 constant        entry                    external dcl 47 ref 328
copy_pdir_$deadproc             000020 constant        entry                    external dcl 48 ref 389
copy_pdir_$delete               000022 constant        entry                    external dcl 50 ref 400
copy_pdir_$liveproc             000024 constant        entry                    external dcl 51 ref 391
cu_$arg_count                   000026 constant        entry                    external dcl 53 ref 177
cu_$arg_ptr                     000030 constant        entry                    external dcl 54 ref 194 548
deadproc                        000120 automatic       bit(1)                   packed unaligned dcl 117 set ref 153* 160* 183 196
                                                                                  197 199 202 212 218 232 339 361 389
delete_sw                       000117 automatic       bit(1)                   packed unaligned dcl 116 set ref 164* 196* 197* 308
                                                                                  328 335* 399
dir                       0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 107 ref 444 587
dir_len                         000121 automatic       fixed bin(21,0)          dcl 118 set ref 203 203 206* 219* 245 245 247
dir_ptr                         000122 automatic       pointer                  dcl 119 set ref 169* 203 203 206* 218 220* 241 245
                                                                                  245 247
dir_str                                based           char                     packed unaligned dcl 105 set ref 203* 245 245 247
dirname                         000124 automatic       char(168)                packed unaligned dcl 120 in procedure
                                                                                  "copy_deadproc" set ref 260* 261* 261* 264* 265*
                                                                                  265* 277* 277* 292* 292* 297* 298* 298* 299* 299*
                                                                                  303* 304* 304* 305* 305* 311* 312* 315* 323* 323*
                                                                                  323* 328* 328* 328* 347* 389* 391* 393* 393* 400*
                                                                                  401* 401*
dirname                                parameter       char(168)                packed unaligned dcl 497 in procedure
                                                                                  "determine_hphcs_need" set ref 495 510* 512* 515*
                                                                                  515*
ecode                                  parameter       fixed bin(35,0)          dcl 563 in procedure "report_error" set ref 561 566*
ecode                                  parameter       fixed bin(35,0)          dcl 421 in procedure "argument_error" set ref 419
                                                                                  424*
ename                                  parameter       char(32)                 packed unaligned dcl 498 in procedure
                                                                                  "determine_hphcs_need" set ref 495 510* 515* 515*
ename                           000176 automatic       char(32)                 packed unaligned dcl 121 in procedure
                                                                                  "copy_deadproc" set ref 260* 261* 261* 264* 265*
                                                                                  265* 277* 277* 292* 292* 297* 298* 298* 299* 299*
                                                                                  303* 304* 304* 305* 305* 323* 323* 328* 328* 332*
                                                                                  339* 347* 363 363* 389* 391* 393* 393* 400* 401*
                                                                                  401*
error_table_$action_not_performed
                                000066 external static fixed bin(35,0)          dcl 70 set ref 292* 332* 363*
error_table_$badopt             000070 external static fixed bin(35,0)          dcl 70 set ref 229*
error_table_$incorrect_access   000072 external static fixed bin(35,0)          dcl 70 set ref 321 323*
error_table_$moderr             000074 external static fixed bin(35,0)          dcl 70 set ref 254 275 305* 355
error_table_$no_m_permission    000076 external static fixed bin(35,0)          dcl 70 ref 319
error_table_$no_s_permission    000100 external static fixed bin(35,0)          dcl 70 ref 320
error_table_$noarg              000102 external static fixed bin(35,0)          dcl 70 set ref 183* 188* 233* 241* 243* 544*
error_table_$noentry            000104 external static fixed bin(35,0)          dcl 70 ref 253 273 352
error_table_$notadir            000106 external static fixed bin(35,0)          dcl 70 set ref 299*
expand_pathname_                000032 constant        entry                    external dcl 55 ref 260 286 311
get_authorization_              000034 constant        entry                    external dcl 56 ref 267
get_group_id_                   000110 constant        entry                    external dcl 503 ref 510 510 515 515
get_group_id_$tag_star          000112 constant        entry                    external dcl 504 ref 506
get_privileges_                 000036 constant        entry                    external dcl 57 ref 581
hcs_$get_access_class           000040 constant        entry                    external dcl 58 ref 264 289
hcs_$get_user_effmode           000042 constant        entry                    external dcl 59 ref 303 314 510 515
hcs_$set_256K_switch            000044 constant        entry                    external dcl 60 ref 386 447
hcs_$status_minf                000046 constant        entry                    external dcl 61 ref 297 373
ignore                          000206 automatic       fixed bin(24,0)          dcl 122 set ref 297* 373*
ignore_code                     000207 automatic       fixed bin(35,0)          dcl 123 set ref 439* 444* 445* 447*
index                                                  builtin function         dcl 95 ref 474 483 507
message                                parameter       char                     packed unaligned dcl 563 in procedure "report_error"
                                                                                  set ref 561 566*
message                                parameter       char                     packed unaligned dcl 421 in procedure
                                                                                  "argument_error" set ref 419 424*
mode                            000210 automatic       fixed bin(5,0)           dcl 124 set ref 303* 305 305 314* 317 317 319 320
                                                                                  510* 513 515* 517
myname                          000211 automatic       char(13)                 packed unaligned dcl 125 set ref 154* 161* 179* 328*
                                                                                  387* 389* 391* 400* 424* 566*
name_len                        000217 automatic       fixed bin(21,0)          dcl 128 set ref 209 209 212* 214* 223* 226 226 236
                                                                                  236 238 342 343 391 391
name_ptr                        000220 automatic       pointer                  dcl 129 set ref 169* 209 209 212* 214* 222 224* 226
                                                                                  233 236 236 238 243 342 343 391 391
name_str                               based           char                     packed unaligned dcl 106 set ref 209* 226* 236 236
                                                                                  238 342 343 391 391
name_sw                         000215 automatic       bit(1)                   packed unaligned dcl 126 set ref 164*
nargs                           000216 automatic       fixed bin(17,0)          dcl 127 set ref 177* 183 193 543
ncd_sw                          000222 automatic       bit(1)                   packed unaligned dcl 130 set ref 164* 199* 308 323
                                                                                  346 399
need_hphcs                      000223 automatic       bit(1)                   packed unaligned dcl 131 set ref 164* 347* 348 389*
                                                                                  391*
need_priv                       000224 automatic       bit(1)                   packed unaligned dcl 132 set ref 164*
new_name                               parameter       char                     packed unaligned dcl 463 set ref 460 471* 475* 476*
                                                                                  479* 479
no_chase                        000225 automatic       fixed bin(1,0)           dcl 133 set ref 171* 297* 373*
null                                                   builtin function         dcl 95 ref 169 203 209 218 222 233 241 243 251 251
                                                                                  350 350 584 584
old_256k_sw                     000226 automatic       bit(2)                   dcl 134 set ref 164* 386* 447*
old_name                               parameter       char                     packed unaligned dcl 464 ref 460 472 474 476 485
owner_sw                        000227 automatic       bit(1)                   packed unaligned dcl 135 set ref 164* 201* 285 361
                                                                                  362
parent_access                   000230 automatic       bit(1)                   packed unaligned dcl 136 set ref 164* 279*
parent_access_class             000232 automatic       bit(72)                  dcl 137 set ref 289* 292
pathname_                       000050 constant        entry                    external dcl 62 ref 261 261 265 265 277 277 287 287
                                                                                  290 290 292 292 292 292 298 298 299 299 304 304
                                                                                  305 305 323 323 328 328 379 379 393 393 393 393
                                                                                  401 401 515 515
pdir_access_class               000244 automatic       bit(72)                  dcl 139 set ref 264* 269* 292
pdir_path                       000246 automatic       char(168)                packed unaligned dcl 140 set ref 236* 238* 245* 247*
                                                                                  260*
pdir_to_create                  000320 automatic       char(32)                 packed unaligned dcl 141 set ref 339* 342* 373* 377*
                                                                                  379* 379* 389* 391* 393* 393* 439*
person_proj                     000234 automatic       char(32)                 packed unaligned dcl 138 in procedure
                                                                                  "copy_deadproc" set ref 339* 343* 347* 363 367*
                                                                                  389* 391*
person_proj                            parameter       char(32)                 packed unaligned dcl 499 in procedure
                                                                                  "determine_hphcs_need" ref 495 507
priv_string                     000330 automatic       bit(36)                  dcl 142 set ref 444 445 581* 587 589
privileges                             based           structure                level 1 packed packed unaligned dcl 107
privileges_are_set              000331 automatic       bit(1)                   packed unaligned dcl 143 set ref 164* 271 443 592*
restore_names                   000332 automatic       bit(1)                   packed unaligned dcl 144 set ref 164* 376* 396* 439
                                                                                  442*
rtrim                                                  builtin function         dcl 95 ref 342 472 479
search                                                 builtin function         dcl 95 ref 236 245
seg                       0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 107 ref 445 589
str1                                   parameter       char                     packed unaligned dcl 421 in procedure
                                                                                  "argument_error" set ref 419 424*
str1                                   parameter       char                     packed unaligned dcl 563 in procedure "report_error"
                                                                                  set ref 561 566*
str2                                   parameter       char                     packed unaligned dcl 421 in procedure
                                                                                  "argument_error" set ref 419 424*
str2                                   parameter       char                     packed unaligned dcl 563 in procedure "report_error"
                                                                                  set ref 561 566*
substr                                                 builtin function         dcl 95 ref 217 475 484 507
system_privilege_$dir_priv_off  000052 constant        entry                    external dcl 63 ref 444
system_privilege_$dir_priv_on   000054 constant        entry                    external dcl 64 ref 588
system_privilege_$seg_priv_off  000056 constant        entry                    external dcl 65 ref 445
system_privilege_$seg_priv_on   000060 constant        entry                    external dcl 66 ref 590
target_dir                      000333 automatic       char(168)                packed unaligned dcl 145 set ref 168* 286* 373* 377*
                                                                                  379* 379* 389* 391* 393* 393* 439*
target_dirname                  000405 automatic       char(168)                packed unaligned dcl 146 set ref 286* 287* 287* 289*
                                                                                  290* 290* 292* 292*
target_parent                   000457 automatic       char(168)                packed unaligned dcl 147 set ref 286* 287* 287* 289*
                                                                                  290* 290* 292* 292*
tdirname                        000531 automatic       char(168)                packed unaligned dcl 148 set ref 311* 314*
temp_idx                        000643 automatic       fixed bin(17,0)          dcl 467 set ref 474* 475 475 483* 484 484
temp_name                       000632 automatic       varying char(32)         dcl 466 set ref 472* 475 483 484
tename                          000603 automatic       char(32)                 packed unaligned dcl 149 set ref 311* 314*
type                            000613 automatic       fixed bin(2,0)           dcl 150 set ref 297* 299 373*
upd_free_name_$restore_with_suffix
                                000064 constant        entry                    external dcl 68 ref 439
upd_free_name_$retain_suffix    000062 constant        entry                    external dcl 67 ref 377
userid                          000653 automatic       char(32)                 packed unaligned dcl 502 set ref 506* 507 507
yes_sw                          000614 automatic       bit(1)                   packed unaligned dcl 151 set ref 328* 332

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_PRIVILEGES                         internal static bit(36)                  initial dcl 2-16
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
COMM_PRIVILEGE                         internal static bit(36)                  initial dcl 2-16
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
DIR_PRIVILEGE                          internal static bit(36)                  initial dcl 2-16
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
IPC_PRIVILEGE                          internal static bit(36)                  initial dcl 2-16
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
RCP_PRIVILEGE                          internal static bit(36)                  initial dcl 2-16
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RING1_PRIVILEGE                        internal static bit(36)                  initial dcl 2-16
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SEG_PRIVILEGE                          internal static bit(36)                  initial dcl 2-16
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SOOS_PRIVILEGE                         internal static bit(36)                  initial dcl 2-16
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
aim_privileges_ptr                     automatic       pointer                  dcl 2-4

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000745 constant        label                    dcl 164 ref 155 162
END_COPY                        004234 constant        label                    dcl 406 ref 567
EXIT                            004240 constant        label                    dcl 409 ref 180 425
argument_error                  004241 constant        entry                    internal dcl 419 ref 183 188 203 209 226 229 233 241
                                                                                  243 544 549
clean_up                        004321 constant        entry                    internal dcl 434 ref 174 406
construct_names_from_pdir       004430 constant        entry                    internal dcl 460 ref 339
copy_deadproc                   000714 constant        entry                    external dcl 9
copy_liveproc                   000733 constant        entry                    external dcl 157
determine_hphcs_need            004621 constant        entry                    internal dcl 495 ref 347
get_next_arg                    005075 constant        entry                    internal dcl 535 ref 206 212 214
report_error                    005200 constant        entry                    internal dcl 561 ref 253 254 261 265 273 275 277 287
                                                                                  290 292 298 299 304 305 312 315 323 332 352 355
                                                                                  363 379 393 401 512
set_privileges                  005257 constant        entry                    internal dcl 576 ref 271

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6746        7062    6310        6756
Length      7426    6310       114         327     436           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
copy_deadproc                       880 external procedure  is an external procedure.  
on unit on line 173                  64 on unit               
argument_error                          internal procedure  shares stack frame of external procedure copy_deadproc.  
clean_up                             84 internal procedure  is called by several nonquick procedures.  
construct_names_from_pdir               internal procedure  shares stack frame of external procedure copy_deadproc.  
determine_hphcs_need                    internal procedure  shares stack frame of external procedure copy_deadproc.  
get_next_arg                            internal procedure  shares stack frame of external procedure copy_deadproc.  
report_error                            internal procedure  shares stack frame of external procedure copy_deadproc.  
set_privileges                          internal procedure  shares stack frame of external procedure copy_deadproc.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 code                        clean_up
copy_deadproc            000106 al                          copy_deadproc
                         000110 ap                          copy_deadproc
                         000112 argno                       copy_deadproc
                         000114 caller_access_class         copy_deadproc
                         000116 code                        copy_deadproc
                         000117 delete_sw                   copy_deadproc
                         000120 deadproc                    copy_deadproc
                         000121 dir_len                     copy_deadproc
                         000122 dir_ptr                     copy_deadproc
                         000124 dirname                     copy_deadproc
                         000176 ename                       copy_deadproc
                         000206 ignore                      copy_deadproc
                         000207 ignore_code                 copy_deadproc
                         000210 mode                        copy_deadproc
                         000211 myname                      copy_deadproc
                         000215 name_sw                     copy_deadproc
                         000216 nargs                       copy_deadproc
                         000217 name_len                    copy_deadproc
                         000220 name_ptr                    copy_deadproc
                         000222 ncd_sw                      copy_deadproc
                         000223 need_hphcs                  copy_deadproc
                         000224 need_priv                   copy_deadproc
                         000225 no_chase                    copy_deadproc
                         000226 old_256k_sw                 copy_deadproc
                         000227 owner_sw                    copy_deadproc
                         000230 parent_access               copy_deadproc
                         000232 parent_access_class         copy_deadproc
                         000234 person_proj                 copy_deadproc
                         000244 pdir_access_class           copy_deadproc
                         000246 pdir_path                   copy_deadproc
                         000320 pdir_to_create              copy_deadproc
                         000330 priv_string                 copy_deadproc
                         000331 privileges_are_set          copy_deadproc
                         000332 restore_names               copy_deadproc
                         000333 target_dir                  copy_deadproc
                         000405 target_dirname              copy_deadproc
                         000457 target_parent               copy_deadproc
                         000531 tdirname                    copy_deadproc
                         000603 tename                      copy_deadproc
                         000613 type                        copy_deadproc
                         000614 yes_sw                      copy_deadproc
                         000632 temp_name                   construct_names_from_pdir
                         000643 temp_idx                    construct_names_from_pdir
                         000652 code                        determine_hphcs_need
                         000653 userid                      determine_hphcs_need
                         000672 code                        get_next_arg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          enable_op           shorten_stack       ext_entry           int_entry           set_chars_eis
index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$equal              check_gate_access_            com_err_                      command_query_$yes_no
copy_pdir_$deadproc           copy_pdir_$delete             copy_pdir_$liveproc           cu_$arg_count
cu_$arg_ptr                   expand_pathname_              get_authorization_            get_group_id_
get_group_id_$tag_star        get_privileges_               hcs_$get_access_class         hcs_$get_user_effmode
hcs_$set_256K_switch          hcs_$status_minf              pathname_
system_privilege_$dir_priv_off                              system_privilege_$dir_priv_on
system_privilege_$seg_priv_off                              system_privilege_$seg_priv_on
upd_free_name_$restore_with_suffix                          upd_free_name_$retain_suffix

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$badopt           error_table_$incorrect_access
error_table_$moderr           error_table_$no_m_permission  error_table_$no_s_permission  error_table_$noarg
error_table_$noentry          error_table_$notadir




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000713       153 000721       154 000723       155 000731       157 000732       160 000740       161 000741
    162 000744       164 000745       168 000760       169 000763       170 000766       171 000767       173 000770
    174 001004       175 001011       177 001012       178 001023       179 001025       180 001042       183 001043
    188 001102       193 001135       194 001145       196 001163       197 001202       199 001220       201 001237
    202 001254       203 001273       206 001335       207 001344       208 001345       209 001355       212 001417
    214 001431       216 001441       217 001442       218 001446       219 001454       220 001456       221 001457
    222 001460       223 001464       224 001466       225 001467       226 001470       228 001526       229 001527
    230 001560       232 001562       233 001564       236 001617       238 001651       239 001655       241 001656
    243 001711       245 001744       247 001776       251 002002       252 002027       253 002031       254 002043
    260 002053       261 002077       264 002126       265 002153       267 002202       269 002213       271 002232
    272 002236       273 002240       275 002252       277 002263       279 002307       285 002311       286 002313
    287 002336       289 002364       290 002410       292 002436       297 002527       298 002564       299 002613
    303 002665       304 002724       305 002753       308 003030       311 003034       312 003060       314 003067
    315 003126       317 003135       319 003142       320 003150       321 003156       323 003161       328 003232
    332 003323       335 003357       339 003360       342 003366       343 003427       346 003434       347 003436
    348 003440       350 003443       351 003470       352 003472       355 003504       361 003514       362 003521
    363 003523       366 003557       367 003560       373 003563       375 003620       376 003622       377 003624
    379 003653       386 003703       387 003720       389 003746       391 004013       393 004077       396 004150
    399 004151       400 004155       401 004202       406 004234       409 004240       419 004241       424 004264
    425 004317       434 004320       438 004326       439 004327       442 004360       443 004362       444 004364
    445 004376       447 004411       449 004427       460 004430       471 004453       472 004465       474 004507
    475 004521       476 004527       479 004533       483 004573       484 004603       485 004612       488 004620
    495 004621       506 004623       507 004632       510 004654       512 004723       513 004754       515 004757
    517 005050       519 005061       521 005067       535 005075       542 005106       543 005107       544 005112
    545 005147       548 005150       549 005166       551 005177       561 005200       566 005223       567 005256
    576 005257       580 005261       581 005262       584 005271       585 005323       587 005327       588 005333
    589 005342       590 005346       592 005356       594 005360


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
