	COMPILATION LISTING OF SEGMENT mail_errfiles
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1317.6 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 mail_errfiles:           proc;
       12 
       13 /*     ENTRY DECLARATIONS     */
       14 
       15 dcl  get_wdir_ entry returns (char (168));		/* wdir of err segs */
       16 dcl  (temp_string1, temp_string) char(32);
       17 dcl  hcs_$star_ entry (char (*) aligned, char (*) aligned, fixed bin (2), ptr,
       18      fixed bin, ptr, ptr, fixed bin (35));		/* names of err segs */
       19 dcl  hcs_$fs_get_mode entry (ptr, fixed bin (5), fixed bin (35)); /* mailbox accessable ? */
       20 dcl  delete_$path entry (char (*) aligned, char (*), bit (6), char (*), fixed bin (35));
       21 dcl  continue_to_signal_  entry (fixed bin(35));
       22 dcl  find_condition_info_ entry (ptr, ptr, fixed bin(35));
       23 dcl  ioa_$ioa_stream      entry options (variable);
       24 dcl  com_err_ entry options(variable);
       25 dcl  mailbox_$close entry(fixed bin,fixed bin(35));
       26 dcl  mailbox_$get_mode_index entry(fixed bin,bit(*)aligned,fixed bin(35));
       27 dcl  mailbox_$open entry(char(*)aligned,char(*)aligned,fixed bin,fixed bin(35));
       28 dcl  mail entry options(variable);			/* new mail, ring 1 mailboxes */
       29 dcl  old_mail entry options(variable);			/* old mail, "mailbox" segments */
       30 dcl  hcs_$terminate_noname
       31      entry (ptr, fixed bin (35));			/* mail went OK         */
       32 dcl  dprint_ entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
       33 dcl  get_system_free_area_
       34      entry returns (ptr);				/* for hcs_$star        */
       35 dcl  hcs_$initiate_count entry (char (*) aligned, char (*) aligned, char (*), fixed bin (24),
       36      fixed bin (2), ptr, fixed bin (35));		/* find mailbox of err causer */
       37 dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));	/* no access, scratch err seg */
       38 
       39 /*     BUILTIN FUNCTIONS     */
       40 
       41 dcl (addr, after, before, null, substr) builtin;
       42 
       43 /*     BASED STRUCTURES     */
       44 
       45 dcl 1 box based (p) aligned,				/* mailbox structure    */
       46     2 lock bit (36) aligned,
       47     2 nchr fixed bin,
       48     2 nmsg fixed bin,
       49     2 lins fixed bin,
       50     2 secret fixed bin,
       51     2 pad (3) fixed bin,
       52     2 b,
       53       3 yte (1000) bit (9) unaligned;
       54 
       55 dcl 1 in based (p) aligned,				/* used by initiate_seg    */
       56     2 put (1000)bit (9) unaligned;
       57 
       58 
  1     1 /* BEGIN INCLUDE FILE ... dprint_arg.incl.pl1 */
  1     2 /* Modified 11/13/74 by Noel I. Morris */
  1     3 /* Modified: 10 April 1981 by G. Palter for version 6 structure -- longer request type names */
  1     4 /* Modified: 30 April 1982 by R. Kovalcik for version 7 structure -- defer_until_process_terminataion */
  1     5 /* Modified: November 1983 by C. Marker for version 8 structure -- no_separator */
  1     6 
  1     7 /****^  HISTORY COMMENTS:
  1     8*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  1     9*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  1    10*     Add line_nbrs bit for line-numbered printouts, version 9.
  1    11*  2) change(88-02-05,Farley), approve(88-02-05,PBF7686), audit(88-02-05,GWMay),
  1    12*     install(88-02-05,MR12.2-1022):
  1    13*     Corrected alignment of line_nbrs, was aligned s/b unaligned..
  1    14*  3) change(88-08-29,Farley), approve(88-09-16,MCR7911),
  1    15*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    16*     Created a new 64 character forms_name variable, which supersedes the old
  1    17*     char 24 form_name variable, version 10.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 dcl  dpap ptr;					/* ptr to argument structure */
  1    22 dcl  1 dprint_arg_buf aligned like dprint_arg;		/* Automatic storage for arg. */
  1    23 
  1    24 dcl  1 dprint_arg based (dpap) aligned,			/* argument structure */
  1    25        2 version fixed bin,				/* version number of dcl - current version is 9 */
  1    26        2 copies fixed bin,				/* number of copies wanted */
  1    27        2 delete fixed bin,				/* 1=delete after print */
  1    28        2 queue fixed bin,				/* print queue */
  1    29        2 pt_pch fixed bin,				/* 1=print, 2=punch */
  1    30        2 notify fixed bin,				/* 1 = notify user when done */
  1    31        2 heading char (64),				/* first page heading */
  1    32        2 output_module fixed bin,			/* 1=print, 2=7punch, 3=mcc, 4=raw, 5=plotter */
  1    33        2 dest char (12),				/* version 5 made this a pad - see destination below */
  1    34 						/* limit of version 1 structure */
  1    35        2 carriage_control,				/* Carriage control flags. */
  1    36          3 nep bit (1) unal,				/* TRUE if print trhu perf. */
  1    37          3 single bit (1) unal,			/* TRUE if ignore FF and VT */
  1    38          3 non_edited bit (1) unal,			/* TRUE if printing in non-edited mode */
  1    39          3 truncate bit (1) unal,			/* TRUE if truncating lines at line length */
  1    40          3 center_top_label bit (1) unal,		/* TRUE if top label to be centered */
  1    41          3 center_bottom_label bit (1) unal,		/* TRUE if bottom label to be centered */
  1    42          3 esc bit (1) unal,				/* version 5 TRUE if text escapes are to be processed */
  1    43          3 no_separator bit (1) unal,			/* version 8 TRUE if the inner head and tail sheets are to be suppressed. */
  1    44          3 line_nbrs bit (1) unal,			/* version 9, line numbers */
  1    45          3 padding bit (27) unal,
  1    46        2 pad (30) fixed bin,
  1    47        2 forms char (8),				/* version 5 made this a pad - see form_name below */
  1    48        2 lmargin fixed bin,				/* left margin */
  1    49        2 line_lth fixed bin,				/* max line lth */
  1    50 						/* limit of version 2 structure */
  1    51        2 class char (8),				/* version 6 made this a pad - see request_type below */
  1    52        2 page_lth fixed bin,				/* Paper length arg */
  1    53 						/* limit of version 3 structure */
  1    54        2 top_label char (136),			/* top-of-page label */
  1    55        2 bottom_label char (136),			/* bottom-of-page label */
  1    56 						/* limit of version 4 structure */
  1    57        2 bit_count fixed bin (35),			/* segment bit count */
  1    58        2 form_name char (24),				/* name of special forms needed - moved from forms */
  1    59 						/* version 10 made this a pad - see forms_name below */
  1    60        2 destination char (24),			/* the long destination - moved from dest */
  1    61        2 chan_stop_path char (168),			/* path of user channel stops - future */
  1    62 						/* limit of version 5 structure */
  1    63        2 request_type character (24) unaligned,		/* request type for the request */
  1    64                                                             /* limit of version 6 structure */
  1    65        2 defer_until_process_termination fixed bin,	/* 1 = don't process request until requesting process terminates */
  1    66        2 forms_name char (64) unal;			/* name of special forms needed - moved from form_name */
  1    67                                                             /* limit of version 10 structure */
  1    68 
  1    69 dcl  dprint_arg_version_1 fixed bin int static options (constant) init (1);
  1    70 dcl  dprint_arg_version_2 fixed bin int static options (constant) init (2);
  1    71 dcl  dprint_arg_version_3 fixed bin int static options (constant) init (3);
  1    72 dcl  dprint_arg_version_4 fixed bin int static options (constant) init (4);
  1    73 dcl  dprint_arg_version_5 fixed bin int static options (constant) init (5);
  1    74 dcl  dprint_arg_version_6 fixed bin int static options (constant) init (6);
  1    75 dcl  dprint_arg_version_7 fixed bin int static options (constant) init (7);
  1    76 dcl  dprint_arg_version_8 fixed bin int static options (constant) init (8);
  1    77 dcl  dprint_arg_version_9 fixed bin int static options (constant) init (9);
  1    78 dcl  dprint_arg_version_10 fixed bin int static options (constant) init (10);
  1    79 						/* current version */
  1    80 
  1    81 dcl  (
  1    82      DP_PRINT init (1),
  1    83      DP_PUNCH init (2),
  1    84      DP_PLOT init (3)
  1    85      ) fixed bin static options (constant);		/* for dprint_arg.pt_pch */
  1    86 
  1    87 /* END INCLUDE FILE ... dprint_arg.incl.pl1 */
       59 
       60 dcl 1 entries (encount) aligned based (eptr),		/* for hcs_$star        */
       61     2 type bit (2) unaligned,
       62     2 nname bit (16) unaligned,
       63     2 nindex bit (18) unaligned;
       64 
       65 /*     MISCELLANEOUS DATA ITEMS AND POINTERS     */
       66 
       67 dcl  names (0:100) char (32) aligned based (nptr);	/* EF seg names from list_err */
       68 dcl  areap ptr init (null);				/* ptr to sys free area         */
       69 dcl  encount fixed bin (17);				/* no of err seg names        */
       70 dcl  mseg_index fixed bin(17) init(0);			/* index of ring 1 mailbox */
       71 dcl (eptr, delptr, nptr) ptr init (null);		/* miscellaneous pointers       */
       72 dcl  xmode bit(36) aligned;				/* extended access on ring 1 mailbox */
       73 dcl  star_arg char (6) aligned init ("EF.**");		/* indicates all segs beg w EF. */
       74 dcl  mode fixed bin (5);				/* access mode                  */
       75 dcl  bmode bit (36) based (addr (mode));		/* for testing mode             */
       76 dcl  ind fixed bin;					/* index of no of EF. segs      */
       77 dcl  dptr ptr init (null);				/* ptr to dprint buffer         */
       78 dcl  dir_name char(168) aligned int static		/* directory in which to look for errfiles */
       79 	init(">udd>SysDaemon>error_file");
       80 dcl  code fixed bin (35);				/* std error code ind           */
       81 dcl dirp char(168) aligned;				/* mailbox dirname */
       82 dcl  p ptr init (null);
       83 dcl enamep char(32) aligned;				/* mailbox entry name */
       84 dcl  ec fixed bin (35);				/* std sys err code             */
       85 dcl  bitct fixed bin (24);				/* bitct of err causers mailbox */
       86 dcl (this_seg, cur_seg) char (70);			/* name of seg in my directory  */
       87 dcl  cur_name char (22) aligned;			/* err causers name             */
       88 dcl  error_table_$noentry fixed bin (35) ext;		/* in case no mailbox           */
       89 dcl  error_table_$no_dir fixed bin (35) ext;		/* sm dir in pth nm not spec    */
       90 dcl  error_table_$no_info fixed bin (35) ext;		/* not enuf acc to rtn any info */
       91 dcl  cur_proj char (9) aligned;			/* err causers proj             */
       92 dcl  my_path char (168) aligned;			/* pathname of seg in my wdir   */
       93 dcl  any_other condition;
       94 
       95 /*     BEGIN PROGRAM EXECUTION     */
       96 
       97 
       98 
       99 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      100 /*                                                                                                           */ 
      101 /*  Initialize all the components of the dprint_arg structure                                                */
      102 /*                                                                                                           */ 
      103 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      104 
      105 
      106           dpap = addr (dprint_arg_buf);                     /* set ptr to the dprint_ args  */
      107           dpap -> dprint_arg.version = 1;                   /* the version no is one        */
      108           dpap -> dprint_arg.copies  = 1;                   /* only one copy                */
      109           dpap -> dprint_arg.delete  = 1;                   /* dprint and delete the seg    */
      110           dpap -> dprint_arg.queue   = 3;                   /* no hurry, so print in Q 3    */
      111           dpap -> dprint_arg.pt_pch  = 1;                   /* print it don't punch it      */
      112           dpap -> dprint_arg.notify  = 1;                   /* don't bother to notify       */
      113           dpap -> dprint_arg.output_module = 1;             /* tell again to print not punch*/
      114           dpap -> dprint_arg.class   = "printer";           /* make it perfectly clear      */
      115 
      116 
      117 
      118 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      119 /*                                                                                                           */ 
      120 /*  Get the name of the wdir containing the backup dump exceptions processed by list_err                     */
      121 /*  Pick up any segment names beginning with EF. and store them in the variable 'names where they will       */
      122 /*  be processed one at a time.  if there are no EF. segments today then quit till tomorrow                  */
      123 /*                                                                                                           */ 
      124 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      125 
      126           areap = get_system_free_area_ ();
      127           call hcs_$star_ (dir_name, star_arg, 11b, areap, encount, eptr, nptr, code);
      128           if code ^= 0 then do;
      129                call com_err_ (code, "mail_errfiles", "Error in obtaining error segments.");
      130                go to fin;
      131           end;
      132 
      133 
      134 
      135 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      136 /*                                                                                                           */ 
      137 /*  For each un backed up segment, pick up the name, strip off the EF. prefis and parse out                  */
      138 /*  the name and the project.                                                                                */
      139 /*                                                                                                           */ 
      140 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      141 
      142           do ind = 1 to encount;
      143                this_seg = nptr -> names (ind-1);
      144 	     my_path = before(dir_name," ")||">"||this_seg;
      145                cur_seg = after (this_seg, "EF.");
      146                temp_string = cur_seg;
      147                do while (index (temp_string, ".") ^= 0);
      148                     temp_string1 = before (temp_string, ".");
      149                     temp_string = after (temp_string, ".");
      150                end;
      151                     cur_name = temp_string1;
      152                     cur_proj = temp_string;
      153 
      154 
      155 
      156 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      157 /*                                                                                                           */ 
      158 /*  Check to see if this is the segment named EF.strange^line which is the storage place that list_err       */
      159 /*  uses for all lines in the backup dump which it cannot recognize as normal processing.                    */
      160 /*  If this is the strange^line segment it is bypassed and left in the directory so that it can be           */
      161 /*  dprinted and examined for any serious problems.                                                          */
      162 /*                                                                                                           */ 
      163 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      164 
      165              if cur_name = "strange" then go to fin;
      166 
      167 
      168 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      169 /*                                                                                                           */ 
      170 /*  Look for a ring 1 mailbox to mail this segment to. If mail cannot be sent to a ring 1 mailbox for any   */
      171 /*  reason, either because no such mailbox exists or because of insufficient access, try sending to an old  */
      172 /*  mailbox. If there is not enough information available to say whether an old mailbox exists,             */
      173 /*  then assume that the receiver doesn't want to know about his un backed up segments and delete the        */
      174 /*  segment from the wdir.  If there is no mailbox or if some directory in the pathname is missing, then     */
      175 /*  dprint the segment and go get the next one if any.                                                       */
      176 /*                                                                                                           */ 
      177 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      178 
      179 	     on condition(any_other) call default_handler;
      180                dirp = ">udd>"||before (cur_proj, " ")||">"||before (cur_name, " ");
      181                enamep = before(cur_name," ")||".mbx";
      182 	     call mailbox_$open(dirp,enamep,mseg_index,code);
      183 	     if mseg_index=0 then do;			/* can't send to new mailbox */
      184 
      185 try_old:		enamep = "mailbox";
      186 		call hcs_$initiate_count (dirp, enamep, "", bitct, 1, p, ec);
      187 		if p=null then do;
      188 
      189 		     if ec = error_table_$no_info then go to del_seg;
      190 		     else if ec = error_table_$noentry | ec = error_table_$no_dir then do;
      191 print_it:
      192 			dpap -> dprint_arg.dest = cur_proj;
      193 			dpap -> dprint_arg.heading = cur_name;
      194 
      195 			call dprint_ (dir_name, ("EF."||before(cur_name, " ")||"."||cur_proj), dpap, code);
      196 			go to fin;
      197 		     end;
      198 
      199 
      200 
      201 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      202 /*                                                                                                           */ 
      203 /*  If there is a null pointer where the mailbox pointer should be then call com_err_ to say why and go      */
      204 /*  to get the next entry.  If there is a valid pointer, check to see if we have access.  If we have been    */
      205 /*  refused access assume the potential receiver doesn't want to hear from us and delete the segment         */
      206 /*  and go get the next one.                                                                                 */
      207 /*                                                                                                           */ 
      208 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      209 
      210 	               call com_err_ (ec, "mail_errfiles", "Null pointer returned to mailbox ^a>^a",dirp,enamep);
      211 	               go to fin;
      212 		end;
      213 		call hcs_$fs_get_mode (p, mode, code);
      214 		if ^substr (bmode, 33, 1) | ^substr (bmode, 35, 1) then do;
      215 
      216 		     call hcs_$terminate_noname(p,code);
      217 del_seg:
      218 		     call delete_$path (dir_name, this_seg, "000100"b, "mail_errfiles", code);
      219 		     if code ^= 0 then
      220 		          call com_err_ (code, "mail_errfiles", "Unsuccessful delete attempt of seg", "^a", my_path);
      221 		     go to fin;
      222 		end;
      223 
      224 
      225 
      226 
      227 
      228 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      229 /*                                                                                                           */ 
      230 /*  When we finally have access, see first if this is a real mailbox.  If it is not, go dprint               */
      231 /*  the segment instead.  If this is a real mailbox, mail the segment at last, and go get the next           */
      232 /*  one , if any.                                                                                            */
      233 /*                                                                                                           */ 
      234 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      235 
      236 		if bitct > 0 then if p -> box.secret ^= 2962 then do;
      237                                  call hcs_$terminate_noname (p, code);
      238                                  go to print_it;
      239 		end;
      240 		call old_mail (my_path, before(cur_name, " "), before(cur_proj, " "));
      241 		call hcs_$terminate_noname (p, ec);
      242 		p = null;
      243 	     end;
      244 
      245 
      246 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  */
      247 /*										  */
      248 /*  There is a ring 1 mailbox. Check extended access and if insufficient, go back and try old mail.   */
      249 /*  If we have append extended access (first bit), send mail and close the mailbox.		  */
      250 /*										  */
      251 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  */
      252 
      253 
      254 	     else do;
      255 		call mailbox_$get_mode_index(mseg_index,xmode,ec);
      256 		if ec^=0 | ^substr(xmode,1,1) then do;
      257 		     call mailbox_$close(mseg_index,code);
      258 		     go to try_old;
      259 		end;
      260 
      261 		call mail (my_path,before(cur_name," "),before(cur_proj," "));
      262 		call mailbox_$close(mseg_index,code);
      263 	     end;
      264 fin:	end;
      265 
      266 default_handler:     proc;
      267 
      268 dcl 1 cond_info      aligned,
      269       2 mcptr                 ptr,
      270       2 version               fixed bin,
      271       2 condition_name        char(32) varying,
      272       2 infop                 ptr,
      273       2 wcptr                 ptr,
      274       2 loc_ptr               ptr,
      275       2 flags        aligned,
      276         3 crawlout            bit(1) unal,
      277         3 pad1                bit(35) unal,
      278 
      279       2 pad_word              bit(36) aligned,
      280       2 user_loc              ptr,
      281       2 pad(4)                bit(36) aligned;
      282 
      283 
      284 call find_condition_info_ (null, addr(cond_info), code);
      285 if code ^= 0 then do;
      286 
      287      call ioa_$ioa_stream ("error_output", "Error: Unknown signal has been received.");
      288      return;
      289 end;
      290 
      291 if cond_info.condition_name = "alrm" then do;
      292 
      293 continue:
      294      call continue_to_signal_ (code);
      295      return;
      296 end;
      297 
      298 if cond_info.condition_name = "cput" then go to continue;
      299 if cond_info.condition_name = "linkage_error" then go to continue;
      300 if cond_info.condition_name = "mme2" then go to continue;
      301 if cond_info.condition_name = "quit" then go to continue;
      302 if cond_info.condition_name = "command_error" then go to continue;
      303 if cond_info.condition_name = "finish" then go to continue;
      304 if cond_info.condition_name = "stack" then go to continue;
      305 if cond_info.condition_name = "program_interrupt" then return;
      306 
      307 call hcs_$terminate_noname (p, code);
      308 go to fin;
      309 
      310 end default_handler;
      311 
      312 
      313 /*  This is the end                                                                                          */
      314 
      315 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1302.3  mail_errfiles.pl1                 >special_ldd>install>MR12.2-1199>mail_errfiles.pl1
59           1    10/28/88  1227.7  dprint_arg.incl.pl1               >special_ldd>install>MR12.2-1199>dprint_arg.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 41 ref 106 214 214 284 284
after                                                  builtin function         dcl 41 ref 145 149
any_other                       000706 stack reference condition                dcl 93 ref 179
areap                           000444 automatic       pointer                  initial dcl 68 set ref 68* 126* 127*
before                                                 builtin function         dcl 41 ref 144 148 180 180 181 195 240 240 240 240
                                                                                  261 261 261 261
bitct                           000555 automatic       fixed bin(24,0)          dcl 85 set ref 186* 236
bmode                                  based           bit(36)                  packed unaligned dcl 75 ref 214 214
box                                    based           structure                level 1 dcl 45
class                    75            based           char(8)                  level 2 dcl 1-24 set ref 114*
code                            000466 automatic       fixed bin(35,0)          dcl 80 set ref 127* 128 129* 182* 195* 213* 216*
                                                                                  217* 219 219* 237* 257* 262* 284* 285 293* 307*
com_err_                        000076 constant        entry                    external dcl 24 ref 129 210 219
cond_info                       000106 automatic       structure                level 1 dcl 268 set ref 284 284
condition_name            3     000106 automatic       varying char(32)         level 2 dcl 268 set ref 291 298 299 300 301 302 303
                                                                                  304 305
continue_to_signal_             000070 constant        entry                    external dcl 21 ref 293
copies                    1            based           fixed bin(17,0)          level 2 dcl 1-24 set ref 108*
cur_name                        000622 automatic       char(22)                 dcl 87 set ref 151* 165 180 181 193 195 240 240 261
                                                                                  261
cur_proj                        000630 automatic       char(9)                  dcl 91 set ref 152* 180 191 195 240 240 261 261
cur_seg                         000600 automatic       char(70)                 packed unaligned dcl 86 set ref 145* 146
delete                    2            based           fixed bin(17,0)          level 2 dcl 1-24 set ref 109*
delete_$path                    000066 constant        entry                    external dcl 20 ref 217
delptr                          000452 automatic       pointer                  initial dcl 71 set ref 71*
dest                     27            based           char(12)                 level 2 dcl 1-24 set ref 191*
dir_name                        000010 internal static char(168)                initial dcl 78 set ref 127* 144 195* 217*
dirp                            000467 automatic       char(168)                dcl 81 set ref 180* 182* 186* 210*
dpap                            000120 automatic       pointer                  dcl 1-21 set ref 106* 107 108 109 110 111 112 113
                                                                                  114 191 193 195*
dprint_                         000114 constant        entry                    external dcl 32 ref 195
dprint_arg                             based           structure                level 1 dcl 1-24
dprint_arg_buf                  000122 automatic       structure                level 1 dcl 1-22 set ref 106
dptr                            000464 automatic       pointer                  initial dcl 77 set ref 77*
ec                              000554 automatic       fixed bin(35,0)          dcl 84 set ref 186* 189 190 190 210* 241* 255* 256
enamep                          000544 automatic       char(32)                 dcl 83 set ref 181* 182* 185* 186* 210*
encount                         000446 automatic       fixed bin(17,0)          dcl 69 set ref 127* 142
eptr                            000450 automatic       pointer                  initial dcl 71 set ref 71* 127*
error_table_$no_dir             000124 external static fixed bin(35,0)          dcl 89 ref 190
error_table_$no_info            000126 external static fixed bin(35,0)          dcl 90 ref 189
error_table_$noentry            000122 external static fixed bin(35,0)          dcl 88 ref 190
find_condition_info_            000072 constant        entry                    external dcl 22 ref 284
get_system_free_area_           000116 constant        entry                    external dcl 33 ref 126
hcs_$fs_get_mode                000064 constant        entry                    external dcl 19 ref 213
hcs_$initiate_count             000120 constant        entry                    external dcl 35 ref 186
hcs_$star_                      000062 constant        entry                    external dcl 17 ref 127
hcs_$terminate_noname           000112 constant        entry                    external dcl 30 ref 216 237 241 307
heading                   6            based           char(64)                 level 2 dcl 1-24 set ref 193*
ind                             000463 automatic       fixed bin(17,0)          dcl 76 set ref 142* 143*
ioa_$ioa_stream                 000074 constant        entry                    external dcl 23 ref 287
mail                            000106 constant        entry                    external dcl 28 ref 261
mailbox_$close                  000100 constant        entry                    external dcl 25 ref 257 262
mailbox_$get_mode_index         000102 constant        entry                    external dcl 26 ref 255
mailbox_$open                   000104 constant        entry                    external dcl 27 ref 182
mode                            000462 automatic       fixed bin(5,0)           dcl 74 set ref 213* 214 214
mseg_index                      000447 automatic       fixed bin(17,0)          initial dcl 70 set ref 70* 182* 183 255* 257* 262*
my_path                         000633 automatic       char(168)                dcl 92 set ref 144* 219* 240* 261*
names                                  based           char(32)                 array dcl 67 ref 143
notify                    5            based           fixed bin(17,0)          level 2 dcl 1-24 set ref 112*
nptr                            000454 automatic       pointer                  initial dcl 71 set ref 71* 127* 143
null                                                   builtin function         dcl 41 ref 68 71 71 71 77 82 187 242 284 284
old_mail                        000110 constant        entry                    external dcl 29 ref 240
output_module            26            based           fixed bin(17,0)          level 2 dcl 1-24 set ref 113*
p                               000542 automatic       pointer                  initial dcl 82 set ref 82* 186* 187 213* 216* 236
                                                                                  237* 241* 242* 307*
pt_pch                    4            based           fixed bin(17,0)          level 2 dcl 1-24 set ref 111*
queue                     3            based           fixed bin(17,0)          level 2 dcl 1-24 set ref 110*
secret                    4            based           fixed bin(17,0)          level 2 dcl 45 ref 236
star_arg                        000460 automatic       char(6)                  initial dcl 73 set ref 73* 127*
substr                                                 builtin function         dcl 41 ref 214 214 256
temp_string                     000110 automatic       char(32)                 packed unaligned dcl 16 set ref 146* 147 148 149*
                                                                                  149 152
temp_string1                    000100 automatic       char(32)                 packed unaligned dcl 16 set ref 148* 151
this_seg                        000556 automatic       char(70)                 packed unaligned dcl 86 set ref 143* 144 145 217*
version                                based           fixed bin(17,0)          level 2 dcl 1-24 set ref 107*
xmode                           000456 automatic       bit(36)                  dcl 72 set ref 255* 256

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DP_PLOT                                internal static fixed bin(17,0)          initial dcl 1-81
DP_PRINT                               internal static fixed bin(17,0)          initial dcl 1-81
DP_PUNCH                               internal static fixed bin(17,0)          initial dcl 1-81
dprint_arg_version_1                   internal static fixed bin(17,0)          initial dcl 1-69
dprint_arg_version_10                  internal static fixed bin(17,0)          initial dcl 1-78
dprint_arg_version_2                   internal static fixed bin(17,0)          initial dcl 1-70
dprint_arg_version_3                   internal static fixed bin(17,0)          initial dcl 1-71
dprint_arg_version_4                   internal static fixed bin(17,0)          initial dcl 1-72
dprint_arg_version_5                   internal static fixed bin(17,0)          initial dcl 1-73
dprint_arg_version_6                   internal static fixed bin(17,0)          initial dcl 1-74
dprint_arg_version_7                   internal static fixed bin(17,0)          initial dcl 1-75
dprint_arg_version_8                   internal static fixed bin(17,0)          initial dcl 1-76
dprint_arg_version_9                   internal static fixed bin(17,0)          initial dcl 1-77
entries                                based           structure                array level 1 dcl 60
get_wdir_                       000000 constant        entry                    external dcl 15
hcs_$delentry_seg               000000 constant        entry                    external dcl 37
in                                     based           structure                level 1 dcl 55

NAMES DECLARED BY EXPLICIT CONTEXT.
continue                        001515 constant        label                    dcl 293 ref 298 299 300 301 302 303 304
default_handler                 001437 constant        entry                    internal dcl 266 ref 179
del_seg                         001077 constant        label                    dcl 217 ref 189
fin                             001434 constant        label                    dcl 264 ref 130 165 196 211 221 308
mail_errfiles                   000150 constant        entry                    external dcl 11
print_it                        000705 constant        label                    dcl 191 ref 238
try_old                         000623 constant        label                    dcl 185 ref 258

NAME DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 147

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2052        2202    1615        2062
Length      2434    1615       130         216     235          52

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mail_errfiles                       522 external procedure  is an external procedure.  
on unit on line 179                 128 on unit               
default_handler                         internal procedure  shares stack frame of on unit on line 179.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dir_name                    mail_errfiles

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mail_errfiles            000100 temp_string1                mail_errfiles
                         000110 temp_string                 mail_errfiles
                         000120 dpap                        mail_errfiles
                         000122 dprint_arg_buf              mail_errfiles
                         000444 areap                       mail_errfiles
                         000446 encount                     mail_errfiles
                         000447 mseg_index                  mail_errfiles
                         000450 eptr                        mail_errfiles
                         000452 delptr                      mail_errfiles
                         000454 nptr                        mail_errfiles
                         000456 xmode                       mail_errfiles
                         000460 star_arg                    mail_errfiles
                         000462 mode                        mail_errfiles
                         000463 ind                         mail_errfiles
                         000464 dptr                        mail_errfiles
                         000466 code                        mail_errfiles
                         000467 dirp                        mail_errfiles
                         000542 p                           mail_errfiles
                         000544 enamep                      mail_errfiles
                         000554 ec                          mail_errfiles
                         000555 bitct                       mail_errfiles
                         000556 this_seg                    mail_errfiles
                         000600 cur_seg                     mail_errfiles
                         000622 cur_name                    mail_errfiles
                         000630 cur_proj                    mail_errfiles
                         000633 my_path                     mail_errfiles
on unit on line 179      000106 cond_info                   default_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac          tra_ext_1
enable_op           shorten_stack       ext_entry           int_entry           set_chars_eis       index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           delete_$path                  dprint_
find_condition_info_          get_system_free_area_         hcs_$fs_get_mode              hcs_$initiate_count
hcs_$star_                    hcs_$terminate_noname         ioa_$ioa_stream               mail
mailbox_$close                mailbox_$get_mode_index       mailbox_$open                 old_mail

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_dir           error_table_$no_info          error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000147        68 000155        70 000157        71 000160        73 000163        77 000165        82 000167
    106 000170       107 000172       108 000174       109 000175       110 000176       111 000200       112 000202
    113 000203       114 000204       126 000207       127 000215       128 000262       129 000264       130 000314
    142 000315       143 000325       144 000333       145 000367       146 000405       147 000410       148 000421
    149 000431       150 000447       151 000450       152 000456       165 000462       179 000466       180 000504
    181 000556       182 000573       183 000621       185 000623       186 000626       187 000671       189 000675
    190 000701       191 000705       193 000711       195 000714       196 001003       210 001005       211 001044
    213 001045       214 001060       216 001066       217 001077       219 001136       221 001202       236 001203
    237 001211       238 001222       240 001223       241 001274       242 001306       243 001310       255 001311
    256 001332       257 001337       258 001350       261 001351       262 001422       264 001434       315 001436
    266 001437       284 001440       285 001460       287 001463       288 001507       291 001510       293 001515
    295 001525       298 001526       299 001533       300 001540       301 001545       302 001552       303 001557
    304 001564       305 001571       307 001577       308 001610


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
