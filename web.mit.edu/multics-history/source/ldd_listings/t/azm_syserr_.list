	COMPILATION LISTING OF SEGMENT azm_syserr_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/28/87  0931.7 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(87-01-15,Farley), approve(87-07-09,MCR7746),
       13*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
       14*     Changed to properly set P_ret_len when exiting, when entered at
       15*     returns_string.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 
       19 azm_syserr_:
       20      proc;
       21 	return;
       22 
       23 /* *	84-12-15, W. Olin Sibert: Converted (albeit with a monstrous kludge)
       24*   *	   for new-format log segments in the partition.
       25*   */
       26 /*        Modified 01/21/85, B. Braun to 
       27*          a) call print_sys_log with a severity specified. 
       28*	b) change the data and log entries to require a char severity range instead of fixed bin.
       29*	c) delete the $code_only entry as it apparently isn't referenced by anyone.
       30*	d) Set severity for returns_string entry in case it goes to the log.
       31**/
       32 
       33 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       34 
       35 /* Parameters */
       36 dcl  P_amu_info_ptr ptr;
       37 dcl  P_sci_ptr ptr;
       38 dcl  P_code fixed bin (35);
       39 dcl  P_count fixed bin (35);
       40 dcl  P_match_str char (*) var;
       41 dcl  P_match_sw bit (1);
       42 dcl  P_expand_sw bit (1);
       43 dcl  P_syserr_code fixed bin;
       44 dcl  P_severity  char(*) var;
       45 dcl  P_string_len fixed bin (21);
       46 dcl  P_string_ptr ptr;
       47 	
       48 
       49 dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
       50 dcl  amu_$slt_search_seg_num entry (ptr, ptr, char (32) aligned, fixed bin, fixed bin (35));
       51 dcl  amu_$definition_ptr entry (ptr, char (*), char (*), fixed bin (35)) returns (ptr);
       52 dcl  amu_$do_translation entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
       53 dcl  azm_display_mc_ entry (ptr, ptr, ptr, ptr, fixed bin (35));
       54 dcl  ioa_ entry () options (variable);
       55 dcl  ioa_$rs entry() options(variable);
       56 dcl  ssu_$get_temp_segment	entry (ptr, char(*), ptr);
       57 dcl  ssu_$release_temp_segment	entry (ptr, ptr);
       58 dcl  print_syserr_msg_ entry (ptr, fixed bin (35));
       59 dcl  iox_$user_output ptr ext static;
       60 dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
       61 dcl  date_time_ entry (fixed bin (71), char (*));
       62 dcl  amu_$hranl entry (ptr, ptr, bit (1));
       63 
       64 /* Builtins */
       65 
       66 dcl  (addr, addrel, baseno, char, fixed, index, 
       67       null, rel, rtrim, size, substr, unspec)	builtin;
       68 
       69 /* Handlers */
       70 
       71 dcl  cleanup			condition;
       72 
       73 /* Automatic */
       74 
       75 dcl  a_syserr_code fixed bin;
       76 dcl  data_area_ptr ptr;
       77 dcl  mess_count fixed bin;
       78 dcl  head_size fixed bin;
       79 dcl  severity char(30);
       80 dcl  segno fixed bin (17);
       81 dcl  (offset, range) fixed bin (18);
       82 dcl  (code, def_code) fixed bin (35);
       83 dcl  w_header (size (wlog_header)) fixed bin;
       84 dcl  1 current_hardcore like hardcore_cur;
       85 dcl  i fixed bin;
       86 dcl  new_time char (24);
       87 dcl  1 auto_parg like parg aligned automatic;
       88 dcl  plural_sw bit (1) init ("0"b);
       89 dcl  (msgs_printed, msgs_bypassed) fixed bin init (0);
       90 dcl  text char (512);
       91 dcl  msg_printed bit (1);
       92 dcl  code_only_sw bit (1);
       93 dcl  found_one_sw bit (1);
       94 dcl  returns_sw bit (1);
       95 dcl ret_len fixed bin (21);
       96 dcl foo_len fixed bin (21);
       97 dcl ret_string_ptr ptr;
       98 dcl ret_data char (ret_len) based (ret_string_ptr);
       99 dcl sci_ptr ptr;
      100 
      101 
      102 returns_string:   entry (P_sci_ptr,P_amu_info_ptr, P_syserr_code, P_count, P_string_ptr,P_string_len,P_code);
      103 
      104 	ret_string_ptr = P_string_ptr;
      105 	ret_len = 0;
      106 	returns_sw = "1"b;
      107 	amu_info_ptr = P_amu_info_ptr;
      108 	sci_ptr = P_sci_ptr;
      109 	a_syserr_code = P_syserr_code;
      110 	severity = char(a_syserr_code);		/* Need this if we get to code_from_log		*/
      111 	code_only_sw = "1"b;
      112 	mess_count = P_count;
      113 	found_one_sw = "0"b;
      114 	goto code_from_data;
      115 
      116 check_if_found:
      117 	if returns_sw then P_string_len = ret_len;
      118 	P_code = 0;
      119 	return;
      120 
      121 data:
      122      entry (P_sci_ptr, P_amu_info_ptr, P_count, P_match_str, P_match_sw, P_expand_sw, P_severity, P_code);
      123 	amu_info_ptr = P_amu_info_ptr;		
      124 	sci_ptr = P_sci_ptr;
      125           severity = substr(P_severity,1);
      126 	code_only_sw,returns_sw = "0"b;
      127 	mess_count = P_count;
      128 
      129 code_from_data:
      130 	
      131 	wmess_ptr = null ();
      132           on condition(cleanup) begin;
      133 	     if wmess_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, wmess_ptr);
      134 	     end;
      135 
      136 	data_area_ptr = amu_$definition_ptr (amu_info_ptr, "syserr_data", "wired_log_area", def_code);
      137 	head_size = size (wlog_header);
      138 	wlog_ptr = addr (w_header);
      139 	segno = fixed (baseno (data_area_ptr), 17);
      140 	offset = fixed (rel (data_area_ptr), 18);
      141 	range = head_size;
      142 	call amu_$do_translation (amu_info_ptr, segno, wlog_ptr, offset, range, code);
      143 	if code ^= 0 then do;
      144 	     if returns_sw then P_string_len = ret_len;
      145 	     P_code = code;
      146 	     return;
      147 	     end;
      148 	if wlog.count = 0 then do;
      149 	     if code_only_sw then goto code_from_log;
      150 	     call ioa_ ("No entries in syserr_data (segment #^o).", segno);
      151 	     goto check_if_found;
      152 	     end;
      153 
      154 	call ssu_$get_temp_segment (sci_ptr,"azm-syserr_data", wmess_ptr);
      155 	offset = offset + head_size;
      156 	range = fixed (wlog.head.bsize, 18);
      157 	call amu_$do_translation (amu_info_ptr, segno, wmess_ptr, offset, range, code);
      158 	if code ^= 0 then do;
      159 	     if returns_sw then P_string_len = ret_len;
      160 	     P_code = code;
      161 	     if wmess_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, wmess_ptr);	     
      162 	     return;
      163 	     end;
      164 
      165 	argp = addr (auto_parg);			/* Get pointer to argument list */
      166 	parg.iocbp = iox_$user_output;		/* Data is written here */
      167 	parg.prev_time = "";			/* Clear previous time field */
      168 	if code_only_sw then do;
      169 	     parg.bin_sw = "0"b;
      170 	     parg.octal_sw = "0"b;
      171 	end;
      172 	else do;
      173 	     parg.bin_sw = P_expand_sw;
      174 	     parg.octal_sw = P_expand_sw;
      175 	end;
      176 	parg.pad = "0"b;				/* Be neat */
      177 	parg.linelen = get_line_length_$switch (iox_$user_output, code);
      178 						/* Need length of line */
      179 	if code ^= 0 then parg.linelen = 132;		/* Assume printer if error */
      180 
      181 	if ^code_only_sw then
      182 	     call ioa_ ("There ^[are^]^[is^] ^d message^[s^] in syserr_data (segment #^o).", (wlog.count > 1),
      183 	     (wlog.count = 1), wlog.count, (wlog.count > 1), segno);
      184 
      185           if mess_count > wlog.count | mess_count <=0 then mess_count = wlog.count;
      186 	do i = 1 to mess_count;
      187 	     if wmess.text_len = 0 then goto skip;
      188 	     new_time = datm (addr (wmess.time));
      189 	     if code_only_sw then do;
      190 		if wmess.code ^= a_syserr_code then go to skip;
      191 		syserr_msgp = addr (wmess.seq_num);
      192 		if returns_sw then do;
      193 		     ret_len = ret_len + syserr_msg.text_len + 1;
      194 		     call ioa_$rs ("^a ",ret_data,foo_len,
      195 			substr(syserr_msg.text,1, syserr_msg.text_len));
      196 		     goto skip;
      197 		end;
      198 		text = syserr_msg.text;
      199 		msg_printed = "0"b;
      200 		found_one_sw = "1"b;
      201 		goto ok_to_print_data;
      202 	     end;
      203 	     
      204 	     if P_match_str ^= "" then do;
      205 	        if index (substr (wmess.text, 1, wmess.text_len), P_match_str) = 0 then do;
      206 
      207 	           if P_match_sw then go to skip;
      208 		 end;
      209 	        else if ^P_match_sw then goto skip;   /* excluding */
      210 	        end;
      211 
      212 	     if wmess.code > a_syserr_code then go to skip;
      213 	     msg_printed = "0"b;
      214 	     syserr_msgp = addr (wmess.seq_num);
      215 	     text = syserr_msg.text;
      216 	     if syserr_msg.data_code = SB_hw_fault & syserr_msg.data_size > 0 then
      217 		if P_expand_sw then do;
      218 		   call display_hw_fault (addr (syserr_msg.data));
      219 		   msg_printed = "1"b;
      220 		   end;
      221 ok_to_print_data:	     
      222 	     parg.msgp = addr (wmess.seq_num);
      223 	     parg.textp = addr (text);
      224 	     parg.textl = syserr_msg.text_len;
      225 	     parg.printp = addr (text);
      226 	     parg.printl = syserr_msg.text_len;
      227 
      228 	     if ^msg_printed then call print_syserr_msg_ (argp, code);
      229 
      230 	     if code ^= 0 then do;
      231 		if returns_sw then P_string_len = ret_len;
      232 		P_code = code;
      233 		return;
      234 		end;
      235 skip:
      236 	     parg.prev_time = new_time;
      237 	     wmess_ptr = addr (wmess.data (wmess.data_size + 1));
      238 
      239 	end;
      240           if wmess_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, wmess_ptr);
      241 	if returns_sw then P_string_len = ret_len;
      242 	P_code = 0;
      243 	if code_only_sw then goto code_from_log;
      244 
      245 EXIT_DATA:
      246 	return;					/* end of azm_syserr_$data  */
      247 
      248 
      249 log:
      250      entry (P_sci_ptr, P_amu_info_ptr, P_count, P_match_str, P_match_sw, P_expand_sw, P_severity, P_code);
      251 
      252           amu_info_ptr = P_amu_info_ptr;
      253           sci_ptr = P_sci_ptr;
      254           severity = substr(P_severity,1);
      255           code_only_sw,returns_sw = "0"b;
      256 
      257 code_from_log:
      258           mess_count = P_count;
      259 
      260           hardcore_cur_ptr = addr (current_hardcore);
      261           call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      262 
      263           call ioa_ ("^/Syserr messages from log partition:^/");
      264 
      265           call print_log_partition ();
      266 
      267 	if returns_sw then P_string_len = ret_len;
      268           P_code = code;
      269           return;
      270 
      271 
      272 /* This procedure is responsible for printing messages from the log partition.
      273*   I am not proud of this implementation; it is not very flexible, it works by
      274*   calling the command, possibly producing unexpected results, and is in
      275*   general not very pretty. On the other hand, what it has to recommend it
      276*   is that it works. I chose this approach because the interface from azm is
      277*   itself not very flexible, and I didn't want to change that right at this
      278*   moment. Ultimately, of course, the AZM log requests should just be direct
      279*   interfaces to print_sys_log, and do no processing of their own. For the
      280*   moment, though, that's too awkward, so instead we settle for this kludge.
      281*
      282*   It works by copying the one or two log segments in use into temp segments,
      283*   then creating links to those temp segments in the process dir, and calling
      284*   print_sys_log to print the log family defined by those links to temp segs.
      285*   It has various cases of calling print_sys_log depending on the options
      286*   passed in from the AZM request.
      287*   */
      288 
      289 print_log_partition:
      290      procedure ();
      291 
      292 declare 1 auto_syserr_log_data aligned like syserr_log_data automatic;
      293 declare 1 log_seg (2) aligned,
      294           2 segno fixed bin,
      295           2 name char (32) unaligned,
      296           2 pathname char (168) unaligned,
      297           2 copy_ptr pointer,
      298           2 link_dname char (168) unaligned,
      299           2 link_ename char (32) unaligned;
      300 
      301 declare   syserr_log_data_segno fixed bin;
      302 declare   family_name char (32);
      303 declare   log_path char (168);
      304 declare   match_arg char (32);
      305 declare   expand_arg char (32);
      306  declare   delete_$path entry (char (*), char (*), bit (6), char (*), fixed bin (35));
      307 declare   get_pdir_ entry () returns (char (168));
      308 declare   hcs_$fs_get_path_name entry (pointer, char (*), fixed bin, char (*), fixed bin (35));
      309 declare   hcs_$append_link entry (char (*), char (*), char (*), fixed bin (35));
      310 declare   log_segment_$last_message_info entry (pointer, fixed bin (35), fixed bin (18), fixed bin (35));
      311 declare   pathname_ entry (char (*), char (*)) returns (char (168));
      312 declare    unique_chars_ entry (bit (*)) returns (char (15));
      313 
      314 declare   print_sys_log entry options (variable);
      315 
      316 /*  */
      317 
      318           log_seg.copy_ptr (*) = null ();
      319           log_seg.pathname (*) = "";
      320           log_seg.link_ename (*) = "";
      321           log_seg.link_dname (*) = "";
      322 
      323           on condition (cleanup)
      324                call clean_up_print_log_partition ();
      325 
      326           syserr_log_data_ptr = addr (auto_syserr_log_data);
      327 
      328           call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp,
      329                "syserr_log_data", syserr_log_data_segno, code);
      330           if (code ^= 0) then goto ERROR_RETURN;
      331 
      332           call amu_$do_translation (amu_info_ptr,
      333                syserr_log_data_segno, syserr_log_data_ptr, 0, size (syserr_log_data), code);
      334           if (code ^= 0) then goto ERROR_RETURN;
      335 
      336           if (syserr_log_data.live_log ^= 1) & (syserr_log_data.live_log ^= 2) then do;
      337                call ioa_ ("No active syserr log segment in syserr_log_data.");
      338                code = 0;
      339                goto ERROR_RETURN;
      340                end;
      341 
      342           family_name = unique_chars_ (""b);
      343           call get_log_segment (syserr_log_data.live_log, family_name);
      344 
      345           if (syserr_log_data.swap_time ^= 0) then do;      /* Other one isn't empty */
      346                family_name = rtrim (family_name) || ".19841214.164821";
      347                call get_log_segment ((3 - syserr_log_data.live_log),
      348                     (rtrim (family_name) || ".19841214.214821"));
      349                end;
      350 
      351           log_path = pathname_ (log_seg.link_dname (syserr_log_data.live_log),
      352                log_seg.link_ename (syserr_log_data.live_log));
      353 
      354 	if P_match_sw then
      355 	     match_arg = "-match";
      356 	else match_arg = "-exclude";
      357 
      358 	if P_expand_sw then
      359 	     expand_arg = "-expand";
      360 	else expand_arg = "-no_expand";
      361 
      362           if (mess_count > 0) then
      363                if (P_match_str ^= "") then
      364                     call print_sys_log (log_path, "-reverse", "-no_header", "-date_format", "", expand_arg, 
      365 		     "-severity", severity, "-last", char (mess_count), match_arg, substr (P_match_str, 1));
      366                else call print_sys_log (log_path, "-reverse", "-no_header", "-date_format", "", expand_arg,
      367 		     "-severity", severity, "-last", char (mess_count));
      368           else
      369                if (substr (P_match_str, 1) ^= "") then
      370                     call print_sys_log (log_path, "-reverse", "-no_header", "-date_format", "", expand_arg, 
      371 		     "-severity", severity, match_arg, substr (P_match_str, 1));
      372                else call print_sys_log (log_path, "-reverse", "-no_header", "-date_format", "", expand_arg, 
      373 		"-severity", severity);
      374 
      375           code = 0;                                         /* Indicate success */
      376 
      377 ERROR_RETURN:
      378           call clean_up_print_log_partition ();
      379 
      380           return;
      381 
      382 /*  */
      383 
      384 get_log_segment:
      385      procedure (P_idx, P_link_name);
      386 
      387 declare   P_idx fixed bin parameter;
      388 declare   P_link_name char (*) parameter;
      389 
      390 declare   log_name char (32);
      391 declare   last_offset fixed bin (18);
      392 declare   dname char (168);
      393 declare   ename char (32);
      394 
      395 /* This procedure copies a syserr log segment into a temp segment, and
      396*   makes a link to that temp segment in order to use it as input to
      397*   print_sys_log. First, it determines the log name, acquires the temp
      398*   segment, and records its pathname. */
      399 
      400 
      401           if (P_idx = 1) then
      402                log_name = "syserr_log_laurel";
      403           else log_name = "syserr_log_hardy";
      404 
      405           call ssu_$get_temp_segment (sci_ptr, ("azm-" || log_name), log_seg.copy_ptr (P_idx));
      406 
      407           call hcs_$fs_get_path_name (log_seg.copy_ptr (P_idx), dname, (0), ename, code);
      408           if (code ^= 0) then goto ERROR_RETURN;
      409 
      410           log_seg.pathname (P_idx) = pathname_ (dname, ename);
      411 
      412 /* Next, it finds the segment in the dump address space */
      413 
      414           call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp,
      415                (log_name), log_seg.segno (P_idx), code);
      416           if (code ^= 0) then goto ERROR_RETURN;
      417 
      418 /* Now, copy the contents of the header, figure out how much is actually
      419*   in use, and then copy the whole of the in-use object. */
      420 
      421           call amu_$do_translation (amu_info_ptr,
      422                log_seg.segno (P_idx), log_seg.copy_ptr (P_idx),
      423                0, size (log_segment_header), code);
      424           if (code ^= 0) then goto ERROR_RETURN;
      425 
      426           log_segment_ptr = log_seg.copy_ptr (P_idx);
      427           call log_segment_$last_message_info (log_segment_ptr, (0), last_offset, code);
      428           if (code ^= 0) then goto ERROR_RETURN;
      429 
      430           if (last_offset <= size (log_segment_header)) then
      431                return;
      432 
      433           call amu_$do_translation (amu_info_ptr, log_seg.segno (P_idx),
      434                addrel (log_seg.copy_ptr (P_idx), size (log_segment_header)),
      435                size (log_segment_header),
      436                (last_offset - size (log_segment_header)), code);
      437           if (code ^= 0) then goto ERROR_RETURN;
      438 
      439           log_seg.link_dname (P_idx) = get_pdir_ ();
      440           log_seg.link_ename (P_idx) = P_link_name;
      441           call hcs_$append_link (log_seg.link_dname (P_idx),
      442                log_seg.link_ename (P_idx), log_seg.pathname (P_idx), code);
      443           if (code ^= 0) then goto ERROR_RETURN;
      444 
      445           return;
      446           end get_log_segment;
      447 
      448 /*  */
      449 
      450 clean_up_print_log_partition:
      451      procedure ();
      452 
      453 
      454           if (log_seg.link_dname (1) ^= "") then
      455                call delete_$path (log_seg.link_dname (1), log_seg.link_ename (1),
      456                     "000010"b, "", (0));
      457 
      458           if (log_seg.link_dname (2) ^= "") then
      459                call delete_$path (log_seg.link_dname (2), log_seg.link_ename (2),
      460                     "000010"b, "", (0));
      461 
      462           if (log_seg.copy_ptr (1) ^= null ()) then
      463                call ssu_$release_temp_segment (sci_ptr, log_seg.copy_ptr (1));
      464 
      465           if (log_seg.copy_ptr (2) ^= null ()) then
      466                call ssu_$release_temp_segment (sci_ptr, log_seg.copy_ptr (2));
      467 
      468           return;
      469           end clean_up_print_log_partition;
      470 
      471           end print_log_partition;
      472 datm:
      473      proc (tp) returns (char (24) aligned);
      474 dcl  tp ptr;					/* pointer to time value to convert */
      475 dcl  timcv fixed bin (71);
      476 dcl  timein (2) fixed bin (35) based (tp);
      477 dcl  timeint (2) fixed bin (35) based (addr (timcv));
      478 dcl  timout char (24);
      479 	timeint = timein;				/* Copy time value to assure even boundary */
      480 	call date_time_ (timcv, timout);
      481 	return (timout);
      482      end datm;
      483 
      484 display_hw_fault:
      485      proc (fault_msgp);
      486 
      487 dcl  hr_ptr ptr;
      488 dcl  fault_msgp ptr;
      489 dcl  my_mcp ptr;
      490 dcl  1 a_arg_bits_def like arg_bits_def;
      491 dcl  1 fault_msg aligned,
      492        2 mcx like mc aligned;
      493 
      494 dcl  1 fault_msg1 aligned based (fault_msgp),
      495        2 mcy like mc aligned,
      496        2 hisregs (128) bit (36) aligned;
      497 
      498 
      499 /* set up to display all MC data */
      500 
      501 	a_arg_bits_def.dump, a_arg_bits_def.mc_stored, a_arg_bits_def.long = "0"b;
      502 	a_arg_bits_def.all = "1"b;
      503 	arg_bits_ptr = addr (a_arg_bits_def);
      504 	mcp = fault_msgp;
      505 	hr_ptr = addr (fault_msg1.hisregs);
      506 
      507 /* Copy the data over to auto. This is necessary as the PRs in syserr are
      508*   not on even word boundaries. */
      509 
      510 	mcx = mc;
      511 	unspec (mcx.prs) = unspec (mc.prs);
      512 	my_mcp = addr (fault_msg);
      513 	call azm_display_mc_ (sci_ptr, amu_info_ptr, my_mcp, arg_bits_ptr, code);
      514 
      515 	call ioa_ ("^/History Register Data:^/");
      516 	call amu_$hranl (hr_ptr, null, "0"b);
      517 	call ioa_ ("^/");
      518 	msgs_printed = msgs_printed + 1;
      519 	return;
      520      end display_hw_fault;
      521 
      522 
  1     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  1     2 
  1     3 dcl 1 amu_info aligned based (amu_info_ptr),
  1     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  1     5     2 flags aligned,
  1     6       3 early_dump bit(1) unal,
  1     7       3 pad  bit(35) unal,
  1     8     2 type fixed bin unal,				/* One of the types below */
  1     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  1    10     2 chain,					/* a chain of all the amu_info's which exist */
  1    11       3 prev pointer unaligned,
  1    12       3 next pointer unaligned,
  1    13 
  1    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  1    15 
  1    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  1    17 						/*   SEE: amu_translation.incl.pl1 */
  1    18     2 fdump_info_ptr pointer, 			
  1    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  1    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  1    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  1    22 						/* See: amu_old_uid_table			*/
  1    23 	
  1    24 
  1    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  1    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  1    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  1    28 						/*   SEE: amu_copy_info.incl.pl1 */
  1    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  1    30 						/*   SEE: amu_process_info.incl.pl1 */
  1    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  1    32 
  1    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  1    34 
  1    35     2 error_info,					/* various info about how amu_error_ is to behave */
  1    36       3 error_flags aligned,
  1    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  1    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  1    39         4 pad bit (34) unaligned,
  1    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  1    41     2 definitions_info_ptr ptr;
  1    42 
  1    43 dcl  amu_area area based (amu_info.area_ptr);
  1    44 
  1    45 dcl  amu_info_ptr pointer;
  1    46 
  1    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  1    48      FDUMP_PROCESS_TYPE	init (1038),
  1    49      ONLINE_TYPE		init (1039),
  1    50      ONLINE_PROCESS_TYPE	init (1040),
  1    51      NETWORK_FDUMP_TYPE	init (1041),
  1    52      NETWORK_ONLINE_TYPE	init (1042),
  1    53      SAVED_PROC_TYPE	init (1043),
  1    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  1    55 
  1    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  1    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  1    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  1    59 
  1    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  1    61 
  1    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      523 
      524 
  2     1 /* BEGIN INCLUDE FILE ... syserr_log_dcls.incl.pl1 ... 84-08-17 ... W. Olin Sibert */
  2     2 /* Modified 1984-12-10, BIM: changed to a fast lock, added error count. */
  2     3 
  2     4 /* The syserr_log_data segment, made reverse-deciduous in >sl1, overlays the
  2     5*   first page of the LOG partition, and contains control information about
  2     6*   the other syserr_log segments. */
  2     7 
  2     8 declare   syserr_log_data$    fixed bin external static;
  2     9 declare   syserr_log_data_ptr pointer;
  2    10 
  2    11 declare 1 syserr_log_data     aligned based (syserr_log_data_ptr),
  2    12           2 version           char (8) unaligned,           /* SYSERR_LOG_DATA_V1 */
  2    13           2 old_init_word     char (4) unaligned,           /* Overlays slog.head.init_word ("INIT") */
  2    14 	2 pad003    	bit (1) aligned,
  2    15 
  2    16           2 live_log          fixed bin,                    /* Identifier of live log (#1 or #2) */
  2    17 	2 pad001		bit (1) aligned,
  2    18           2 error_count       fixed bin (35),               /* errors copying the log */
  2    19           2 swap_time         fixed bin (71),               /* Time of last log swap; zero if other_log_empty */
  2    20 
  2    21           2 messages_copied   fixed bin (35),               /* A meter */
  2    22           2 messages_lost     fixed bin (35),               /* Messages not copied because logs full */
  2    23 
  2    24           2 log_start (2)     fixed bin,                    /* Offset of each log segment in the partition */
  2    25           2 log_size (2)      fixed bin,                    /* Number of pages in each log segment */
  2    26 
  2    27           2 per_bootload,                                   /* Ramaining structure is reinitialized at each boot */
  2    28             3 log_ptr (2) pointer,                          /* Pointer to the three segments in the partition */
  2    29 
  2    30             3 log_name (2) char (32) unaligned,             /* Current names of log segments (by syserr_seg_manager) */
  2    31             3 log_dir char (168) unaligned,                 /* Parent directory */
  2    32 
  2    33             3 lock		aligned,
  2    34 	    4 pid		bit (36) aligned,             /* Standard format wait lock, used when updating log */
  2    35               4 event_id      fixed bin (35),
  2    36               4 notify_requested 
  2    37 	                    bit (1) unaligned,
  2    38 	    4 pad           bit (35) unaligned,
  2    39             3 take_a_fault    bit (1) aligned,              /* Forces a fault if on, for testing fault recovery */
  2    40             3 test_mode       bit (1) aligned,              /* Running in outer-ring test mode */
  2    41 
  2    42             3 copy_disabled   bit (1) aligned,              /* No more messages being copied into live log */
  2    43             3 drop_severity_5 bit (1) aligned,              /* No more severity 5 messages (log is 3/4 full) */
  2    44 	  3 wakeup_on_printable bit (1) aligned,	/* Console recovery: send wakeup for printable message */
  2    45 
  2    46             3 copy_threshold  fixed bin (18),               /* How often to copy to outer ring log segments */
  2    47             3 copy_channel    fixed bin (71),
  2    48             3 copy_process_id bit (36) aligned,
  2    49 
  2    50           2 pad fixed bin (71);                             /* Anything goes, as long as it's under a page */
  2    51 
  2    52 declare   SYSERR_LOG_DATA_V1 char (8) internal static options (constant) init ("syserr01");
  2    53 
  2    54 /* END INCLUDE FILE ... syserr_log_dcls.incl.p1l */
      525 
      526 
  3     1 /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  3     2 
  3     3 declare   log_segment_ptr               pointer;
  3     4 declare   log_segment_max_size          fixed bin (18);
  3     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
  3     6 
  3     7 
  3     8 declare 1 log_segment                   aligned based (log_segment_ptr),
  3     9           2 header                      aligned like log_segment_header,
  3    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
  3    11 
  3    12 
  3    13 declare 1 log_segment_header            aligned based,
  3    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
  3    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
  3    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
  3    17 
  3    18           2 limits,
  3    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
  3    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
  3    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
  3    22             3 last_time                 fixed bin (71),
  3    23 
  3    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
  3    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
  3    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
  3    27           2 max_size                    fixed bin (18),     /* Total words in data area */
  3    28 
  3    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
  3    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
  3    31                                                             /* detect all the dead listeners after a reboot */
  3    32           2 listener (25),                                  /* Processes waiting for messages in the log */
  3    33             3 process_id                bit (36) aligned,
  3    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
  3    35 
  3    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
  3    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
  3    38 
  3    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
  3    40 
  3    41 
  3    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
  3    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
  3    44 
  3    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
      527 
      528 
  4     1 /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  4     2 
  4     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  4     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  4     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  4     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  4     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  4     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  4     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  4    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  4    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  4    12 
  4    13 declare 1 log_message         aligned based (log_message_ptr),
  4    14           2 header            aligned like log_message_header,
  4    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  4    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  4    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  4    18 
  4    19 declare   log_message_ptr pointer;
  4    20 declare   log_message_text_lth fixed bin;
  4    21 declare   log_message_data_class_lth fixed bin;
  4    22 declare   log_message_data_lth fixed bin;
  4    23 
  4    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      529 
      530 
  5     1 /* BEGIN INCLUDE FILE  syserr_data.incl.pl1 */
  5     2 
  5     3 /* Created by  Bill Silver  on 01/03/73. */
  5     4 /* Modified September 1975 by Larry Johnson to add binary data */
  5     5 /* Modified March 1976 by Steve Webber for use with cds */
  5     6 /* Modified 1985-01-21 by EJ Sharpe: added wmess.process_id */
  5     7 /* Modified 1985-02-18 by Keith Loepere to break out headers. */
  5     8 
  5     9 /* This include file defines the syserr and log areas found in  syserr_data.cds
  5    10*   There is one lock that coordinates the use of all the data found in
  5    11*   syserr_data.cds.  NOTE, if this include file changes, syserr_data.cds
  5    12*   may also have to be changed. */
  5    13 
  5    14 dcl  syserr_data$syserr_area char (1) aligned external,
  5    15      syserr_data$wired_log_area char (1) aligned external;
  5    16 
  5    17 dcl  sd_ptr ptr,					/* Pointer to beginning of syserr_area. */
  5    18      wlog_ptr ptr,					/* Pointer to beginning of wired_log_area. */
  5    19      wmess_ptr ptr;					/* Pointer to a message entry in the wired log. */
  5    20 
  5    21 dcl 1 sd based (sd_ptr) aligned,			/* Overlay of syserr_data$syserr_area. */
  5    22     2 lock bit (36),				/* Locks all the data in syserr_data. */
  5    23     2 log_flag bit (1) unal,				/* ON => logging mechanism enabled. */
  5    24     2 char_type_flag bit (1) unal,			/* ON => ASCII,  OFF => BCD. */
  5    25     2 ocdcm_init_flag bit (1) unal,			/* ON => ocdcm_ has been initialized. */
  5    26     2 pad bit (33) unal,
  5    27     2 prev_text_written char (80);			/* Text of last message written */
  5    28 
  5    29 dcl 1 wlog based (wlog_ptr) aligned,			/* Overlay of syserr_data$wired_log_area. */
  5    30     2 head like wlog_header,				/* Wired log header. */
  5    31     2 buffer (wlog.head.bsize) bit (36);		/* Wired log buffer. */
  5    32 
  5    33 dcl 1 wlog_header based aligned,			/* WIRED LOG HEADER */
  5    34     2 bsize fixed bin,				/* Size of the wired log buffer in words.
  5    35*						   Defined in syserr_data.cds. */
  5    36     2 count fixed bin,				/* Num of message entries in wired log. */
  5    37     2 slog_ptr ptr,					/* Pointer to the paged log segment: syserr_log. */
  5    38     2 seq_num fixed bin (35),				/* Sequence number of last message logged. */
  5    39     2 next bit (18) unal,				/* Offset relative to base syserr_data */
  5    40 						/* Where next entry will go in wired log. */
  5    41     2 pad bit (18) unal;
  5    42 
  5    43 
  5    44 /* This is an overlay of a message entry that goes into the wired log.  Each message
  5    45*   entry corresponds to one syserr message. */
  5    46 
  5    47 dcl 1 wmess based (wmess_ptr) aligned,
  5    48     2 header aligned like wmess_header,
  5    49     2 text char (0 refer (wmess.text_len)),		/* Text of expanded message - kept in ASCII. */
  5    50     2 data (0 refer (wmess.data_size)) bit (36);		/* Binary data area */
  5    51 
  5    52 dcl 1 wmess_header based aligned,
  5    53     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  5    54     2 time fixed bin (71) unal,			/* Time message logged at */
  5    55     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  5    56     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  5    57     2 data_size fixed bin (11) unal,			/* Size of binary data */
  5    58     2 data_code fixed bin (11) unal,			/* Data code */
  5    59     2 pad bit (24) unal,
  5    60     2 process_id bit (36);				/* ID of process which wrote message */
  5    61 
  5    62 /* END INCLUDE FILE syserr_data.incl.pl1 */
      531 
      532 
  6     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  6     2 
  6     3 /* This include file has an ALM version, keep 'em in sync. */
  6     4 
  6     5 /* format: off */
  6     6 
  6     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  6     8*   to be examined by display_cpu_error. */
  6     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  6    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  6    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  6    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  6    13*		also changed some codes to "SB_unused_NN" - see line comments */
  6    14 
  6    15 /* In the future, these will be the only constants needed in this include
  6    16*file.  They are the binary data class strings for messages in the new format
  6    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  6    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  6    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  6    20 
  6    21 dcl (						/* include file name */
  6    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  6    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  6    24 SB_mos_data_class		init ("mos"),		/* scr */
  6    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  6    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  6    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  6    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  6    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  6    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  6    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  6    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  6    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  6    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  6    35 ) static internal char (16) varying options (constant);
  6    36 
  6    37 
  6    38 /************************
  6    39*Once the syserr$binary is replaced with something that takes real data classes
  6    40*and all system modules and tools are upgraded to use the new interface, the
  6    41*rest of this include file may be discarded.
  6    42*************************/
  6    43 
  6    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  6    45*   extended at any time. */
  6    46 
  6    47 dcl (
  6    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  6    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  6    50 SB_io_err		init (3),		SBL_io_err	init (5),
  6    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  6    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  6    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  6    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  6    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  6    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  6    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  6    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  6    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  6    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  6    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  6    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  6    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  6    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  6    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  6    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  6    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  6    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  6    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  6    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  6    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  6    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  6    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  6    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  6    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  6    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  6    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  6    78   ) internal static options (constant) fixed bin;
  6    79 
  6    80 
  6    81 /* The following array is a mapping of the old syserr$binary codes into the
  6    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  6    83*the binary data codes stored in the wired syserr log (see above) into the data
  6    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  6    85*is also used by syserr_log_util_ to translate the data classes back into the
  6    86*corresponding binary code (for tools not yet upgraded to deal with the new
  6    87*format log messages). */
  6    88 
  6    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  6    90 	init (	"io_status",		/* 1 */
  6    91 		"hwfault",		/* 2 */
  6    92 		"io_status",		/* 3 */
  6    93 		"unused_4",		/* 4 */
  6    94 		"mos",			/* 5 */
  6    95 
  6    96 		"unused_6",		/* 6 */
  6    97 		"unused_7",		/* 7 */
  6    98 		"unused_8",		/* 8 */
  6    99 		"unused_9",		/* 9 */ 
  6   100 		"unused_10",		/* 10 */
  6   101 
  6   102 		"segdamage",		/* 11 */
  6   103 		"unused_12",		/* 12 */
  6   104 		"segdamage",		/* 13 */
  6   105 		"unused_14",		/* 14 */
  6   106 		"unused_15",		/* 15 */
  6   107 
  6   108 		"segdamage",		/* 16 */
  6   109 		"voldamage",		/* 17 */
  6   110 		"unused_18",		/* 18 */
  6   111 		"mdc_del_uidpath",		/* 19 */
  6   112 		"io_status",		/* 20 */
  6   113 
  6   114 		"mmdam",			/* 21 */
  6   115 		"hwfault",		/* 22 */
  6   116 		"io_status",		/* 23 */
  6   117 		"mpc_poll",		/* 24 */
  6   118 		"fnp_poll",		/* 25 */
  6   119 
  6   120 		"config_deck",		/* 26 */
  6   121 		"vtoce",			/* 27 */
  6   122 		"access_audit",		/* 28 */
  6   123 		"unused_29",		/* 29 */
  6   124 		"unused_30",		/* 30 */
  6   125 		"unused_31",		/* 31 */
  6   126 		"unused_32",		/* 32 */
  6   127 		"unused_33",		/* 33 */
  6   128 		"unused_34",		/* 34 */
  6   129 		"ibm3270_mde",		/* 35 */
  6   130 		"unused_36"		/* 36 */
  6   131 	);
  6   132 
  6   133 
  6   134 /* format: on */
  6   135 
  6   136 /* These constants are used by various tools which analyze syserr messages and
  6   137*still call the old interface "syserr_log_util_". */
  6   138 
  6   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  6   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  6   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  6   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  6   143 
  6   144      dcl	   display_cpu_error_binary_defs (2) init (
  6   145 			      2,			/** SB_hw_fault */
  6   146 			      22			/** SB_verify_lock */
  6   147 			      ) internal static options (constant) fixed bin;
  6   148 
  6   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      533 
      534 
  7     1 /* Begin include file ..... print_syserr_msg_args.incl.pl1 */
  7     2 
  7     3 /* This include file defines a structure which is used as a parameter to call the
  7     4*   subroutine print_syserr_msg_ */
  7     5 
  7     6 /* Written January 1976 by Larry Johnson */
  7     7 
  7     8 dcl  argp ptr;					/* Pointer to structure */
  7     9 
  7    10 dcl 1 parg aligned based (argp),
  7    11     2 msgp ptr,					/* Pointer to syserr message */
  7    12     2 iocbp ptr,					/* Pointer to iocb to which data is written */
  7    13     2 textp ptr,					/* Pointer to real text of message */
  7    14     2 printp ptr,					/* Pointer to message to print */
  7    15     2 textl fixed bin,				/* Length of real text of message */
  7    16     2 printl fixed bin,				/* Length of message to print */
  7    17     2 linelen fixed bin,				/* Length to terminal line */
  7    18     2 prev_time char (24),				/* Time of last message */
  7    19     2 bin_sw bit (1) unal,				/* Set if binary data should be printed */
  7    20     2 octal_sw bit (1) unal,				/* Set if binary data should be printed in octal */
  7    21     2 pad bit (34) unal;
  7    22 
  7    23 
  7    24 /* Notes:
  7    25*
  7    26*   This include file defines 3 different  character string messages. The first is contained
  7    27*   in the syserr message pointed to by "msgp". The second is defined by "textp" and "textl".
  7    28*   The third is defined by "printp" and "printl". The print_syserr_msg_ subroutine never looks at
  7    29*   the text in the syserr message pointer to by "msgp". It always prints the message
  7    30*   defined by "printp" and "printl". This may be an "=". If bin_sw is "1"b and octal_sw is "0"b,
  7    31*   the subroutine requires the real text of the message which is defined by "textp" and
  7    32*   "textl" to determine how to interpret the binary data. These paramaters should
  7    33*   be set to the last non "=" message from the log. */
  7    34 
  7    35 /* End include file ..... print_syserr_msg_args.incl.pl1 */
      535 
      536 
  8     1 /* Begin include file ..... syserr_message.incl.pl1 */
  8     2 
  8     3 /* Format of a syserr message */
  8     4 
  8     5 /* Created October 1975 by Larry Johnson */
  8     6 
  8     7 dcl  syserr_msgp ptr;				/* Base for include file */
  8     8 
  8     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  8    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  8    11     2 time fixed bin (71) unal,			/* Time message logged at */
  8    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  8    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  8    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  8    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  8    16     2 pad bit (60) unal,				/* RESERVED! */
  8    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  8    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  8    19 
  8    20 
  8    21 /* End include file ..... syserr_message.incl.pl1 */
      537 
      538 
  9     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  9     2 
  9     3 /* This structure contains information about the hardcore supervisor address
  9     4*   space for an address translation. */
  9     5 
  9     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  9     7 
  9     8     2 pointers,					/* assorted pointers to various useful items */
  9     9       3 slt aligned,				/* SLT */
  9    10         4 fptr pointer unaligned,			/* address in foreign address space */
  9    11         4 lptr pointer unaligned,			/* location in local address space */
  9    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  9    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  9    14 
  9    15       3 sst aligned like hardcore_info.slt,		/* SST */
  9    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  9    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  9    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  9    19 
  9    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  9    21       3 prds fixed bin (15),				/* segno of PRDS */
  9    22       3 dseg fixed bin (15),				/* DSEG */
  9    23       3 pds fixed bin (15),				/* PDS */
  9    24       3 kst fixed bin (15),				/* KST */
  9    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  9    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  9    27 
  9    28     2 apt,					/* information about the APT */
  9    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  9    30       3 local_ptr pointer unaligned,
  9    31       3 count fixed bin,				/* number of APTEs */
  9    32       3 size fixed bin,				/* size of a single APTE */
  9    33 
  9    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  9    35 
  9    36     2 pad1 fixed bin;
  9    37 
  9    38 dcl hardcore_cur_ptr ptr;
  9    39 
  9    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  9    41     2 sltp ptr,
  9    42     2 sltntp ptr,
  9    43     2 defp ptr,
  9    44     2 sstp ptr,
  9    45     2 tc_datap ptr,
  9    46     2 sstntp ptr,
  9    47     2 uptp ptr;
  9    48 	
  9    49     
  9    50 
  9    51 
  9    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      539 
      540 
 10     1 /*  */
 10     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 10     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 10     4 /* Modified 07/07/76 by Morris for fault register data */
 10     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 10     6 /* Modified '82 to make values constant */
 10     7 
 10     8 /* words 0-15 pointer registers */
 10     9 
 10    10 dcl  mcp ptr;
 10    11 
 10    12 dcl 1 mc based (mcp) aligned,
 10    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 10    14    (2 regs,					/* registers */
 10    15       3 x (0:7) bit (18),				/* index registers */
 10    16       3 a bit (36),					/* accumulator */
 10    17       3 q bit (36),					/* q-register */
 10    18       3 e bit (8),					/* exponent */
 10    19       3 pad1 bit (28),
 10    20       3 t bit (27),					/* timer register */
 10    21       3 pad2 bit (6),
 10    22       3 ralr bit (3),				/* ring alarm register */
 10    23 
 10    24     2 scu (0:7) bit (36),
 10    25 
 10    26     2 mask bit (72),				/* mem controller mask at time of fault */
 10    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 10    28     2 errcode fixed bin (35),				/* fault handler's error code */
 10    29     2 fim_temp,
 10    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 10    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 10    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 10    33     2 fault_reg bit (36),				/* fault register */
 10    34     2 pad2 bit (1),
 10    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 10    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 10    37     2 fault_time bit (54),				/* time of fault */
 10    38 
 10    39     2 eis_info (0:7) bit (36)) unaligned;
 10    40 
 10    41 
 10    42 dcl (apx fixed bin init (0),
 10    43      abx fixed bin init (1),
 10    44      bpx fixed bin init (2),
 10    45      bbx fixed bin init (3),
 10    46      lpx fixed bin init (4),
 10    47      lbx fixed bin init (5),
 10    48      spx fixed bin init (6),
 10    49      sbx fixed bin init (7)) internal static options (constant);
 10    50 
 10    51 
 10    52 
 10    53 
 10    54 dcl  scup ptr;
 10    55 
 10    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 10    57 
 10    58 
 10    59 /*	WORD (0)		*/
 10    60 
 10    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 10    62       3 prr bit (3),				/* procedure ring register */
 10    63       3 psr bit (15),				/* procedure segment register */
 10    64       3 p bit (1),					/* procedure privileged bit */
 10    65 
 10    66     2 apu,					/* APPENDING UNIT STATUS */
 10    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 10    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 10    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 10    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 10    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 10    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 10    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 10    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 10    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 10    76       3 ptw bit (1),				/* Fetch of PTW */
 10    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 10    78       3 fap bit (1),				/* Fetch of final address paged */
 10    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 10    80       3 fabs bit (1),				/* Fetch of final address absolute */
 10    81 
 10    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 10    83 
 10    84 
 10    85 /*	WORD (1)		*/
 10    86 
 10    87     2 fd,						/* FAULT  DATA */
 10    88       3 iro bit (1),				/* illegal ring order */
 10    89       3 oeb bit (1),				/* out of execute bracket */
 10    90       3 e_off bit (1),				/* no execute */
 10    91       3 orb bit (1),				/* out of read bracket */
 10    92       3 r_off bit (1),				/* no read */
 10    93       3 owb bit (1),				/* out of write bracket */
 10    94       3 w_off bit (1),				/* no write */
 10    95       3 no_ga bit (1),				/* not a gate */
 10    96       3 ocb bit (1),				/* out of call bracket */
 10    97       3 ocall bit (1),				/* outward call */
 10    98       3 boc bit (1),				/* bad outward call */
 10    99       3 inret bit (1),				/* inward return */
 10   100       3 crt bit (1),				/* cross ring transfer */
 10   101       3 ralr bit (1),				/* ring alarm register */
 10   102       3 am_er bit (1),				/* associative memory fault */
 10   103       3 oosb bit (1),				/* out of segment bounds */
 10   104       3 paru bit (1),				/* processor parity upper */
 10   105       3 parl bit (1),				/* processor parity lower */
 10   106       3 onc_1 bit (1),				/* op not complete type 1 */
 10   107       3 onc_2 bit (1),				/* op not complete type 2 */
 10   108 
 10   109     2 port_stat,					/* PORT  STATUS */
 10   110       3 ial bit (4),				/* illegal action lines */
 10   111       3 iac bit (3),				/* illegal action channel */
 10   112       3 con_chan bit (3),				/* connect channel */
 10   113 
 10   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 10   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 10   116 
 10   117 
 10   118 /*	WORD (2)		*/
 10   119 
 10   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 10   121       3 trr bit (3),				/* temporary ring register */
 10   122       3 tsr bit (15),				/* temporary segment register */
 10   123 
 10   124     2 pad2 bit (9),
 10   125 
 10   126     2 cpu_no bit (3),				/* CPU number */
 10   127 
 10   128     2 delta bit (6),				/* tally modification DELTA */
 10   129 
 10   130 
 10   131 /*	WORD (3)		*/
 10   132 
 10   133     2 word3 bit (18),
 10   134 
 10   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 10   136       3 tsna,					/* Word 1 status */
 10   137         4 prn bit (3),				/* Word 1  PR  number */
 10   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 10   139       3 tsnb,					/* Word 2  status */
 10   140         4 prn bit (3),				/* Word 2  PR  number */
 10   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 10   142       3 tsnc,					/* Word 3  status */
 10   143         4 prn bit (3),				/* Word 3  PR  number */
 10   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 10   145 
 10   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 10   147 
 10   148 
 10   149 /* 	WORD (4)		*/
 10   150 
 10   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 10   152 
 10   153     2 ir,						/* INDICATOR  REGISTERS */
 10   154       3 zero bit (1),				/* zero indicator */
 10   155       3 neg bit (1),				/* negative indicator */
 10   156       3 carry bit (1),				/* carryry indicator */
 10   157       3 ovfl bit (1),				/* overflow indicator */
 10   158       3 eovf bit (1),				/* eponent overflow */
 10   159       3 eufl bit (1),				/* exponent underflow */
 10   160       3 oflm bit (1),				/* overflow mask */
 10   161       3 tro bit (1),				/* tally runout */
 10   162       3 par bit (1),				/* parity error */
 10   163       3 parm bit (1),				/* parity mask */
 10   164       3 bm bit (1),					/* ^bar mode */
 10   165       3 tru bit (1),				/* truncation mode */
 10   166       3 mif bit (1),				/* multi-word instruction mode */
 10   167       3 abs bit (1),				/* absolute mode */
 10   168       3 hex bit (1),				/* hexadecimal exponent mode */
 10   169       3 pad bit (3),
 10   170 
 10   171 
 10   172 /*	WORD (5)		*/
 10   173 
 10   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 10   175 
 10   176     2 cu,						/* CONTROL UNIT STATUS */
 10   177       3 rf bit (1),					/* on first cycle of repeat instr */
 10   178       3 rpt bit (1),				/* repeat instruction */
 10   179       3 rd bit (1),					/* repeat double instruction */
 10   180       3 rl bit (1),					/* repeat link instruciton */
 10   181       3 pot bit (1),				/* IT  modification */
 10   182       3 pon bit (1),				/* return type instruction */
 10   183       3 xde bit (1),				/* XDE from Even location */
 10   184       3 xdo bit (1),				/* XDE from Odd  location */
 10   185       3 poa bit (1),				/* operation preparation */
 10   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 10   187       3 its bit (1),				/* ITS modification */
 10   188       3 if bit (1),					/* fault occured during instruction fetch */
 10   189 
 10   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 10   191 
 10   192 
 10   193 /*	WORDS (6,7)	*/
 10   194 
 10   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 10   196 
 10   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 10   198 
 10   199 
 10   200 
 10   201 
 10   202 
 10   203 
 10   204 /*	ALTERNATE   SCU  DECLARATION		*/
 10   205 
 10   206 
 10   207 dcl 1 scux based (scup) aligned,
 10   208 
 10   209    (2 pad0 bit (36),
 10   210 
 10   211     2 fd,						/* GROUP II  FAULT DATA */
 10   212       3 isn bit (1),				/* illegal segment number */
 10   213       3 ioc bit (1),				/* illegal op  code  */
 10   214       3 ia_am bit (1),				/* illegal address - modifier */
 10   215       3 isp bit (1),				/* illegal slave  procedure */
 10   216       3 ipr bit (1),				/* illegal procedure */
 10   217       3 nea bit (1),				/* non existent address */
 10   218       3 oobb bit (1),				/* out of bounds */
 10   219       3 pad bit (29),
 10   220 
 10   221     2 pad2 bit (36),
 10   222 
 10   223     2 pad3a bit (18),
 10   224 
 10   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 10   226       3 prn bit (3),				/* PR  number */
 10   227       3 prv bit (1),				/* PR  valid bit */
 10   228 
 10   229     2 pad3b bit (6)) unaligned,
 10   230 
 10   231     2 pad45 (0:1) bit (36),
 10   232 
 10   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 10   234 
 10   235 
 10   236 
 10   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      541 
      542 
 11     1 /* Begin amu_mc.incl.pl1 */
 11     2 
 11     3 dcl number_val_args fixed bin (17) init (23) static options (constant);
 11     4 
 11     5 dcl valid_mc_arg (24) char (8) init 
 11     6 ("-dump",		    /*  mc from bos dump */
 11     7 "-lg",		    /*  all of the info stored at the given pointer */
 11     8 "-scu","-ppr","-tpr","-inst",   /*  scu data or trs or psr (if scu then not psr nor tsr) */
 11     9 "-reg",		    /*  basic ou regs */
 11    10 "-misc","-code","-flt","-tm", /* misc line of mc data if misc then not others */
 11    11 "-eis",		    /* eis info if MIF flag in scu_data */	
 11    12 "-prs","-pr0","-pr1","-pr2","-pr3","-pr4","-pr5","-pr6","-pr7", /* pointer regs if prs then not the others */
 11    13 "-vbf","-oct","-set")  /* control args */
 11    14  static options (constant);
 11    15 
 11    16 /* the next structuers all all the same real data word and a dcl'ed in
 11    17*     many ways to make the code easer to write and undersand, only time
 11    18*     will tell if this is the correct end result. If any are changed they 
 11    19*     all must by changed, The bit order must corespond to valid_mc_arg */
 11    20 
 11    21 
 11    22 	
 11    23 dcl 1 arg_bits based (arg_bits_ptr) aligned,
 11    24     2 request_arg(number_val_args) bit (1) unal;
 11    25 
 11    26 dcl 1 what_prs based (arg_bits_ptr) aligned,
 11    27     2 pad bit (13) unal,
 11    28     2 pregs (0:7) bit (1) unal,
 11    29     2 padr bit (16);
 11    30 	
 11    31 
 11    32 dcl 1 arg_bits_def based (arg_bits_ptr),
 11    33     2 dump bit (1) unal,
 11    34     2 all bit (1) unal,
 11    35     2 scu bit (1) unal,
 11    36     2 ppr bit (1) unal,
 11    37     2 tpr bit (1) unal,
 11    38     2 inst bit (1) unal,
 11    39     2 regs bit (1) unal,
 11    40     2 xreg (0:7) bit (1) unal,
 11    41     2 areg bit (1) unal,
 11    42     2 qreg bit (1) unal,
 11    43     2 mis bit (1) unal,
 11    44     2 mc_err bit (1) unal,
 11    45     2 flt bit (1) unal,
 11    46     2 tm bit (1) unal,
 11    47     2 eis bit (1) unal,
 11    48     2 prs bit (1) unal,
 11    49     2 pr (0:7) bit (1) unal,
 11    50     2 long bit (1) unal,
 11    51     2 set_ptr bit (1) unal,
 11    52     2 mc_stored bit (1) unal,
 11    53     2 rest_bits bit (1) unal;   /* bits to fill out the word **/
 11    54 	
 11    55 	
 11    56 
 11    57 dcl arg_bits_ptr ptr;
 11    58 	
 11    59 /* End amu_mc.incl.pl1 */
      543 
      544 
      545 
      546 
      547      end azm_syserr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/28/87  0930.0  azm_syserr_.pl1                   >spec>install>MR12.1-1049>azm_syserr_.pl1
523          1    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
525          2    01/06/85  1422.2  syserr_log_dcls.incl.pl1          >ldd>include>syserr_log_dcls.incl.pl1
527          3    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
529          4    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
531          5    03/08/85  0852.7  syserr_data.incl.pl1              >ldd>include>syserr_data.incl.pl1
533          6    03/15/85  0953.1  syserr_binary_def.incl.pl1        >ldd>include>syserr_binary_def.incl.pl1
535          7    06/22/76  1355.6  print_syserr_msg_args.incl.pl1    >ldd>include>print_syserr_msg_args.incl.pl1
537          8    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
539          9    11/20/84  0854.8  amu_hardcore_info.incl.pl1        >ldd>include>amu_hardcore_info.incl.pl1
541         10    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
543         11    09/22/83  1102.5  amu_mc.incl.pl1                   >ldd>include>amu_mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_amu_info_ptr                         parameter       pointer                  dcl 36 ref 102 107 121 123 249 252
P_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 102 118* 121 145* 160* 232* 242* 249
                                                                                  268*
P_count                                parameter       fixed bin(35,0)          dcl 39 ref 102 112 121 127 249 257
P_expand_sw                            parameter       bit(1)                   unaligned dcl 42 ref 121 173 174 216 249 358
P_idx                                  parameter       fixed bin(17,0)          dcl 387 ref 384 401 405 407 410 414 421 421 426 433
                                                                                  433 433 439 440 441 441 441
P_link_name                            parameter       char                     unaligned dcl 388 ref 384 440
P_match_str                            parameter       varying char             dcl 40 ref 121 204 205 249 362 362 362 368 368 368
P_match_sw                             parameter       bit(1)                   unaligned dcl 41 ref 121 207 209 249 354
P_sci_ptr                              parameter       pointer                  dcl 37 ref 102 108 121 124 249 253
P_severity                             parameter       varying char             dcl 44 ref 121 125 249 254
P_string_len                           parameter       fixed bin(21,0)          dcl 45 set ref 102 116* 144* 159* 231* 241* 267*
P_string_ptr                           parameter       pointer                  dcl 46 ref 102 104
P_syserr_code                          parameter       fixed bin(17,0)          dcl 43 ref 102 109
SB_hw_fault                            constant        fixed bin(17,0)          initial dcl 6-47 ref 216
a_arg_bits_def                  000506 automatic       structure                level 1 packed unaligned dcl 490 set ref 503
a_syserr_code                   000106 automatic       fixed bin(17,0)          dcl 75 set ref 109* 110 190 212
addr                                                   builtin function         dcl 66 ref 138 165 188 188 191 214 218 218 221 223
                                                                                  225 237 260 326 479 503 505 512
addrel                                                 builtin function         dcl 66 ref 433 433
all                       0(01) 000506 automatic       bit(1)                   level 2 packed unaligned dcl 490 set ref 502*
amu_$definition_ptr             000014 constant        entry                    external dcl 51 ref 136
amu_$do_translation             000016 constant        entry                    external dcl 52 ref 142 157 332 421 433
amu_$hardcore_info_set_cur_ptrs 000010 constant        entry                    external dcl 49 ref 261
amu_$hranl                      000042 constant        entry                    external dcl 62 ref 516
amu_$slt_search_seg_num         000012 constant        entry                    external dcl 50 ref 328 414
amu_info_ptr                    000420 automatic       pointer                  dcl 1-45 set ref 107* 123* 136* 142* 157* 252* 261*
                                                                                  332* 421* 433* 513*
arg_bits_def                           based           structure                level 1 packed unaligned dcl 11-32
arg_bits_ptr                    000442 automatic       pointer                  dcl 11-57 set ref 503* 513*
argp                            000432 automatic       pointer                  dcl 7-8 set ref 165* 166 167 169 170 173 174 176 177
                                                                                  179 221 223 224 225 226 228* 235
auto_parg                       000160 automatic       structure                level 1 dcl 87 set ref 165
auto_syserr_log_data            000100 automatic       structure                level 1 dcl 292 set ref 326
azm_display_mc_                 000020 constant        entry                    external dcl 53 ref 513
baseno                                                 builtin function         dcl 66 ref 139
bin_sw                   21            based           bit(1)                   level 2 packed unaligned dcl 7-10 set ref 169* 173*
bsize                                  based           fixed bin(17,0)          level 3 dcl 5-29 ref 156
char                                                   builtin function         dcl 66 ref 110 362 362 366 366
cleanup                         000100 stack reference condition                dcl 71 ref 132 323
code                            000127 automatic       fixed bin(35,0)          dcl 82 in procedure "azm_syserr_" set ref 142* 143
                                                                                  145 157* 158 160 177* 179 228* 230 232 268 328*
                                                                                  330 332* 334 338* 375* 407* 408 414* 416 421* 424
                                                                                  427* 428 433* 437 441* 443 513*
code                      3            based           fixed bin(11,0)          level 3 in structure "wmess" packed unaligned
                                                                                  dcl 5-47 in procedure "azm_syserr_" ref 190 212
code_only_sw                    000406 automatic       bit(1)                   unaligned dcl 92 set ref 111* 126* 149 168 181 189
                                                                                  243 255*
copy_ptr                 64     000236 automatic       pointer                  array level 2 dcl 293 set ref 318* 405* 407* 421*
                                                                                  426 433 433 462 462* 465 465*
count                     1            based           fixed bin(17,0)          level 3 dcl 5-29 set ref 148 181 181 181* 181 185
                                                                                  185
current_hardcore                000132 automatic       structure                level 1 unaligned dcl 84 set ref 260
data                                   based           bit(36)                  array level 2 in structure "syserr_msg" dcl 8-9
                                                                                  in procedure "azm_syserr_" set ref 218 218
data                                   based           bit(36)                  array level 2 in structure "wmess" dcl 5-47
                                                                                  in procedure "azm_syserr_" set ref 237
data_area_ptr                   000110 automatic       pointer                  dcl 76 set ref 136* 139 140
data_code                 4            based           fixed bin(11,0)          level 2 packed unaligned dcl 8-9 ref 216
data_size                 3(24)        based           fixed bin(11,0)          level 3 in structure "wmess" packed unaligned
                                                                                  dcl 5-47 in procedure "azm_syserr_" ref 237
data_size                 3(24)        based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 8-9 in procedure "azm_syserr_" ref 216
date_time_                      000040 constant        entry                    external dcl 61 ref 480
def_code                        000130 automatic       fixed bin(35,0)          dcl 82 set ref 136*
delete_$path                    000044 constant        entry                    external dcl 306 ref 454 458
dname                           000111 automatic       char(168)                unaligned dcl 392 set ref 407* 410*
dump                            000506 automatic       bit(1)                   level 2 packed unaligned dcl 490 set ref 501*
ename                           000163 automatic       char(32)                 unaligned dcl 393 set ref 407* 410*
expand_arg                      000651 automatic       char(32)                 unaligned dcl 305 set ref 358* 360* 362* 366* 368*
                                                                                  372*
family_name                     000557 automatic       char(32)                 unaligned dcl 302 set ref 342* 343* 346* 346 347
fault_msg                       000510 automatic       structure                level 1 dcl 491 set ref 512
fault_msg1                             based           structure                level 1 dcl 494
fault_msgp                             parameter       pointer                  dcl 488 ref 484 504 505
fixed                                                  builtin function         dcl 66 ref 139 140 156
foo_len                         000412 automatic       fixed bin(21,0)          dcl 96 set ref 194*
found_one_sw                    000407 automatic       bit(1)                   unaligned dcl 93 set ref 113* 200*
get_line_length_$switch         000036 constant        entry                    external dcl 60 ref 177
get_pdir_                       000046 constant        entry                    external dcl 307 ref 439
hardcore_cur                           based           structure                level 1 unaligned dcl 9-40
hardcore_cur_ptr                000436 automatic       pointer                  dcl 9-38 set ref 260* 261* 328 328 414 414
hardcore_info                          based           structure                level 1 dcl 9-6
hcs_$append_link                000052 constant        entry                    external dcl 309 ref 441
hcs_$fs_get_path_name           000050 constant        entry                    external dcl 308 ref 407
head                                   based           structure                level 2 dcl 5-29
head_size                       000113 automatic       fixed bin(17,0)          dcl 78 set ref 137* 141 155
header                                 based           structure                level 2 dcl 5-47
hisregs                  60            based           bit(36)                  array level 2 dcl 494 set ref 505
hr_ptr                          000502 automatic       pointer                  dcl 487 set ref 505* 516*
i                               000150 automatic       fixed bin(17,0)          dcl 85 set ref 186*
index                                                  builtin function         dcl 66 ref 205
ioa_                            000022 constant        entry                    external dcl 54 ref 150 181 263 337 515 517
ioa_$rs                         000024 constant        entry                    external dcl 55 ref 194
iocbp                     2            based           pointer                  level 2 dcl 7-10 set ref 166*
iox_$user_output                000034 external static pointer                  dcl 59 set ref 166 177*
last_offset                     000110 automatic       fixed bin(18,0)          dcl 391 set ref 427* 430 433
linelen                  12            based           fixed bin(17,0)          level 2 dcl 7-10 set ref 177* 179*
link_dname               66     000236 automatic       char(168)                array level 2 packed unaligned dcl 293 set ref 321*
                                                                                  351* 439* 441* 454 454* 458 458*
link_ename              140     000236 automatic       char(32)                 array level 2 packed unaligned dcl 293 set ref 320*
                                                                                  351* 440* 441* 454* 458*
live_log                  4            based           fixed bin(17,0)          level 2 dcl 2-11 set ref 336 336 343* 347 351 351
log_message_header                     based           structure                level 1 dcl 4-3
log_name                        000100 automatic       char(32)                 unaligned dcl 390 set ref 401* 403* 405 414
log_path                        000567 automatic       char(168)                unaligned dcl 303 set ref 351* 362* 366* 368* 372*
log_seg                         000236 automatic       structure                array level 1 dcl 293
log_segment_$last_message_info  000054 constant        entry                    external dcl 310 ref 427
log_segment_header                     based           structure                level 1 dcl 3-13 ref 421 421 430 433 433 433 433 433
log_segment_ptr                 000424 automatic       pointer                  dcl 3-3 set ref 426* 427*
long                      0(31) 000506 automatic       bit(1)                   level 2 packed unaligned dcl 490 set ref 501*
match_arg                       000641 automatic       char(32)                 unaligned dcl 304 set ref 354* 356* 362* 368*
mc                                     based           structure                level 1 dcl 10-12 ref 510
mc_stored                 0(33) 000506 automatic       bit(1)                   level 2 packed unaligned dcl 490 set ref 501*
mcp                             000440 automatic       pointer                  dcl 10-10 set ref 504* 510 511
mcx                             000510 automatic       structure                level 2 dcl 491 set ref 510*
mess_count                      000112 automatic       fixed bin(17,0)          dcl 77 set ref 112* 127* 185 185 185* 186 257* 362
                                                                                  362 362 366 366
msg_printed                     000405 automatic       bit(1)                   unaligned dcl 91 set ref 199* 213* 219* 228
msgp                                   based           pointer                  level 2 dcl 7-10 set ref 221*
msgs_bypassed                   000204 automatic       fixed bin(17,0)          initial dcl 89 set ref 89*
msgs_printed                    000203 automatic       fixed bin(17,0)          initial dcl 89 set ref 89* 518* 518
my_mcp                          000504 automatic       pointer                  dcl 489 set ref 512* 513*
new_time                        000151 automatic       char(24)                 unaligned dcl 86 set ref 188* 235
null                                                   builtin function         dcl 66 ref 129 133 161 240 318 462 465 516 516
octal_sw                 21(01)        based           bit(1)                   level 2 packed unaligned dcl 7-10 set ref 170* 174*
offset                          000125 automatic       fixed bin(18,0)          dcl 81 set ref 140* 142* 155* 155 157*
pad                      21(02)        based           bit(34)                  level 2 packed unaligned dcl 7-10 set ref 176*
parg                                   based           structure                level 1 dcl 7-10
pathname                 11     000236 automatic       char(168)                array level 2 packed unaligned dcl 293 set ref 319*
                                                                                  410* 441*
pathname_                       000056 constant        entry                    external dcl 311 ref 351 410
plural_sw                       000202 automatic       bit(1)                   initial unaligned dcl 88 set ref 88*
pointers                               based           structure                level 2 dcl 9-6
prev_time                13            based           char(24)                 level 2 dcl 7-10 set ref 167* 235*
print_sys_log                   000062 constant        entry                    external dcl 314 ref 362 366 368 372
print_syserr_msg_               000032 constant        entry                    external dcl 58 ref 228
printl                   11            based           fixed bin(17,0)          level 2 dcl 7-10 set ref 226*
printp                    6            based           pointer                  level 2 dcl 7-10 set ref 225*
prs                             000510 automatic       pointer                  array level 3 in structure "fault_msg" dcl 491
                                                                                  in procedure "display_hw_fault" set ref 511*
prs                                    based           pointer                  array level 2 in structure "mc" dcl 10-12
                                                                                  in procedure "azm_syserr_" ref 511
range                           000126 automatic       fixed bin(18,0)          dcl 81 set ref 141* 142* 156* 157*
rel                                                    builtin function         dcl 66 ref 140
ret_data                               based           char                     unaligned dcl 98 set ref 194*
ret_len                         000411 automatic       fixed bin(21,0)          dcl 95 set ref 105* 116 144 159 193* 193 194 194 231
                                                                                  241 267
ret_string_ptr                  000414 automatic       pointer                  dcl 97 set ref 104* 194
returns_sw                      000410 automatic       bit(1)                   unaligned dcl 94 set ref 106* 116 126* 144 159 192
                                                                                  231 241 255* 267
rtrim                                                  builtin function         dcl 66 ref 346 347
sci_ptr                         000416 automatic       pointer                  dcl 99 set ref 108* 124* 133* 154* 161* 240* 253*
                                                                                  405* 462* 465* 513*
segno                           000124 automatic       fixed bin(17,0)          dcl 80 in procedure "azm_syserr_" set ref 139* 142*
                                                                                  150* 157* 181*
segno                           000236 automatic       fixed bin(17,0)          array level 2 in structure "log_seg" dcl 293
                                                                                  in procedure "print_log_partition" set ref 414*
                                                                                  421* 433*
seq_num                                based           fixed bin(35,0)          level 3 dcl 5-47 set ref 191 214 221
severity                        000114 automatic       char(30)                 unaligned dcl 79 set ref 110* 125* 254* 362* 366*
                                                                                  368* 372*
size                                                   builtin function         dcl 66 ref 83 137 332 332 421 421 430 433 433 433
                                                                                  433 433
slt                                    based           structure                level 3 dcl 9-6
sltntp                    2            based           pointer                  level 2 dcl 9-40 set ref 328* 414*
sltp                                   based           pointer                  level 2 dcl 9-40 set ref 328* 414*
ssu_$get_temp_segment           000026 constant        entry                    external dcl 56 ref 154 405
ssu_$release_temp_segment       000030 constant        entry                    external dcl 57 ref 133 161 240 462 465
substr                                                 builtin function         dcl 66 ref 125 194 194 205 254 362 362 368 368 368
swap_time                10            based           fixed bin(71,0)          level 2 dcl 2-11 ref 345
syserr_log_data                        based           structure                level 1 dcl 2-11 set ref 332 332
syserr_log_data_ptr             000422 automatic       pointer                  dcl 2-9 set ref 326* 332* 332 332 336 336 343 345
                                                                                  347 351 351
syserr_log_data_segno           000556 automatic       fixed bin(17,0)          dcl 301 set ref 328* 332*
syserr_msg                             based           structure                level 1 dcl 8-9
syserr_msgp                     000434 automatic       pointer                  dcl 8-7 set ref 191* 193 194 194 194 194 198 214*
                                                                                  215 216 216 218 218 224 226
text                      6            based           char                     level 2 in structure "syserr_msg" dcl 8-9
                                                                                  in procedure "azm_syserr_" ref 194 194 198 215
text                            000205 automatic       char(512)                unaligned dcl 90 in procedure "azm_syserr_" set ref
                                                                                  198* 215* 223 225
text                      6            based           char                     level 2 in structure "wmess" dcl 5-47 in procedure
                                                                                  "azm_syserr_" ref 205
text_len                  3(12)        based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 8-9 in procedure "azm_syserr_" ref 193 194 194
                                                                                  194 194 198 215 218 218 224 226
text_len                  3(12)        based           fixed bin(11,0)          level 3 in structure "wmess" packed unaligned
                                                                                  dcl 5-47 in procedure "azm_syserr_" ref 187 205
                                                                                  205 237
textl                    10            based           fixed bin(17,0)          level 2 dcl 7-10 set ref 224*
textp                     4            based           pointer                  level 2 dcl 7-10 set ref 223*
timcv                           000464 automatic       fixed bin(71,0)          dcl 475 set ref 479 480*
time                      1            based           fixed bin(71,0)          level 3 packed unaligned dcl 5-47 set ref 188 188
timein                                 based           fixed bin(35,0)          array dcl 476 ref 479
timeint                                based           fixed bin(35,0)          array dcl 477 set ref 479*
timout                          000466 automatic       char(24)                 unaligned dcl 478 set ref 480* 481
tp                                     parameter       pointer                  dcl 474 ref 472 479
unique_chars_                   000060 constant        entry                    external dcl 312 ref 342
unspec                                                 builtin function         dcl 66 set ref 511* 511
w_header                        000131 automatic       fixed bin(17,0)          array dcl 83 set ref 138
wlog                                   based           structure                level 1 dcl 5-29
wlog_header                            based           structure                level 1 dcl 5-33 ref 83 137
wlog_ptr                        000426 automatic       pointer                  dcl 5-17 set ref 138* 142* 148 156 181 181 181 181
                                                                                  185 185
wmess                                  based           structure                level 1 dcl 5-47
wmess_header                           based           structure                level 1 dcl 5-52
wmess_ptr                       000430 automatic       pointer                  dcl 5-17 set ref 129* 133 133* 154* 157* 161 161*
                                                                                  187 188 188 190 191 205 205 212 214 221 237* 237
                                                                                  237 240 240*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 1-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 1-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 1-58
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 1-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 1-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 1-47
LOG_SEGMENT_COMPLETE_MESSAGE           internal static bit(36)                  initial dcl 3-43
LOG_SEGMENT_NEW_MESSAGE                internal static bit(36)                  initial dcl 3-42
LOG_SEGMENT_VERSION_1                  internal static char(8)                  initial unaligned dcl 3-5
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 1-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 1-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 1-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 1-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 1-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 1-47
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 6-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 6-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 6-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 6-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 6-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 6-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 6-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 6-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 6-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 6-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 6-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 6-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 6-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 6-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 6-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 6-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 6-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 6-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 6-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 6-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 6-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 6-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 6-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 6-21
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 6-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 6-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 6-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 6-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 6-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 6-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 6-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 6-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 6-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 6-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 6-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 6-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 6-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 6-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 6-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 6-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 6-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 6-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 6-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 6-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 6-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 6-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 6-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 6-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 6-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 6-47
SYSERR_LOG_DATA_V1                     internal static char(8)                  initial unaligned dcl 2-52
abx                                    internal static fixed bin(17,0)          initial dcl 10-42
amu_area                               based           area(1024)               dcl 1-43
amu_info                               based           structure                level 1 dcl 1-3
apx                                    internal static fixed bin(17,0)          initial dcl 10-42
arg_bits                               based           structure                level 1 dcl 11-23
bbx                                    internal static fixed bin(17,0)          initial dcl 10-42
bpx                                    internal static fixed bin(17,0)          initial dcl 10-42
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 6-144
lbx                                    internal static fixed bin(17,0)          initial dcl 10-42
log_message                            based           structure                level 1 dcl 4-13
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 4-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 4-22
log_message_ptr                        automatic       pointer                  dcl 4-19
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 4-20
log_segment                            based           structure                level 1 dcl 3-8
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 3-4
lpx                                    internal static fixed bin(17,0)          initial dcl 10-42
number_val_args                        internal static fixed bin(17,0)          initial dcl 11-3
sbx                                    internal static fixed bin(17,0)          initial dcl 10-42
scu                                    based           structure                level 1 dcl 10-56
scup                                   automatic       pointer                  dcl 10-54
scux                                   based           structure                level 1 dcl 10-207
sd                                     based           structure                level 1 dcl 5-21
sd_ptr                                 automatic       pointer                  dcl 5-17
spx                                    internal static fixed bin(17,0)          initial dcl 10-42
syserr_binary_address_damage_mask      internal static bit(36)                  initial unaligned dcl 6-142
syserr_binary_mos_mask                 internal static bit(36)                  initial unaligned dcl 6-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial unaligned dcl 6-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial unaligned dcl 6-141
syserr_data$syserr_area                external static char(1)                  dcl 5-14
syserr_data$wired_log_area             external static char(1)                  dcl 5-14
syserr_log_data$                       external static fixed bin(17,0)          dcl 2-8
valid_mc_arg                           internal static char(8)                  initial array unaligned dcl 11-5
what_prs                               based           structure                level 1 dcl 11-26

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    002614 constant        label                    dcl 377 ref 330 334 339 408 416 424 428 437 443
EXIT_DATA                       001403 constant        label                    dcl 245
azm_syserr_                     000241 constant        entry                    external dcl 19
check_if_found                  000327 constant        label                    dcl 116 ref 151
clean_up_print_log_partition    003267 constant        entry                    internal dcl 450 ref 323 377
code_from_data                  000413 constant        label                    dcl 129 ref 114
code_from_log                   001452 constant        label                    dcl 257 set ref 149 243
data                            000345 constant        entry                    external dcl 121
datm                            003434 constant        entry                    internal dcl 472 ref 188
display_hw_fault                003466 constant        entry                    internal dcl 484 ref 218
get_log_segment                 002622 constant        entry                    internal dcl 384 ref 343 347
log                             001406 constant        entry                    external dcl 249
ok_to_print_data                001267 constant        label                    dcl 221 set ref 201
print_log_partition             001520 constant        entry                    internal dcl 289 ref 265
returns_string                  000256 constant        entry                    external dcl 102
skip                            001331 constant        label                    dcl 235 ref 187 190 196 207 209 212

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4212        4276    3630        4222
Length      4752    3630        64         440     361           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_syserr_                         481 external procedure  is an external procedure.  
on unit on line 132                  70 on unit               
print_log_partition                 540 internal procedure  enables or reverts conditions.  
on unit on line 323                  64 on unit               
get_log_segment                     174 internal procedure  is called during a stack extension.  
clean_up_print_log_partition         90 internal procedure  is called by several nonquick procedures.  
datm                                    internal procedure  shares stack frame of external procedure azm_syserr_.  
display_hw_fault                        internal procedure  shares stack frame of external procedure azm_syserr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_syserr_              000106 a_syserr_code               azm_syserr_
                         000110 data_area_ptr               azm_syserr_
                         000112 mess_count                  azm_syserr_
                         000113 head_size                   azm_syserr_
                         000114 severity                    azm_syserr_
                         000124 segno                       azm_syserr_
                         000125 offset                      azm_syserr_
                         000126 range                       azm_syserr_
                         000127 code                        azm_syserr_
                         000130 def_code                    azm_syserr_
                         000131 w_header                    azm_syserr_
                         000132 current_hardcore            azm_syserr_
                         000150 i                           azm_syserr_
                         000151 new_time                    azm_syserr_
                         000160 auto_parg                   azm_syserr_
                         000202 plural_sw                   azm_syserr_
                         000203 msgs_printed                azm_syserr_
                         000204 msgs_bypassed               azm_syserr_
                         000205 text                        azm_syserr_
                         000405 msg_printed                 azm_syserr_
                         000406 code_only_sw                azm_syserr_
                         000407 found_one_sw                azm_syserr_
                         000410 returns_sw                  azm_syserr_
                         000411 ret_len                     azm_syserr_
                         000412 foo_len                     azm_syserr_
                         000414 ret_string_ptr              azm_syserr_
                         000416 sci_ptr                     azm_syserr_
                         000420 amu_info_ptr                azm_syserr_
                         000422 syserr_log_data_ptr         azm_syserr_
                         000424 log_segment_ptr             azm_syserr_
                         000426 wlog_ptr                    azm_syserr_
                         000430 wmess_ptr                   azm_syserr_
                         000432 argp                        azm_syserr_
                         000434 syserr_msgp                 azm_syserr_
                         000436 hardcore_cur_ptr            azm_syserr_
                         000440 mcp                         azm_syserr_
                         000442 arg_bits_ptr                azm_syserr_
                         000464 timcv                       datm
                         000466 timout                      datm
                         000502 hr_ptr                      display_hw_fault
                         000504 my_mcp                      display_hw_fault
                         000506 a_arg_bits_def              display_hw_fault
                         000510 fault_msg                   display_hw_fault
get_log_segment          000100 log_name                    get_log_segment
                         000110 last_offset                 get_log_segment
                         000111 dname                       get_log_segment
                         000163 ename                       get_log_segment
print_log_partition      000100 auto_syserr_log_data        print_log_partition
                         000236 log_seg                     print_log_partition
                         000556 syserr_log_data_segno       print_log_partition
                         000557 family_name                 print_log_partition
                         000567 log_path                    print_log_partition
                         000641 match_arg                   print_log_partition
                         000651 expand_arg                  print_log_partition

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          tra_ext_1           alloc_auto_adj      enable_op
shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc      set_chars_eis
index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$definition_ptr           amu_$do_translation           amu_$hardcore_info_set_cur_ptrs
amu_$hranl                    amu_$slt_search_seg_num       azm_display_mc_               date_time_
delete_$path                  get_line_length_$switch       get_pdir_                     hcs_$append_link
hcs_$fs_get_path_name         ioa_                          ioa_$rs
log_segment_$last_message_info                              pathname_                     print_sys_log
print_syserr_msg_             ssu_$get_temp_segment         ssu_$release_temp_segment     unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     83 000227        88 000233        89 000234        19 000240        21 000247       102 000250       104 000271
    105 000275       106 000276       107 000300       108 000303       109 000306       110 000310       111 000322
    112 000323       113 000325       114 000326       116 000327       118 000334       119 000335       121 000336
    123 000373       124 000377       125 000402       126 000407       127 000411       129 000413       132 000415
    133 000431       134 000446       136 000447       137 000511       138 000513       139 000515       140 000521
    141 000524       142 000526       143 000547       144 000551       145 000556       146 000560       148 000561
    149 000564       150 000566       151 000606       154 000607       155 000635       156 000637       157 000641
    158 000662       159 000664       160 000671       161 000673       162 000710       165 000711       166 000713
    167 000717       168 000722       169 000724       170 000726       171 000730       173 000731       174 000736
    176 000741       177 000743       179 000755       181 000762       185 001034       186 001044       187 001053
    188 001060       189 001067       190 001071       191 001076       192 001100       193 001102       194 001111
    196 001152       198 001154       199 001162       200 001163       201 001165       204 001166       205 001175
    207 001207       208 001214       209 001215       212 001222       213 001227       214 001230       215 001232
    216 001240       218 001256       219 001265       221 001267       223 001271       224 001274       225 001301
    226 001303       228 001304       230 001317       231 001321       232 001326       233 001330       235 001331
    237 001335       239 001354       240 001356       241 001373       242 001400       243 001401       245 001403
    249 001404       252 001434       253 001440       254 001443       255 001450       257 001452       260 001454
    261 001456       263 001467       265 001503       267 001507       268 001514       269 001516       289 001517
    318 001525       319 001541       320 001556       321 001572       323 001606       326 001630       328 001633
    330 001656       332 001661       334 001705       336 001710       337 001716       338 001732       339 001734
    342 001735       343 001755       345 001773       346 001777       347 002025       349 002073       351 002074
    354 002120       356 002133       358 002136       360 002147       362 002152       366 002306       368 002414
    372 002525       375 002612       377 002614       380 002620       384 002621       401 002635       403 002645
    405 002650       407 002701       408 002740       410 002747       414 002774       416 003023       421 003032
    424 003065       426 003074       427 003104       428 003122       430 003131       433 003134       437 003173
    439 003202       440 003216       441 003227       443 003256       445 003265       450 003266       454 003274
    458 003334       462 003375       465 003414       468 003433       472 003434       479 003436       480 003443
    481 003460       484 003466       501 003470       502 003476       503 003500       504 003502       505 003505
    510 003507       511 003513       512 003516       513 003520       515 003537       516 003553       517 003572
    518 003605       519 003606


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
