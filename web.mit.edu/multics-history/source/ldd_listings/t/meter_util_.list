	COMPILATION LISTING OF SEGMENT meter_util_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1515.5 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 meter_util_: proc;
       12 
       13 /* This procedure contains several entries which are used by the hardcore
       14*   metering programs. To use this package, the user must first
       15*   call meter_util_$get_buffers to reserve some buffer space (in internal
       16*   static -- or at least in the linkage segment).	 */
       17 /* mod fall 78 REM- copy out 280 (not 256) words of tc_data */
       18 /* Modified November 1984 by M. Pandolf to include hc_lock. */
       19 
       20 
       21 dcl 1 pa (40) aligned static,
       22     2 pad (10) fixed bin;
       23 
       24 dcl  ring_zero_peek_ ext entry (ptr, ptr, fixed bin, fixed bin (35)),
       25      ioa_ ext entry options (variable),
       26      ioa_$rsnnl ext entry options (variable),
       27      ring0_get_$segptr ext entry (char (*), char (*), ptr, fixed bin),
       28      hcs_$assign_linkage ext entry (fixed bin, ptr, fixed bin),
       29 
       30      unique_index fixed bin,
       31      meter_time float bin,
       32      rs char (12) aligned,
       33      a_meter_time float bin,
       34     (a_sstp1, a_sstp2, a_tcdp1, a_tcdp2, p, lp) ptr,
       35     (code, ignore, sec, min, hr) fixed bin,
       36      error_code fixed bin (35),
       37      static_index fixed bin static init (1),
       38     (sstp0, tcdp0) ptr static,
       39      inited bit (1) static init ("0"b),
       40     (mod, addr, addrel, divide, substr) builtin,
       41      move_280 (280) fixed bin based,
       42      move_512 (512) fixed bin based;
       43 
       44 dcl 1 pa1 based (p) aligned,
       45     2 reset_called fixed bin,
       46     2 pad fixed bin,
       47     2 (sstp1, sstp2, tcdp1, tcdp2) ptr;
       48 
       49 	/*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
       49 
       50 	/* BEGIN INCLUDE FILE ... tcm.incl.pl1 ... used to generate tc_data cds */
  2     2 /* NOTE -- This include file has TWO counterparts in ALM: tc_meters.incl.alm and */
  2     3 /* wcte.incl.alm. They cannot be produced with cif, and must be kept up to date manually. */
  2     4 /* Modified 830914 to replace tty_polling_time with opc_polling_time... -E. A. Ranzenbach */
  2     5 /* Modified 1984.05.21 by M. Pandolf to add tc_suspend_lock */
  2     6 /* Modified 1984.11.26 by Keith Loepere for uid_array. */
  2     7 /* Modified 1984.12.06 by Keith Loepere for page create delaying. */
  2     8 
  2     9 dcl  tcmp ptr;
  2    10 
  2    11 dcl 1 tcm aligned based (tcmp),
  2    12     2 tc_suspend_lock like lock,			/* when locked, tc is suspended */
  2    13     2 cid2 fixed bin (18),
  2    14     2 cid3 fixed bin (18),
  2    15     2 cid4 fixed bin (18),
  2    16     2 depth_count fixed bin (18),			/* depth last process run */
  2    17     2 loadings fixed bin (18),			/* number of process loadings */
  2    18 
  2    19     2 blocks fixed bin (18),				/* number of calls to block */
  2    20     2 wakeups fixed bin (18),				/* number of calls to wakeup */
  2    21     2 waits fixed bin (18),				/* number of calls to wait */
  2    22     2 notifies fixed bin (18),			/* number of calls to notify */
  2    23     2 schedulings fixed bin (18),
  2    24     2 interactions fixed bin (18),			/* number of interactive schedulings */
  2    25     2 avequeue fixed bin (35, 18),			/* recent time average of number in queue */
  2    26     2 te_wait fixed bin (18),				/* times te called from wait */
  2    27 
  2    28     2 te_block fixed bin (18),			/* times te updated from block */
  2    29     2 te_i_stop fixed bin (18),			/* times te updated from i_stop */
  2    30     2 te_pre_empt fixed bin (18),			/* times te updated from pre_empt */
  2    31     2 p_interactions fixed bin,			/* times interaction bit turned off because of high priority */
  2    32     2 idle fixed bin (71),				/* total idle time */
  2    33     2 mp_idle fixed bin (71),				/* multi-programming idle */
  2    34 
  2    35     2 nmp_idle fixed bin (71),			/* non-multi-programming idle time */
  2    36     2 zero_idle fixed bin (71),			/* zero idle time */
  2    37     2 last_time fixed bin (71),			/* last time a process was run */
  2    38     2 loop_locks fixed bin (18),			/* times looped on the APT lock */
  2    39     2 loop_lock_time fixed bin (18),			/* time looping on the APT lock */
  2    40     2 ave_eligible fixed bin (35, 18),			/* average length of eligible queue */
  2    41     2 sort_to_elhead fixed bin (18),			/* 0=> no one,1 => int've only, 2 => everybody */
  2    42     2 processor_time fixed bin (71),			/* total processor time on system */
  2    43     2 response_time fixed bin (71),			/* estimate of response time */
  2    44     2 eligible_time fixed bin (71),			/* estimate of eligible time */
  2    45     2 response_count fixed bin,			/* count of response meters */
  2    46     2 eligible_count fixed bin,			/* count of eligible meters */
  2    47     2 quit_counts (0:5) fixed bin,			/* array of buckets indexed by state */
  2    48     2 loading_idle fixed bin (71),			/* loading_idle time */
  2    49     2 delta_vcpu fixed bin (71),			/* delta virtual CPU time for the system */
  2    50     2 post_purge_switch fixed bin,			/* ON if post purging is to be done */
  2    51     2 time_out_severity fixed bin,			/* syserr first arg for notify time outs */
  2    52     2 notify_check fixed bin,				/* obsolete */
  2    53     2 quit_priority fixed bin,			/* factor for scheduler quit response */
  2    54     2 iobm_polling_time fixed bin (71),			/* time to poll iobm */
  2    55     2 end_of_time fixed bin (71),			/* very large time */
  2    56     2 gp_at_notify fixed bin (18),			/* 0 => just do get_idle_processor */
  2    57     2 gp_at_ptlnotify fixed bin (18),			/* 0 => just do get_idle_processor */
  2    58     2 int_q_enabled fixed bin (18),			/* 0 => no intv q in percent mode */
  2    59     2 fnp_buffer_threshold fixed bin (18),		/* if fewer free buffs then stingy alloc strategy */
  2    60 						/* set this to >= half n_ttylines/fnp for safety */
  2    61 
  2    62 /* 100 octal */
  2    63 
  2    64     2 depths (8) fixed bin (18),			/* histogram of run depths */
  2    65     2 tdepths (8) fixed bin (71),			/* histogram of times run per depth */
  2    66     2 pfdepth (8) fixed bin (18),			/* histogram of page faults per depth */
  2    67 
  2    68     2 ptl_not_waits fixed bin (18),			/* times ptl_wait noticed ptl was unlocked */
  2    69     2 gw_gp_window_count fixed bin (18),		/* times window noticed */
  2    70     2 metering_lock fixed bin (18),			/* 0=locked, else unlocked */
  2    71     2 ptl_waits fixed bin (18),			/* num calls to ptl_wait */
  2    72     2 gp_start_count fixed bin (18),			/*  to detect gw_gp window lossage */
  2    73     2 gp_done_count fixed bin (18),
  2    74     2 nto_check_time fixed bin (71),			/* next time at which nto code will be called */
  2    75     2 nto_delta fixed bin (35),			/* microsec between nto checks */
  2    76     2 nto_count fixed bin (18),			/* number of times nto detected */
  2    77     2 tcpu_scheduling fixed bin (18),			/* obsolete				*/
  2    78     2 nto_event bit (36),				/* last event which NTO'd */
  2    79     2 page_notifies fixed bin (18),
  2    80     2 notify_nobody_count fixed bin (18),
  2    81     2 notify_nobody_event bit (36),
  2    82     2 system_type fixed bin,				/* used to be tcm.inter */
  2    83 
  2    84     2 stat (0:15) fixed bin (18),			/* num apte's in each state */
  2    85 
  2    86 /* 200 octal */
  2    87 
  2    88     2 wait (8),
  2    89       3 time fixed bin (18),				/* histogram of page fault waiting times versus did */
  2    90       3 count fixed bin (18),
  2    91 
  2    92     2 ready (8),
  2    93       3 time fixed bin (18),				/* histogram of times in ready queue */
  2    94       3 count fixed bin (18),
  2    95 
  2    96     2 total_pf_time fixed bin (71),			/* total time spent from start to end of
  2    97*						   all page faults */
  2    98     2 total_pf_count fixed bin (18),			/* total number of page faults metered */
  2    99     2 auto_tune_ws fixed bin (18),			/* 0=> dont, atherwise compensate for quantum len */
  2   100     2 ocore_delta fixed bin (18),			/* number of pages reserved for int users */
  2   101     2 ws_sum fixed bin (18),				/* total of eligible's ws_sizes */
  2   102     2 nonidle_force_count fixed bin (18),		/* count of eligibilities forced */
  2   103     2 itt_list_lock bit (36) aligned,			/* Lock on ITT free list */
  2   104     2 cpu_pf_time fixed bin (71),			/* total cpu time spent handling page faults */
  2   105     2 cpu_pf_count fixed bin (18),			/* total count of cpu time meterings */
  2   106     2 special_offsets unaligned,
  2   107       3 apt_offset bit (18),
  2   108       3 pad bit (18),
  2   109     2 getwork_time fixed bin (71),			/* total time spent in getwork */
  2   110     2 getwork_count fixed bin (18),			/* total times through getwork */
  2   111     2 short_pf_count fixed bin (18),			/* number of short page faults */
  2   112     2 interrupt_time fixed bin (71),			/* total time spent in interrupt */
  2   113     2 interrupt_count fixed bin (71),			/* total number of metered interrupts */
  2   114     2 ocore fixed bin (35, 18),			/* fraction of core for int've users */
  2   115     2 pre_empt_flag bit (36) aligned,			/* controls whether preempting at done time */
  2   116     2 cumulative_memory_usage fixed binary (71),		/* total number of memory usage units */
  2   117     2 processor_time_at_define_wc fixed bin (71),		/* value of processor_time when WC's last defined */
  2   118     2 boost_priority fixed bin,			/* number of times priority process given high priority */
  2   119     2 lost_priority fixed bin,			/* number of times priority process lost eligibility */
  2   120     2 total_clock_lag fixed bin (71),			/* sum of all simulated clock delays */
  2   121     2 clock_simulations fixed bin,			/* number of times alarm clock interrupt was simulated */
  2   122     2 max_clock_lag fixed bin,			/* largest simulated alarm clock delay */
  2   123 
  2   124 /* 300 octal */
  2   125 
  2   126     2 pdscopyl fixed bin (18),			/* amount of pds to copy for new process */
  2   127     2 max_hproc_segno fixed bin,			/* largest allowed hardcore segment number */
  2   128     2 prds_length fixed bin (18),			/* length of PRDS */
  2   129     2 pds_length fixed bin (18),			/* length of PDS */
  2   130     2 lock fixed bin (18),				/* process id generator lock */
  2   131     2 id bit (36) aligned,				/* next uid to be added to uid_array */
  2   132     2 system_shutdown fixed bin (18),
  2   133     2 working_set_factor fixed bin (35, 18),		/* working set factor */
  2   134 
  2   135     2 ncpu fixed bin (18),				/* number of processors currently being used */
  2   136     2 last_eligible bit (18),				/* last process to gain eligibility */
  2   137     2 apt_lock fixed bin (35),			/* + write; 0 hidden; -1 unlocked; -(N+1) Nreaders */
  2   138     2 apt_size fixed bin (18),			/* number of APT entries */
  2   139     2 realtime_q aligned like based_sentinel,		/* processes with realtime deadlines */
  2   140     2 aht_size fixed bin (18),			/* APT hash table size */
  2   141     2 itt_size fixed bin (18),			/* number of ITT entries */
  2   142 
  2   143     2 dst_size fixed bin (18),			/* number of allowed DST entries */
  2   144     2 itt_free_list bit (18),				/* pointer to ITT free list */
  2   145     2 used_itt fixed bin (18),			/* number of used ITT entries */
  2   146     2 initializer_id bit (36) aligned,			/* process id of initializer */
  2   147     2 n_eligible fixed bin (18),			/* number of processes eligible */
  2   148     2 max_eligible fixed bin (30),			/* maximum allowed number of eligible processes */
  2   149     2 wait_enable fixed bin (18),			/* turned on when waiting mechanism works */
  2   150     2 apt_entry_size fixed bin (18),			/* size of an APT entry */
  2   151 
  2   152     2 interactive_q aligned like based_sentinel,		/* head of interactive queue */
  2   153     2 dst_ptr ptr,					/* pointer to device signal table */
  2   154     2 old_user ptr,					/* last process to run (apt ptr ) */
  2   155     2 initialize_time fixed bin (71),			/* time of initialization */
  2   156 
  2   157     2 init_event fixed bin (18),			/* wait event during initialization */
  2   158     2 oldt fixed bin (18),				/* timer reading from previous process */
  2   159     2 newt fixed bin (18),				/* timer setting for new process */
  2   160     2 tefirst fixed bin (30),				/* first eligible time */
  2   161     2 telast fixed bin (30),				/* last eligible time */
  2   162     2 timax fixed bin (35),				/* time in queue for lowest level */
  2   163     2 empty_q bit (18),				/* thread of empty APT entries */
  2   164     2 working_set_addend fixed bin (18),		/* additive working set parameter */
  2   165     2 ready_q_head bit (0) aligned,			/* for added segdef */
  2   166     2 eligible_q_head aligned like based_sentinel,	/* head of eligible queue */
  2   167     2 ready_q_tail bit (0) aligned,			/* for added segdef */
  2   168     2 eligible_q_tail aligned like based_sentinel,	/* tail of eligible queue */
  2   169     2 idle_tail aligned like based_sentinel,		/* tail of idle list */
  2   170     2 min_eligible fixed bin (30),
  2   171     2 alarm_timer_list bit (18) aligned,		/* rel pointer to apt entry for next alarm timer */
  2   172     2 guaranteed_elig_inc fixed bin (35),		/* amount of guaranteed eligibility time in microsecs. */
  2   173     2 priority_sched_inc fixed bin (35),		/* amount of block time before process is given priority */
  2   174     2 next_alarm_time fixed bin (71),			/* clock time for next alarm timer */
  2   175     2 priority_sched_time fixed bin (71),		/* time for priority process to be given priority */
  2   176     2 opc_polling_time fixed bin (71),			/* time to poll console DIM */
  2   177     2 disk_polling_time fixed bin (71),			/* time to poll disk DIM */
  2   178     2 tape_polling_time fixed bin (71),			/* time to poll tape DIM */
  2   179     2 imp_polling_time fixed bin (71),			/* time to poll imp */
  2   180     2 imp_polling_lock fixed bin (18),			/* do not poll if lock set */
  2   181     2 max_channels fixed bin (18),			/* num special channels per process */
  2   182 
  2   183 /* 400 octal */
  2   184 
  2   185     2 system_virtual_time fixed bin (71),		/* non-idle virtual time */
  2   186     2 credit_bank fixed bin (71),			/* credits not yet passed out */
  2   187     2 min_wct_index bit (18) aligned,			/* offset of initializer work class table entry */
  2   188     2 max_wct_index bit (18) aligned,			/* offset of highest wcte currently defined */
  2   189     2 delta_vt fixed bin (71),			/* temp used by pxss.compute_virtual_clocks */
  2   190     2 gross_idle_time fixed bin (71),			/* idle time_used_clock */
  2   191     2 credits_per_scatter fixed bin (35),		/* total number of credits awarded at once */
  2   192     2 best_credit_value fixed bin (18),			/* temp for pxss.find_next_eligible */
  2   193     2 define_wc_time fixed bin (71),			/* clock time when workclasses last degined */
  2   194     2 max_batch_elig fixed bin (35),
  2   195     2 num_batch_elig fixed bin (35),
  2   196     2 deadline_mode fixed bin (35),			/* 0=> ti sorts, else deadline sorts */
  2   197     2 credits_scattered fixed bin (35),
  2   198     2 max_max_eligible fixed bin (30),			/* Maximum of maxe */
  2   199     2 max_stopped_stack_0 fixed bin (35),		/* Maximum stack_0's suspended by stopped procs	*/
  2   200     2 stopped_stack_0 fixed bin (35),			/* Number stack_0's suspended by stopped procs	*/
  2   201     2 mos_polling_interval fixed bin (35),		/* for heals */
  2   202     2 mos_polling_time fixed bin (71),			/* for heals */
  2   203     2 vcpu_response_bounds (VCPU_RESPONSE_BOUNDS) fixed bin (35),
  2   204     2 vcpu_response_bounds_size fixed bin (35),
  2   205     2 meter_response_time_calls fixed bin (35),
  2   206     2 meter_response_time_invalid fixed bin (35),
  2   207     2 meter_response_time_overhead fixed bin (71),
  2   208     2 init_wait_time fixed bin (71),			/* used by wait/notify during initialization	*/
  2   209     2 init_wait_timeout fixed bin (71),			/* notify-timeout interval during initialization	*/
  2   210     2 init_timeout_severity fixed bin,			/* notify-timeout severity during initialization	*/
  2   211     2 init_timeout_recurse fixed bin,			/* count of NTO recursion during initialization	*/
  2   212     2 max_timer_register fixed bin (71),		/* max cpu burst = # cpus x pre_empt_sample_time	*/
  2   213     2 pre_empt_sample_time fixed bin (35),		/* tuning parameter - max time between samples	*/
  2   214     2 governing_credit_bank fixed bin (35),		/* used for limiting eligibility on governed work classes*/
  2   215     2 process_initial_quantum fixed bin (35),		/* eligibility quantum first eligibility	*/
  2   216     2 default_procs_required bit (8) aligned,		/* default mask of CPUs required */
  2   217     2 work_class_idle fixed bin (71),			/* idle time due to work class restrictions */
  2   218 
  2   219 /* Tuning Parameters for Stack Truncation */
  2   220 
  2   221     2 stk_truncate bit (1) aligned,
  2   222     2 stk_truncate_always bit (1) aligned,
  2   223     2 stk_trunc_avg_f1 fixed bin (35, 18),
  2   224     2 stk_trunc_avg_f2 fixed bin (35, 18),
  2   225     2 lock_error_severity fixed bin,                        /* syserr severity */
  2   226 
  2   227     2 gv_integration fixed bin (35),			/* Integration interval for governing */
  2   228     2 gv_integration_set bit (1) aligned,		/* ON => gv_integration set by ctp */
  2   229     2 pauses fixed bin (35),				/* Calls to pause (reschedule) */
  2   230     2 volmap_polling_time fixed bin (71),
  2   231     2 next_ring0_timer fixed bin (71),			/* next time that ring 0 timer goes off */
  2   232     2 realtime_io_priority_switch fixed bin,		/* 0 => give I/O interrupt wakeups realtime priotiry */
  2   233     2 realtime_io_deadline fixed bin (35),		/* Delta to clock for I/O realtime deadline */
  2   234     2 realtime_io_quantum fixed bin (35),		/* Quantum for I/O realtime burst */
  2   235     2 realtime_priorities fixed bin (35),		/* Count for metering */
  2   236     2 relinquishes fixed bin (35),			/* Calls to relinquish_priority */
  2   237     2 abort_ips_mask bit (36) aligned,			/* IPS mask for tc_util$check_abort */
  2   238 
  2   239 /* 500 octal */
  2   240 
  2   241     2 uid_array (0:15) bit (36) aligned,		/* array from which a uid is chosen (randomly) */
  2   242     2 pad5 (176) fixed bin (35),			/* room for expansion compatibly		*/
  2   243 
  2   244 /* 1000 octal */
  2   245 
  2   246     2 pad7 (64) fixed bin (35),
  2   247 
  2   248 /* 1100 octal */
  2   249 
  2   250     2 pad6 (8) fixed bin (35),
  2   251     2 work_class_table aligned,			/* array of per workclass information */
  2   252       3 wcte (0:16) aligned like wct_entry,
  2   253 
  2   254 /* 3000 octal */
  2   255 
  2   256     2 apt fixed bin;
  2   257 
  2   258 dcl  wctep ptr;
  2   259 
  2   260 dcl 1 wct_entry aligned based (wctep),			/* Work class entry */
  2   261     2 thread unaligned,				/* Ready list */
  2   262       3 fp bit (18),				/* Head of ready list */
  2   263       3 bp bit (18),				/* Tail of ready list */
  2   264     2 flags unaligned,
  2   265       3 mnbz bit (1),				/* Sentinel bit must not be zero. */
  2   266       3 defined bit (1),
  2   267       3 io_priority bit (1),
  2   268       3 governed bit (1),
  2   269       3 interactive_q bit (1),
  2   270       3 pad bit (31),
  2   271     2 credits fixed bin (35),				/* Current worthiness of group */
  2   272     2 minf fixed bin (35),				/* min fraction of cpu */
  2   273     2 pin_weight fixed bin (35),			/* number of cycles to pin pages */
  2   274     2 eligibilities fixed bin (35),			/* Count of eligibilities awarded */
  2   275     2 cpu_sum fixed bin (71),				/* CPU used by members */
  2   276     2 resp1 fixed bin (71),
  2   277     2 resp2 fixed bin (71),
  2   278     2 quantum1 fixed bin (35),
  2   279     2 quantum2 fixed bin (35),
  2   280     2 rmeter1 fixed bin (71),
  2   281     2 rmeter2 fixed bin (71),
  2   282     2 rcount1 fixed bin (35),
  2   283     2 rcount2 fixed bin (35),
  2   284     2 realtime fixed bin (35),
  2   285     2 purging fixed bin (35),
  2   286     2 maxel fixed bin (35),
  2   287     2 nel fixed bin (35),
  2   288     2 number_thinks fixed bin (35),			/* number times process entered "think" state	*/
  2   289     2 number_queues fixed bin (35),			/* number times process entered "queued" state	*/
  2   290     2 total_think_time fixed bin (71),
  2   291     2 total_queue_time fixed bin (71),
  2   292 
  2   293 /*  The next three arrays  correspond to the array vcpu_response_bounds				*/
  2   294 
  2   295     2 number_processing (VCPU_RESPONSE_BOUNDS+1) fixed bin (35), /* number times entered "processing" state	*/
  2   296     2 total_processing_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  2   297     2 total_vcpu_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  2   298     2 maxf fixed bin (35),				/* maximum fraction of cpu time		*/
  2   299     2 governing_credits fixed bin (35),			/* for limiting cpu resources			*/
  2   300     2 pad1 (4) fixed bin (35);
  2   301 	
  2   302 
  2   303 dcl 1 based_sentinel aligned based,			/* format of pxss-style sentinel */
  2   304     2 fp bit (18) unal,
  2   305     2 bp bit (18) unal,
  2   306     2 sentinel bit (36) aligned;
  2   307 
  2   308 dcl VCPU_RESPONSE_BOUNDS fixed bin init (3) int static options (constant);
  2   309 
  2   310 /* END INCLUDE FILE tcm.incl.pl1 */
       50 
       51 	/* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  3     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  3     3*   encourages name conflicts.
  3     4*   USE HC_FAST_LOCK INSTEAD!
  3     5**/
  3     6 
  3     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     8 
  3     9 /* format: style3 */
  3    10 
  3    11 declare	lock_ptr		pointer;
  3    12 declare	1 lock		aligned based (lock_ptr),
  3    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    15 	  2 flags		aligned,
  3    16 	    3 notify_sw	bit (1) unaligned,
  3    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    18 
  3    19 /* End include file hc_lock.incl.pl1 */
       51 
       52 
       53 /* 
       54*   get_buffers
       55*
       56*   This entry is called to reserve 4 buffers in the combined linkage
       57*   segment(s) for the process. One buffer is used for the current sst data,
       58*   one buffer is used for the past sst data, one buffer is used for the
       59*   current tc_data data, and the last buffer is used for the past tc_data
       60*   data.						 */
       61 
       62 get_buffers: entry (unique_index, a_sstp1, a_sstp2, a_tcdp1, a_tcdp2, code);
       63 
       64 	unique_index = static_index;
       65 	static_index = static_index + 1;		/* increment unique index generator */
       66 	if static_index > 40 then do;			/* don't let things get out of hand */
       67 	     code = 1;
       68 	     return;
       69 	end;
       70 
       71 	call hcs_$assign_linkage (1584, lp, code);	/* reserve the necessary storage */
       72 	if code ^= 0 then return;
       73 
       74 	p = addr (pa (unique_index));			/* get pointer to the current sub-structure */
       75 	sstp1, a_sstp1 = lp;			/* generate pointers, return them, and save them */
       76 	sstp2, a_sstp2 = addrel (lp, 512);
       77 	tcdp1, a_tcdp1 = addrel (lp, 1024);
       78 	tcdp2, a_tcdp2 = addrel (lp, 1304);
       79 
       80 	if ^ inited then do;			/* if haven't got ring zero pointers yet, get them */
       81 	     call ring0_get_$segptr ("", "sst", sstp0, code); /* get ring zero sst pointer */
       82 	     if code ^= 0 then return;
       83 	     call ring0_get_$segptr ("", "tc_data", tcdp0, code); /* get ring zero tc_data pointer */
       84 	     inited = "1"b;				/* indicated we've found the pointers */
       85 	end;
       86 
       87 	return;
       88 
       89 fill_buffers: entry (unique_index);
       90 
       91 /* This entry reads the current data from the sst and tc_data and
       92*   copies it into the "current" buffer for the specified caller. */
       93 
       94 	p = addr (pa (unique_index));			/* get a pointer to the current set of pointers */
       95 	call ring_zero_peek_ (sstp0, sstp2, 512, error_code); /* copy out the sst */
       96 	call ring_zero_peek_ (tcdp0, tcdp2, 280, error_code); /* copy out the tc_data header */
       97 
       98 	return;
       99 
      100 reset:	entry (unique_index);
      101 
      102 /* This entry is called to copy the current buffers into the old buffers
      103*   and hence cause an effective reset of the meters. */
      104 
      105 	p = addr (pa (unique_index));			/* get a pointer to the current set of pointers */
      106 	reset_called = 1;				/* set flag saying reset was called */
      107 	tcdp1 -> move_280 = tcdp2 -> move_280;		/* copy the tc_data header */
      108 	sstp1 -> move_512 = sstp2 -> move_512;		/* copt the sst header */
      109 
      110 	return;
      111 
      112 time:	entry (unique_index, a_meter_time);
      113 
      114 /* This entry prints the time of the metering interval and returns
      115*   the same to the caller. */
      116 
      117 	p = addr (pa (unique_index));			/* get a pointer to the callers variables */
      118 	if reset_called = 0 then
      119 	     meter_time = tcdp2 -> tcm.last_time - tcdp2 -> tcm.initialize_time; /* use time since bootload */
      120 	else
      121 	meter_time = tcdp2 -> tcm.last_time - tcdp1 -> tcm.last_time; /* use time since last reset */
      122 
      123 	sec = meter_time*1e-6;			/* get number of seconds of metering */
      124 	min = divide (sec, 60, 17, 0);		/* get minutes of metering */
      125 	hr = divide (min, 60, 17, 0);			/* get hours of metering */
      126 	sec = mod (sec, 60);			/* get seconds left in last minute */
      127 	min = mod (min, 60);			/* get minutes left in last hour */
      128 	call ioa_$rsnnl ("^4d^3d^3d", rs, ignore, hr, min+100, sec+100); /* convert to character string */
      129 	substr (rs, 5, 1) = ":";			/* fill in separators */
      130 	substr (rs, 8, 1) = ":";
      131 	call ioa_ ("^/Total metering time^-^a^/", rs);	/* print out the metring time */
      132 
      133 	a_meter_time = meter_time;			/* return metering interval lenght */
      134 
      135 	return;
      136 
      137      end meter_util_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1306.0  meter_util_.pl1                   >spec>temp>41-5>meter_util_.pl1
49           1    01/22/85  1321.6  sst.incl.pl1                      >spec>temp>41-5>sst.incl.pl1
50           2    01/22/85  1321.5  tcm.incl.pl1                      >spec>temp>41-5>tcm.incl.pl1
51           3    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_meter_time                           parameter       float bin(27)            dcl 24 set ref 112 133*
a_sstp1                                parameter       pointer                  dcl 24 set ref 62 75*
a_sstp2                                parameter       pointer                  dcl 24 set ref 62 76*
a_tcdp1                                parameter       pointer                  dcl 24 set ref 62 77*
a_tcdp2                                parameter       pointer                  dcl 24 set ref 62 78*
addr                                                   builtin function         dcl 24 ref 74 94 105 117
addrel                                                 builtin function         dcl 24 ref 76 77 78
based_sentinel                         based           structure                level 1 dcl 2-303
code                                   parameter       fixed bin(17,0)          dcl 24 set ref 62 67* 71* 72 81* 82 83*
divide                                                 builtin function         dcl 24 ref 124 125
error_code                      000114 automatic       fixed bin(35,0)          dcl 24 set ref 95* 96*
hcs_$assign_linkage             000650 constant        entry                    external dcl 24 ref 71
hr                              000113 automatic       fixed bin(17,0)          dcl 24 set ref 125* 128*
ignore                          000110 automatic       fixed bin(17,0)          dcl 24 set ref 128*
inited                          000636 internal static bit(1)                   initial unaligned dcl 24 set ref 80 84*
initialize_time         336            based           fixed bin(71,0)          level 2 dcl 2-11 ref 118
ioa_                            000642 constant        entry                    external dcl 24 ref 131
ioa_$rsnnl                      000644 constant        entry                    external dcl 24 ref 128
last_time                34            based           fixed bin(71,0)          level 2 dcl 2-11 ref 118 120 120
lock                                   based           structure                level 1 dcl 3-12
lp                              000106 automatic       pointer                  dcl 24 set ref 71* 75 76 77 78
meter_time                      000100 automatic       float bin(27)            dcl 24 set ref 118* 120* 123 133
min                             000112 automatic       fixed bin(17,0)          dcl 24 set ref 124* 125 127* 127 128
mod                                                    builtin function         dcl 24 ref 126 127
move_280                               based           fixed bin(17,0)          array dcl 24 set ref 107* 107
move_512                               based           fixed bin(17,0)          array dcl 24 set ref 108* 108
p                               000104 automatic       pointer                  dcl 24 set ref 74* 75 76 77 78 94* 95 96 105* 106
                                                                                  107 107 108 108 117* 118 118 118 120 120
pa                              000010 internal static structure                array level 1 dcl 21 set ref 74 94 105 117
pa1                                    based           structure                level 1 dcl 44
reset_called                           based           fixed bin(17,0)          level 2 dcl 44 set ref 106* 118
ring0_get_$segptr               000646 constant        entry                    external dcl 24 ref 81 83
ring_zero_peek_                 000640 constant        entry                    external dcl 24 ref 95 96
rs                              000101 automatic       char(12)                 dcl 24 set ref 128* 129* 130* 131*
sec                             000111 automatic       fixed bin(17,0)          dcl 24 set ref 123* 124 126* 126 128
sstp0                           000632 internal static pointer                  dcl 24 set ref 81* 95*
sstp1                     2            based           pointer                  level 2 dcl 44 set ref 75* 108
sstp2                     4            based           pointer                  level 2 dcl 44 set ref 76* 95* 108
static_index                    000630 internal static fixed bin(17,0)          initial dcl 24 set ref 64 65* 65 66
substr                                                 builtin function         dcl 24 set ref 129* 130*
tcdp0                           000634 internal static pointer                  dcl 24 set ref 83* 96*
tcdp1                     6            based           pointer                  level 2 dcl 44 set ref 77* 107 120
tcdp2                    10            based           pointer                  level 2 dcl 44 set ref 78* 96* 107 118 118 120
tcm                                    based           structure                level 1 dcl 2-11
unique_index                           parameter       fixed bin(17,0)          dcl 24 set ref 62 64* 74 89 94 100 105 112 117
wct_entry                              based           structure                level 1 dcl 2-260

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VCPU_RESPONSE_BOUNDS                   internal static fixed bin(17,0)          initial dcl 2-308
lock_ptr                               automatic       pointer                  dcl 3-11
sst                                    based           structure                level 1 dcl 1-9
sst_seg$                               external static fixed bin(17,0)          dcl 1-6
sstp                                   automatic       pointer                  dcl 1-7
tcmp                                   automatic       pointer                  dcl 2-9
wctep                                  automatic       pointer                  dcl 2-258

NAMES DECLARED BY EXPLICIT CONTEXT.
fill_buffers                    000223 constant        entry                    external dcl 89
get_buffers                     000045 constant        entry                    external dcl 62
meter_util_                     000031 constant        entry                    external dcl 11
reset                           000277 constant        entry                    external dcl 100
time                            000333 constant        entry                    external dcl 112

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       616        1470     501         626
Length      1720     501       652         214     115         630

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
meter_util_                         134 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 pa                          meter_util_
000630 static_index                meter_util_
000632 sstp0                       meter_util_
000634 tcdp0                       meter_util_
000636 inited                      meter_util_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
meter_util_              000100 meter_time                  meter_util_
                         000101 rs                          meter_util_
                         000104 p                           meter_util_
                         000106 lp                          meter_util_
                         000110 ignore                      meter_util_
                         000111 sec                         meter_util_
                         000112 min                         meter_util_
                         000113 hr                          meter_util_
                         000114 error_code                  meter_util_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              fl2_to_fx1          mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$assign_linkage           ioa_                          ioa_$rsnnl                    ring0_get_$segptr
ring_zero_peek_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS
000000  aa     524000000033

000001  aa     404000000022

000002  aa     524000000014

000003  aa     524000000011

000500  aa     000000000074

000004  aa     732414336750

000005  aa     524000000007

000006  aa     524000000003

000007  aa  163 163 164 000	sst

000010  aa     524000000000

000011  aa     464000000000

000012  aa     414000000033

000013  aa     404000000021

000014  aa  164 143 137 144	tc_d
000015  aa  141 164 141 000	ata

000016  aa  136 064 144 136	^4d^
000017  aa  063 144 136 063	3d^3
000020  aa  144 000 000 000	d

000021  aa  136 057 124 157	^/To
000022  aa  164 141 154 040	tal 
000023  aa  155 145 164 145	mete
000024  aa  162 151 156 147	ring
000025  aa  040 164 151 155	 tim
000026  aa  145 136 055 136	e^-^
000027  aa  141 136 057 000	a^/

BEGIN PROCEDURE meter_util_
ENTRY TO meter_util_                                        STATEMENT 1 ON LINE 11
meter_util_: proc;

000030  da     000062200000
000031  aa   000220 6270 00	eax7 	144
000032  aa  7 00034 3521 20	epp2 	pr7|28,*
000033  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000034  aa     000000000000
000035  aa     000000000000
						STATEMENT 1 ON LINE 62
get_buffers: entry (unique_index, a_sstp1, a_sstp2, a_tcdp1, a_tcdp2, code);

000036  aa   000014 7100 04	tra  	12,ic		000052
ENTRY TO get_buffers                                        STATEMENT 1 ON LINE 62
get_buffers: entry (unique_index, a_sstp1, a_sstp2, a_tcdp1, a_tcdp2, code);

000037  at     000006000013
000040  tt     000011000011
000041  tt     000011000011
000042  ta     000013000000
000043  ta     000037000000
000044  da     000070300000
000045  aa   000220 6270 00	eax7 	144
000046  aa  7 00034 3521 20	epp2 	pr7|28,*
000047  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000050  aa     000014000000
000051  aa     000000000000
						STATEMENT 1 ON LINE 64
	unique_index = static_index;

000052  ia  4 00630 2361 00	ldq  	pr4|408		static_index
000053  aa  6 00032 3735 20	epp7 	pr6|26,*
000054  aa  7 00002 7561 20	stq  	pr7|2,*		unique_index
						STATEMENT 1 ON LINE 65
	static_index = static_index + 1;

000055  ia  4 00630 0541 00	aos  	pr4|408		static_index
						STATEMENT 1 ON LINE 66
	if static_index > 40 then do;

000056  ia  4 00630 2361 00	ldq  	pr4|408		static_index
000057  aa   000050 1160 07	cmpq 	40,dl
000060  aa   000004 6044 04	tmoz 	4,ic		000064
						STATEMENT 1 ON LINE 67
	     code = 1;

000061  aa   000001 2360 07	ldq  	1,dl
000062  aa  7 00014 7561 20	stq  	pr7|12,*		code
						STATEMENT 1 ON LINE 68
	     return;

000063  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 69
	end;

						STATEMENT 1 ON LINE 71
	call hcs_$assign_linkage (1584, lp, code);

000064  aa   003060 2360 07	ldq  	1584,dl
000065  aa  6 00115 7561 00	stq  	pr6|77
000066  aa  6 00115 3521 00	epp2 	pr6|77
000067  aa  6 00120 2521 00	spri2	pr6|80
000070  aa  6 00106 3521 00	epp2 	pr6|70		lp
000071  aa  6 00122 2521 00	spri2	pr6|82
000072  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000073  aa  6 00124 2521 00	spri2	pr6|84
000074  aa  6 00116 6211 00	eax1 	pr6|78
000075  aa   014000 4310 07	fld  	6144,dl
000076  la  4 00650 3521 20	epp2 	pr4|424,*		hcs_$assign_linkage
000077  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 72
	if code ^= 0 then return;

000100  aa  6 00032 3735 20	epp7 	pr6|26,*
000101  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000102  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 74
	p = addr (pa (unique_index));

000103  aa  7 00002 2361 20	ldq  	pr7|2,*		unique_index
000104  aa   000012 4020 07	mpy  	10,dl
000105  aa  6 00044 3701 20	epp4 	pr6|36,*
000106  ia  4 77776 3715 06	epp5 	pr4|-2,ql		pa
000107  aa  6 00104 6515 00	spri5	pr6|68		p
						STATEMENT 1 ON LINE 75
	sstp1, a_sstp1 = lp;

000110  aa  6 00106 3535 20	epp3 	pr6|70,*		lp
000111  aa  5 00002 2535 00	spri3	pr5|2		pa1.sstp1
000112  aa  7 00004 2535 20	spri3	pr7|4,*		a_sstp1
						STATEMENT 1 ON LINE 76
	sstp2, a_sstp2 = addrel (lp, 512);

000113  aa  6 00106 3521 20	epp2 	pr6|70,*		lp
000114  aa   001000 0520 03	adwp2	512,du
000115  aa  6 00126 2521 00	spri2	pr6|86
000116  aa  5 00004 2521 00	spri2	pr5|4		pa1.sstp2
000117  aa  7 00006 2521 20	spri2	pr7|6,*		a_sstp2
						STATEMENT 1 ON LINE 77
	tcdp1, a_tcdp1 = addrel (lp, 1024);

000120  aa  6 00106 3521 20	epp2 	pr6|70,*		lp
000121  aa   002000 0520 03	adwp2	1024,du
000122  aa  6 00126 2521 00	spri2	pr6|86
000123  aa  5 00006 2521 00	spri2	pr5|6		pa1.tcdp1
000124  aa  7 00010 2521 20	spri2	pr7|8,*		a_tcdp1
						STATEMENT 1 ON LINE 78
	tcdp2, a_tcdp2 = addrel (lp, 1304);

000125  aa  6 00106 3521 20	epp2 	pr6|70,*		lp
000126  aa   002430 0520 03	adwp2	1304,du
000127  aa  6 00126 2521 00	spri2	pr6|86
000130  aa  5 00010 2521 00	spri2	pr5|8		pa1.tcdp2
000131  aa  7 00012 2521 20	spri2	pr7|10,*		a_tcdp2
						STATEMENT 1 ON LINE 80
	if ^ inited then do;

000132  ia  4 00636 2351 00	lda  	pr4|414		inited
000133  aa   000064 6010 04	tnz  	52,ic		000217
						STATEMENT 1 ON LINE 81
	     call ring0_get_$segptr ("", "sst", sstp0, code);

000134  aa   777653 2350 04	lda  	-85,ic		000007 = 163163164000
000135  aa  6 00130 7551 00	sta  	pr6|88
000136  aa  6 00115 3521 00	epp2 	pr6|77
000137  aa  6 00134 2521 00	spri2	pr6|92
000140  aa  6 00130 3521 00	epp2 	pr6|88
000141  aa  6 00136 2521 00	spri2	pr6|94
000142  ia  4 00632 3521 00	epp2 	pr4|410		sstp0
000143  aa  6 00140 2521 00	spri2	pr6|96
000144  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000145  aa  6 00142 2521 00	spri2	pr6|98
000146  aa   777642 3520 04	epp2 	-94,ic		000010 = 524000000000
000147  aa  6 00144 2521 00	spri2	pr6|100
000150  aa   777636 3520 04	epp2 	-98,ic		000006 = 524000000003
000151  aa  6 00146 2521 00	spri2	pr6|102
000152  aa   777637 3520 04	epp2 	-97,ic		000011 = 464000000000
000153  aa  6 00150 2521 00	spri2	pr6|104
000154  aa   777637 3520 04	epp2 	-97,ic		000013 = 404000000021
000155  aa  6 00152 2521 00	spri2	pr6|106
000156  aa  6 00132 6211 00	eax1 	pr6|90
000157  aa   020000 4310 07	fld  	8192,dl
000160  la  4 00646 3521 20	epp2 	pr4|422,*		ring0_get_$segptr
000161  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 82
	     if code ^= 0 then return;

000162  aa  6 00032 3735 20	epp7 	pr6|26,*
000163  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000164  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 83
	     call ring0_get_$segptr ("", "tc_data", tcdp0, code);

000165  aa   777627 2370 04	ldaq 	-105,ic		000014 = 164143137144 141164141000
000166  aa  6 00126 7571 00	staq 	pr6|86
000167  aa  6 00130 3521 00	epp2 	pr6|88
000170  aa  6 00134 2521 00	spri2	pr6|92
000171  aa  6 00126 3521 00	epp2 	pr6|86
000172  aa  6 00136 2521 00	spri2	pr6|94
000173  aa  6 00044 3701 20	epp4 	pr6|36,*
000174  ia  4 00634 3521 00	epp2 	pr4|412		tcdp0
000175  aa  6 00140 2521 00	spri2	pr6|96
000176  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000177  aa  6 00142 2521 00	spri2	pr6|98
000200  aa   777610 3520 04	epp2 	-120,ic		000010 = 524000000000
000201  aa  6 00144 2521 00	spri2	pr6|100
000202  aa   777603 3520 04	epp2 	-125,ic		000005 = 524000000007
000203  aa  6 00146 2521 00	spri2	pr6|102
000204  aa   777605 3520 04	epp2 	-123,ic		000011 = 464000000000
000205  aa  6 00150 2521 00	spri2	pr6|104
000206  aa   777605 3520 04	epp2 	-123,ic		000013 = 404000000021
000207  aa  6 00152 2521 00	spri2	pr6|106
000210  aa  6 00132 6211 00	eax1 	pr6|90
000211  aa   020000 4310 07	fld  	8192,dl
000212  la  4 00646 3521 20	epp2 	pr4|422,*		ring0_get_$segptr
000213  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 84
	     inited = "1"b;

000214  aa   400000 2350 03	lda  	131072,du
000215  aa  6 00044 3701 20	epp4 	pr6|36,*
000216  ia  4 00636 7551 00	sta  	pr4|414		inited
						STATEMENT 1 ON LINE 85
	end;

						STATEMENT 1 ON LINE 87
	return;

000217  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO fill_buffers                                       STATEMENT 1 ON LINE 89
fill_buffers: entry (unique_index);

000220  at     000001000013
000221  ta     000220000000
000222  da     000077300000
000223  aa   000220 6270 00	eax7 	144
000224  aa  7 00034 3521 20	epp2 	pr7|28,*
000225  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000226  aa     000002000000
000227  aa     000000000000
						STATEMENT 1 ON LINE 94
	p = addr (pa (unique_index));

000230  aa  6 00032 3735 20	epp7 	pr6|26,*
000231  aa  7 00002 2361 20	ldq  	pr7|2,*		unique_index
000232  aa   000012 4020 07	mpy  	10,dl
000233  aa  6 00044 3701 20	epp4 	pr6|36,*
000234  ia  4 77776 3715 06	epp5 	pr4|-2,ql		pa
000235  aa  6 00104 6515 00	spri5	pr6|68		p
						STATEMENT 1 ON LINE 95
	call ring_zero_peek_ (sstp0, sstp2, 512, error_code);

000236  aa   001000 2360 07	ldq  	512,dl
000237  aa  6 00130 7561 00	stq  	pr6|88
000240  ia  4 00632 3521 00	epp2 	pr4|410		sstp0
000241  aa  6 00134 2521 00	spri2	pr6|92
000242  aa  5 00004 3521 00	epp2 	pr5|4		pa1.sstp2
000243  aa  6 00136 2521 00	spri2	pr6|94
000244  aa  6 00130 3521 00	epp2 	pr6|88
000245  aa  6 00140 2521 00	spri2	pr6|96
000246  aa  6 00114 3521 00	epp2 	pr6|76		error_code
000247  aa  6 00142 2521 00	spri2	pr6|98
000250  aa  6 00132 6211 00	eax1 	pr6|90
000251  aa   020000 4310 07	fld  	8192,dl
000252  la  4 00640 3521 20	epp2 	pr4|416,*		ring_zero_peek_
000253  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 96
	call ring_zero_peek_ (tcdp0, tcdp2, 280, error_code);

000254  aa   000430 2360 07	ldq  	280,dl
000255  aa  6 00130 7561 00	stq  	pr6|88
000256  aa  6 00044 3701 20	epp4 	pr6|36,*
000257  ia  4 00634 3521 00	epp2 	pr4|412		tcdp0
000260  aa  6 00134 2521 00	spri2	pr6|92
000261  aa  6 00104 3735 20	epp7 	pr6|68,*		p
000262  aa  7 00010 3521 00	epp2 	pr7|8		pa1.tcdp2
000263  aa  6 00136 2521 00	spri2	pr6|94
000264  aa  6 00130 3521 00	epp2 	pr6|88
000265  aa  6 00140 2521 00	spri2	pr6|96
000266  aa  6 00114 3521 00	epp2 	pr6|76		error_code
000267  aa  6 00142 2521 00	spri2	pr6|98
000270  aa  6 00132 6211 00	eax1 	pr6|90
000271  aa   020000 4310 07	fld  	8192,dl
000272  la  4 00640 3521 20	epp2 	pr4|416,*		ring_zero_peek_
000273  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 98
	return;

000274  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO reset                                              STATEMENT 1 ON LINE 100
reset:	entry (unique_index);

000275  ta     000220000000
000276  da     000104300000
000277  aa   000220 6270 00	eax7 	144
000300  aa  7 00034 3521 20	epp2 	pr7|28,*
000301  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000302  aa     000002000000
000303  aa     000000000000
						STATEMENT 1 ON LINE 105
	p = addr (pa (unique_index));

000304  aa  6 00032 3735 20	epp7 	pr6|26,*
000305  aa  7 00002 2361 20	ldq  	pr7|2,*		unique_index
000306  aa   000012 4020 07	mpy  	10,dl
000307  aa  6 00044 3701 20	epp4 	pr6|36,*
000310  ia  4 77776 3715 06	epp5 	pr4|-2,ql		pa
000311  aa  6 00104 6515 00	spri5	pr6|68		p
						STATEMENT 1 ON LINE 106
	reset_called = 1;

000312  aa   000001 2360 07	ldq  	1,dl
000313  aa  5 00000 7561 00	stq  	pr5|0		pa1.reset_called
						STATEMENT 1 ON LINE 107
	tcdp1 -> move_280 = tcdp2 -> move_280;

000314  aa  5 00006 3535 20	epp3 	pr5|6,*		pa1.tcdp1
000315  aa  5 00010 3515 20	epp1 	pr5|8,*		pa1.tcdp2
000316  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000317  aa  1 00000 00 2140	desc9a	pr1|0,1120	move_280
000320  aa  3 00000 00 2140	desc9a	pr3|0,1120	move_280
						STATEMENT 1 ON LINE 108
	sstp1 -> move_512 = sstp2 -> move_512;

000321  aa  5 00002 3535 20	epp3 	pr5|2,*		pa1.sstp1
000322  aa  5 00004 3515 20	epp1 	pr5|4,*		pa1.sstp2
000323  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000324  aa  1 00000 00 4000	desc9a	pr1|0,2048	move_512
000325  aa  3 00000 00 4000	desc9a	pr3|0,2048	move_512
						STATEMENT 1 ON LINE 110
	return;

000326  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO time                                               STATEMENT 1 ON LINE 112
time:	entry (unique_index, a_meter_time);

000327  at     000002000013
000330  ta     000012000000
000331  ta     000327000000
000332  da     000111300000
000333  aa   000220 6270 00	eax7 	144
000334  aa  7 00034 3521 20	epp2 	pr7|28,*
000335  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000336  aa     000004000000
000337  aa     000000000000
						STATEMENT 1 ON LINE 117
	p = addr (pa (unique_index));

000340  aa  6 00032 3735 20	epp7 	pr6|26,*
000341  aa  7 00002 2361 20	ldq  	pr7|2,*		unique_index
000342  aa   000012 4020 07	mpy  	10,dl
000343  aa  6 00044 3701 20	epp4 	pr6|36,*
000344  ia  4 77776 3715 06	epp5 	pr4|-2,ql		pa
000345  aa  6 00104 6515 00	spri5	pr6|68		p
						STATEMENT 1 ON LINE 118
	if reset_called = 0 then
	     meter_time = tcdp2 -> tcm.last_time - tcdp2 -> tcm.initialize_time;

000346  aa  5 00000 2361 00	ldq  	pr5|0		pa1.reset_called
000347  aa   000010 6010 04	tnz  	8,ic		000357
000350  aa  5 00010 3535 20	epp3 	pr5|8,*		pa1.tcdp2
000351  aa  3 00034 2371 00	ldaq 	pr3|28		tcm.last_time
000352  aa  3 00336 1771 00	sbaq 	pr3|222		tcm.initialize_time
000353  aa   216000 4110 03	lde  	72704,du
000354  aa   400000 4750 03	fad  	131072,du
000355  aa  6 00100 4551 00	fst  	pr6|64		meter_time
000356  aa   000010 7100 04	tra  	8,ic		000366
						STATEMENT 1 ON LINE 120
	else
	meter_time = tcdp2 -> tcm.last_time - tcdp1 -> tcm.last_time;

000357  aa  5 00010 3535 20	epp3 	pr5|8,*		pa1.tcdp2
000360  aa  3 00034 2371 00	ldaq 	pr3|28		tcm.last_time
000361  aa  5 00006 3515 20	epp1 	pr5|6,*		pa1.tcdp1
000362  aa  1 00034 1771 00	sbaq 	pr1|28		tcm.last_time
000363  aa   216000 4110 03	lde  	72704,du
000364  aa   400000 4750 03	fad  	131072,du
000365  aa  6 00100 4551 00	fst  	pr6|64		meter_time
						STATEMENT 1 ON LINE 123
	sec = meter_time*1e-6;

000366  aa   777416 4610 04	fmp  	-242,ic		000004 = 732414336750
000367  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
000370  aa  6 00111 7561 00	stq  	pr6|73		sec
						STATEMENT 1 ON LINE 124
	min = divide (sec, 60, 17, 0);

000371  aa   000074 5060 07	div  	60,dl
000372  aa  6 00112 7561 00	stq  	pr6|74		min
						STATEMENT 1 ON LINE 125
	hr = divide (min, 60, 17, 0);

000373  aa   000074 5060 07	div  	60,dl
000374  aa  6 00113 7561 00	stq  	pr6|75		hr
						STATEMENT 1 ON LINE 126
	sec = mod (sec, 60);

000375  aa  6 00111 2361 00	ldq  	pr6|73		sec
000376  aa   000102 3520 04	epp2 	66,ic		000500 = 000000000074
000377  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000400  aa  6 00111 7561 00	stq  	pr6|73		sec
						STATEMENT 1 ON LINE 127
	min = mod (min, 60);

000401  aa  6 00112 2361 00	ldq  	pr6|74		min
000402  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
000403  aa  6 00112 7561 00	stq  	pr6|74		min
						STATEMENT 1 ON LINE 128
	call ioa_$rsnnl ("^4d^3d^3d", rs, ignore, hr, min+100, sec+100);

000404  aa   777412 2370 04	ldaq 	-246,ic		000016 = 136064144136 063144136063
000405  aa  6 00116 7571 00	staq 	pr6|78
000406  aa   144000 2350 03	lda  	51200,du
000407  aa  6 00120 7551 00	sta  	pr6|80
000410  aa  6 00112 2361 00	ldq  	pr6|74		min
000411  aa   000144 0760 07	adq  	100,dl
000412  aa  6 00130 7561 00	stq  	pr6|88
000413  aa  6 00111 2361 00	ldq  	pr6|73		sec
000414  aa   000144 0760 07	adq  	100,dl
000415  aa  6 00115 7561 00	stq  	pr6|77
000416  aa  6 00116 3521 00	epp2 	pr6|78
000417  aa  6 00156 2521 00	spri2	pr6|110
000420  aa  6 00101 3521 00	epp2 	pr6|65		rs
000421  aa  6 00160 2521 00	spri2	pr6|112
000422  aa  6 00110 3521 00	epp2 	pr6|72		ignore
000423  aa  6 00162 2521 00	spri2	pr6|114
000424  aa  6 00113 3521 00	epp2 	pr6|75		hr
000425  aa  6 00164 2521 00	spri2	pr6|116
000426  aa  6 00130 3521 00	epp2 	pr6|88
000427  aa  6 00166 2521 00	spri2	pr6|118
000430  aa  6 00115 3521 00	epp2 	pr6|77
000431  aa  6 00170 2521 00	spri2	pr6|120
000432  aa   777351 3520 04	epp2 	-279,ic		000003 = 524000000011
000433  aa  6 00172 2521 00	spri2	pr6|122
000434  aa   777346 3520 04	epp2 	-282,ic		000002 = 524000000014
000435  aa  6 00174 2521 00	spri2	pr6|124
000436  aa   777355 3520 04	epp2 	-275,ic		000013 = 404000000021
000437  aa  6 00176 2521 00	spri2	pr6|126
000440  aa  6 00200 2521 00	spri2	pr6|128
000441  aa   777340 3520 04	epp2 	-288,ic		000001 = 404000000022
000442  aa  6 00202 2521 00	spri2	pr6|130
000443  aa  6 00204 2521 00	spri2	pr6|132
000444  aa  6 00154 6211 00	eax1 	pr6|108
000445  aa   030000 4310 07	fld  	12288,dl
000446  la  4 00644 3521 20	epp2 	pr4|420,*		ioa_$rsnnl
000447  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 129
	substr (rs, 5, 1) = ":";

000450  aa   072000 2350 03	lda  	29696,du
000451  aa  6 00102 5511 40	stba 	pr6|66,40		rs
						STATEMENT 1 ON LINE 130
	substr (rs, 8, 1) = ":";

000452  aa   000072 2350 07	lda  	58,dl
000453  aa  6 00102 5511 04	stba 	pr6|66,04		rs
						STATEMENT 1 ON LINE 131
	call ioa_ ("^/Total metering time^-^a^/", rs);

000454  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000455  aa   777345 00 0034	desc9a	-283,28		000021 = 136057124157
000456  aa  6 00116 00 0034	desc9a	pr6|78,28
000457  aa  6 00116 3521 00	epp2 	pr6|78
000460  aa  6 00134 2521 00	spri2	pr6|92
000461  aa  6 00101 3521 00	epp2 	pr6|65		rs
000462  aa  6 00136 2521 00	spri2	pr6|94
000463  aa   777315 3520 04	epp2 	-307,ic		000000 = 524000000033
000464  aa  6 00140 2521 00	spri2	pr6|96
000465  aa   777315 3520 04	epp2 	-307,ic		000002 = 524000000014
000466  aa  6 00142 2521 00	spri2	pr6|98
000467  aa  6 00132 6211 00	eax1 	pr6|90
000470  aa   010000 4310 07	fld  	4096,dl
000471  aa  6 00044 3701 20	epp4 	pr6|36,*
000472  la  4 00642 3521 20	epp2 	pr4|418,*		ioa_
000473  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 133
	a_meter_time = meter_time;

000474  aa  6 00100 4311 00	fld  	pr6|64		meter_time
000475  aa  6 00032 3735 20	epp7 	pr6|26,*
000476  aa  7 00004 4551 20	fst  	pr7|4,*		a_meter_time
						STATEMENT 1 ON LINE 135
	return;

000477  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 137
     end meter_util_;

  END PROCEDURE meter_util_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
