	COMPILATION LISTING OF SEGMENT compare_mst
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/16/87  1334.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 compare_mst: proc;
       13 
       14 /* format: off */
       15 
       16 /* This command mounts two mst tapes (the names of which are given as arguments)
       17*   and compares them, printing out all significant changes.
       18*
       19*   Written 9/20/74 by C. D. Tavares.
       20*
       21*   Rewritten by Kobziar 3/75 to handle additions, deletions, and moves. Also allows saving of segment contents
       22*   if they are different, and header copmparisons corrected to ignore acl pad field.
       23*   Can compare any number of collections, ie. service or bos tapes.
       24*
       25*   Modified 11/05/80, W. Olin Sibert, to add -file control argument.
       26*   Modified 06/08/84, Keith Loepere, to work when an object appears on a tape more than once.
       27*   */
       28 
       29 
       30 /****^  HISTORY COMMENTS:
       31*  1) change(87-01-12,GDixon), approve(87-04-16,MCR7614),
       32*     audit(87-05-21,Farley), install(87-07-15,MR12.1-1040):
       33*     Add support for comparing MST data coming from either tape or disk files,
       34*     via -master_file and -copy_file control args.  Add a severity variable
       35*     to allow testing of success/fail of the compare operation.  Modernize code
       36*     somewhat (it needs more work, at some point in future, however).
       37*                                                   END HISTORY COMMENTS */
       38 
       39 
       40 
       41 	dcl     REWP		 char (64) static aligned options(constant)
       42 				 initial ("NULL   P  W   WP E   E P EW  EWPR   R  PR W R WPRE  RE PERW REWP");
       43 	dcl     OFF_ON		 char (8) static aligned options(constant) initial ("OFF ON  ");
       44 	dcl    (UNSET		 init(0),
       45 	        MASTER		 init(1),
       46 	        COPY		 init(2)) fixed bin int static options(constant);
       47 	dcl     abs_changes		 fixed bin int static options(constant) init (45);
       48 	dcl     mst_name		 (2) char (19) varying int static options(constant)
       49 				 initial ("compare_mst.master.", "compare_mst.copy.");
       50 	dcl     rew		 char (24) static aligned options(constant) initial ("n    w e  ewr  r wre rew");
       51 
       52 	dcl     arg		 char(argl) based(argp),
       53 	        opt		 char(optl) based(optp);
       54 
       55 	dcl     bits		 (bit_len) bit (1) unaligned based (bits_ptr); /* for index comparisons */
       56 
       57 	dcl     1 bootstrap_header	 aligned based,	/* special format for bound_bootload_0 header */
       58 		2 header_control_word like mst1.header_control_word aligned,
       59 		2 slte		 like slte aligned,
       60 		2 minus_ones	 (18) fixed bin (35), /* bad filler */
       61 		2 segment_control_word like mst1.segment_control_word aligned;
       62 
       63 	dcl     1 collection_mark_data based,
       64 		2 pad		 bit (36),	/* header word */
       65 		2 major		 fixed bin (18) uns unal,
       66 		2 minor		 fixed bin (18) uns unal;
       67 
       68 	dcl     header_words	 (bit_len) based fixed bin; /* entire header */
       69 
       70 	dcl     1 mst1		 aligned based (mst_ptr (1)), /* Format of an MST segment header */
       71 		2 header		 aligned,
       72 		  3 header_control_word aligned,
       73 		    4 collection_mark bit (18) unaligned, /* if non-zero, this is a 2-word collection mark only */
       74 		    4 header_length	 fixed bin (17) unaligned, /* length of REST of header, not counting first 2 wds */
       75 
       76 		  3 slte		 like slte aligned, /* first word of slte is a dummy, rest used */
       77 
       78 		  3 names_array	 aligned,		/* this is always there, except for bound_bootload_0 */
       79 		    4 n_names	 fixed bin aligned, /* number of names */
       80 		    4 name_element	 (n_names (1)) aligned,
       81 		      5 n_chars	 fixed bin aligned, /* number of chars in each name */
       82 		      5 name	 char (32) aligned, /* the name */
       83 
       84 		  3 pathname_array	 (has_branch (1)) aligned, /* This may or may not be there, hence the zero subscripting */
       85 		    4 pathname_length fixed bin aligned,/* pathname is exactly this long, plus spaces to fill */
       86 		    4 pathname	 char (path_length (1)) aligned, /* out to end of a word */
       87 
       88 		  3 acl_structure	 (has_acl (1)) aligned, /* This also may or may not be there */
       89 		    4 n_acls	 fixed bin,	/* number of acl entries */
       90 		    4 acl		 (n_acls (1)) aligned, /* Each acl */
       91 		      5 accessname	 char (32) aligned,
       92 		      5 mode	 bit (3) aligned,	/* r, e, w */
       93 		      5 pad	 (2) fixed bin,
       94 
       95 		  3 segment_control_word aligned,	/* This tells about the segment following */
       96 		    4 ident	 fixed bin (17) unaligned, /* This is always a one */
       97 		    4 segment_length fixed bin (17) unaligned; /* in words, of seg following */
       98 
       99 
      100 	dcl     1 mst2		 based (mst_ptr (2)) aligned, /* same thing as mst1; look up there. */
      101 		2 header		 aligned,
      102 		  3 header_control_word aligned,
      103 		    4 collection_mark bit (18) unaligned,
      104 		    4 header_length	 fixed bin (17) unaligned,
      105 
      106 		  3 slte		 like slte aligned,
      107 
      108 		  3 names_array	 aligned,
      109 		    4 n_names	 fixed bin aligned,
      110 		    4 name_element	 (n_names (2)) aligned,
      111 		      5 n_chars	 fixed bin aligned,
      112 		      5 name	 char (32) aligned,
      113 
      114 		  3 pathname_array	 (has_branch (2)) aligned,
      115 		    4 pathname_length fixed bin aligned,
      116 		    4 pathname	 char (path_length (2)) aligned,
      117 
      118 		  3 acl_structure	 (has_acl (2)) aligned,
      119 		    4 n_acls	 fixed bin,
      120 		    4 acl		 (n_acls (2)) aligned,
      121 		      5 accessname	 char (32) aligned,
      122 		      5 mode	 bit (3) aligned,
      123 		      5 pad	 (2) fixed bin,
      124 
      125 		  3 segment_control_word aligned,
      126 		    4 ident	 fixed bin (17) unaligned,
      127 		    4 segment_length fixed bin (17) unaligned;
      128 
      129 	dcl     segment_1		 (seg_length (1)) based fixed bin;
      130 	dcl     segment_2		 (seg_length (2)) based fixed bin;
      131 
      132 	dcl     sys_id_pickup	 char (8) aligned based;
      133 
      134 	dcl     1 tp_name		 based aligned,
      135 		2 order_info,			/* info that we maintain relative to an object's order on the tape. */
      136 		  3 name		 char (32),	/* primary name of seg */
      137 		  3 org_index	 fixed bin,	/* value of org sequence in list before sort */
      138 		  3 major_collection fixed bin,	/* segment contained within */
      139 		  3 minor_collection fixed bin,
      140 		  3 sw		 unaligned,	/* status of this seg */
      141 		    4 col		 bit (1),		/* indicates a collection mark */
      142 		    4 add		 bit (1),
      143 		    4 del		 bit (1),
      144 		    4 mov		 bit (1),
      145 		2 info_ptr	 ptr,		/* pts to seg  body if saving or moved */
      146 		2 head_ptr	 ptr,		/* pts to header if seg  has been moved */
      147 		2 move_index	 fixed bin,	/* points to second list's correspondin g seg */
      148 		2 pos_n		 fixed bin;	/* points to place in list where orjg name now is stored */
      149 
      150 	dcl     1 tp1_names		 (name_count (1)) based (np (1)) aligned like tp_name;
      151 	dcl     1 tp2_names		 (name_count (2)) based (np (2)) aligned like tp_name;
      152 
      153 	dcl     argl		 fixed bin(21);
      154 	dcl     anp		 (2) ptr;
      155 	dcl     argp		 pointer;
      156 	dcl     arg_count		 fixed bin;
      157 	dcl     argx		 fixed bin;
      158 	dcl     atd		 char(256);
      159 	dcl     bit_len		 fixed bin;
      160 	dcl     bits_ptr		 pointer;
      161 	dcl     boot_label		 (2) bit(1) aligned;
      162 	dcl     boot_ptr		 (2) ptr;
      163 	dcl     bootstrap_sw	 (2) bit (1) aligned;
      164 	dcl     1 bpi		 (2) aligned like boot_program_info;
      165 	dcl     code		 fixed bin (35);
      166 	dcl     collection		 bit (1) aligned;
      167 	dcl     copy_ptr		 ptr;
      168 	dcl     has_acl		 dimension (2) fixed bin;
      169 	dcl     has_branch		 dimension (2) fixed bin;
      170 	dcl     have_sysid		 bit (1) aligned;
      171 	dcl     i			 fixed bin;
      172 	dcl     in_den		 (2) fixed bin;
      173 	dcl     in_file_name	 (2) char(168);
      174 	dcl     in_tape_name	 (2) char(32);
      175 	dcl     iocb_ptr		 (2) ptr;
      176 	dcl     j			 fixed bin;
      177 	dcl     k			 fixed bin;
      178 	dcl     l1_index		 fixed bin;
      179 	dcl     l2_index		 fixed bin;
      180 	dcl     master_copy		 fixed bin;
      181 	dcl     mst_ptr		 (2) pointer;
      182 	dcl     mst_ptr_hold	 (2) ptr;
      183 	dcl     n_acls		 dimension (2) fixed bin;
      184 	dcl     n_names		 dimension (2) fixed bin;
      185 	dcl     name_count		 (2) fixed bin;
      186 	dcl     name_len		 fixed bin(18) uns unal;
      187 	dcl     nelemt		 fixed bin (21);
      188 	dcl     np		 (2) ptr;
      189 	dcl     optl		 fixed bin(21);
      190 	dcl     optp		 ptr;
      191 	dcl     path_length		 dimension (2) fixed bin;
      192 	dcl     saving		 bit (1);
      193 	dcl     sci_ptr		 ptr;
      194 	dcl     seg_len		 fixed bin(18) uns unal;
      195 	dcl     seg_length		 (2) fixed bin;
      196 	dcl     segment_name	 char (32);
      197 	dcl     set		 fixed bin;
      198 	dcl     skip_1		 bit (1) aligned;
      199 	dcl     sys_id		 (2) char (8) aligned;
      200 
      201 	dcl     absolute_pathname_	 entry (char(*), char(*), fixed bin(35));
      202 	dcl     com_err_		 entry options (variable);
      203 	dcl     cu_$arg_list_ptr	 entry returns(ptr);
      204 	dcl     get_shortest_path_	 entry (char(*)) returns(char(168));
      205 	dcl     get_wdir_		 entry returns (char (168));
      206 	dcl     initiate_file_$create	 entry (char(*), char(*), bit(*), ptr, bit(1) aligned, fixed bin(24),
      207 				     fixed bin(35));
      208 	dcl     ioa_		 entry options (variable);
      209 	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
      210 	dcl     iox_$close		 entry (ptr, fixed bin (35));
      211 	dcl     iox_$control	 entry (ptr, char(*), ptr, fixed bin(35));
      212 	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
      213 	dcl     iox_$get_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      214 	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      215 	dcl     parse_tape_reel_name_	 entry (char(*), char(*));
      216 	dcl     ssu_$abort_subsystem	 entry() options(variable);
      217 	dcl     ssu_$arg_count	 entry (ptr, fixed bin);
      218 	dcl     ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin(21));
      219 	dcl     ssu_$destroy_invocation
      220 				 entry (ptr);
      221 	dcl     ssu_$get_temp_segment	 entry (ptr, char(*), ptr);
      222 	dcl     ssu_$standalone_invocation
      223 				 entry (ptr, char(*), char(*), ptr, entry, fixed bin(35));
      224 	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      225 	dcl     unique_chars_	 entry (bit(*)) returns(char(15));
      226 
      227 
      228           dcl     compare_mst_severity_  fixed bin ext static init(0);
      229 
      230 	dcl    (error_table_$bad_arg,
      231 	        error_table_$badopt,
      232 	        error_table_$end_of_info,
      233 	        error_table_$inconsistent,
      234 	        error_table_$noarg)
      235 				 fixed bin (35) external static;
      236 
      237 	dcl     (abs, addr, binary, char, convert, divide, index, length,
      238 	         ltrim, max, null, ptr, reverse, rtrim, size, string, substr)
      239 				 builtin;
      240 
      241 	dcl     cleanup		 condition;
      242 
      243 	compare_mst_severity_ = 4;
      244 	bits_ptr = null ();
      245 	boot_ptr = null ();
      246 	iocb_ptr = null ();
      247 	mst_ptr_hold = null ();
      248 	np = null ();
      249 	sci_ptr = null();
      250 	on cleanup call clean_up;
      251 
      252 	call ssu_$standalone_invocation (sci_ptr, "compare_mst", "1.0",
      253 	   cu_$arg_list_ptr(), exit_proc, code);
      254 	if code ^= 0 then call com_err_ ("compare_mst", code, "Creating standalone ssu_ subsystem.");
      255 
      256 	bootstrap_sw = "0"b;			/* set for first pass */
      257 	have_sysid = "0"b;
      258 	saving = "0"b;
      259 
      260 	call ssu_$arg_count (sci_ptr, arg_count);
      261 	
      262 	in_file_name, in_tape_name = "";
      263 	in_den = UNSET;
      264 	master_copy = UNSET;
      265 
      266 	do argx = 1 to arg_count;
      267 	   call ssu_$arg_ptr (sci_ptr, argx, argp, argl);
      268 	   if index (arg, "-") = 1 then do;
      269 	      if arg = "-save" then
      270 	         saving = "1"b;
      271 	      else if arg = "-master_volume" | arg = "-mvol" then do;
      272 	         master_copy = MASTER;
      273 SETTAPE:	         in_tape_name(master_copy), in_file_name(master_copy) = "";
      274 	         if argx = arg_count then
      275 		  call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
      276 		     "^a must be followed by a tape volume name.", arg);
      277 	         else do;
      278 		  argx = argx + 1;
      279 		  call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
      280 		  in_tape_name(master_copy) = opt;
      281 		  end;
      282 	         end;
      283 	      else if arg = "-master_file" | arg = "-mf" then do;
      284 	         master_copy = MASTER;
      285 SETFILE:	         in_tape_name(master_copy), in_file_name(master_copy) = "";
      286 	         if argx = arg_count then
      287 		  call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
      288 		     "^a must be followed by a file name.", arg);
      289 	         else do;
      290 		  argx = argx + 1;
      291 		  call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
      292 		  in_file_name(master_copy) = opt;
      293 		  end;
      294 	         master_copy = UNSET;
      295 	         end;
      296 	      else if (arg = "-copy_volume" | arg = "-cvol") then do;
      297 	         master_copy = COPY;
      298 	         go to SETTAPE;
      299 	         end;
      300 	      else if (arg = "-copy_file" | arg = "-cf") then do;
      301 	         master_copy = COPY;
      302 	         go to SETFILE;
      303 	         end;
      304 	      else if arg = "-density" | arg = "-den" then do;
      305 	         if argx = arg_count then
      306 		  call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
      307 		     "^a must be followed by a tape density.", arg);
      308 	         else do;
      309 		  argx = argx + 1;
      310 		  call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
      311 		  if opt = "800" | opt = "1600" | opt = "6250" then do;
      312 		     if master_copy = UNSET then
      313 		        call ssu_$abort_subsystem (sci_ptr,
      314 			 error_table_$inconsistent,
      315 			 "^a ^a must follow either -mvol or -cvol.", arg,
      316 			 opt);
      317 		     else
      318 		        in_den(master_copy) = convert(in_den(1), opt);
      319 		     end;
      320 		  else
      321 		     call ssu_$abort_subsystem (sci_ptr,
      322 		        error_table_$bad_arg,
      323 		        "^a ^a^/Allowed densities are: 800, 1600, 6250.",
      324 		        arg, opt);
      325 		  end;
      326 	         end;
      327 	      else
      328 	         call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, arg);
      329 	      end;
      330 	   else if in_tape_name(MASTER) = "" & in_file_name(MASTER) = "" then
      331 	      in_tape_name(MASTER) = arg;
      332 	   else if in_tape_name(COPY) = "" & in_file_name(COPY) = "" then
      333 	      in_tape_name(COPY) = arg;
      334 	   else
      335 	      call ssu_$abort_subsystem (sci_ptr, error_table_$bad_arg, arg);
      336 	   end;
      337 
      338 	do i = MASTER to COPY;
      339 	   if in_tape_name(i) = "" & in_file_name(i) = "" then
      340 	      call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
      341 	         "^/A ^[master^;copy^] tape or file must be specified via -^[m^;c^]vol or -^[m^;c^]f.",
      342 	         i, i, i);
      343 	   end;
      344 
      345           do i = MASTER to COPY;
      346 	   call ssu_$get_temp_segment (sci_ptr, "boot pgm", boot_ptr(i));
      347 	   call ssu_$get_temp_segment (sci_ptr, "buffer", mst_ptr_hold(i));
      348 	   call ssu_$get_temp_segment (sci_ptr, "tape names", np(i));
      349 	   call get_in_medium (i);
      350 	   end;
      351 	mst_ptr = mst_ptr_hold;
      352 	call ssu_$get_temp_segment (sci_ptr, "bit seg", bits_ptr);
      353 	compare_mst_severity_ = 0;
      354 
      355 	call ioa_ ("^/Begin comparison.");
      356 
      357 	if boot_label(MASTER) ^= boot_label(COPY) then do;
      358 	   call ioa_ (
      359 	      "^/^[Master^;Copy^] MST has a bootload label program, while ^[Master^;Copy^] MST does not.",
      360 	      boot_label(MASTER), boot_label(COPY));
      361 	   compare_mst_severity_ = max(compare_mst_severity_, 3);
      362 	   end;
      363 	else if boot_label(MASTER) then do;
      364 	   if bpi(MASTER).boot_program_name ^= bpi(COPY).boot_program_name then do;
      365 	      call ioa_ ("Boot program names disagree.
      366   Master:  ^a
      367   Copy:    ^a", bpi(MASTER).boot_program_name, bpi(COPY).boot_program_name);
      368 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      369 	      end;
      370 	   else if bpi(MASTER).boot_program_text_length ^=
      371 		 bpi(COPY).boot_program_text_length then do;
      372 	      call ioa_ ("Boot program lengths disagree.
      373   Master:  ^d
      374   Copy:    ^d",    bpi(MASTER).boot_program_text_length,
      375 	         bpi(COPY).boot_program_text_length);
      376 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      377 	      end;
      378 	   else do;
      379 	      seg_length(MASTER) = bpi(MASTER).boot_program_text_length;
      380 	      seg_length(COPY)   = bpi(COPY).boot_program_text_length;
      381 	      mst_ptr = bpi.boot_program_ptr;
      382 	      segment_name = "bootload label program";
      383 	      call check_segments();
      384 	      mst_ptr = mst_ptr_hold;
      385 	      end;
      386 	   end;
      387 
      388 
      389 	call read_tape (MASTER);
      390 
      391 /* rewind first tape */
      392 	call rewind_in_medium (MASTER);
      393 
      394 	call read_tape (COPY);
      395 
      396 	if have_sysid then call ioa_ ("System ^a to ^a", sys_id (MASTER), sys_id (COPY));
      397 
      398 /* rewind tape COPY */
      399 	call rewind_in_medium (COPY);
      400 
      401 	call sort_names (MASTER);
      402 	call sort_names (COPY);
      403 	call list_comp;				/* get add,del,and mov bits set up */
      404 
      405 	bootstrap_sw = "0"b;			/* reset for second pass */
      406 	l1_index, l2_index = 1;
      407 	skip_1 = "0"b;
      408 
      409 
      410 /* now do the dirty work */
      411 	do while ((l1_index ^> name_count (MASTER)) & (l2_index ^> name_count (COPY)));
      412 	   j = tp2_names (l2_index).pos_n;		/* use tape order to process names */
      413 	   if skip_1 then do;
      414 	      skip_1 = "0"b;
      415 	      goto try_2;
      416 	      end;
      417 	   i = tp1_names (l1_index).pos_n;
      418 
      419 
      420 	   call read_header (MASTER, collection);
      421 	   if collection then
      422 	      if ^tp1_names (i).sw.col then do;
      423 out_of_sync:       compare_mst_severity_ = max(compare_mst_severity_, 3);
      424 	         call ssu_$abort_subsystem (sci_ptr, 0,
      425 		  "tape out of sync.");
      426 	         end;
      427 	      else do;
      428 	         if tp1_names (i).sw.del then do;
      429 		  call ioa_ ("^a mark deleted.", tp1_names (i).name);
      430 		  compare_mst_severity_ = max(compare_mst_severity_, 3);
      431 		  end;
      432 	         l1_index = l1_index + 1;
      433 	         goto loop_cont;
      434 	         end;
      435 	   else if segment_name ^= tp1_names (i).name then goto out_of_sync;
      436 
      437 
      438 	   if tp1_names (i).sw.del then do;
      439 	      call ioa_ ("^a deleted", segment_name);
      440 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      441 	      call skip_block (MASTER);
      442 	      l1_index = l1_index + 1;
      443 	      goto loop_cont;
      444 	      end;
      445 
      446 						/* if moved, has first been read in already ? */
      447 	   if tp1_names (i).sw.mov then if tp1_names (i).move_index ^= 0 then do;
      448 						/* top segment already in  */
      449 	      set = tp1_names (i).move_index; /* pick up other list offset */
      450 	      mst_ptr (COPY) = tp2_names (set).head_ptr;
      451 	      call header_setup_2;
      452 	      call check_headers;
      453 	      call read_segment (MASTER);
      454 	      mst_ptr (COPY) = tp2_names (set).info_ptr;
      455 	      call check_segments;
      456 	      mst_ptr (COPY) = mst_ptr_hold (COPY);
      457 	      l1_index = l1_index + 1;
      458 	      goto loop_cont;
      459 	      end;
      460 	   else do;				/* save the header and body */
      461 	      call ioa_ ("^a moved down.", segment_name);
      462 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      463 	      call ssu_$get_temp_segment (sci_ptr,
      464 	         "header", tp1_names(i).head_ptr);
      465 	      bit_len = mst1.header_length + 2;
      466 	      tp1_names (i).head_ptr -> header_words = mst_ptr (MASTER) -> header_words;
      467 	      call ssu_$get_temp_segment (sci_ptr,
      468 	         "info", tp1_names(i).info_ptr);
      469 	      mst_ptr (MASTER) = tp1_names (i).info_ptr;
      470 	      call read_segment (MASTER);
      471 	      mst_ptr (MASTER) = mst_ptr_hold (MASTER);
      472 	      l1_index = l1_index + 1;
      473 	      goto loop_cont;
      474 	      end;
      475 
      476 try_2:
      477 	   call read_header (COPY, collection);
      478 	   if collection then
      479 	      if ^tp2_names (j).sw.col then goto out_of_sync;
      480 	      else do;
      481 	         if tp2_names (j).sw.add then do;
      482 		  call ioa_ ("^a mark added.", tp2_names (j).name);
      483 		  compare_mst_severity_ = max(compare_mst_severity_, 3);
      484 		  end;
      485 	         l2_index = l2_index + 1;
      486 	         skip_1 = "1"b;
      487 	         goto loop_cont;
      488 	         end;
      489 	   else if segment_name ^= tp2_names (j).name then goto out_of_sync;
      490 
      491 
      492 	   if tp2_names (j).sw.add then do;
      493 	      call ioa_ ("^a added.", segment_name);
      494 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      495 	      if saving then do;
      496 	         call initiate_file_$create (get_wdir_(),
      497 		  "tp2." || segment_name, RW_ACCESS,
      498 		  tp2_names (j).info_ptr, "0"b, 0, code);
      499 	         if tp2_names (j).info_ptr = null then goto make_x;
      500 	         mst_ptr (COPY) = tp2_names (j).info_ptr;
      501 	         call read_segment (COPY);
      502 	         mst_ptr (COPY) = mst_ptr_hold (COPY);
      503 	         call terminate_file_ (tp2_names(j).info_ptr,
      504 		  seg_length(COPY) * BITS_PER_WORD, TERM_FILE_TRUNC_BC_TERM, 
      505 		  code);
      506 	         end;
      507 	      else call skip_block (COPY);
      508 	      l2_index = l2_index + 1;
      509 	      skip_1 = "1"b;
      510 	      goto loop_cont;
      511 	      end;
      512 
      513 
      514 	   if tp2_names (j).sw.mov then
      515 	   if tp2_names (j).move_index ^= 0 then do;
      516 	      set = tp2_names (j).move_index;
      517 	      mst_ptr (MASTER) = tp1_names (set).head_ptr;
      518 	      call header_setup_1;
      519 	      call check_headers;
      520 	      call read_segment (COPY);
      521 	      mst_ptr (MASTER) = tp1_names (set).info_ptr;
      522 	      call check_segments;
      523 	      mst_ptr (MASTER) = mst_ptr_hold (MASTER);
      524 	      l2_index = l2_index + 1;
      525 	      skip_1 = "1"b;
      526 	      goto loop_cont;
      527 	      end;
      528 	   else do;
      529 	      call ioa_ ("^a moved up.", segment_name);
      530 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      531 	      call ssu_$get_temp_segment (sci_ptr, "hdr." || segment_name,
      532 	         tp2_names (j).head_ptr);
      533 	      bit_len = mst2.header_length + 2;
      534 	      tp2_names (j).head_ptr -> header_words = mst_ptr (COPY) -> header_words;
      535 	      call ssu_$get_temp_segment (sci_ptr, "tp2." || segment_name,
      536 	         tp2_names (j).info_ptr);
      537 	      mst_ptr (COPY) = tp2_names (j).info_ptr;
      538 	      call read_segment (COPY);
      539 	      mst_ptr (COPY) = mst_ptr_hold (COPY);
      540 	      l2_index = l2_index + 1;
      541 	      skip_1 = "1"b;
      542 	      goto loop_cont;
      543 	      end;
      544 						/* compare segments */
      545 	   call check_headers;
      546 	   call read_segment (MASTER);
      547 	   call read_segment (COPY);
      548 	   call check_segments;
      549 	   l1_index = l1_index + 1;
      550 	   l2_index = l2_index + 1;
      551 loop_cont:
      552 	   end;					/* do while */
      553 
      554 	if l1_index > name_count (MASTER) then if l2_index ^> name_count (COPY)
      555 	   then i = 2;
      556 	else goto detach_and_return;			/* process end of longer tape */
      557 	else i = 1;
      558 
      559 	if i = 1 then j = l1_index;
      560 	else j = l2_index;
      561 	do while (j ^> name_count (i));
      562 	   call read_header (i, collection);
      563 	   if collection then goto incr_j;
      564 	   k = np (i) -> tp1_names (j).pos_n;
      565 	   if segment_name ^= np (i) -> tp1_names (k).name then goto out_of_sync;
      566 	   if np (i) -> tp1_names (k).sw.add then do;
      567 	      call ioa_ ("^a added.", segment_name);
      568 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      569 	      if saving then do;
      570 	         call initiate_file_$create (get_wdir_ (),
      571 		  "tp2." || segment_name, RW_ACCESS, mst_ptr (i), ""b, 0,
      572 		  code);
      573 	         if mst_ptr (i) = null then goto make_x;
      574 	         call read_segment (i);
      575 	         call terminate_file_ (mst_ptr (i),
      576 		  seg_length(i) * BITS_PER_WORD, TERM_FILE_TRUNC_BC_TERM,
      577 		  code);
      578 	         mst_ptr (i) = mst_ptr_hold (i);
      579 	         end;
      580 	      else call skip_block (i);
      581 	      end;
      582 	   else do;				/* must be deleted */
      583 	      call skip_block (i);
      584 	      call ioa_ ("^a deleted.", segment_name);
      585 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      586 	      end;
      587 incr_j:	   j = j + 1;
      588 	   end;
      589 	call ioa_ ("End of comparison.^/");
      590 
      591 detach_and_return:
      592 	call clean_up;
      593 	return;					/* successful job finish */
      594 
      595 exit_proc:
      596 	procedure;
      597 	go to detach_and_return;
      598 	end exit_proc;
      599 
      600 make_x:   compare_mst_severity_ = max(compare_mst_severity_, 4);
      601 	call ssu_$abort_subsystem (sci_ptr, code,
      602 	   "Making -save segment in working directory.");
      603 	go to detach_and_return;
      604 
      605 clean_up: proc;
      606 	do i = MASTER to COPY;
      607 	   if iocb_ptr (i) = null ()
      608 	      then go to CLEAN;
      609 	   call iox_$close (iocb_ptr (i), code);
      610 	   call iox_$detach_iocb (iocb_ptr (i), code);
      611 CLEAN:	   end;
      612 	call ssu_$destroy_invocation (sci_ptr);
      613 	end;
      614 
      615 get_data:	proc (index, data_ptr, data_words);
      616 
      617     dcl	index			 fixed bin,
      618 	data_ptr			 ptr,
      619 	data_words		 fixed bin(18) uns unal;
      620 
      621 	call iox_$get_chars (iocb_ptr(index),
      622 	   data_ptr, data_words * CHARS_PER_WORD, (0), code);
      623 	if code = error_table_$end_of_info then go to detach_and_return;
      624 	else if code ^= 0 then do;
      625 	   call ssu_$abort_subsystem (sci_ptr, code,
      626 	      "Tape error on ^[master^;copy^] tape.", index);
      627 	   end;
      628 	end get_data;
      629 
      630 
      631 get_in_file:
      632 	proc (index);
      633 
      634     dcl	index			 fixed bin;
      635 
      636     dcl	1 control_word		 aligned,
      637 	  2 type			 fixed bin (17) unaligned,
      638 	  2 count			 fixed bin (18) uns unal;
      639 
      640 	call absolute_pathname_ (in_file_name(index),
      641 	   in_file_name(index), code);
      642 	if code ^= 0 then
      643 	   call ssu_$abort_subsystem (sci_ptr, code, "^[-if^;-of^] ^a.",
      644 	      index, in_file_name);
      645 
      646 	in_file_name(index) = get_shortest_path_ (in_file_name(index));
      647 
      648 	call iox_$attach_name (mst_name(index) || unique_chars_(""b),
      649 	   iocb_ptr(index), "vfile_ " || in_file_name(index) || " -old",
      650 	   null, code);
      651 	if code ^= 0 then
      652 	   call ssu_$abort_subsystem (sci_ptr, code,
      653 	      "Cannot attach input file ^a.", in_file_name(index));
      654 
      655 REWIND_FILE:
      656 	call iox_$open (iocb_ptr(index), Stream_input, ("0"b), code);
      657 	if code ^= 0 then 
      658 	   call ssu_$abort_subsystem (sci_ptr, code,
      659 	      "Cannot open input file ^a.", in_file_name(index));
      660 
      661 	call get_data (index, addr (control_word), size(control_word));
      662 	if control_word.type = -1 then do;		/* bootload program control word */
      663 						/* It is written as a name, followed by the pgm.	*/
      664 
      665 	   bpi(index).version = BOOT_PROGRAM_INFO_VERSION_1;
      666 						/* set version */
      667 	   boot_label(index) = "1"b;			/* set flag to copy onto output tape */
      668 	   name_len = divide (length (bpi(index).boot_program_name), CHARS_PER_WORD, 18, 0);
      669 	   seg_len = control_word.count - name_len;	/* set copy length */
      670 	   call get_data (index, addr (bpi(index).boot_program_name), name_len);
      671 	   call get_data (index, boot_ptr(index), seg_len);
      672 						/* copy boot program in to temp seg */
      673 	   bpi(index).boot_program_ptr = boot_ptr(index); /* set new boot program ptr */
      674 	   bpi(index).boot_program_text_length = seg_len;
      675 	   end;
      676 	else do;
      677 	   boot_label(index) = "0"b;
      678 	   call iox_$close (iocb_ptr(index), (0));
      679 	   call iox_$open (iocb_ptr(index), Stream_input, ""b, (0));
      680 	   end;
      681 	return;
      682 
      683 rewind_in_file:
      684 	entry (index);
      685 
      686 	call iox_$close (iocb_ptr(index), code);
      687 	if code ^= 0 then do;
      688 	   compare_mst_severity_ = max(compare_mst_severity_, 4);
      689 	   call ssu_$abort_subsystem (sci_ptr, code,
      690 	      "error in reopening. Aborting.");
      691 	   end;
      692 	go to REWIND_FILE;
      693 
      694      end get_in_file;
      695 
      696 
      697 get_in_medium:
      698   	proc (index);
      699 
      700     dcl	index			 fixed bin;
      701 
      702 	if in_file_name(index) ^= "" then
      703 	   call get_in_file (index);
      704 	else if in_tape_name(index) ^= "" then
      705 	   call get_in_tape (index);
      706 	return;
      707 
      708 rewind_in_medium:
      709 	entry (index);
      710 
      711 	if in_file_name(index) ^= "" then
      712 	   call rewind_in_file (index);
      713 	else
      714 	   call rewind_in_tape (index);
      715 
      716 	end get_in_medium;
      717 
      718 get_in_tape:
      719 	proc (index);
      720 	
      721     dcl	index			 fixed bin;
      722 
      723     dcl	copy			 (seg_len) fixed bin(35) based;
      724 
      725 	call parse_tape_reel_name_ (in_tape_name(index), atd);
      726 	if in_den(index) ^= UNSET
      727 	   then atd = rtrim (atd) || " -density " || ltrim (char (in_den(index)));
      728 
      729 	call iox_$attach_name (mst_name(index) || unique_chars_ (""b),
      730 	   iocb_ptr(index), "tape_mult_ " || rtrim (atd), null, code);
      731 	if code ^= 0 then
      732 	   call ssu_$abort_subsystem (sci_ptr, code,
      733 	      "Cannot attach input tape ^a.", in_tape_name(index));
      734 
      735 REWIND_TAPE:
      736 	call iox_$open (iocb_ptr(index), Stream_input, ("0"b), code);
      737 	if code ^= 0 then 
      738 	   call ssu_$abort_subsystem (sci_ptr, code,
      739 	      "Cannot open input tape ^a.", in_tape_name(index));
      740 
      741 	bpi(index).version = BOOT_PROGRAM_INFO_VERSION_1;	/* set version */
      742 	call iox_$control (iocb_ptr(index), "get_boot_program",
      743 	   addr (bpi(index)), code);
      744 	if code ^= 0 then
      745 	   call ssu_$abort_subsystem (sci_ptr, code,
      746 	      "Getting bootload program info from input tape ^a.",
      747 	      in_tape_name(index));
      748 
      749 	if bpi(index).boot_program_ptr ^= null then do;	/* if this tape has a boot label... */
      750 	   boot_label(index) = "1"b;			/* set flag to copy onto output tape */
      751 	   seg_len = bpi(index).boot_program_text_length;
      752 						/* set copy length */
      753 	   boot_ptr(index) -> copy = bpi(index).boot_program_ptr -> copy;
      754 						/* copy boot program in to temp seg */
      755 	   bpi(index).boot_program_ptr = boot_ptr(index);
      756 						/* set new boot program ptr */
      757 	   end;
      758 	else
      759 	   boot_label(index) = "0"b;
      760 	return;
      761 	
      762 rewind_in_tape:
      763 	entry (index);
      764 	
      765 	call iox_$close (iocb_ptr (index), code);
      766 	if code ^= 0 then do;
      767 	   compare_mst_severity_ = max(compare_mst_severity_, 4);
      768 	   call ssu_$abort_subsystem (sci_ptr, code,
      769 	      "error in rewind, aborting");
      770 	   end;
      771 	go to REWIND_TAPE;
      772 
      773 	end get_in_tape;
      774 
      775 read_header: proc (index, found_mark);
      776 
      777 	dcl     found_mark		 bit (1) aligned;
      778 	dcl     index		 fixed bin;
      779 
      780 /* Get two words.  The first word will tell you how many more words to read to complete
      781*   the header (i.e., it is the header length minus 2.)  If the collection mark is on, however, it
      782*   is complete in itself.  In that case, you
      783*   must reach in and get a whole fresh header. */
      784 
      785 
      786 	call iox_$get_chars (iocb_ptr (index), mst_ptr (index), 8, nelemt, code); /* read 2 words */
      787 	if code = 0 then do;
      788 	   if mst_ptr (index) -> mst1.collection_mark then do;
      789 	      found_mark = "1"b;			/* don't read rest of header; there is none */
      790 	      return;
      791 	      end;
      792 	   else call iox_$get_chars (iocb_ptr (index), ptr (mst_ptr (index), 2),
      793 	      mst_ptr (index) -> mst1.header_length * 4, nelemt, code);
      794 						/* read rest of header */
      795 	   if code ^= 0 then call check_status;
      796 	   found_mark = "0"b;
      797 
      798 	   if index = 1 then call header_setup_1;
      799 	   else call header_setup_2;
      800 	   end;
      801 	else if code ^= error_table_$end_of_info then call check_status;
      802 
      803 	end;
      804 
      805 header_setup_1: proc;
      806 
      807 	n_names (MASTER) = mst_ptr (MASTER) -> mst1.n_names;
      808 						/* pull out number of names */
      809 	if n_names (MASTER) = -1 then do;		/* special bootstrap processing */
      810 	   if bootstrap_sw (MASTER) then do;
      811 	      call ioa_ ("second bound_bootload_0 found on master tape. Aborting.");
      812 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      813 	      goto detach_and_return;
      814 	      end;
      815 	   bootstrap_sw (MASTER) = "1"b;
      816 	   n_names (MASTER) = 0;
      817 	   has_acl (MASTER) = 0;
      818 	   n_acls (MASTER) = 0;
      819 	   has_branch (MASTER) = 0;
      820 	   path_length (MASTER) = 0;
      821 	   segment_name = "bound_bootload_0";
      822 	   seg_length (MASTER) = mst_ptr (MASTER) -> bootstrap_header.segment_length;
      823 	   end;
      824 	else do;
      825 	   has_acl (MASTER) = binary (mst_ptr (MASTER) -> mst1.slte.acl_provided); /* is there an acl? */
      826 	   has_branch (MASTER) = binary (mst_ptr (MASTER) -> mst1.slte.branch_required); /* is there a pathname? */
      827 	   if has_branch (MASTER) = 1 then path_length (MASTER) = mst_ptr (MASTER) -> mst1.pathname_length (1); /* get length */
      828 	   else path_length (MASTER) = 0;
      829 	   if has_acl (MASTER) = 1 then n_acls (MASTER) = mst_ptr (MASTER) -> mst1.n_acls (1);
      830 	   else n_acls (MASTER) = 0;
      831 	   segment_name = mst_ptr (MASTER) -> mst1.name (MASTER);
      832 	   seg_length (MASTER) = mst_ptr (MASTER) -> mst1.segment_length;
      833 	   end;
      834 	end;
      835 
      836 header_setup_2: proc;				/* must use references based on mst2 varibs */
      837 
      838 	n_names (COPY) = mst_ptr (COPY) -> mst2.n_names;
      839 	if n_names (COPY) = -1 then do;
      840 	   if bootstrap_sw (COPY) then do;
      841 	      call ioa_ ("second bound_bootload_0 found on copy tape. Aborting.");
      842 	      compare_mst_severity_ = max(compare_mst_severity_, 3);
      843 	      goto detach_and_return;
      844 	      end;
      845 	   bootstrap_sw(COPY) = "1"b;
      846 	   n_names (COPY) = 0;
      847 	   has_acl (COPY) = 0;
      848 	   n_acls (COPY) = 0;
      849 	   has_branch (COPY) = 0;
      850 	   path_length (COPY) = 0;
      851 	   segment_name = "bound_bootload_0";
      852 	   seg_length (COPY) = mst_ptr (COPY) -> bootstrap_header.segment_length;
      853 	   end;
      854 	else do;
      855 	   has_acl (COPY) = binary (mst_ptr (COPY) -> mst2.slte.acl_provided);
      856 	   has_branch (COPY) = binary (mst_ptr (COPY) -> mst2.slte.branch_required);
      857 	   if has_branch (COPY) = 1 then path_length (COPY) = mst_ptr (COPY) -> mst2.pathname_length (1);
      858 	   else path_length (COPY) = 0;
      859 	   if has_acl (COPY) = 1 then n_acls (COPY) = mst_ptr (COPY) -> mst2.n_acls (1);
      860 	   else n_acls (COPY) = 0;
      861 	   segment_name = mst_ptr (COPY) -> mst2.name (1);
      862 	   seg_length (COPY) = mst_ptr (COPY) -> mst2.segment_length;
      863 	   end;
      864 	end;
      865 
      866 check_headers: proc;
      867 
      868 
      869 	if mst1.header_length ^= mst2.header_length then goto header_discrepancy;
      870 
      871 	bit_len = mst1.header_length + 2;		/* comparison of headers here */
      872 	bits = mst_ptr (MASTER) -> header_words = mst_ptr (COPY) -> header_words;
      873 	if (^string (bits)) ^= ""b then
      874 	if ((n_acls (MASTER) = 0) | (n_acls (COPY) = 0)) then goto header_discrepancy;
      875 	else do;					/* zero pad in acl structure */
      876 	   do k = 1 to n_acls (MASTER);
      877 	      mst1.acl (1, k).pad (1), mst1.acl (1, k).pad (2) = 0;
      878 	      end;
      879 	   do k = 1 to n_acls (COPY);
      880 	      mst2.acl (1, k).pad (1), mst2.acl (1, k).pad (2) = 0;
      881 	      end;
      882 	   bits = mst_ptr (MASTER) -> header_words = mst_ptr (COPY) -> header_words;
      883 	   if (^string (bits)) ^= ""b then goto header_discrepancy;
      884 	   end;
      885 	return;
      886 
      887 header_discrepancy:
      888 	call ioa_ ("^/Segment ^a:", segment_name);
      889 	compare_mst_severity_ = max(compare_mst_severity_, 3);
      890 
      891 /* Now find out exactly why. */
      892 	if mst_ptr (MASTER) -> mst1.access ^= mst_ptr (COPY) -> mst2.access then
      893 	   call ioa_ ("^-SDW access has changed from ^a to ^a",
      894 	      substr (REWP, binary (mst_ptr (MASTER) -> mst1.access) * 4 + 1, 4),
      895 	      substr (REWP, binary (mst_ptr (COPY) -> mst2.access) * 4 + 1, 4));
      896 	if mst_ptr (MASTER) -> mst1.cache ^= mst_ptr (COPY) -> mst2.cache then
      897 	   call ioa_ ("^-Cache bit has changed from ^a to ^a",
      898 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.cache) * 4 + 1, 3),
      899 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.cache) * 4 + 1, 3));
      900 	if mst_ptr (MASTER) -> mst1.wired ^= mst_ptr (COPY) -> mst2.wired then
      901 	   call ioa_ ("^-Wired bit has changed from ^a to ^a.",
      902 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.wired) * 4 + 1, 3),
      903 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.wired) * 4 + 1, 3));
      904 	if mst_ptr (MASTER) -> mst1.paged ^= mst_ptr (COPY) -> mst2.paged then
      905 	   call ioa_ ("^-Paged bit has changed from ^a to ^a.",
      906 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.paged) * 4 + 1, 3),
      907 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.paged) * 4 + 1, 3));
      908 	if mst_ptr (MASTER) -> mst1.per_process ^= mst_ptr (COPY) -> mst2.per_process then
      909 	   call ioa_ ("^-Per-process bit has changed from ^a to ^a.",
      910 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.per_process) * 4 + 1, 3),
      911 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.per_process) * 4 + 1, 3));
      912 
      913 	if mst_ptr (MASTER) -> mst1.acl_provided ^= mst_ptr (COPY) -> mst2.acl_provided then
      914 	   call ioa_ ("^-ACL-provided switch has changed from ^a to ^a.",
      915 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.acl_provided) * 4 + 1, 3),
      916 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.acl_provided) * 4 + 1, 3));
      917 	else if has_acl (MASTER) = 1 then
      918 	     if n_acls (MASTER) ^= n_acls (COPY) then goto print_acls;
      919 	else do;
      920 	   bit_len = 11 * n_acls (MASTER) + 1;
      921 	   anp (MASTER) = addr (mst1.acl_structure (1));
      922 	   anp (COPY) = addr (mst2.acl_structure (1));
      923 	   bits = anp (MASTER) -> header_words = anp (COPY) -> header_words;
      924 	   if (^string (bits)) ^= ""b then do;
      925 print_acls:     call ioa_ ("^-Number of ACLs was ^d, now is ^d.",
      926 	         n_acls (MASTER), n_acls (COPY));
      927 	      if abs (n_acls (MASTER) - n_acls (COPY)) > abs_changes then do;
      928 too_much:	         compare_mst_severity_ = max(compare_mst_severity_, 4);
      929 	         call ssu_$abort_subsystem (sci_ptr, 0,
      930 		  "Probable bad tape, aborting.");
      931 	         goto detach_and_return;
      932 	         end;
      933 	      call ioa_ ("^5xACL was:");
      934 	      do k = 1 to n_acls (MASTER);
      935 	         call ioa_ ("^-^3a  ^a",
      936 		  substr (rew, binary (mst_ptr (MASTER) -> mst1.acl (1, k).mode) * 3 + 1, 3),
      937 		  mst_ptr (MASTER) -> mst1.acl (1, k).accessname);
      938 	         end;
      939 	      call ioa_ ("^5xACL is:");
      940 	      do k = 1 to n_acls (COPY);
      941 	         call ioa_ ("^-^3a  ^a",
      942 		  substr (rew, binary (mst_ptr (COPY) -> mst2.acl (1, k).mode) * 3 + 1, 3),
      943 		  mst_ptr (COPY) -> mst2.acl (1, k).accessname);
      944 	         end;
      945 	      end;
      946 	   end;
      947 	if mst_ptr (MASTER) -> mst1.branch_required ^= mst_ptr (COPY) -> mst2.branch_required then
      948 	   call ioa_ ("^-Hierarchy-branch required indicator has changed from ^a to ^a.",
      949 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.branch_required) * 4 + 1, 3),
      950 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.branch_required) * 4 + 1, 3));
      951 	else if has_branch (MASTER) = 1 then
      952 	     if mst_ptr (MASTER) -> mst1.pathname (1) ^= mst_ptr (COPY) -> mst2.pathname (1) then
      953 	   call ioa_ ("^-Pathname has changed from ^a to ^a.",
      954 	      mst_ptr (MASTER) -> mst1.pathname (1), mst_ptr (COPY) -> mst2.pathname (1));
      955 	if mst_ptr (MASTER) -> mst1.init_seg ^= mst_ptr (COPY) -> mst2.init_seg then
      956 	   call ioa_ ("^-Initialization-seg indicator has changed from ^a to ^a.",
      957 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.init_seg) * 4 + 1, 3),
      958 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.init_seg) * 4 + 1, 3));
      959 	if mst_ptr (MASTER) -> mst1.temp_seg ^= mst_ptr (COPY) -> mst2.temp_seg then
      960 	   call ioa_ ("^-Temp-seg indicator has changed from ^a to ^a.",
      961 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.temp_seg) * 4 + 1, 3),
      962 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.temp_seg) * 4 + 1, 3));
      963 
      964 	if mst_ptr (MASTER) -> mst1.link_provided ^= mst_ptr (COPY) -> mst2.link_provided then
      965 	   call ioa_ ("^-Linkage-provided indicator has changed from ^a to ^a.",
      966 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.link_provided) * 4 + 1, 3),
      967 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.link_provided) * 4 + 1, 3));
      968 	if mst_ptr (MASTER) -> mst1.link_sect ^= mst_ptr (COPY) -> mst2.link_sect then
      969 	   call ioa_ ("^-Linkage-segment indicator has changed from ^a to ^a.",
      970 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.link_sect) * 4 + 1, 3),
      971 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.link_sect) * 4 + 1, 3));
      972 	if mst_ptr (MASTER) -> mst1.link_sect_wired ^= mst_ptr (COPY) -> mst2.link_sect_wired then
      973 	   call ioa_ ("^-Linkage-wired indicator has changed from ^a to ^a.",
      974 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.link_sect_wired) * 4 + 1, 3),
      975 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.link_sect_wired) * 4 + 1, 3));
      976 	if mst_ptr (MASTER) -> mst1.combine_link ^= mst_ptr (COPY) -> mst2.combine_link then
      977 	   call ioa_ ("^-Combine-linkage switch has changed from ^a to ^a.",
      978 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.combine_link) * 4 + 1, 3),
      979 	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.combine_link) * 4 + 1, 3));
      980 	if mst_ptr (MASTER) -> mst1.pre_linked ^= mst_ptr (COPY) -> mst2.pre_linked then
      981 	   call ioa_ ("^-Pre-linked indicator has changed from ^a to ^a.",
      982 	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.pre_linked) * 4 + 1, 3),
      983    	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.pre_linked) * 4 + 1, 3));
      984 	if mst_ptr (MASTER) -> mst1.cur_length ^= mst_ptr (COPY) -> mst2.cur_length then
      985 	   call ioa_ ("^-Cur-length has changed from ^o to ^o.",
      986 	      binary (mst_ptr (MASTER) -> mst1.cur_length, 35),
      987 	      binary (mst_ptr (COPY) -> mst2.cur_length, 35));
      988 	if mst_ptr (MASTER) -> mst1.ringbrack (1) ^= mst_ptr (COPY) -> mst2.ringbrack (1) |
      989 	   mst_ptr (MASTER) -> mst1.ringbrack (2) ^= mst_ptr (COPY) -> mst2.ringbrack (2) |
      990 	   mst_ptr (MASTER) -> mst1.ringbrack (3) ^= mst_ptr (COPY) -> mst2.ringbrack (3) then
      991 	   call ioa_ ("^-Ring brackets have changed from ^d,^d,^d to ^d,^d,^d.",
      992 	      binary (mst_ptr (MASTER) -> mst1.ringbrack (1), 35),
      993 	      binary (mst_ptr (MASTER) -> mst1.ringbrack (2), 35),
      994 	      binary (mst_ptr (MASTER) -> mst1.ringbrack (3), 35),
      995 	      binary (mst_ptr (COPY) -> mst2.ringbrack (1), 35),
      996 	      binary (mst_ptr (COPY) -> mst2.ringbrack (2), 35),
      997 	      binary (mst_ptr (COPY) -> mst2.ringbrack (3), 35));
      998 	if mst_ptr (MASTER) -> mst1.segno ^= mst_ptr (COPY) -> mst2.segno then
      999 	   call ioa_ ("^-Segment number has changed from ^o to ^o.",
     1000 	      binary (mst_ptr (MASTER) -> mst1.segno, 35),
     1001 	      binary (mst_ptr (COPY) -> mst2.segno, 35));
     1002 	if mst_ptr (MASTER) -> mst1.max_length ^= mst_ptr (COPY) -> mst2.max_length then
     1003 	   call ioa_ ("^-Max length has changed from ^o to ^o.",
     1004 	      binary (mst_ptr (MASTER) -> mst1.max_length, 35),
     1005 	      binary (mst_ptr (COPY) -> mst2.max_length, 35));
     1006 	if mst_ptr (MASTER) -> mst1.bit_count ^= mst_ptr (COPY) -> mst2.bit_count then
     1007 	   call ioa_ ("^-Bit count has changed from ^d to ^d.",
     1008 	      binary (mst_ptr (MASTER) -> mst1.bit_count, 35),
     1009 	      binary (mst_ptr (COPY) -> mst2.bit_count, 35));
     1010 
     1011 	if n_names (MASTER) = 0 then return;		/* bound_bootload_0 */
     1012 	if n_names (MASTER) ^= n_names (COPY) then goto print_names;
     1013 	else do;
     1014 	   bit_len = 9 * n_names (MASTER) + 1;
     1015 	   anp (MASTER) = addr (mst1.names_array);
     1016 	   anp (COPY) = addr (mst2.names_array);
     1017 	   bits = anp (MASTER) -> header_words = anp (COPY) -> header_words;
     1018 	   if (^string (bits)) ^= ""b then do;
     1019 print_names:    call ioa_ ("^-Number of names was ^d, now is ^d.",
     1020 	         n_names (MASTER), n_names (COPY));
     1021 	      if abs (n_names (MASTER) - n_names (COPY)) > abs_changes then goto too_much;
     1022 	      call ioa_ ("^5xNames were:");
     1023 	      do k = 1 to n_names (MASTER);
     1024 	         call ioa_ ("^-^a", mst_ptr (MASTER) -> mst1.name (k));
     1025 	         end;
     1026 	      call ioa_ ("^5xNames are:");
     1027 	      do k = 1 to n_names (COPY);
     1028 	         call ioa_ ("^-^a", mst_ptr (COPY) -> mst2.name (k));
     1029 	         end;
     1030 	      end;
     1031 	   end;
     1032 	if mst_ptr (MASTER) -> mst1.segment_length ^= mst_ptr (COPY) -> mst2.segment_length then
     1033 	   call ioa_ ("^-Segment length has changed from ^o to ^o.",
     1034 	      mst_ptr (MASTER) -> mst1.segment_length, mst_ptr (COPY) -> mst2.segment_length);
     1035 
     1036 	end;
     1037 
     1038 skip_block: proc (index);
     1039 	dcl     index		 fixed bin;
     1040 						/* positioning not supported, so just read */
     1041 	call iox_$get_chars (iocb_ptr (index), mst_ptr (index), seg_length (index) * 4, nelemt, code);
     1042 	if code ^= 0 then call check_status;
     1043 	end;
     1044 
     1045 read_segment: proc (index);
     1046 	dcl     index		 fixed bin;
     1047 
     1048 	call iox_$get_chars (iocb_ptr (index), mst_ptr (index), seg_length (index) * 4, nelemt, code);
     1049 	if code ^= 0 then call check_status;
     1050 
     1051 	end;
     1052 
     1053 check_status: proc;
     1054 	compare_mst_severity_ = max(compare_mst_severity_, 4);
     1055           call ssu_$abort_subsystem (sci_ptr, code, 
     1056 	   "Error in manipulating tapes.");
     1057 	end;
     1058 
     1059 read_tape: proc (index);
     1060 
     1061 	dcl     index		 fixed bin parameter;
     1062 
     1063 	dcl     i			 fixed bin;
     1064 	dcl     last_collection_mark	 fixed bin;
     1065 	dcl     name_index		 fixed bin;
     1066 	dcl     1 tp_names		 (name_count (index)) based (np (index)) aligned like tp_name;
     1067 
     1068 	last_collection_mark = 0;
     1069 	name_index, name_count (index) = 0;
     1070 	do while (code ^= error_table_$end_of_info);	/* get the whole tape */
     1071 	   call read_header (index, collection);
     1072 	   if code = 0 then do;
     1073 	      name_index, name_count (index) = name_count (index) + 1;
     1074 	      tp_names (name_index).org_index = name_index;
     1075 	      tp_names (name_index).pos_n = name_index;	/* init */
     1076 	      tp_names (name_index).head_ptr = null;
     1077 	      tp_names (name_index).info_ptr = null;
     1078 	      if index = 1 then tp_names (name_index).sw.del = "1"b;
     1079 						/* assume not on other tape */
     1080 	      else tp_names (name_index).sw.add = "1"b; /* assume everything new */
     1081 	      if collection then do;
     1082 	         do i = last_collection_mark + 1 to name_index;
     1083 						/* record collection contained within */
     1084 		  tp_names (i).major_collection = mst_ptr (index) -> collection_mark_data.major;
     1085 		  tp_names (i).minor_collection = mst_ptr (index) -> collection_mark_data.minor;
     1086 		  end;
     1087 	         last_collection_mark = name_index;
     1088 	         
     1089 	         tp_names (name_index).name = "collection." ||
     1090 		  ltrim (char (mst_ptr (index) -> collection_mark_data.major)) ||
     1091 		  "." || ltrim (char (mst_ptr (index) -> collection_mark_data.minor));
     1092 	         tp_names (name_index).sw.col = "1"b;
     1093 	         end;
     1094 	      else do;
     1095 	         tp_names (name_index).name = segment_name;
     1096 	         call skip_block (index);
     1097 	         if segment_name = "active_all_rings_data" then do;
     1098 		  have_sysid = "1"b;
     1099 		  sys_id (index) = mst_ptr (index) -> sys_id_pickup;
     1100 		  end;
     1101 	         end;
     1102 	      end;
     1103 	   end;
     1104 
     1105 	if substr (tp_names (name_index).name, 1, 10) ^= "collection" then do;
     1106 	   call ioa_ ("tape ^d does not end in a collection mark.", index);
     1107 	   compare_mst_severity_ = max(compare_mst_severity_, 3);
     1108 	   end;
     1109 	return;
     1110 	end;
     1111 
     1112 check_segments: proc;
     1113 
     1114 	if seg_length (MASTER) ^= seg_length (COPY) then goto check_saving;
     1115 	bit_len = seg_length (MASTER);			/* ready for bit comparison */
     1116 
     1117 	bits = mst_ptr (MASTER) -> segment_1 = mst_ptr (COPY) -> segment_1; /* set up equal bits */
     1118 
     1119 	if (^string (bits)) ^= ""b then goto segment_contents_discrepancy; /* something has been changed. */
     1120 
     1121 	return;
     1122 
     1123 
     1124 segment_contents_discrepancy:
     1125 	k = index (string (bits), "0"b) - 1;		/* j tells which word first noticed as changed */
     1126 	call ioa_ ("^/Segment ^a contains differences from word ^o.", segment_name, k);
     1127 	compare_mst_severity_ = max(compare_mst_severity_, 3);
     1128 	k = bit_len - index (reverse (string (bits)), "0"b);
     1129 	call ioa_ ("^-last difference found at word ^o.", k);
     1130 check_saving:
     1131 	if saving then do;
     1132 	   call initiate_file_$create (get_wdir_ (),
     1133 	      "tp1." || segment_name, RW_ACCESS, copy_ptr, ""b, 0, code);
     1134 	   if copy_ptr = null then return;
     1135 	   copy_ptr -> segment_1 = mst_ptr (MASTER) -> segment_1;
     1136 	   call terminate_file_ (copy_ptr, size(segment_1) * BITS_PER_WORD,
     1137 	      TERM_FILE_TRUNC_BC_TERM, code);
     1138 
     1139 	   call initiate_file_$create (get_wdir_ (),
     1140 	      "tp2." || segment_name, RW_ACCESS, copy_ptr, ""b, 0, code);
     1141 	   if copy_ptr = null then return;
     1142 	   copy_ptr -> segment_2 = mst_ptr (COPY) -> segment_2;
     1143 	   call terminate_file_ (copy_ptr, size(segment_2) * BITS_PER_WORD,
     1144 	      TERM_FILE_TRUNC_BC_TERM, code);
     1145 	   end;
     1146 	return;
     1147 	end;
     1148 
     1149 sort_names: proc (index);
     1150 						/* shell sort, keeping track of original position */
     1151 	dcl     index		 fixed bin;
     1152 
     1153 	dcl     1 hold_info		 aligned like tp_name.order_info;
     1154 	dcl     sd		 fixed bin;
     1155 	dcl     si		 fixed bin;
     1156 	dcl     sj		 fixed bin;
     1157 	dcl     sk		 fixed bin;
     1158 	dcl     1 tp_names		 (name_count (index)) aligned based (np (index)) like tp_name;
     1159 
     1160 	sd = name_count (index);
     1161 
     1162 down:	sd = 1 + 2 * divide (sd, 4, 17, 0);
     1163 	do si = 1 to name_count (index) - sd;
     1164 	   sj = si + sd;
     1165 up:	   sk = sj - sd;
     1166 	   if tp_names (sk).name <= tp_names (sj).name then goto ok;
     1167 	   
     1168 	   hold_info = tp_names (sk).order_info;
     1169 
     1170 	   tp_names (sk).order_info = tp_names (sj).order_info;
     1171 	   tp_names (tp_names (sk).org_index).pos_n = sk;
     1172 
     1173 	   tp_names (sj).order_info = hold_info;
     1174 	   tp_names (tp_names (sj).org_index).pos_n = sj;
     1175 	   
     1176 	   if sk > sd then do;
     1177 	      sj = sk;
     1178 	      goto up;
     1179 	      end;
     1180 ok:	   end;
     1181 	if sd > 1 then goto down;
     1182 
     1183 	end;
     1184 
     1185 name_search: proc (tp_name_ptr, index, ret_ans);
     1186 
     1187 /* See if name exists on list(index).  Do binary search, preferring the object
     1188*in the same collection as before. */
     1189 
     1190 	dcl     index		 fixed bin;
     1191 	dcl     ret_ans		 fixed bin;
     1192 	dcl     tp_name_ptr		 ptr;
     1193 
     1194 	dcl     low_index		 fixed bin;
     1195 	dcl     high_index		 fixed bin;
     1196 	dcl     1 tp_names		 (name_count (index)) aligned based (np (index)) like tp_name;
     1197 
     1198 	ret_ans = 0;
     1199 	low_index = 1;
     1200 	high_index = name_count (index);
     1201 	do while (high_index > low_index);
     1202 	   k = divide (low_index + high_index, 2, 17);
     1203 	   if tp_names (k).name = tp_name_ptr -> tp_name.name then go to match;
     1204 	   else if tp_names (k).name < tp_name_ptr -> tp_name.name then low_index = k + 1; /* name in high half of subdivision */
     1205 	   else high_index = k - 1;			/* low half */
     1206 	   end;
     1207 	if high_index < 1 then return;
     1208 	if low_index > name_count (index) then return;
     1209 	if tp_names (high_index).name = tp_name_ptr -> tp_name.name then do;
     1210 	   k = high_index;
     1211 match:
     1212 
     1213 /* Name the same; look for the one in the same collection. */
     1214 
     1215 	   do ret_ans = k to name_count (index) while (tp_name_ptr -> tp_name.name = tp_names (ret_ans).name), 
     1216 		      k - 1 to 1 by -1 while (tp_name_ptr -> tp_name.name = tp_names (ret_ans).name);
     1217 	      if tp_name_ptr -> tp_name.major_collection = tp_names (ret_ans).major_collection &
     1218 	         tp_name_ptr -> tp_name.minor_collection = tp_names (ret_ans).minor_collection then return;
     1219 	      end;
     1220 	   ret_ans = ret_ans + 1;			/* pick first one found */
     1221 	   end;
     1222 	return;
     1223 	end;
     1224 
     1225 list_comp: proc;					/* find out what's added, deleted, or moved */
     1226 						/* process in original order to get add/del counts rigHt */
     1227 	dcl     add_count		 fixed bin;
     1228 	dcl     del_count		 fixed bin;
     1229 	dcl     offset_1		 fixed bin;
     1230 	dcl     offset_2		 fixed bin;
     1231 
     1232 	do i = 1 to name_count (MASTER);
     1233 	   call name_search (addr (tp1_names (tp1_names (i).pos_n)), 2, offset_1);
     1234 	   if offset_1 = 0 then go to d_lp_c;		/* remains marked as deleted */
     1235 	   else do;
     1236 	      tp1_names (tp1_names (i).pos_n).sw.del = "0"b;
     1237 	      tp2_names (offset_1).sw.add = "0"b;
     1238 	      end;
     1239 d_lp_c:	   end;
     1240 						/* check for movement by matching list position */
     1241 	i, j = 1;
     1242 	add_count, del_count = 0;
     1243 						/* need process only shortest list */
     1244 	do while ((i <= name_count (MASTER)) & (j <= name_count (COPY)));
     1245 	   if tp1_names (tp1_names (i).pos_n).sw.del |
     1246 	      tp1_names (tp1_names (i).pos_n).move_index ^= 0 then do;
     1247 	      i = i + 1;
     1248 	      go to l_cont;
     1249 	      end;
     1250 	   if tp2_names (tp2_names (j).pos_n).sw.add |
     1251 	      tp2_names (tp2_names (j).pos_n).move_index ^= 0 then do;
     1252 	      j = j + 1;
     1253 	      go to l_cont;
     1254 	      end;
     1255 						/* if names equal then ok */
     1256 	   if tp1_names (tp1_names (i).pos_n).name = tp2_names (tp2_names (j).pos_n).name then do;
     1257 	      i = i + 1;
     1258 	      j = j + 1;
     1259 	      goto l_cont;
     1260 	      end;
     1261 						/* see which side moved */
     1262 	   call name_search (addr (tp1_names (tp1_names (i).pos_n)), COPY, offset_2);
     1263 	   call name_search (addr (tp2_names (tp2_names (j).pos_n)), MASTER, offset_1);
     1264 						/* find out which is farther, ignore adds,deletes */
     1265 	   del_count = tp1_names (offset_1).org_index - tp1_names (tp1_names (i).pos_n).org_index;
     1266 	   add_count = tp2_names (offset_2).org_index - tp2_names (tp2_names (j).pos_n).org_index;
     1267 						/* mark one as moved */
     1268 	   if del_count > add_count then do;		/* first tape's match is lower */
     1269 	      tp2_names (tp2_names (j).pos_n).sw.mov = "1"b;
     1270 	      tp1_names (offset_1).sw.mov = "1"b;
     1271 	      tp1_names (offset_1).move_index = tp2_names (j).pos_n;
     1272 	      j = j + 1;
     1273 	      goto l_cont;
     1274 	      end;
     1275 	   else do;
     1276 	      tp1_names (tp1_names (i).pos_n).sw.mov = "1"b;
     1277 	      tp2_names (offset_2).sw.mov = "1"b;
     1278 	      tp2_names (offset_2).move_index = tp1_names (i).pos_n;
     1279 	      i = i + 1;
     1280 	      goto l_cont;
     1281 	      end;
     1282 l_cont:	   end;					/* do while */
     1283 	end;					/* proc */
     1284  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1284 
     1285  /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
     1285 
     1286  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  3     2 /* Declaration for Segment Loading Table Entry structure.
  3     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  3     4 /* modified 5/4/76 by Noel I. Morris	*/
  3     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  3     6 /* format: style3 */
  3     7 
  3     8 dcl	sltep		ptr;
  3     9 
  3    10 dcl	1 slte_uns	based (sltep) aligned,
  3    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  3    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  3    13 /**** End of word 1 */
  3    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  3    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  3    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  3    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  3    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  3    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  3    20 	  2 pad1		bit (3),			/* unused */
  3    21 	  2 wired		bit (1),			/* segment is wired if ON */
  3    22 	  2 paged		bit (1),			/* segment is paged if ON */
  3    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  3    24 	  2 pad3		bit (2),
  3    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  3    26 /**** End of 1st half of word 2 */
  3    27 	  2 pad4		bit (3),
  3    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  3    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  3    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  3    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  3    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  3    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  3    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  3    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  3    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  3    37 /***** End of word 2 */
  3    38 	  2 pad5		bit (6),
  3    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  3    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  3    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  3    42 /***** End of word 3 */
  3    43 	  2 pad7		bit (3),
  3    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  3    45 	  2 bit_count	fixed bin (24) uns
  3    46 	  )		unaligned;		/* bitcount of segment */
  3    47 
  3    48 dcl	1 slte		based (sltep) aligned,
  3    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  3    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  3    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  3    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  3    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  3    54 	  2 firmware_seg    bit (1),
  3    55 	  2 layout_seg      bit (1),
  3    56 	  2 breakpointable  bit (1),
  3    57 	  2 pad2		bit (3),
  3    58 	  2 wired		bit (1),			/* segment is wired if ON */
  3    59 	  2 paged		bit (1),			/* segment is paged if ON */
  3    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  3    61 	  2 pad3		bit (2),
  3    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  3    63 	  2 pad4		bit (3),
  3    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  3    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  3    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  3    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  3    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  3    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  3    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  3    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  3    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  3    73 	  2 pad5		bit (6),
  3    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  3    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  3    76 	  2 segno		bit (18),			/* text/link segment number */
  3    77 	  2 pad6		bit (3),
  3    78 	  2 max_length	bit (9),			/* maximum length for segment */
  3    79 	  2 bit_count	bit (24)
  3    80 	  )		unaligned;		/* bitcount of segment */
  3    81 
  3    82 /* END INCLUDE FILE slte.incl.pl1 */
     1286 
     1287  /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
  4     5*     install(86-11-21,MR12.0-1223):
  4     6*     created.
  4     7*                                                   END HISTORY COMMENTS */
  4     8 
  4     9 /* format: off */
  4    10 
  4    11 /* ************************************************************************ */
  4    12 /*							      */
  4    13 /* Function: Provides constants for commonly used Multics system values.    */
  4    14 /*							      */
  4    15 /* Usage: These values are available for use in place of "magic" numbers    */
  4    16 /*        (unexplained numbers) in programming applications.	      */
  4    17 /*							      */
  4    18 /* Definitions:						      */
  4    19 /*							      */
  4    20 /*   PER             bit     character/byte     word     page     segment   */
  4    21 /*		 					      */
  4    22 /*   bits              1            9             36     36864    9400320   */
  4    23 /*   characters/bytes	      1	           4      4096    1044480   */
  4    24 /*   words				 1      1024     261120   */
  4    25 /*   pages				           1        255   */
  4    26 /*   segments						  1   */
  4    27 /*							      */
  4    28 /*  The base values for a bit, char, word and page are determined by the    */
  4    29 /*  Multics hardware implementation.  The other values are calculated from  */
  4    30 /*  their relation to one another as shown in the matrix above.	      */
  4    31 /*							      */
  4    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
  4    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
  4    34 /*		  = 9 * 4					      */
  4    35 /*		  = 36					      */
  4    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
  4    37 /*		  = 9 * 4 * 1024				      */
  4    38 /*		  = 36864					      */
  4    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
  4    40 /*		    PAGES_PER_SEGMENT			      */
  4    41 /*		  = 9 * 4 * 1024 * 255			      */
  4    42 /*		  = 9400320				      */
  4    43 /*							      */
  4    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
  4    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
  4    46 /*		  = 4 * 1024				      */
  4    47 /*		  = 4096					      */
  4    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
  4    49 /*		  = 4 * 1024 * 255				      */
  4    50 /*		  = 1044480				      */
  4    51 /*							      */
  4    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
  4    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
  4    54 /*		  = 1024 * 255				      */
  4    55 /*		  = 261120				      */
  4    56 /*							      */
  4    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
  4    58 /*							      */
  4    59 /* ************************************************************************ */
  4    60 
  4    61        declare BITS_PER_CHAR		fixed bin (4) internal static
  4    62 				options (constant) initial (9);
  4    63 
  4    64        declare BITS_PER_WORD		fixed bin (6) internal static
  4    65 				options (constant) initial (36);
  4    66 
  4    67        declare BITS_PER_PAGE		fixed bin (16) internal static
  4    68 				options (constant) initial (36864);
  4    69 
  4    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
  4    71 				options (constant) initial (9400320);
  4    72 
  4    73        declare CHARS_PER_WORD		fixed bin (3) internal static
  4    74 				options (constant) initial (4);
  4    75 
  4    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
  4    77 				options (constant) initial (4096);
  4    78 
  4    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
  4    80 				options (constant) initial (1044480);
  4    81 
  4    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
  4    83 
  4    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
  4    85 				options (constant) initial (1024);
  4    86 
  4    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
  4    88 
  4    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
  4    90 				options (constant) initial (261120);
  4    91 
  4    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
  4    93 				options (constant) initial (255);
  4    94 
  4    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
  4    96 
     1287 
     1288  /* BEGIN INCLUDE FILE tape_mult_boot_info.incl.pl1 */
  5     2 /* Written by J. A. Bush 6/27/81 */
  5     3 
  5     4 dcl 1 boot_program_info aligned,
  5     5     2 version fixed bin,				/* Currently 1 */
  5     6     2 boot_program_ptr pointer,			/* Pointer to text section of boot program */
  5     7     2 boot_program_text_length fixed bin (21),		/* Length of the text section in words */
  5     8     2 boot_program_name char (32) unaligned;		/* Name for recording in label */
  5     9 
  5    10 dcl  BOOT_PROGRAM_INFO_VERSION_1 fixed bin internal static options
  5    11     (constant) init (1);
  5    12 
  5    13 /* END INCLUDE FILE tape_mult_boot_info.incl.pl1 */
     1288 
     1289  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  6     2 /* format: style2,^inddcls,idind32 */
  6     3 
  6     4 declare 1 terminate_file_switches	based,
  6     5 	2 truncate		bit (1) unaligned,
  6     6 	2 set_bc			bit (1) unaligned,
  6     7 	2 terminate		bit (1) unaligned,
  6     8 	2 force_write		bit (1) unaligned,
  6     9 	2 delete			bit (1) unaligned;
  6    10 
  6    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  6    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  6    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  6    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  6    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  6    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  6    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  6    18 
  6    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1289 
     1290      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/15/87  1716.0  compare_mst.pl1                   >special_ldd>install>MR12.1-1040>compare_mst.pl1
1284         1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1285         2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1286         3    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
1287         4    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
1288         5    03/27/82  0429.7  tape_mult_boot_info.incl.pl1      >ldd>include>tape_mult_boot_info.incl.pl1
1289         6    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_WORD                          constant        fixed bin(6,0)           initial dcl 4-64 ref 503 575 1136 1143
BOOT_PROGRAM_INFO_VERSION_1            constant        fixed bin(17,0)          initial dcl 5-10 ref 665 741
CHARS_PER_WORD                         constant        fixed bin(3,0)           initial dcl 4-73 ref 621 668
COPY                                   constant        fixed bin(17,0)          initial dcl 44 set ref 297 301 332 332 332 338 345
                                                                                  357 358 364 365 370 372 380 380 394* 396 399* 402*
                                                                                  411 450 454 456 456 476* 500 501* 502 502 503 507*
                                                                                  520* 534 537 538* 539 539 547* 554 606 838 838 839
                                                                                  840 845 846 847 848 849 850 852 852 855 855 856
                                                                                  856 857 857 857 858 859 859 859 860 861 862 862
                                                                                  872 873 879 882 892 892 892 896 896 896 900 900
                                                                                  900 904 904 904 908 908 908 913 913 913 917 922
                                                                                  923 925 927 940 941 941 941 947 947 947 951 951
                                                                                  955 955 955 959 959 959 964 964 964 968 968 968
                                                                                  972 972 972 976 976 976 980 980 980 984 984 984
                                                                                  988 988 988 988 988 988 988 988 988 998 998 998
                                                                                  1002 1002 1002 1006 1006 1006 1012 1016 1017 1019
                                                                                  1021 1027 1028 1032 1032 1114 1117 1142 1244 1262*
MASTER                                 constant        fixed bin(17,0)          initial dcl 44 set ref 272 284 330 330 330 338 345
                                                                                  357 358 363 364 365 370 372 379 379 389* 392* 396
                                                                                  401* 411 420* 441* 453* 466 469 470* 471 471 517
                                                                                  521 523 523 546* 554 606 807 807 809 810 815 816
                                                                                  817 818 819 820 822 822 825 825 826 826 827 827
                                                                                  827 828 829 829 829 830 831 831 832 832 872 873
                                                                                  876 882 892 892 892 896 896 896 900 900 900 904
                                                                                  904 904 908 908 908 913 913 913 917 917 920 921
                                                                                  923 925 927 934 935 935 935 947 947 947 951 951
                                                                                  951 955 955 955 959 959 959 964 964 964 968 968
                                                                                  968 972 972 972 976 976 976 980 980 980 984 984
                                                                                  984 988 988 988 988 988 988 988 988 988 998 998
                                                                                  998 1002 1002 1002 1006 1006 1006 1011 1012 1014
                                                                                  1015 1017 1019 1021 1023 1024 1032 1032 1114 1115
                                                                                  1117 1135 1232 1244 1263*
OFF_ON                          000024 constant        char(8)                  initial dcl 43 ref 896 896 896 896 900 900 900 900
                                                                                  904 904 904 904 908 908 908 908 913 913 913 913
                                                                                  947 947 947 947 955 955 955 955 959 959 959 959
                                                                                  964 964 964 964 968 968 968 968 972 972 972 972
                                                                                  976 976 976 976 980 980 980 980
REWP                            000026 constant        char(64)                 initial dcl 41 ref 892 892 892 892
RW_ACCESS                       000153 constant        bit(3)                   initial unaligned dcl 1-11 set ref 496* 570* 1132*
                                                                                  1139*
Stream_input                    000163 constant        fixed bin(17,0)          initial dcl 2-15 set ref 655* 679* 735*
TERM_FILE_TRUNC_BC_TERM         000000 constant        bit(3)                   initial unaligned dcl 6-15 set ref 503* 575* 1136*
                                                                                  1143*
UNSET                                  constant        fixed bin(17,0)          initial dcl 44 ref 263 264 294 312 726
abs                                                    builtin function         dcl 237 ref 927 1021
abs_changes                            constant        fixed bin(17,0)          initial dcl 47 ref 927 1021
absolute_pathname_              000010 constant        entry                    external dcl 201 ref 640
access                    2            based           bit(4)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 892 892 892
access                    2            based           bit(4)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 892 892 892
accessname                             based           char(32)                 array level 5 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 935*
accessname                             based           char(32)                 array level 5 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 941*
acl                                    based           structure                array level 4 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst"
acl                                    based           structure                array level 4 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst"
acl_provided              2(17)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 855 913 913 913
acl_provided              2(17)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 825 913 913 913
acl_structure                          based           structure                array level 3 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 922
acl_structure                          based           structure                array level 3 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 921
add                      13(01)        based           bit(1)                   array level 4 in structure "tp1_names" packed
                                                                                  unaligned dcl 150 in procedure "compare_mst" set
                                                                                  ref 566
add                      13(01)        based           bit(1)                   array level 4 in structure "tp2_names" packed
                                                                                  unaligned dcl 151 in procedure "compare_mst" set
                                                                                  ref 481 492 1237* 1250
add                      13(01)        based           bit(1)                   array level 4 in structure "tp_names" packed
                                                                                  unaligned dcl 1066 in procedure "read_tape" set
                                                                                  ref 1080*
add_count                       000774 automatic       fixed bin(17,0)          dcl 1227 set ref 1242* 1266* 1268
addr                                                   builtin function         dcl 237 ref 661 661 670 670 742 742 921 922 1015
                                                                                  1016 1233 1233 1262 1262 1263 1263
anp                             000102 automatic       pointer                  array dcl 154 set ref 921* 922* 923 923 1015* 1016*
                                                                                  1017 1017
arg                                    based           char                     unaligned dcl 52 set ref 268 269 271 271 274* 283
                                                                                  283 286* 296 296 300 300 304 304 305* 312* 320*
                                                                                  327* 330 332 334*
arg_count                       000110 automatic       fixed bin(17,0)          dcl 156 set ref 260* 266 274 286 305
argl                            000100 automatic       fixed bin(21,0)          dcl 153 set ref 267* 268 269 271 271 274 274 283 283
                                                                                  286 286 296 296 300 300 304 304 305 305 312 312
                                                                                  320 320 327 327 330 332 334 334
argp                            000106 automatic       pointer                  dcl 155 set ref 267* 268 269 271 271 274 283 283 286
                                                                                  296 296 300 300 304 304 305 312 320 327 330 332
                                                                                  334
argx                            000111 automatic       fixed bin(17,0)          dcl 157 set ref 266* 267* 274 278* 278 279* 286 290*
                                                                                  290 291* 305 309* 309 310*
atd                             000112 automatic       char(256)                unaligned dcl 158 set ref 725* 726* 726 729
binary                                                 builtin function         dcl 237 ref 825 826 855 856 892 892 892 892 896 896
                                                                                  896 896 900 900 900 900 904 904 904 904 908 908
                                                                                  908 908 913 913 913 913 935 935 941 941 947 947
                                                                                  947 947 955 955 955 955 959 959 959 959 964 964
                                                                                  964 964 968 968 968 968 972 972 972 972 976 976
                                                                                  976 976 980 980 980 980 984 984 984 984 988 988
                                                                                  988 988 988 988 988 988 988 988 988 988 998 998
                                                                                  998 998 1002 1002 1002 1002 1006 1006 1006 1006
bit_count                 4(12)        based           bit(24)                  level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 1006 1006 1006
bit_count                 4(12)        based           bit(24)                  level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 1006 1006 1006
bit_len                         000212 automatic       fixed bin(17,0)          dcl 159 set ref 465* 466 533* 534 871* 872 872 872
                                                                                  873 882 882 882 883 920* 923 923 923 924 1014*
                                                                                  1017 1017 1017 1018 1115* 1117 1119 1124 1128 1128
bits                                   based           bit(1)                   array unaligned dcl 55 set ref 872* 873 882* 883
                                                                                  923* 924 1017* 1018 1117* 1119 1124 1128
bits_ptr                        000214 automatic       pointer                  dcl 160 set ref 244* 352* 872 873 882 883 923 924
                                                                                  1017 1018 1117 1119 1124 1128
boot_label                      000216 automatic       bit(1)                   array dcl 161 set ref 357 357 358* 358* 363 667*
                                                                                  677* 750* 758*
boot_program_info               000542 automatic       structure                level 1 dcl 5-4
boot_program_name         5     000226 automatic       char(32)                 array level 2 packed unaligned dcl 164 set ref 364
                                                                                  364 365* 365* 668 670 670
boot_program_ptr          2     000226 automatic       pointer                  array level 2 dcl 164 set ref 381 673* 749 753 755*
boot_program_text_length
                          4     000226 automatic       fixed bin(21,0)          array level 2 dcl 164 set ref 370 370 372* 372* 379
                                                                                  380 674* 751
boot_ptr                        000220 automatic       pointer                  array dcl 162 set ref 245* 346* 671* 673 753 755
bootstrap_header                       based           structure                level 1 dcl 57
bootstrap_sw                    000224 automatic       bit(1)                   array dcl 163 set ref 256* 405* 810 815* 840 845*
bpi                             000226 automatic       structure                array level 1 dcl 164 set ref 742 742
branch_required           2(21)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 856 947 947 947
branch_required           2(21)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 826 947 947 947
cache                     2(04)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 896 896 896
cache                     2(04)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 896 896 896
char                                                   builtin function         dcl 237 ref 726 1089 1089
cleanup                         000534 stack reference condition                dcl 241 ref 250
code                            000262 automatic       fixed bin(35,0)          dcl 165 set ref 252* 254 254* 496* 503* 570* 575*
                                                                                  601* 609* 610* 621* 623 624 625* 640* 642 642*
                                                                                  648* 651 651* 655* 657 657* 686* 687 689* 729* 731
                                                                                  731* 735* 737 737* 742* 744 744* 765* 766 768*
                                                                                  786* 787 792* 795 801 1041* 1042 1048* 1049 1055*
                                                                                  1070 1072 1132* 1136* 1139* 1143*
col                      13            based           bit(1)                   array level 4 in structure "tp1_names" packed
                                                                                  unaligned dcl 150 in procedure "compare_mst" set
                                                                                  ref 421
col                      13            based           bit(1)                   array level 4 in structure "tp2_names" packed
                                                                                  unaligned dcl 151 in procedure "compare_mst" set
                                                                                  ref 478
col                      13            based           bit(1)                   array level 4 in structure "tp_names" packed
                                                                                  unaligned dcl 1066 in procedure "read_tape" set
                                                                                  ref 1092*
collection                      000263 automatic       bit(1)                   dcl 166 set ref 420* 421 476* 478 562* 563 1071*
                                                                                  1081
collection_mark                        based           bit(18)                  level 4 packed unaligned dcl 70 ref 788
collection_mark_data                   based           structure                level 1 packed unaligned dcl 63
com_err_                        000012 constant        entry                    external dcl 202 ref 254
combine_link              2(27)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 976 976 976
combine_link              2(27)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 976 976 976
compare_mst_severity_           000064 external static fixed bin(17,0)          initial dcl 228 set ref 243* 353* 361* 361 368* 368
                                                                                  376* 376 423* 423 430* 430 440* 440 462* 462 483*
                                                                                  483 494* 494 530* 530 568* 568 585* 585 600* 600
                                                                                  688* 688 767* 767 812* 812 842* 842 889* 889 928*
                                                                                  928 1054* 1054 1107* 1107 1127* 1127
control_word                    000600 automatic       structure                level 1 dcl 636 set ref 661 661 661 661
convert                                                builtin function         dcl 237 ref 317
copy                                   based           fixed bin(35,0)          array dcl 723 set ref 753* 753
copy_ptr                        000264 automatic       pointer                  dcl 167 set ref 1132* 1134 1135 1136* 1139* 1141
                                                                                  1142 1143*
count                     0(18) 000600 automatic       fixed bin(18,0)          level 2 packed unsigned unaligned dcl 636 set ref
                                                                                  669
cu_$arg_list_ptr                000014 constant        entry                    external dcl 203 ref 252 252
cur_length                3            based           bit(9)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 984 984 984
cur_length                3            based           bit(9)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 984 984 984
data_ptr                               parameter       pointer                  dcl 617 set ref 615 621*
data_words                             parameter       fixed bin(18,0)          unsigned unaligned dcl 617 ref 615 621
del                      13(02)        based           bit(1)                   array level 4 in structure "tp_names" packed
                                                                                  unaligned dcl 1066 in procedure "read_tape" set
                                                                                  ref 1078*
del                      13(02)        based           bit(1)                   array level 4 in structure "tp1_names" packed
                                                                                  unaligned dcl 150 in procedure "compare_mst" set
                                                                                  ref 428 438 1236* 1245
del_count                       000775 automatic       fixed bin(17,0)          dcl 1228 set ref 1242* 1265* 1268
divide                                                 builtin function         dcl 237 ref 668 1162 1202
error_table_$bad_arg            000066 external static fixed bin(35,0)          dcl 230 set ref 320* 334*
error_table_$badopt             000070 external static fixed bin(35,0)          dcl 230 set ref 327*
error_table_$end_of_info        000072 external static fixed bin(35,0)          dcl 230 ref 623 801 1070
error_table_$inconsistent       000074 external static fixed bin(35,0)          dcl 230 set ref 312*
error_table_$noarg              000076 external static fixed bin(35,0)          dcl 230 set ref 274* 286* 305* 339*
found_mark                             parameter       bit(1)                   dcl 777 set ref 775 789* 796*
get_shortest_path_              000016 constant        entry                    external dcl 204 ref 646
get_wdir_                       000020 constant        entry                    external dcl 205 ref 496 496 570 570 1132 1132 1139
                                                                                  1139
has_acl                         000266 automatic       fixed bin(17,0)          array dcl 168 set ref 817* 825* 829 832 847* 855*
                                                                                  859 862 917 1032 1032 1032 1032
has_branch                      000270 automatic       fixed bin(17,0)          array dcl 169 set ref 819* 826* 827 829 832 849*
                                                                                  856* 857 859 862 877 877 880 880 921 922 935 935
                                                                                  935 941 941 941 951 1032 1032 1032 1032
have_sysid                      000272 automatic       bit(1)                   dcl 170 set ref 257* 396 1098*
head_ptr                 16            based           pointer                  array level 2 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1076*
head_ptr                 16            based           pointer                  array level 2 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst" set ref 450 531* 534
head_ptr                 16            based           pointer                  array level 2 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst" set ref 463* 466 517
header                                 based           structure                level 2 in structure "mst2" dcl 100 in procedure
                                                                                  "compare_mst"
header                                 based           structure                level 2 in structure "mst1" dcl 70 in procedure
                                                                                  "compare_mst"
header_control_word                    based           structure                level 3 in structure "mst1" dcl 70 in procedure
                                                                                  "compare_mst"
header_control_word                    based           structure                level 3 in structure "mst2" dcl 100 in procedure
                                                                                  "compare_mst"
header_length             0(18)        based           fixed bin(17,0)          level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 533 869
header_length             0(18)        based           fixed bin(17,0)          level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 465 792 869 871
header_words                           based           fixed bin(17,0)          array dcl 68 set ref 466* 466 534* 534 872 872 882
                                                                                  882 923 923 1017 1017
high_index                      000761 automatic       fixed bin(17,0)          dcl 1195 set ref 1200* 1201 1202 1205* 1207 1209
                                                                                  1210
hold_info                       000730 automatic       structure                level 1 dcl 1153 set ref 1168* 1173
i                               000706 automatic       fixed bin(17,0)          dcl 1063 in procedure "read_tape" set ref 1082* 1084
                                                                                  1085*
i                               000273 automatic       fixed bin(17,0)          dcl 171 in procedure "compare_mst" set ref 338* 339
                                                                                  339 339* 339* 339* 345* 346 347 348 349* 417* 421
                                                                                  428 429 435 438 447 447 449 463 466 467 469 554*
                                                                                  557* 559 561 562* 564 565 566 570 573 574* 575 575
                                                                                  578 578 580* 583* 606* 607 609 610* 1232* 1233
                                                                                  1233 1236* 1241* 1244 1245 1245 1247* 1247 1256
                                                                                  1257* 1257 1262 1262 1265 1276 1278 1279* 1279
in_den                          000274 automatic       fixed bin(17,0)          array dcl 172 set ref 263* 317* 317 726 726
in_file_name                    000276 automatic       char(168)                array unaligned dcl 173 set ref 262* 273* 285* 292*
                                                                                  330 332 339 640* 640* 642* 646* 646* 648 651* 657*
                                                                                  702 711
in_tape_name                    000422 automatic       char(32)                 array unaligned dcl 174 set ref 262* 273* 280* 285*
                                                                                  330 330* 332 332* 339 704 725* 731* 737* 744*
index                                                  builtin function         dcl 237 in procedure "compare_mst" ref 268 1124 1128
index                                  parameter       fixed bin(17,0)          dcl 1190 in procedure "name_search" ref 1185 1200
                                                                                  1203 1204 1208 1209 1211 1211 1217 1217 1219
index                                  parameter       fixed bin(17,0)          dcl 634 in procedure "get_in_file" set ref 631 640
                                                                                  640 642* 646 646 648 648 648 651 655 657 661* 665
                                                                                  667 668 670* 670 670 671* 671 673 673 674 677 678
                                                                                  679 683 686
index                                  parameter       fixed bin(17,0)          dcl 700 in procedure "get_in_medium" set ref 697 702
                                                                                  702* 704 704* 708 711 711* 713*
index                                  parameter       fixed bin(17,0)          dcl 1046 in procedure "read_segment" ref 1045 1048
                                                                                  1048 1048
index                                  parameter       fixed bin(17,0)          dcl 1061 in procedure "read_tape" set ref 1059 1069
                                                                                  1071* 1073 1073 1074 1075 1076 1077 1078 1078 1080
                                                                                  1084 1084 1085 1085 1089 1089 1089 1092 1095 1096*
                                                                                  1099 1099 1105 1106*
index                                  parameter       fixed bin(17,0)          dcl 1039 in procedure "skip_block" ref 1038 1041
                                                                                  1041 1041
index                                  parameter       fixed bin(17,0)          dcl 721 in procedure "get_in_tape" ref 718 725 726
                                                                                  726 729 729 731 735 737 741 742 742 742 744 749
                                                                                  750 751 753 753 755 755 758 762 765
index                                  parameter       fixed bin(17,0)          dcl 1151 in procedure "sort_names" ref 1149 1160
                                                                                  1163 1166 1166 1168 1170 1170 1171 1171 1173 1174
                                                                                  1174
index                                  parameter       fixed bin(17,0)          dcl 617 in procedure "get_data" set ref 615 621 625*
index                                  parameter       fixed bin(17,0)          dcl 778 in procedure "read_header" ref 775 786 786
                                                                                  788 792 792 792 792 798
info_ptr                 14            based           pointer                  array level 2 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst" set ref 467* 469 521
info_ptr                 14            based           pointer                  array level 2 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1077*
info_ptr                 14            based           pointer                  array level 2 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst" set ref 454 496* 499
                                                                                  500 503* 535* 537
init_seg                  2(22)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 955 955 955
init_seg                  2(22)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 955 955 955
initiate_file_$create           000022 constant        entry                    external dcl 206 ref 496 570 1132 1139
ioa_                            000024 constant        entry                    external dcl 208 ref 355 358 365 372 396 429 439 461
                                                                                  482 493 529 567 584 589 811 841 887 892 896 900
                                                                                  904 908 913 925 933 935 939 941 947 951 955 959
                                                                                  964 968 972 976 980 984 988 998 1002 1006 1019
                                                                                  1022 1024 1026 1028 1032 1106 1126 1129
iocb_ptr                        000442 automatic       pointer                  array dcl 175 set ref 246* 607 609* 610* 621* 648*
                                                                                  655* 678* 679* 686* 729* 735* 742* 765* 786* 792*
                                                                                  1041* 1048*
iox_$attach_name                000026 constant        entry                    external dcl 209 ref 648 729
iox_$close                      000030 constant        entry                    external dcl 210 ref 609 678 686 765
iox_$control                    000032 constant        entry                    external dcl 211 ref 742
iox_$detach_iocb                000034 constant        entry                    external dcl 212 ref 610
iox_$get_chars                  000036 constant        entry                    external dcl 213 ref 621 786 792 1041 1048
iox_$open                       000040 constant        entry                    external dcl 214 ref 655 679 735
j                               000446 automatic       fixed bin(17,0)          dcl 176 set ref 412* 478 481 482 489 492 496 499 500
                                                                                  503 514 514 516 531 534 535 537 559* 560* 561 564
                                                                                  587* 587 1241* 1244 1250 1250 1252* 1252 1256
                                                                                  1258* 1258 1263 1263 1266 1269 1271 1272* 1272
k                               000447 automatic       fixed bin(17,0)          dcl 177 set ref 564* 565 566 876* 877 877* 879* 880
                                                                                  880* 934* 935 935 935* 940* 941 941 941* 1023*
                                                                                  1024* 1027* 1028* 1124* 1126* 1128* 1129* 1202*
                                                                                  1203 1204 1204 1205 1210* 1211 1211
l1_index                        000450 automatic       fixed bin(17,0)          dcl 178 set ref 406* 411 417 432* 432 442* 442 457*
                                                                                  457 472* 472 549* 549 554 559
l2_index                        000451 automatic       fixed bin(17,0)          dcl 179 set ref 406* 411 412 485* 485 508* 508 524*
                                                                                  524 540* 540 550* 550 554 560
last_collection_mark            000707 automatic       fixed bin(17,0)          dcl 1064 set ref 1068* 1082 1087*
length                                                 builtin function         dcl 237 ref 668
link_provided             2(24)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 964 964 964
link_provided             2(24)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 964 964 964
link_sect                 2(25)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 968 968 968
link_sect                 2(25)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 968 968 968
link_sect_wired           2(26)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 972 972 972
link_sect_wired           2(26)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 972 972 972
low_index                       000760 automatic       fixed bin(17,0)          dcl 1194 set ref 1199* 1201 1202 1204* 1208
ltrim                                                  builtin function         dcl 237 ref 726 1089 1089
major                     1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 63 ref 1084
                                                                                  1089
major_collection         11            based           fixed bin(17,0)          level 3 in structure "tp_name" dcl 134 in procedure
                                                                                  "compare_mst" ref 1217
major_collection         11            based           fixed bin(17,0)          array level 3 in structure "tp_names" dcl 1196
                                                                                  in procedure "name_search" ref 1217
major_collection         11            based           fixed bin(17,0)          array level 3 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1084*
master_copy                     000452 automatic       fixed bin(17,0)          dcl 180 set ref 264* 272* 273 273 280 284* 285 285
                                                                                  292 294* 297* 301* 312 317
max                                                    builtin function         dcl 237 ref 361 368 376 423 430 440 462 483 494 530
                                                                                  568 585 600 688 767 812 842 889 928 1054 1107 1127
max_length                4(03)        based           bit(9)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 1002 1002 1002
max_length                4(03)        based           bit(9)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 1002 1002 1002
minor                     1(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 63 ref 1085
                                                                                  1089
minor_collection         12            based           fixed bin(17,0)          level 3 in structure "tp_name" dcl 134 in procedure
                                                                                  "compare_mst" ref 1217
minor_collection         12            based           fixed bin(17,0)          array level 3 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1085*
minor_collection         12            based           fixed bin(17,0)          array level 3 in structure "tp_names" dcl 1196
                                                                                  in procedure "name_search" ref 1217
mode                                   based           bit(3)                   array level 5 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 935 935
mode                                   based           bit(3)                   array level 5 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 941 941
mov                      13(03)        based           bit(1)                   array level 4 in structure "tp2_names" packed
                                                                                  unaligned dcl 151 in procedure "compare_mst" set
                                                                                  ref 514 1269* 1277*
mov                      13(03)        based           bit(1)                   array level 4 in structure "tp1_names" packed
                                                                                  unaligned dcl 150 in procedure "compare_mst" set
                                                                                  ref 447 1270* 1276*
move_index               20            based           fixed bin(17,0)          array level 2 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst" set ref 514 516 1250
                                                                                  1278*
move_index               20            based           fixed bin(17,0)          array level 2 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst" set ref 447 449 1245
                                                                                  1271*
mst1                                   based           structure                level 1 dcl 70
mst2                                   based           structure                level 1 dcl 100
mst_name                        000007 constant        varying char(19)         initial array dcl 48 ref 648 729
mst_ptr                         000454 automatic       pointer                  array dcl 181 set ref 351* 381* 384* 450* 454* 456*
                                                                                  465 466 469* 471* 500* 502* 517* 521* 523* 533 534
                                                                                  537* 539* 570* 573 575* 578* 786* 788 792 792 792
                                                                                  807 822 825 826 827 829 831 832 838 852 855 856
                                                                                  857 859 861 862 869 869 871 872 872 877 877 880
                                                                                  880 882 882 892 892 892 892 892 892 896 896 896
                                                                                  896 896 896 900 900 900 900 900 900 904 904 904
                                                                                  904 904 904 908 908 908 908 908 908 913 913 913
                                                                                  913 913 913 921 922 935 935 935 941 941 941 947
                                                                                  947 947 947 947 947 951 951 951 951 955 955 955
                                                                                  955 955 955 959 959 959 959 959 959 964 964 964
                                                                                  964 964 964 968 968 968 968 968 968 972 972 972
                                                                                  972 972 972 976 976 976 976 976 976 980 980 980
                                                                                  980 980 980 984 984 984 984 984 984 988 988 988
                                                                                  988 988 988 988 988 988 988 988 988 988 988 988
                                                                                  988 988 988 998 998 998 998 998 998 1002 1002 1002
                                                                                  1002 1002 1002 1006 1006 1006 1006 1006 1006 1015
                                                                                  1016 1024 1028 1032 1032 1032 1032 1041* 1048*
                                                                                  1084 1085 1089 1089 1099 1117 1117 1135 1142
mst_ptr_hold                    000460 automatic       pointer                  array dcl 182 set ref 247* 347* 351 384 456 471 502
                                                                                  523 539 578
n_acls                                 based           fixed bin(17,0)          array level 4 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 859
n_acls                          000464 automatic       fixed bin(17,0)          array dcl 183 in procedure "compare_mst" set ref
                                                                                  818* 829* 829 829 830* 832 848* 859* 859 859 860*
                                                                                  862 873 873 876 877 877 877 877 879 880 880 880
                                                                                  880 917 917 920 921 921 922 922 925* 925* 927 927
                                                                                  934 935 935 935 935 935 935 940 941 941 941 941
                                                                                  941 941 1032 1032 1032 1032
n_acls                                 based           fixed bin(17,0)          array level 4 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 829
n_names                         000466 automatic       fixed bin(17,0)          array dcl 184 in procedure "compare_mst" set ref
                                                                                  807* 809 816* 827 829 832 838* 839 846* 857 859
                                                                                  862 877 877 880 880 921 922 935 935 935 941 941
                                                                                  941 951 951 951 951 1011 1012 1012 1014 1019*
                                                                                  1019* 1021 1021 1023 1027 1032 1032 1032 1032
n_names                   5            based           fixed bin(17,0)          level 4 in structure "mst1" dcl 70 in procedure
                                                                                  "compare_mst" set ref 807
n_names                   5            based           fixed bin(17,0)          level 4 in structure "mst2" dcl 100 in procedure
                                                                                  "compare_mst" set ref 838
name                                   based           char(32)                 array level 3 in structure "tp_names" dcl 1196
                                                                                  in procedure "name_search" ref 1203 1204 1209 1211
                                                                                  1219
name                      7            based           char(32)                 array level 5 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 861 1028*
name                      7            based           char(32)                 array level 5 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 831 1024*
name                                   based           char(32)                 level 3 in structure "tp_name" dcl 134 in procedure
                                                                                  "compare_mst" ref 1203 1204 1209 1211 1219
name                                   based           char(32)                 array level 3 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst" set ref 482* 489 1256
name                                   based           char(32)                 array level 3 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1089* 1095* 1105
name                                   based           char(32)                 array level 3 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst" set ref 429* 435 565
                                                                                  1256
name                                   based           char(32)                 array level 3 in structure "tp_names" dcl 1158
                                                                                  in procedure "sort_names" set ref 1166 1166
name_count                      000470 automatic       fixed bin(17,0)          array dcl 185 set ref 411 411 554 554 561 1069* 1073
                                                                                  1073* 1160 1163 1200 1208 1211 1232 1244 1244
name_element              6            based           structure                array level 4 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst"
name_element              6            based           structure                array level 4 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst"
name_index                      000710 automatic       fixed bin(17,0)          dcl 1065 set ref 1069* 1073* 1074 1074 1075 1075
                                                                                  1076 1077 1078 1080 1082 1087 1089 1092 1095 1105
name_len                        000472 automatic       fixed bin(18,0)          unsigned unaligned dcl 186 set ref 668* 669 670*
names_array               5            based           structure                level 3 in structure "mst2" dcl 100 in procedure
                                                                                  "compare_mst" set ref 1016
names_array               5            based           structure                level 3 in structure "mst1" dcl 70 in procedure
                                                                                  "compare_mst" set ref 1015
nelemt                          000473 automatic       fixed bin(21,0)          dcl 187 set ref 786* 792* 1041* 1048*
np                              000474 automatic       pointer                  array dcl 188 set ref 248* 348* 412 417 421 428 429
                                                                                  435 438 447 447 449 450 454 463 466 467 469 478
                                                                                  481 482 489 492 496 499 500 503 514 514 516 517
                                                                                  521 531 534 535 537 564 565 566 1074 1075 1076
                                                                                  1077 1078 1080 1084 1085 1089 1092 1095 1105 1166
                                                                                  1166 1168 1170 1170 1171 1171 1173 1174 1174 1203
                                                                                  1204 1209 1211 1217 1217 1219 1233 1233 1233 1233
                                                                                  1236 1236 1237 1245 1245 1245 1245 1250 1250 1250
                                                                                  1250 1256 1256 1256 1256 1262 1262 1262 1262 1263
                                                                                  1263 1263 1263 1265 1265 1265 1266 1266 1266 1269
                                                                                  1269 1270 1271 1271 1276 1276 1277 1278 1278
null                                                   builtin function         dcl 237 ref 244 245 246 247 248 249 499 573 607 648
                                                                                  648 729 729 749 1076 1077 1134 1141
offset_1                        000776 automatic       fixed bin(17,0)          dcl 1229 set ref 1233* 1234 1237 1263* 1265 1270
                                                                                  1271
offset_2                        000777 automatic       fixed bin(17,0)          dcl 1230 set ref 1262* 1266 1277 1278
opt                                    based           char                     unaligned dcl 52 set ref 280 292 311 311 311 312*
                                                                                  317 320*
optl                            000500 automatic       fixed bin(21,0)          dcl 189 set ref 279* 280 291* 292 310* 311 311 311
                                                                                  312 312 317 320 320
optp                            000502 automatic       pointer                  dcl 190 set ref 279* 280 291* 292 310* 311 311 311
                                                                                  312 317 320
order_info                             based           structure                array level 2 in structure "tp_names" dcl 1196
                                                                                  in procedure "name_search"
order_info                             based           structure                level 2 in structure "tp_name" dcl 134 in procedure
                                                                                  "compare_mst"
order_info                             based           structure                array level 2 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape"
order_info                             based           structure                array level 2 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst"
order_info                             based           structure                array level 2 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst"
order_info                             based           structure                array level 2 in structure "tp_names" dcl 1158
                                                                                  in procedure "sort_names" set ref 1168 1170* 1170
                                                                                  1173*
org_index                10            based           fixed bin(17,0)          array level 3 in structure "tp_names" dcl 1158
                                                                                  in procedure "sort_names" set ref 1171 1174
org_index                10            based           fixed bin(17,0)          array level 3 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1074*
org_index                10            based           fixed bin(17,0)          array level 3 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst" set ref 1265 1265
org_index                10            based           fixed bin(17,0)          array level 3 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst" set ref 1266 1266
pad                                    based           fixed bin(17,0)          array level 5 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 880* 880*
pad                                    based           fixed bin(17,0)          array level 5 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 877* 877*
paged                     2(13)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 904 904 904
paged                     2(13)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 904 904 904
parse_tape_reel_name_           000042 constant        entry                    external dcl 215 ref 725
path_length                     000504 automatic       fixed bin(17,0)          array dcl 191 set ref 820* 827* 827 827 828* 829 832
                                                                                  850* 857* 857 857 858* 859 862 877 877 880 880 921
                                                                                  922 935 935 935 941 941 941 951 951 951 951 951
                                                                                  951 951 951 951 951 951 951 951 951 1032 1032 1032
                                                                                  1032
pathname                               based           char                     array level 4 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" set ref 951 951*
pathname                               based           char                     array level 4 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" set ref 951 951*
pathname_array                         based           structure                array level 3 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst"
pathname_array                         based           structure                array level 3 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst"
pathname_length                        based           fixed bin(17,0)          array level 4 in structure "mst1" dcl 70
                                                                                  in procedure "compare_mst" ref 827
pathname_length                        based           fixed bin(17,0)          array level 4 in structure "mst2" dcl 100
                                                                                  in procedure "compare_mst" ref 857
per_process               2(14)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 908 908 908
per_process               2(14)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 908 908 908
pos_n                    21            based           fixed bin(17,0)          array level 2 in structure "tp_names" dcl 1066
                                                                                  in procedure "read_tape" set ref 1075*
pos_n                    21            based           fixed bin(17,0)          array level 2 in structure "tp2_names" dcl 151
                                                                                  in procedure "compare_mst" set ref 412 1250 1250
                                                                                  1256 1263 1263 1266 1269 1271
pos_n                    21            based           fixed bin(17,0)          array level 2 in structure "tp_names" dcl 1158
                                                                                  in procedure "sort_names" set ref 1171* 1174*
pos_n                    21            based           fixed bin(17,0)          array level 2 in structure "tp1_names" dcl 150
                                                                                  in procedure "compare_mst" set ref 417 564 1233
                                                                                  1233 1236 1245 1245 1256 1262 1262 1265 1276 1278
pre_linked                2(28)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 980 980 980
pre_linked                2(28)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 980 980 980
ptr                                                    builtin function         dcl 237 ref 792 792
ret_ans                                parameter       fixed bin(17,0)          dcl 1191 set ref 1185 1198* 1211* 1211 1217 1217*
                                                                                  1219* 1220* 1220
reverse                                                builtin function         dcl 237 ref 1128
rew                             000001 constant        char(24)                 initial dcl 50 ref 935 935 941 941
ringbrack                 3(09)        based           bit(3)                   array level 4 in structure "mst1" packed unaligned
                                                                                  dcl 70 in procedure "compare_mst" ref 988 988 988
                                                                                  988 988 988 988 988 988
ringbrack                 3(09)        based           bit(3)                   array level 4 in structure "mst2" packed unaligned
                                                                                  dcl 100 in procedure "compare_mst" ref 988 988 988
                                                                                  988 988 988 988 988 988
rtrim                                                  builtin function         dcl 237 ref 726 729
saving                          000506 automatic       bit(1)                   unaligned dcl 192 set ref 258* 269* 495 569 1130
sci_ptr                         000510 automatic       pointer                  dcl 193 set ref 249* 252* 260* 267* 274* 279* 286*
                                                                                  291* 305* 310* 312* 320* 327* 334* 339* 346* 347*
                                                                                  348* 352* 424* 463* 467* 531* 535* 601* 612* 625*
                                                                                  642* 651* 657* 689* 731* 737* 744* 768* 929* 1055*
sd                              000744 automatic       fixed bin(17,0)          dcl 1154 set ref 1160* 1162* 1162 1163 1164 1165
                                                                                  1176 1181
seg_len                         000512 automatic       fixed bin(18,0)          unsigned unaligned dcl 194 set ref 669* 671* 674
                                                                                  751* 753
seg_length                      000514 automatic       fixed bin(17,0)          array dcl 195 set ref 379* 380* 503 575 822* 832*
                                                                                  852* 862* 1041 1048 1114 1114 1115 1117 1117 1135
                                                                                  1136 1142 1143
segment_1                              based           fixed bin(17,0)          array dcl 129 set ref 1117 1117 1135* 1135 1136
segment_2                              based           fixed bin(17,0)          array dcl 130 set ref 1142* 1142 1143
segment_control_word                   based           structure                level 3 in structure "mst1" dcl 70 in procedure
                                                                                  "compare_mst"
segment_control_word     27            based           structure                level 2 in structure "bootstrap_header" dcl 57
                                                                                  in procedure "compare_mst"
segment_control_word                   based           structure                level 3 in structure "mst2" dcl 100 in procedure
                                                                                  "compare_mst"
segment_length                         based           fixed bin(17,0)          level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" set ref 862 1032 1032*
segment_length                         based           fixed bin(17,0)          level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" set ref 832 1032 1032*
segment_length           27(18)        based           fixed bin(17,0)          level 3 in structure "bootstrap_header" packed
                                                                                  unaligned dcl 57 in procedure "compare_mst" ref
                                                                                  822 852
segment_name                    000516 automatic       char(32)                 unaligned dcl 196 set ref 382* 435 439* 461* 489
                                                                                  493* 496 529* 531 535 565 567* 570 584* 821* 831*
                                                                                  851* 861* 887* 1095 1097 1126* 1132 1139
segno                     3(18)        based           bit(18)                  level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 998 998 998
segno                     3(18)        based           bit(18)                  level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 998 998 998
set                             000526 automatic       fixed bin(17,0)          dcl 197 set ref 449* 450 454 516* 517 521
si                              000745 automatic       fixed bin(17,0)          dcl 1155 set ref 1163* 1164*
size                                                   builtin function         dcl 237 ref 661 661 1136 1143
sj                              000746 automatic       fixed bin(17,0)          dcl 1156 set ref 1164* 1165 1166 1170 1173 1174 1174
                                                                                  1177*
sk                              000747 automatic       fixed bin(17,0)          dcl 1157 set ref 1165* 1166 1168 1170 1171 1171 1176
                                                                                  1177
skip_1                          000527 automatic       bit(1)                   dcl 198 set ref 407* 413 414* 486* 509* 525* 541*
slte                                   based           structure                level 1 dcl 3-48 in procedure "compare_mst"
slte                      1            based           structure                level 3 in structure "mst1" dcl 70 in procedure
                                                                                  "compare_mst"
slte                      1            based           structure                level 3 in structure "mst2" dcl 100 in procedure
                                                                                  "compare_mst"
ssu_$abort_subsystem            000044 constant        entry                    external dcl 216 ref 274 286 305 312 320 327 334 339
                                                                                  424 601 625 642 651 657 689 731 737 744 768 929
                                                                                  1055
ssu_$arg_count                  000046 constant        entry                    external dcl 217 ref 260
ssu_$arg_ptr                    000050 constant        entry                    external dcl 218 ref 267 279 291 310
ssu_$destroy_invocation         000052 constant        entry                    external dcl 219 ref 612
ssu_$get_temp_segment           000054 constant        entry                    external dcl 221 ref 346 347 348 352 463 467 531 535
ssu_$standalone_invocation      000056 constant        entry                    external dcl 222 ref 252
string                                                 builtin function         dcl 237 ref 873 883 924 1018 1119 1124 1128
substr                                                 builtin function         dcl 237 ref 892 892 892 892 896 896 896 896 900 900
                                                                                  900 900 904 904 904 904 908 908 908 908 913 913
                                                                                  913 913 935 935 941 941 947 947 947 947 955 955
                                                                                  955 955 959 959 959 959 964 964 964 964 968 968
                                                                                  968 968 972 972 972 972 976 976 976 976 980 980
                                                                                  980 980 1105
sw                       13            based           structure                array level 3 in structure "tp2_names" packed
                                                                                  unaligned dcl 151 in procedure "compare_mst"
sw                       13            based           structure                array level 3 in structure "tp1_names" packed
                                                                                  unaligned dcl 150 in procedure "compare_mst"
sw                       13            based           structure                array level 3 in structure "tp_names" packed
                                                                                  unaligned dcl 1066 in procedure "read_tape"
sys_id                          000530 automatic       char(8)                  array dcl 199 set ref 396* 396* 1099*
sys_id_pickup                          based           char(8)                  dcl 132 ref 1099
temp_seg                  2(23)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 959 959 959
temp_seg                  2(23)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 959 959 959
terminate_file_                 000060 constant        entry                    external dcl 224 ref 503 575 1136 1143
tp1_names                              based           structure                array level 1 dcl 150 set ref 1233 1233 1262 1262
tp2_names                              based           structure                array level 1 dcl 151 set ref 1263 1263
tp_name                                based           structure                level 1 dcl 134
tp_name_ptr                            parameter       pointer                  dcl 1192 ref 1185 1203 1204 1209 1211 1217 1217 1219
tp_names                               based           structure                array level 1 dcl 1196 in procedure "name_search"
tp_names                               based           structure                array level 1 dcl 1066 in procedure "read_tape"
tp_names                               based           structure                array level 1 dcl 1158 in procedure "sort_names"
type                            000600 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 636 set ref 662
unique_chars_                   000062 constant        entry                    external dcl 225 ref 648 729
version                         000226 automatic       fixed bin(17,0)          array level 2 dcl 164 set ref 665* 741*
wired                     2(12)        based           bit(1)                   level 4 in structure "mst2" packed unaligned dcl 100
                                                                                  in procedure "compare_mst" ref 900 900 900
wired                     2(12)        based           bit(1)                   level 4 in structure "mst1" packed unaligned dcl 70
                                                                                  in procedure "compare_mst" ref 900 900 900

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 4-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 4-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 4-70
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 4-76
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 4-79
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 4-92
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 2-15
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 6-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 6-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 6-16
TERM_FILE_TERM                         internal static bit(3)                   initial unaligned dcl 6-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 6-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 6-13
WORDS_PER_PAGE                         internal static fixed bin(11,0)          initial dcl 4-84
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 4-89
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
iox_modes                              internal static char(24)                 initial array dcl 2-6
short_iox_modes                        internal static char(4)                  initial array dcl 2-12
slte_uns                               based           structure                level 1 dcl 3-10
sltep                                  automatic       pointer                  dcl 3-8
terminate_file_switches                based           structure                level 1 packed unaligned dcl 6-4

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEAN                           005226 constant        label                    dcl 611 ref 607
REWIND_FILE                     005622 constant        label                    dcl 655 set ref 692
REWIND_TAPE                     006521 constant        label                    dcl 735 set ref 771
SETFILE                         002171 constant        label                    dcl 285 ref 302
SETTAPE                         002055 constant        label                    dcl 273 ref 298
check_headers                   007535 constant        entry                    internal dcl 866 ref 452 519 545
check_saving                    013575 constant        label                    dcl 1130 ref 1114
check_segments                  013432 constant        entry                    internal dcl 1112 ref 383 455 522 548
check_status                    012772 constant        entry                    internal dcl 1053 ref 795 801 1042 1049
clean_up                        005154 constant        entry                    internal dcl 605 ref 250 591
compare_mst                     001457 constant        entry                    external dcl 12
d_lp_c                          014455 constant        label                    dcl 1239 ref 1234
detach_and_return               005103 constant        label                    dcl 591 ref 554 597 603 623 813 843 931
down                            014063 constant        label                    dcl 1162 ref 1181
exit_proc                       005143 constant        entry                    internal dcl 595 ref 252 252
get_data                        005241 constant        entry                    internal dcl 615 ref 661 670 671
get_in_file                     005336 constant        entry                    internal dcl 631 ref 702
get_in_medium                   006135 constant        entry                    internal dcl 697 ref 349
get_in_tape                     006223 constant        entry                    internal dcl 718 ref 704
header_discrepancy              010006 constant        label                    dcl 887 set ref 869 873 883
header_setup_1                  007127 constant        entry                    internal dcl 805 ref 518 798
header_setup_2                  007333 constant        entry                    internal dcl 836 ref 451 799
incr_j                          005062 constant        label                    dcl 587 ref 563
l_cont                          014640 constant        label                    dcl 1282 ref 1248 1253 1259 1273 1280
list_comp                       014414 constant        entry                    internal dcl 1225 ref 403
loop_cont                       004561 constant        label                    dcl 551 ref 433 443 458 473 487 510 526 542
make_x                          005110 constant        label                    dcl 600 ref 499 573
match                           014277 constant        label                    dcl 1211 ref 1203
name_search                     014202 constant        entry                    internal dcl 1185 ref 1233 1262 1263
ok                              014174 constant        label                    dcl 1180 ref 1166
out_of_sync                     003465 constant        label                    dcl 423 ref 435 478 489 565
print_acls                      010551 constant        label                    dcl 925 ref 917
print_names                     012377 constant        label                    dcl 1019 ref 1012
read_header                     007014 constant        entry                    internal dcl 775 ref 420 476 562 1071
read_segment                    012736 constant        entry                    internal dcl 1045 ref 453 470 501 520 538 546 547
                                                                                  574
read_tape                       013025 constant        entry                    internal dcl 1059 ref 389 394
rewind_in_file                  006063 constant        entry                    internal dcl 683 ref 711
rewind_in_medium                006173 constant        entry                    internal dcl 708 ref 392 399
rewind_in_tape                  006742 constant        entry                    internal dcl 762 ref 713
segment_contents_discrepancy    013502 constant        label                    dcl 1124 ref 1119
skip_block                      012702 constant        entry                    internal dcl 1038 ref 441 507 580 583 1096
sort_names                      014056 constant        entry                    internal dcl 1149 ref 401 402
too_much                        010610 constant        label                    dcl 928 set ref 1021
try_2                           004033 constant        label                    dcl 476 ref 415
up                              014105 constant        label                    dcl 1165 ref 1178

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15312       15412   14737       15322
Length     16110   14737       100         462     353           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
compare_mst                        1324 external procedure  is an external procedure.  
on unit on line 250                  64 on unit               
exit_proc                            64 internal procedure  is assigned to an entry variable.  
clean_up                             72 internal procedure  is called by several nonquick procedures.  
get_data                                internal procedure  shares stack frame of external procedure compare_mst.  
get_in_file                             internal procedure  shares stack frame of external procedure compare_mst.  
get_in_medium                           internal procedure  shares stack frame of external procedure compare_mst.  
get_in_tape                             internal procedure  shares stack frame of external procedure compare_mst.  
read_header                             internal procedure  shares stack frame of external procedure compare_mst.  
header_setup_1                          internal procedure  shares stack frame of external procedure compare_mst.  
header_setup_2                          internal procedure  shares stack frame of external procedure compare_mst.  
check_headers                           internal procedure  shares stack frame of external procedure compare_mst.  
skip_block                              internal procedure  shares stack frame of external procedure compare_mst.  
read_segment                            internal procedure  shares stack frame of external procedure compare_mst.  
check_status                            internal procedure  shares stack frame of external procedure compare_mst.  
read_tape                               internal procedure  shares stack frame of external procedure compare_mst.  
check_segments                          internal procedure  shares stack frame of external procedure compare_mst.  
sort_names                              internal procedure  shares stack frame of external procedure compare_mst.  
name_search                             internal procedure  shares stack frame of external procedure compare_mst.  
list_comp                               internal procedure  shares stack frame of external procedure compare_mst.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
compare_mst              000100 argl                        compare_mst
                         000102 anp                         compare_mst
                         000106 argp                        compare_mst
                         000110 arg_count                   compare_mst
                         000111 argx                        compare_mst
                         000112 atd                         compare_mst
                         000212 bit_len                     compare_mst
                         000214 bits_ptr                    compare_mst
                         000216 boot_label                  compare_mst
                         000220 boot_ptr                    compare_mst
                         000224 bootstrap_sw                compare_mst
                         000226 bpi                         compare_mst
                         000262 code                        compare_mst
                         000263 collection                  compare_mst
                         000264 copy_ptr                    compare_mst
                         000266 has_acl                     compare_mst
                         000270 has_branch                  compare_mst
                         000272 have_sysid                  compare_mst
                         000273 i                           compare_mst
                         000274 in_den                      compare_mst
                         000276 in_file_name                compare_mst
                         000422 in_tape_name                compare_mst
                         000442 iocb_ptr                    compare_mst
                         000446 j                           compare_mst
                         000447 k                           compare_mst
                         000450 l1_index                    compare_mst
                         000451 l2_index                    compare_mst
                         000452 master_copy                 compare_mst
                         000454 mst_ptr                     compare_mst
                         000460 mst_ptr_hold                compare_mst
                         000464 n_acls                      compare_mst
                         000466 n_names                     compare_mst
                         000470 name_count                  compare_mst
                         000472 name_len                    compare_mst
                         000473 nelemt                      compare_mst
                         000474 np                          compare_mst
                         000500 optl                        compare_mst
                         000502 optp                        compare_mst
                         000504 path_length                 compare_mst
                         000506 saving                      compare_mst
                         000510 sci_ptr                     compare_mst
                         000512 seg_len                     compare_mst
                         000514 seg_length                  compare_mst
                         000516 segment_name                compare_mst
                         000526 set                         compare_mst
                         000527 skip_1                      compare_mst
                         000530 sys_id                      compare_mst
                         000542 boot_program_info           compare_mst
                         000600 control_word                get_in_file
                         000706 i                           read_tape
                         000707 last_collection_mark        read_tape
                         000710 name_index                  read_tape
                         000730 hold_info                   sort_names
                         000744 sd                          sort_names
                         000745 si                          sort_names
                         000746 sj                          sort_names
                         000747 sk                          sort_names
                         000760 low_index                   name_search
                         000761 high_index                  name_search
                         000774 add_count                   list_comp
                         000775 del_count                   list_comp
                         000776 offset_1                    list_comp
                         000777 offset_2                    list_comp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           bound_ck_signal     mpfx2               enable_op
shorten_stack       ext_entry           int_entry           reverse_bs          set_bits_eis        index_bits_eis
index_bs_1_eis      any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      cu_$arg_list_ptr              get_shortest_path_
get_wdir_                     initiate_file_$create         ioa_                          iox_$attach_name
iox_$close                    iox_$control                  iox_$detach_iocb              iox_$get_chars
iox_$open                     parse_tape_reel_name_         ssu_$abort_subsystem          ssu_$arg_count
ssu_$arg_ptr                  ssu_$destroy_invocation       ssu_$get_temp_segment         ssu_$standalone_invocation
terminate_file_               unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
compare_mst_severity_         error_table_$bad_arg          error_table_$badopt           error_table_$end_of_info
error_table_$inconsistent     error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 001456       243 001464       244 001466       245 001470       246 001503       247 001517       248 001533
    249 001547       250 001551       252 001573       254 001650       256 001703       257 001714       258 001715
    260 001716       262 001727       263 001760       264 001771       266 001773       267 002003       268 002020
    269 002034       271 002043       272 002053       273 002055       274 002071       278 002130       279 002131
    280 002146       282 002156       283 002157       284 002167       285 002171       286 002205       290 002244
    291 002245       292 002262       294 002272       295 002274       296 002275       297 002305       298 002307
    300 002310       301 002320       302 002322       304 002323       305 002333       309 002372       310 002373
    311 002410       312 002426       317 002473       319 002504       320 002505       326 002547       327 002550
    329 002574       330 002575       332 002621       334 002645       336 002671       338 002673       339 002703
    343 002754       345 002756       346 002765       347 003011       348 003035       349 003064       350 003066
    351 003070       352 003074       353 003116       355 003120       357 003136       358 003147       361 003173
    362 003201       363 003202       364 003204       365 003217       368 003243       369 003251       370 003252
    372 003256       376 003302       377 003310       379 003311       380 003312       381 003314       382 003331
    383 003334       384 003335       389 003341       392 003343       394 003345       396 003347       399 003401
    401 003403       402 003405       403 003407       405 003410       406 003420       407 003423       411 003424
    412 003434       413 003440       414 003442       415 003443       417 003444       420 003451       421 003453
    423 003465       424 003473       426 003517       428 003520       429 003523       430 003547       432 003555
    433 003556       434 003557       435 003560       438 003570       439 003577       440 003620       441 003626
    442 003630       443 003631       447 003632       449 003637       450 003640       451 003647       452 003650
    453 003651       454 003653       455 003662       456 003663       457 003666       458 003667       461 003670
    462 003711       463 003717       465 003746       466 003753       467 003770       469 004015       470 004024
    471 004026       472 004031       473 004032       476 004033       478 004035       481 004046       482 004051
    483 004075       485 004103       486 004104       487 004106       489 004107       492 004117       493 004126
    494 004150       495 004156       496 004160       499 004245       500 004255       501 004261       502 004263
    503 004266       506 004325       507 004326       508 004330       509 004331       510 004333       514 004334
    516 004341       517 004342       518 004351       519 004352       520 004353       521 004355       522 004364
    523 004365       524 004370       525 004371       526 004373       529 004374       530 004415       531 004423
    533 004456       534 004463       535 004500       537 004531       538 004540       539 004542       540 004545
    541 004546       542 004550       545 004551       546 004552       547 004554       548 004556       549 004557
    550 004560       551 004561       554 004562       557 004574       559 004576       560 004603       561 004605
    562 004612       563 004614       564 004617       565 004627       566 004635       567 004640       568 004662
    569 004670       570 004672       573 004754       574 004762       575 004764       578 005020       579 005024
    580 005025       581 005027       583 005030       584 005032       585 005054       587 005062       588 005063
    589 005064       591 005103       593 005107       600 005110       601 005116       603 005141       595 005142
    597 005150       605 005153       606 005161       607 005172       609 005200       610 005212       611 005226
    612 005231       613 005240       615 005241       621 005243       623 005277       624 005303       625 005305
    628 005335       631 005336       640 005340       642 005363       646 005423       648 005443       651 005564
    655 005622       657 005644       661 005701       662 005720       665 005724       667 005732       668 005735
    669 005741       670 005751       671 005767       673 006004       674 006014       675 006017       677 006020
    678 006023       679 006037       681 006062       683 006063       686 006065       687 006101       688 006103
    689 006111       692 006134       697 006135       702 006137       704 006155       706 006172       708 006173
    711 006175       713 006214       716 006222       718 006223       725 006225       726 006244       729 006335
    731 006463       735 006521       737 006543       741 006600       742 006606       744 006646       749 006703
    750 006713       751 006716       753 006722       755 006735       757 006736       758 006737       760 006741
    762 006742       765 006744       766 006760       767 006762       768 006770       771 007013       775 007014
    786 007016       787 007042       788 007044       789 007053       790 007055       792 007056       795 007106
    796 007111       798 007113       799 007120       800 007121       801 007122       803 007126       805 007127
    807 007130       809 007135       810 007137       811 007142       812 007156       813 007164       815 007165
    816 007167       817 007170       818 007172       819 007173       820 007175       821 007176       822 007201
    823 007207       825 007210       826 007220       827 007224       828 007244       829 007245       830 007274
    831 007275       832 007305       834 007332       836 007333       838 007334       839 007341       840 007343
    841 007346       842 007362       843 007370       845 007371       846 007373       847 007374       848 007376
    849 007377       850 007401       851 007402       852 007405       853 007413       855 007414       856 007424
    857 007430       858 007450       859 007451       860 007500       861 007501       862 007506       864 007534
    866 007535       869 007536       871 007547       872 007551       873 007576       876 007611       877 007621
    878 007670       879 007672       880 007703       881 007752       882 007754       883 010000       885 010005
    887 010006       889 010027       892 010035       896 010103       900 010156       904 010231       908 010304
    913 010357       917 010435       920 010445       921 010450       922 010474       923 010520       924 010544
    925 010551       927 010577       928 010610       929 010616       931 010642       933 010643       934 010660
    935 010671       938 010767       939 010771       940 011006       941 011017       944 011115       947 011117
    951 011175       955 011273       959 011346       964 011421       968 011474       972 011547       976 011622
    980 011675       984 011750       988 012015       998 012145      1002 012211      1006 012260      1011 012324
   1012 012330      1014 012333      1015 012336      1016 012342      1017 012346      1018 012372      1019 012377
   1021 012425      1022 012436      1023 012453      1024 012463      1025 012511      1026 012513      1027 012530
   1028 012541      1029 012567      1032 012571      1036 012701      1038 012702      1041 012704      1042 012732
   1043 012735      1045 012736      1048 012740      1049 012766      1051 012771      1053 012772      1054 012773
   1055 013001      1057 013024      1059 013025      1068 013027      1069 013030      1070 013033      1071 013040
   1072 013051      1073 013053      1074 013061      1075 013072      1076 013100      1077 013106      1078 013110
   1080 013121      1081 013124      1082 013127      1084 013137      1085 013156      1086 013171      1087 013173
   1089 013175      1092 013330      1093 013334      1095 013335      1096 013342      1097 013350      1098 013354
   1099 013356      1103 013367      1105 013370      1106 013404      1107 013423      1109 013431      1112 013432
   1114 013433      1115 013440      1117 013441      1119 013474      1121 013501      1124 013502      1126 013510
   1127 013534      1128 013542      1129 013555      1130 013575      1132 013577      1134 013660      1135 013665
   1136 013676      1139 013726      1141 014007      1142 014014      1143 014025      1146 014055      1149 014056
   1160 014060      1162 014063      1163 014070      1164 014103      1165 014105      1166 014110      1168 014133
   1170 014137      1171 014144      1173 014151      1174 014161      1176 014167      1177 014172      1178 014173
   1180 014174      1181 014176      1183 014201      1185 014202      1198 014204      1199 014205      1200 014207
   1201 014212      1202 014215      1203 014220      1204 014236      1205 014243      1206 014246      1207 014247
   1208 014252      1209 014260      1210 014275      1211 014277      1217 014327      1219 014352      1220 014412
   1222 014413      1225 014414      1232 014415      1233 014425      1234 014437      1236 014441      1237 014450
   1239 014455      1241 014457      1242 014462      1244 014464      1245 014474      1247 014507      1248 014510
   1250 014511      1252 014524      1253 014525      1256 014526      1257 014536      1258 014537      1259 014540
   1262 014541      1263 014545      1265 014556      1266 014573      1268 014610      1269 014614      1270 014616
   1271 014621      1272 014624      1273 014625      1276 014626      1277 014630      1278 014633      1279 014636
   1280 014637      1283 014640


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
