	COMPILATION LISTING OF SEGMENT heals_report
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/04/87  1625.1 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* heals_report is the command program for
        7*   the generation of heals reports.  Calls are made to specific
        8*   report generators depending upon the requested reports */
        9 /* Coded by A. Downing March 1976,
       10*   modified by A. Downing 10/76 for release mr5.0 */
       11 /* Modified by A. Downing July 1977 for MR6 */
       12 
       13 heals_report: hr: proc;
       14 dcl  upper_case char (26) int static init
       15     ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
       16 dcl  lower_case char (26) int static init
       17     ("abcdefghijklmnopqrstuvwxyz");
       18 dcl  numbers char (10) int static init
       19     ("1234567890");
       20 dcl  other_chars char (21) int static init
       21     (" ,.<>#;:*+-_/?!$%'()&");
       22 dcl  hcs_$initiate entry (char (*), char (*), char (*),
       23      fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       24 dcl  heals_io_reports_ entry (ptr, fixed bin (35));
       25 dcl  heals_cpu_reports_ entry (ptr, fixed bin (35));
       26 dcl  heals_mos_edac_reports_ entry (ptr, fixed bin (35));
       27 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
       28 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
       29 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       30 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
       31 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       32 dcl  iox_$close entry (ptr, fixed bin (35));
       33 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
       34 dcl  delete_$path entry
       35     (char (*), char (*), bit (6), char (*), fixed bin (35));
       36 dcl  get_pdir_ entry returns (char (168));
       37 dcl  get_wdir_ entry returns (char (168));
       38 dcl  command_query_ entry options (variable);
       39 dcl (com_err_, ioa_) entry options (variable);
       40 dcl  date_time_ entry (fixed bin (71), char (*));
       41 dcl  clock_ entry returns (fixed bin (71));
       42 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
       43 dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
       44 dcl  cu_$arg_list_ptr entry returns (ptr);
       45 dcl  cu_$arg_count entry returns (fixed bin);
       46 dcl  report_file char (168) aligned init
       47     (before (get_wdir_ (), " ") || ">heals_reports");
       48 dcl  buffer char (1024) aligned;
       49 dcl  rec_len fixed bin (21);
       50 dcl (ip, whoptr) ptr init (null ());
       51 dcl  qip ptr;
       52 dcl 1 query_info aligned,
       53     2 version fixed bin init (1),
       54     2 yes_or_no_sw bit (1) unal init ("1"b),		/* Require "yes" or "no" answer. */
       55     2 suppress_name_sw bit (1) unal init ("0"b),		/* Print name with question. */
       56     2 status_code fixed bin (35),			/* Set to code of error prompting question. */
       57     2 query_code fixed bin (35) init (0);
       58 dcl  answer char (32) init ("");
       59 dcl  i fixed bin;
       60 dcl  code fixed bin (35);
       61 dcl  log_path char (168) ext static aligned init (">system_control_1>heals_dir>heals_log");
       62 dcl  error_table_$noentry ext static fixed bin (35);
       63 dcl (error_table_$not_attached, error_table_$not_open) ext static fixed bin (35);
       64 dcl  error_table_$not_closed ext static fixed bin (35);
       65 dcl  error_table_$end_of_info ext static fixed bin (35);
       66 dcl  error_table_$badopt ext static fixed bin (35);
       67 dcl  error_table_$noarg ext static fixed bin (35);
       68 dcl  one_day fixed bin (71);
       69 dcl  io_data bit (1) unal defined heals_arg_info.info_selection pos (1);
       70 dcl  mpc_data bit (1) unal defined heals_arg_info.info_selection pos (2);
       71 dcl  cpu_data bit (1) unal defined heals_arg_info.info_selection pos (3);
       72 dcl  mos_edac_data bit (1) unal defined heals_arg_info.info_selection pos (4);
       73 dcl  sorted_io_data bit (1) unal defined heals_arg_info.info_selection pos (5);
       74 dcl  disk_data bit (1) unal defined heals_arg_info.info_selection pos (6);
       75 dcl  bulk_data bit (1) unal defined heals_arg_info.info_selection pos (7);
       76 dcl  media_data bit (1) unal defined heals_arg_info.info_selection pos (8);
       77 dcl (addr, before, null, verify) builtin;
       78 dcl  cleanup condition;
       79 dcl  record_quota_overflow condition;
       80 
       81 	if cu_$arg_count () < 1 then do;
       82 	  call com_err_ (error_table_$noarg, "heals_report",
       83 	    "
       84 Usage: heals_report REPORT_NAME -CONTROL_ARGS-");
       85 	  return;
       86 	end;
       87 
       88 	code = 0;
       89 	heals_message_p = null ();
       90 	heals_state_p = null ();
       91 	heals_message_p = addr (buffer);
       92 	qip = addr (query_info);
       93 	heals_arg_info.heals_log_path_name = log_path;
       94 	i = index (reverse (heals_log_path_name), ">");
       95 	i = length (heals_log_path_name) - i ;
       96 	call hcs_$initiate
       97 	  (substr (heals_log_path_name, 1, i), "heals_log_info", "", 0, 0, heals_state_p, code);
       98 	if heals_state_p = null () then do;
       99 	  call com_err_ (code, "heals_report", "could not initiate heals_log_info");
      100 	  return;
      101 	end;
      102 	one_day = 24 * 60 * 60 * 1000000;		/* one day of micro-seconds */
      103 	heals_arg_info.iocbp = null ();
      104 	heals_arg_info.report_iocbp = null ();
      105 	heals_arg_info.to_time = clock_ ();
      106 	heals_arg_info.from_time = heals_arg_info.to_time - one_day;
      107 	heals_arg_info.from_seq = 0;
      108 	heals_arg_info.to_seq = heals_state.last_message_seq_num;
      109 	heals_arg_info.info_selection = "0"b;		/* init off */
      110 	err_nb = 0;
      111 	report_name = "";
      112 	call heals_arg_parser_ (cu_$arg_list_ptr (), cu_$arg_count (), code);
      113 	if code = 0 then do;			/* try to generate a report */
      114 	  call hcs_$initiate
      115 	    (">sc1", "whotab", "", 0, 0, whoptr, code);
      116 	  heals_arg_info.system_id =
      117 	    before (whoptr -> whotab.sysid, " ");
      118 	  call hcs_$initiate (">sc1", "installation_parms", "",
      119 	    0, 0, ip, code);
      120 	  heals_arg_info.installation_id =
      121 	    before (ip -> installation_parms.installation_id, " ");
      122 	  if verify (heals_arg_info.installation_id,
      123 	  lower_case || upper_case || numbers || other_chars)
      124 	  > 0 then
      125 	    heals_arg_info.installation_id = "";
      126 	  on cleanup call clean_up;
      127 	  call iox_$attach_ioname
      128 	    ("heals_report_stream", report_iocbp, "vfile_ " ||
      129 	    before (report_file, " ") || " -extend", code);
      130 	  if code ^= 0 then do;
      131 	    call com_err_ (code, "heals_report", "could not attach to the report file.");
      132 	    call clean_up;
      133 	    return;
      134 	  end;
      135 	  else call iox_$open (report_iocbp, 2 /* stream_output */, "0"b, code);
      136 	  if code ^= 0 then do;
      137 	    call com_err_ (code, "heals_report", "could not open the report file.");
      138 	    call clean_up;
      139 	    return;
      140 	  end;
      141 	  call iox_$attach_ioname ("heals_io", heals_arg_info.iocbp,
      142 	    "vfile_ " ||
      143 	    before (heals_arg_info.heals_log_path_name, " "), code);
      144 	  if code ^= 0 then do;
      145 	    call com_err_ (code, "heals_report", "could not attach to ^a.",
      146 	      heals_arg_info.heals_log_path_name);
      147 	    call clean_up;
      148 	    return;
      149 	  end;
      150 	  call iox_$open (heals_arg_info.iocbp, 8 /* keyed_seq in */, "0"b, code);
      151 	  if code ^= 0 then do;
      152 	    call com_err_ (code, "heals_report",
      153 	      "unable to open ^a.", heals_arg_info.heals_log_path_name);
      154 	    call clean_up;
      155 	    return;
      156 	  end;
      157 pos_at_beginning:
      158 	  if ^(io_data | sorted_io_data | media_data | cpu_data | mos_edac_data)
      159 	  then go to done;				/* reports all generated */
      160 	  on record_quota_overflow begin;
      161 	    call com_err_ (0, "heals_report",
      162 	      "There is insufficient quota to produce the specified reports.");
      163 	    call clean_up;
      164 	    go to done;
      165 	  end;
      166 	  if heals_arg_info.iocbp -> iocb.attach_descrip_ptr ^= null () then
      167 	    if heals_arg_info.iocbp -> iocb.open_descrip_ptr = null () then do;
      168 	      call iox_$open (heals_arg_info.iocbp, 8 /* keyed seq in */, "0"b, 0);
      169 	      if code ^= 0 then
      170 	        if code ^= error_table_$not_attached &
      171 	        code ^= error_table_$not_closed then go to pos_error;
      172 	        else;
      173 	      else;
      174 	    end;
      175 	  call iox_$position (heals_arg_info.iocbp, -1, 0, code);
      176 	  call iox_$read_record (heals_arg_info.iocbp,
      177 	    heals_message_p, length (buffer), rec_len, code);
      178 	  if code ^= 0 then do;
      179 pos_error:    call com_err_ (code, "heals_report",
      180 	      "error while positioning to proper record in heals_log.");
      181 	    call clean_up;
      182 	    return;
      183 	  end;
      184 	  do while ((heals_message.time < heals_arg_info.from_time) &
      185 	      (heals_message.time < heals_arg_info.to_time));
      186 	    call iox_$read_record (heals_arg_info.iocbp,
      187 	      heals_message_p, length (buffer), rec_len, code);
      188 	    if code ^= 0 then
      189 	      if code ^= error_table_$end_of_info then go to pos_error;
      190 	      else go to at_proper_record;
      191 	    else;
      192 	  end;					/* end of while loop */
      193 at_proper_record:
      194 	  if heals_message.time ^= heals_arg_info.from_time then do;
      195 	    call iox_$position (heals_arg_info.iocbp, 0, -1, code);
      196 	    if code ^= 0 then go to pos_error;
      197 	  end;
      198 	  if io_data then do;
      199 	    report_name = "io_error";
      200 	    call heals_io_reports_ (addr (heals_arg_info), code);
      201 	    if code ^= 0 then do;			/* something went wrong */
      202 	      call com_err_
      203 	        (code, "heals_report", "abnormal termination of ^a report generator.", report_name);
      204 	      if heals_arg_info.err_nb > 0 then
      205 	        call com_err_ (0, "heals_report",
      206 	        "heals internal error #^d was returned by the ^a report generator,
      207 contact Multics heals programming team for instructions.",
      208 	        heals_arg_info.err_nb, report_name);
      209 	      call clean_up;
      210 	      return;
      211 	    end;
      212 	    if heals_arg_info.err_nb = 0 then
      213 	      call ioa_
      214 	      ("^v(^4xio_error report generated^/^)^v(^4xsorted_io_error report generated^/^)^v(^4xmedia_error report generated^/^)",
      215 	      bin (io_data, 1, 0), bin (sorted_io_data, 1, 0), bin (media_data, 1, 0));
      216 	    else call ioa_ ("^a report's may be incomplete.", report_name);
      217 	    io_data, sorted_io_data, media_data = "0"b;
      218 	    go to pos_at_beginning;
      219 	  end;
      220 	  if sorted_io_data then do;
      221 	    report_name = "sorted_io_error";
      222 	    call heals_io_reports_ (addr (heals_arg_info), code);
      223 	    if code ^= 0 then do;			/* something went wrong */
      224 	      call com_err_
      225 	        (code, "heals_report", "abnormal termination of ^a report generator.", report_name);
      226 	      if heals_arg_info.err_nb > 0 then
      227 	        call com_err_ (0, "heals_report",
      228 	        "heals internal error #^d was returned by the ^a report generator,
      229 contact Multics heals programming team for instructions.",
      230 	        heals_arg_info.err_nb, report_name);
      231 	      call clean_up;
      232 	      return;
      233 	    end;
      234 	    if heals_arg_info.err_nb = 0 then
      235 	      call ioa_
      236 	      ("^v(^4xio_error report generated^/^)^v(^4xsorted_io_error report generated^/^)^v(^4xmedia_error report generated^/^)",
      237 	      bin (io_data, 1, 0), bin (sorted_io_data, 1, 0), bin (media_data, 1, 0));
      238 	    else call ioa_ ("^a report may be incomplete.", report_name);
      239 	    sorted_io_data, media_data = "0"b;		/* report generated */
      240 	    go to pos_at_beginning;
      241 	  end;
      242 	  if media_data then do;
      243 	    report_name = "media_error";
      244 	    call heals_io_reports_ (addr (heals_arg_info), code);
      245 	    if code ^= 0 then do;			/* something went wrong */
      246 	      call com_err_
      247 	        (code, "heals_report", "abnormal termination of ^a report generator.", report_name);
      248 	      if heals_arg_info.err_nb > 0 then
      249 	        call com_err_ (0, "heals_report",
      250 	        "heals internal error #^d was returned by the ^a report generator,
      251 contact Multics heals programming team for instructions.",
      252 	        heals_arg_info.err_nb, report_name);
      253 	      call clean_up;
      254 	      return;
      255 	    end;
      256 	    if heals_arg_info.err_nb = 0 then
      257 	      call ioa_
      258 	      ("^v(^4xio_error report generated^/^)^v(^4xsorted_io_error report generated^/^)^v(^4xmedia_error report generated^/^)",
      259 	      bin (io_data, 1, 0), bin (sorted_io_data, 1, 0), bin (media_data, 1, 0));
      260 	    else call ioa_ ("^a report may be incomplete.", report_name);
      261 	    media_data = "0"b;			/* report generated */
      262 	    go to pos_at_beginning;
      263 	  end;
      264 	  if cpu_data then do;
      265 	    report_name = "cpu_error";
      266 	    call heals_cpu_reports_ (addr (heals_arg_info), code);
      267 	    if code ^= 0 then do;			/* something went wrong */
      268 	      call com_err_
      269 	        (code, "heals_report", "abnormal termination of ^a report generator.", report_name);
      270 	      if heals_arg_info.err_nb > 0 then
      271 	        call com_err_ (0, "heals_report",
      272 	        "heals internal error #^d was returned by the ^a report generator,
      273 contact Multics heals programming team for instructions.",
      274 	        heals_arg_info.err_nb, report_name);
      275 	      call clean_up;
      276 	      return;
      277 	    end;
      278 	    cpu_data = "0"b;			/* report generated */
      279 	    if heals_arg_info.err_nb = 0 then
      280 	      call ioa_ ("^4x^a report generated.", report_name);
      281 	    else call ioa_ ("^a report may be incomplete.", report_name);
      282 	    go to pos_at_beginning;
      283 	  end;
      284 	  if mos_edac_data then do;
      285 	    report_name = "mos_edac_error";
      286 	    call heals_mos_edac_reports_ (addr (heals_arg_info), code);
      287 	    if code ^= 0 then do;			/* something went wrong */
      288 	      call com_err_
      289 	        (code, "heals_report", "abnormal termination of ^a report generator.", report_name);
      290 	      if heals_arg_info.err_nb > 0 then
      291 	        call com_err_ (0, "heals_report",
      292 	        "heals internal error #^d was returned by the ^a report generator,
      293 contact Multics heals programming team for instructions.",
      294 	        heals_arg_info.err_nb, report_name);
      295 	      call clean_up;
      296 	      return;
      297 	    end;
      298 	    mos_edac_data = "0"b;			/* report generated */
      299 	    if heals_arg_info.err_nb = 0 then
      300 	      call ioa_ ("^4x^a report generated.", report_name);
      301 	    else call ioa_ ("^a report may be incomplete.", report_name);
      302 	    go to pos_at_beginning;
      303 	  end;
      304 	  if heals_arg_info.err_nb > 0 then do;		/* heals private error */
      305 	    call com_err_ (0, "heals_report",
      306 	      "heals internal error #^d was returned by the ^a report generator,
      307 contact Multics heals programming team for instructions.",
      308 	      heals_arg_info.err_nb, report_name);
      309 	    go to pos_at_beginning;
      310 	  end;
      311 else done:
      312 	  if heals_arg_info.iocbp ^= null () then do;
      313 	    call iox_$close (heals_arg_info.iocbp, code);
      314 	    call iox_$detach_iocb (heals_arg_info.iocbp, code);
      315 	    heals_arg_info.iocbp = null ();
      316 	  end;
      317 	  if heals_arg_info.report_iocbp ^= null () then do;
      318 	    call iox_$close (heals_arg_info.report_iocbp, code);
      319 	    call iox_$detach_iocb (heals_arg_info.report_iocbp, code);
      320 	    heals_arg_info.report_iocbp = null ();
      321 	  end;
      322 	end;
      323 	else do;
      324 	  call com_err_ (0, "heals_report",
      325 	    "no reports generated");
      326 	  return;
      327 	end;					/* end of argument parsing error */
      328 	return;
      329 
      330 /*  */
      331 heals_arg_parser_: proc (ap, ac, code);
      332 dcl  ap ptr;					/* ptr to arg list */
      333 dcl  ac fixed bin;					/* arg count */
      334 dcl  code fixed bin (35);				/* error code */
      335 dcl  from bit (1) init ("0"b);
      336 dcl  arg char (arg_len) based (argp);
      337 dcl  argp ptr;					/* ptr to specific arg */
      338 dcl  arg_len fixed bin;				/* length of specific arg */
      339 dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
      340 dcl  i fixed bin;
      341 
      342 	  i = 1;
      343 	  call cu_$arg_ptr_rel (1, argp, arg_len, code, ap);
      344 	  if code ^= 0 then do;
      345 	    call com_err_ (code, "heals_arg_parser_", "could not obtain report name.");
      346 	    return;
      347 	  end;
      348 	  do while (code = 0 & substr (arg, 1, 1) ^= "-");
      349 	    if arg = "io_error" then io_data = "1"b;
      350 	    else if arg = "sorted_io_error" then sorted_io_data = "1"b;
      351 	    else if arg = "media_error" | arg = "media_io_error" then
      352 	      media_data = "1"b;
      353 	    else if arg = "cpu_error" then cpu_data = "1"b;
      354 	    else if arg = "mos_edac_error" then mos_edac_data = "1"b;
      355 	    else if arg = "disk_error" then disk_data = "1"b;
      356 	    else if arg = "bulk_error" then bulk_data = "1"b;
      357 	    else do;
      358 	      call com_err_ (0, "heals_arg_parser_", "report ^a is not available.", arg);
      359 	      code = error_table_$badopt;
      360 	      return;
      361 	    end;
      362 	    i = i + 1;
      363 	    call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      364 	  end;
      365 	  if i > 1 then code = 0;
      366 	  do while (i <= ac);
      367 	    call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      368 	    if code ^= 0 then do;
      369 	      call com_err_ (code, "heals_arg_parser_", "error while parsing arguments.");
      370 	      return;
      371 	    end;
      372 	    i = i + 1;				/* increment arg index */
      373 	    if arg = "-from" | arg = "-fm" then do;	/* from time */
      374 	      call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      375 	      if code ^= 0 then do;
      376 	        call com_err_ (code, "heals_arg_parser_", "could not obtain beginning time.");
      377 	        return;
      378 	      end;
      379 	      i = i + 1;
      380 	      call convert_date_to_binary_ (arg, heals_arg_info.from_time, code);
      381 	      if code ^= 0 then do;
      382 	        call com_err_ (code, "heals_arg_parser_", "error while obtaining beginning time.");
      383 	        return;
      384 	      end;
      385 	      from = "1"b;
      386 	    end;
      387 	    else if arg = "-from_seq" | arg = "-fm_seq" then do; /* from seq */
      388 	      call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      389 	      if code ^= 0 then do;
      390 	        call com_err_ (code, "heals_arg_parser_", "could not obtain beginning seq.");
      391 	        return;
      392 	      end;
      393 	      heals_arg_info.from_seq = convert (from_seq, arg);
      394 	      i = i + 1;
      395 	      from = "1"b;
      396 	    end;
      397 	    else if arg = "-to" then do;		/* to time */
      398 	      call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      399 	      if code ^= 0 then do;
      400 	        call com_err_ (code, "heals_arg_parser_", "could not obtain termination time.");
      401 	        return;
      402 	      end;
      403 	      i = i + 1;
      404 	      call convert_date_to_binary_ (arg, heals_arg_info.to_time, code);
      405 	      if code ^= 0 then do;
      406 	        call com_err_ (code, "heals_arg_parser_", "error while obtaining termination time.");
      407 	        return;
      408 	      end;
      409 	    end;
      410 	    else if arg = "-to_seq" then do;		/* to seq */
      411 	      call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      412 	      if code ^= 0 then do;
      413 	        call com_err_ (code, "heals_arg_parser_", "could not obtain beginning seq.");
      414 	        return;
      415 	      end;
      416 	      heals_arg_info.to_seq = convert (to_seq, arg);
      417 	      i = i + 1;
      418 	    end;
      419 	    else if arg = "-dp" | arg = "-dprint" then do;
      420 						/* for now, do not implement this one */
      421 	      code = error_table_$badopt;
      422 	      call com_err_ (code, "heals_arg_parser_", "^a", arg);
      423 	      return;
      424 	    end;
      425 	    else if arg = "-of" | arg = "-output_file" then do;
      426 	      call cu_$arg_ptr_rel (i, argp, arg_len, code, ap);
      427 	      if code ^= 0 then do;
      428 	        call com_err_ (code, "heals_arg_parser_", "could not obtain report file.");
      429 	        return;
      430 	      end;
      431 	      i = i + 1;
      432 	      call expand_path_ (addr (arg), (arg_len), addr (report_file), null (), code);
      433 	      if code ^= 0 then do;
      434 	        call com_err_ ("heals_arg_partser_", "^a", arg);
      435 	        return;
      436 	      end;
      437 	    end;
      438 	    else if arg = "-a" | arg = "-all" then do;
      439 	      io_data, media_data, sorted_io_data, cpu_data,
      440 	        mos_edac_data = "1"b;
      441 	    end;
      442 	    else do;				/* not a valid control arg */
      443 	      code = error_table_$badopt ;
      444 	      call com_err_ (code, "heals_arg_parser_", "^a", arg);
      445 	      return;
      446 	    end;
      447 	  end;
      448 	  if ^from then
      449 	    heals_arg_info.from_time = heals_arg_info.to_time - one_day;
      450 	  return;
      451 	end heals_arg_parser_;
      452 clean_up:	proc;
      453 	  if report_iocbp ^= null () then do;
      454 	    call iox_$close (report_iocbp, code);
      455 	    call iox_$detach_iocb (report_iocbp, code);
      456 	    report_iocbp = null ();
      457 	  end;
      458 	  if heals_arg_info.iocbp ^= null () then do;
      459 	    call iox_$close (heals_arg_info.iocbp, code);
      460 	    call iox_$detach_iocb (heals_arg_info.iocbp, code);
      461 	    heals_arg_info.iocbp = null ();
      462 	  end;
      463 	  call command_query_ (qip, answer, "heals_report",
      464 	    "The report file may be incomplete due to premature termination,
      465 do you wish to delete it?");
      466 	  if substr (answer, 1, 3) = "yes" then do;
      467 	    call delete_$path (reverse (after (reverse (report_file), ">")),
      468 	      reverse (before (reverse (report_file), ">")),
      469 	      "111111"b, "heals_report", code);
      470 	    if code ^= 0 then
      471 	      if code ^= error_table_$noentry then
      472 	        call com_err_ (code, "heals_report", "Did not delete heals_reports.");
      473 	      else;
      474 	    else;
      475 	  end;
      476 	  return;
      477 	end clean_up;
      478 						/* 
      479*						   include files */
  1     1 /* heals_arg_info.incl.pl1 contains the declaration
  1     2*   of the argument structure passed between heals releated utilities.
  1     3*   Created January 1976 by A. R. Downing */
  1     4 dcl 1 heals_arg_info aligned,
  1     5     2 iocbp ptr,
  1     6     2 report_iocbp ptr,
  1     7     2 err_nb fixed bin (35),
  1     8     2 info_selection bit (72) unal,
  1     9     2 report_name char (64) varying,
  1    10     2 heals_log_path_name char (168),			/* path name of the heals log */
  1    11     2 system_id char (32) varying,
  1    12     2 installation_id char (32) varying,
  1    13     2 from_seq fixed bin (35),			/* beginning seq_num */
  1    14     2 to_seq fixed bin (35),				/* ending seq_num */
  1    15     2 from_time fixed bin (71),			/* beginning of desired time period */
  1    16     2 to_time fixed bin (71);				/* end of desired time period */
  1    17 						/* end heals_arg_info. */
      480 
  2     1 /* BEGIN INCLUDE FILE ... installation_parms.incl.pl1 */
  2     2 
  2     3 /* Modified 740723 by PG to add short AIM access names */
  2     4 /* Modified Fall 1977 by T. Casey to add fatal loop and trm_ signal parameters */
  2     5 /* Modified 04/03/78 by CDT to add rcp_init_flags structure */
  2     6 /* Modified May 1978 by T. Casey to add resource timer and resource price list parameters */
  2     7 /* Modified November 1978 by T. Casey for MR7.0, to add absentee control parameters */
  2     8 /* Modified 17 September 1980 by G. Palter to add default absentee queue */
  2     9 /* Modified April 1981 by E. N. Kittlitz for chn_wakeup_error_loop, chn_wakeup_error_count */
  2    10 /* Modified June 1981 by E. N. Kittlitz for nrates/rate_structures UNCA rate_structure support.
  2    11*     Version, expand foregound_cpu_default_limit and abs_cpu_max_limit to fixed bin (35) fields.
  2    12*     nrscp & resource array moved from offset 2064 (octal) to 2400 (octal). */
  2    13 /* Modified 1984-06-19 BIM to remove obsolete fields, and add 
  2    14*		       strict_trusted_path. */
  2    15 /* Modified 1984-10-24 BIM for default_pdir_quota. */
  2    16 /* Modified 1984-12-05 BIM for require_operator_login. */
  2    17 /* Modified 1985-03-01 by E. Swenson for password flags. */
  2    18 
  2    19 
  2    20 /****^  HISTORY COMMENTS:
  2    21*  1) change(86-01-27,MSharpe), approve(87-05-25,MCR7690),
  2    22*     audit(87-03-29,GDixon), install(87-08-04,MR12.1-1056):
  2    23*     added vchn_requires_accept parameter.
  2    24*  2) change(87-02-17,GDixon), approve(87-05-25,MCR7680),
  2    25*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
  2    26*     Correct formatting problems.
  2    27*                                                   END HISTORY COMMENTS */
  2    28 
  2    29 
  2    30 /* NOTE: rate_structure.incl.pl1 uses these declarations */
  2    31 
  2    32 
  2    33 dcl 1 installation_parms based (ip) aligned,		/* describes installation parameters */
  2    34     2 part_1 like installation_parms_part_1 aligned,
  2    35     2 resource (0 refer (installation_parms.nrscp)) like installation_parms_resource_array_part aligned;
  2    36 
  2    37 dcl  installation_parms_version_1 fixed bin init (1) static internal options (constant);
  2    38 dcl  installation_parms_version_2 fixed bin init (2) static internal options (constant);
  2    39 
  2    40 dcl 1 installation_parms_part_1 based aligned,		/* Used only by installation_parms and rate_structure */
  2    41     2 installation_id char (32),			/* Name printed at dialup and in who */
  2    42     2 company char (64),				/* company name */
  2    43     2 department char (64),				/* department */
  2    44     2 companyds char (120),				/* company, double spaced */
  2    45     2 departmentds char (120),			/* dpeartment double spaced */
  2    46     2 shifttab (336) bit (3) unal,			/* half-hrs from 0000 Mon, value is shift no */
  2    47     2 cpu_price (0: 7) float bin,			/* price for cpu hour, by shift */
  2    48     2 log_base_price (0: 7) float bin,			/* price for log hour, by shift */
  2    49     2 io_ops_price (0: 7) float bin,			/* price per 1000 terminal io ops */
  2    50     2 core_price (0: 7) float bin,			/* price for core page-hour, by shift */
  2    51     2 ndevices fixed bin,				/* number of devices to charge */
  2    52     2 devtab (16),					/* Maximum 16 */
  2    53       3 device_id char (8),				/* Name of device */
  2    54       3 device_price (0: 7) float bin,			/* Price by shift */
  2    55     2 inactive_time fixed bin,			/* seconds of inactivity permitted */
  2    56     2 warning_time fixed bin,				/* seconds from warning to logout */
  2    57     2 login_time fixed bin,				/* seconds in which to complete login */
  2    58     2 acct_update fixed bin,				/* seconds between acct update */
  2    59     2 login_tries fixed bin,				/* number of login tries allowed */
  2    60     2 disk_price float bin,				/* disk rate, in $/page-sec */
  2    61     2 registration_price float bin,			/* fee per month per user */
  2    62     2 dolsign char (1),				/* "dollar sign" */
  2    63     2 abs_cpu_price (4) float bin,			/* price for absentee cpu by queue */
  2    64     2 abs_mem_price (4) float bin,			/* Absentee memory charge */
  2    65     2 iod_rec_price (4) float bin,			/* price for io daemon lines, per K, by queue */
  2    66     2 abs_timax (4) fixed bin (35),			/* Absentee TIMAX parameter */
  2    67     2 abs_cpu_default_limit (4) fixed bin (35),		/* default absentee cpu limit in seconds (changed from usec.) */
  2    68     2 syserr_log_copy_threshold fixed bin (9),		/* Threshold (in PAGES) at which the
  2    69*						   Initializer will copy the syserr_log */
  2    70     2 default_pdir_seg_quota fixed bin (17) unaligned,	/* if system and project say 0 */
  2    71     2 default_pdir_dir_quota fixed bin (17) unaligned,       /* Always used */
  2    72     2 fatal_error_loop_count fixed bin (17) unaligned,
  2    73     2 fatal_error_loop_seconds fixed bin (17) unaligned,
  2    74     2 term_real_time_seconds fixed bin (17) unaligned,
  2    75     2 term_cpu_time_seconds fixed bin (17) unaligned,
  2    76     2 rcp_init_flags like rcp_init_flags aligned,		/* one word long */
  2    77     2 rsc_timer_seconds fixed bin (17) unaligned,		/* time interval at which to check for resource availability */
  2    78     2 pad_old_fg_cpu_default_limit bit (18) unaligned,
  2    79     2 foreground_queue_position fixed bin (17) unal,	/* queue that foreground queue comes after */
  2    80     2 idle_time_constant_seconds fixed bin (17) unal,	/* how far back to maintain moving average of load */
  2    81     2 sus_cpu_time_seconds fixed bin (17) unal,		/* allow suspended process this much cpu time */
  2    82     2 sus_real_time_seconds fixed bin (17) unal,		/* and this much real time, before bumping it */
  2    83     2 foreground_cpu_default_limit fixed bin (35),	/* default cpu time limit (sec) for foreground absentee jobs */
  2    84     2 access_authorization_ceiling bit (72),		/* "System high" access authorization. */
  2    85     2 level_names (0:7) char (32),			/* Names for security levels. */
  2    86     2 category_names (18) char (32),			/* Names for security categories. */
  2    87     2 short_level_names (0:7) char (8),			/* Abbreviated level names. */
  2    88     2 short_category_names (18) char (8),		/* Abbreviated category names. */
  2    89     2 ncon fixed bin,				/* Number of config elements. */
  2    90     2 cona (51),					/* each entry is 5 words long */
  2    91       3 cpu fixed bin (5) unal,			/* Number of CPU's */
  2    92       3 shift fixed bin (5) unal,			/* Shift number */
  2    93       3 x1 fixed bin (23) unal,
  2    94       3 kmem fixed bin (17) unal,			/* Memory size */
  2    95       3 kbulk fixed bin (17) unal,			/* Bulk store size */
  2    96       3 x2 fixed bin (17) unal,
  2    97       3 maxa fixed bin (11) unal,			/* Max abs users */
  2    98       3 maxq fixed bin (5) unal,			/* Max abs q */
  2    99       3 maxu_base fixed bin (17) unal,
  2   100       3 response_high fixed bin (17) unal,
  2   101       3 response_low fixed bin (17) unal,
  2   102       3 x3 fixed bin (17) unal,
  2   103 
  2   104 /* Absentee control parameters. New for MR7.0 */
  2   105 
  2   106     2 max_abs (0:7) fixed bin (17) unal,		/* per-shift upper limit on abs_maxu */
  2   107     2 min_abs (0:7) fixed bin (17) unal,		/* per-shift lower limit on abs_maxu */
  2   108     2 pct_abs (0:7) fixed bin (17) unal,		/* abs_maxu is this pct (per-shift) of idle units */
  2   109 
  2   110     2 max_qres (0:7, 4) fixed bin (17) unal,		/* per-shift-and-queue upper limit on reserved slots */
  2   111     2 min_qres (0:7, 4) fixed bin (17) unal,		/* per-shift-and-queue lower limit on reserved slots */
  2   112     2 pct_qres (0:7, 4) fixed bin (17) unal,		/* reserved slots are these pcts of abs_maxu */
  2   113 
  2   114     2 abs_cpu_max_limit (0:7, 4) fixed bin (35),		/* per-shift-and-queue upper limit (sec) on jobs' cpu times */
  2   115 
  2   116     2 default_absentee_queue fixed binary (17) unaligned,	/* default absentee queue for ear, etc. */
  2   117 
  2   118     2 chn_wakeup_error_loop_count fixed bin (17) unaligned, /* maximum number of channel wakeups in following interval */
  2   119     2 chn_wakeup_error_loop_seconds fixed bin (17) unaligned, /* works like fatal_error_loop_count/seconds */
  2   120     2 rate_structure_number fixed bin (17) unaligned,	/* rate_structure number of this RS */
  2   121     2 version fixed bin (35),				/* must be 2 */
  2   122     2 nrates fixed bin,				/* number of rate structures */
  2   123     2 rate_structures (0:9) char (32),			/* names of rate_structures */
  2   124     2 trusted_path_login bit (1) aligned,		/* forbid logout -hold and new_proc -auth */
  2   125     2 require_operator_login bit (1) aligned,		/* just what it says */
  2   126     2 operator_inactive_time fixed bin,			/* seconds between commands --> not logged in. */
  2   127     2 validate_daemon_commands bit (1) aligned,		/* force existence and adequate access to 
  2   128*						   mcacs segments for operators */
  2   129     2 password_min_length fixed bin,			/* minimum length of passwords */
  2   130     2 password_gpw_length fixed bin,			/* length of generated passwords */
  2   131     2 password_change_interval fixed bin,		/* number of days until must change */
  2   132     2 password_expiration_interval fixed bin,		/* number of days that a password may remain unused */
  2   133     2 vchn_requires_accept bit (1) aligned,		/* "login personid -op -vchn foo" must be
  2   134*						   "accepted" by operator if personid is not 
  2   135*						   signed on system console */
  2   136     2 end_pad (219) bit (36) aligned,			/* leave plenty of pad before the variable length price list */
  2   137     2 nrscp fixed bin;				/* length of resource price array; must have offset 2400 (octal),
  2   138*						   or someone miscounted when using part of pad2 */
  2   139 
  2   140 
  2   141 /* Entries in the following array may be accessed via system_info_$resource_price.
  2   142*   This array should not be accessed directly, since its format will change in subsequent releases of Multics. */
  2   143 
  2   144 dcl 1 installation_parms_resource_array_part (0 refer (installation_parms.nrscp)) based,
  2   145       2 name char (32),
  2   146       2 price float bin;
  2   147 
  3     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  3     2 
  3     3 /* Created on 04/24/78 by Michael R. Jordan */
  3     4 /* Modified 04/10/79 by C. D. Tavares */
  3     5 
  3     6 dcl  rifp ptr;
  3     7 
  3     8 dcl 1 rcp_init_flags based (rifp),
  3     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  3    10     2 pad1 bit (2) unaligned,				/* obsolete */
  3    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  3    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  3    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  3    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  3    15 
  3    16 dcl (No_authentication initial (0),
  3    17      Nominal_authentication initial (1),
  3    18      Automatic_authentication initial (2),
  3    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  3    20 
  3    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  3    22     ("none", "nominal", "automatic", "manual");
  3    23 
  3    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  2   148 
  2   149 
  2   150 /* END INCLUDE FILE ... installation_parms.incl.pl1 */
      481 
  4     1 /* BEGIN INCLUDE FILE ... whotab.incl.pl1 */
  4     2 
  4     3 /* Modified 740723 by PG to add security info */
  4     4 /* Modified April 1976 by T. Casey to add shift and shift start and end times */
  4     5 /* Modified May 1979 by T. Casey for MR7.0a to add foreground absentee variables */
  4     6 /* Modified June 1981 by E. N. Kittlitz to add n_rate_structures. */
  4     7 /* Modified December 1981 by E. N. Kittlitz to expand header. */
  4     8 /* Modified 84-11-14  by E. A. Ranzenbach to add "session" fiedld in  place of obsolete system ID... */
  4     9 
  4    10 dcl 1 whotab based (whoptr) aligned,
  4    11     2 mxusers fixed bin,				/* max. number of users on system */
  4    12     2 n_users fixed bin,				/* current number of users */
  4    13     2 mxunits fixed bin,				/* maximun "load units" allowed */
  4    14     2 n_units fixed bin,				/* current load */
  4    15     2 timeup fixed bin (71),				/* time system was started */
  4    16     2 session char (8),				/* AS state, same as anstbl.session  */
  4    17     2 nextsd fixed bin (71),				/* time we will shutdown */
  4    18     2 until fixed bin (71),				/* projected time we start up again */
  4    19     2 lastsd fixed bin (71),				/* time of last crash or shutdown */
  4    20     2 erfno char (8),				/* if a crash, the error number */
  4    21     2 obsolete_why char (32),				/* reason for last shutdown */
  4    22     2 installation_id char (32),			/* name of installation */
  4    23     2 obsolete_message char (32),			/* message for all users */
  4    24     2 abs_event fixed bin (71),			/* event channel associated with absentee */
  4    25     2 abs_procid bit (36) aligned,			/* process to whom messages about absentee are signalled */
  4    26     2 max_abs_users fixed bin,			/* max number of absentee users */
  4    27     2 abs_users fixed bin,				/* number of absentee users logged-in */
  4    28     2 n_daemons fixed bin,				/* Number of daemon users logged in */
  4    29     2 request_channel fixed bin (71),			/* System master channel for requests to AS. */
  4    30     2 request_process_id bit (36),			/* Process ID of request dispatcher */
  4    31     2 shift fixed bin,				/* current shift (copied from anstbl, for users to see) */
  4    32     2 next_shift_change_time fixed bin (71),		/* time current shift ends */
  4    33     2 last_shift_change_time fixed bin (71),		/* time current shift started */
  4    34     2 fg_abs_users fixed bin (17) unal,			/* number of foreground absentee users */
  4    35     2 n_rate_structures fixed bin (9) unsigned unal,	/* number of rate_structures defined at bootload */
  4    36     2 pad1 bit (9) unal,
  4    37     2 pad (3) fixed bin,
  4    38     2 version fixed bin,				/* structure version */
  4    39     2 header_size fixed bin,				/* length of header in words */
  4    40     2 entry_size fixed bin,				/* length of entry in words */
  4    41 						/* laste_adjust is used only by Answering Service programs */
  4    42     2 laste_adjust fixed bin,				/* count of 32 wd blocks in hdr from header_extension_mbz1 */
  4    43     2 laste fixed bin,				/* index of last entry in use (includes laste_adjust) */
  4    44     2 freep fixed bin (18) unsigned,			/* index of first free entry. chained thru "chain" */
  4    45 
  4    46 /* whotab header extension:  The header is extended from 64 words by
  4    47*   annexing whole user entries from the 'e' array.  Each 'e' entry is 32 words
  4    48*   long. Each annexed block has its first word set to zero, indicating that no user entry is
  4    49*   present.  This allows existing programs to function with old definitions of
  4    50*   whotab.  Obviously no new header field can be more than 31 contiguous words in
  4    51*   length.  In the Answering Service, all programs using whotab must be compiled
  4    52*   with the latest version. Only lg_ctl_ uses laste_adjust. */
  4    53 
  4    54     2 header_extension_mbz1 fixed bin,			/* location 100o */
  4    55     2 n_abs (4) fixed bin,				/* number of processes from each background queue */
  4    56     2 abs_qres (4) fixed bin,				/* number of absentee positions reserved for each queue */
  4    57     2 abs_cpu_limit (4) fixed bin (35),			/* current absentee cpu limits */
  4    58     2 abs_control,					/* see absentee_user_table */
  4    59       3 mnbz bit (1) unal,				/* must not be zero */
  4    60       3 abs_maxu_auto bit (1) unal,			/* 1 if automatic */
  4    61       3 abs_maxq_auto bit (1) unal,			/* 1 if automatic */
  4    62       3 abs_qres_auto bit (1) unal,			/* 1 if automatic */
  4    63       3 abs_cpu_limit_auto bit (1) unal,		/* 1 if automatic */
  4    64       3 queue_dropped (-1:4) bit (1) unal,		/* 1 if queue dropped */
  4    65       3 abs_up bit (1) unal,				/* 1 if absentee facility is running */
  4    66       3 abs_stopped bit (1) unal,			/* 1 if absentee facility is stopped */
  4    67       3 control_pad bit (23) unal,
  4    68     2 installation_request_channel fixed bin (71),	/* IPC channel for install command */
  4    69     2 installation_request_pid bit (36),		/* installation process identifier */
  4    70     2 sysid char (32),				/* current system name */
  4    71     2 header_extension_pad1 (7) fixed bin,		/* pad to size of e element, offset 137o */
  4    72     2 header_extension_mbz2 fixed bin,			/* offset 140o */
  4    73     2 message char (124),				/* message for all users */
  4    74     2 header_extension_mbz3 fixed bin,			/* offset 200o */
  4    75     2 why char (124),				/* reason for last shutdown */
  4    76     2 e (1000),					/* offset 240o */
  4    77       3 active fixed bin,				/* nonzero means logged in */
  4    78       3 person char (28) aligned,			/* person name */
  4    79       3 project char (28),				/* project id */
  4    80       3 anon fixed bin,				/* 1 if anonymous user */
  4    81       3 padding fixed bin (71),
  4    82       3 timeon fixed bin (71),			/* time of login */
  4    83       3 units fixed bin,				/* load units */
  4    84       3 stby fixed bin,				/* 1 if stby */
  4    85       3 idcode char (4),				/* tty id code */
  4    86       3 chain fixed bin (18) unsigned,			/* chain for free list */
  4    87       3 proc_type fixed bin,				/* 1 = interactive, 2 = absentee, 3 = daemon */
  4    88       3 group char (8),				/* party-line group */
  4    89       3 fg_abs bit (1) unal,				/* "1"b if foreground absentee user */
  4    90       3 disconnected bit (1) unaligned,			/* "1"b if process is disconnected */
  4    91       3 suspended bit (1) unaligned,			/* "1"b if process is suspended */
  4    92       3 pad2 bit (33) unal,
  4    93       3 cant_bump_until fixed bin (71),			/* protected from primary bump till here */
  4    94       3 process_authorization bit (72);			/* access authorization of process */
  4    95 
  4    96 dcl  WHOTAB_VERSION_1 fixed bin init (1) static options (constant);
  4    97 
  4    98 /* END INCLUDE FILE ... whotab.incl.pl1 */
      482 
  5     1 /* begin heals_message.incl.pl1 */
  5     2 /* Produced March 1976 by A. Downing. */
  5     3 dcl 1 heals_message based (heals_message_p) aligned,
  5     4     2 tally fixed bin (35),
  5     5     2 rest_of_record aligned,
  5     6       3 seq_num fixed bin (35),			/* Sequence number of this message. */
  5     7       3 time fixed bin (71) unal,			/* Time message logged at */
  5     8       3 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  5     9       3 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  5    10       3 data_size fixed bin (11) unal,			/* Size of binary data */
  5    11       3 data_code fixed bin (11) unal,			/* format type code */
  5    12       3 pad bit (60) unal,
  5    13       3 text char (0 refer (heals_message.text_len)),	/* Text of expanded message - kept in ASCII. */
  5    14       3 data (0 refer (heals_message.data_size)) bit (36);	/* Binary data area */
  5    15 dcl  heals_message_p ptr;
  5    16 						/* end heals_message.incl.pl1 */
      483 
  6     1 /* begin heals_state.incl.pl1 */
  6     2 /* Produced March 1976 by A. Downing. */
  6     3 
  6     4 dcl 1 heals_state aligned based (heals_state_p),
  6     5     2 last_message_time fixed bin (71),
  6     6     2 last_message_seq_num fixed bin (35),
  6     7     2 busy bit (36) aligned;
  6     8 dcl  heals_state_p ptr;
  6     9 dcl  heals_log_info$ ext static fixed bin (35) aligned dim (64000);
  6    10 						/* end heals_state.incl.pl1 */
      484 
  7     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  7     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  7     3*      version number to IOX2. */
  7     4 /* format: style2 */
  7     5 
  7     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  7     7 	     2 version	      character (4) aligned,	/* IOX2 */
  7     8 	     2 name	      char (32),		/* I/O name of this block. */
  7     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  7    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  7    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  7    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  7    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  7    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  7    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  7    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  7    17 						/* open(p,mode,not_used,s) */
  7    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  7    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  7    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  7    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    24 						/* put_chars(p,bufptr,buflen,s) */
  7    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  7    26 						/* modes(p,newmode,oldmode,s) */
  7    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  7    28 						/* position(p,u1,u2,s) */
  7    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  7    30 						/* control(p,order,infptr,s) */
  7    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  7    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    34 						/* write_record(p,bufptr,buflen,s) */
  7    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  7    36 						/* rewrite_record(p,bufptr,buflen,s) */
  7    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  7    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    39 						/* seek_key(p,key,len,s) */
  7    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    41 						/* read_key(p,key,len,s) */
  7    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  7    43 						/* read_length(p,len,s) */
  7    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  7    45 						/* open_file(p,mode,desc,not_used,s) */
  7    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  7    47 						/* close_file(p,desc,s) */
  7    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  7    49 						/* detach(p,desc,s) */
  7    50 
  7    51      declare iox_$iocb_version_sentinel
  7    52 			      character (4) aligned external static;
  7    53 
  7    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      485 
      486         end heals_report;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/04/87  1540.9  heals_report.pl1                  >special_ldd>install>MR12.1-1054>heals_report.pl1
480          1    11/02/76  1752.0  heals_arg_info.incl.pl1           >ldd>include>heals_arg_info.incl.pl1
481          2    08/04/87  1140.0  installation_parms.incl.pl1       >spec>install>1056>installation_parms.incl.pl1
2-148        3    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
482          4    01/18/85  0953.2  whotab.incl.pl1                   >ldd>include>whotab.incl.pl1
483          5    10/25/77  1258.3  heals_message.incl.pl1            >ldd>include>heals_message.incl.pl1
484          6    11/10/82  1749.8  heals_state.incl.pl1              >ldd>include>heals_state.incl.pl1
485          7    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ac                                     parameter       fixed bin(17,0)          dcl 333 ref 331 366
addr                                                   builtin function         dcl 77 ref 91 92 200 200 222 222 244 244 266 266 286
                                                                                  286 432 432 432 432
answer                          000566 automatic       char(32)                 initial unaligned dcl 58 set ref 58* 463* 466
ap                                     parameter       pointer                  dcl 332 set ref 331 343* 363* 367* 374* 388* 398*
                                                                                  411* 426*
arg                                    based           char                     unaligned dcl 336 set ref 348 349 350 351 351 353
                                                                                  354 355 356 358* 373 373 380* 387 387 393 397 404*
                                                                                  410 416 419 419 422* 425 425 432 432 434* 438 438
                                                                                  444*
arg_len                         000766 automatic       fixed bin(17,0)          dcl 338 set ref 343* 348 349 350 351 351 353 354 355
                                                                                  356 358 358 363* 367* 373 373 374* 380 380 387 387
                                                                                  388* 393 397 398* 404 404 410 411* 416 419 419 422
                                                                                  422 425 425 426* 432 432 432 434 434 438 438 444
                                                                                  444
argp                            000764 automatic       pointer                  dcl 337 set ref 343* 348 349 350 351 351 353 354 355
                                                                                  356 358 363* 367* 373 373 374* 380 387 387 388*
                                                                                  393 397 398* 404 410 411* 416 419 419 422 425 425
                                                                                  426* 432 432 434 438 438 444
attach_descrip_ptr       14            based           pointer                  level 2 dcl 7-6 ref 166
before                                                 builtin function         dcl 77 ref 46 116 120 127 141 467 467
buffer                          000152 automatic       char(1024)               dcl 48 set ref 91 176 176 186 186
bulk_data                              defined         bit(1)                   unaligned dcl 75 set ref 356*
cleanup                         000602 stack reference condition                dcl 78 ref 126
clock_                          000050 constant        entry                    external dcl 41 ref 105
code                            000577 automatic       fixed bin(35,0)          dcl 60 in procedure "hr" set ref 88* 96* 99* 112*
                                                                                  113 114* 118* 127* 130 131* 135* 136 137* 141* 144
                                                                                  145* 150* 151 152* 169 169 169 175* 176* 178 179*
                                                                                  186* 188 188 195* 196 200* 201 202* 222* 223 224*
                                                                                  244* 245 246* 266* 267 268* 286* 287 288* 313*
                                                                                  314* 318* 319* 454* 455* 459* 460* 467* 470 470
                                                                                  470*
code                                   parameter       fixed bin(35,0)          dcl 334 in procedure "heals_arg_parser_" set ref 331
                                                                                  343* 344 345* 348 359* 363* 365* 367* 368 369*
                                                                                  374* 375 376* 380* 381 382* 388* 389 390* 398* 399
                                                                                  400* 404* 405 406* 411* 412 413* 421* 422* 426*
                                                                                  427 428* 432* 433 443* 444*
com_err_                        000044 constant        entry                    external dcl 39 ref 82 99 131 137 145 152 161 179
                                                                                  202 204 224 226 246 248 268 270 288 290 305 324
                                                                                  345 358 369 376 382 390 400 406 413 422 428 434
                                                                                  444 470
command_query_                  000042 constant        entry                    external dcl 38 ref 463
convert_date_to_binary_         000052 constant        entry                    external dcl 42 ref 380 404
cpu_data                               defined         bit(1)                   unaligned dcl 71 set ref 157 264 278* 353* 439*
cu_$arg_count                   000056 constant        entry                    external dcl 45 ref 81 112 112
cu_$arg_list_ptr                000054 constant        entry                    external dcl 44 ref 112 112
cu_$arg_ptr_rel                 000076 constant        entry                    external dcl 339 ref 343 363 367 374 388 398 411 426
delete_$path                    000036 constant        entry                    external dcl 34 ref 467
disk_data                              defined         bit(1)                   unaligned dcl 74 set ref 355*
err_nb                    4     000616 automatic       fixed bin(35,0)          level 2 dcl 1-4 set ref 110* 204 204* 212 226 226*
                                                                                  234 248 248* 256 270 270* 279 290 290* 299 304
                                                                                  305*
error_table_$badopt             000072 external static fixed bin(35,0)          dcl 66 ref 359 421 443
error_table_$end_of_info        000070 external static fixed bin(35,0)          dcl 65 ref 188
error_table_$noarg              000074 external static fixed bin(35,0)          dcl 67 set ref 82*
error_table_$noentry            000062 external static fixed bin(35,0)          dcl 62 ref 470
error_table_$not_attached       000064 external static fixed bin(35,0)          dcl 63 ref 169
error_table_$not_closed         000066 external static fixed bin(35,0)          dcl 64 ref 169
expand_path_                    000034 constant        entry                    external dcl 33 ref 432
from                            000762 automatic       bit(1)                   initial unaligned dcl 335 set ref 335* 385* 395* 448
from_seq                124     000616 automatic       fixed bin(35,0)          level 2 dcl 1-4 set ref 107* 393* 393
from_time               126     000616 automatic       fixed bin(71,0)          level 2 dcl 1-4 set ref 106* 184 193 380* 448*
get_wdir_                       000040 constant        entry                    external dcl 37 ref 46
hcs_$initiate                   000010 constant        entry                    external dcl 22 ref 96 114 118
heals_arg_info                  000616 automatic       structure                level 1 dcl 1-4 set ref 200 200 222 222 244 244 266
                                                                                  266 286 286
heals_cpu_reports_              000014 constant        entry                    external dcl 25 ref 266
heals_io_reports_               000012 constant        entry                    external dcl 24 ref 200 222 244
heals_log_path_name      30     000616 automatic       char(168)                level 2 dcl 1-4 set ref 93* 94 95 96 96 141 145*
                                                                                  152*
heals_message                          based           structure                level 1 dcl 5-3
heals_message_p                 000750 automatic       pointer                  dcl 5-15 set ref 89* 91* 176* 184 184 186* 193
heals_mos_edac_reports_         000016 constant        entry                    external dcl 26 ref 286
heals_state                            based           structure                level 1 dcl 6-4
heals_state_p                   000752 automatic       pointer                  dcl 6-8 set ref 90* 96* 98 108
i                               000767 automatic       fixed bin(17,0)          dcl 340 in procedure "heals_arg_parser_" set ref
                                                                                  342* 362* 362 363* 365 366 367* 372* 372 374* 379*
                                                                                  379 388* 394* 394 398* 403* 403 411* 417* 417 426*
                                                                                  431* 431
i                               000576 automatic       fixed bin(17,0)          dcl 59 in procedure "hr" set ref 94* 95* 95 96 96
info_selection            5     000616 automatic       bit(72)                  level 2 packed unaligned dcl 1-4 set ref 109* 157
                                                                                  157 157 157 157 157 157 157 157 157 198 198 212
                                                                                  212 212 212 212 212 212 212 212 212 212 212 217*
                                                                                  217 217* 217 217* 217 220 220 234 234 234 234 234
                                                                                  234 234 234 234 234 234 234 239* 239 239* 239 242
                                                                                  242 256 256 256 256 256 256 256 256 256 256 256
                                                                                  256 261* 261 264 264 278* 278 284 284 298* 298
                                                                                  349* 349 350* 350 351* 351 353* 353 354* 354 355*
                                                                                  355 356* 356 439* 439 439* 439 439* 439 439* 439
                                                                                  439* 439
installation_id         113     000616 automatic       varying char(32)         level 2 in structure "heals_arg_info" dcl 1-4
                                                                                  in procedure "hr" set ref 120* 122 122*
installation_id                        based           char(32)                 level 3 in structure "installation_parms" dcl 2-33
                                                                                  in procedure "hr" ref 120
installation_parms                     based           structure                level 1 dcl 2-33
installation_parms_part_1              based           structure                level 1 dcl 2-40
installation_parms_resource_array_part based           structure                array level 1 unaligned dcl 2-144
io_data                                defined         bit(1)                   unaligned dcl 69 set ref 157 198 212 212 217* 234
                                                                                  234 256 256 349* 439*
ioa_                            000046 constant        entry                    external dcl 39 ref 212 216 234 238 256 260 279 281
                                                                                  299 301
iocb                                   based           structure                level 1 dcl 7-6
iocbp                           000616 automatic       pointer                  level 2 dcl 1-4 set ref 103* 141* 150* 166 166 168*
                                                                                  175* 176* 186* 195* 311 313* 314* 315* 458 459*
                                                                                  460* 461*
iox_$attach_ioname              000020 constant        entry                    external dcl 27 ref 127 141
iox_$close                      000032 constant        entry                    external dcl 32 ref 313 318 454 459
iox_$detach_iocb                000022 constant        entry                    external dcl 28 ref 314 319 455 460
iox_$open                       000024 constant        entry                    external dcl 29 ref 135 150 168
iox_$position                   000026 constant        entry                    external dcl 30 ref 175 195
iox_$read_record                000030 constant        entry                    external dcl 31 ref 176 186
ip                              000554 automatic       pointer                  initial dcl 50 set ref 50* 118* 120
last_message_seq_num      2            based           fixed bin(35,0)          level 2 dcl 6-4 ref 108
log_path                        000060 external static char(168)                initial dcl 61 ref 93
lower_case                      000011 constant        char(26)                 initial unaligned dcl 16 ref 122
media_data                             defined         bit(1)                   unaligned dcl 76 set ref 157 212 212 217* 234 234
                                                                                  239* 242 256 256 261* 351* 439*
mos_edac_data                          defined         bit(1)                   unaligned dcl 72 set ref 157 284 298* 354* 439*
null                                                   builtin function         dcl 77 ref 50 50 89 90 98 103 104 166 166 311 315
                                                                                  317 320 432 432 453 456 458 461
numbers                         000006 constant        char(10)                 initial unaligned dcl 18 ref 122
one_day                         000600 automatic       fixed bin(71,0)          dcl 68 set ref 102* 106 448
open_descrip_ptr         20            based           pointer                  level 2 dcl 7-6 ref 166
other_chars                     000000 constant        char(21)                 initial unaligned dcl 20 ref 122
part_1                                 based           structure                level 2 dcl 2-33
qip                             000560 automatic       pointer                  dcl 51 set ref 92* 463*
query_code                3     000562 automatic       fixed bin(35,0)          initial level 2 dcl 52 set ref 52*
query_info                      000562 automatic       structure                level 1 dcl 52 set ref 92
rcp_init_flags                         based           structure                level 1 packed unaligned dcl 3-8
rec_len                         000552 automatic       fixed bin(21,0)          dcl 49 set ref 176* 186*
record_quota_overflow           000610 stack reference condition                dcl 79 ref 160
report_file                     000100 automatic       char(168)                initial dcl 46 set ref 46* 127 432 432 467 467 467
                                                                                  467
report_iocbp              2     000616 automatic       pointer                  level 2 dcl 1-4 set ref 104* 127* 135* 317 318* 319*
                                                                                  320* 453 454* 455* 456*
report_name               7     000616 automatic       varying char(64)         level 2 dcl 1-4 set ref 111* 199* 202* 204* 216*
                                                                                  221* 224* 226* 238* 243* 246* 248* 260* 265* 268*
                                                                                  270* 279* 281* 285* 288* 290* 299* 301* 305*
rest_of_record            1            based           structure                level 2 dcl 5-3
sorted_io_data                         defined         bit(1)                   unaligned dcl 73 set ref 157 212 212 217* 220 234
                                                                                  234 239* 256 256 350* 439*
suppress_name_sw          1(01) 000562 automatic       bit(1)                   initial level 2 packed unaligned dcl 52 set ref 52*
sysid                   121            based           char(32)                 level 2 dcl 4-10 ref 116
system_id               102     000616 automatic       varying char(32)         level 2 dcl 1-4 set ref 116*
time                      2            based           fixed bin(71,0)          level 3 packed unaligned dcl 5-3 ref 184 184 193
to_seq                  125     000616 automatic       fixed bin(35,0)          level 2 dcl 1-4 set ref 108* 416* 416
to_time                 130     000616 automatic       fixed bin(71,0)          level 2 dcl 1-4 set ref 105* 106 184 404* 448
upper_case                      000020 constant        char(26)                 initial unaligned dcl 14 ref 122
verify                                                 builtin function         dcl 77 ref 122
version                         000562 automatic       fixed bin(17,0)          initial level 2 dcl 52 set ref 52*
whoptr                          000556 automatic       pointer                  initial dcl 50 set ref 50* 114* 116
whotab                                 based           structure                level 1 dcl 4-10
yes_or_no_sw              1     000562 automatic       bit(1)                   initial level 2 packed unaligned dcl 52 set ref 52*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 3-16
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 3-16
No_authentication                      internal static fixed bin(17,0)          initial dcl 3-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 3-16
WHOTAB_VERSION_1                       internal static fixed bin(17,0)          initial dcl 4-96
authentication_level_names             internal static char(12)                 initial array unaligned dcl 3-21
convert_date_to_binary_$relative
                                000000 constant        entry                    external dcl 43
date_time_                      000000 constant        entry                    external dcl 40
error_table_$not_open                  external static fixed bin(35,0)          dcl 63
get_pdir_                       000000 constant        entry                    external dcl 36
heals_log_info$                        external static fixed bin(35,0)          array dcl 6-9
installation_parms_version_1           internal static fixed bin(17,0)          initial dcl 2-37
installation_parms_version_2           internal static fixed bin(17,0)          initial dcl 2-38
iox_$iocb_version_sentinel             external static char(4)                  dcl 7-51
mpc_data                               defined         bit(1)                   unaligned dcl 70
rifp                                   automatic       pointer                  dcl 3-6

NAMES DECLARED BY EXPLICIT CONTEXT.
at_proper_record                002421 constant        label                    dcl 193 ref 190
clean_up                        005516 constant        entry                    internal dcl 452 ref 126 132 138 147 154 163 181 209
                                                                                  231 253 275 295
done                            004000 constant        label                    dcl 311 ref 157 164
heals_arg_parser_               004114 constant        entry                    internal dcl 331 ref 112
heals_report                    000767 constant        entry                    external dcl 13
hr                              000757 constant        entry                    external dcl 13
pos_at_beginning                002123 constant        label                    dcl 157 ref 218 240 262 282 302 309
pos_error                       002323 constant        label                    dcl 179 ref 169 188 196

NAMES DECLARED BY CONTEXT OR IMPLICATION.
after                                                  builtin function         ref 467 467
bin                                                    builtin function         ref 212 212 212 212 212 212 234 234 234 234 234 234
                                                                                  256 256 256 256 256 256
convert                                                builtin function         ref 393 416
index                                                  builtin function         ref 94
length                                                 builtin function         ref 95 176 176 186 186
reverse                                                builtin function         ref 94 467 467 467 467 467 467 467 467
substr                                                 builtin function         ref 96 96 348 466

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6460        6560    6033        6470
Length      7204    6033       100         410     424           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hr                                  814 external procedure  is an external procedure.  
on unit on line 126                  64 on unit               
on unit on line 160                 100 on unit               
heals_arg_parser_                       internal procedure  shares stack frame of external procedure hr.  
clean_up                            162 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
hr                       000100 report_file                 hr
                         000152 buffer                      hr
                         000552 rec_len                     hr
                         000554 ip                          hr
                         000556 whoptr                      hr
                         000560 qip                         hr
                         000562 query_info                  hr
                         000566 answer                      hr
                         000576 i                           hr
                         000577 code                        hr
                         000600 one_day                     hr
                         000616 heals_arg_info              hr
                         000750 heals_message_p             hr
                         000752 heals_state_p               hr
                         000762 from                        heals_arg_parser_
                         000764 argp                        heals_arg_parser_
                         000766 arg_len                     heals_arg_parser_
                         000767 i                           heals_arg_parser_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
reverse_cs          set_chars_eis       verify_eis          any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      command_query_                convert_date_to_binary_
cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel               delete_$path
expand_path_                  get_wdir_                     hcs_$initiate                 heals_cpu_reports_
heals_io_reports_             heals_mos_edac_reports_       ioa_                          iox_$attach_ioname
iox_$close                    iox_$detach_iocb              iox_$open                     iox_$position
iox_$read_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$end_of_info      error_table_$noarg            error_table_$noentry
error_table_$not_attached     error_table_$not_closed       log_path




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     46 000705        50 000736        52 000742        58 000751        13 000756        81 000775        82 001007
     85 001037        88 001040        89 001041        90 001043        91 001044        92 001046        93 001050
     94 001055        95 001066        96 001070        98 001147        99 001154       100 001204       102 001205
    103 001214       104 001216       105 001217       106 001226       107 001231       108 001232       109 001235
    110 001240       111 001241       112 001242       113 001262       114 001264       116 001333       118 001350
    120 001423       122 001440       126 001472       127 001515       130 001577       131 001602       132 001632
    133 001636       135 001637       136 001660       137 001662       138 001712       139 001716       141 001717
    144 001770       145 001773       147 002027       148 002033       150 002034       151 002055       152 002057
    154 002116       155 002122       157 002123       160 002142       161 002156       163 002206       164 002213
    166 002216       168 002227       169 002251       175 002260       176 002300       178 002321       179 002323
    181 002353       182 002357       184 002360       186 002371       188 002412       190 002417       192 002420
    193 002421       195 002427       196 002447       198 002451       199 002454       200 002460       201 002473
    202 002475       204 002531       209 002574       210 002600       212 002601       216 002645       217 002665
    218 002673       220 002674       221 002677       222 002704       223 002717       224 002721       226 002755
    231 003020       232 003024       234 003025       238 003071       239 003111       240 003115       242 003116
    243 003121       244 003126       245 003141       246 003143       248 003177       253 003242       254 003246
    256 003247       260 003313       261 003333       262 003335       264 003336       265 003341       266 003346
    267 003361       268 003363       270 003417       275 003462       276 003466       278 003467       279 003471
    281 003514       282 003534       284 003535       285 003540       286 003545       287 003560       288 003562
    290 003616       295 003661       296 003665       298 003666       299 003670       301 003713       302 003733
    304 003734       305 003736       309 003777       311 004000       313 004004       314 004015       315 004026
    317 004030       318 004034       319 004045       320 004056       322 004060       324 004061       326 004112
    328 004113       331 004114       335 004116       342 004117       343 004121       344 004142       345 004145
    346 004177       348 004200       349 004210       350 004220       351 004227       353 004242       354 004251
    355 004260       356 004267       358 004276       359 004340       360 004344       362 004345       363 004346
    364 004365       365 004366       366 004372       367 004376       368 004415       369 004420       370 004452
    372 004453       373 004454       374 004466       375 004505       376 004510       377 004542       379 004543
    380 004544       381 004570       382 004573       383 004625       385 004626       386 004630       387 004631
    388 004641       389 004660       390 004663       391 004715       393 004716       394 004726       395 004727
    396 004731       397 004732       398 004736       399 004755       400 004760       401 005012       403 005013
    404 005014       405 005040       406 005043       407 005075       409 005076       410 005077       411 005103
    412 005122       413 005125       414 005157       416 005160       417 005170       418 005171       419 005172
    421 005202       422 005205       423 005244       425 005245       426 005255       427 005274       428 005277
    429 005331       431 005332       432 005333       433 005362       434 005365       435 005416       437 005417
    438 005420       439 005430       441 005442       443 005443       444 005446       445 005505       447 005506
    448 005507       450 005514       452 005515       453 005523       454 005530       455 005540       456 005552
    458 005555       459 005561       460 005572       461 005604       463 005607       466 005643       467 005650
    470 005754       476 006012


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
