	COMPILATION LISTING OF SEGMENT mvt_tst
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/22/84  1117.0 mst Mon
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* ******************************************************
       11*   *                                                    *
       12*   *                                                    *
       13*   *    Copyright, (C) Honeywell Information Systems    *
       14*   *    Inc., 1980.                                     *
       15*   *                                                    *
       16*   *                                                    *
       17*   ****************************************************** */
       18 
       19 mvt_tst: proc;
       20 
       21 dcl (init_temp, asc_mas, bcd_mas, ftn_mas, ntf_mas, eas_mas, aes_mas)
       22      bit (1) unaligned int static init ("0"b);
       23 dcl (tptrs (9), asp, bcdp, esp, ebp, ftnp, ntfp, wkp1, wkp2, wkp3) int static ptr;
       24 dcl  code fixed bin (35);
       25 dcl (i, j, k, m) fixed bin;
       26 dcl (divide, fixed, addr, hbound, bit, string, null) builtin;
       27 dcl (ascln, bcdln, aesln, easln, ftnln, ntfln) fixed bin (24) int static;
       28 dcl (cln, bln) fixed bin (24);
       29 dcl  char_temp char (cln) aligned based;
       30 dcl  bit_temp bit (bln) aligned based;
       31 dcl  ae_temp char (aesln/9) based (esp);
       32 dcl  ea_temp char (easln/9) based (ebp);
       33 dcl  tp ptr;
       34 dcl  cleanup condition;
       35 dcl  NL char (1) int static init ("
       36 ");
       37 
       38 dcl (ioa_, com_err_) entry options (variable);
       39 dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
       40 dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
       41 dcl  translate_strings_$nine_to_six entry (char (*) aligned, bit (*) aligned, ptr);
       42 dcl  translate_strings_$six_to_nine entry (bit (*) aligned, char (*) aligned, ptr);
       43 dcl  translate_strings_$nine_to_four_ entry (char (*) aligned, bit (*) aligned, ptr);
       44 dcl  translate_strings_$four_to_nine_ entry (bit (*) aligned, char (*) aligned, ptr);
       45 dcl  ebcdic_to_ascii_ entry (char (*), char (*));
       46 dcl  ascii_to_ebcdic_ entry (char (*), char (*));
       47 
       48 dcl  ascii_to_ebcdic_$ae_table (0 : 127) bit (9) unaligned ext static;
       49 
       50 dcl  ascii_to_bcd_table (0:127) bit (9) unaligned static initial
       51     ((10) (9) "0"b, "000001100"b, (21) (9) "0"b,
       52      "000010000"b, "000111111"b, "000111110"b, "000001011"b, "000101011"b, "000111100"b, "000011010"b, "000101111"b,
       53      "000011101"b, "000101101"b, "000101100"b, "000110000"b, "000111011"b, "000101010"b, "000011011"b, "000110001"b,
       54      "000000000"b, "000000001"b, "000000010"b, "000000011"b, "000000100"b, "000000101"b, "000000110"b, "000000111"b,
       55      "000001000"b, "000001001"b, "000001101"b, "000101110"b, "000011110"b, "000111101"b, "000001110"b, "000001111"b,
       56      "000001100"b, "000010001"b, "000010010"b, "000010011"b, "000010100"b, "000010101"b, "000010110"b, "000010111"b,
       57      "000011000"b, "000011001"b, "000100001"b, "000100010"b, "000100011"b, "000100100"b, "000100101"b, "000100110"b,
       58      "000100111"b, "000101000"b, "000101001"b, "000110010"b, "000110011"b, "000110100"b, "000110101"b, "000110110"b,
       59      "000110111"b, "000111000"b, "000111001"b, "000001010"b, "000011111"b, "000011100"b, "000100000"b, "000111010"b,
       60      "000011111"b, "000010001"b, "000010010"b, "000010011"b, "000010100"b, "000010101"b, "000010110"b, "000010111"b,
       61      "000011000"b, "000011001"b, "000100001"b, "000100010"b, "000100011"b, "000100100"b, "000100101"b, "000100110"b,
       62      "000100111"b, "000101000"b, "000101001"b, "000110010"b, "000110011"b, "000110100"b, "000110101"b, "000110110"b,
       63      "000110111"b, "000111000"b, "000111001"b, "000001010"b, "000111111"b, "000011100"b, "000000000"b, "000000000"b);
       64 
       65 dcl  bcd_to_ascii_table (0:63) bit (9) unaligned static initial
       66     ("000110000"b, "000110001"b, "000110010"b, "000110011"b, "000110100"b, "000110101"b, "000110110"b, "000110111"b,
       67      "000111000"b, "000111001"b, "001011011"b, "000100011"b, "000001010"b, "000111010"b, "000111110"b, "000111111"b,
       68      "000100000"b, "001000001"b, "001000010"b, "001000011"b, "001000100"b, "001000101"b, "001000110"b, "001000111"b,
       69      "001001000"b, "001001001"b, "000100110"b, "000101110"b, "001011101"b, "000101000"b, "000111100"b, "001011100"b,
       70      "001011110"b, "001001010"b, "001001011"b, "001001100"b, "001001101"b, "001001110"b, "001001111"b, "001010000"b,
       71      "001010001"b, "001010010"b, "000101101"b, "000100100"b, "000101010"b, "000101001"b, "000111011"b, "000100111"b,
       72      "000101011"b, "000101111"b, "001010011"b, "001010100"b, "001010101"b, "001010110"b, "001010111"b, "001011000"b,
       73      "001011001"b, "001011010"b, "001011111"b, "000101100"b, "000100101"b, "000111101"b, "000100010"b, "000100001"b);
       74 
       75 dcl  nine_to_four_table (0:15) bit (9) unaligned static init
       76     ("000000000"b, "000000001"b, "000000010"b, "000000011"b, "000000100"b, "000000101"b, "000000110"b, "000000111"b,
       77      "000001000"b, "000001001"b, "000001010"b, "000001011"b, "000001100"b, "000001101"b, "000001110"b, "000001111"b);
       78 
       79 /*  */
       80 mvt_tst_ascii_to_bcd: entry;				/* test nine to six conversion with MVT instruction */
       81 
       82 	if ^init_temp then
       83 	     call init_temp_segs;			/* make our temp segs */
       84 	if ^asc_mas then
       85 	     call init_asc_mas;			/* fill in ascii master seg */
       86 	if ^bcd_mas then
       87 	     call cv_bcd;				/* go do non eis conversion for bcdmaster */
       88 
       89 /* now do eis (MVT) conversion on 3 segments */
       90 
       91 	cln = divide (ascln, 9, 17, 0);
       92 	bln = bcdln;
       93 	do tp = wkp1, wkp2, wkp3;
       94 	     call translate_strings_$nine_to_six (asp -> char_temp, tp -> bit_temp, addr (ascii_to_bcd_table));
       95 	end;
       96 
       97 /* now compare the 3 segments to bcd master seg */
       98 
       99 	call compare (bcdp, bcdln);
      100 	return;					/* that's it folks */
      101 
      102 mvt_tst_bcd_to_ascii: entry;				/* test six to nine conversion with MVT instruction */
      103 
      104 	if ^init_temp then
      105 	     call init_temp_segs;			/* make our temp segs */
      106 	if ^asc_mas then
      107 	     call init_asc_mas;			/* fill in ascii master seg */
      108 	if ^bcd_mas then
      109 	     call cv_bcd;				/* go do non eis conversion for bcdmaster */
      110 
      111 /* now do eis (MVT) conversion on 3 segments */
      112 
      113 	cln = divide (ascln, 9, 17, 0);
      114 	bln = bcdln;
      115 	do tp = wkp1, wkp2, wkp3;
      116 	     call translate_strings_$six_to_nine (bcdp -> bit_temp, tp -> char_temp, addr (bcd_to_ascii_table));
      117 	end;
      118 
      119 /* mow compare the 3 segments to the ascii master seg */
      120 
      121 	call compare (asp, ascln);
      122 	return;
      123 
      124 mvt_tst_ascii_to_ebcdic: entry;				/* test nine to nine conversion with MVT instruction */
      125 
      126 	if ^init_temp then
      127 	     call init_temp_segs;			/* make our temp segs */
      128 	if ^aes_mas then
      129 	     call init_aes_mas;			/*  fill in our ascii to ebcdic master seg */
      130 	if ^eas_mas then
      131 	     call cv_asc_to_ebc;			/* go do non eis conversion on ascii seg */
      132 
      133 /* now do eis (MVT) conversion on 3 segments */
      134 
      135 	do tp = wkp1, wkp2, wkp3;
      136 	     call ascii_to_ebcdic_ (ae_temp, tp -> ea_temp);
      137 	end;
      138 
      139 /* Now compare the 3 segments to the ebcdic master */
      140 	call compare (ebp, easln);
      141 	return;
      142 
      143 mvt_tst_ebcdic_to_ascii: entry;				/* test nine to nine conversion with the MVT instruction */
      144 
      145 	if ^init_temp then
      146 	     call init_temp_segs;			/* make our temp segs */
      147 	if ^aes_mas then
      148 	     call init_aes_mas;			/*  fill in our ascii to ebcdic master seg */
      149 	if ^eas_mas then
      150 	     call cv_asc_to_ebc;			/* go do non eis conversion on ascii seg */
      151 
      152 /* now do eis (MVT) conversion on 3 segments */
      153 
      154 	do tp = wkp1, wkp2, wkp3;
      155 	     call ebcdic_to_ascii_ (ea_temp, tp -> ae_temp);
      156 	end;
      157 
      158 /* Now compare the 3 segments to the ascii master */
      159 
      160 	call compare (esp, aesln);
      161 	return;
      162 
      163 mvt_tst_nine_to_four: entry;				/* test nine to four conversion with the MVT instruction */
      164 
      165 	if ^init_temp then
      166 	     call init_temp_segs;			/* make our temp segs */
      167 	if ^ntf_mas then
      168 	     call init_ntf_mas;			/* Fill in our four to nine master seg */
      169 	if ^ftn_mas then
      170 	     call cv_ntf;				/* go do non eis conversion for four to nine master */
      171 
      172 /* now do eis (MVT) conversion on 3 segments */
      173 
      174 	cln = divide (ntfln, 9, 17, 0);
      175 	bln = ftnln;
      176 	do tp = wkp1, wkp2, wkp3;
      177 	     call translate_strings_$nine_to_four_ (ntfp -> char_temp, tp -> bit_temp, addr (nine_to_four_table));
      178 	end;
      179 
      180 /* Now compare the 3 segments to the four to nine master */
      181 
      182 	call compare (ftnp, ftnln);
      183 	return;
      184 
      185 mvt_tst_four_to_nine: entry;				/* test four to nine conversion with the MVT instruction */
      186 
      187 	if ^init_temp then
      188 	     call init_temp_segs;			/* make our temp segs */
      189 	if ^ntf_mas then
      190 	     call init_ntf_mas;			/* Fill in our four to nine master seg */
      191 	if ^ftn_mas then
      192 	     call cv_ntf;				/* go do non eis conversion for four to nine master */
      193 
      194 /* now do eis (MVT) conversion on 3 segments */
      195 
      196 	cln = divide (ntfln, 9, 17, 0);
      197 	bln = ftnln;
      198 	do tp = wkp1, wkp2, wkp3;
      199 	     call translate_strings_$four_to_nine_ (ftnp -> bit_temp, tp -> char_temp, addr (nine_to_four_table));
      200 	end;
      201 
      202 /* Now compare the 3 segments with the nine to four master */
      203 
      204 	call compare (ntfp, ntfln);
      205 	return;
      206 
      207 mvt_tst_release_t_segs: entry;				/* entry to release temp segs */
      208 	do i = 1 to hbound (tptrs, 1);		/* delete temp segments */
      209 	     call hcs_$delentry_seg (tptrs (i), code);
      210 	     tptrs (i) = null;
      211 	end;
      212 	asp, bcdp, esp, ebp, ftnp, ntfp, wkp1, wkp2, wkp3 = null;
      213 	init_temp, asc_mas, bcd_mas, ftn_mas, ntf_mas, eas_mas, aes_mas = "0"b;
      214 	return;
      215 
      216 /*  */
      217 init_temp_segs: proc;				/* porcedure to make all our temp segs */
      218 
      219 	     call get_temp_segments_ ("mvt_st", tptrs, code);
      220 	     if code ^= 0 then do;
      221 		call com_err_ ("mvt_tst", code, " creating temp segs ");
      222 		return;
      223 	     end;
      224 
      225 	     asp = tptrs (1);			/* set up segment pointers */
      226 	     bcdp = tptrs (2);
      227 	     esp = tptrs (3);
      228 	     ebp = tptrs (4);
      229 	     ftnp = tptrs (5);
      230 	     ntfp = tptrs (6);
      231 	     wkp1 = tptrs (7);
      232 	     wkp2 = tptrs (8);
      233 	     wkp3 = tptrs (9);
      234 	     init_temp = "1"b;			/* set switch */
      235 	end init_temp_segs;
      236 
      237 /*  */
      238 compare:	proc (mptr, mln);				/* procedure to compare temp segments to master segments */
      239 dcl  mptr ptr;
      240 dcl  mln fixed bin (24);
      241 dcl (i, j, k, ln) fixed bin;
      242 dcl  tempp ptr;
      243 dcl  mas_seg (0 : ln) bit (36) based (mptr);
      244 dcl  temp_seg (0 : ln) bit (36) based (tempp);
      245 dcl  esw bit (1);
      246 
      247 	     ln = divide (mln, 36, 17, 0) -1;		/* ln = word count - 1 */
      248 	     k = 0;
      249 	     do tempp = wkp1, wkp2, wkp3;
      250 		k = k + 1;
      251 		j = 0;
      252 		esw = "0"b;
      253 		do i = 0 to ln;			/* compare the segments */
      254 		     if temp_seg (i) ^= mas_seg (i) then do;
      255 			if ^esw then do;
      256 			     esw = "1"b;
      257 			     call ioa_ (" Discrepencies exist in the number ^d converted segment", k);
      258 			     call ioa_ ("^4xoffset^4xcontents^4xoffset^4xcontents");
      259 			end;
      260 			j = j + 1;
      261 			if j < 10 then
      262 			     call ioa_ ("^4x^6o^2x^w^2x^6o^2x^w", i, mas_seg (i), i, temp_seg (i));
      263 		     end;
      264 		end;
      265 		if j ^= 0 then
      266 		     call ioa_ ("Total of ^d discrepencies found", j);
      267 	     end;
      268 	end compare;
      269 
      270 /*  */
      271 init_asc_mas: proc;					/* procedure to initilize ascii master data seg */
      272 
      273 dcl  asc_dta char (79) int static init
      274     ("THIS IS A SEVENTY-NINE-CHARACTER FIELD FULL OF RANDOM TEST DATA. LINE X OF 10.");
      275 dcl  asctemp (333) char (80) based (asp);
      276 
      277 	     do i = 1 to hbound (asctemp, 1);
      278 		asctemp (i) = asc_dta || NL;
      279 	     end;
      280 	     ascln = hbound (asctemp, 1) * 80 * 9;
      281 	     asc_mas = "1"b;			/* set flag  so we don't init this seg again */
      282 	end init_asc_mas;
      283 
      284 init_aes_mas: proc;					/* proc to init_ascii_to ebcdic master */
      285 
      286 dcl  aes_dta char (230) int static init
      287     ("this is a test of ascii to ebcdic and ebcdic to ascii conversion.
      288 lower case keyboard: |{1234567890-_}~qwertyuiop`:;lkjhgfdsazxcvbnm,./
      289 UPPER CASE KEYBOARD: \[! #$%&'() =_]^@POIUYTREWQASDFGHJKL+*?><MNBVCXZ
      290 
      291 9_");
      292 dcl  aestemp (130) char (230) based (esp);
      293 
      294 	     do i = 1 to hbound (aestemp, 1);
      295 		aestemp (i) = aes_dta || NL;
      296 	     end;
      297 	     aesln = hbound (aestemp, 1) * 230 * 9;
      298 	     aes_mas = "1"b;
      299 	end init_aes_mas;
      300 
      301 
      302 init_ntf_mas: proc;					/* proc to init nine to four master */
      303 
      304 dcl 1 ntf_temp (1800) based (ntfp) aligned,
      305     2 ntf_char (0:15) unaligned,
      306       3 ntf_fb fixed bin (8);
      307 
      308 	     do i = 1 to divide (hbound (ntf_temp, 1), 16, 17, 0);
      309 		do j = 0 to 15;
      310 		     m = j;
      311 		     do k = 0 to 15;
      312 			ntf_temp (i).ntf_char (k).ntf_fb = m;
      313 			m = m + 1;
      314 			if m > 15 then m = 0;
      315 		     end;
      316 		end;
      317 	     end;
      318 	     ntfln = hbound (ntf_temp, 1) * 16 * 9;
      319 	     ntf_mas = "1"b;
      320 	end init_ntf_mas;
      321 
      322 /*  */
      323 convert:	proc;					/* procedure to do non EIS conversion */
      324 
      325 dcl  six_seg (sln) bit (6) based unaligned;
      326 dcl  nine_seg (nln) bit (9) based unaligned;
      327 dcl 1 cvfour aligned,
      328     2 pad bit (1) init ("0"b) unaligned,
      329     2 chr1 bit (4) unaligned,
      330     2 chr2 bit (4) unaligned;
      331 dcl (inptr, otptr) ptr;
      332 dcl (sln, nln) fixed bin (24);
      333 
      334 cv_bcd:	     entry;				/* convert ascii to bcd */
      335 	     inptr = asp;
      336 	     otptr = bcdp;
      337 	     nln = divide (ascln, 9, 17, 0);
      338 	     sln = 262000;
      339 	     do i = 1 to nln;			/* convert ascii char */
      340 		otptr -> six_seg (i) = bit (fixed (ascii_to_bcd_table (fixed (inptr -> nine_seg (i), 9)), 6));
      341 	     end;
      342 	     bcdln = i * 6;				/* set up bcd seg length */
      343 	     bcd_mas = "1"b;
      344 	     return;
      345 
      346 cv_asc_to_ebc: entry;				/* convert ascii to ebcdic */
      347 	     inptr = esp;
      348 	     otptr = ebp;
      349 	     nln = divide (aesln, 9, 17, 0);
      350 	     do i = 1 to nln;			/* convert ascii to ebcdic */
      351 		otptr -> nine_seg (i) = bit (fixed (ascii_to_ebcdic_$ae_table (fixed (inptr -> nine_seg (i), 9)), 9));
      352 	     end;
      353 	     easln = i * 9;				/* set up ebcdic seg length */
      354 	     eas_mas = "1"b;
      355 	     return;
      356 
      357 cv_ntf:	     entry;				/* convert 9 bit to 4 bit (packed decimal */
      358 	     inptr = ntfp;
      359 	     otptr = ftnp;
      360 	     nln = divide (ntfln, 9, 17, 0);
      361 	     do i = 1 to nln;			/* convert nine to four */
      362 		j = i * 2;
      363 		cvfour.chr1 = bit (fixed (inptr -> nine_seg (j - 1), 4));
      364 		cvfour.chr2 = bit (fixed (inptr -> nine_seg (j), 4));
      365 		otptr -> nine_seg (i) = string (cvfour);
      366 	     end;
      367 	     ftnln = i * 9 / 2;			/* set up packed decimal segment length */
      368 	     ftn_mas = "1"b;
      369 	     return;
      370 	end convert;
      371 
      372      end mvt_tst;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/22/84  1101.2  mvt_tst.pl1                       >spec>on>6978-10/22/84>mvt_tst.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              002207 constant        char(1)                  initial unaligned dcl 35 ref 278 295
addr                                                   builtin function         dcl 26 ref 94 94 116 116 177 177 199 199
ae_temp                                based           char                     unaligned dcl 31 set ref 136* 155*
aes_dta                         000000 constant        char(230)                initial unaligned dcl 286 ref 295
aes_mas                         000016 internal static bit(1)                   initial unaligned dcl 21 set ref 128 147 213* 298*
aesln                           000066 internal static fixed bin(24,0)          dcl 27 set ref 136 136 155 155 160* 297* 349
aestemp                                based           char(230)                array unaligned dcl 292 set ref 294 295* 297
asc_dta                         000072 constant        char(79)                 initial unaligned dcl 273 ref 278
asc_mas                         000011 internal static bit(1)                   initial unaligned dcl 21 set ref 84 106 213* 281*
ascii_to_bcd_table              000072 internal static bit(9)                   initial array unaligned dcl 50 set ref 94 94 340
ascii_to_ebcdic_                000200 constant        entry                    external dcl 46 ref 136
ascii_to_ebcdic_$ae_table       000202 external static bit(9)                   array unaligned dcl 48 ref 351
ascln                           000064 internal static fixed bin(24,0)          dcl 27 set ref 91 113 121* 280* 337
asctemp                                based           char(80)                 array unaligned dcl 275 set ref 277 278* 280
asp                             000042 internal static pointer                  dcl 23 set ref 94 121* 212* 225* 277 278 280 335
bcd_mas                         000012 internal static bit(1)                   initial unaligned dcl 21 set ref 86 108 213* 343*
bcd_to_ascii_table              000132 internal static bit(9)                   initial array unaligned dcl 65 set ref 116 116
bcdln                           000065 internal static fixed bin(24,0)          dcl 27 set ref 92 99* 114 342*
bcdp                            000044 internal static pointer                  dcl 23 set ref 99* 116 212* 226* 336
bit                                                    builtin function         dcl 26 ref 340 351 363 364
bit_temp                               based           bit                      dcl 30 set ref 94* 116* 177* 199*
bln                             000106 automatic       fixed bin(24,0)          dcl 28 set ref 92* 94 94 114* 116 116 175* 177 177
                                                                                  197* 199 199
char_temp                              based           char                     dcl 29 set ref 94* 116* 177* 199*
chr1                      0(01) 000210 automatic       bit(4)                   level 2 packed unaligned dcl 327 set ref 363*
chr2                      0(05) 000210 automatic       bit(4)                   level 2 packed unaligned dcl 327 set ref 364*
cln                             000105 automatic       fixed bin(24,0)          dcl 28 set ref 91* 94 94 113* 116 116 174* 177 177
                                                                                  196* 199 199
code                            000100 automatic       fixed bin(35,0)          dcl 24 set ref 209* 219* 220 221*
com_err_                        000160 constant        entry                    external dcl 38 ref 221
cvfour                          000210 automatic       structure                level 1 dcl 327 set ref 365
divide                                                 builtin function         dcl 26 ref 91 113 174 196 247 308 337 349 360
ea_temp                                based           char                     unaligned dcl 32 set ref 136* 155*
eas_mas                         000015 internal static bit(1)                   initial unaligned dcl 21 set ref 130 149 213* 354*
easln                           000067 internal static fixed bin(24,0)          dcl 27 set ref 136 136 140* 155 155 353*
ebcdic_to_ascii_                000176 constant        entry                    external dcl 45 ref 155
ebp                             000050 internal static pointer                  dcl 23 set ref 140* 155 212* 228* 348
esp                             000046 internal static pointer                  dcl 23 set ref 136 160* 212* 227* 294 295 297 347
esw                             000150 automatic       bit(1)                   unaligned dcl 245 set ref 252* 255 256*
fixed                                                  builtin function         dcl 26 ref 340 340 351 351 363 364
ftn_mas                         000013 internal static bit(1)                   initial unaligned dcl 21 set ref 169 191 213* 368*
ftnln                           000070 internal static fixed bin(24,0)          dcl 27 set ref 175 182* 197 367*
ftnp                            000052 internal static pointer                  dcl 23 set ref 182* 199 212* 229* 359
get_temp_segments_              000162 constant        entry                    external dcl 39 ref 219
hbound                                                 builtin function         dcl 26 ref 208 277 280 294 297 308 318
hcs_$delentry_seg               000164 constant        entry                    external dcl 40 ref 209
i                               000101 automatic       fixed bin(17,0)          dcl 25 in procedure "mvt_tst" set ref 208* 209 210*
                                                                                  277* 278* 294* 295* 308* 312* 339* 340 340* 342
                                                                                  350* 351 351* 353 361* 362 365* 367
i                               000142 automatic       fixed bin(17,0)          dcl 241 in procedure "compare" set ref 253* 254 254
                                                                                  261* 261 261* 261*
init_temp                       000010 internal static bit(1)                   initial unaligned dcl 21 set ref 82 104 126 145 165
                                                                                  187 213* 234*
inptr                           000212 automatic       pointer                  dcl 331 set ref 335* 340 347* 351 358* 363 364
ioa_                            000156 constant        entry                    external dcl 38 ref 257 258 261 265
j                               000143 automatic       fixed bin(17,0)          dcl 241 in procedure "compare" set ref 251* 260* 260
                                                                                  261 265 265*
j                               000102 automatic       fixed bin(17,0)          dcl 25 in procedure "mvt_tst" set ref 309* 310* 362*
                                                                                  363 364
k                               000103 automatic       fixed bin(17,0)          dcl 25 in procedure "mvt_tst" set ref 311* 312*
k                               000144 automatic       fixed bin(17,0)          dcl 241 in procedure "compare" set ref 248* 250* 250
                                                                                  257*
ln                              000145 automatic       fixed bin(17,0)          dcl 241 set ref 247* 253
m                               000104 automatic       fixed bin(17,0)          dcl 25 set ref 310* 312 313* 313 314 314*
mas_seg                                based           bit(36)                  array unaligned dcl 243 set ref 254 261*
mln                                    parameter       fixed bin(24,0)          dcl 240 ref 238 247
mptr                                   parameter       pointer                  dcl 239 ref 238 254 261
nine_seg                               based           bit(9)                   array unaligned dcl 326 set ref 340 351* 351 363 364
                                                                                  365*
nine_to_four_table              000152 internal static bit(9)                   initial array unaligned dcl 75 set ref 177 177 199
                                                                                  199
nln                             000217 automatic       fixed bin(24,0)          dcl 332 set ref 337* 339 349* 350 360* 361
ntf_char                               based           structure                array level 2 packed unaligned dcl 304
ntf_fb                                 based           fixed bin(8,0)           array level 3 packed unaligned dcl 304 set ref 312*
ntf_mas                         000014 internal static bit(1)                   initial unaligned dcl 21 set ref 167 189 213* 319*
ntf_temp                               based           structure                array level 1 dcl 304 set ref 308 318
ntfln                           000071 internal static fixed bin(24,0)          dcl 27 set ref 174 196 204* 318* 360
ntfp                            000054 internal static pointer                  dcl 23 set ref 177 204* 212* 230* 308 312 318 358
null                                                   builtin function         dcl 26 ref 210 212
otptr                           000214 automatic       pointer                  dcl 331 set ref 336* 340 348* 351 359* 365
pad                             000210 automatic       bit(1)                   initial level 2 packed unaligned dcl 327 set ref
                                                                                  327*
six_seg                                based           bit(6)                   array unaligned dcl 325 set ref 340*
sln                             000216 automatic       fixed bin(24,0)          dcl 332 set ref 338*
string                                                 builtin function         dcl 26 ref 365
temp_seg                               based           bit(36)                  array unaligned dcl 244 set ref 254 261*
tempp                           000146 automatic       pointer                  dcl 242 set ref 249* 254 261*
tp                              000110 automatic       pointer                  dcl 33 set ref 93* 94* 115* 116* 135* 136* 154* 155*
                                                                                  176* 177* 198* 199*
tptrs                           000020 internal static pointer                  array dcl 23 set ref 208 209* 210* 219* 225 226 227
                                                                                  228 229 230 231 232 233
translate_strings_$four_to_nine_
                                000174 constant        entry                    external dcl 44 ref 199
translate_strings_$nine_to_four_
                                000172 constant        entry                    external dcl 43 ref 177
translate_strings_$nine_to_six  000166 constant        entry                    external dcl 41 ref 94
translate_strings_$six_to_nine  000170 constant        entry                    external dcl 42 ref 116
wkp1                            000056 internal static pointer                  dcl 23 set ref 93 115 135 154 176 198 212* 231* 249
wkp2                            000060 internal static pointer                  dcl 23 set ref 93 115 135 154 176 198 212* 232* 249
wkp3                            000062 internal static pointer                  dcl 23 set ref 93 115 135 154 176 198 212* 233* 249

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
cleanup                         000000 stack reference condition                dcl 34

NAMES DECLARED BY EXPLICIT CONTEXT.
compare                         001327 constant        entry                    internal dcl 238 ref 99 121 140 160 182 204
convert                         001723 constant        entry                    internal dcl 323
cv_asc_to_ebc                   002015 constant        entry                    internal dcl 346 ref 130 149
cv_bcd                          001726 constant        entry                    internal dcl 334 ref 86 108
cv_ntf                          002100 constant        entry                    internal dcl 357 ref 169 191
init_aes_mas                    001566 constant        entry                    internal dcl 284 ref 128 147
init_asc_mas                    001534 constant        entry                    internal dcl 271 ref 84 106
init_ntf_mas                    001632 constant        entry                    internal dcl 302 ref 167 189
init_temp_segs                  001221 constant        entry                    internal dcl 217 ref 82 104 126 145 165 187
mvt_tst                         000226 constant        entry                    external dcl 19
mvt_tst_ascii_to_bcd            000235 constant        entry                    external dcl 80
mvt_tst_ascii_to_ebcdic         000464 constant        entry                    external dcl 124
mvt_tst_bcd_to_ascii            000350 constant        entry                    external dcl 102
mvt_tst_ebcdic_to_ascii         000577 constant        entry                    external dcl 143
mvt_tst_four_to_nine            001026 constant        entry                    external dcl 185
mvt_tst_nine_to_four            000712 constant        entry                    external dcl 163
mvt_tst_release_t_segs          001142 constant        entry                    external dcl 207

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2456        2662    2212        2466
Length      3134    2212       204         235     243         146

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mvt_tst                             253 external procedure  is an external procedure.  
init_temp_segs                          internal procedure  shares stack frame of external procedure mvt_tst.  
compare                                 internal procedure  shares stack frame of external procedure mvt_tst.  
init_asc_mas                            internal procedure  shares stack frame of external procedure mvt_tst.  
init_aes_mas                            internal procedure  shares stack frame of external procedure mvt_tst.  
init_ntf_mas                            internal procedure  shares stack frame of external procedure mvt_tst.  
convert                                 internal procedure  shares stack frame of external procedure mvt_tst.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 init_temp                   mvt_tst
000011 asc_mas                     mvt_tst
000012 bcd_mas                     mvt_tst
000013 ftn_mas                     mvt_tst
000014 ntf_mas                     mvt_tst
000015 eas_mas                     mvt_tst
000016 aes_mas                     mvt_tst
000020 tptrs                       mvt_tst
000042 asp                         mvt_tst
000044 bcdp                        mvt_tst
000046 esp                         mvt_tst
000050 ebp                         mvt_tst
000052 ftnp                        mvt_tst
000054 ntfp                        mvt_tst
000056 wkp1                        mvt_tst
000060 wkp2                        mvt_tst
000062 wkp3                        mvt_tst
000064 ascln                       mvt_tst
000065 bcdln                       mvt_tst
000066 aesln                       mvt_tst
000067 easln                       mvt_tst
000070 ftnln                       mvt_tst
000071 ntfln                       mvt_tst
000072 ascii_to_bcd_table          mvt_tst
000132 bcd_to_ascii_table          mvt_tst
000152 nine_to_four_table          mvt_tst

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mvt_tst                  000100 code                        mvt_tst
                         000101 i                           mvt_tst
                         000102 j                           mvt_tst
                         000103 k                           mvt_tst
                         000104 m                           mvt_tst
                         000105 cln                         mvt_tst
                         000106 bln                         mvt_tst
                         000110 tp                          mvt_tst
                         000142 i                           compare
                         000143 j                           compare
                         000144 k                           compare
                         000145 ln                          compare
                         000146 tempp                       compare
                         000150 esw                         compare
                         000210 cvfour                      convert
                         000212 inptr                       convert
                         000214 otptr                       convert
                         000216 sln                         convert
                         000217 nln                         convert

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              mpfx2               shorten_stack
ext_entry           trunc_fx2           divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ascii_to_ebcdic_              com_err_                      ebcdic_to_ascii_              get_temp_segments_
hcs_$delentry_seg             ioa_                          translate_strings_$four_to_nine_
translate_strings_$nine_to_four_                            translate_strings_$nine_to_six
translate_strings_$six_to_nine

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
ascii_to_ebcdic_$ae_table




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     19 000225        80 000233        82 000242        84 000245        86 000251        91 000255        92 000261
     93 000263        94 000267        95 000320        99 000335       100 000346       102 000347       104 000355
    106 000361       108 000365       113 000371       114 000375       115 000377       116 000403       117 000434
    121 000451       122 000462       124 000463       126 000471       128 000475       130 000501       135 000505
    136 000512       137 000547       140 000564       141 000575       143 000576       145 000604       147 000610
    149 000614       154 000620       155 000625       156 000662       160 000677       161 000710       163 000711
    165 000717       167 000723       169 000727       174 000733       175 000737       176 000741       177 000745
    178 000776       182 001013       183 001024       185 001025       187 001033       189 001037       191 001043
    196 001047       197 001053       198 001055       199 001061       200 001112       204 001127       205 001140
    207 001141       208 001147       209 001155       210 001170       211 001174       212 001176       213 001211
    214 001220       217 001221       219 001222       220 001245       221 001247       222 001300       225 001301
    226 001304       227 001306       228 001310       229 001312       230 001314       231 001316       232 001320
    233 001322       234 001324       235 001326       238 001327       247 001331       248 001335       249 001336
    250 001343       251 001344       252 001345       253 001346       254 001355       255 001365       256 001367
    257 001371       258 001411       260 001425       261 001426       264 001472       265 001474       267 001516
    268 001533       271 001534       277 001535       278 001543       279 001555       280 001557       281 001563
    282 001565       284 001566       294 001567       295 001575       296 001614       297 001617       298 001627
    299 001631       302 001632       308 001633       309 001643       310 001647       311 001650       312 001655
    313 001674       314 001675       315 001701       316 001703       317 001705       318 001707       319 001713
    320 001715       327 001717       323 001723       334 001725       335 001730       336 001733       337 001735
    338 001740       339 001742       340 001751       341 002005       342 002007       343 002012       344 002014
    346 002015       347 002017       348 002022       349 002024       350 002027       351 002035       352 002070
    353 002072       354 002075       355 002077       357 002100       358 002102       359 002105       360 002107
    361 002112       362 002121       363 002123       364 002143       365 002163       366 002171       367 002173
    368 002203       369 002205


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
