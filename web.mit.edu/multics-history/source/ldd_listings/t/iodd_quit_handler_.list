	COMPILATION LISTING OF SEGMENT iodd_quit_handler_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1336.6 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 iodd_quit_handler_: proc;
       13 
       14 /* This is the standard quit handler for the I/O daemon driver process */
       15 /* Its primary function is to see who sent the quit by looking for input. */
       16 /* We assume that the first to give a response is the one who QUIT, and will */
       17 /* accept the next input line as a command to be passed to the I/O daemon */
       18 /* command processor.  If all is well, we will return to where the */
       19 /* Quit took place.  However, the command processor may signal a condition */
       20 /* and never return.   */
       21 
       22 /* Originally coded in Sept 1973 by Robert S. Coren */
       23 /* Rewritten in Feb 1975 by J. C. Whitmore for the access isolation */
       24 /*      mechanism and general restructuring of the driver process. */
       25 /* Modified Dec 1975 by J. C. Whitmore to pass quit/signal state to command processor and */
       26 /*    to avoid writing on the slave stream if detached. */
       27 /* Modified Aug 1977 by J. C. Whitmore to use the iodd_get_cmd_ subroutine for reading cmd lines */
       28 /* Modified Nov 1977 by J. C. Whitmore to use iodd_msg_ for operator messages */
       29 /* Modified Mar 1978 by J. C. Whitmore to use parameter to set auto start delay time */
       30 /* Modified Mar 1979 by J. C. Whitmore to give proc name in last error call */
       31 
       32 
       33 
       34 /****^  HISTORY COMMENTS:
       35*  1) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       36*     audit(88-10-19,Wallman), install(88-10-28,MR12.2-1199):
       37*     Upgraded to version 5 iod tables.
       38*                                                   END HISTORY COMMENTS */
       39 
       40 
       41 /*	ENTRIES		*/
       42 
       43 	dcl     continue_to_signal_	 entry (fixed bin (35));
       44 	dcl     ioa_$rsnnl		 entry options (variable);
       45 	dcl     iodd_command_processor_ entry (fixed bin, fixed bin, char (*), fixed bin (35));
       46 	dcl     iodd_msg_		 entry options (variable);
       47 	dcl     iodd_get_cmd_	 entry (ptr, fixed bin, fixed bin, bit (36), char (*), fixed bin, fixed bin (35));
       48 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
       49 	dcl     timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry);
       50 	dcl     timer_manager_$reset_alarm_call entry (entry);
       51 
       52 
       53 
       54 /*	AUTOMATIC		*/
       55 
       56 	dcl     code		 fixed bin (35);
       57 	dcl     terminal		 (2) ptr;
       58 	dcl     line		 char (132);	/* input from terminal */
       59 	dcl     message		 char (64);	/* what to say after a quit */
       60 	dcl     junk		 fixed bin;	/* length from ioa_$rsnnl */
       61 	dcl     nchars		 fixed bin;	/* number of chars read */
       62 	dcl     state		 fixed bin;	/* quit = 2, signal handler = 3  */
       63 
       64 	dcl     control		 bit (36);	/* control flags for the get cmd subr */
       65 
       66 	dcl     1 ctl		 based (addr (control)),
       67 		2 wait_for_input	 bit (1),
       68 		2 prompt_master	 bit (1),
       69 		2 prompt_slave	 bit (1),
       70 		2 pad		 bit (33);
       71 
       72 	dcl     iodd_stat_p		 ptr ext static;	/* where stat_p is stored */
       73 
       74 	dcl     none		 fixed bin int static options (constant) init (0);
       75 	dcl     master		 fixed bin int static options (constant) init (1); /* constant  indicating input from master device */
       76 	dcl     slave		 fixed bin int static options (constant) init (2); /* constant indicating input from slave */
       77 	dcl     both		 fixed bin int static options (constant) init (0); /* constant for output to both master & salve */
       78 	dcl     normal		 fixed bin int static options (constant) init (1);
       79 	dcl     error		 fixed bin int static options (constant) init (2);
       80 	dcl     id		 char (20) int static options (constant) init ("iodd_quit_handler_");
       81 	dcl     quit_cmd_level	 fixed bin int static options (constant) init (4);
       82 	dcl     signal_cmd_level	 fixed bin int static options (constant) init (5);
       83 	dcl     master_cmd		 bit (1);		/* true if master gave a cmd at this level */
       84 	dcl     slave_cmd		 bit (1);		/* true if the slave gave a cmd at this level */
       85 	dcl     last_cmd		 fixed bin;	/* who gave the last cmd line */
       86 	dcl     source		 fixed bin;	/* who gave the current command line */
       87 	dcl     slave_input_state	 bit (1);		/* last setting of the slave accept input switch */
       88 
       89 	dcl     1 form_data		 aligned,		/* data from ctl_dim_ for form alignment */
       90 		2 page_length	 fixed bin,	/* length of logical page */
       91 		2 line_length	 fixed bin,	/* number of chars before folding line */
       92 		2 line_no		 fixed bin,	/* current line on the page */
       93 		2 carriage_pos	 fixed bin,	/* position of next char on the line */
       94 		2 aligned		 bit (1) unal,	/* "1"b if we are simulating form feeds */
       95 		2 pad		 bit (35) unal;
       96 
       97 /*	CONDITIONS		*/
       98 
       99 	dcl     (cleanup, any_other, alrm) condition;
      100 
      101 
      102 /*	BUILTINS		*/
      103 
      104 	dcl     (addr, null, substr, rtrim) builtin;
      105 
      106 
      107 /*	BASED STRUCTURES AND INCLUDE FILES		*/
      108 
      109 
  1     1 /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  1     7*     Ancient History
  1     8*     Created by J. Stern, 1/20/75
  1     9*     Modified by J. C. Whitmore April 1978 for enhancements
  1    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  1    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  1    12*     q_group_tab
  1    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  1    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    15*     Change version number to reflect changes in q_group_tab and
  1    16*     iod_device_tab for laser printer support.  Added font tables.
  1    17*                                                   END HISTORY COMMENTS */
  1    18 
  1    19 
  1    20 /* format: style4 */
  1    21 
  1    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  1    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  1    24        2 version char (8),				/* version of this structure */
  1    25        2 date_time_compiled fixed bin (71),
  1    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  1    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  1    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  1    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  1    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  1    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  1    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  1    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  1    34        2 text_strings_offset fixed bin (18),
  1    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  1    36 
  1    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  1    38 dcl  text_strings_ptr ptr;
  1    39 dcl  1 text_strings aligned based (text_strings_ptr),
  1    40        2 length fixed bin,
  1    41        2 chars char (1 refer (text_strings.length)) unaligned;
  1    42 
  1    43 /* this defines text offsets used to locate i/o daemon tables strings in
  1    44*   the text_strings structure */
  1    45 dcl  1 text_offset based,
  1    46        2 first_char fixed bin (18) unsigned unaligned,
  1    47        2 total_chars fixed bin (18) unsigned unaligned;
  1    48 
  1    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  1    50 
  1    51 
  1    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      110 
  2     1 /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  2     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  2     7*     Add support for logout_on_hangup option.
  2     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  2     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  2    10*     Add head/tail_sheet entry variables and paper_type variable.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 /* format: style4 */
  2    14 
  2    15 dcl  stat_p int static ptr;
  2    16 
  2    17 dcl  1 iodd_static based (stat_p) aligned,
  2    18 
  2    19 /*    The first part is set only once for a device driver */
  2    20 
  2    21        2 ithp ptr,					/* pointer to iod tables header */
  2    22        2 ltp ptr,					/* pointer to line table */
  2    23        2 idtp ptr,					/* pointer to device tab */
  2    24        2 mdtp ptr,					/* pointer to minor device table */
  2    25        2 qgtp ptr,					/* pointer to q_group table */
  2    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  2    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  2    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  2    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  2    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  2    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  2    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  2    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  2    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  2    35        2 log_stream char (32),			/* stream name used for log output */
  2    36        2 master_input char (32),			/* master console input stream for commands */
  2    37        2 master_output char (32),			/* master console output stream for messages */
  2    38        2 master_out ptr,				/* master output iocbp */
  2    39        2 master_in ptr,				/* master input iocbp */
  2    40        2 log_iocbp ptr,				/* log output iocbp */
  2    41        2 error_io ptr,				/* error i/o iocbp */
  2    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  2    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  2    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  2    45        2 device_dim char (32),			/* dim which drives the major device */
  2    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  2    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  2    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  2    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  2    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  2    51        2 major_device char (32),			/* name of the major device */
  2    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  2    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  2    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  2    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  2    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  2    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  2    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  2    59 
  2    60 /*    driver module entrypoints are defined by the following entry variables */
  2    61 
  2    62        2 driver_init entry variable options (variable),
  2    63        2 driver_request entry variable options (variable),
  2    64        2 driver_command entry variable options (variable),
  2    65        2 driver_default_handler entry variable options (variable),
  2    66 
  2    67 /*    entrypoints for head/tail_sheet_ entries */
  2    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  2    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  2    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  2    71 
  2    72        2 paper_type fixed bin,			/* type of paper being used */
  2    73 						/* 1 = single sheet */
  2    74 						/* 2 = continuous forms */
  2    75 
  2    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  2    77 
  2    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  2    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  2    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  2    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  2    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  2    83        2 output_device char (32),			/* name of minor device currently in use */
  2    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  2    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  2    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  2    87        2 segptr ptr,				/* ptr to current user segment being processed */
  2    88        2 flags,					/* control flags */
  2    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  2    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  2    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  2    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  2    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  2    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  2    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  2    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  2    97          3 step bit (1) unal,				/* run in step mode */
  2    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  2    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  2   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  2   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  2   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  2   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  2   104          3 pad bit (21) unal,				/* unused space */
  2   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  2   106          3 slave_input char (32),			/* slave input stream name */
  2   107          3 slave_output char (32),			/* slave output stream name */
  2   108          3 slave_pad fixed bin,			/* allocation breakage */
  2   109          3 slave_in ptr,				/* slave input iocbp */
  2   110          3 slave_out ptr,				/* slave output iocbp */
  2   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  2   112          3 active bit (1) unal,			/* on if there is a slave */
  2   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  2   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  2   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  2   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  2   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  2   118          3 priv2 bit (1) unal,
  2   119          3 priv3 bit (1) unal,
  2   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  2   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  2   122        2 ctl_term,					/* control terminal data */
  2   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  2   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  2   125          3 ctl_pad fixed bin,				/* allocation breakage */
  2   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  2   127          3 ctl_input char (32),			/* ctl input stream name */
  2   128          3 ctl_output char (32),			/* ctl output stream name */
  2   129          3 ctl_io char (32),				/* ctl i/o stream name */
  2   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  2   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  2   132          3 ctl_device char (32),			/* ctl terminal device name */
  2   133          3 form_type char (16),			/* format type if printing forms */
  2   134          3 attached bit (1) unal,			/* ctl term attached to process */
  2   135          3 forms bit (1) unal,			/* on if printing forms */
  2   136          3 pad bit (34) unal,
  2   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  2   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  2   139 
  2   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
      111 
      112 
      113 
      114 	stat_p = iodd_stat_p;			/* copy ptr to iodd_static */
      115 
      116 	control = "0"b;
      117 
      118 	ctl.prompt_master = "0"b;			/* get ready to ask for help */
      119 	ctl.prompt_slave = "1"b;
      120 	if iodd_static.request_in_progress then iodd_static.quit_during_request = "1"b;
      121 	if iodd_static.request_in_progress then
      122 	     if iodd_static.assigned_devices > 1 then
      123 		call ioa_$rsnnl ("* QUIT *  request in progress on device: ^a", message, junk,
      124 		     iodd_static.output_device);
      125 	     else call ioa_$rsnnl ("* QUIT *  request in progress", message, junk);
      126 	else message = "* QUIT *";
      127 
      128 	call iox_$control (iodd_static.master_in, "resetread", null, code); /* we want clean input */
      129 
      130 	if iodd_static.slave.active & iodd_static.slave.accept_input & iodd_static.allow_quits then do;
      131 		call iox_$control (iodd_static.slave_in, "resetread", null, code);
      132 		source = both;			/* send message to both master and slave */
      133 	     end;
      134 	else source = master;
      135 
      136 	call iodd_msg_ (normal, source, 0, "", message);
      137 
      138 	call timer_manager_$alarm_call (iodd_static.auto_start_delay, "11"b, auto_start);
      139 						/* set a timer to automatically restart */
      140 						/* if no command is given within 60 seconds */
      141 	on alrm call continue_to_signal_ (code);	/* let this go through */
      142 
      143 	on any_other begin;
      144 		last_cmd = master;			/* stop the auto start proc */
      145 		call timer_manager_$reset_alarm_call (auto_start); /* in case this frame goes away */
      146 		call continue_to_signal_ (code);
      147 	     end;
      148 	message = "quit";
      149 	state = quit_cmd_level;			/* tell the command processor it was a quit */
      150 	iodd_static.quit_signaled = "1"b;		/* set the flag for anyone who is watching */
      151 
      152 join:	slave_input_state = iodd_static.slave.accept_input; /* in case of a cleanup */
      153 	if ^iodd_static.slave.allow_quits then /* if no quits allowed, don't read the terminal */
      154 	     iodd_static.slave.accept_input = "0"b;
      155 
      156 	on cleanup begin;
      157 		call timer_manager_$reset_alarm_call (auto_start); /* now we know the frame is gone */
      158 		iodd_static.slave.accept_input = slave_input_state;
      159 		if iodd_static.slave.active & iodd_static.allow_quits then
      160 		     call iox_$control (iodd_static.slave_in, "quit_enable", null, (0));
      161 	     end;
      162 
      163 	master_cmd = "0"b;				/* no commands received yet */
      164 	slave_cmd = "0"b;
      165 	last_cmd = none;
      166 	terminal (master) = iodd_static.master_in;	/* copy the iocb ptrs for easy use */
      167 	terminal (slave) = iodd_static.slave_in;
      168 
      169 
      170 wait:	ctl.wait_for_input = "1"b;			/* say to wait for a command */
      171 
      172 read:	call iodd_get_cmd_ (addr (line), 128, nchars, control, rtrim (message), source, code);
      173 
      174 	if source = master then
      175 	     if iodd_static.slave.active then /* don't let the slave interrupt the master */
      176 		call iox_$control (iodd_static.slave_in, "quit_disable", null, (0));
      177 
      178 	if source = none then go to start;		/* last cmd was start, so let er roll */
      179 
      180 	if source = master then master_cmd = "1"b;	/* if master gave the cmd */
      181 	else slave_cmd = "1"b;			/* otherwise it was the slave */
      182 	last_cmd = source;				/* who gave the last cmd */
      183 	ctl.wait_for_input = "0"b;			/* gotsome input */
      184 
      185 	call iodd_command_processor_ (source, state, substr (line, 1, nchars), code);
      186 
      187 	if iodd_static.slave.allow_quits then do;	/* let slave get a chance */
      188 		iodd_static.slave.accept_input = (iodd_static.slave.accept_input | slave_input_state);
      189 		call iox_$control (iodd_static.slave_in, "quit_enable", null, (0));
      190 	     end;
      191 	else do;					/* not accepting input */
      192 		if iodd_static.slave.accept_input then slave_input_state = "1"b; /* in case set */
      193 		iodd_static.slave.accept_input = "0"b;	/* hold off for now */
      194 	     end;
      195 
      196 	if code = 2 then go to read;			/* let's roll...but first check for input */
      197 	if code = 0 | code = 1 then go to wait;		/* we want more input...no errors */
      198 	call iox_$control (terminal (source), "resetread", null, (0)); /* clear input after bad command */
      199 	go to wait;				/* and wait for correct input */
      200 
      201 start:
      202 	call timer_manager_$reset_alarm_call (auto_start);/* just in case.... */
      203 
      204 /*	We can continue from the point of interruption now, unless operator has forced a "hold" */
      205 
      206 	if iodd_static.forms then /* check alignment if simulating forms */
      207 	     if iodd_static.ctl_term.attached then do;	/* if the terminal is there */
      208 		     call iox_$control (iodd_static.slave_out, "form_status", addr (form_data), code);
      209 		     if code ^= 0 then do;		/* something was wrong */
      210 			     iodd_static.forms = "0"b;/* drop the forms */
      211 			     call iodd_msg_ (error, slave, code, id, "Control terminal form simulation terminated.");
      212 			     ctl.prompt_master = "1"b;/* force operator action */
      213 			     ctl.prompt_slave = "1"b; /* slave can answer */
      214 			     call iox_$control (iodd_static.master_in, "resetread", null, (0));
      215 			     call iox_$control (iodd_static.slave_in, "resetread", null, (0));
      216 			     go to wait;
      217 			end;
      218 		     if ^form_data.aligned then do;	/* dim says not aligned...so, */
      219 			     call iodd_msg_ (normal, slave, 0, "", "Control forms not aligned."); /* tell slave opr */
      220 			     iodd_static.slave_hold = "1"b;
      221 			     go to wait;
      222 			end;
      223 		end;
      224 	     else iodd_static.forms = "0"b;		/* not legal if no ctl term attached */
      225 
      226 	if last_cmd = slave then /* do we owe the master a courtesy message? */
      227 	     if master_cmd then
      228 		call iodd_msg_ (normal, master, 0, "", "^a driver continuing.", iodd_static.major_device);
      229 	     else ;
      230 
      231 	else if slave_cmd then /* do we owe the slave a courtesy message? */
      232 	     if iodd_static.slave.active then /* be sure it wasn't detached since last prompt */
      233 		call iodd_msg_ (normal, slave, 0, "", "^a driver continuing.", iodd_static.major_device);
      234 
      235 	iodd_static.slave.accept_input = slave_input_state;
      236 
      237 	call iox_$control (iodd_static.master_in, "start", null, (0)); /* be sure we don't lose a wakeup */
      238 
      239 	if iodd_static.slave.active then do;
      240 		call iox_$control (iodd_static.slave_in, "start", null, (0)); /* be sure we don't lose a wakeup */
      241 	     end;
      242 
      243 	return;					/* let'er roll */
      244 
      245 
      246 command_level: entry;
      247 
      248 /*  This entry is used by the signal handler in test mode to allow
      249*   most commands to be used after the process has been initialized. */
      250 
      251           control = "0"b;
      252 	ctl.prompt_master = "1"b;			/* only tell the master of the problem */
      253 	ctl.prompt_slave = "0"b;
      254 	message = "iodd signal";			/* new cmd level name */
      255 	state = signal_cmd_level;			/* tell the command processor it was from an unclaimed signal */
      256 	iodd_static.master_hold = "1"b;		/* force a response from the master */
      257 	go to join;				/* now join the main procedure */
      258 
      259 init: entry (aptr);
      260 
      261 	dcl     aptr		 ptr;
      262 
      263 	stat_p = aptr;				/* init the pointer for iodd_static */
      264 	return;
      265 
      266 auto_start: proc;
      267 
      268 /* internal proc to automatically "start" after a quit if no commands are given in 60 seconds */
      269 
      270 	if iodd_static.re_init_in_progress then return;
      271 
      272 	if last_cmd = none then do;
      273 		call iodd_msg_ (normal, both, 0, "", "Automatic Start Given");
      274 		go to start;
      275 	     end;
      276 	else return;				/* wasn't that easy? */
      277 
      278      end auto_start;
      279 
      280      end iodd_quit_handler_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1233.0  iodd_quit_handler_.pl1            >special_ldd>install>MR12.2-1199>iodd_quit_handler_.pl1
110          1    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
111          2    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
accept_input            342(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref 130
                                                                                  152 153* 158* 188* 188 192 193* 235*
active                  342            based           bit(1)                   level 3 packed packed unaligned dcl 2-17 ref 130 159
                                                                                  174 231 239
addr                                                   builtin function         dcl 104 ref 118 119 170 172 172 183 208 208 212 213
                                                                                  252 253
aligned                   4     000200 automatic       bit(1)                   level 2 packed packed unaligned dcl 89 set ref 218
allow_quits             342(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 ref 130 153
                                                                                  159 187
alrm                            000222 stack reference condition                dcl 99 ref 141
any_other                       000214 stack reference condition                dcl 99 ref 143
aptr                                   parameter       pointer                  dcl 261 ref 259 263
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 2-17 ref 121
attached                436            based           bit(1)                   level 3 packed packed unaligned dcl 2-17 ref 206
auto_start_delay        302            based           fixed bin(71,0)          level 2 dcl 2-17 set ref 138*
both                            000027 constant        fixed bin(17,0)          initial dcl 77 set ref 132 273*
cleanup                         000206 stack reference condition                dcl 99 ref 156
code                            000100 automatic       fixed bin(35,0)          dcl 56 set ref 128* 131* 141* 146* 172* 185* 196 197
                                                                                  197 208* 209 211*
continue_to_signal_             000012 constant        entry                    external dcl 43 ref 141 146
control                         000172 automatic       bit(36)                  packed unaligned dcl 64 set ref 116* 118 119 170
                                                                                  172* 183 212 213 251* 252 253
ctl                                    based           structure                level 1 packed packed unaligned dcl 66
ctl_term                344            based           structure                level 2 dcl 2-17
error                           000033 constant        fixed bin(17,0)          initial dcl 79 set ref 211*
flags                   310            based           structure                level 2 dcl 2-17
form_data                       000200 automatic       structure                level 1 dcl 89 set ref 208 208
forms                   436(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref 206
                                                                                  210* 224*
id                              000000 constant        char(20)                 initial packed unaligned dcl 80 set ref 211*
ioa_$rsnnl                      000014 constant        entry                    external dcl 44 ref 121 125
iodd_command_processor_         000016 constant        entry                    external dcl 45 ref 185
iodd_get_cmd_                   000022 constant        entry                    external dcl 47 ref 172
iodd_msg_                       000020 constant        entry                    external dcl 46 ref 136 211 219 226 231 273
iodd_stat_p                     000032 external static pointer                  dcl 72 ref 114
iodd_static                            based           structure                level 1 dcl 2-17
iox_$control                    000024 constant        entry                    external dcl 48 ref 128 131 159 174 189 198 208 214
                                                                                  215 237 240
junk                            000167 automatic       fixed bin(17,0)          dcl 60 set ref 121* 125*
last_cmd                        000175 automatic       fixed bin(17,0)          dcl 85 set ref 144* 165* 182* 226 272
line                            000106 automatic       char(132)                packed unaligned dcl 58 set ref 172 172 185 185
major_device            154            based           char(32)                 level 2 dcl 2-17 set ref 226* 231*
master                          000031 constant        fixed bin(17,0)          initial dcl 75 set ref 134 144 166 174 180 226*
master_cmd                      000173 automatic       bit(1)                   packed unaligned dcl 83 set ref 163* 180* 226
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  256*
master_in                70            based           pointer                  level 2 dcl 2-17 set ref 128* 166 214* 237*
message                         000147 automatic       char(64)                 packed unaligned dcl 59 set ref 121* 125* 126* 136*
                                                                                  148* 172 172 254*
nchars                          000170 automatic       fixed bin(17,0)          dcl 61 set ref 172* 185 185
none                                   constant        fixed bin(17,0)          initial dcl 74 ref 165 178 272
normal                          000031 constant        fixed bin(17,0)          initial dcl 78 set ref 136* 219* 226* 231* 273*
null                                                   builtin function         dcl 104 ref 128 128 131 131 159 159 174 174 189 189
                                                                                  198 198 214 214 215 215 237 237 240 240
output_device           267            based           char(32)                 level 2 dcl 2-17 set ref 121*
prompt_master             0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 66 set ref 118*
                                                                                  212* 252*
prompt_slave              0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 66 set ref 119*
                                                                                  213* 253*
quit_cmd_level                         constant        fixed bin(17,0)          initial dcl 81 ref 149
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  120*
quit_signaled           310(12)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  150*
re_init_in_progress     310(11)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 ref 270
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 ref 120 121
rtrim                                                  builtin function         dcl 104 ref 172 172
signal_cmd_level                       constant        fixed bin(17,0)          initial dcl 82 ref 255
slave                           000033 constant        fixed bin(17,0)          initial dcl 76 in procedure "iodd_quit_handler_" set
                                                                                  ref 167 211* 219* 226 231*
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 2-17
                                                                                  in procedure "iodd_quit_handler_"
slave_cmd                       000174 automatic       bit(1)                   packed unaligned dcl 84 set ref 164* 181* 231
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  220*
slave_in                334            based           pointer                  level 3 dcl 2-17 set ref 131* 159* 167 174* 189*
                                                                                  215* 240*
slave_input_state               000177 automatic       bit(1)                   packed unaligned dcl 87 set ref 152* 158 188 192*
                                                                                  235
slave_out               336            based           pointer                  level 3 dcl 2-17 set ref 208*
source                          000176 automatic       fixed bin(17,0)          dcl 86 set ref 132* 134* 136* 172* 174 178 180 182
                                                                                  185* 198
stat_p                          000010 internal static pointer                  dcl 2-15 set ref 114* 120 120 121 121 121 128 130
                                                                                  130 130 131 138 150 152 153 153 158 159 159 159
                                                                                  166 167 174 174 187 188 188 189 192 193 206 206
                                                                                  208 210 214 215 220 224 226 231 231 235 237 239
                                                                                  240 256 263* 270
state                           000171 automatic       fixed bin(17,0)          dcl 62 set ref 149* 185* 255*
substr                                                 builtin function         dcl 104 ref 185 185
terminal                        000102 automatic       pointer                  array dcl 57 set ref 166* 167* 198*
text_offset                            based           structure                level 1 packed packed unaligned dcl 1-45
timer_manager_$alarm_call       000026 constant        entry                    external dcl 49 ref 138
timer_manager_$reset_alarm_call 000030 constant        entry                    external dcl 50 ref 145 157 201
wait_for_input                         based           bit(1)                   level 2 packed packed unaligned dcl 66 set ref 170*
                                                                                  183*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 1-49
iod_tables_hdr                         based           structure                level 1 dcl 1-23
ithp                                   automatic       pointer                  dcl 1-22
text_strings                           based           structure                level 1 dcl 1-39
text_strings_ptr                       automatic       pointer                  dcl 1-38

NAMES DECLARED BY EXPLICIT CONTEXT.
auto_start                      001742 constant        entry                    internal dcl 266 ref 138 138 145 145 157 157 201 201
command_level                   001677 constant        entry                    external dcl 246
init                            001726 constant        entry                    external dcl 259
iodd_quit_handler_              000146 constant        entry                    external dcl 12
join                            000527 constant        label                    dcl 152 ref 257
read                            000657 constant        label                    dcl 172 ref 196
start                           001176 constant        label                    dcl 201 ref 178 274
wait                            000655 constant        label                    dcl 170 ref 197 199 216 221

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2222        2256    2023        2232
Length      2544    2023        34         252     177           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iodd_quit_handler_                  240 external procedure  is an external procedure.  
on unit on line 141                  68 on unit               
on unit on line 143                  72 on unit               
on unit on line 156                  94 on unit               
auto_start                           94 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 stat_p                      iodd_quit_handler_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
iodd_quit_handler_       000100 code                        iodd_quit_handler_
                         000102 terminal                    iodd_quit_handler_
                         000106 line                        iodd_quit_handler_
                         000147 message                     iodd_quit_handler_
                         000167 junk                        iodd_quit_handler_
                         000170 nchars                      iodd_quit_handler_
                         000171 state                       iodd_quit_handler_
                         000172 control                     iodd_quit_handler_
                         000173 master_cmd                  iodd_quit_handler_
                         000174 slave_cmd                   iodd_quit_handler_
                         000175 last_cmd                    iodd_quit_handler_
                         000176 source                      iodd_quit_handler_
                         000177 slave_input_state           iodd_quit_handler_
                         000200 form_data                   iodd_quit_handler_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          move_label_var      make_label_var
tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           ioa_$rsnnl                    iodd_command_processor_       iodd_get_cmd_
iodd_msg_                     iox_$control                  timer_manager_$alarm_call
timer_manager_$reset_alarm_call

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iodd_stat_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000145       114 000153       116 000156       118 000157       119 000161       120 000163       121 000171
    125 000227       126 000253       128 000256       130 000311       131 000317       132 000350       133 000352
    134 000353       136 000355       138 000406       141 000427       143 000453       144 000467       145 000472
    146 000505       147 000515       148 000516       149 000521       150 000523       152 000527       153 000535
    156 000542       157 000556       158 000571       159 000601       161 000637       163 000640       164 000641
    165 000642       166 000644       167 000651       170 000655       172 000657       174 000742       178 001006
    180 001010       181 001015       182 001017       183 001020       185 001022       187 001055       188 001063
    189 001066       190 001120       192 001121       193 001126       196 001130       197 001133       198 001137
    199 001175       201 001176       206 001210       208 001220       209 001252       210 001254       211 001260
    212 001312       213 001314       214 001316       215 001352       216 001406       218 001407       219 001412
    220 001446       221 001452       223 001453       224 001454       226 001456       229 001527       231 001530
    235 001601       237 001610       239 001640       240 001645       243 001675       246 001676       251 001704
    252 001705       253 001707       254 001711       255 001714       256 001716       257 001722       259 001723
    263 001733       264 001740       266 001741       270 001747       272 001753       273 001756       274 002014
    276 002017


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
