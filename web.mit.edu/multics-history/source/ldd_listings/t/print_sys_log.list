	COMPILATION LISTING OF SEGMENT print_sys_log
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/03/86  1030.8 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /* format: style2,indcomtxt */
        9 
       10 print_sys_log:
       11 psl:
       12      procedure () options (variable);
       13 
       14 /* *	PRINT_SYS_LOG
       15*   *
       16*   *	Log-printing procedure for new-format (MR11) logs. See the info file
       17*   *	for details of options too numerous to mention here.
       18*   *
       19*   *	Modification history:
       20*   *	1984-06-05, W. Olin Sibert: Initial coding, inspired by print_syserr_log
       21*   *	1984-08-23, WOS: Added -procedure, -line_length, -output_switch control arguments
       22*   *	1984-10-09, E. Swenson: Fixed bug preventing "-last N" from working.
       23*   *      1984-10-31, WOS: Added -XXX_format, calls to format_log_message_$adjust
       24*   *      1984-12-05, WOS: Fixed for control argument changes, and to handle expansions
       25*   *      1984-12-06, WOS: Added LOG_SELECTOR control arguments
       26*   *	1984-12-06, WOS: Added -dm_sys_log
       27*   *      1984-12-11, BIM: Converted to ssu_ standalone invocation.
       28*   *	1984-12-20, WOS: Added -continuation_indent
       29*   *	1984-12-26, BIM: Changed implementation of -ci to use -1 to mean "default" and to add "standard" keyword.
       30*   *      1985-01-15, BIM: -pid, -data_class, -match/exclude_data_class.
       31*   *	1985-02-07, Steve Herbst: Changed -dms to call dm_misc_util_$get_log_path.
       32*   *	1985-03-13, Steve Herbst: Fixed to recheck time range at end of find_first_message. Fixes bug where
       33*   *		if no messages within time range, procedure was getting the previous and next messages.
       34*   *	1985-03-14, Steve Herbst: Fixed to reject "/foo", "foo/", and "/"
       35*   *		as invalid regular expressions.
       36*   *	1985-03-21, Steve Herbst: Fixed not to recheck time range if the
       37*   *		argument to -from/-to is a sequence number not a time.
       38*   *	1985-04-16, Steve Herbst: Re-implemented -no_data_class, removed
       39*   *		recently by accident.
       40*   *	1985-05-01, Steve Herbst: Fixed to ensure from_time<=to_time.
       41**/
       42 
       43 
       44 /****^  HISTORY COMMENTS:
       45*  1) change(86-04-29,Kissel), approve(86-07-31,MCR7456), audit(86-08-01,Wong),
       46*     install(86-11-03,MR12.0-1149):
       47*     Changed to support DSA system and system aep logs, using the -dsasl and
       48*     -dsasal control arguments.  Also increased the size of an automatic
       49*     string which holds interpreted output so longer interpretations could be
       50*     supported.
       51*                                                   END HISTORY COMMENTS */
       52 
       53 
       54 	declare DM_READER_PROCEDURE	 char (32) init ("dm_log_read_") int static options (constant);
       55 	declare DSA_READER_PROCEDURE	 char (32) init ("dsa_log_admin_gate_") int static options (constant);
       56 
       57 	declare dm_system_log_path	 char (168);
       58 	declare dsa_system_log_path	 char (168);
       59 	declare code		 fixed bin (35);
       60 
       61 	declare log_read_data_ptr	 pointer;
       62 
       63 	declare 1 opt		 automatic,	/* Miscellaneous options for the command itself; */
       64 		2 log_pathname	 char (168),	/* note that formatting options are kept separately */
       65 		2 log_dname	 char (168),	/* in the log_message_format structure */
       66 		2 log_ename	 char (32),
       67 		2 pointers,
       68 		  3 expand_select_ptr
       69 				 pointer,
       70 		  3 lmd_ptr	 pointer,
       71 		2 limit		 aligned like log_limit_info,
       72 		2 reader_procedure	 char (32) varying,
       73 		2 iocb		 pointer,
       74 		2 flags		 aligned,
       75 		  3 debug_sw	 bit (1),
       76 		  3 dm_system_log_sw bit (1),
       77 		  3 reverse_sw	 bit (1),
       78 		  3 from_sw	 bit (1),
       79 		  3 to_sw		 bit (1),
       80 		  3 for_sw	 bit (1),
       81 		  3 last_sw	 bit (1),
       82 		  3 expand_sw	 bit (1),
       83 		  3 octal_sw	 bit (1),
       84 		  3 interpret_sw	 bit (1),
       85 		  3 log_path_sw	 bit (1),
       86 		  3 no_header_sw	 bit (1),
       87 		  3 limit_sw	 bit (1),
       88 		  3 process_id_sw	 bit (1),
       89 		  3 data_class_sw	 bit (1),
       90 		  3 dsa_system_log_sw
       91 				 bit (1);
       92 
       93 	declare expand_this_message	 bit (1) aligned;
       94 	declare expand_mode_ptr	 pointer;
       95 	declare expansion		 char (30000) varying;
       96 
       97 	declare (fb71_from_time, fb71_to_time)
       98 				 fixed bin (71);
       99 
      100 	declare 1 log_open_info	 aligned like log_read_open_info;
      101 
      102 	declare sci_ptr		 pointer;
      103 
      104 	declare error_table_$bad_arg	 fixed bin (35) external static;
      105 	declare error_table_$bad_conversion
      106 				 fixed bin (35) external static;
      107 	declare error_table_$badopt	 fixed bin (35) external static;
      108 	declare error_table_$invalid_conversion
      109 				 fixed bin (35) external static;
      110 	declare error_table_$moderr	 fixed bin (35) external static;
      111 	declare error_table_$noentry	 fixed bin (35) external static;
      112 	declare error_table_$no_log_message
      113 				 fixed bin (35) external static;
      114 	declare error_table_$noarg	 fixed bin (35) external static;
      115 	declare error_table_$too_many_args
      116 				 fixed bin (35) external static;
      117 
      118 
      119 	declare iox_$user_output	 pointer external static;
      120 
      121 	declare check_gate_access_	 entry (char (*), ptr, fixed bin (35));
      122 	declare com_err_		 entry options (variable);
      123 	declare convert_date_to_binary_
      124 				 entry (char (*), fixed bin (71), fixed bin (35));
      125 	declare cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
      126 	declare cu_$arg_list_ptr	 entry returns (pointer);
      127 	declare dm_misc_util_$get_log_path
      128 				 entry (char (*));
      129 	declare dsa_nit_$get_field	 entry (char (*), char (*), char (*), char (*), fixed bin (35));
      130 	declare expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      131 	declare get_line_length_$switch
      132 				 entry (pointer, fixed bin (35)) returns (fixed bin);
      133 	declare ioa_$ioa_switch	 entry options (variable);
      134 	declare iox_$look_iocb	 entry (char (*), pointer, fixed bin (35));
      135 	declare iox_$put_chars	 entry (pointer, pointer, fixed bin (21), fixed bin (35));
      136 	declare pathname_		 entry (char (*), char (*)) returns (char (168));
      137 
      138 	declare log_format_time_	 entry (fixed bin (71)) returns (char (32) varying);
      139 	declare expand_log_message_	 entry (pointer, pointer, pointer, char (*) varying, fixed bin (35));
      140 	declare expand_log_message_$append_octal
      141 				 entry (pointer, pointer, fixed binary, character (*) var);
      142 	declare expand_log_message_$append_process_id
      143 				 entry (pointer, pointer, character (*) var);
      144 	declare expand_log_message_$append_data_class
      145 				 entry (pointer, pointer, character (*) var);
      146 	declare format_log_message_$init
      147 				 entry (pointer);
      148 	declare format_log_message_$adjust
      149 				 entry (pointer, fixed bin (35));
      150 	declare format_log_message_$free
      151 				 entry (pointer);
      152 	declare format_log_message_$format
      153 				 entry (pointer, pointer, pointer, char (*) varying, char (*) varying,
      154 				 fixed bin (35));
      155 
      156 	declare log_limit_scan_	 entry (pointer, pointer, bit (1) aligned, pointer);
      157 	declare log_expand_select_$add entry (pointer, char (*), fixed bin (35));
      158 	declare log_expand_select_$free
      159 				 entry (pointer);
      160 	declare log_expand_select_$test
      161 				 entry (pointer, pointer, bit (1) aligned, pointer);
      162 	declare log_match_$add_match	 entry (pointer, char (*));
      163 	declare log_match_$add_exclude entry (pointer, char (*));
      164 	declare log_match_$add_match_data
      165 				 entry (pointer, char (*));
      166 	declare log_match_$add_exclude_data
      167 				 entry (pointer, char (*));
      168 	declare log_match_$add_match_data_class
      169 				 entry (pointer, character (*));
      170 	declare log_match_$add_exclude_data_class
      171 				 entry (pointer, character (*));
      172 	declare log_match_$clear_text_strings
      173 				 entry (pointer);
      174 	declare log_match_$clear_data_strings
      175 				 entry (pointer);
      176 	declare log_match_$clear_data_class_strings
      177 				 entry (pointer);
      178 	declare log_match_$add_severity
      179 				 entry (pointer, fixed bin, fixed bin);
      180 	declare log_match_$clear_severity
      181 				 entry (pointer);
      182 	declare log_match_$free	 entry (pointer);
      183 	declare log_match_$test	 entry (pointer, pointer, char (*) varying) returns (bit (1) aligned);
      184 	declare log_read_$open	 entry (char (*), char (*), pointer, fixed bin (35));
      185 	declare log_read_$open_long	 entry (character (*), character (*), pointer, pointer, fixed binary (35));
      186 	declare log_read_$close	 entry (pointer, fixed bin (35));
      187 	declare log_read_$next_message entry (pointer, pointer, fixed bin (35));
      188 	declare log_read_$prev_message entry (pointer, pointer, fixed bin (35));
      189 	declare ssu_$standalone_invocation
      190 				 entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
      191 	declare ssu_$arg_count	 entry (ptr, fixed bin);
      192 	declare ssu_$abort_line	 entry options (variable);
      193 	declare ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin (21));
      194 	declare ssu_$destroy_invocation
      195 				 entry (ptr);
      196 	declare ssu_$get_area	 entry (ptr, ptr, char (*), ptr);
      197 	declare ssu_$set_debug_mode	 entry (ptr, bit (1) aligned);
      198 
      199 	declare cleanup		 condition;
      200 
      201 	declare WHOAMI		 char (32) internal static options (constant) init ("print_sys_log");
      202 	declare DEFAULT_LINE_LENGTH	 fixed bin internal static options (constant) init (132);
      203 
      204 	declare (abs, addr, addwordno, after, before, char, dimension, index, length, null, substr, unspec)
      205 				 builtin;
      206 
      207 /**/
      208 
      209 	log_read_data_ptr = null ();
      210 	log_message_format_ptr = null ();
      211 	sci_ptr = null ();
      212 
      213 	on cleanup
      214 	     begin;				/* Temporary cleanup handler until opt is initialized */
      215 		if sci_ptr ^= null ()
      216 		then call ssu_$destroy_invocation (sci_ptr);
      217 	     end;
      218 
      219 	call ssu_$standalone_invocation (sci_ptr, WHOAMI, "1.0", cu_$arg_list_ptr (), ssu_abort, code);
      220 	if code ^= 0
      221 	then do;
      222 		call com_err_ (code, WHOAMI, "Failed to create ssu_ invocation.");
      223 		return;
      224 	     end;
      225 
      226 	call initialize_options ();
      227 
      228 
      229 
      230 	on condition (cleanup) call clean_up ();
      231 
      232 
      233 	call process_arguments ();
      234 
      235 
      236 	if opt.reader_procedure = ""
      237 	then call log_read_$open (opt.log_dname, opt.log_ename, log_read_data_ptr, code);
      238 	else do;
      239 		log_open_info.version = LOG_READ_OPEN_INFO_VERSION_1;
      240 		log_open_info.reader_procedure = opt.reader_procedure;
      241 		call ssu_$get_area (sci_ptr, null (), "log_read_ copies", log_open_info.allocation_area_ptr);
      242 		log_open_info.allocate_copies = "0"b;	/* That is the inner-ring's job */
      243 		call log_read_$open_long (opt.log_dname, opt.log_ename, addr (log_open_info), log_read_data_ptr, code)
      244 		     ;
      245 	     end;
      246 
      247 	if (code ^= 0)
      248 	then call ssu_$abort_line (sci_ptr, code, "Cannot open ^a", opt.log_pathname);
      249 
      250 	call log_limit_scan_ (sci_ptr, addr (opt.limit), opt.reverse_sw, log_read_data_ptr);
      251 
      252 	call find_first_message ();
      253 
      254 	call print_limits ();
      255 
      256 	call process_messages ();
      257 
      258 MAIN_RETURN:					/* This is the ONLY return statement for this procedure */
      259 	call clean_up ();				/* do the cleanup in the main activation, not the error procedure. */
      260 	return;
      261 
      262 
      263 ssu_abort:
      264      procedure ();					/* procedure called by ssu_ when there is a call to abort_line, which is how all errors are reported */
      265 	goto MAIN_RETURN;
      266 
      267      end ssu_abort;
      268 
      269 
      270 
      271 clean_up:
      272      procedure ();
      273 
      274 	if (opt.lmd_ptr ^= null ())
      275 	then call log_match_$free (opt.lmd_ptr);
      276 
      277 	if (opt.expand_select_ptr ^= null ())
      278 	then call log_expand_select_$free (opt.expand_select_ptr);
      279 
      280 	if (log_read_data_ptr ^= null ())
      281 	then call log_read_$close (log_read_data_ptr, (0));
      282 
      283 	if (log_message_format_ptr ^= null ())
      284 	then call format_log_message_$free (log_message_format_ptr);
      285 
      286 	if (sci_ptr ^= null ())
      287 	then call ssu_$destroy_invocation (sci_ptr);
      288 	return;
      289      end clean_up;
      290 
      291 /**/
      292 
      293 find_first_message:
      294      procedure ();
      295 
      296 	declare exchange_ptr	 pointer;
      297 	declare total_count		 fixed bin;
      298 	declare match_count		 fixed bin;
      299 	declare matching_message_ptr	 pointer;
      300 
      301 /* This procedure locates the message we're going to start with, in case we're
      302*   doing something like "-last 10", where log_limit_scan_ can't determine the
      303*   real starting point because it depends on the content of the messages. */
      304 
      305 	total_count = 0;
      306 
      307 /* First, we swap the limits if we're going to be printing backwards */
      308 
      309 	if opt.reverse_sw
      310 	then do;
      311 		exchange_ptr = opt.first_msg;
      312 		opt.first_msg = opt.last_msg;
      313 		opt.last_msg = exchange_ptr;
      314 	     end;
      315 
      316 	if (opt.first_msg ^= null ())
      317 	then /* We know where we're starting */
      318 	     go to FOUND;
      319 
      320 /* Otherwise, we look backwards to find where to start.  We are guaranteed,
      321*   by log_limit_scan_, that at least one limit is non-null, and also that if
      322*   one is null, there is a limit count. If, however, we run out of messages
      323*   before we hit the limit, that's still OK, and we print all that we have. */
      324 
      325 	match_count = 0;
      326 	log_message_ptr = opt.last_msg;
      327 	matching_message_ptr = null ();		/* Most recent matching message */
      328 
      329 	do total_count = 1 by 1 while (match_count < opt.msg_count);
      330 	     if message_matches ()
      331 	     then do;
      332 		     match_count = match_count + 1;
      333 		     matching_message_ptr = log_message_ptr;
      334 		end;
      335 
      336 	     call prev_message ();
      337 	     if (log_message_ptr = null ())
      338 	     then /* If we've run out, terminate the loop */
      339 		match_count = opt.msg_count;
      340 	end;
      341 
      342 	if (matching_message_ptr = null ())
      343 	then
      344 NO_MESSAGES:
      345 	     call ssu_$abort_line (sci_ptr, 0, "No messages matched criteria. ^d message^[s^] read.", total_count,
      346 		(total_count ^= 1));
      347 
      348 	opt.first_msg = matching_message_ptr;
      349 FOUND:
      350 	return;
      351 
      352      end find_first_message;
      353 
      354 /**/
      355 
      356 print_limits:
      357      procedure ();
      358 
      359 	if opt.no_header_sw
      360 	then return;
      361 
      362 	if (opt.first_msg = null ())
      363 	then call ioa_$ioa_switch (opt.iocb, "Log ^a to ^a", opt.log_pathname,
      364 		log_format_time_ ((opt.last_msg -> log_message.time)));
      365 
      366 	else if (opt.last_msg = null ())
      367 	then call ioa_$ioa_switch (opt.iocb, "Log ^a from ^a", opt.log_pathname,
      368 		log_format_time_ ((opt.first_msg -> log_message.time)));
      369 
      370 	else call ioa_$ioa_switch (opt.iocb, "Log ^a from ^a to ^a", opt.log_pathname,
      371 		log_format_time_ ((opt.first_msg -> log_message.time)),
      372 		log_format_time_ ((opt.last_msg -> log_message.time)));
      373 
      374 	return;
      375      end print_limits;
      376 
      377 /**/
      378 
      379 process_messages:
      380      procedure ();
      381 
      382 	declare prev_message_ptr	 pointer;
      383 	declare message_limit	 fixed bin (35);
      384 	declare message_count	 fixed bin (35);
      385 
      386 
      387 	prev_message_ptr = null ();
      388 	log_message_ptr = opt.first_msg;
      389 
      390 	if (opt.msg_count > 0)
      391 	then message_limit = opt.msg_count;
      392 	else message_limit = 100000000;		/* Meaning, everything */
      393 	message_count = 0;
      394 
      395 	do while (log_message_ptr ^= null ());		/* Catch running out of messages benignly */
      396 	     if message_matches ()
      397 	     then /* Print it if it matches */
      398 		call process_a_message ();
      399 
      400 	     if (log_message_ptr = opt.last_msg)
      401 	     then /* All done */
      402 		return;
      403 
      404 	     if (message_count >= message_limit)
      405 	     then /* Ran out of requested messages */
      406 		return;
      407 
      408 	     call next_message ();
      409 	end;
      410 
      411 	return;
      412 
      413 
      414 
      415 process_a_message:
      416      procedure ();
      417 
      418 	declare output_buffer	 char (30000) varying;
      419 
      420 /* This is where we put the selection tests */
      421 
      422 	message_count = message_count + 1;
      423 
      424 	if ^opt.interpret_sw
      425 	then /* If not interpreting, then definitely not */
      426 	     expand_this_message = "0"b;
      427 	else if (dimension (log_message.data, 1) = 0)
      428 	then /* And, if no data, also definitely not */
      429 	     expand_this_message = "0"b;
      430 	else if (opt.expand_select_ptr = null ())
      431 	then do;					/* But if we are interpreting, and no classes were */
      432 		expand_this_message = "1"b;		/* asked for, we do expand this one's data */
      433 		expand_mode_ptr = null ();		/* But, obviously, there were no expand modes asked for */
      434 	     end;
      435 	else call log_expand_select_$test
      436 		/* Otherwise, we ask the selector */ (opt.expand_select_ptr, log_message_ptr, expand_this_message,
      437 		expand_mode_ptr);
      438 
      439 	if expand_this_message
      440 	then call expand_log_message_ (log_message_format_ptr, log_message_ptr, expand_mode_ptr, expansion, (0));
      441 	else expansion = "";			/* This one has nothing for the formatter */
      442 	if opt.octal_sw
      443 	then call expand_log_message_$append_octal (log_message_format_ptr, addr (log_message.data),
      444 		(log_message.data_lth), expansion);
      445 	if opt.data_class_sw & log_message.data_class ^= ""
      446 	then call expand_log_message_$append_data_class (log_message_format_ptr, log_message_ptr, expansion);
      447 	if opt.process_id_sw
      448 	then call expand_log_message_$append_process_id (log_message_format_ptr, log_message_ptr, expansion);
      449 
      450 	call format_log_message_$format (log_message_format_ptr, log_message_ptr, prev_message_ptr, expansion,
      451 	     output_buffer, (0));
      452 
      453 	call iox_$put_chars (opt.iocb, addwordno (addr (output_buffer), 1), length (output_buffer), (0));
      454 						/* Buffer contains own newline */
      455 	prev_message_ptr = log_message_ptr;
      456 
      457 	return;
      458      end process_a_message;
      459 
      460      end process_messages;
      461 
      462 /**/
      463 
      464 message_matches:
      465      procedure () returns (bit (1) aligned);
      466 
      467 /* This procedure determines whether the current message matches selection
      468*   criteria. It first checks the text of the message, then, if that matches,
      469*   expands the binary data (if any) and tries again. */
      470 
      471 	if (^log_match_$test (opt.lmd_ptr, log_message_ptr, ""))
      472 	then return ("0"b);
      473 
      474 	if ^opt.interpret_sw
      475 	then return ("1"b);				/* No need to expand */
      476 
      477 	if opt.expand_select_ptr = null ()
      478 	then do;
      479 		expand_this_message = "1"b;
      480 		expand_mode_ptr = null ();
      481 	     end;
      482 	else call log_expand_select_$test (opt.expand_select_ptr, log_message_ptr, expand_this_message, expand_mode_ptr)
      483 		;
      484 
      485 	if ^expand_this_message
      486 	then return ("1"b);				/* No expand, no exclude on expansion */
      487 	call expand_log_message_ (log_message_format_ptr, log_message_ptr, expand_mode_ptr, expansion, (0));
      488 
      489 	return (log_match_$test (opt.lmd_ptr, log_message_ptr, expansion));
      490      end message_matches;
      491 
      492 next_message:
      493      procedure ();
      494 
      495 /* This procedure advances to the next message, returning with log_message_ptr
      496*   set to null when it encounters no further messages. */
      497 
      498 	if opt.reverse_sw
      499 	then call log_read_$prev_message (log_read_data_ptr, log_message_ptr, code);
      500 	else call log_read_$next_message (log_read_data_ptr, log_message_ptr, code);
      501 
      502 	if (code = error_table_$no_log_message)
      503 	then log_message_ptr = null ();		/* Force quiet loop termination */
      504 
      505 	else if (code ^= 0)
      506 	then call ssu_$abort_line (sci_ptr, code, "Reading next message.");
      507 
      508 	return;
      509      end next_message;				/*						*/
      510 prev_message:
      511      procedure ();
      512 
      513 /* This procedure advances to the previous message, returning with log_message_ptr
      514*   set to null when it encounters no further messages. */
      515 
      516 	if opt.reverse_sw
      517 	then call log_read_$next_message (log_read_data_ptr, log_message_ptr, code);
      518 	else call log_read_$prev_message (log_read_data_ptr, log_message_ptr, code);
      519 
      520 	if (code = error_table_$no_log_message)
      521 	then log_message_ptr = null ();		/* Force quiet loop termination */
      522 
      523 	else if (code ^= 0)
      524 	then call ssu_$abort_line (sci_ptr, code, "Reading previous message.");
      525 
      526 	return;
      527      end prev_message;
      528 
      529 /**/
      530 
      531 initialize_options:
      532      procedure ();
      533 
      534 /* This must be run before the cleanup handler gets set up */
      535 
      536 	unspec (opt) = ""b;				/* Turn all options off */
      537 	opt.pointers = null ();			/* Aggregate assignment */
      538 	opt.limit.version = LOG_LIMIT_INFO_VERSION_1;
      539 	opt.limit.to_opt = "";			/* Set up to call the limit scanner */
      540 	opt.limit.from_opt = "";
      541 	opt.limit.for_opt = "";
      542 	opt.limit.last_opt = "";
      543 	opt.log_pathname = "";
      544 	opt.iocb = iox_$user_output;
      545 
      546 	call format_log_message_$init (log_message_format_ptr);
      547 	log_message_format.caller = WHOAMI;
      548 	log_message_format.equal_sw = "1"b;		/* Default */
      549 
      550 	log_message_format.line_lth = get_line_length_$switch (opt.iocb, code);
      551 	if (code ^= 0)
      552 	then log_message_format.line_lth = DEFAULT_LINE_LENGTH;
      553 						/* Pretend to be a printer, by default */
      554 
      555 	call adjust_log_message_format ("Initializing log_message_format structure", "");
      556 
      557 	opt.reader_procedure = "";			/* Default */
      558 	return;
      559      end initialize_options;
      560 
      561 /**/
      562 
      563 process_arguments:
      564      procedure ();
      565 
      566 	declare arg		 char (arg_lth) based (arg_ptr);
      567 	declare arg_lth		 fixed bin (21);
      568 	declare arg_ptr		 pointer;
      569 	declare arg_count		 fixed bin;
      570 	declare arg_idx		 fixed bin;
      571 
      572 	declare looking_for		 fixed bin;
      573 	declare number_arg		 char (20) varying;
      574 	declare pathname_arg	 char (168) varying;
      575 	declare iocb_arg		 char (32) varying;
      576 
      577 	declare LOG_PATHNAME	 init (1) fixed bin internal static options (constant);
      578 	declare MATCH_STRING	 init (2) fixed bin internal static options (constant);
      579 	declare EXCLUDE_STRING	 init (3) fixed bin internal static options (constant);
      580 	declare MATCH_DATA_STRING	 init (4) fixed bin internal static options (constant);
      581 	declare EXCLUDE_DATA_STRING	 init (5) fixed bin internal static options (constant);
      582 	declare SEVERITY		 init (6) fixed bin internal static options (constant);
      583 	declare EXPAND_TYPE		 init (8) fixed bin internal static options (constant);
      584 	declare MATCH_DATA_CLASS_STRING
      585 				 init (9) fixed bin internal static options (constant);
      586 	declare EXCLUDE_DATA_CLASS_STRING
      587 				 init (10) fixed bin internal static options (constant);
      588 						/*						*/
      589 
      590 	call ssu_$arg_count (sci_ptr, arg_count);
      591 
      592 	looking_for = 0 - LOG_PATHNAME;		/* Start out "casually" looking for a pathname */
      593 
      594 	do arg_idx = 1 to arg_count;
      595 	     call ssu_$arg_ptr (sci_ptr, arg_idx, arg_ptr, arg_lth);
      596 
      597 	     if (looking_for > 0)
      598 	     then do;				/* First one after a control argument */
      599 		     call process_looking_for ();	/* -match -fred matches "-fred", but */
      600 		     looking_for = 0 - looking_for;	/* -match str -fred is an error */
      601 		end;				/* "Casually" looking for signalled by negative value */
      602 
      603 	     else if (arg = "-syserr")
      604 	     then call set_pathname (">sl1>syserr_log");
      605 	     else if (arg = "-answering_service") | (arg = "-as")
      606 	     then call set_pathname (">sc1>as_logs>log");
      607 	     else if (arg = "-admin")
      608 	     then call set_pathname (">sc1>as_logs>admin_log");
      609 	     else if (arg = "-pathname") | (arg = "-pn")
      610 	     then do;
      611 		     call get_next_arg (pathname_arg);
      612 		     call set_pathname (pathname_arg);
      613 		end;
      614 	     else if (arg = "-mc_log") | (arg = "-mcl")
      615 	     then do;
      616 		     call get_next_arg (pathname_arg);
      617 		     call set_pathname (">sc1>as_logs>" || pathname_arg);
      618 		end;
      619 	     else if (arg = "-dm_system") | (arg = "-dms")
      620 	     then do;
      621 		     opt.dm_system_log_sw = "1"b;
      622 		     call dm_misc_util_$get_log_path (dm_system_log_path);
      623 		     call set_pathname ((dm_system_log_path));
      624 		     opt.reader_procedure = DM_READER_PROCEDURE;
      625 		end;
      626 
      627 	     else if (arg = "-dsa_sys_log") | (arg = "-dsasl")
      628 	     then do;
      629 		     opt.dsa_system_log_sw = "1"b;
      630 
      631 		     /*** Check to see if we will succeed. */
      632 
      633 		     call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);
      634 
      635 		     if code = error_table_$noentry
      636 		     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.")
      637 			     ;
      638 		     else if code = error_table_$moderr
      639 		     then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
      640 			     DSA_READER_PROCEDURE);
      641 		     else if code ^= 0
      642 		     then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.",
      643 			     DSA_READER_PROCEDURE);
      644 
      645 		     /*** The code was 0, proceed. */
      646 
      647 		     else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_log", dsa_system_log_path,
      648 			     code);
      649 
      650 		     if code ^= 0
      651 		     then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system log.");
      652 
      653 		     call set_pathname ((dsa_system_log_path));
      654 		     opt.reader_procedure = DSA_READER_PROCEDURE;
      655 		end;
      656 
      657 	     else if (arg = "-dsa_sys_aep_log") | (arg = "-dsasal")
      658 	     then do;
      659 		     opt.dsa_system_log_sw = "1"b;
      660 
      661 		     /*** Check to see if we will succeed. */
      662 
      663 		     call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);
      664 
      665 		     if code = error_table_$noentry
      666 		     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.")
      667 			     ;
      668 		     else if code = error_table_$moderr
      669 		     then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
      670 			     DSA_READER_PROCEDURE);
      671 		     else if code ^= 0
      672 		     then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.",
      673 			     DSA_READER_PROCEDURE);
      674 
      675 		     /*** The code was 0, proceed. */
      676 
      677 		     else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_aep_log", dsa_system_log_path,
      678 			     code);
      679 
      680 		     if code ^= 0
      681 		     then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system aep log.");
      682 
      683 		     call set_pathname ((dsa_system_log_path));
      684 		     opt.reader_procedure = DSA_READER_PROCEDURE;
      685 		end;
      686 
      687 	     else if (arg = "-forward") | (arg = "-fwd")
      688 	     then opt.reverse_sw = "0"b;
      689 	     else if (arg = "-reverse") | (arg = "-rv")
      690 	     then opt.reverse_sw = "1"b;
      691 	     else if (arg = "-header") | (arg = "-he")
      692 	     then opt.no_header_sw = "0"b;
      693 	     else if (arg = "-no_header") | (arg = "-nhe")
      694 	     then opt.no_header_sw = "1"b;
      695 	     else if (arg = "-duplicates") | (arg = "-dup")
      696 	     then do;
      697 		     log_message_format.equal_sw = "0"b;
      698 		     call adjust_log_message_format ("Processing -duplicates argument.", "");
      699 		end;
      700 
      701 	     else if (arg = "-debug") | (arg = "-db")
      702 	     then do;
      703 		     log_message_format.equal_sw = "0"b;
      704 		     call adjust_log_message_format ("Processing -debug argument.", "");
      705 		     opt.debug_sw = "1"b;
      706 		     call ssu_$set_debug_mode (sci_ptr, "1"b);
      707 		end;
      708 
      709 	     else if (arg = "-no_duplicates") | (arg = "-ndup")
      710 	     then do;
      711 		     log_message_format.equal_sw = "1"b;
      712 		     call adjust_log_message_format ("Processing -no_duplicates argument.", "");
      713 		end;
      714 
      715 	     else if (arg = "-absolute_pathname") | (arg = "-absp")
      716 	     then opt.log_path_sw = "1"b;
      717 	     else if (arg = "-no_absolute_pathname") | (arg = "-nabsp")
      718 	     then opt.log_path_sw = "1"b;
      719 	     else if (arg = "-limits") | (arg = "-lim")
      720 	     then opt.limit_sw = "1"b;
      721 
      722 	     else if (arg = "-match") | (arg = "-mh")
      723 	     then looking_for = MATCH_STRING;
      724 	     else if (arg = "-exclude") | (arg = "-ex")
      725 	     then looking_for = EXCLUDE_STRING;
      726 	     else if (arg = "-match_data") | (arg = "-md")
      727 	     then looking_for = MATCH_DATA_STRING;
      728 	     else if (arg = "-exclude_data") | (arg = "-exd")
      729 	     then looking_for = EXCLUDE_DATA_STRING;
      730 	     else if (arg = "-match_data_class") | (arg = "-mdc")
      731 	     then looking_for = MATCH_DATA_CLASS_STRING;
      732 	     else if (arg = "-exclude_data_class") | (arg = "-exdc")
      733 	     then looking_for = EXCLUDE_DATA_CLASS_STRING;
      734 	     else if (arg = "-all_data_classes") | (arg = "-adc")
      735 	     then call log_match_$clear_data_class_strings (opt.lmd_ptr);
      736 	     else if (arg = "-all_text") | (arg = "-atxt")
      737 	     then call log_match_$clear_text_strings (opt.lmd_ptr);
      738 	     else if (arg = "-all_data") | (arg = "-ad")
      739 	     then call log_match_$clear_data_strings (opt.lmd_ptr);
      740 
      741 	     else if (arg = "-severity") | (arg = "-sv") | (arg = "-action")
      742 	     then looking_for = SEVERITY;
      743 
      744 	     else if (arg = "-all_severities") | (arg = "-asv")
      745 	     then call log_match_$clear_severity (opt.lmd_ptr);
      746 
      747 	     else if (arg = "-process_id") | (arg = "-pid")
      748 	     then opt.process_id_sw = "1"b;
      749 
      750 	     else if (arg = "-no_process_id") | (arg = "-npid")
      751 	     then opt.process_id_sw = "0"b;
      752 
      753 	     else if (arg = "-data_class") | (arg = "-dc")
      754 	     then opt.data_class_sw = "1"b;
      755 
      756 	     else if (arg = "-no_data_class") | (arg = "-ndc")
      757 	     then opt.data_class_sw = "0"b;
      758 
      759 /**** -match_data_class, -exclude_data_class, -all_data_classes */
      760 
      761 	     else if (arg = "-expand") | (arg = "-exp")
      762 	     then do;
      763 		     looking_for = (0 - EXPAND_TYPE);	/* Don't necessarily eat the next argument */
      764 		     opt.expand_sw = "1"b;
      765 		end;
      766 
      767 	     else if (arg = "-no_expand") | (arg = "-nexp")
      768 	     then do;
      769 		     opt.expand_sw = "0"b;
      770 		     opt.octal_sw = "0"b;
      771 		     opt.interpret_sw = "0"b;
      772 		end;
      773 
      774 	     else if (arg = "-octal") | (arg = "-oc")
      775 	     then do;
      776 		     opt.expand_sw = "1"b;
      777 		     opt.octal_sw = "1"b;
      778 		end;
      779 
      780 	     else if (arg = "-interpret") | (arg = "-int") | (arg = "-it")
      781 	     then do;
      782 		     opt.expand_sw = "1"b;
      783 		     opt.interpret_sw = "1"b;
      784 		end;
      785 
      786 
      787 	     else if (arg = "-from") | (arg = "-fm")
      788 	     then call get_next_arg (opt.limit.from_opt);
      789 	     else if (arg = "-last") | (arg = "-lt")
      790 	     then call get_next_arg (opt.limit.last_opt);
      791 	     else if (arg = "-to")
      792 	     then call get_next_arg (opt.limit.to_opt);
      793 	     else if (arg = "-for") | (arg = "-next")
      794 	     then call get_next_arg (opt.limit.for_opt);
      795 
      796 	     else if (arg = "-procedure") | (arg = "-proc")
      797 	     then call get_next_arg (opt.reader_procedure);
      798 
      799 	     else if (arg = "-line_length") | (arg = "-ll")
      800 	     then do;
      801 		     call get_next_arg (number_arg);
      802 		     log_message_format.line_lth = cv_dec_check_ ((number_arg), code);
      803 		     if (code ^= 0) | (log_message_format.line_lth < 25) | (log_message_format.line_lth > 500)
      804 		     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      805 			     "Line length must be between 25 and 500, not ^a", number_arg);
      806 
      807 		     call adjust_log_message_format ("Processing -line_length.", arg);
      808 		end;				/* Of -line_length processing */
      809 
      810 	     else if (arg = "-output_switch") | (arg = "-osw")
      811 	     then do;
      812 		     call get_next_arg (iocb_arg);
      813 		     call iox_$look_iocb ((iocb_arg), opt.iocb, code);
      814 		     if (code ^= 0)
      815 		     then call ssu_$abort_line (sci_ptr, code, "I/O switch ^a", iocb_arg);
      816 
      817 		     log_message_format.line_lth = get_line_length_$switch (opt.iocb, code);
      818 		     if (code ^= 0)
      819 		     then /* Must reset the line length, also reapply the default */
      820 			log_message_format.line_lth = DEFAULT_LINE_LENGTH;
      821 
      822 		     call adjust_log_message_format ("Setting line length from -output_switch", arg);
      823 		end;				/* Of -line_length processing */
      824 
      825 	     else if (arg = "-indent") | (arg = "-ind") | (arg = "-in")
      826 	     then do;
      827 		     call get_next_arg (number_arg);
      828 		     log_message_format.indentation = cv_dec_check_ ((number_arg), code);
      829 		     if (code ^= 0) | (log_message_format.indentation < 0) | (log_message_format.indentation > 50)
      830 		     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      831 			     "Indentation must be between 0 and 50, not ^a", number_arg);
      832 
      833 		     call adjust_log_message_format ("Processing -indent", arg);
      834 		end;				/* Of -indent processing */
      835 
      836 	     else if (arg = "-continuation_indent") | (arg = "-ci")
      837 	     then do;
      838 		     call get_next_arg (number_arg);
      839 		     if number_arg = "standard" | number_arg = "std"
      840 		     then log_message_format.continuation_indent = -1;
      841 		     else do;
      842 			     log_message_format.continuation_indent = cv_dec_check_ ((number_arg), code);
      843 			     if (code ^= 0) | (log_message_format.continuation_indent < 0)
      844 				| (log_message_format.continuation_indent > 50)
      845 			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      846 				     "Continuation indent must be between 0 and 50 or ""standard"", not ^a",
      847 				     number_arg);
      848 
      849 			end;
      850 		     call adjust_log_message_format ("Processing -continuation_indent", arg);
      851 		end;				/* Of -continuation_indent processing */
      852 
      853 	     else if (arg = "-prefix") | (arg = "-pfx")
      854 	     then do;
      855 		     call get_next_arg (log_message_format.prefix);
      856 		     call adjust_log_message_format ("Processing -prefix", arg);
      857 		end;				/* Of -prefix processing */
      858 
      859 
      860 	     else if (arg = "-time_format") | (arg = "-tfmt")
      861 	     then do;
      862 		     call get_next_arg (log_message_format.time_format);
      863 		     call adjust_log_message_format ("Processing -time_format", arg);
      864 		end;
      865 
      866 	     else if (arg = "-date_format") | (arg = "-dfmt")
      867 	     then do;
      868 		     call get_next_arg (log_message_format.date_format);
      869 		     call adjust_log_message_format ("Processing -date_format", arg);
      870 		end;
      871 
      872 	     else if (arg = "-number_format") | (arg = "-nfmt")
      873 	     then do;
      874 		     call get_next_arg (log_message_format.number_format);
      875 		     call adjust_log_message_format ("Processing -number_format", arg);
      876 		end;
      877 
      878 	     else if (index (arg, "-") = 1)
      879 	     then call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);
      880 
      881 	     else call process_looking_for ();
      882 	end;					/* of loop through arguments */
      883 
      884 	call check_options ();
      885 
      886 	return;					/* End of argument processing */
      887 
      888 /**/
      889 
      890 process_looking_for:
      891      procedure ();
      892 
      893 	declare really_looking_for	 fixed bin;
      894 	declare severity1		 fixed bin;
      895 	declare severity2		 fixed bin;
      896 
      897 
      898 	really_looking_for = abs (looking_for);
      899 
      900 /* Weed out invalid regular expressions in match/exclude args */
      901 
      902 	if really_looking_for = MATCH_STRING | really_looking_for = EXCLUDE_STRING
      903 	     | really_looking_for = MATCH_DATA_STRING | really_looking_for = EXCLUDE_DATA_STRING
      904 	     | really_looking_for = MATCH_DATA_CLASS_STRING | really_looking_for = EXCLUDE_DATA_CLASS_STRING
      905 	then if substr (arg, 1, 1) = "/" & substr (arg, arg_lth, 1) ^= "/"
      906 	     then
      907 INVALID_REGULAR_EXPRESSION:
      908 		call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "Invalid regular expression ""^a""", arg);
      909 	     else if substr (arg, arg_lth, 1) = "/" & substr (arg, 1, 1) ^= "/"
      910 	     then go to INVALID_REGULAR_EXPRESSION;
      911 	     else if arg = "/"
      912 	     then go to INVALID_REGULAR_EXPRESSION;
      913 
      914 
      915 	if (really_looking_for = LOG_PATHNAME)
      916 	then call set_pathname ((arg));
      917 
      918 	else if (really_looking_for = MATCH_STRING)
      919 	then call log_match_$add_match (opt.lmd_ptr, arg);
      920 
      921 	else if (really_looking_for = EXCLUDE_STRING)
      922 	then call log_match_$add_exclude (opt.lmd_ptr, arg);
      923 
      924 	else if (really_looking_for = MATCH_DATA_STRING)
      925 	then call log_match_$add_match_data (opt.lmd_ptr, arg);
      926 
      927 	else if (really_looking_for = EXCLUDE_DATA_STRING)
      928 	then call log_match_$add_exclude_data (opt.lmd_ptr, arg);
      929 
      930 	else if (really_looking_for = MATCH_DATA_CLASS_STRING)
      931 	then call log_match_$add_match_data_class (opt.lmd_ptr, arg);
      932 
      933 	else if (really_looking_for = EXCLUDE_DATA_CLASS_STRING)
      934 	then call log_match_$add_exclude_data_class (opt.lmd_ptr, arg);
      935 
      936 	else if (really_looking_for = SEVERITY)
      937 	then do;
      938 		severity1 = cv_dec_check_ (before (arg, ":"), code);
      939 		if (code ^= 0)
      940 		then
      941 INVALID_SEVERITY_RANGE:
      942 		     call ssu_$abort_line (sci_ptr, error_table_$invalid_conversion,
      943 			"Invalid severity value ""^a"": must be <N> or <N>:<M>", arg);
      944 
      945 		if (index (arg, ":") = 0)
      946 		then /* Not a range, just a single number */
      947 		     severity2 = severity1;
      948 		else severity2 = cv_dec_check_ (after (arg, ":"), code);
      949 		if (code ^= 0)
      950 		then goto INVALID_SEVERITY_RANGE;
      951 
      952 		call log_match_$add_severity (opt.lmd_ptr, severity1, severity2);
      953 	     end;
      954 
      955 	else if (really_looking_for = EXPAND_TYPE)
      956 	then do;
      957 		call log_expand_select_$add (opt.expand_select_ptr, arg, code);
      958 		if (code ^= 0)
      959 		then call ssu_$abort_line (sci_ptr, code, "Invalid expansion type/modes: ""^a"".", arg);
      960 	     end;
      961 
      962 	return;
      963      end process_looking_for;
      964 
      965 /**/
      966 
      967 get_next_arg:
      968      procedure (P_option);
      969 
      970 	declare P_option		 char (*) varying parameter;
      971 
      972 
      973 	if (arg_idx >= arg_count)
      974 	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Value missing after ^a", arg);
      975 
      976 	arg_idx = arg_idx + 1;
      977 	call ssu_$arg_ptr (sci_ptr, arg_idx, arg_ptr, arg_lth);
      978 
      979 	P_option = arg;
      980 
      981 	return;
      982      end get_next_arg;
      983 
      984 
      985 
      986 set_pathname:
      987      procedure (P_pathname);
      988 
      989 	declare P_pathname		 char (*) varying parameter;
      990 
      991 /* This is a separate procedure both for convenience, and also to ease the
      992*   implementation of reading multiple logs-- just take out the restriction,
      993*   and add the proper support in open. */
      994 
      995 
      996 	if (opt.log_pathname ^= "")
      997 	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args, "Only one log pathname: ^a invalid", P_pathname)
      998 		;
      999 
     1000 	call expand_pathname_ ((P_pathname), opt.log_dname, opt.log_ename, code);
     1001 	if (code ^= 0)
     1002 	then call ssu_$abort_line (sci_ptr, code, "Invalid log pathname: ^a", P_pathname);
     1003 
     1004 	opt.log_pathname = pathname_ (opt.log_dname, opt.log_ename);
     1005 						/* Value used in messages */
     1006 
     1007 	return;
     1008      end set_pathname;
     1009 
     1010 /**/
     1011 
     1012 check_options:
     1013      procedure ();
     1014 
     1015 	dcl     temp_number		 fixed bin;
     1016 	dcl     (from_time, to_time)	 fixed bin (71);
     1017 	dcl     exchange_opt	 char (50) varying;
     1018 	dcl     code		 fixed bin (35);
     1019 
     1020 	if (opt.log_pathname = "")
     1021 	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage:^-^a  LOG-SELECTOR  {-control_args}", WHOAMI);
     1022 
     1023 	if (looking_for > 0)
     1024 	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "After ^a", arg);
     1025 
     1026 	if opt.expand_sw & ^(opt.octal_sw | opt.interpret_sw)
     1027 	then opt.interpret_sw = "1"b;			/* If neither specified, default is -interpret */
     1028 
     1029 /* Make sure the -from time is less than the -to time */
     1030 
     1031 	if opt.limit.from_opt ^= "" & opt.limit.to_opt ^= ""
     1032 	then do;
     1033 		temp_number = cv_dec_check_ ((opt.limit.from_opt), code);
     1034 		if code ^= 0
     1035 		then do;
     1036 			temp_number = cv_dec_check_ ((opt.limit.to_opt), code);
     1037 			if code ^= 0
     1038 			then do;
     1039 				call convert_date_to_binary_ ((opt.limit.from_opt), from_time, 0);
     1040 				call convert_date_to_binary_ ((opt.limit.to_opt), to_time, 0);
     1041 				if from_time > to_time
     1042 				then do;
     1043 					exchange_opt = opt.limit.from_opt;
     1044 					opt.limit.from_opt = opt.limit.to_opt;
     1045 					opt.limit.to_opt = exchange_opt;
     1046 				     end;
     1047 			     end;
     1048 		     end;
     1049 	     end;
     1050 
     1051 	return;
     1052 
     1053      end check_options;
     1054 
     1055      end process_arguments;
     1056 
     1057 /**/
     1058 
     1059 adjust_log_message_format:
     1060      procedure (P_doing_what, P_doing_it_with);
     1061 
     1062 	declare P_doing_what	 char (*) parameter;
     1063 	declare P_doing_it_with	 char (*) parameter;
     1064 
     1065 
     1066 	call format_log_message_$adjust (log_message_format_ptr, code);
     1067 	if (code = 0)
     1068 	then /* All OK */
     1069 	     return;
     1070 
     1071 	call ssu_$abort_line (sci_ptr, code, "^a ^a",	/* Hope this identifies the source of error correctly */
     1072 	     P_doing_what, P_doing_it_with);		/* There are many possible errors from $adjust */
     1073 
     1074      end adjust_log_message_format;
     1075 
     1076 
  1     1 /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  1     2 
  1     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  1     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  1     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  1     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  1     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  1     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  1     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  1    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  1    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  1    12 
  1    13 declare 1 log_message         aligned based (log_message_ptr),
  1    14           2 header            aligned like log_message_header,
  1    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  1    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  1    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  1    18 
  1    19 declare   log_message_ptr pointer;
  1    20 declare   log_message_text_lth fixed bin;
  1    21 declare   log_message_data_class_lth fixed bin;
  1    22 declare   log_message_data_lth fixed bin;
  1    23 
  1    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
     1077 
     1078 
  2     1 /* BEGIN INCLUDE FILE ... log_message_format.incl.pl1 ... 84-07-03 ... W. Olin Sibert */
  2     2 
  2     3 declare 1 log_message_format            aligned based (log_message_format_ptr),
  2     4           2 caller                      char (32) unaligned, /* Caller name to use when printing error messages */
  2     5           2 line_lth                    fixed bin,          /* Max length of output lines; longer messages are folded */
  2     6           2 indentation                 fixed bin,          /* Number of spaces at beginning of each output line */
  2     7           2 equal_sw                    bit (1) aligned,    /* Whether to suppress messages with identical text */
  2     8           2 error_sw                    bit (1) aligned,    /* Whether to print error messages via com_err_ */
  2     9           2 prefix                      char (40) varying,  /* Prefix for printing messages */
  2    10           2 number_format               char (20) varying,  /* ioa_ format for printing message numbers */
  2    11           2 time_format                 char (40) varying,  /* date_time_$format string for message times */
  2    12           2 date_format                 char (40) varying,  /* date_time_$format string for when date changes */
  2    13           2 continuation_indent	fixed bin,	/* If >= zero, value for continuation lines */
  2    14 						/* Otherwise, lined up under the text by default */
  2    15 
  2    16           2 pad (59)                    bit (36) aligned,
  2    17 
  2    18 /* ONLY format_log_message_$adjust ever changes the values below */
  2    19 
  2    20           2 internal_info               aligned,            /* Internal info, set by $adjust-- DO NOT CHANGE */
  2    21             3 area_ptr                  pointer,            /* Where this structure is allocated */
  2    22             3 date_ioa_string           char (100) varying, /* Format for date breaks,if any */
  2    23             3 message_ioa_string        char (100) varying, /* Format for first lines of messages */
  2    24             3 real_continuation_indent  fixed bin,          /* Indentation for continuation lines */
  2    25             3 prefix_lth                fixed bin,          /* Length of indent + prefix + time + sequence + severity */
  2    26             3 date_modulus              fixed bin (36),     /* Modulus for checking whether dates are equal */
  2    27 
  2    28           2 end                         fixed bin;
  2    29 
  2    30 declare   log_message_format_ptr pointer;
  2    31 
  2    32 /* END INCLUDE FILE ... log_message_format.incl.pl1 */
     1079 
     1080 
  3     1 /* BEGIN INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
  3     2 /* Modified 1984-12-16, BIM: for a version number */
  3     3 
  3     4 declare   log_limit_info_ptr pointer;
  3     5 
  3     6 declare 1 log_limit_info      aligned based (log_limit_info_ptr),
  3     7           2 version           char (8) aligned,
  3     8           2 to_opt            char (50) varying,            /* Input: options supplied after control */
  3     9           2 from_opt          char (50) varying,            /* argument of this name */
  3    10           2 for_opt           char (50) varying,
  3    11           2 last_opt          char (50) varying,
  3    12 
  3    13           2 first_msg         pointer,                      /* Output: results of successful processing */
  3    14           2 last_msg          pointer,                      /* of above options */
  3    15           2 msg_count         fixed bin (35);
  3    16 
  3    17 declare LOG_LIMIT_INFO_VERSION_1 char (8) init ("lliv0001") internal static options (constant);
  3    18 
  3    19 /* END INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
     1081 
     1082 
  4     1 /* Begin include file log_read_open_data.incl.pl1 BIM 1984-12-15 */
  4     2 /* Use this with log_read_$open_long to specify special purpose options */
  4     3 
  4     4 declare log_read_open_info_ptr pointer;
  4     5 declare 1 log_read_open_info aligned based (log_read_open_info_ptr),
  4     6         2 version char (8) aligned,
  4     7         2 reader_procedure char (32) varying,		/* this is an outer ring opening, and this procedure retrieves from the inner ring */
  4     8         2 allocation_area_ptr pointer,			/* if reader_procedure is not "",  */
  4     9 						/* this is passed to it to for allocation */		
  4    10         2 allocate_copies bit (1) aligned;		/* incompatable with reader_procedure ^= "" */
  4    11 						/* indicates that this opening must allocate copies for use by an outer ring */
  4    12 
  4    13 declare LOG_READ_OPEN_INFO_VERSION_1
  4    14         char (8) init ("logro001") int static options (constant);
  4    15 
  4    16 /* End include file log_read_open_info.incl.pl1 */
     1083 
     1084      end print_sys_log;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/03/86  0953.3  print_sys_log.pl1                 >spec>install>1149>print_sys_log.pl1
1077         1    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
1079         2    01/21/85  0912.2  log_message_format.incl.pl1       >ldd>include>log_message_format.incl.pl1
1081         3    01/21/85  0912.2  log_limit_info.incl.pl1           >ldd>include>log_limit_info.incl.pl1
1083         4    01/21/85  0912.3  log_read_open_info.incl.pl1       >ldd>include>log_read_open_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEFAULT_LINE_LENGTH                    constant        fixed bin(17,0)          initial dcl 202 ref 551 818
DM_READER_PROCEDURE             000024 constant        char(32)                 initial unaligned dcl 54 ref 624
DSA_READER_PROCEDURE            000014 constant        char(32)                 initial unaligned dcl 55 set ref 633* 638* 641* 654
                                                                                  663* 668* 671* 684
EXCLUDE_DATA_CLASS_STRING              constant        fixed bin(17,0)          initial dcl 586 ref 732 902 933
EXCLUDE_DATA_STRING                    constant        fixed bin(17,0)          initial dcl 581 ref 728 902 927
EXCLUDE_STRING                         constant        fixed bin(17,0)          initial dcl 579 ref 724 902 921
EXPAND_TYPE                            constant        fixed bin(17,0)          initial dcl 583 ref 763 955
LOG_LIMIT_INFO_VERSION_1        000002 constant        char(8)                  initial unaligned dcl 3-17 ref 538
LOG_PATHNAME                           constant        fixed bin(17,0)          initial dcl 577 ref 592 915
LOG_READ_OPEN_INFO_VERSION_1    000000 constant        char(8)                  initial unaligned dcl 4-13 ref 239
MATCH_DATA_CLASS_STRING                constant        fixed bin(17,0)          initial dcl 584 ref 730 902 930
MATCH_DATA_STRING                      constant        fixed bin(17,0)          initial dcl 580 ref 726 902 924
MATCH_STRING                           constant        fixed bin(17,0)          initial dcl 578 ref 722 902 918
P_doing_it_with                        parameter       char                     unaligned dcl 1063 set ref 1059 1071*
P_doing_what                           parameter       char                     unaligned dcl 1062 set ref 1059 1071*
P_option                               parameter       varying char             dcl 970 set ref 967 979*
P_pathname                             parameter       varying char             dcl 989 set ref 986 996* 1000 1001*
SEVERITY                               constant        fixed bin(17,0)          initial dcl 582 ref 741 936
WHOAMI                          000004 constant        char(32)                 initial unaligned dcl 201 set ref 219* 222* 547
                                                                                  1020*
abs                                                    builtin function         dcl 204 ref 898
addr                                                   builtin function         dcl 204 ref 243 243 250 250 442 442 453 453
addwordno                                              builtin function         dcl 204 ref 453 453
after                                                  builtin function         dcl 204 ref 948 948
allocate_copies          16     017244 automatic       bit(1)                   level 2 dcl 100 set ref 242*
allocation_area_ptr      14     017244 automatic       pointer                  level 2 dcl 100 set ref 241*
arg                                    based           char                     unaligned dcl 566 set ref 603 605 605 607 609 609
                                                                                  614 614 619 619 627 627 657 657 687 687 689 689
                                                                                  691 691 693 693 695 695 701 701 709 709 715 715
                                                                                  717 717 719 719 722 722 724 724 726 726 728 728
                                                                                  730 730 732 732 734 734 736 736 738 738 741 741
                                                                                  741 744 744 747 747 750 750 753 753 756 756 761
                                                                                  761 767 767 774 774 780 780 780 787 787 789 789
                                                                                  791 793 793 796 796 799 799 807* 810 810 822* 825
                                                                                  825 825 833* 836 836 850* 853 853 856* 860 860
                                                                                  863* 866 866 869* 872 872 875* 878 878* 902 902
                                                                                  902* 909 909 911 915 918* 921* 924* 927* 930* 933*
                                                                                  938 938 939* 945 948 948 957* 958* 973* 979 1023*
arg_count                       036122 automatic       fixed bin(17,0)          dcl 569 set ref 590* 594 973
arg_idx                         036123 automatic       fixed bin(17,0)          dcl 570 set ref 594* 595* 973 976* 976 977*
arg_lth                         036116 automatic       fixed bin(21,0)          dcl 567 set ref 595* 603 605 605 607 609 609 614 614
                                                                                  619 619 627 627 657 657 687 687 689 689 691 691
                                                                                  693 693 695 695 701 701 709 709 715 715 717 717
                                                                                  719 719 722 722 724 724 726 726 728 728 730 730
                                                                                  732 732 734 734 736 736 738 738 741 741 741 744
                                                                                  744 747 747 750 750 753 753 756 756 761 761 767
                                                                                  767 774 774 780 780 780 787 787 789 789 791 793
                                                                                  793 796 796 799 799 807 807 810 810 822 822 825
                                                                                  825 825 833 833 836 836 850 850 853 853 856 856
                                                                                  860 860 863 863 866 866 869 869 872 872 875 875
                                                                                  878 878 878 902 902 902 902 902 909 909 909 911
                                                                                  915 918 918 921 921 924 924 927 927 930 930 933
                                                                                  933 938 938 939 939 945 948 948 957 957 958 958
                                                                                  973 973 977* 979 1023 1023
arg_ptr                         036120 automatic       pointer                  dcl 568 set ref 595* 603 605 605 607 609 609 614 614
                                                                                  619 619 627 627 657 657 687 687 689 689 691 691
                                                                                  693 693 695 695 701 701 709 709 715 715 717 717
                                                                                  719 719 722 722 724 724 726 726 728 728 730 730
                                                                                  732 732 734 734 736 736 738 738 741 741 741 744
                                                                                  744 747 747 750 750 753 753 756 756 761 761 767
                                                                                  767 774 774 780 780 780 787 787 789 789 791 793
                                                                                  793 796 796 799 799 807 810 810 822 825 825 825
                                                                                  833 836 836 850 853 853 856 860 860 863 866 866
                                                                                  869 872 872 875 878 878 902 902 902 909 909 911
                                                                                  915 918 921 924 927 930 933 938 938 939 945 948
                                                                                  948 957 958 973 977* 979 1023
before                                                 builtin function         dcl 204 ref 938 938
caller                                 based           char(32)                 level 2 packed unaligned dcl 2-3 set ref 547*
check_gate_access_              000034 constant        entry                    external dcl 121 ref 633 663
cleanup                         017266 stack reference condition                dcl 199 ref 213 230
code                            000224 automatic       fixed bin(35,0)          dcl 59 in procedure "psl" set ref 219* 220 222* 236*
                                                                                  243* 247 247* 498* 500* 502 505 505* 516* 518* 520
                                                                                  523 523* 550* 551 633* 635 638 638* 641 641* 647*
                                                                                  650 650* 663* 665 668 668* 671 671* 677* 680 680*
                                                                                  802* 803 813* 814 814* 817* 818 828* 829 842* 843
                                                                                  938* 939 948* 949 957* 958 958* 1000* 1001 1001*
                                                                                  1066* 1067 1071*
code                            036272 automatic       fixed bin(35,0)          dcl 1018 in procedure "check_options" set ref 1033*
                                                                                  1034 1036* 1037
com_err_                        000036 constant        entry                    external dcl 122 ref 222
continuation_indent      63            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 839* 842* 843 843
convert_date_to_binary_         000040 constant        entry                    external dcl 123 ref 1039 1040
cu_$arg_list_ptr                000044 constant        entry                    external dcl 126 ref 219 219
cv_dec_check_                   000042 constant        entry                    external dcl 125 ref 802 828 842 938 948 1033 1036
data                                   based           bit(36)                  array level 2 dcl 1-13 set ref 427 442 442
data_class                             based           char                     level 2 packed unaligned dcl 1-13 ref 445
data_class_lth            2(09)        based           fixed bin(9,0)           level 3 packed unsigned unaligned dcl 1-13 ref 427
                                                                                  442 442 445
data_class_sw           270     000230 automatic       bit(1)                   level 3 dcl 63 set ref 445 753* 756*
data_lth                  4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 1-13 ref 427 442
date_format              50            based           varying char(40)         level 2 dcl 2-3 set ref 868*
debug_sw                252     000230 automatic       bit(1)                   level 3 dcl 63 set ref 705*
dimension                                              builtin function         dcl 204 ref 427
dm_misc_util_$get_log_path      000046 constant        entry                    external dcl 127 ref 622
dm_system_log_path              000100 automatic       char(168)                unaligned dcl 57 set ref 622* 623
dm_system_log_sw        253     000230 automatic       bit(1)                   level 3 dcl 63 set ref 621*
dsa_nit_$get_field              000050 constant        entry                    external dcl 129 ref 647 677
dsa_system_log_path             000152 automatic       char(168)                unaligned dcl 58 set ref 647* 653 677* 683
dsa_system_log_sw       271     000230 automatic       bit(1)                   level 3 dcl 63 set ref 629* 659*
equal_sw                 12            based           bit(1)                   level 2 dcl 2-3 set ref 548* 697* 703* 711*
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 104 set ref 635* 665* 902*
error_table_$bad_conversion     000012 external static fixed bin(35,0)          dcl 105 set ref 803* 829* 843*
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 107 set ref 878*
error_table_$invalid_conversion 000016 external static fixed bin(35,0)          dcl 108 set ref 939*
error_table_$moderr             000020 external static fixed bin(35,0)          dcl 110 ref 638 668
error_table_$no_log_message     000024 external static fixed bin(35,0)          dcl 112 ref 502 520
error_table_$noarg              000026 external static fixed bin(35,0)          dcl 114 set ref 973* 1020* 1023*
error_table_$noentry            000022 external static fixed bin(35,0)          dcl 111 ref 635 665
error_table_$too_many_args      000030 external static fixed bin(35,0)          dcl 115 set ref 996*
exchange_opt                    036254 automatic       varying char(50)         dcl 1017 set ref 1043* 1045
exchange_ptr                    017306 automatic       pointer                  dcl 296 set ref 311* 313
expand_log_message_             000070 constant        entry                    external dcl 139 ref 439 487
expand_log_message_$append_data_class
                                000076 constant        entry                    external dcl 144 ref 445
expand_log_message_$append_octal
                                000072 constant        entry                    external dcl 140 ref 442
expand_log_message_$append_process_id
                                000074 constant        entry                    external dcl 142 ref 447
expand_mode_ptr                 000524 automatic       pointer                  dcl 94 set ref 433* 435* 439* 480* 482* 487*
expand_pathname_                000052 constant        entry                    external dcl 130 ref 1000
expand_select_ptr       134     000230 automatic       pointer                  level 3 dcl 63 set ref 277 277* 430 435* 477 482*
                                                                                  957*
expand_sw               261     000230 automatic       bit(1)                   level 3 dcl 63 set ref 764* 769* 776* 782* 1026
expand_this_message             000522 automatic       bit(1)                   dcl 93 set ref 424* 427* 432* 435* 439 479* 482* 485
expansion                       000526 automatic       varying char(30000)      dcl 95 set ref 439* 441* 442* 445* 447* 450* 487*
                                                                                  489*
first_msg               232     000230 automatic       pointer                  level 3 dcl 63 set ref 311 312* 316 348* 362 366 370
                                                                                  388
flags                   252     000230 automatic       structure                level 2 dcl 63
for_opt                 176     000230 automatic       varying char(50)         level 3 dcl 63 set ref 541* 793*
format_log_message_$adjust      000102 constant        entry                    external dcl 148 ref 1066
format_log_message_$format      000106 constant        entry                    external dcl 152 ref 450
format_log_message_$free        000104 constant        entry                    external dcl 150 ref 283
format_log_message_$init        000100 constant        entry                    external dcl 146 ref 546
from_opt                160     000230 automatic       varying char(50)         level 3 dcl 63 set ref 540* 787* 1031 1033 1039 1043
                                                                                  1044*
from_time                       036250 automatic       fixed bin(71,0)          dcl 1016 set ref 1039* 1041
get_line_length_$switch         000054 constant        entry                    external dcl 131 ref 550 817
header                                 based           structure                level 2 dcl 1-13
indentation              11            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 828* 829 829
index                                                  builtin function         dcl 204 ref 878 945
interpret_sw            263     000230 automatic       bit(1)                   level 3 dcl 63 set ref 424 474 771* 783* 1026 1026*
ioa_$ioa_switch                 000056 constant        entry                    external dcl 133 ref 362 366 370
iocb                    250     000230 automatic       pointer                  level 2 dcl 63 set ref 362* 366* 370* 453* 544* 550*
                                                                                  813* 817*
iocb_arg                        036206 automatic       varying char(32)         dcl 575 set ref 812* 813 814*
iox_$look_iocb                  000060 constant        entry                    external dcl 134 ref 813
iox_$put_chars                  000062 constant        entry                    external dcl 135 ref 453
iox_$user_output                000032 external static pointer                  dcl 119 ref 544
last_msg                234     000230 automatic       pointer                  level 3 dcl 63 set ref 312 313* 326 362 366 370 400
last_opt                214     000230 automatic       varying char(50)         level 3 dcl 63 set ref 542* 789*
length                                                 builtin function         dcl 204 ref 453 453
limit                   140     000230 automatic       structure                level 2 dcl 63 set ref 250 250
limit_sw                266     000230 automatic       bit(1)                   level 3 dcl 63 set ref 719*
line_lth                 10            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 550* 551* 802* 803 803 817*
                                                                                  818*
lmd_ptr                 136     000230 automatic       pointer                  level 3 dcl 63 set ref 274 274* 471* 489* 734* 736*
                                                                                  738* 744* 918* 921* 924* 927* 930* 933* 952*
log_dname                52     000230 automatic       char(168)                level 2 packed unaligned dcl 63 set ref 236* 243*
                                                                                  1000* 1004*
log_ename               124     000230 automatic       char(32)                 level 2 packed unaligned dcl 63 set ref 236* 243*
                                                                                  1000* 1004*
log_expand_select_$add          000112 constant        entry                    external dcl 157 ref 957
log_expand_select_$free         000114 constant        entry                    external dcl 158 ref 277
log_expand_select_$test         000116 constant        entry                    external dcl 160 ref 435 482
log_format_time_                000066 constant        entry                    external dcl 138 ref 362 366 370 370
log_limit_info                         based           structure                level 1 dcl 3-6
log_limit_scan_                 000110 constant        entry                    external dcl 156 ref 250
log_match_$add_exclude          000122 constant        entry                    external dcl 163 ref 921
log_match_$add_exclude_data     000126 constant        entry                    external dcl 166 ref 927
log_match_$add_exclude_data_class
                                000132 constant        entry                    external dcl 170 ref 933
log_match_$add_match            000120 constant        entry                    external dcl 162 ref 918
log_match_$add_match_data       000124 constant        entry                    external dcl 164 ref 924
log_match_$add_match_data_class 000130 constant        entry                    external dcl 168 ref 930
log_match_$add_severity         000142 constant        entry                    external dcl 178 ref 952
log_match_$clear_data_class_strings
                                000140 constant        entry                    external dcl 176 ref 734
log_match_$clear_data_strings   000136 constant        entry                    external dcl 174 ref 738
log_match_$clear_severity       000144 constant        entry                    external dcl 180 ref 744
log_match_$clear_text_strings   000134 constant        entry                    external dcl 172 ref 736
log_match_$free                 000146 constant        entry                    external dcl 182 ref 274
log_match_$test                 000150 constant        entry                    external dcl 183 ref 471 489
log_message                            based           structure                level 1 dcl 1-13
log_message_format                     based           structure                level 1 dcl 2-3
log_message_format_ptr          017276 automatic       pointer                  dcl 2-30 set ref 210* 283 283* 439* 442* 445* 447*
                                                                                  450* 487* 546* 547 548 550 551 697 703 711 802 803
                                                                                  803 817 818 828 829 829 839 842 843 843 855 862
                                                                                  868 874 1066*
log_message_header                     based           structure                level 1 dcl 1-3
log_message_ptr                 017274 automatic       pointer                  dcl 1-19 set ref 326* 333 337 388* 395 400 427 435*
                                                                                  439* 442 442 442 445 445* 447* 450* 455 471* 482*
                                                                                  487* 489* 498* 500* 502* 516* 518* 520*
log_open_info                   017244 automatic       structure                level 1 dcl 100 set ref 243 243
log_path_sw             264     000230 automatic       bit(1)                   level 3 dcl 63 set ref 715* 717*
log_pathname                    000230 automatic       char(168)                level 2 packed unaligned dcl 63 set ref 247* 362*
                                                                                  366* 370* 543* 996 1004* 1020
log_read_$close                 000156 constant        entry                    external dcl 186 ref 280
log_read_$next_message          000160 constant        entry                    external dcl 187 ref 500 516
log_read_$open                  000152 constant        entry                    external dcl 184 ref 236
log_read_$open_long             000154 constant        entry                    external dcl 185 ref 243
log_read_$prev_message          000162 constant        entry                    external dcl 188 ref 498 518
log_read_data_ptr               000226 automatic       pointer                  dcl 61 set ref 209* 236* 243* 250* 280 280* 498*
                                                                                  500* 516* 518*
log_read_open_info                     based           structure                level 1 dcl 4-5
looking_for                     036124 automatic       fixed bin(17,0)          dcl 572 set ref 592* 597 600* 600 722* 724* 726*
                                                                                  728* 730* 732* 741* 763* 898 1023
match_count                     017311 automatic       fixed bin(17,0)          dcl 298 set ref 325* 329 332* 332 337*
matching_message_ptr            017312 automatic       pointer                  dcl 299 set ref 327* 333* 342 348
message_count                   017333 automatic       fixed bin(35,0)          dcl 384 set ref 393* 404 422* 422
message_limit                   017332 automatic       fixed bin(35,0)          dcl 383 set ref 390* 392* 404
msg_count               236     000230 automatic       fixed bin(35,0)          level 3 dcl 63 set ref 329 337 390 390
no_header_sw            265     000230 automatic       bit(1)                   level 3 dcl 63 set ref 359 691* 693*
null                                                   builtin function         dcl 204 ref 209 210 211 215 241 241 274 277 280 283
                                                                                  286 316 327 337 342 362 366 387 395 430 433 477
                                                                                  480 502 520 537 633 633 663 663
number_arg                      036125 automatic       varying char(20)         dcl 573 set ref 801* 802 803* 827* 828 829* 838* 839
                                                                                  839 842 843*
number_format            27            based           varying char(20)         level 2 dcl 2-3 set ref 874*
octal_sw                262     000230 automatic       bit(1)                   level 3 dcl 63 set ref 442 770* 777* 1026
opt                             000230 automatic       structure                level 1 unaligned dcl 63 set ref 536*
output_buffer                   017342 automatic       varying char(30000)      dcl 418 set ref 450* 453 453 453 453
pathname_                       000064 constant        entry                    external dcl 136 ref 1004
pathname_arg                    036133 automatic       varying char(168)        dcl 574 set ref 611* 612* 616* 617
pointers                134     000230 automatic       structure                level 2 unaligned dcl 63 set ref 537*
prefix                   14            based           varying char(40)         level 2 dcl 2-3 set ref 855*
prev_message_ptr                017330 automatic       pointer                  dcl 382 set ref 387* 450* 455*
process_id_sw           267     000230 automatic       bit(1)                   level 3 dcl 63 set ref 447 747* 750*
reader_procedure        237     000230 automatic       varying char(32)         level 2 in structure "opt" dcl 63 in procedure "psl"
                                                                                  set ref 236 240 557* 624* 654* 684* 796*
reader_procedure          2     017244 automatic       varying char(32)         level 2 in structure "log_open_info" dcl 100
                                                                                  in procedure "psl" set ref 240*
really_looking_for              036226 automatic       fixed bin(17,0)          dcl 893 set ref 898* 902 902 902 902 902 902 915 918
                                                                                  921 924 927 930 933 936 955
reverse_sw              254     000230 automatic       bit(1)                   level 3 dcl 63 set ref 250* 309 498 516 687* 689*
sci_ptr                         017264 automatic       pointer                  dcl 102 set ref 211* 215 215* 219* 241* 247* 250*
                                                                                  286 286* 342* 505* 523* 590* 595* 635* 638* 641*
                                                                                  650* 665* 668* 671* 680* 706* 803* 814* 829* 843*
                                                                                  878* 902* 939* 958* 973* 977* 996* 1001* 1020*
                                                                                  1023* 1071*
severity1                       036227 automatic       fixed bin(17,0)          dcl 894 set ref 938* 945 952*
severity2                       036230 automatic       fixed bin(17,0)          dcl 895 set ref 945* 948* 952*
ssu_$abort_line                 000170 constant        entry                    external dcl 192 ref 247 342 505 523 635 638 641 650
                                                                                  665 668 671 680 803 814 829 843 878 902 939 958
                                                                                  973 996 1001 1020 1023 1071
ssu_$arg_count                  000166 constant        entry                    external dcl 191 ref 590
ssu_$arg_ptr                    000172 constant        entry                    external dcl 193 ref 595 977
ssu_$destroy_invocation         000174 constant        entry                    external dcl 194 ref 215 286
ssu_$get_area                   000176 constant        entry                    external dcl 196 ref 241
ssu_$set_debug_mode             000200 constant        entry                    external dcl 197 ref 706
ssu_$standalone_invocation      000164 constant        entry                    external dcl 189 ref 219
substr                                                 builtin function         dcl 204 ref 902 902 909 909
temp_number                     036246 automatic       fixed bin(17,0)          dcl 1015 set ref 1033* 1036*
text_lth                  4            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-13 ref 427 442 442
                                                                                  445
time                      2(18)        based           fixed bin(53,0)          level 3 packed unaligned dcl 1-13 ref 362 366 370
                                                                                  370
time_format              35            based           varying char(40)         level 2 dcl 2-3 set ref 862*
to_opt                  142     000230 automatic       varying char(50)         level 3 dcl 63 set ref 539* 791* 1031 1036 1040 1044
                                                                                  1045*
to_time                         036252 automatic       fixed bin(71,0)          dcl 1016 set ref 1040* 1041
total_count                     017310 automatic       fixed bin(17,0)          dcl 297 set ref 305* 329* 342* 342
unspec                                                 builtin function         dcl 204 set ref 536*
version                         017244 automatic       char(8)                  level 2 in structure "log_open_info" dcl 100
                                                                                  in procedure "psl" set ref 239*
version                 140     000230 automatic       char(8)                  level 3 in structure "opt" dcl 63 in procedure "psl"
                                                                                  set ref 538*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
char                                                   builtin function         dcl 204
fb71_from_time                         automatic       fixed bin(71,0)          dcl 97
fb71_to_time                           automatic       fixed bin(71,0)          dcl 97
log_limit_info_ptr                     automatic       pointer                  dcl 3-4
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 1-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 1-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 1-20
log_read_open_info_ptr                 automatic       pointer                  dcl 4-4

NAMES DECLARED BY EXPLICIT CONTEXT.
FOUND                           002043 constant        label                    dcl 349 ref 316
INVALID_REGULAR_EXPRESSION      006406 constant        label                    dcl 902 ref 909 911
INVALID_SEVERITY_RANGE          006731 constant        label                    dcl 939 ref 949
MAIN_RETURN                     001576 constant        label                    dcl 258 ref 265
NO_MESSAGES                     002000 constant        label                    dcl 342
adjust_log_message_format       007767 constant        entry                    internal dcl 1059 ref 555 698 704 712 807 822 833
                                                                                  850 856 863 869 875
check_options                   007451 constant        entry                    internal dcl 1012 ref 884
clean_up                        001615 constant        entry                    internal dcl 271 ref 230 258
find_first_message              001721 constant        entry                    internal dcl 293 ref 252
get_next_arg                    007151 constant        entry                    internal dcl 967 ref 611 616 787 789 791 793 796 801
                                                                                  812 827 838 855 862 868 874
initialize_options              003220 constant        entry                    internal dcl 531 ref 226
message_matches                 002654 constant        entry                    internal dcl 464 ref 330 396
next_message                    003035 constant        entry                    internal dcl 492 ref 408
prev_message                    003130 constant        entry                    internal dcl 510 ref 336
print_limits                    002044 constant        entry                    internal dcl 356 ref 254
print_sys_log                   001207 constant        entry                    external dcl 10
process_a_message               002340 constant        entry                    internal dcl 415 ref 396
process_arguments               003310 constant        entry                    internal dcl 563 ref 233
process_looking_for             006346 constant        entry                    internal dcl 890 ref 599 881
process_messages                002275 constant        entry                    internal dcl 379 ref 256
psl                             001200 constant        entry                    external dcl 10
set_pathname                    007256 constant        entry                    internal dcl 986 ref 603 605 607 612 617 623 653 683
                                                                                  915
ssu_abort                       001604 constant        entry                    internal dcl 263 ref 219 219

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11172       11374   10221       11202
Length     12042   10221       202         431     750           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
psl                               16118 external procedure  is an external procedure.  
on unit on line 213                  68 on unit               
on unit on line 230                  64 on unit               
ssu_abort                            64 internal procedure  is assigned to an entry variable.  
clean_up                             76 internal procedure  is called by several nonquick procedures.  
find_first_message                      internal procedure  shares stack frame of external procedure psl.  
print_limits                            internal procedure  shares stack frame of external procedure psl.  
process_messages                        internal procedure  shares stack frame of external procedure psl.  
process_a_message                       internal procedure  shares stack frame of external procedure psl.  
message_matches                         internal procedure  shares stack frame of external procedure psl.  
next_message                            internal procedure  shares stack frame of external procedure psl.  
prev_message                            internal procedure  shares stack frame of external procedure psl.  
initialize_options                      internal procedure  shares stack frame of external procedure psl.  
process_arguments                       internal procedure  shares stack frame of external procedure psl.  
process_looking_for                     internal procedure  shares stack frame of external procedure psl.  
get_next_arg                            internal procedure  shares stack frame of external procedure psl.  
set_pathname                         96 internal procedure  is called during a stack extension.  
check_options                           internal procedure  shares stack frame of external procedure psl.  
adjust_log_message_format               internal procedure  shares stack frame of external procedure psl.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
psl                      000100 dm_system_log_path          psl
                         000152 dsa_system_log_path         psl
                         000224 code                        psl
                         000226 log_read_data_ptr           psl
                         000230 opt                         psl
                         000522 expand_this_message         psl
                         000524 expand_mode_ptr             psl
                         000526 expansion                   psl
                         017244 log_open_info               psl
                         017264 sci_ptr                     psl
                         017274 log_message_ptr             psl
                         017276 log_message_format_ptr      psl
                         017306 exchange_ptr                find_first_message
                         017310 total_count                 find_first_message
                         017311 match_count                 find_first_message
                         017312 matching_message_ptr        find_first_message
                         017330 prev_message_ptr            process_messages
                         017332 message_limit               process_messages
                         017333 message_count               process_messages
                         017342 output_buffer               process_a_message
                         036116 arg_lth                     process_arguments
                         036120 arg_ptr                     process_arguments
                         036122 arg_count                   process_arguments
                         036123 arg_idx                     process_arguments
                         036124 looking_for                 process_arguments
                         036125 number_arg                  process_arguments
                         036133 pathname_arg                process_arguments
                         036206 iocb_arg                    process_arguments
                         036226 really_looking_for          process_looking_for
                         036227 severity1                   process_looking_for
                         036230 severity2                   process_looking_for
                         036246 temp_number                 check_options
                         036250 from_time                   check_options
                         036252 to_time                     check_options
                         036254 exchange_opt                check_options
                         036272 code                        check_options

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     realloc_char_temp   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_gate_access_            com_err_                      convert_date_to_binary_       cu_$arg_list_ptr
cv_dec_check_                 dm_misc_util_$get_log_path    dsa_nit_$get_field            expand_log_message_
expand_log_message_$append_data_class                       expand_log_message_$append_octal
expand_log_message_$append_process_id                       expand_pathname_              format_log_message_$adjust
format_log_message_$format    format_log_message_$free      format_log_message_$init      get_line_length_$switch
ioa_$ioa_switch               iox_$look_iocb                iox_$put_chars                log_expand_select_$add
log_expand_select_$free       log_expand_select_$test       log_format_time_              log_limit_scan_
log_match_$add_exclude        log_match_$add_exclude_data   log_match_$add_exclude_data_class
log_match_$add_match          log_match_$add_match_data     log_match_$add_match_data_class
log_match_$add_severity       log_match_$clear_data_class_strings                         log_match_$clear_data_strings
log_match_$clear_severity     log_match_$clear_text_strings log_match_$free               log_match_$test
log_read_$close               log_read_$next_message        log_read_$open                log_read_$open_long
log_read_$prev_message        pathname_                     ssu_$abort_line               ssu_$arg_count
ssu_$arg_ptr                  ssu_$destroy_invocation       ssu_$get_area                 ssu_$set_debug_mode
ssu_$standalone_invocation

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_conversion   error_table_$badopt
error_table_$invalid_conversion                             error_table_$moderr           error_table_$no_log_message
error_table_$noarg            error_table_$noentry          error_table_$too_many_args    iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 001177       209 001214       210 001216       211 001217       213 001220       215 001234       217 001247
    219 001250       220 001320       222 001322       223 001346       226 001347       230 001350       233 001372
    236 001373       239 001426       240 001430       241 001435       242 001466       243 001467       247 001521
    250 001554       252 001573       254 001574       256 001575       258 001576       260 001602       263 001603
    265 001611       271 001614       274 001622       277 001635       280 001651       283 001670       286 001704
    288 001720       293 001721       305 001722       309 001723       311 001726       312 001730       313 001732
    316 001734       325 001740       326 001741       327 001743       329 001745       330 001753       332 001760
    333 001761       336 001763       337 001764       340 001772       342 001774       348 002041       349 002043
    356 002044       359 002045       362 002050       366 002126       370 002203       374 002274       379 002275
    387 002276       388 002300       390 002302       392 002306       393 002310       395 002311       396 002316
    400 002324       404 002331       408 002335       409 002336       411 002337       415 002340       422 002341
    424 002345       427 002351       430 002360       432 002364       433 002366       434 002370       435 002371
    439 002406       441 002442       442 002443       445 002512       447 002547       450 002571       453 002624
    455 002651       457 002653       464 002654       471 002656       474 002711       477 002717       479 002723
    480 002725       481 002727       482 002730       485 002745       487 002754       489 003004       492 003035
    498 003036       500 003055       502 003070       505 003077       508 003127       510 003130       516 003131
    518 003150       520 003163       523 003172       526 003217       531 003220       536 003221       537 003224
    538 003227       539 003231       540 003232       541 003233       542 003234       543 003235       544 003240
    546 003244       547 003252       548 003256       550 003260       551 003273       555 003300       557 003306
    558 003307       563 003310       590 003311       592 003322       594 003324       595 003333       597 003350
    599 003352       600 003353       601 003355       603 003356       605 003402       607 003430       609 003452
    611 003462       612 003465       613 003475       614 003476       616 003506       617 003511       618 003540
    619 003542       621 003552       622 003554       623 003565       624 003602       625 003607       627 003610
    629 003620       633 003622       635 003645       638 003675       641 003727       647 003761       650 004021
    653 004047       654 004064       655 004071       657 004072       659 004102       663 004104       665 004127
    668 004157       671 004211       677 004243       680 004302       683 004330       684 004345       685 004352
    687 004353       689 004365       691 004400       693 004412       695 004425       697 004435       698 004437
    699 004445       701 004446       703 004456       704 004460       705 004466       706 004470       707 004502
    709 004503       711 004513       712 004516       713 004524       715 004525       717 004540       719 004553
    722 004566       724 004601       726 004614       728 004627       730 004642       732 004655       734 004670
    736 004710       738 004730       741 004750       744 004767       747 005007       750 005022       753 005034
    756 005047       761 005061       763 005071       764 005073       765 005075       767 005076       769 005106
    770 005107       771 005110       772 005111       774 005112       776 005122       777 005124       778 005125
    780 005126       782 005142       783 005144       784 005145       787 005146       789 005162       791 005176
    793 005206       796 005222       799 005236       801 005246       802 005251       803 005304       807 005344
    808 005371       810 005372       812 005402       813 005405       814 005436       817 005472       818 005506
    822 005513       823 005535       825 005536       827 005552       828 005555       829 005610       833 005647
    834 005674       836 005675       838 005705       839 005710       842 005726       843 005761       850 006020
    851 006042       853 006043       855 006053       856 006064       857 006111       860 006112       862 006122
    863 006133       864 006160       866 006161       868 006171       869 006202       870 006227       872 006230
    874 006240       875 006251       876 006273       878 006274       881 006341       882 006342       884 006344
    886 006345       890 006346       898 006347       902 006354       909 006442       911 006450       915 006455
    918 006501       921 006525       924 006550       927 006573       930 006616       933 006641       936 006664
    938 006666       939 006726       945 006764       948 007002       949 007046       952 007051       953 007064
    955 007065       957 007067       958 007113       962 007150       967 007151       973 007162       976 007223
    977 007224       979 007241       981 007254       986 007255       996 007271      1000 007326      1001 007366
   1004 007427      1007 007450      1012 007451      1020 007452      1023 007506      1026 007542      1031 007552
   1033 007564      1034 007616      1036 007621      1037 007653      1039 007656      1040 007710      1041 007743
   1043 007747      1044 007754      1045 007761      1051 007766      1059 007767      1066 010005      1067 010016
   1071 010021      1074 010056


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
