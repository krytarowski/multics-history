	COMPILATION LISTING OF SEGMENT amu_deadproc_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/28/87  0927.6 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 amu_deadproc_:
        7      proc;
        8 
        9 /*  Modified August 84 by B. Braun to correctly analyze dead processes.
       10*    Modified 10 Jan 85 by B. Braun to add entry $name_to_segno.	
       11*    Modified 11 Jan 85 by B. Braun to
       12*      1) Provide more informative error messages in $init_deadproc and $create_uid_hash.
       13*      2) initialize and correctly assign the release_id in old_uid_table.sys_release.
       14*      3) Get rid of double quotes of the pdir name in the id string.
       15*    Modified 12 Jan 85 by B. Braun to call amu_$kst_util_expand_uid_path and delete the internal proc expand_it.
       16*    Modified 13 Jan 85 by B. Braun to make the uid_hash_table per invocation of selecting the 
       17*      deadproc so users don't write into uid_hash_table in the pdir.
       18*    Modified 18 Jan 85 by B. Braun to store short names of level 1 dirs in the hash table
       19*      via a call to amu_$get_l1dir_shortname.
       20*    Modified 24 Jan 85 by B. Braun to $segno_to_name to inititate P_name to "CANNOT-GET-PATH". 
       21*    Modified 02 Feb 85 by B. Braun to have the dp_dir and dp_name set in $init_deadproc and NOT in $create_uid_hash.
       22**/
       23 
       24 /* parameters */
       25 
       26 dcl P_amu_info_ptr			ptr;
       27 dcl P_bt				fixed bin (24);
       28 dcl P_caller			char(*);
       29 dcl P_code			fixed bin (35);
       30 dcl P_dir				char (168);
       31 dcl P_name			char (*);
       32 dcl P_ptr				ptr;
       33 dcl P_segno			fixed bin;
       34 
       35 /* External Entries */
       36 
       37 dcl amu_$create_translation		entry (ptr, fixed bin);
       38 dcl amu_$do_translation_segno	entry (ptr, fixed bin, ptr, fixed bin (35));
       39 dcl amu_$error_for_caller		entry options (variable);
       40 dcl amu_$hardcore_info_deadproc	entry (char(*), ptr, char (168), fixed bin (35));
       41 dcl amu_$kst_util_expand_uid_path	entry (ptr, (16) bit (36) aligned, char(*), fixed bin(35));
       42 dcl amu_$kst_util_segno_to_uid	entry (ptr, fixed bin, bit (36) aligned, fixed bin (35));
       43 dcl amu_$kst_util_segno_to_uid_path	entry (ptr, fixed bin, (16) bit (36) aligned, fixed bin (35));
       44 dcl amu_$kst_util_uid_to_kstep	entry (ptr, bit (36) aligned, fixed bin (18), fixed bin (35));
       45 dcl  amu_$temp_seg_get		entry (pointer, char (*), pointer, pointer);
       46 dcl amu_$temp_seg_release_all		entry (ptr);
       47 dcl amu_$terminate_translation          entry (ptr);
       48 dcl amu_$translate_allocate		entry (ptr, fixed bin);
       49 dcl amu_$translate_add		entry (ptr, ptr, fixed bin, fixed bin (35));
       50 dcl amu_$translate_get		entry (ptr, fixed bin, ptr, fixed bin (35));
       51 dcl cv_oct_check_			entry (char (*), fixed bin (35)) returns (fixed bin (35));
       52 dcl expand_pathname_		entry (char (*), char (*), char (*), fixed bin (35));
       53 dcl get_system_free_area_		entry returns (ptr);
       54 dcl get_temp_segment_		entry (char (*), ptr, fixed bin (35));
       55 dcl hash_$opt_size			entry (fixed bin) returns (fixed bin);
       56 dcl hcs_$make_seg			entry (char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35));
       57 dcl hcs_$star_			entry (char(*), char(*), fixed bin(2), ptr, fixed bin, ptr, ptr, fixed bin(35));
       58 dcl hcs_$status_long		entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
       59 dcl initiate_file_			entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
       60 dcl ioa_				entry () options (variable);
       61 dcl iox_$attach_name		entry (char (*), ptr, char (*), ptr, fixed bin (35));
       62 dcl iox_$close			entry (ptr, fixed bin (35));
       63 dcl iox_$detach_iocb		entry (ptr, fixed bin (35));
       64 dcl iox_$get_line			entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       65 dcl iox_$open			entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       66 dcl pathname_			entry (char(*), char(*)) returns(char(168));
       67 dcl phcs_$initiate			entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
       68 dcl phcs_$ring_0_peek		entry (ptr, ptr, fixed bin);
       69 dcl phcs_$terminate_noname		entry (ptr, fixed bin (35));
       70 dcl release_temp_segment_		entry (char (*), ptr, fixed bin (35));
       71 dcl ring0_get_$segptr		entry (char (*), char (*), ptr, fixed bin (35));
       72 dcl terminate_file_		entry (ptr, fixed bin(24), bit(*), fixed bin(35));
       73 
       74 /* External Static  */
       75 
       76 dcl (
       77      amu_et_$make_uid_hash,
       78      amu_et_$no_amu_ptr,
       79      amu_et_$no_kst,
       80      amu_et_$no_uid_hash,
       81      amu_et_$no_sl1_in_kst,
       82      amu_et_$no_sl1_uid,
       83      error_table_$action_not_performed,
       84      error_table_$end_of_info,
       85      error_table_$noentry
       86     )				fixed bin (35) ext static;
       87 
       88 /* Automatic */
       89 
       90 dcl af_lth			fixed bin (21);
       91 dcl af_ptr			ptr;
       92 dcl af_sw				bit(1);
       93 dcl attach_desc			char (200);
       94 dcl bitcount			fixed bin (24);
       95 dcl code				fixed bin (35);
       96 dcl cur_state			char (1);
       97 dcl deadproc_dir			char (168);
       98 dcl deadproc_name			char (32);
       99 dcl dlen				fixed bin;
      100 dcl dp_dir_path			char(168);
      101 dcl dseg_ptr			ptr;
      102 dcl expand_path			char (168);
      103 dcl i				fixed bin;
      104 dcl ignore			fixed bin(24);
      105 dcl iocbp				ptr;
      106 dcl 1 info,
      107       2 char_uid char (12),
      108       2 name char (32),
      109       2 newline char(1);
      110 dcl info_ptr			ptr;
      111 dcl kste_offset			fixed bin (18);
      112 dcl look_kst			bit (1);
      113 dcl n_read			fixed bin (21);
      114 dcl old_uid			fixed bin (35);
      115 dcl (rzdp, rzdsp)			ptr;
      116 dcl sl1_uid			bit(36) aligned;
      117 dcl system_area_ptr			ptr;
      118 dcl t_kst_path			char(168);
      119 dcl temp_dir			char (168);
      120 dcl temp_name			char (32);
      121 dcl temp_ptr			ptr;
      122 dcl 1 temp_translation		like translation;
      123 dcl temp_uid_table_ptr		ptr;
      124 dcl 1 tsdw			like sdw aligned;
      125 dcl uid_basep			ptr;
      126 dcl uid_path (16)			bit (36) aligned;
      127 
      128 /* Based */
      129 
      130 dcl af_str			char (af_lth) varying based (af_ptr);
      131 dcl based_uid			bit (36) aligned based (uid_basep);
      132 dcl data				char (n_read) based (info_ptr);
      133 
      134 /* Areas */
      135 
      136 dcl system_area			area based (system_area_ptr);
      137 
      138 /* Internal Static */
      139 
      140 dcl who_ami			char (32) init ("amu_deadproc_") int static options(constant);
      141 
      142 /* Builtins */
      143 
      144 dcl (addr, addrel, after,
      145      baseno, binary, convert,
      146      divide, fixed, hbound, index,
      147      lbound, max, null, ptr,
      148      reverse, rtrim, size, sum,
      149      substr, unspec)		builtin;
      150 
      151 /* Conditions */
      152 
      153 dcl cleanup			condition;
      154 
      155 /*****************************************************************************/
      156 
      157 amu_deadproc_$create_uid_hash: entry(P_dir, P_code);
      158 
      159     amu_info_ptr, status_ptr, kstp, old_uid_table_ptr = null ();
      160     t_kst_path = "";
      161     code = 0;
      162 
      163     on cleanup begin;
      164        if status_ptr ^= null() then free status_branch in (amu_area);
      165        if kstp ^= null() then call terminate_file_(kstp, ignore, "0010"b, (0));
      166        if old_uid_table_ptr ^= null() then call terminate_file_(old_uid_table_ptr, ignore, "0010"b, (0));
      167        if amu_info_ptr ^= null () then call amu_$terminate_translation (amu_info_ptr);
      168        end;
      169 
      170     call expand_pathname_ (P_dir, deadproc_dir, deadproc_name, code);
      171     if code ^= 0 then goto END_CREATE;
      172 
      173     dp_dir_path = pathname_ (deadproc_dir, deadproc_name);
      174     t_kst_path = pathname_ (dp_dir_path, "kst");
      175     call initiate_file_ (dp_dir_path, "kst", R_ACCESS, kstp, (0), code);
      176     if kstp = null () then do;
      177        code = amu_et_$no_kst;
      178        goto END_CREATE;
      179        end;
      180 
      181     call amu_$create_translation (amu_info_ptr,SAVED_PROC_TYPE);
      182     if amu_info_ptr = null () then do;
      183        code = amu_et_$no_amu_ptr;
      184        goto END_CREATE;
      185        end;
      186 
      187     allocate status_branch in (amu_area) set (status_ptr);
      188     call hcs_$status_long (">", "sl1", 0, status_ptr, null (), code);
      189     if code ^= 0 then do;
      190        code = amu_et_$no_sl1_uid;
      191        goto CREATE_UID_ERR;
      192        end;
      193 
      194     sl1_uid = status_branch.long.uid;
      195 
      196     call hcs_$make_seg (dp_dir_path, "uid_hash_table", "", RW_ACCESS_BIN, old_uid_table_ptr, code);
      197     if code ^= 0 then do;
      198        code = amu_et_$make_uid_hash;
      199        goto CREATE_UID_ERR;
      200        end;
      201 
      202     allocate_uid_hash = hash_$opt_size (max((kst.highseg - kst.lowseg), divide(fixed("7777"b3,17),3,17)));
      203     old_uid_table.max_uid_ind = allocate_uid_hash;
      204     old_uid_table.hash_factor = 3;
      205     old_uid_table.uid_array (*).uid = ""b;
      206     old_uid_table.uid_array (*).seg_name,
      207        old_uid_table.dp_name,
      208        old_uid_table.dp_dir,
      209        old_uid_table.sys_release = "";
      210 
      211     call add_sl1_segs_to_hash (sl1_uid, code);
      212     if code ^= 0 then  goto CREATE_UID_ERR;
      213 
      214 CREATE_UID_ERR:
      215 
      216     if status_ptr ^= null () then free status_branch in (amu_area);
      217     if kstp ^= null() then call terminate_file_(kstp, ignore, "0010"b, (0));
      218     if old_uid_table_ptr ^= null() then call terminate_file_(old_uid_table_ptr, ignore, "0010"b, (0));
      219     if amu_info_ptr ^= null () then call amu_$terminate_translation (amu_info_ptr);
      220 
      221 END_CREATE:
      222     P_code = code;    
      223     return;
      224 
      225 /*****************************************************************************/
      226 
      227 amu_deadproc_$cur_dp:
      228 	entry (P_amu_info_ptr);
      229 
      230 	cur_state = ">";
      231 	af_sw = "0"b;
      232 	goto COMMON_NAME;	
      233 
      234 /*****************************************************************************/
      235 
      236 amu_deadproc_$name_dp:
      237 	entry (P_amu_info_ptr);
      238 	cur_state = " ";
      239 	af_sw = "0"b;
      240 	goto COMMON_NAME;
      241 
      242 /*****************************************************************************/
      243 
      244 amu_deadproc_$name_dp_af:
      245 	entry (P_amu_info_ptr, af_ptr, af_lth);
      246 
      247 	cur_state = " ";
      248 	af_sw = "1"b;
      249 
      250 COMMON_NAME:
      251 
      252 	amu_info_ptr = P_amu_info_ptr;
      253 	old_uid_table_ptr = amu_info.fdump_info_ptr;
      254 	if af_sw then af_str =  rtrim(old_uid_table.dp_dir) || ">" || rtrim(old_uid_table.dp_name);
      255 	else call ioa_ ("^1a DP ""^a"" from directory ^a Sys-Release ^a",cur_state,
      256 	     old_uid_table.dp_name,old_uid_table.dp_dir,
      257 	     old_uid_table.sys_release);
      258 	return;
      259 
      260 /*****************************************************************************/
      261 
      262 amu_deadproc_$init_deadproc:
      263      entry (P_caller, P_dir, P_amu_info_ptr, P_code);
      264 
      265      call amu_$create_translation (amu_info_ptr, SAVED_PROC_TYPE);
      266      if amu_info_ptr = null () then do;
      267         P_code = error_table_$action_not_performed;
      268         call amu_$error_for_caller (amu_info_ptr, P_code, P_caller, "Unable to create the amu_ translation for ^a.", P_dir);
      269         return;
      270         end;
      271      P_amu_info_ptr = amu_info_ptr;
      272     amu_info.process_info_ptr = null();
      273     amu_info.fdump_info_ptr = null();
      274     amu_info.copy_chain = null();
      275     old_uid_table_ptr = null();
      276     dseg_ptr, iocbp, temp_ptr, temp_uid_table_ptr = null();
      277 
      278     on cleanup begin;   
      279        if iocbp ^= null() then do;
      280           call iox_$close (iocbp, (0));
      281           call iox_$detach_iocb (iocbp, (0));
      282 	end;
      283        if temp_uid_table_ptr ^= null() then call terminate_file_(temp_uid_table_ptr, (0), "0010"b, (0));
      284        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      285      end;
      286 
      287     allocate process_info in (amu_area) set (amu_info.process_info_ptr);
      288     call amu_$translate_allocate (amu_info_ptr, 25);
      289 
      290     dp_dir_path = P_dir;
      291     call expand_pathname_ (P_dir, deadproc_dir, deadproc_name, code);
      292     if code ^= 0 then do;
      293        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Expanding the pathname ^a.", P_dir);
      294        P_code = code;
      295        return;
      296        end;
      297     call amu_$hardcore_info_deadproc (P_caller, amu_info_ptr, dp_dir_path, code);
      298     if code ^= 0 then do;
      299        P_code = code;
      300        return;
      301        end;
      302     
      303 
      304     kstp = process_info.kst.local_ptr; 
      305 
      306     /* setup uid_hash_table */
      307 
      308     call initiate_file_ (dp_dir_path, "uid_hash_table", R_ACCESS, temp_uid_table_ptr, (0), code);    
      309     if temp_uid_table_ptr = null () then do;
      310        code = amu_et_$no_uid_hash;
      311        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Initiating ^a.", pathname_(dp_dir_path, "uid_hash_table"));
      312        P_code = code;
      313        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      314        goto END_INIT;
      315        end;
      316 
      317     call amu_$temp_seg_get (amu_info_ptr, "DP " || rtrim(deadproc_name), amu_info.copy_chain, old_uid_table_ptr);
      318     
      319     /* copy old_uid_hash contents to the user process area. */
      320 
      321     allocate_uid_hash =  temp_uid_table_ptr -> old_uid_table.max_uid_ind;
      322     old_uid_table_ptr -> old_uid_table = temp_uid_table_ptr -> old_uid_table;
      323 
      324     amu_info.fdump_info_ptr = old_uid_table_ptr;
      325 
      326     /* set name and dir in old_uid_table */
      327     old_uid_table.dp_dir = deadproc_dir;
      328     old_uid_table.dp_name = deadproc_name;
      329 
      330     info_ptr = addr (info);
      331     uid_basep = addr (old_uid);
      332     attach_desc = "vfile_ " || rtrim (dp_dir_path) || ">pdir_info";
      333     call iox_$attach_name ("amu_dp_sw", iocbp, attach_desc, null (), code);
      334     if code ^= 0 then do;
      335        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Attaching switch ^a to read ^a.", 
      336 			    attach_desc, pathname_(dp_dir_path, "pdir_info"));
      337        P_code = code;
      338        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      339        goto END_INIT;
      340        end;
      341 
      342     call iox_$open (iocbp, 1, "0"b, code);
      343     if code ^= 0 then do;
      344        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Reading ^a.", pathname_(dp_dir_path, "pdir_info"));
      345        P_code = code;
      346        call iox_$detach_iocb (iocbp, code);
      347        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      348        goto END_INIT;
      349        end;
      350 
      351     /* First line is the system release_id */
      352     call iox_$get_line (iocbp, info_ptr, 45, n_read, code);
      353     if code ^= 0 then do;
      354        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Reading ^a.", pathname_(dp_dir_path, "pdir_info"));
      355        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      356        goto ERROR;
      357        end;
      358 
      359     old_uid_table.sys_release = rtrim (info.char_uid);
      360     translation_ptr = addr(temp_translation);
      361     /* get dseg ptr */
      362     call amu_$do_translation_segno(amu_info_ptr, 0, dseg_ptr, code);
      363     if code ^= 0 then do;
      364        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Getting dseg ptr ^a.", pathname_(dp_dir_path, "dseg"));
      365        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      366        goto ERROR;
      367        end;
      368     
      369     /* get next line to begin loop */
      370 
      371     call iox_$get_line (iocbp, info_ptr, 45, n_read, code);
      372     if code ^= 0 then do;
      373        call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Reading ^a.", pathname_(dp_dir_path, "pdir_info"));
      374        if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      375        goto ERROR;
      376        end;
      377 
      378     do while (code = 0);
      379        old_uid = cv_oct_check_ (info.char_uid, code);
      380        temp_name = info.name;
      381        call initiate_file_ (dp_dir_path, temp_name, R_ACCESS, temp_ptr, bitcount, code);
      382        if temp_ptr = null () then do;
      383           call ioa_ ("Cannot initiate ^a", pathname_(dp_dir_path, temp_name));
      384 	code = 0;
      385 	goto NEXT;
      386           end;
      387        call check_name (temp_name, temp_ptr, look_kst);
      388        if look_kst then do;
      389 	call amu_$kst_util_uid_to_kstep (kstp, based_uid, kste_offset, code);
      390 	if code ^= 0 then do;
      391 	   if code = error_table_$noentry then do;
      392 	      call ioa_ ("Cannot translate ^a with uid ^a.", temp_name, char_uid);
      393 	      code = 0;
      394 	      end;
      395 	  else do; 
      396 	     call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Unable to get the kst entry for ^a with uid ^a.",
      397 				  temp_name, char_uid);
      398 	     code = 0;
      399 	     end;
      400 	  end;
      401 	else do;
      402 	   kstep = addrel (kstp, kste_offset);
      403 	   call add_hash (old_uid, (temp_name),"1"b);
      404 	   call add_trans (temp_ptr, (kste.segno), dseg_ptr, code);
      405 	   if code ^= 0 then do;
      406                 call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Unable to add ^a (segno ^o) to uid_hash_table.",
      407 				   rtrim(temp_name), kste.segno);
      408 	      if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      409 	      goto ERROR;
      410 	      end;
      411 	   end;
      412 	end;
      413 NEXT:  
      414        call iox_$get_line (iocbp, info_ptr, 45, n_read, code);
      415        if (code ^= 0) & (code ^= error_table_$end_of_info) then do;
      416 	call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Getting next line of ^a.",
      417 			       pathname_(dp_dir_path, "pdir_info"));
      418           if amu_info_ptr ^= null() then call amu_deadproc_$term_deadproc (amu_info_ptr, (0));
      419           goto ERROR;
      420 	end;
      421        end;
      422 
      423     code = 0;
      424     
      425     call get_stack_base(dp_dir_path, dseg_ptr, code);
      426 ERROR:
      427     P_code = code;
      428     call iox_$close (iocbp, (0));
      429     call iox_$detach_iocb (iocbp, (0));
      430 
      431 END_INIT:
      432     if temp_uid_table_ptr ^= null() then call terminate_file_(temp_uid_table_ptr, (0), "0010"b, (0));
      433     return;
      434 	
      435 /*****************************************************************************/
      436 
      437 amu_deadproc_$segno_to_name:
      438      entry (P_amu_info_ptr, P_segno, P_name, P_code);
      439 
      440 /*  Given a segment number, finds the name of the segment by comparing the uid
      441*    of the segment number with the uids in the kst until a match is found.
      442*
      443*    P_amu_info_ptr     pointer to amu_info structure (input).
      444*    P_segno	   segment number (input).
      445*    P_name	   name of the segment (output).
      446*    P_code	   standard error code (output).
      447**/
      448     amu_info_ptr = P_amu_info_ptr;
      449     P_name, expand_path = "CANNOT-GET-PATH";
      450     P_code, code = 0;
      451 
      452     /* first check to see if one of those "special segnos" */
      453     if P_segno = hardcore_info.stack_0 then do;
      454        P_name = "stack_0";
      455        goto RET_NAME;
      456        end;
      457 
      458     old_uid_table_ptr = amu_info.fdump_info_ptr;
      459     kstp = process_info.kst.local_ptr;
      460     uid_basep = addr (old_uid);
      461 
      462     call amu_$kst_util_segno_to_uid (kstp, P_segno, based_uid, code);  /* get the uid */
      463     if code ^= 0 then goto RET_NAME;
      464     call get_name_from_hash (based_uid, expand_path);	/* see if its already in the hash table		*/
      465     if expand_path = "" then do;			/* Not in the hash table			*/
      466        call amu_$kst_util_segno_to_uid_path (kstp, P_segno, uid_path, code);
      467        if code ^= 0 then goto RET_NAME;
      468        call amu_$kst_util_expand_uid_path (kstp, uid_path, expand_path, code);
      469        if code ^= 0 then goto RET_NAME;
      470        else do;
      471           call add_hash (old_uid, expand_path, "0"b);
      472 	end;
      473        end;
      474 
      475 RET_NAME: 
      476     P_name = expand_path;
      477     P_code = code;
      478     return;
      479 	
      480 /*****************************************************************************/
      481 
      482 amu_deadproc_$name_to_segno:
      483      entry (P_amu_info_ptr, P_name,  P_segno, P_code);
      484 
      485 /*  Given a segment name, finds the segment number by looping through the
      486*    uid_hash_table until finding the uid which corressponds with the given
      487*    name. Then, we loop through the kst matching on uids to get the segment 
      488*    number.
      489*
      490*    P_amu_info_ptr     pointer to amu_info structure (input).
      491*    P_name	   name of the segment (input).
      492*    P_segno	   segment number (output).
      493*    P_code	   standard error code (output).
      494**/
      495 dcl no_match bit(1);
      496 dcl segno fixed bin;
      497 dcl match_name char(256) var;
      498 
      499     amu_info_ptr = P_amu_info_ptr;
      500     P_segno, segno = -1;
      501     P_code, code = 0;
      502 
      503     old_uid_table_ptr = amu_info.fdump_info_ptr;
      504     kstp = process_info.kst.local_ptr;
      505     uid_basep = addr (old_uid);
      506     match_name = rtrim(P_name);
      507     if index (match_name, ">" ) > 0 then 		/* In this case match on entryname only		*/
      508        match_name = reverse(substr(reverse(match_name), 1, index(reverse(match_name), ">") -1));
      509     
      510     /* Loop through the uid_hash_table until a match on the names is found. */
      511 
      512     no_match = "1"b;
      513     do i = 0 to old_uid_table.max_uid_ind while (no_match);
      514        if index(old_uid_table.uid_array (i).seg_name, match_name) > 0 then do;
      515           no_match = "0"b;
      516 	based_uid = old_uid_table.uid_array (i).uid;
      517 	end;
      518        end;
      519 
      520     if no_match then do;
      521        code = error_table_$noentry;
      522        goto RET_SEGNO;
      523        end;
      524 
      525     /* Now, with the uid get its kste which contains the segno. */
      526 
      527     kste_offset = 0;
      528     call amu_$kst_util_uid_to_kstep (kstp, based_uid, kste_offset, code); 
      529     kstep = addrel (kstp, kste_offset);
      530     if code = 0 then segno = kste.segno;
      531 
      532 RET_SEGNO: 
      533     P_segno = segno;
      534     P_code = code;
      535     return;
      536 
      537 /*****************************************************************************/
      538 
      539 amu_deadproc_$expand_to_ptr:
      540      entry (P_amu_info_ptr, P_segno, P_ptr, P_bt);
      541 	amu_info_ptr = P_amu_info_ptr;
      542 	old_uid_table_ptr = amu_info.fdump_info_ptr;
      543 	P_ptr = null ();
      544 	P_bt = 0;
      545 	kstp = process_info.kst.local_ptr;
      546 	call amu_$kst_util_segno_to_uid_path (kstp, P_segno, uid_path, code);
      547 	if code ^= 0 then return;
      548 
      549           call amu_$kst_util_expand_uid_path (kstp, uid_path, expand_path, code);
      550 	if code ^= 0 then return;
      551 
      552 	call expand_pathname_ (expand_path, temp_dir, temp_name, code);
      553 	if code ^= 0 then return;
      554 	call initiate_file_ (temp_dir, temp_name, R_ACCESS, temp_ptr, bitcount, code);
      555 	P_ptr = temp_ptr;
      556 	P_bt = bitcount;
      557 	return;
      558 
      559 /*****************************************************************************/
      560 
      561 amu_deadproc_$term_deadproc:
      562      entry (P_amu_info_ptr, P_code);
      563 
      564     amu_info_ptr = P_amu_info_ptr;		/* terminate all translated segs */
      565     if amu_info.translation_table_ptr ^= null then do;
      566        do i = lbound (translation_table.array, 1) to hbound (translation_table.array, 1);
      567 	if (translation_table.used (i) = "1"b) & (translation_table.array (i).flags.in_dp_dir) then do;
      568 	   temp_ptr = translation_table.array (i).part1.ptr;
      569 	   if temp_ptr ^= null() then call terminate_file_(temp_ptr, (0), "0010"b, (0));
      570 	   end;
      571 	end;
      572        free translation_table in (amu_area);
      573        amu_info.translation_table_ptr = null ();
      574        end;
      575 
      576     if amu_info.process_info_ptr ^= null () then do;
      577        free process_info in (amu_area);
      578        amu_info.process_info_ptr = null ();
      579        end;	
      580 				/* release all temp segs known in copy_chain */
      581     call amu_$temp_seg_release_all (amu_info.copy_chain);
      582     return;
      583 
      584 /*****************************************************************************/
      585 
      586 add_hash:
      587      proc (fixed_uid, name,pd_sw);
      588 dcl fixed_uid fixed bin (35);
      589 dcl in_uid bit (36);
      590 dcl name char (168);
      591 dcl ind fixed bin;
      592 dcl pd_sw bit (1);
      593 dcl short_path char(168);
      594 dcl code fixed bin(35);
      595 dcl amu_$get_l1dir_shortname  entry(char(*), char(*), fixed bin(35));  
      596 
      597     short_path = "";
      598     code = 0;
      599     ind = hash_uid (fixed_uid);
      600     in_uid = unspec (fixed_uid);
      601     old_uidep = addr (old_uid_table.uid_array (ind));
      602     if old_uide.uid = ""b then goto FILL_TABLE;
      603     else do;
      604        if old_uide.uid = in_uid then goto END_ADD_HASH;
      605        do ind = (ind + 1) to old_uid_table.max_uid_ind;     /* check it sequentially			*/
      606 	old_uidep = addr (old_uid_table.uid_array (ind));
      607 	if old_uide.uid = in_uid then goto END_ADD_HASH;
      608 	if old_uide.uid = ""b then goto FILL_TABLE;
      609 	end;
      610        end;
      611 
      612 FILL_TABLE:
      613     old_uide.uid = in_uid;
      614     if pd_sw then old_uide.seg_name = "[pd]>" || rtrim (name);
      615     else do;
      616        call amu_$get_l1dir_shortname (name, short_path, code);
      617        if code = 0 then old_uide.seg_name = short_path;
      618        else  old_uide.seg_name = rtrim (name);
      619        end;
      620 
      621 END_ADD_HASH:
      622     return;
      623 
      624 end add_hash;
      625 
      626 /*****************************************************************************/
      627 
      628 add_sl1_segs_to_hash:   proc (sl1_uid, code);
      629 
      630 dcl sl1_uid bit(36) aligned;
      631 dcl code fixed bin(35);
      632 
      633 dcl seg_ind fixed bin;
      634 dcl got_one bit(1);
      635 
      636     got_one = "0"b;
      637     do seg_ind = kst.highseg to kst.lowseg by -1;
      638        code = 0;
      639        call amu_$kst_util_segno_to_uid_path (kstp, seg_ind, uid_path, code);
      640        if code ^= 0 then goto NEXT_ONE;
      641        if uid_path (2) = sl1_uid then do;
      642           call amu_$kst_util_expand_uid_path (kstp, uid_path, expand_path, code);
      643           if code ^= 0 then goto END_ADD_SL1;
      644           got_one = "1"b;
      645 	call add_hash (fixed(kst_entry(seg_ind).uid,35), expand_path, "0"b);
      646 	end;
      647 NEXT_ONE:
      648        end;    /* loop */
      649 END_ADD_SL1:
      650   
      651     if ^(got_one) then code = amu_et_$no_sl1_in_kst;
      652     else code = 0;
      653 
      654 end add_sl1_segs_to_hash;
      655 
      656 /*****************************************************************************/
      657 
      658 add_trans:
      659      proc (seg_ptr, segnum, dseg_ptr, code);
      660 
      661 dcl code fixed bin(35);
      662 dcl  segnum fixed bin;
      663 dcl  seg_ptr ptr;
      664 dcl sdwp ptr;
      665 dcl bound fixed bin(19);
      666 dcl dseg_ptr ptr;
      667 
      668           code = 0;
      669 				/* get a pointer to the SDW for the segment */
      670           sdwp = addrel(dseg_ptr, 2*segnum);
      671 	
      672           bound = (binary (sdwp->sdw.bound, 14) +1) * 16; /* get number of words */
      673 
      674 	translation.segno = segnum;
      675 	translation.flags = "0"b;
      676 	translation.flags.in_perm_seg = "1"b;
      677 	translation.flags.in_dp_dir = "1"b;
      678 	translation.part1.ptr = seg_ptr;
      679 	translation.part1.lth = bound;
      680 	translation.part2.ptr = null ();
      681 	translation.part2.lth = 0;
      682 	call amu_$translate_add (amu_info_ptr, translation_ptr, (translation.segno), code);
      683 	if code ^= 0 then do;
      684 	     call ioa_ ("translation error segment ^o ^a", segnum, data);
      685 	     call amu_$translate_get (amu_info_ptr,segnum,translation_ptr,code);
      686 	     if code ^= 0 then do;
      687 		call ioa_ ("No trans (get trans)");
      688 		return;
      689 	     end;
      690 	     call ioa_ ("translation is: segno ^o ^[two_part^1x]^[in_dump^x]^[in_temp_seg^x]^[in_perm_seg^x]^[in_dp_dir]",
      691 		     translation.segno, translation.two_part,translation.in_dump,translation.in_temp_seg,
      692 		     translation.in_perm_seg,translation.in_dp_dir);
      693 	     call ioa_ ("Part1.ptr = ^p lth = ^o (oct)",translation.part1.ptr,translation.part1.lth);
      694 	     call ioa_ ("Part2.ptr = ^p lth = ^o (oct)",translation.part2.ptr,translation.part2.lth);
      695 	     return;
      696 	     end;
      697      end add_trans;
      698 
      699 /*****************************************************************************/
      700 
      701 check_name:
      702      proc (name, seg_ptr, look);
      703 dcl  name char (32);
      704 dcl  seg_ptr ptr;
      705 dcl  look bit (1);
      706 
      707 	look = "0"b;
      708 	if name = "dseg" then return;
      709 	if name = "pds" then return;
      710 	if name = "prds" then return;
      711 	if name = "kst" then return;
      712 	if name = "stack_0" then return;
      713 	look = "1"b;
      714      end check_name;
      715 
      716 /*****************************************************************************/
      717 
      718 get_name_from_hash:
      719      proc (in_uid, segname);
      720 
      721 dcl  in_uid bit (36) aligned;
      722 dcl  segname char (*);
      723 dcl  ind fixed bin;
      724 
      725     ind = hash_uid (fixed (in_uid, 35));
      726     old_uidep = addr (old_uid_table.uid_array (ind));
      727     if old_uide.uid = in_uid then do;
      728        segname = old_uide.seg_name;
      729        return;
      730        end;
      731     else if old_uide.uid ^= ""b then do;
      732        do ind = (ind + 1) to old_uid_table.max_uid_ind while (old_uide.uid ^= ""b);
      733 	old_uidep = addr (old_uid_table.uid_array (ind));
      734 	if old_uide.uid = in_uid then do;
      735 	   segname = old_uide.seg_name;
      736 	   return;
      737 	   end;
      738 	end;
      739        end;
      740     segname = "";
      741     return;
      742 end get_name_from_hash;
      743 
      744 /*****************************************************************************/
      745 
      746 get_stack_base: proc (dirname, dseg_ptr, code);
      747 
      748 dcl dirname char(*);
      749 dcl code fixed bin (35);
      750 dcl dseg_ptr ptr;
      751 dcl stackbase  char(32);
      752 dcl stackno fixed bin;
      753 dcl sb_ptr ptr;
      754 
      755     code = 0;
      756     star_entry_ptr = null ();
      757     star_names_ptr = null ();
      758     sb_ptr = null();
      759     system_area_ptr = get_system_free_area_();
      760     on condition (cleanup) begin;
      761        if star_names_ptr ^= null () then free star_names in (system_area);
      762        if star_entry_ptr ^= null () then free star_entries in (system_area);
      763        end;
      764 
      765     call hcs_$star_ (dirname, "stack_base_*", star_BRANCHES_ONLY, system_area_ptr, star_entry_count, star_entry_ptr, 
      766 		star_names_ptr, code);
      767 
      768     if code ^= 0 | star_entry_count = 0 then do;
      769        call amu_$error_for_caller (amu_info_ptr, 0, P_caller, "Unable to determine the stack base.");
      770        code = error_table_$action_not_performed;
      771        goto END_STACK_BASE;
      772        end;
      773 
      774     stackbase = "";
      775     stackbase = after(star_names(1), "stack_base_");
      776     if stackbase ^= "" then do;
      777        /* get stack base seg number */
      778        stackno = convert(stackno, rtrim(stackbase));
      779 
      780        hardcore_info.segno.stack_0 = stackno;
      781        call initiate_file_ (dirname, "stack_0", R_ACCESS, sb_ptr, (0), code);
      782        if sb_ptr = null() then do;
      783           call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Initiating ^a.", pathname_(dirname, "stack_0"));
      784 	code = 0;  /* non-fatal error */
      785 	goto END_STACK_BASE;
      786 	end;
      787        call add_trans (sb_ptr, stackno, dseg_ptr, code);
      788        if code ^= 0 then do;
      789           call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Unable to add ^a (segno ^o) to uid_hash_table.", 
      790 			       pathname_(dirname, "stack_0"), stackno);
      791           code = 0;
      792           goto END_STACK_BASE;
      793           end;
      794        end;
      795 END_STACK_BASE:
      796     if star_names_ptr ^= null () then free star_names in (system_area);
      797     if star_entry_ptr ^= null () then free star_entries in (system_area);
      798     revert cleanup;
      799 
      800 end get_stack_base;
      801 
      802 /*****************************************************************************/
      803 
      804 hash_uid:
      805      proc (in_uid) returns (fixed bin);
      806 dcl  in_uid fixed bin (35);
      807 dcl  rev_uid bit (12);
      808 dcl  hash_ind fixed bin;
      809 	rev_uid = reverse (substr (unspec (in_uid), 25, 12));
      810 	hash_ind = divide (fixed (rev_uid, 17), hash_factor, 17);
      811 	if hash_ind > old_uid_table.max_uid_ind then do;
      812 	     call ioa_ ("hash_ind = ^d  old_uid_table.max_uid_ind = ^d (dec) uid = ^12.3b", 
      813 		     hash_ind, old_uid_table.max_uid_ind, unspec(in_uid));
      814 	end;
      815 	return (hash_ind);
      816      end hash_uid;
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      817 
  2     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  2     2 
  2     3 /* This structure contains information about the hardcore supervisor address
  2     4*   space for an address translation. */
  2     5 
  2     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  2     7 
  2     8     2 pointers,					/* assorted pointers to various useful items */
  2     9       3 slt aligned,				/* SLT */
  2    10         4 fptr pointer unaligned,			/* address in foreign address space */
  2    11         4 lptr pointer unaligned,			/* location in local address space */
  2    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  2    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  2    14 
  2    15       3 sst aligned like hardcore_info.slt,		/* SST */
  2    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  2    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  2    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  2    19 
  2    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  2    21       3 prds fixed bin (15),				/* segno of PRDS */
  2    22       3 dseg fixed bin (15),				/* DSEG */
  2    23       3 pds fixed bin (15),				/* PDS */
  2    24       3 kst fixed bin (15),				/* KST */
  2    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  2    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  2    27 
  2    28     2 apt,					/* information about the APT */
  2    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  2    30       3 local_ptr pointer unaligned,
  2    31       3 count fixed bin,				/* number of APTEs */
  2    32       3 size fixed bin,				/* size of a single APTE */
  2    33 
  2    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  2    35 
  2    36     2 pad1 fixed bin;
  2    37 
  2    38 dcl hardcore_cur_ptr ptr;
  2    39 
  2    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  2    41     2 sltp ptr,
  2    42     2 sltntp ptr,
  2    43     2 defp ptr,
  2    44     2 sstp ptr,
  2    45     2 tc_datap ptr,
  2    46     2 sstntp ptr,
  2    47     2 uptp ptr;
  2    48 	
  2    49     
  2    50 
  2    51 
  2    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      818 
  3     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  3     2 
  3     3 dcl 1 amu_info aligned based (amu_info_ptr),
  3     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  3     5     2 flags aligned,
  3     6       3 early_dump bit(1) unal,
  3     7       3 pad  bit(35) unal,
  3     8     2 type fixed bin unal,				/* One of the types below */
  3     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  3    10     2 chain,					/* a chain of all the amu_info's which exist */
  3    11       3 prev pointer unaligned,
  3    12       3 next pointer unaligned,
  3    13 
  3    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  3    15 
  3    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  3    17 						/*   SEE: amu_translation.incl.pl1 */
  3    18     2 fdump_info_ptr pointer, 			
  3    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  3    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  3    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  3    22 						/* See: amu_old_uid_table			*/
  3    23 	
  3    24 
  3    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  3    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  3    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  3    28 						/*   SEE: amu_copy_info.incl.pl1 */
  3    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  3    30 						/*   SEE: amu_process_info.incl.pl1 */
  3    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  3    32 
  3    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  3    34 
  3    35     2 error_info,					/* various info about how amu_error_ is to behave */
  3    36       3 error_flags aligned,
  3    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  3    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  3    39         4 pad bit (34) unaligned,
  3    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  3    41     2 definitions_info_ptr ptr;
  3    42 
  3    43 dcl  amu_area area based (amu_info.area_ptr);
  3    44 
  3    45 dcl  amu_info_ptr pointer;
  3    46 
  3    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  3    48      FDUMP_PROCESS_TYPE	init (1038),
  3    49      ONLINE_TYPE		init (1039),
  3    50      ONLINE_PROCESS_TYPE	init (1040),
  3    51      NETWORK_FDUMP_TYPE	init (1041),
  3    52      NETWORK_ONLINE_TYPE	init (1042),
  3    53      SAVED_PROC_TYPE	init (1043),
  3    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  3    55 
  3    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  3    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  3    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  3    59 
  3    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  3    61 
  3    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      819 
  4     1 /* Begin amu_old_uid_table.incl.pl1 */
  4     2 
  4     3 dcl old_uid_table_ptr ptr;
  4     4 	
  4     5 
  4     6 dcl 1 old_uid_table based (old_uid_table_ptr),
  4     7       2 dp_dir char (168),
  4     8       2 dp_name char (32),
  4     9       2 sys_release char (8),
  4    10       2 max_uid_ind fixed bin,
  4    11       2 hash_factor fixed bin,
  4    12       2 uid_array (0 :allocate_uid_hash) like old_uide;
  4    13       
  4    14 dcl old_uidep ptr;
  4    15 
  4    16 dcl 1 old_uide based (old_uidep),
  4    17       2 uid bit (36),
  4    18       2 seg_name char (168);
  4    19       
  4    20 dcl allocate_uid_hash fixed bin;
  4    21       
      820 
  5     1 /*	BEGIN INCLUDE FILE amu_process_info.incl.pl1	*/
  5     2 
  5     3 /* This structure describes information about a single process in an address
  5     4*   translation. It is only relevant for translations involving the online system
  5     5*   or an FDUMP. */
  5     6 
  5     7 dcl 1 process_info aligned based (amu_info.process_info_ptr), /* information about a single process */
  5     8     2 pid bit (36) aligned,				/* process_id of this process */
  5     9     2 address_map_ptr pointer unaligned,		/* pointer to address map */
  5    10     2 idx fixed bin,				/* index of process in FDUMP, or apte index if online */
  5    11     2 state fixed bin,				/* state, from the APTE -- only good for FDUMP */
  5    12 
  5    13     2 dbr fixed bin (71),				/* DBR of this process */
  5    14 
  5    15     2 apte aligned, 				/* pointer to this process's APTE */
  5    16       3 foreign_ptr pointer unaligned,
  5    17       3 local_ptr pointer unaligned,
  5    18     2 prds aligned like process_info.apte, 		/* and PRDS, IFF it has one (is running) -- volatile */
  5    19     2 dseg aligned like process_info.apte, 		/* DSEG -- These values must be constantly recalculated */
  5    20     2 pds aligned like process_info.apte,		/* PDS --- for an online process, if phcs transparency */
  5    21     2 kst aligned like process_info.apte,		/* KST --- is not in use. */
  5    22 
  5    23     2 dump_segx,					/* index of first and last seg belonging to this */
  5    24       3 first fixed bin,				/* process in bos_dump.seg_array, or zero if none */
  5    25       3 last fixed bin,				/* this information is only valid for a process in a dump */
  5    26 
  5    27     2 pad1 fixed bin;
  5    28 
  5    29 /*	END INCLUDE FILE amu_process_info.incl.pl1	*/
      821 
  6     1 /*	BEGIN INCLUDE FILE amu_translation.incl.pl1	*/
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(87-01-16,Parisek), approve(87-07-16,MCR7746),
  6     7*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
  6     8*     Added the "replaced" field to record whether a segment was replaced by
  6     9*     another segment via the "replace" request.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 
  6    13 dcl 1 translation_table aligned based (amu_info.translation_table_ptr),
  6    14     2 n_entries fixed bin,
  6    15     2 max_entries fixed bin,
  6    16 
  6    17     2 valid_array aligned,				/* one bit for each valid segno */
  6    18       3 valid (0 : 4095) bit (1) unaligned,
  6    19     2 used_array aligned,				/* one bit for each existing translation */
  6    20       3 used (0 : 4095) bit (1) unaligned,
  6    21 
  6    22     2 array (alloc_translation_table_max_entries refer (translation_table.max_entries)) like translation;
  6    23 
  6    24 dcl 1 translation aligned based (translation_ptr),	/* a single translation */
  6    25     2 segno fixed bin (18) unsigned unaligned,		/* foreign segno for this translation */
  6    26     2 flags unaligned,
  6    27       3 two_part bit (1) unaligned,			/* segment is in two pieces -- from an FDUMP */
  6    28       3 in_dump bit (1) unaligned,			/* segment is part of an FDUMP image */
  6    29       3 in_temp_seg bit (1) unaligned,			/* segment is a copy at the base of a temp segment */
  6    30       3 in_perm_seg bit (1) unaligned,			/* segment is in the file system */
  6    31       3 in_dp_dir bit (1) unaligned,
  6    32       3 replaced bit (1) unaligned,
  6    33       3 pad bit (12) unaligned,
  6    34     2 part1,					/* pointer to first (possibly only) part of segment */
  6    35       3 ptr pointer unaligned,
  6    36       3 lth fixed bin (19),
  6    37     2 part2 like translation.part1;
  6    38 
  6    39 dcl  alloc_translation_table_max_entries fixed bin;
  6    40 dcl  translation_ptr pointer;
  6    41 
  6    42 /*	END INCLUDE FILE amu_translation.incl.pl1	*/
      822 
  7     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  7     2 
  7     3 
  7     4 /* Template for an entry. Length = 38 words */
  7     5 
  7     6 dcl  ep ptr;
  7     7 
  7     8 dcl 1 entry based (ep) aligned,
  7     9 
  7    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  7    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  7    12 
  7    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  7    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  7    15 
  7    16     2 uid bit (36),					/* unique id of entry */
  7    17 
  7    18     2 dtem bit (36),				/* date-time entry modified */
  7    19 
  7    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  7    21     2 pad0 bit (17),
  7    22     2 nnames fixed bin (17),				/* number of names for this entry */
  7    23 
  7    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  7    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  7    26 
  7    27     2 author,					/* user who created branch */
  7    28       3 pers_rp bit (18),				/* name of user who created branch */
  7    29       3 proj_rp bit (18),				/* project of user who created branch */
  7    30 
  7    31       3 tag char (1),				/* tag of user who created branch */
  7    32       3 pad1 char (3),
  7    33 
  7    34     2 primary_name bit (504),				/* first name on name list */
  7    35 
  7    36     2 dtd bit (36),					/* date time dumped */
  7    37 
  7    38     2 pad2 bit (36),
  7    39 
  7    40 
  7    41 /* the declarations below are for branch only */
  7    42 
  7    43 
  7    44     2 pvid bit (36),				/* physical volume id */
  7    45 
  7    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  7    47     2 pad3 bit (18),
  7    48 
  7    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  7    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  7    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  7    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  7    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  7    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  7    55     2 audit_flag bit (1),				/* segment must be audited for security */
  7    56     2 security_oosw bit (1),				/* security out of service switch */
  7    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  7    58     2 master_dir bit (1),				/* TRUE for master directory */
  7    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  7    60     2 pad4 bit (11),
  7    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  7    62 
  7    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  7    64 
  7    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  7    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  7    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  7    68 
  7    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  7    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  7    71 
  7    72     2 bc_author,					/* user who last set the bit count */
  7    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  7    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  7    75 
  7    76       3 tag char (1),				/* tag of user who set the bit count */
  7    77       3 pad5 bit (2),
  7    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  7    79 
  7    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  7    81 
  7    82     2 pad6 bit (36),
  7    83 
  7    84     2 checksum bit (36),				/* checksum from dtd */
  7    85 
  7    86     2 owner bit (36);				/* uid of containing directory */
  7    87 
  7    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      823 
  8     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  8     2 /* Modified 8/74 for NSS */
  8     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  8     4 /* Modified 3/82 BIM for change pclock */
  8     5 /* format: style3 */
  8     6 
  8     7 /* Template for the directory header. Length = 64 words. */
  8     8 
  8     9 dcl  dp ptr;
  8    10 
  8    11 dcl 1 dir based (dp) aligned,
  8    12 
  8    13    2 modify bit (36),				/* Process ID of last modifier */
  8    14    2 type bit (18) unaligned,			/* type of object = dir header */
  8    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  8    16     2 dtc (3),					/* date-time checked by salvager array */
  8    17       3 date bit (36),				/* the date */
  8    18       3 error bit (36),				/* what errors were discovered */
  8    19 
  8    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  8    21 
  8    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  8    23 
  8    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  8    25 
  8    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  8    27 
  8    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  8    29     2 version_number fixed bin (17),			/* version number of header */
  8    30 
  8    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  8    32     2 pad2 bit (18),
  8    33 
  8    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  8    35     2 pad3 bit (18),
  8    36 
  8    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  8    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  8    39 
  8    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  8    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  8    42 
  8    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  8    44     2 dir_count fixed bin (17),			/* number of directory branches */
  8    45 
  8    46     2 lcount fixed bin (17),				/* number of links */
  8    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  8    48 
  8    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  8    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  8    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  8    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  8    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  8    54     2 pad4 bit (14),
  8    55 
  8    56     2 iacl_count (0:7),
  8    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  8    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  8    59 
  8    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  8    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  8    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  8    63 
  8    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  8    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  8    66 
  8    67     2 htsize fixed bin (17),				/* size of hash table */
  8    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  8    69 
  8    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  8    71     2 pad6 fixed bin (17),
  8    72 
  8    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  8    74     2 pad7 bit (18)) unaligned,
  8    75 
  8    76     2 dts bit (36),					/* date-time directory last salvaged */
  8    77 
  8    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  8    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  8    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  8    81     2 checksum bit (36),				/* checksummed from uid on */
  8    82     2 owner bit (36);				/* uid of parent dir */
  8    83 
  8    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  8    85 
  8    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      824 
  9     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  9     2 
  9     3 /* Template for names of branches or links. Length = 14 words. */
  9     4 
  9     5 dcl np ptr;
  9     6 
  9     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  9     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  9     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  9    10 
  9    11     2 type bit (18) unaligned,			/* type = dir name */
  9    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  9    13 
  9    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  9    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  9    16 
  9    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  9    18     2 pad3 bit (18) unal,
  9    19 
  9    20     2 name char(32) aligned,
  9    21 
  9    22     2 checksum bit (36),				/* checksum from entry_rp */
  9    23 
  9    24     2 owner bit (36);				/* uid of entry */
  9    25 
  9    26 
  9    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      825 
 10     1 /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
 10     2 
 10     3 /*
 10     4*Modified March 1976 by R. Bratt 
 10     5*Modified November 1984 to remove hdr, Keith Loepere. */
 10     6 
 10     7 
 10     8 /****^  HISTORY COMMENTS:
 10     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
 10    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
 10    11*     Add warning on use of kste.entryp.
 10    12*                                                   END HISTORY COMMENTS */
 10    13 
 10    14 
 10    15 dcl  pds$kstp ext ptr,
 10    16     (kstp, kstep) ptr;
 10    17 
 10    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
 10    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
 10    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
 10    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
 10    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
 10    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
 10    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
 10    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
 10    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
 10    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
 10    28     2 template bit (1) unaligned,			/* this is a template kst if set */
 10    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
 10    30     2 unused_2 bit (9) unaligned,
 10    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
 10    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
 10    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
 10    34     2 end_of_kst bit (36);
 10    35 
 10    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
 10    37     2 fp bit (18) unaligned,				/* forward rel pointer */
 10    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
 10    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
 10    40     2 entryp ptr unaligned,				/* branch pointer */
 10    41 						/* See WARNING below for requirements to use entryp. */
 10    42     2 uid bit (36) aligned,				/* unique identifier */
 10    43     2 access_information unaligned,
 10    44       3 dtbm bit (36),				/* date time branch modified */
 10    45       3 extended_access bit (33),			/* extended access from the branch */
 10    46       3 access bit (3),				/* rew */
 10    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
 10    48     2 pad1 bit (3) unaligned,
 10    49     2 flags unaligned,
 10    50       3 dirsw bit (1),				/* directory switch */
 10    51       3 allow_write bit (1),				/* set if initiated with write permission */
 10    52       3 priv_init bit (1),				/* privileged initiation */
 10    53       3 tms bit (1),				/* transparent modification switch */
 10    54       3 tus bit (1),				/* transparent usage switch */
 10    55       3 tpd bit (1),				/* transparent paging device switch */
 10    56       3 audit bit (1),				/* audit switch */
 10    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
 10    58       3 pad bit (3),
 10    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
 10    60 
 10    61 
 10    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 10    63 /*							       */
 10    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
 10    65 /* entry associated with the kst entry, you must first validate its value    */
 10    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
 10    67 /* the containing directory.  The containing directory must remain locked    */
 10    68 /* during the entire period when kste.entryp and the directory entry are     */
 10    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
 10    70 /* longer be used to get a pointer to the entry within the unlocked	       */
 10    71 /* directory since the dir entry could have been moved within the directory  */
 10    72 /* by another processor.					       */
 10    73 /*							       */
 10    74 /* If you only need a pointer to the directory containing the associated     */
 10    75 /* dir entry (but not to the dir entry itself), you can use:	       */
 10    76 /*    pointer (kste.entryp, 0)				       */
 10    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
 10    78 /*							       */
 10    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 10    80 
 10    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      826 
 11     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
 11     2 
 11     3 dcl  sdwp ptr;
 11     4 
 11     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
 11     6 
 11     7    (2 add bit (24),					/* main memory address of page table */
 11     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
 11     9     2 df bit (1),					/* directed fault bit (0 => fault) */
 11    10     2 df_no bit (2),				/* directed fault number */
 11    11 
 11    12     2 pad1 bit (1),
 11    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
 11    14     2 access,					/* access bits */
 11    15       3 read bit (1),				/* read permission bit */
 11    16       3 execute bit (1),				/* execute permission bit */
 11    17       3 write bit (1),				/* write permission bit */
 11    18       3 privileged bit (1),				/* privileged bit */
 11    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
 11    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
 11    21     2 cache bit (1),				/* cache enable bit */
 11    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
 11    23 
 11    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
 11    25 
 11    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      827 
 12     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
 12     2 
 12     3 /* This include file contains structures for the hcs_$star_,
 12     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
 12     5*
 12     6*   Written 23 October 1978 by Monte Davidoff.
 12     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
 12     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
 12     9**/
 12    10 
 12    11 /* automatic */
 12    12 
 12    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
 12    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
 12    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
 12    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
 12    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
 12    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
 12    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
 12    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
 12    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
 12    22 
 12    23 /* based */
 12    24 
 12    25 /* hcs_$star_ entry structure */
 12    26 
 12    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
 12    28         2 type fixed binary (2) unsigned unaligned,
 12    29 						/* storage system type */
 12    30         2 nnames fixed binary (16) unsigned unaligned,
 12    31 						/* number of names of entry that match star_name */
 12    32         2 nindex fixed binary (18) unsigned unaligned;
 12    33 						/* index of first name in star_names */
 12    34 
 12    35 /* hcs_$star_ name structure */
 12    36 
 12    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
 12    38 
 12    39 /* hcs_$star_list_ branch structure */
 12    40 
 12    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 12    42         2 type fixed binary (2) unsigned unaligned,
 12    43 						/* storage system type */
 12    44         2 nnames fixed binary (16) unsigned unaligned,
 12    45 						/* number of names of entry that match star_name */
 12    46         2 nindex fixed binary (18) unsigned unaligned,
 12    47 						/* index of first name in star_list_names */
 12    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
 12    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
 12    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
 12    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
 12    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
 12    53         2 pad bit (7) unaligned,
 12    54         2 records fixed binary (18) unsigned unaligned;
 12    55 						/* records used by branch */
 12    56 
 12    57 /* hcs_$star_dir_list_ branch structure */
 12    58 
 12    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 12    60         2 type fixed binary (2) unsigned unaligned,
 12    61 						/* storage system type */
 12    62         2 nnames fixed binary (16) unsigned unaligned,
 12    63 						/* number of names of entry that match star_name */
 12    64         2 nindex fixed binary (18) unsigned unaligned,
 12    65 						/* index of first name in star_list_names */
 12    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
 12    67         2 pad bit (36) unaligned,
 12    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
 12    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
 12    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
 12    71         2 bit_count fixed binary (24) unaligned;
 12    72 						/* bit count of the branch */
 12    73 
 12    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
 12    75 
 12    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 12    77         2 type fixed binary (2) unsigned unaligned,
 12    78 						/* storage system type */
 12    79         2 nnames fixed binary (16) unsigned unaligned,
 12    80 						/* number of names of entry that match star_name */
 12    81         2 nindex fixed binary (18) unsigned unaligned,
 12    82 						/* index of first name in star_list_names */
 12    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
 12    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
 12    85         2 pathname_len fixed binary (18) unsigned unaligned,
 12    86 						/* length of the pathname of the link */
 12    87         2 pathname_index fixed binary (18) unsigned unaligned;
 12    88 						/* index of start of pathname in star_list_names */
 12    89 
 12    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
 12    91 
 12    92 declare  star_list_names char (32) based (star_list_names_ptr)
 12    93 	dimension (star_links (star_branch_count + star_link_count).nindex
 12    94 	 + star_links (star_branch_count + star_link_count).nnames
 12    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
 12    96 	   * binary (
 12    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
 12    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
 12    99 
 12   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
 12   101 
 12   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
 12   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
 12   104 
 12   105 /* internal static */
 12   106 
 12   107 /* star_select_sw values */
 12   108 
 12   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
 12   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
 12   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
 12   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
 12   113          fixed binary (3) internal static options (constant) initial (5);
 12   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
 12   115          fixed binary (3) internal static options (constant) initial (7);
 12   116 
 12   117 /* storage system types */
 12   118 
 12   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
 12   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
 12   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
 12   122 
 12   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
      828 
 13     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
 13     2 
 13     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
 13     4 
 13     5 /* This include file contains branch and link structures returned by
 13     6*   hcs_$status_ and hcs_$status_long. */
 13     7 
 13     8 dcl 1 status_branch aligned based (status_ptr),
 13     9     2 short aligned,
 13    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
 13    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
 13    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
 13    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
 13    14       3 dtu bit (36) unaligned,			/* date/time last used */
 13    15       3 mode bit (5) unaligned,			/* caller's effective access */
 13    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
 13    17       3 pad1 bit (8) unaligned,
 13    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
 13    19 
 13    20 /* Limit of information returned by hcs_$status_ */
 13    21 
 13    22     2 long aligned,
 13    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
 13    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
 13    25       3 lvid bit (36) unaligned,			/* logical volume ID */
 13    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
 13    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
 13    28       3 pad2 bit (8) unaligned,
 13    29       3 copy_switch bit (1) unaligned,			/* copy switch */
 13    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
 13    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
 13    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
 13    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
 13    34       3 pad3 bit (5) unaligned,
 13    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
 13    36       3 uid bit (36) unaligned;			/* unique ID */
 13    37 
 13    38 dcl 1 status_link aligned based (status_ptr),
 13    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
 13    40     2 nnames fixed bin (16) unaligned unsigned,
 13    41     2 names_relp bit (18) unaligned,
 13    42     2 dtem bit (36) unaligned,
 13    43     2 dtd bit (36) unaligned,
 13    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
 13    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
 13    46 
 13    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
 13    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
 13    49 						/* array of names returned */
 13    50      status_pathname character (status_link.pathname_length) aligned
 13    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
 13    52 						/* link target path */
 13    53      status_area_ptr pointer,
 13    54      status_ptr pointer;
 13    55 
 13    56 dcl (Link initial (0),
 13    57      Segment initial (1),
 13    58      Directory initial (2)) fixed bin internal static options (constant);
 13    59 						/* values for type fields declared above */
 13    60 
 13    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      829 
      830 
      831 
      832      end amu_deadproc_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/28/87  0927.6  amu_deadproc_.pl1                 >spec>install>MR12.1-1049>amu_deadproc_.pl1
817          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
818          2    11/20/84  0854.8  amu_hardcore_info.incl.pl1        >ldd>include>amu_hardcore_info.incl.pl1
819          3    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
820          4    09/22/83  1102.5  amu_old_uid_table.incl.pl1        >ldd>include>amu_old_uid_table.incl.pl1
821          5    11/20/84  0856.2  amu_process_info.incl.pl1         >ldd>include>amu_process_info.incl.pl1
822          6    07/28/87  0927.3  amu_translation.incl.pl1          >spec>install>MR12.1-1049>amu_translation.incl.pl1
823          7    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
824          8    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
825          9    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
826         10    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
827         11    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
828         12    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
829         13    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_amu_info_ptr                         parameter       pointer                  dcl 26 set ref 227 236 244 250 262 271* 437 448 482
                                                                                  499 539 541 561 564
P_bt                                   parameter       fixed bin(24,0)          dcl 27 set ref 539 544* 556*
P_caller                               parameter       char                     unaligned dcl 28 set ref 262 268* 293* 297* 311*
                                                                                  335* 344* 354* 364* 373* 396* 406* 416* 769* 783*
                                                                                  789*
P_code                                 parameter       fixed bin(35,0)          dcl 29 set ref 157 221* 262 267* 268* 294* 299* 312*
                                                                                  337* 345* 426* 437 450* 477* 482 501* 534* 561
P_dir                                  parameter       char(168)                unaligned dcl 30 set ref 157 170* 262 268* 290 291*
                                                                                  293*
P_name                                 parameter       char                     unaligned dcl 31 set ref 437 449* 454* 475* 482 506
P_ptr                                  parameter       pointer                  dcl 32 set ref 539 543* 555*
P_segno                                parameter       fixed bin(17,0)          dcl 33 set ref 437 453 462* 466* 482 500* 532* 539
                                                                                  546*
RW_ACCESS_BIN                   000055 constant        fixed bin(5,0)           initial dcl 1-36 set ref 196*
R_ACCESS                        000045 constant        bit(3)                   initial unaligned dcl 1-11 set ref 175* 308* 381*
                                                                                  554* 781*
SAVED_PROC_TYPE                 000000 constant        fixed bin(17,0)          initial dcl 3-47 set ref 181* 265*
addr                                                   builtin function         dcl 144 ref 330 331 360 460 505 601 606 726 733
addrel                                                 builtin function         dcl 144 ref 402 529 670
af_lth                                 parameter       fixed bin(21,0)          dcl 90 ref 244 254
af_ptr                                 parameter       pointer                  dcl 91 ref 244 254
af_str                                 based           varying char             dcl 130 set ref 254*
af_sw                           000100 automatic       bit(1)                   unaligned dcl 92 set ref 231* 239* 248* 254
after                                                  builtin function         dcl 144 ref 775
allocate_uid_hash               000740 automatic       fixed bin(17,0)          dcl 4-20 set ref 202* 203 205 206 321* 322
amu_$create_translation         000010 constant        entry                    external dcl 37 ref 181 265
amu_$do_translation_segno       000012 constant        entry                    external dcl 38 ref 362
amu_$error_for_caller           000014 constant        entry                    external dcl 39 ref 268 293 311 335 344 354 364 373
                                                                                  396 406 416 769 783 789
amu_$get_l1dir_shortname        000126 constant        entry                    external dcl 595 ref 616
amu_$hardcore_info_deadproc     000016 constant        entry                    external dcl 40 ref 297
amu_$kst_util_expand_uid_path   000020 constant        entry                    external dcl 41 ref 468 549 642
amu_$kst_util_segno_to_uid      000022 constant        entry                    external dcl 42 ref 462
amu_$kst_util_segno_to_uid_path 000024 constant        entry                    external dcl 43 ref 466 546 639
amu_$kst_util_uid_to_kstep      000026 constant        entry                    external dcl 44 ref 389 528
amu_$temp_seg_get               000030 constant        entry                    external dcl 45 ref 317
amu_$temp_seg_release_all       000032 constant        entry                    external dcl 46 ref 581
amu_$terminate_translation      000034 constant        entry                    external dcl 47 ref 167 219
amu_$translate_add              000040 constant        entry                    external dcl 49 ref 682
amu_$translate_allocate         000036 constant        entry                    external dcl 48 ref 288
amu_$translate_get              000042 constant        entry                    external dcl 50 ref 685
amu_area                               based           area(1024)               dcl 3-43 ref 164 187 214 287 572 577
amu_et_$make_uid_hash           000104 external static fixed bin(35,0)          dcl 76 ref 198
amu_et_$no_amu_ptr              000106 external static fixed bin(35,0)          dcl 76 ref 183
amu_et_$no_kst                  000110 external static fixed bin(35,0)          dcl 76 ref 177
amu_et_$no_sl1_in_kst           000114 external static fixed bin(35,0)          dcl 76 ref 649
amu_et_$no_sl1_uid              000116 external static fixed bin(35,0)          dcl 76 ref 190
amu_et_$no_uid_hash             000112 external static fixed bin(35,0)          dcl 76 ref 310
amu_info                               based           structure                level 1 dcl 3-3
amu_info_ptr                    000732 automatic       pointer                  dcl 3-45 set ref 159* 164 167 167* 181* 182 187 214
                                                                                  219 219* 250* 253 265* 266 268* 271 272 273 274
                                                                                  284 284* 287 287 288* 293* 297* 304 311* 313 313*
                                                                                  317* 317 324 335* 338 338* 344* 347 347* 354* 355
                                                                                  355* 362* 364* 365 365* 373* 374 374* 396* 406*
                                                                                  408 408* 416* 418 418* 448* 453 458 459 499* 503
                                                                                  504 541* 542 545 564* 565 566 566 567 567 568 572
                                                                                  572 573 576 577 577 578 581 682* 685* 769* 780
                                                                                  783* 789*
apte                      6            based           structure                level 2 dcl 5-7
area_ptr                 10            based           pointer                  level 2 dcl 3-3 ref 164 187 214 287 572 577
array                   346            based           structure                array level 2 dcl 6-13 ref 566 566
attach_desc                     000101 automatic       char(200)                unaligned dcl 93 set ref 332* 333* 335*
based_uid                              based           bit(36)                  dcl 131 set ref 389* 462* 464* 516* 528*
binary                                                 builtin function         dcl 144 ref 672
bitcount                        000163 automatic       fixed bin(24,0)          dcl 94 set ref 381* 554* 556
bound                     1(01)        based           bit(14)                  level 2 in structure "sdw" packed unaligned dcl 11-5
                                                                                  in procedure "amu_deadproc_" ref 672
bound                           000102 automatic       fixed bin(19,0)          dcl 665 in procedure "add_trans" set ref 672* 679
char_uid                        000402 automatic       char(12)                 level 2 packed unaligned dcl 106 set ref 359 379*
                                                                                  392* 396*
cleanup                         000620 stack reference condition                dcl 153 ref 163 278 760 798
code                                   parameter       fixed bin(35,0)          dcl 631 in procedure "add_sl1_segs_to_hash" set ref
                                                                                  628 638* 639* 640 642* 643 649* 652*
code                                   parameter       fixed bin(35,0)          dcl 661 in procedure "add_trans" set ref 658 668*
                                                                                  682* 683 685* 686
code                            001066 automatic       fixed bin(35,0)          dcl 594 in procedure "add_hash" set ref 598* 616*
                                                                                  617
code                            000164 automatic       fixed bin(35,0)          dcl 95 in procedure "amu_deadproc_" set ref 161*
                                                                                  170* 171 175* 177* 183* 188* 189 190* 196* 197
                                                                                  198* 211* 212 221 291* 292 293* 294 297* 298 299
                                                                                  308* 310* 311* 312 333* 334 335* 337 342* 343 344*
                                                                                  345 346* 352* 353 354* 362* 363 364* 371* 372 373*
                                                                                  378 379* 381* 384* 389* 390 391 393* 396* 398*
                                                                                  404* 405 406* 413* 415 415 416* 423* 425* 426 450*
                                                                                  462* 463 466* 467 468* 469 477 501* 521* 528* 530
                                                                                  534 546* 547 549* 550 552* 553 554*
code                                   parameter       fixed bin(35,0)          dcl 749 in procedure "get_stack_base" set ref 746
                                                                                  755* 765* 768 770* 781* 783* 784* 787* 788 789*
                                                                                  791*
convert                                                builtin function         dcl 144 ref 778
copy_chain               20            based           pointer                  level 2 dcl 3-3 set ref 274* 317* 581*
cur_state                       000165 automatic       char(1)                  unaligned dcl 96 set ref 230* 238* 247* 255*
cv_oct_check_                   000044 constant        entry                    external dcl 51 ref 379
data                                   based           char                     unaligned dcl 132 set ref 684*
deadproc_dir                    000166 automatic       char(168)                unaligned dcl 97 set ref 170* 173* 291* 327
deadproc_name                   000240 automatic       char(32)                 unaligned dcl 98 set ref 170* 173* 291* 317 328
dirname                                parameter       char                     unaligned dcl 748 set ref 746 765* 781* 783* 783*
                                                                                  789* 789*
divide                                                 builtin function         dcl 144 ref 202 202 810
dp_dir                                 based           char(168)                level 2 packed unaligned dcl 4-6 set ref 206* 254
                                                                                  255* 327*
dp_dir_path                     000250 automatic       char(168)                unaligned dcl 100 set ref 173* 174* 175* 196* 290*
                                                                                  297* 308* 311* 311* 332 335* 335* 344* 344* 354*
                                                                                  354* 364* 364* 373* 373* 381* 383* 383* 416* 416*
                                                                                  425*
dp_name                  52            based           char(32)                 level 2 packed unaligned dcl 4-6 set ref 206* 254
                                                                                  255* 328*
dseg_ptr                        000322 automatic       pointer                  dcl 101 in procedure "amu_deadproc_" set ref 276*
                                                                                  362* 404* 425*
dseg_ptr                               parameter       pointer                  dcl 666 in procedure "add_trans" ref 658 670
dseg_ptr                               parameter       pointer                  dcl 750 in procedure "get_stack_base" set ref 746
                                                                                  787*
error_table_$action_not_performed
                                000120 external static fixed bin(35,0)          dcl 76 ref 267 770
error_table_$end_of_info        000122 external static fixed bin(35,0)          dcl 76 ref 415
error_table_$noentry            000124 external static fixed bin(35,0)          dcl 76 ref 391 521
expand_path                     000324 automatic       char(168)                unaligned dcl 102 set ref 449* 464* 465 468* 471*
                                                                                  475 549* 552* 642* 645*
expand_pathname_                000046 constant        entry                    external dcl 52 ref 170 291 552
fdump_info_ptr           14            based           pointer                  level 2 dcl 3-3 set ref 253 273* 324* 458 503 542
fixed                                                  builtin function         dcl 144 ref 202 202 645 645 725 725 810
fixed_uid                              parameter       fixed bin(35,0)          dcl 588 set ref 586 599* 600
flags                   346(18)        based           structure                array level 3 in structure "translation_table"
                                                                                  packed unaligned dcl 6-13 in procedure
                                                                                  "amu_deadproc_"
flags                     0(18)        based           structure                level 2 in structure "translation" packed unaligned
                                                                                  dcl 6-24 in procedure "amu_deadproc_" set ref 675*
get_system_free_area_           000050 constant        entry                    external dcl 53 ref 759
got_one                         001077 automatic       bit(1)                   unaligned dcl 634 set ref 636* 644* 649
hardcore_info                          based           structure                level 1 dcl 2-6
hardcore_info_ptr        16            based           pointer                  level 2 dcl 3-3 ref 453 780
hash_$opt_size                  000052 constant        entry                    external dcl 55 ref 202
hash_factor              65            based           fixed bin(17,0)          level 2 dcl 4-6 set ref 204* 810
hash_ind                        001127 automatic       fixed bin(17,0)          dcl 808 set ref 810* 811 812* 815
hbound                                                 builtin function         dcl 144 ref 566
hcs_$make_seg                   000054 constant        entry                    external dcl 56 ref 196
hcs_$star_                      000056 constant        entry                    external dcl 57 ref 765
hcs_$status_long                000060 constant        entry                    external dcl 58 ref 188
highseg                   1            based           fixed bin(17,0)          level 2 dcl 10-18 ref 202 202 637
i                               000376 automatic       fixed bin(17,0)          dcl 103 set ref 513* 514 516* 566* 567 567 568*
ignore                          000377 automatic       fixed bin(24,0)          dcl 104 set ref 165* 166* 217* 218*
in_dp_dir                 0(22)        based           bit(1)                   level 3 in structure "translation" packed unaligned
                                                                                  dcl 6-24 in procedure "amu_deadproc_" set ref 677*
                                                                                  690*
in_dp_dir               346(22)        based           bit(1)                   array level 4 in structure "translation_table"
                                                                                  packed unaligned dcl 6-13 in procedure
                                                                                  "amu_deadproc_" ref 567
in_dump                   0(19)        based           bit(1)                   level 3 packed unaligned dcl 6-24 set ref 690*
in_perm_seg               0(21)        based           bit(1)                   level 3 packed unaligned dcl 6-24 set ref 676* 690*
in_temp_seg               0(20)        based           bit(1)                   level 3 packed unaligned dcl 6-24 set ref 690*
in_uid                                 parameter       bit(36)                  dcl 721 in procedure "get_name_from_hash" ref 718
                                                                                  725 725 727 734
in_uid                          001012 automatic       bit(36)                  unaligned dcl 589 in procedure "add_hash" set ref
                                                                                  600* 604 607 612
in_uid                                 parameter       fixed bin(35,0)          dcl 806 in procedure "hash_uid" ref 804 809 812 812
ind                             001013 automatic       fixed bin(17,0)          dcl 591 in procedure "add_hash" set ref 599* 601
                                                                                  605* 605* 606*
ind                             001116 automatic       fixed bin(17,0)          dcl 723 in procedure "get_name_from_hash" set ref
                                                                                  725* 726 732* 732* 733*
index                                                  builtin function         dcl 144 ref 507 507 514
info                            000402 automatic       structure                level 1 packed unaligned dcl 106 set ref 330
info_ptr                        000416 automatic       pointer                  dcl 110 set ref 330* 352* 371* 413* 684
initiate_file_                  000062 constant        entry                    external dcl 59 ref 175 308 381 554 781
ioa_                            000064 constant        entry                    external dcl 60 ref 255 383 392 684 687 690 693 694
                                                                                  812
iocbp                           000400 automatic       pointer                  dcl 105 set ref 276* 279 280* 281* 333* 342* 346*
                                                                                  352* 371* 413* 428* 429*
iox_$attach_name                000066 constant        entry                    external dcl 61 ref 333
iox_$close                      000070 constant        entry                    external dcl 62 ref 280 428
iox_$detach_iocb                000072 constant        entry                    external dcl 63 ref 281 346 429
iox_$get_line                   000074 constant        entry                    external dcl 64 ref 352 371 413
iox_$open                       000076 constant        entry                    external dcl 65 ref 342
kst                                    based           structure                level 1 dcl 10-18 in procedure "amu_deadproc_"
kst                      16            based           structure                level 2 in structure "process_info" dcl 5-7
                                                                                  in procedure "amu_deadproc_"
kst_entry               110            based           structure                array level 2 dcl 10-18
kste                                   based           structure                level 1 dcl 10-36
kste_offset                     000420 automatic       fixed bin(18,0)          dcl 111 set ref 389* 402 527* 528* 529
kstep                           000746 automatic       pointer                  dcl 10-15 set ref 402* 404 406 529* 530
kstp                            000744 automatic       pointer                  dcl 10-15 set ref 159* 165 165* 175* 176 202 202 202
                                                                                  202 217 217* 304* 389* 402 459* 462* 466* 468*
                                                                                  504* 528* 529 545* 546* 549* 637 637 639* 642* 645
                                                                                  645
lbound                                                 builtin function         dcl 144 ref 566
local_ptr                17            based           pointer                  level 3 packed unaligned dcl 5-7 ref 304 459 504 545
long                      4            based           structure                level 2 dcl 13-8
look                                   parameter       bit(1)                   unaligned dcl 705 set ref 701 707* 713*
look_kst                        000421 automatic       bit(1)                   unaligned dcl 112 set ref 387* 388
lowseg                                 based           fixed bin(17,0)          level 2 dcl 10-18 ref 202 202 637 645 645
lth                       2            based           fixed bin(19,0)          level 3 in structure "translation" dcl 6-24
                                                                                  in procedure "amu_deadproc_" set ref 679* 693*
lth                       4            based           fixed bin(19,0)          level 3 in structure "translation" dcl 6-24
                                                                                  in procedure "amu_deadproc_" set ref 681* 694*
match_name                      000630 automatic       varying char(256)        dcl 497 set ref 506* 507 507* 507 507 514
max                                                    builtin function         dcl 144 ref 202 202
max_entries               1            based           fixed bin(17,0)          level 2 dcl 6-13 ref 566 572
max_uid_ind              64            based           fixed bin(17,0)          level 2 dcl 4-6 set ref 203* 321 513 605 732 811
                                                                                  812*
n_read                          000422 automatic       fixed bin(21,0)          dcl 113 set ref 352* 371* 413* 684 684
name                                   parameter       char(32)                 unaligned dcl 703 in procedure "check_name" ref 701
                                                                                  708 709 710 711 712
name                                   parameter       char(168)                unaligned dcl 590 in procedure "add_hash" set ref
                                                                                  586 614 616* 618
name                      3     000402 automatic       char(32)                 level 2 in structure "info" packed unaligned dcl 106
                                                                                  in procedure "amu_deadproc_" set ref 380
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed unsigned unaligned dcl 12-27
                                                                                  ref 761 795
no_match                        000626 automatic       bit(1)                   unaligned dcl 495 set ref 512* 513 515* 520
null                                                   builtin function         dcl 144 ref 159 164 165 166 167 176 182 188 188 214
                                                                                  217 218 219 266 272 273 274 275 276 279 283 284
                                                                                  309 313 333 333 338 347 355 365 374 382 408 418
                                                                                  431 543 565 569 573 576 578 680 756 757 758 761
                                                                                  762 782 795 797
old_uid                         000423 automatic       fixed bin(35,0)          dcl 114 set ref 331 379* 403* 460 471* 505
old_uid_table                          based           structure                level 1 unaligned dcl 4-6 set ref 322* 322
old_uid_table_ptr               000734 automatic       pointer                  dcl 4-3 set ref 159* 166 166* 196* 203 204 205 206
                                                                                  206 206 206 218 218* 253* 254 254 255 255 255 275*
                                                                                  317* 322 324 327 328 359 458* 503* 513 514 516
                                                                                  542* 601 605 606 726 732 733 810 811 812
old_uide                               based           structure                level 1 packed unaligned dcl 4-16
old_uidep                       000736 automatic       pointer                  dcl 4-14 set ref 601* 602 604 606* 607 608 612 614
                                                                                  617 618 726* 727 728 731 732 733* 734 735
part1                   347            based           structure                array level 3 in structure "translation_table"
                                                                                  dcl 6-13 in procedure "amu_deadproc_"
part1                     1            based           structure                level 2 in structure "translation" dcl 6-24
                                                                                  in procedure "amu_deadproc_"
part1                     1     000566 automatic       structure                level 2 in structure "temp_translation" unaligned
                                                                                  dcl 122 in procedure "amu_deadproc_"
part2                     3            based           structure                level 2 dcl 6-24
pathname_                       000100 constant        entry                    external dcl 66 ref 173 174 311 311 335 335 344 344
                                                                                  354 354 364 364 373 373 383 383 416 416 783 783
                                                                                  789 789
pd_sw                                  parameter       bit(1)                   unaligned dcl 592 ref 586 614
pointers                               based           structure                level 2 dcl 2-6
process_info                           based           structure                level 1 dcl 5-7 ref 287 577
process_info_ptr         22            based           pointer                  level 2 dcl 3-3 set ref 272* 287* 304 459 504 545
                                                                                  576 577 578*
ptr                       1            based           pointer                  level 3 in structure "translation" packed unaligned
                                                                                  dcl 6-24 in procedure "amu_deadproc_" set ref 678*
                                                                                  693*
ptr                     347            based           pointer                  array level 4 in structure "translation_table"
                                                                                  packed unaligned dcl 6-13 in procedure
                                                                                  "amu_deadproc_" ref 568
ptr                       3            based           pointer                  level 3 in structure "translation" packed unaligned
                                                                                  dcl 6-24 in procedure "amu_deadproc_" set ref 680*
                                                                                  694*
rev_uid                         001126 automatic       bit(12)                  unaligned dcl 807 set ref 809* 810
reverse                                                builtin function         dcl 144 ref 507 507 507 809
rtrim                                                  builtin function         dcl 144 ref 254 254 317 332 359 406 406 506 614 618
                                                                                  778
sb_ptr                          000112 automatic       pointer                  dcl 753 set ref 758* 781* 782 787*
sdw                                    based           structure                level 1 dcl 11-5
sdwp                            000100 automatic       pointer                  dcl 664 set ref 670* 672
seg_ind                         001076 automatic       fixed bin(17,0)          dcl 633 set ref 637* 639* 645 645*
seg_name                  1            based           char(168)                level 2 in structure "old_uide" packed unaligned
                                                                                  dcl 4-16 in procedure "amu_deadproc_" set ref 614*
                                                                                  617* 618* 728 735
seg_name                 67            based           char(168)                array level 3 in structure "old_uid_table" packed
                                                                                  unaligned dcl 4-6 in procedure "amu_deadproc_" set
                                                                                  ref 206* 514
seg_ptr                                parameter       pointer                  dcl 704 in procedure "check_name" ref 701
seg_ptr                                parameter       pointer                  dcl 663 in procedure "add_trans" ref 658 678
segname                                parameter       char                     unaligned dcl 722 set ref 718 728* 735* 740*
segno                    16            based           structure                level 2 in structure "hardcore_info" dcl 2-6
                                                                                  in procedure "amu_deadproc_"
segno                                  based           fixed bin(18,0)          level 2 in structure "translation" packed unsigned
                                                                                  unaligned dcl 6-24 in procedure "amu_deadproc_"
                                                                                  set ref 674* 682 690*
segno                           000627 automatic       fixed bin(17,0)          dcl 496 in procedure "amu_deadproc_" set ref 500*
                                                                                  530* 532
segno                     0(18)        based           fixed bin(17,0)          level 2 in structure "kste" packed unaligned
                                                                                  dcl 10-36 in procedure "amu_deadproc_" set ref 404
                                                                                  406* 530
segnum                                 parameter       fixed bin(17,0)          dcl 662 set ref 658 670 674 684* 685*
short_path                      001014 automatic       char(168)                unaligned dcl 593 set ref 597* 616* 617
sl1_uid                                parameter       bit(36)                  dcl 630 in procedure "add_sl1_segs_to_hash" ref 628
                                                                                  641
sl1_uid                         000424 automatic       bit(36)                  dcl 116 in procedure "amu_deadproc_" set ref 194*
                                                                                  211*
slt                                    based           structure                level 3 dcl 2-6
stack_0                  22            based           fixed bin(15,0)          level 3 dcl 2-6 set ref 453 780*
stackbase                       000100 automatic       char(32)                 unaligned dcl 751 set ref 774* 775* 776 778
stackno                         000110 automatic       fixed bin(17,0)          dcl 752 set ref 778* 778 780 787* 789*
star_BRANCHES_ONLY              000062 constant        fixed bin(2,0)           initial dcl 12-110 set ref 765*
star_entries                           based           structure                array level 1 dcl 12-27 ref 762 797
star_entry_count                000750 automatic       fixed bin(17,0)          dcl 12-14 set ref 761 762 765* 768 795 797
star_entry_ptr                  000752 automatic       pointer                  dcl 12-15 set ref 756* 761 762 762 765* 795 797 797
star_names                             based           char(32)                 array unaligned dcl 12-37 ref 761 775 795
star_names_ptr                  000754 automatic       pointer                  dcl 12-19 set ref 757* 761 761 765* 775 795 795
status_branch                          based           structure                level 1 dcl 13-8 ref 164 187 214
status_ptr                      000756 automatic       pointer                  dcl 13-47 set ref 159* 164 164 187* 188* 194 214 214
substr                                                 builtin function         dcl 144 ref 507 809
sum                                                    builtin function         dcl 144 ref 761 795
sys_release              62            based           char(8)                  level 2 packed unaligned dcl 4-6 set ref 206* 255*
                                                                                  359*
system_area                            based           area(1024)               dcl 136 ref 761 762 795 797
system_area_ptr                 000426 automatic       pointer                  dcl 117 set ref 759* 761 762 765* 795 797
t_kst_path                      000430 automatic       char(168)                unaligned dcl 118 set ref 160* 174*
temp_dir                        000502 automatic       char(168)                unaligned dcl 119 set ref 552* 554*
temp_name                       000554 automatic       char(32)                 unaligned dcl 120 set ref 380* 381* 383* 383* 387*
                                                                                  392* 396* 403 406 406 552* 554*
temp_ptr                        000564 automatic       pointer                  dcl 121 set ref 276* 381* 382 387* 404* 554* 555
                                                                                  568* 569 569*
temp_translation                000566 automatic       structure                level 1 unaligned dcl 122 set ref 360
temp_uid_table_ptr              000574 automatic       pointer                  dcl 123 set ref 276* 283 283* 308* 309 321 322 431
                                                                                  431*
terminate_file_                 000102 constant        entry                    external dcl 72 ref 165 166 217 218 283 431 569
translation                            based           structure                level 1 dcl 6-24
translation_ptr                 000742 automatic       pointer                  dcl 6-40 set ref 360* 674 675 676 677 678 679 680
                                                                                  681 682* 682 685* 690 690 690 690 690 690 693 693
                                                                                  694 694
translation_table                      based           structure                level 1 dcl 6-13 ref 572
translation_table_ptr
                         12            based           pointer                  level 2 dcl 3-3 set ref 565 566 566 567 567 568 572
                                                                                  573*
two_part                  0(18)        based           bit(1)                   level 3 packed unaligned dcl 6-24 set ref 690*
uid                     114            based           bit(36)                  array level 3 in structure "kst" dcl 10-18
                                                                                  in procedure "amu_deadproc_" ref 645 645
uid                                    based           bit(36)                  level 2 in structure "old_uide" packed unaligned
                                                                                  dcl 4-16 in procedure "amu_deadproc_" set ref 602
                                                                                  604 607 608 612* 727 731 732 734
uid                      66            based           bit(36)                  array level 3 in structure "old_uid_table" packed
                                                                                  unaligned dcl 4-6 in procedure "amu_deadproc_" set
                                                                                  ref 205* 516
uid                      11            based           bit(36)                  level 3 in structure "status_branch" packed
                                                                                  unaligned dcl 13-8 in procedure "amu_deadproc_"
                                                                                  ref 194
uid_array                66            based           structure                array level 2 packed unaligned dcl 4-6 set ref 601
                                                                                  606 726 733
uid_basep                       000576 automatic       pointer                  dcl 125 set ref 331* 389 460* 462 464 505* 516 528
uid_path                        000600 automatic       bit(36)                  array dcl 126 set ref 466* 468* 546* 549* 639* 641
                                                                                  642*
unspec                                                 builtin function         dcl 144 ref 600 809 812 812
used                    164            based           bit(1)                   array level 3 packed unaligned dcl 6-13 ref 567
used_array              164            based           structure                level 2 dcl 6-13

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 3-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 3-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 3-58
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
Directory                              internal static fixed bin(17,0)          initial dcl 13-56
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 3-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 3-47
Link                                   internal static fixed bin(17,0)          initial dcl 13-56
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 3-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 3-60
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Segment                                internal static fixed bin(17,0)          initial dcl 13-56
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
alloc_translation_table_max_entries    automatic       fixed bin(17,0)          dcl 6-39
baseno                                                 builtin function         dcl 144
dir                                    based           structure                level 1 dcl 8-11
dlen                                   automatic       fixed bin(17,0)          dcl 99
dp                                     automatic       pointer                  dcl 8-9
entry                                  based           structure                level 1 dcl 7-8
ep                                     automatic       pointer                  dcl 7-6
get_temp_segment_               000000 constant        entry                    external dcl 54
hardcore_cur                           based           structure                level 1 unaligned dcl 2-40
hardcore_cur_ptr                       automatic       pointer                  dcl 2-38
names                                  based           structure                level 1 dcl 9-7
np                                     automatic       pointer                  dcl 9-5
pds$kstp                               external static pointer                  dcl 10-15
phcs_$initiate                  000000 constant        entry                    external dcl 67
phcs_$ring_0_peek               000000 constant        entry                    external dcl 68
phcs_$terminate_noname          000000 constant        entry                    external dcl 69
ptr                                                    builtin function         dcl 144
release_temp_segment_           000000 constant        entry                    external dcl 70
ring0_get_$segptr               000000 constant        entry                    external dcl 71
rzdp                                   automatic       pointer                  dcl 115
rzdsp                                  automatic       pointer                  dcl 115
sdwa                                   based           structure                array level 1 dcl 11-24
sdwp                                   automatic       pointer                  dcl 11-3
size                                                   builtin function         dcl 144
star_ALL_ENTRIES                       internal static fixed bin(2,0)           initial dcl 12-111
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 12-114
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 12-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 12-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 12-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 12-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 12-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 12-13
star_dir_list_branch                   based           structure                array level 1 dcl 12-59
star_link_count                        automatic       fixed bin(17,0)          dcl 12-17
star_link_pathname                     based           char                     unaligned dcl 12-102
star_links                             based           structure                array level 1 dcl 12-76
star_linkx                             automatic       fixed bin(17,0)          dcl 12-18
star_list_branch                       based           structure                array level 1 dcl 12-41
star_list_branch_ptr                   automatic       pointer                  dcl 12-16
star_list_names                        based           char(32)                 array unaligned dcl 12-92
star_list_names_ptr                    automatic       pointer                  dcl 12-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 12-21
status_area_ptr                        automatic       pointer                  dcl 13-47
status_entry_names                     based           char(32)                 array dcl 13-47
status_link                            based           structure                level 1 dcl 13-38
status_pathname                        based           char                     dcl 13-47
tsdw                                   automatic       structure                level 1 dcl 124
version_number_2                       internal static fixed bin(17,0)          initial dcl 8-84
who_ami                                internal static char(32)                 initial unaligned dcl 140

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON_NAME                     001412 constant        label                    dcl 250 ref 232 240
CREATE_UID_ERR                  001221 constant        label                    dcl 214 ref 191 199 212
END_ADD_HASH                    005464 constant        label                    dcl 621 ref 604 607
END_ADD_SL1                     005601 constant        label                    dcl 649 ref 643
END_CREATE                      001332 constant        label                    dcl 221 ref 171 178 184
END_INIT                        004223 constant        label                    dcl 431 ref 314 339 348
END_STACK_BASE                  007104 constant        label                    dcl 795 ref 771 785 792
ERROR                           004175 constant        label                    dcl 426 ref 356 366 375 409 419
FILL_TABLE                      005353 constant        label                    dcl 612 ref 602 608
NEXT                            004025 constant        label                    dcl 413 ref 385
NEXT_ONE                        005576 constant        label                    dcl 647 ref 640
RET_NAME                        004461 constant        label                    dcl 475 ref 455 463 467 469
RET_SEGNO                       004725 constant        label                    dcl 532 ref 522
add_hash                        005270 constant        entry                    internal dcl 586 ref 403 471 645
add_sl1_segs_to_hash            005465 constant        entry                    internal dcl 628 ref 211
add_trans                       005614 constant        entry                    internal dcl 658 ref 404 787
amu_deadproc_                   000417 constant        entry                    external dcl 6
amu_deadproc_$create_uid_hash   000431 constant        entry                    external dcl 157
amu_deadproc_$cur_dp            001340 constant        entry                    external dcl 227
amu_deadproc_$expand_to_ptr     004737 constant        entry                    external dcl 539
amu_deadproc_$init_deadproc     001546 constant        entry                    external dcl 262
amu_deadproc_$name_dp           001356 constant        entry                    external dcl 236
amu_deadproc_$name_dp_af        001376 constant        entry                    external dcl 244
amu_deadproc_$name_to_segno     004501 constant        entry                    external dcl 482
amu_deadproc_$segno_to_name     004266 constant        entry                    external dcl 437
amu_deadproc_$term_deadproc     005130 constant        entry                    external dcl 561 ref 284 313 338 347 355 365 374 408
                                                                                  418
check_name                      006145 constant        entry                    internal dcl 701 ref 387
get_name_from_hash              006211 constant        entry                    internal dcl 718 ref 464
get_stack_base                  006322 constant        entry                    internal dcl 746 ref 425
hash_uid                        007152 constant        entry                    internal dcl 804 ref 599 725

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10300       10430    7317       10310
Length     11250    7317       130         604     761           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amu_deadproc_                       798 external procedure  is an external procedure.  
on unit on line 163                  84 on unit               
on unit on line 278                  92 on unit               
add_hash                                internal procedure  shares stack frame of external procedure amu_deadproc_.  
add_sl1_segs_to_hash                    internal procedure  shares stack frame of external procedure amu_deadproc_.  
add_trans                           146 internal procedure  is called by several nonquick procedures.  
check_name                              internal procedure  shares stack frame of external procedure amu_deadproc_.  
get_name_from_hash                      internal procedure  shares stack frame of external procedure amu_deadproc_.  
get_stack_base                      300 internal procedure  enables or reverts conditions.  
on unit on line 760                  64 on unit               
hash_uid                                internal procedure  shares stack frame of external procedure amu_deadproc_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
add_trans                000100 sdwp                        add_trans
                         000102 bound                       add_trans
amu_deadproc_            000100 af_sw                       amu_deadproc_
                         000101 attach_desc                 amu_deadproc_
                         000163 bitcount                    amu_deadproc_
                         000164 code                        amu_deadproc_
                         000165 cur_state                   amu_deadproc_
                         000166 deadproc_dir                amu_deadproc_
                         000240 deadproc_name               amu_deadproc_
                         000250 dp_dir_path                 amu_deadproc_
                         000322 dseg_ptr                    amu_deadproc_
                         000324 expand_path                 amu_deadproc_
                         000376 i                           amu_deadproc_
                         000377 ignore                      amu_deadproc_
                         000400 iocbp                       amu_deadproc_
                         000402 info                        amu_deadproc_
                         000416 info_ptr                    amu_deadproc_
                         000420 kste_offset                 amu_deadproc_
                         000421 look_kst                    amu_deadproc_
                         000422 n_read                      amu_deadproc_
                         000423 old_uid                     amu_deadproc_
                         000424 sl1_uid                     amu_deadproc_
                         000426 system_area_ptr             amu_deadproc_
                         000430 t_kst_path                  amu_deadproc_
                         000502 temp_dir                    amu_deadproc_
                         000554 temp_name                   amu_deadproc_
                         000564 temp_ptr                    amu_deadproc_
                         000566 temp_translation            amu_deadproc_
                         000574 temp_uid_table_ptr          amu_deadproc_
                         000576 uid_basep                   amu_deadproc_
                         000600 uid_path                    amu_deadproc_
                         000626 no_match                    amu_deadproc_
                         000627 segno                       amu_deadproc_
                         000630 match_name                  amu_deadproc_
                         000732 amu_info_ptr                amu_deadproc_
                         000734 old_uid_table_ptr           amu_deadproc_
                         000736 old_uidep                   amu_deadproc_
                         000740 allocate_uid_hash           amu_deadproc_
                         000742 translation_ptr             amu_deadproc_
                         000744 kstp                        amu_deadproc_
                         000746 kstep                       amu_deadproc_
                         000750 star_entry_count            amu_deadproc_
                         000752 star_entry_ptr              amu_deadproc_
                         000754 star_names_ptr              amu_deadproc_
                         000756 status_ptr                  amu_deadproc_
                         001012 in_uid                      add_hash
                         001013 ind                         add_hash
                         001014 short_path                  add_hash
                         001066 code                        add_hash
                         001076 seg_ind                     add_sl1_segs_to_hash
                         001077 got_one                     add_sl1_segs_to_hash
                         001116 ind                         get_name_from_hash
                         001126 rev_uid                     hash_uid
                         001127 hash_ind                    hash_uid
get_stack_base           000100 stackbase                   get_stack_base
                         000110 stackno                     get_stack_base
                         000112 sb_ptr                      get_stack_base

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_in         call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          mpfx2               enable_op           shorten_stack
ext_entry           ext_entry_desc      int_entry           int_entry_desc      fetch_bits          reverse_cs
reverse_bs          set_chars_eis       set_bits_eis        index_chars_eis     any_to_any_truncate_op_alloc_
op_freen_           index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$create_translation       amu_$do_translation_segno     amu_$error_for_caller         amu_$get_l1dir_shortname
amu_$hardcore_info_deadproc   amu_$kst_util_expand_uid_path amu_$kst_util_segno_to_uid
amu_$kst_util_segno_to_uid_path                             amu_$kst_util_uid_to_kstep    amu_$temp_seg_get
amu_$temp_seg_release_all     amu_$terminate_translation    amu_$translate_add            amu_$translate_allocate
amu_$translate_get            cv_oct_check_                 expand_pathname_              get_system_free_area_
hash_$opt_size                hcs_$make_seg                 hcs_$star_                    hcs_$status_long
initiate_file_                ioa_                          iox_$attach_name              iox_$close
iox_$detach_iocb              iox_$get_line                 iox_$open                     pathname_
terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$make_uid_hash         amu_et_$no_amu_ptr            amu_et_$no_kst                amu_et_$no_sl1_in_kst
amu_et_$no_sl1_uid            amu_et_$no_uid_hash           error_table_$action_not_performed
error_table_$end_of_info      error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000416       157 000424       159 000443       160 000450       161 000453       163 000454       164 000470
    165 000477       166 000534       167 000571       168 000605       170 000606       171 000632       173 000634
    174 000654       175 000676       176 000736       177 000742       178 000745       181 000746       182 000757
    183 000763       184 000766       187 000767       188 000775       189 001040       190 001042       191 001045
    194 001046       196 001051       197 001112       198 001114       199 001117       202 001120       203 001143
    204 001146       205 001150       206 001166       211 001215       212 001217       214 001221       217 001227
    218 001263       219 001317       221 001332       223 001334       227 001335       230 001350       231 001352
    232 001353       236 001354       238 001366       239 001370       240 001371       244 001372       247 001406
    248 001410       250 001412       253 001415       254 001417       255 001503       258 001540       262 001541
    265 001570       266 001601       267 001605       268 001610       269 001645       271 001646       272 001650
    273 001652       274 001653       275 001654       276 001655       278 001662       279 001676       280 001703
    281 001714       283 001727       284 001765       285 002003       287 002004       288 002013       290 002026
    291 002032       292 002056       293 002060       294 002116       295 002120       297 002121       298 002150
    299 002152       300 002153       304 002154       308 002160       309 002222       310 002226       311 002231
    312 002313       313 002315       314 002332       317 002333       321 002405       322 002411       324 002421
    327 002423       328 002426       330 002431       331 002433       332 002435       333 002474       334 002533
    335 002535       337 002624       338 002626       339 002643       342 002644       343 002665       344 002667
    345 002753       346 002755       347 002766       348 003003       352 003004       353 003025       354 003027
    355 003113       356 003130       359 003131       360 003146       362 003150       363 003166       364 003170
    365 003253       366 003270       371 003271       372 003312       373 003314       374 003400       375 003415
    378 003416       379 003420       380 003440       381 003443       382 003500       383 003504       384 003544
    385 003545       387 003546       388 003550       389 003553       390 003570       391 003572       392 003575
    393 003620       394 003621       396 003622       398 003663       400 003664       402 003665       403 003671
    404 003700       405 003720       406 003722       408 004006       409 004024       413 004025       415 004046
    416 004053       418 004135       419 004152       421 004153       423 004154       425 004155       426 004175
    428 004177       429 004211       431 004223       433 004260       437 004261       448 004307       449 004312
    450 004325       453 004327       454 004334       455 004340       458 004341       459 004343       460 004346
    462 004350       463 004365       464 004367       465 004403       466 004407       467 004424       468 004426
    469 004453       471 004455       475 004461       477 004471       478 004473       482 004474       499 004522
    500 004525       501 004530       503 004532       504 004534       505 004537       506 004541       507 004567
    512 004633       513 004636       514 004647       515 004662       516 004663       518 004665       520 004667
    521 004671       522 004674       527 004675       528 004676       529 004713       530 004717       532 004725
    534 004727       535 004731       539 004732       541 004751       542 004754       543 004756       544 004761
    545 004762       546 004765       547 005002       549 005004       550 005031       552 005033       553 005057
    554 005061       555 005116       556 005121       557 005123       561 005124       564 005142       565 005145
    566 005151       567 005161       568 005174       569 005176       571 005233       572 005235       573 005244
    576 005247       577 005253       578 005255       581 005260       582 005267       586 005270       597 005272
    598 005275       599 005276       600 005306       601 005311       602 005316       604 005322       605 005326
    606 005335       607 005341       608 005345       609 005351       612 005353       614 005357       615 005415
    616 005416       617 005436       618 005445       621 005464       628 005465       636 005467       637 005470
    638 005501       639 005503       640 005520       641 005523       642 005526       643 005553       644 005556
    645 005560       647 005576       649 005601       652 005610       654 005612       658 005613       668 005621
    670 005623       672 005631       674 005637       675 005644       676 005662       677 005664       678 005666
    679 005672       680 005674       681 005676       682 005677       683 005717       684 005722       685 005752
    686 005771       687 005774       688 006013       690 006014       693 006067       694 006115       695 006143
    697 006144       701 006145       707 006147       708 006153       709 006161       710 006166       711 006173
    712 006200       713 006205       714 006210       718 006211       725 006222       726 006230       727 006235
    728 006244       729 006251       731 006252       732 006254       733 006270       734 006274       735 006302
    736 006307       738 006310       740 006312       741 006320       746 006321       755 006335       756 006337
    757 006342       758 006343       759 006344       760 006352       761 006366       762 006424       763 006434
    765 006435       768 006510       769 006516       770 006552       771 006556       774 006557       775 006562
    776 006600       778 006604       780 006624       781 006631       782 006673       783 006677       784 006765
    785 006767       787 006770       788 007006       789 007011       791 007101       792 007103       795 007104
    797 007141       798 007150       800 007151       804 007152       809 007154       810 007164       811 007171
    812 007173       815 007225


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
