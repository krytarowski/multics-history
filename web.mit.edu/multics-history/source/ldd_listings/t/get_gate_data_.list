	COMPILATION LISTING OF SEGMENT get_gate_data_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1218.9 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* GET_GATE_DATA_ - Procedure to Get Metering Data from a Gate.
       12*   revised 9/15/76 by Noel I. Morris	
       13*   Modified June 1981 by J. Bongiovanni to fix zero linkage size bug	
       14*   Modified July 1984 by Keith Loepere to work against the new, larger hcs_. */
       15 	
       16 get_gate_data_: proc (gate_name, table, nentries, tempp, reset_sw, code);
       17 
       18 dcl  gate_name char (*),				/* name of gate */
       19      nentries fixed bin,				/* number of gate entries */
       20      tempp ptr,					/* pointer to temp segment */
       21      reset_sw bit (1) aligned,			/* "1"b if reset operation to be performed at end */
       22      code fixed bin (35);				/* error code */
       23 
       24 dcl 1 table (*) like gate_table aligned;		/* gate information table */
       25 
       26 dcl  gp ptr,					/* pointer to gate_info */
       27      caller_ptr ptr,				/* pointer to caller of this procedure */
       28      gatep ptr,					/* pointer to gate */
       29      gateno fixed bin (18),				/* segno of gate */
       30      savep ptr,					/* pointer to original copy of linkage */
       31      slp ptr,					/* pointer to static copy of linkage */
       32      type fixed bin (2),				/* segment type */
       33      bc fixed bin (24),				/* segment bit count */
       34      pptr ptr unal,					/* packed pointer from lot */
       35      l0p ptr,					/* pointer to linkage in ring 0 */
       36      llth fixed bin (18),				/* length of linkage */
       37      linkp ptr,					/* pointer to linkage */
       38      tlth fixed bin (18),				/* length of text */
       39      textp ptr,					/* pointer to copy of teext */
       40      defp ptr,					/* pointer to defs */
       41      no_entries fixed bin,				/* number of gate entries */
       42      p ptr,					/* working pointer for searching defs */
       43      i fixed bin,					/* gate table index */
       44      namep ptr,					/* pointer to entry name */
       45      entryp ptr,					/* pointer to gate entry point */
       46      vrel bit (18),					/* rel pointer to gate validation info */
       47      vp ptr,					/* pointer to validation info */
       48      datarel bit (18);				/* rel ptr to gate data */
       49 
       50 dcl 1 linkhdr like header auto;			/* automatic copy of linkage header */
       51 
       52 dcl  ap ptr static init (null ()),			/* pointer to system free area */
       53      fgp ptr static init (null ()),			/* ptr to first gate_info */
       54      lotp0 ptr static init (null ());			/* pointer to ring 0 lot */
       55 
       56 dcl  caller entry returns (ptr),
       57      ring0_get_$segptr entry (char (*), char (*), ptr, fixed bin (35)),
       58      hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35)),
       59      ring_zero_peek_ entry (ptr, ptr, fixed bin (18), fixed bin (35)),
       60      get_system_free_area_ entry (ptr);
       61 
       62 dcl (addr, addrel, baseno, bin, divide, hbound, lbound, null, ptr, size, unspec) builtin;
       63 
       64 
       65 
       66 dcl 1 gate_info aligned based (gp),
       67     2 name char (32),				/* name of gate */
       68     2 user ptr unal,				/* pointer to caller */
       69     2 textp ptr unal,				/* ptr to segment in ring 0 */
       70     2 linkp ptr unal,				/* ptr to linkage in ring 0 */
       71     2 defp ptr unal,				/* pointer to defs */
       72     2 textl fixed bin (18),				/* length of text in words */
       73     2 linkl fixed bin (18),				/* length of linkage in words */
       74     2 stp ptr unal,					/* pointer to static buffer used when doing resets */
       75     2 next ptr unal;
       76 
       77 dcl 1 acc_name based (namep) aligned,			/* name in ACC format */
       78    (2 size fixed bin (8),
       79     2 name char (acc_name.size)) unaligned;
       80 
       81 dcl 1 gate_entry based aligned,			/* entry pointer to gate */
       82     2 body_ptr bit (18);				/* pointer to body of gate entry */
       83 
       84 dcl 1 gate_body based aligned,			/* body of gate entry */
       85     2 nargs bit (18) unal,				/* number of arguments */
       86     2 info_ptr bit (18) unal;				/* rel pointer to information in linkage */
       87 
       88 dcl 1 save_data (no_entries) aligned based (savep) like gate_entry_data,
       89   1 static_data (no_entries) aligned based (slp) like gate_entry_data,
       90   1 current_data (no_entries) aligned based (tempp) like gate_entry_data;
       91 
       92 dcl  based_area area based (ap);
       93 
       94 
       95 dcl 1 definitions_$ (0:511) ext aligned,		/* hardcore definitions */
       96    (2 offset bit (18),
       97     2 length bit (18)) unal;
       98 
       99 
      100 
  1     1 
  1     2 /* Begin include file ...... gate_data.incl.pl1
  1     3*	Created 10/13/76 by Noel I. Morris	*/
  1     4 /* Modified 831107 for ring_alarms, Benson Margulies. */
  1     5 /* format: style3 */
  1     6 
  1     7 dcl	1 gate_table	aligned based,		/* gate information table */
  1     8 	  2 entryp	ptr unal,			/* pointer to entry name */
  1     9 	  2 entryl	fixed bin,		/* length of entry name */
  1    10 	  2 datap		ptr unal;			/* pointer to gate metering data */
  1    11 
  1    12 dcl	gate_datap	ptr;
  1    13 
  1    14 dcl	1 gate_entry_data	based (gate_datap) aligned,	/* gate data in gate segment */
  1    15 	  2 cpu_time	fixed bin (71),		/* total CPU time spent in entry (us) */
  1    16 	  2 vcpu_time	fixed bin (71),		/* virtual CPU time spent in entry (us) */
  1    17 	  2 page_waits	fixed bin (35),		/* number of page waits in entry */
  1    18 	  2 calls		fixed bin (35),		/* number of calls to entry */
  1    19 	  2 ring_alarms	fixed bin (35),		/* number of times RAR was nonzero on exit. */
  1    20 	  2 pad		fixed bin (35);		/* for future use */
  1    21 
  1    22 /* End of include file ...... gate_data.incl.pl1 */
  1    23 
      101 
      102 
      103 
      104 
  2     1 /* BEGIN INCLUDE FILE linkdcl.incl.pl1 --- last modified 15 Nov 1971 by C Garman */
  2     2 
  2     3 /* Last Modified (Date and Reason):
  2     4*   6/75 by M.Weaver to add virgin_linkage_header declaration
  2     5*   6/75 by S.Webber to comment existing structures better
  2     6*   9/77 by M. Weaver to add run_depth to link
  2     7*   2/83 by M. Weaver to add linkage header flags and change run_depth precision
  2     8**/
  2     9 
  2    10 /* format: style3 */
  2    11 dcl	1 link		based aligned,		/* link pair in linkage section */
  2    12 	  2 head_ptr	bit (18) unal,		/* rel pointer to beginning of linkage section */
  2    13 	  2 ringno	bit (3) unal,
  2    14 	  2 mbz		bit (6) unal,
  2    15 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  2    16 	  2 ft2		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  2    17 	  2 exp_ptr	bit (18) unal,		/* pointer (rel to defs) of expression word */
  2    18 	  2 mbz2		bit (12) unal,
  2    19 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  2    20 
  2    21 dcl	1 exp_word	based aligned,		/* expression word in link definition */
  2    22 	  2 type_ptr	bit (18) unal,		/* pointer (rel to defs) of type pair structure */
  2    23 	  2 exp		bit (18) unal;		/* constant expression to be added in when snapping link */
  2    24 
  2    25 dcl	1 type_pair	based aligned,		/* type pair in link definition */
  2    26 	  2 type		bit (18) unal,		/* type of link. may be 1,2,3,4,5, or 6 */
  2    27 	  2 trap_ptr	bit (18) unal,		/* pointer (rel to defs) to the trap word */
  2    28 	  2 seg_ptr	bit (18) unal,		/* pointer to ACC reference name for segment referenced */
  2    29 	  2 ext_ptr	bit (18) unal;		/* pointer (rel to defs)  of ACC segdef name */
  2    30 
  2    31 dcl	1 header		based aligned,		/* linkage block header */
  2    32 	  2 def_ptr	ptr,			/* pointer to definition section */
  2    33 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  2    34 	  2 original_linkage_ptr
  2    35 			ptr unal,			/* pointer to linkage section in object segment */
  2    36 	  2 unused	bit (72),
  2    37 	  2 stats,
  2    38 	    3 begin_links	bit (18) unal,		/* offset (rel to this section) of first link */
  2    39 	    3 block_length	bit (18) unal,		/* number of words in this linkage section */
  2    40 	    3 segment_number
  2    41 			bit (18) unal,		/* text segment number associated with this section */
  2    42 	    3 static_length bit (18) unal;		/* number of words of static for this segment */
  2    43 
  2    44 dcl	1 linkage_header_flags
  2    45 			aligned based,		/* overlay of def_ptr for flags */
  2    46 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  2    47 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  2    48 	  2 perprocess_static
  2    49 			bit (1) unaligned,		/* 1 copy of static section is used by all tasks/run units */
  2    50 	  2 pad2		bit (6) unaligned;
  2    51 
  2    52 dcl	1 virgin_linkage_header
  2    53 			aligned based,		/* template for linkage header in object segment */
  2    54 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  2    55 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  2    56 	  2 def_offset	bit (18) unaligned,		/* offset of definition section */
  2    57 	  2 first_ref_relp	bit (18) unaligned,		/* offset of trap-at-first-reference offset array */
  2    58 	  2 filled_in_later bit (144),
  2    59 	  2 link_begin	bit (18) unaligned,		/* offset of first link */
  2    60 	  2 linkage_section_lng
  2    61 			bit (18) unaligned,		/* length of linkage section */
  2    62 	  2 segno_pad	bit (18) unaligned,		/* will be segment number of copied linkage */
  2    63 	  2 static_length	bit (18) unaligned;		/* length of static section */
  2    64 
  2    65 
  2    66 dcl	1 trap_word	based aligned,		/* trap word in link definition */
  2    67 	  2 call_ptr	bit (18) unal,		/* pointer (rel to link) of link to trap procedure */
  2    68 	  2 arg_ptr	bit (18) unal;		/* pointer (rel to link) of link to arg info for trap proc */
  2    69 
  2    70 dcl	1 name		based aligned,		/* storage of ASCII names in definitions */
  2    71 	  2 nchars	bit (9) unaligned,		/* number of characters in name */
  2    72 	  2 char_string	char (31) unaligned;	/* 31-character name */
  2    73 
  2    74 /* END INCLUDE FILE linkdcl.incl.pl1 */
      105 
      106 
      107 
      108 
  3     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  3     8*     Modified to add indirect bit to definition flags.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 dcl	1 definition	aligned based,
  3    13 	2 forward		unal bit(18),	/* offset of next def */
  3    14 	2 backward	unal bit(18),	/* offset of previous def */
  3    15 	2 value		unal bit(18),
  3    16 	2 flags		unal,
  3    17 	  3 new		bit(1),
  3    18 	  3 ignore	bit(1),
  3    19 	  3 entry		bit(1),
  3    20 	  3 retain	bit(1),
  3    21 	  3 argcount	bit(1),
  3    22 	  3 descriptors	bit(1),
  3    23 	  3 indirect	bit(1),
  3    24 	  3 unused	bit(8),
  3    25 	2 class		unal bit(3),
  3    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  3    27 	2 segname		unal bit(18);	/* offset of segname def */
  3    28 
  3    29 /* END INCLUDE FILE definition.incl.pl1 */
      109 
      110 
      111 
      112 
      113 	code = 0;
      114 
      115 /* If this is the first call, get static pointers. */
      116 
      117 	if ap = null () then			/* Get pointer to system free area. */
      118 	     call get_system_free_area_ (ap);
      119 
      120 	if lotp0 = null () then			/* Get a pointer to ring 0 lot. */
      121 	     call ring0_get_$segptr ("", "lot", lotp0, code);
      122 	if code ^= 0 then return;
      123 
      124 /* See if we already have data. */
      125 
      126 	caller_ptr = caller ();
      127 						/* Get pointer to this procedure's caller. */
      128 	gp = fgp;
      129 	do while (gp ^= null ());
      130 	     if (gate_info.name = gate_name) & (gate_info.user = caller_ptr) then go to found;
      131 	     gp = gate_info.next;
      132 	end;
      133 
      134 /* Set up new entry. */
      135 
      136 	allocate gate_info in (ap -> based_area) set (gp);
      137 	gate_info.next = fgp;
      138 	fgp = gp;
      139 
      140 	call hcs_$status_minf (">system_library_1", gate_name, 1, type, bc, code);
      141 	if code ^= 0 then return;			/* Get length of text. */
      142 	tlth = divide (bc, 36, 18, 0);
      143 
      144 	call ring0_get_$segptr ("", gate_name, gatep, code); /* Get segno of gate. */
      145 	if code ^= 0 then return;
      146 	gateno = bin (baseno (gatep), 18);
      147 
      148 	call ring_zero_peek_ (addrel (lotp0, gateno), addr (pptr), 1, code); /* Find linkage for gate. */
      149 	if code ^= 0 then return;
      150 	l0p = pptr;
      151 
      152 	call ring_zero_peek_ (l0p, addr (linkhdr), size (linkhdr), code); /* Copy linkage header. */
      153 	llth = bin (linkhdr.begin_links, 18) - size (linkhdr); /* Get length of linkage from header. */
      154 	no_entries = divide (llth, size (gate_entry_data), 17, 0); /* Compute no of elements. */
      155 	if no_entries > 0 then do;
      156 	     allocate static_data in (ap -> based_area) set (slp); /* Allocate static buffer. */
      157 	     unspec (static_data) = "0"b;			/* Clear the data. */
      158 	end;
      159 	else slp = null ();
      160 
      161 	defp = ptr (addr (definitions_$), definitions_$ (gateno).offset);
      162 						/* Get pointer to definitions for gate. */
      163 
      164 
      165 
      166 /* Fill in new gate info entry. */
      167 
      168 	gate_info.linkp = addrel (l0p, 8);
      169 	gate_info.linkl = llth;
      170 	gate_info.defp = defp;
      171 	gate_info.textp = gatep;
      172 	gate_info.textl = tlth;
      173 	gate_info.stp = slp;
      174 	gate_info.name = gate_name;
      175 	gate_info.user = caller_ptr;
      176 
      177 found:	
      178 	if gate_info.stp = null () then do;
      179 	     nentries = 0;
      180 	     return;
      181 	end;
      182 
      183 /* Copy the linkage from ring 0. */
      184 
      185 	l0p = gate_info.linkp;
      186 	llth = gate_info.linkl;
      187 	call ring_zero_peek_ (l0p, tempp, llth, code);	/* Copy out the linkage. */
      188 	if code ^= 0 then return;
      189 
      190 /* Compute differences from previous data. */
      191 
      192 	slp = gate_info.stp;
      193 	no_entries = divide (llth, size (gate_entry_data), 17, 0);
      194 
      195 
      196 /* Copy the text from ring 0. */
      197 
      198 	gatep = gate_info.textp;
      199 	tlth = gate_info.textl;
      200 	textp = addrel (tempp, llth);
      201 	call ring_zero_peek_ (gatep, textp, tlth, code);
      202 	if code ^= 0 then return;
      203 
      204 	savep = addrel (textp, tlth);			/* Get pointer for saved data. */
      205 	save_data = current_data;			/* Save the just copied out data. */
      206 	current_data = current_data - static_data;	/* Compute the differences. */
      207 
      208 /* Iterate through the linkage. */
      209 
      210 	linkp = addrel (tempp, -8);			/* Make pointer to imaginary linkage header. */
      211 	defp = gate_info.defp;
      212 
      213 	i = lbound (table, 1);			/* Initialize count. */
      214 	do p = defp repeat addrel (defp, p -> definition.forward)
      215 		while (p -> definition.forward);
      216 	     if i > hbound (table, 1) then go to done;
      217 
      218 	     if p -> definition.ignore then		/* If this isn't really an entry */
      219 		go to next_entry;
      220 	     if p -> definition.class ^= "0"b then	/* Test for segdef to text. */
      221 		go to next_entry;
      222 
      223 	     namep = addrel (defp, p -> definition.symbol);
      224 
      225 	     if acc_name.name = ".my_lp" then goto next_entry; /* Skip the segdef for gate linkage pointer. */
      226 	     if acc_name.name = ".tv_end" then goto next_entry; /* also watch out for call limited segdef */
      227 
      228 	     entryp = addrel (textp, p -> definition.value);
      229 						/* Generate pointer to entry point. */
      230 	     vrel = entryp -> gate_entry.body_ptr;	/* Get relative ptr to validation information. */
      231 	     vp = addrel (textp, vrel);		/* Convert to ITS pointer. */
      232 	     vp = addrel (vp, -1);			/* information is instruction right before */
      233 	     datarel = vp -> gate_body.info_ptr;	/* Get relative ptr to gate data. */
      234 	     if datarel = "0"b then goto next_entry;	/* some gates aren't metered */
      235 	     gate_datap = addrel (linkp, datarel);	/* Convert to ITS pointer. */
      236 
      237 	     table (i).entryp = addr (acc_name.name);
      238 	     table (i).entryl = acc_name.size;
      239 	     table (i).datap = gate_datap;
      240 
      241 	     i = i + 1;
      242 next_entry:
      243 	end;
      244 
      245 done:
      246 	nentries = i - lbound (table, 1);
      247 
      248 	if reset_sw then				/* If reset desired ... */
      249 	     static_data = save_data;			/* Set new static data. */
      250 
      251 	return;
      252 
      253 
      254 
      255 
      256      end get_gate_data_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  get_gate_data_.pl1                >special_ldd>install>MR12.0-1222>get_gate_data_.pl1
101          1    07/11/84  0937.3  gate_data.incl.pl1                >ldd>include>gate_data.incl.pl1
105          2    07/27/83  0910.0  linkdcl.incl.pl1                  >ldd>include>linkdcl.incl.pl1
109          3    11/20/86  1035.2  definition.incl.pl1               >special_ldd>install>MR12.0-1222>definition.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acc_name                               based           structure                level 1 dcl 77
addr                                                   builtin function         dcl 62 ref 148 148 152 152 161 237
addrel                                                 builtin function         dcl 62 ref 148 148 168 200 204 210 223 228 231 232
                                                                                  235 242
ap                              000010 internal static pointer                  initial dcl 52 set ref 117 117* 136 156
based_area                             based           area(1024)               dcl 92 ref 136 156
baseno                                                 builtin function         dcl 62 ref 146
bc                              000115 automatic       fixed bin(24,0)          dcl 26 set ref 140* 142
begin_links               6     000154 automatic       bit(18)                  level 3 packed unaligned dcl 50 set ref 153
bin                                                    builtin function         dcl 62 ref 146 153
body_ptr                               based           bit(18)                  level 2 dcl 81 ref 230
caller                          000016 constant        entry                    external dcl 56 ref 126
caller_ptr                      000102 automatic       pointer                  dcl 26 set ref 126* 130 175
class                     1(33)        based           bit(3)                   level 2 packed unaligned dcl 3-12 ref 220
code                                   parameter       fixed bin(35,0)          dcl 18 set ref 16 113* 120* 122 140* 141 144* 145
                                                                                  148* 149 152* 187* 188 201* 202
current_data                           based           structure                array level 1 dcl 88 set ref 205 206* 206
datap                     2            parameter       pointer                  array level 2 packed unaligned dcl 24 set ref 239*
datarel                         000152 automatic       bit(18)                  unaligned dcl 26 set ref 233* 234 235
definition                             based           structure                level 1 dcl 3-12
definitions_$                   000030 external static structure                array level 1 dcl 95 set ref 161
defp                            000132 automatic       pointer                  dcl 26 in procedure "get_gate_data_" set ref 161*
                                                                                  170 211* 214 223 242
defp                     13            based           pointer                  level 2 in structure "gate_info" packed unaligned
                                                                                  dcl 66 in procedure "get_gate_data_" set ref 170*
                                                                                  211
divide                                                 builtin function         dcl 62 ref 142 154 193
entryl                    1            parameter       fixed bin(17,0)          array level 2 dcl 24 set ref 238*
entryp                                 parameter       pointer                  array level 2 in structure "table" packed unaligned
                                                                                  dcl 24 in procedure "get_gate_data_" set ref 237*
entryp                          000144 automatic       pointer                  dcl 26 in procedure "get_gate_data_" set ref 228*
                                                                                  230
fgp                             000012 internal static pointer                  initial dcl 52 set ref 128 137 138*
flags                     1(18)        based           structure                level 2 packed unaligned dcl 3-12
forward                                based           bit(18)                  level 2 packed unaligned dcl 3-12 ref 214 242
gate_body                              based           structure                level 1 dcl 84
gate_datap                      000164 automatic       pointer                  dcl 1-12 set ref 154 193 235* 239
gate_entry                             based           structure                level 1 dcl 81
gate_entry_data                        based           structure                level 1 dcl 1-14 ref 154 193
gate_info                              based           structure                level 1 dcl 66 set ref 136
gate_name                              parameter       char                     unaligned dcl 18 set ref 16 130 140* 144* 174
gate_table                             based           structure                level 1 dcl 1-7
gateno                          000106 automatic       fixed bin(18,0)          dcl 26 set ref 146* 148 148 161
gatep                           000104 automatic       pointer                  dcl 26 set ref 144* 146 171 198* 201*
get_system_free_area_           000026 constant        entry                    external dcl 56 ref 117
gp                              000100 automatic       pointer                  dcl 26 set ref 128* 129 130 130 131* 131 136* 137
                                                                                  138 168 169 170 171 172 173 174 175 177 185 186
                                                                                  192 198 199 211
hbound                                                 builtin function         dcl 62 ref 216
hcs_$status_minf                000022 constant        entry                    external dcl 56 ref 140
header                                 based           structure                level 1 dcl 2-31
i                               000140 automatic       fixed bin(17,0)          dcl 26 set ref 213* 216 237 238 239 241* 241 245
ignore                    1(19)        based           bit(1)                   level 3 packed unaligned dcl 3-12 ref 218
info_ptr                  0(18)        based           bit(18)                  level 2 packed unaligned dcl 84 ref 233
l0p                             000120 automatic       pointer                  dcl 26 set ref 150* 152* 168 185* 187*
lbound                                                 builtin function         dcl 62 ref 213 245
linkhdr                         000154 automatic       structure                level 1 unaligned dcl 50 set ref 152 152 152 152 153
linkl                    15            based           fixed bin(18,0)          level 2 dcl 66 set ref 169* 186
linkp                           000124 automatic       pointer                  dcl 26 in procedure "get_gate_data_" set ref 210*
                                                                                  235
linkp                    12            based           pointer                  level 2 in structure "gate_info" packed unaligned
                                                                                  dcl 66 in procedure "get_gate_data_" set ref 168*
                                                                                  185
llth                            000122 automatic       fixed bin(18,0)          dcl 26 set ref 153* 154 169 186* 187* 193 200
lotp0                           000014 internal static pointer                  initial dcl 52 set ref 120 120* 148 148
name                                   based           char(32)                 level 2 in structure "gate_info" dcl 66 in procedure
                                                                                  "get_gate_data_" set ref 130 174*
name                      0(09)        based           char                     level 2 in structure "acc_name" packed unaligned
                                                                                  dcl 77 in procedure "get_gate_data_" set ref 225
                                                                                  226 237
namep                           000142 automatic       pointer                  dcl 26 set ref 223* 225 225 226 226 237 237 238
nentries                               parameter       fixed bin(17,0)          dcl 18 set ref 16 179* 245*
next                     17            based           pointer                  level 2 packed unaligned dcl 66 set ref 131 137*
no_entries                      000134 automatic       fixed bin(17,0)          dcl 26 set ref 154* 155 156 157 193* 205 206 206 206
                                                                                  248
null                                                   builtin function         dcl 62 ref 117 120 129 159 177
offset                          000030 external static bit(18)                  array level 2 packed unaligned dcl 95 set ref 161
p                               000136 automatic       pointer                  dcl 26 set ref 214* 214* 218 220 223 228* 242
pptr                            000116 automatic       pointer                  unaligned dcl 26 set ref 148 148 150
ptr                                                    builtin function         dcl 62 ref 161
reset_sw                               parameter       bit(1)                   dcl 18 ref 16 248
ring0_get_$segptr               000020 constant        entry                    external dcl 56 ref 120 144
ring_zero_peek_                 000024 constant        entry                    external dcl 56 ref 148 152 187 201
save_data                              based           structure                array level 1 dcl 88 set ref 205* 248
savep                           000110 automatic       pointer                  dcl 26 set ref 204* 205 248
size                                   based           fixed bin(8,0)           level 2 in structure "acc_name" packed unaligned
                                                                                  dcl 77 in procedure "get_gate_data_" ref 225 226
                                                                                  237 238
size                                                   builtin function         dcl 62 in procedure "get_gate_data_" ref 152 152 153
                                                                                  154 193
slp                             000112 automatic       pointer                  dcl 26 set ref 156* 157 159* 173 192* 206 248
static_data                            based           structure                array level 1 dcl 88 set ref 156 157* 206 248*
stats                     6     000154 automatic       structure                level 2 packed unaligned dcl 50
stp                      16            based           pointer                  level 2 packed unaligned dcl 66 set ref 173* 177 192
symbol                    2            based           bit(18)                  level 2 packed unaligned dcl 3-12 ref 223
table                                  parameter       structure                array level 1 dcl 24 set ref 16 213 216 245
tempp                                  parameter       pointer                  dcl 18 set ref 16 187* 200 205 206 206 210
textl                    14            based           fixed bin(18,0)          level 2 dcl 66 set ref 172* 199
textp                    11            based           pointer                  level 2 in structure "gate_info" packed unaligned
                                                                                  dcl 66 in procedure "get_gate_data_" set ref 171*
                                                                                  198
textp                           000130 automatic       pointer                  dcl 26 in procedure "get_gate_data_" set ref 200*
                                                                                  201* 204 228 231
tlth                            000126 automatic       fixed bin(18,0)          dcl 26 set ref 142* 172 199* 201* 204
type                            000114 automatic       fixed bin(2,0)           dcl 26 set ref 140*
unspec                                                 builtin function         dcl 62 set ref 157*
user                     10            based           pointer                  level 2 packed unaligned dcl 66 set ref 130 175*
value                     1            based           bit(18)                  level 2 packed unaligned dcl 3-12 ref 228
vp                              000150 automatic       pointer                  dcl 26 set ref 231* 232* 232 233
vrel                            000146 automatic       bit(18)                  unaligned dcl 26 set ref 230* 231

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
exp_word                               based           structure                level 1 dcl 2-21
link                                   based           structure                level 1 dcl 2-11
linkage_header_flags                   based           structure                level 1 dcl 2-44
name                                   based           structure                level 1 dcl 2-70
trap_word                              based           structure                level 1 dcl 2-66
type_pair                              based           structure                level 1 dcl 2-25
virgin_linkage_header                  based           structure                level 1 dcl 2-52

NAMES DECLARED BY EXPLICIT CONTEXT.
done                            001003 constant        label                    dcl 245 ref 216
found                           000465 constant        label                    dcl 177 ref 130
get_gate_data_                  000055 constant        entry                    external dcl 16
next_entry                      000775 constant        label                    dcl 242 ref 218 220 225 226 234

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1126        1160    1025        1136
Length      1416    1025        32         222     101           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_gate_data_                      178 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ap                          get_gate_data_
000012 fgp                         get_gate_data_
000014 lotp0                       get_gate_data_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_gate_data_           000100 gp                          get_gate_data_
                         000102 caller_ptr                  get_gate_data_
                         000104 gatep                       get_gate_data_
                         000106 gateno                      get_gate_data_
                         000110 savep                       get_gate_data_
                         000112 slp                         get_gate_data_
                         000114 type                        get_gate_data_
                         000115 bc                          get_gate_data_
                         000116 pptr                        get_gate_data_
                         000120 l0p                         get_gate_data_
                         000122 llth                        get_gate_data_
                         000124 linkp                       get_gate_data_
                         000126 tlth                        get_gate_data_
                         000130 textp                       get_gate_data_
                         000132 defp                        get_gate_data_
                         000134 no_entries                  get_gate_data_
                         000136 p                           get_gate_data_
                         000140 i                           get_gate_data_
                         000142 namep                       get_gate_data_
                         000144 entryp                      get_gate_data_
                         000146 vrel                        get_gate_data_
                         000150 vp                          get_gate_data_
                         000152 datarel                     get_gate_data_
                         000154 linkhdr                     get_gate_data_
                         000164 gate_datap                  get_gate_data_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
unpk_to_pk          call_ext_out_desc   call_ext_out        return_mac          ext_entry_desc      op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
caller                        get_system_free_area_         hcs_$status_minf              ring0_get_$segptr
ring_zero_peek_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
definitions_$


CONSTANTS
001024  aa     007777000001

000000  aa     404000000030

000001  aa     404000000002

000002  aa     404000000001

000003  aa     524000000021

000004  aa     524000000003

000005  aa  154 157 164 000	lot

000006  aa     524000000000

000007  aa     404000000043

000010  aa     514000000001

000011  aa     464000000000

000012  aa     404000000021

000013  aa     526077777777

000014  aa  056 164 166 137	.tv_
000015  aa  145 156 144 000	end

000016  aa  056 155 171 137	.my_
000017  aa  154 160 000 000	lp

000020  aa     077777000043
000021  aa     000001000000

000022  aa  076 163 171 163	>sys
000023  aa  164 145 155 137	tem_
000024  aa  154 151 142 162	libr
000025  aa  141 162 171 137	ary_
000026  aa  061 000 000 000	1

000027  aa     504100000003
000030  aa     000000000000
000031  aa     000000000000
000032  aa     400000000000
000033  aa     466100000000
000034  aa     000000000000
000035  aa     000000000000
000036  aa     400000000000
000037  aa     404100000021
000040  aa     000000000000
000041  aa     000000000000
000042  aa     400000000000
000043  aa     466100000000
000044  aa     000000000000
000045  aa     000000000000
000046  aa     400000000000

BEGIN PROCEDURE get_gate_data_
ENTRY TO get_gate_data_                                     STATEMENT 1 ON LINE 16
get_gate_data_: proc (gate_name, table, nentries, tempp, reset_sw, code);

000047  at     000006000013
000050  tt     000027000012
000051  tt     000011000010
000052  ta     000007000000
000053  ta     000047000000
000054  da     000075300000
000055  aa   000300 6270 00	eax7 	192
000056  aa  7 00034 3521 20	epp2 	pr7|28,*
000057  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000060  aa     000014000000
000061  aa     000000000000
000062  aa  6 00042 3735 20	epp7 	pr6|34,*
000063  aa  7 00000 2361 20	ldq  	pr7|0,*
000064  aa   000002 6040 04	tmi  	2,ic		000066
000065  aa   777777 3760 07	anq  	262143,dl
000066  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000067  aa  6 00167 7561 00	stq  	pr6|119
						STATEMENT 1 ON LINE 113
	code = 0;

000070  aa  6 00032 3715 20	epp5 	pr6|26,*
000071  aa  5 00014 4501 20	stz  	pr5|12,*		code
						STATEMENT 1 ON LINE 117
	if ap = null () then			/* Get pointer to system free area. */
	     call get_system_free_area_ (ap);

000072  ia  4 00010 2371 00	ldaq 	pr4|8		ap
000073  aa   777725 6770 04	eraq 	-43,ic		000020 = 077777000043 000001000000
000074  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000075  aa   000007 6010 04	tnz  	7,ic		000104
000076  ia  4 00010 3521 00	epp2 	pr4|8		ap
000077  aa  6 00172 2521 00	spri2	pr6|122
000100  aa  6 00170 6211 00	eax1 	pr6|120
000101  aa   004000 4310 07	fld  	2048,dl
000102  la  4 00026 3521 20	epp2 	pr4|22,*		get_system_free_area_
000103  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 120
	if lotp0 = null () then			/* Get a pointer to ring 0 lot. */
	     call ring0_get_$segptr ("", "lot", lotp0, code);

000104  aa  6 00044 3701 20	epp4 	pr6|36,*
000105  ia  4 00014 2371 00	ldaq 	pr4|12		lotp0
000106  aa   777712 6770 04	eraq 	-54,ic		000020 = 077777000043 000001000000
000107  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000110  aa   000030 6010 04	tnz  	24,ic		000140
000111  aa   777674 2350 04	lda  	-68,ic		000005 = 154157164000
000112  aa  6 00175 7551 00	sta  	pr6|125
000113  aa  6 00174 3521 00	epp2 	pr6|124
000114  aa  6 00200 2521 00	spri2	pr6|128
000115  aa  6 00175 3521 00	epp2 	pr6|125
000116  aa  6 00202 2521 00	spri2	pr6|130
000117  ia  4 00014 3521 00	epp2 	pr4|12		lotp0
000120  aa  6 00204 2521 00	spri2	pr6|132
000121  aa  6 00032 3735 20	epp7 	pr6|26,*
000122  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000123  aa  6 00206 2521 00	spri2	pr6|134
000124  aa   777662 3520 04	epp2 	-78,ic		000006 = 524000000000
000125  aa  6 00210 2521 00	spri2	pr6|136
000126  aa   777656 3520 04	epp2 	-82,ic		000004 = 524000000003
000127  aa  6 00212 2521 00	spri2	pr6|138
000130  aa   777661 3520 04	epp2 	-79,ic		000011 = 464000000000
000131  aa  6 00214 2521 00	spri2	pr6|140
000132  aa   777655 3520 04	epp2 	-83,ic		000007 = 404000000043
000133  aa  6 00216 2521 00	spri2	pr6|142
000134  aa  6 00176 6211 00	eax1 	pr6|126
000135  aa   020000 4310 07	fld  	8192,dl
000136  la  4 00020 3521 20	epp2 	pr4|16,*		ring0_get_$segptr
000137  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 122
	if code ^= 0 then return;

000140  aa  6 00032 3735 20	epp7 	pr6|26,*
000141  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000142  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 126
	caller_ptr = caller ();

000143  aa  6 00102 3521 00	epp2 	pr6|66		caller_ptr
000144  aa  6 00172 2521 00	spri2	pr6|122
000145  aa  6 00170 6211 00	eax1 	pr6|120
000146  aa   004000 4310 07	fld  	2048,dl
000147  aa  6 00044 3701 20	epp4 	pr6|36,*
000150  la  4 00016 3521 20	epp2 	pr4|14,*		caller
000151  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 128
	gp = fgp;

000152  aa  6 00044 3701 20	epp4 	pr6|36,*
000153  ia  4 00012 3735 20	epp7 	pr4|10,*		fgp
000154  aa  6 00100 6535 00	spri7	pr6|64		gp
						STATEMENT 1 ON LINE 129
	do while (gp ^= null ());

000155  aa   000000 0110 03	nop  	0,du
000156  aa  6 00100 2371 00	ldaq 	pr6|64		gp
000157  aa   777641 6770 04	eraq 	-95,ic		000020 = 077777000043 000001000000
000160  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000161  aa   000020 6000 04	tze  	16,ic		000201
						STATEMENT 1 ON LINE 130
	     if (gate_info.name = gate_name) & (gate_info.user = caller_ptr) then go to found;

000162  aa  6 00100 3735 20	epp7 	pr6|64,*		gp
000163  aa  6 00032 3715 20	epp5 	pr6|26,*
000164  aa  5 00002 3535 20	epp3 	pr5|2,*
000165  aa  6 00167 2351 00	lda  	pr6|119
000166  aa  040 140 106 500	cmpc 	(pr),(pr,rl),fill(040)
000167  aa  7 00000 00 0040	desc9a	pr7|0,32		gate_info.name
000170  aa  3 00000 00 0005	desc9a	pr3|0,al		gate_name
000171  aa   000005 6010 04	tnz  	5,ic		000176
000172  aa  6 00102 2371 00	ldaq 	pr6|66		caller_ptr
000173  aa  0 00560 7001 00	tsx0 	pr0|368		unpk_to_pk
000174  aa  7 00010 1161 00	cmpq 	pr7|8		gate_info.user
000175  aa   000270 6000 04	tze  	184,ic		000465
						STATEMENT 1 ON LINE 131
	     gp = gate_info.next;

000176  aa  7 00017 7611 00	lprp1	pr7|15		gate_info.next
000177  aa  6 00100 2515 00	spri1	pr6|64		gp
						STATEMENT 1 ON LINE 132
	end;

000200  aa   777756 7100 04	tra  	-18,ic		000156
						STATEMENT 1 ON LINE 136
	allocate gate_info in (ap -> based_area) set (gp);

000201  aa   000020 2360 07	ldq  	16,dl
000202  aa  6 00044 3701 20	epp4 	pr6|36,*
000203  ia  4 00010 3521 20	epp2 	pr4|8,*		based_area
000204  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
000205  aa   777774 7100 04	tra  	-4,ic		000201
000206  aa  6 00100 2521 00	spri2	pr6|64		gp
						STATEMENT 1 ON LINE 137
	gate_info.next = fgp;

000207  aa  6 00044 3701 20	epp4 	pr6|36,*
000210  ia  4 00012 3735 20	epp7 	pr4|10,*		fgp
000211  aa  2 00017 5471 00	sprp7	pr2|15		gate_info.next
						STATEMENT 1 ON LINE 138
	fgp = gp;

000212  ia  4 00012 2521 00	spri2	pr4|10		fgp
						STATEMENT 1 ON LINE 140
	call hcs_$status_minf (">system_library_1", gate_name, 1, type, bc, code);

000213  aa   777607 2370 04	ldaq 	-121,ic		000022 = 076163171163 164145155137
000214  aa  6 00176 7571 00	staq 	pr6|126
000215  aa   777607 2370 04	ldaq 	-121,ic		000024 = 154151142162 141162171137
000216  aa  6 00200 7571 00	staq 	pr6|128
000217  aa   061000 2350 03	lda  	25088,du
000220  aa  6 00202 7551 00	sta  	pr6|130
000221  aa   000001 2360 07	ldq  	1,dl
000222  aa  6 00175 7561 00	stq  	pr6|125
000223  aa  6 00176 3521 00	epp2 	pr6|126
000224  aa  6 00222 2521 00	spri2	pr6|146
000225  aa  6 00032 3735 20	epp7 	pr6|26,*
000226  aa  7 00002 3521 20	epp2 	pr7|2,*		gate_name
000227  aa  6 00224 2521 00	spri2	pr6|148
000230  aa  6 00175 3521 00	epp2 	pr6|125
000231  aa  6 00226 2521 00	spri2	pr6|150
000232  aa  6 00114 3521 00	epp2 	pr6|76		type
000233  aa  6 00230 2521 00	spri2	pr6|152
000234  aa  6 00115 3521 00	epp2 	pr6|77		bc
000235  aa  6 00232 2521 00	spri2	pr6|154
000236  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000237  aa  6 00234 2521 00	spri2	pr6|156
000240  aa   777543 3520 04	epp2 	-157,ic		000003 = 524000000021
000241  aa  6 00236 2521 00	spri2	pr6|158
000242  aa  6 00042 3715 20	epp5 	pr6|34,*
000243  aa  5 00000 3521 20	epp2 	pr5|0,*
000244  aa  6 00240 2521 00	spri2	pr6|160
000245  aa   777535 3520 04	epp2 	-163,ic		000002 = 404000000001
000246  aa  6 00242 2521 00	spri2	pr6|162
000247  aa   777532 3520 04	epp2 	-166,ic		000001 = 404000000002
000250  aa  6 00244 2521 00	spri2	pr6|164
000251  aa   777527 3520 04	epp2 	-169,ic		000000 = 404000000030
000252  aa  6 00246 2521 00	spri2	pr6|166
000253  aa   777534 3520 04	epp2 	-164,ic		000007 = 404000000043
000254  aa  6 00250 2521 00	spri2	pr6|168
000255  aa  6 00220 6211 00	eax1 	pr6|144
000256  aa   030000 4310 07	fld  	12288,dl
000257  la  4 00022 3521 20	epp2 	pr4|18,*		hcs_$status_minf
000260  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 141
	if code ^= 0 then return;

000261  aa  6 00032 3735 20	epp7 	pr6|26,*
000262  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000263  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 142
	tlth = divide (bc, 36, 18, 0);

000264  aa  6 00115 2361 00	ldq  	pr6|77		bc
000265  aa   000044 5060 07	div  	36,dl
000266  aa  6 00126 7561 00	stq  	pr6|86		tlth
						STATEMENT 1 ON LINE 144
	call ring0_get_$segptr ("", gate_name, gatep, code);

000267  aa  6 00175 3521 00	epp2 	pr6|125
000270  aa  6 00200 2521 00	spri2	pr6|128
000271  aa  7 00002 3521 20	epp2 	pr7|2,*		gate_name
000272  aa  6 00202 2521 00	spri2	pr6|130
000273  aa  6 00104 3521 00	epp2 	pr6|68		gatep
000274  aa  6 00204 2521 00	spri2	pr6|132
000275  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000276  aa  6 00206 2521 00	spri2	pr6|134
000277  aa   777507 3520 04	epp2 	-185,ic		000006 = 524000000000
000300  aa  6 00210 2521 00	spri2	pr6|136
000301  aa  6 00042 3715 20	epp5 	pr6|34,*
000302  aa  5 00000 3521 20	epp2 	pr5|0,*
000303  aa  6 00212 2521 00	spri2	pr6|138
000304  aa   777505 3520 04	epp2 	-187,ic		000011 = 464000000000
000305  aa  6 00214 2521 00	spri2	pr6|140
000306  aa   777501 3520 04	epp2 	-191,ic		000007 = 404000000043
000307  aa  6 00216 2521 00	spri2	pr6|142
000310  aa  6 00176 6211 00	eax1 	pr6|126
000311  aa   020000 4310 07	fld  	8192,dl
000312  aa  6 00044 3701 20	epp4 	pr6|36,*
000313  la  4 00020 3521 20	epp2 	pr4|16,*		ring0_get_$segptr
000314  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 145
	if code ^= 0 then return;

000315  aa  6 00032 3735 20	epp7 	pr6|26,*
000316  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000317  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 146
	gateno = bin (baseno (gatep), 18);

000320  aa  6 00104 2131 20	epaq 	pr6|68,*		gatep
000321  aa   077777 3750 03	ana  	32767,du
000322  aa   000066 7730 00	lrl  	54
000323  aa  6 00106 7561 00	stq  	pr6|70		gateno
						STATEMENT 1 ON LINE 148
	call ring_zero_peek_ (addrel (lotp0, gateno), addr (pptr), 1, code);

000324  aa  6 00044 3701 20	epp4 	pr6|36,*
000325  ia  4 00014 3521 66	epp2 	pr4|12,*ql	lotp0
000326  aa   000000 0520 03	adwp2	0,du
000327  aa  6 00252 2521 00	spri2	pr6|170
000330  aa  6 00116 3715 00	epp5 	pr6|78		pptr
000331  aa  6 00254 6515 00	spri5	pr6|172
000332  aa   000001 2360 07	ldq  	1,dl
000333  aa  6 00175 7561 00	stq  	pr6|125
000334  aa  6 00252 3521 00	epp2 	pr6|170
000335  aa  6 00200 2521 00	spri2	pr6|128
000336  aa  6 00254 3521 00	epp2 	pr6|172
000337  aa  6 00202 2521 00	spri2	pr6|130
000340  aa  6 00175 3521 00	epp2 	pr6|125
000341  aa  6 00204 2521 00	spri2	pr6|132
000342  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000343  aa  6 00206 2521 00	spri2	pr6|134
000344  aa  6 00176 6211 00	eax1 	pr6|126
000345  aa   020000 4310 07	fld  	8192,dl
000346  la  4 00024 3521 20	epp2 	pr4|20,*		ring_zero_peek_
000347  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 149
	if code ^= 0 then return;

000350  aa  6 00032 3735 20	epp7 	pr6|26,*
000351  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000352  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 150
	l0p = pptr;

000353  aa  6 00116 7651 00	lprp5	pr6|78		pptr
000354  aa  6 00120 6515 00	spri5	pr6|80		l0p
						STATEMENT 1 ON LINE 152
	call ring_zero_peek_ (l0p, addr (linkhdr), size (linkhdr), code);

000355  aa  6 00154 3535 00	epp3 	pr6|108		linkhdr
000356  aa  6 00254 2535 00	spri3	pr6|172
000357  aa   000010 2360 07	ldq  	8,dl
000360  aa  6 00175 7561 00	stq  	pr6|125
000361  aa  6 00120 3521 00	epp2 	pr6|80		l0p
000362  aa  6 00200 2521 00	spri2	pr6|128
000363  aa  6 00254 3521 00	epp2 	pr6|172
000364  aa  6 00202 2521 00	spri2	pr6|130
000365  aa  6 00175 3521 00	epp2 	pr6|125
000366  aa  6 00204 2521 00	spri2	pr6|132
000367  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000370  aa  6 00206 2521 00	spri2	pr6|134
000371  aa  6 00176 6211 00	eax1 	pr6|126
000372  aa   020000 4310 07	fld  	8192,dl
000373  aa  6 00044 3701 20	epp4 	pr6|36,*
000374  la  4 00024 3521 20	epp2 	pr4|20,*		ring_zero_peek_
000375  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 153
	llth = bin (linkhdr.begin_links, 18) - size (linkhdr);

000376  aa  6 00162 2351 00	lda  	pr6|114		linkhdr.begin_links
000377  aa   000066 7730 00	lrl  	54
000400  aa   000010 1760 07	sbq  	8,dl
000401  aa  6 00122 7561 00	stq  	pr6|82		llth
						STATEMENT 1 ON LINE 154
	no_entries = divide (llth, size (gate_entry_data), 17, 0);

000402  aa   000010 5060 07	div  	8,dl
000403  aa  6 00134 7561 00	stq  	pr6|92		no_entries
						STATEMENT 1 ON LINE 155
	if no_entries > 0 then do;

000404  aa   000021 6044 04	tmoz 	17,ic		000425
						STATEMENT 1 ON LINE 156
	     allocate static_data in (ap -> based_area) set (slp);

000405  aa  6 00134 2361 00	ldq  	pr6|92		no_entries
000406  aa   000003 7360 00	qls  	3
000407  aa  6 00044 3701 20	epp4 	pr6|36,*
000410  ia  4 00010 3521 20	epp2 	pr4|8,*		based_area
000411  aa  6 00175 7561 00	stq  	pr6|125
000412  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
000413  aa   777772 7100 04	tra  	-6,ic		000405
000414  aa  6 00112 2521 00	spri2	pr6|74		slp
						STATEMENT 1 ON LINE 157
	     unspec (static_data) = "0"b;

000415  aa  6 00175 2361 00	ldq  	pr6|125
000416  aa   000044 4020 07	mpy  	36,dl
000417  aa   000010 0760 07	adq  	8,dl
000420  aa   000011 5060 07	div  	9,dl
000421  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000422  aa   000000 00 0000	desc9a	0,0
000423  aa  2 00000 00 0006	desc9a	pr2|0,ql
						STATEMENT 1 ON LINE 158
	end;

000424  aa   000003 7100 04	tra  	3,ic		000427
						STATEMENT 1 ON LINE 159
	else slp = null ();

000425  aa   777373 2370 04	ldaq 	-261,ic		000020 = 077777000043 000001000000
000426  aa  6 00112 7571 00	staq 	pr6|74		slp
						STATEMENT 1 ON LINE 161
	defp = ptr (addr (definitions_$), definitions_$ (gateno).offset);

000427  aa  6 00044 3701 20	epp4 	pr6|36,*
000430  la  4 00030 3735 20	epp7 	pr4|24,*		definitions_$
000431  aa  6 00106 7271 00	lxl7 	pr6|70		gateno
000432  la  4 00030 2351 77	lda  	pr4|24,*7		definitions_$.offset
000433  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000434  aa  7 00000 3521 00	epp2 	pr7|0
000435  aa   000000 3120 01	eawp2	0,au
000436  aa  6 00132 2521 00	spri2	pr6|90		defp
						STATEMENT 1 ON LINE 168
	gate_info.linkp = addrel (l0p, 8);

000437  aa  6 00120 3515 20	epp1 	pr6|80,*		l0p
000440  aa   000010 0510 03	adwp1	8,du
000441  aa  6 00100 3715 20	epp5 	pr6|64,*		gp
000442  aa  5 00012 5411 00	sprp1	pr5|10		gate_info.linkp
						STATEMENT 1 ON LINE 169
	gate_info.linkl = llth;

000443  aa  6 00122 2361 00	ldq  	pr6|82		llth
000444  aa  5 00015 7561 00	stq  	pr5|13		gate_info.linkl
						STATEMENT 1 ON LINE 170
	gate_info.defp = defp;

000445  aa  5 00013 5421 00	sprp2	pr5|11		gate_info.defp
						STATEMENT 1 ON LINE 171
	gate_info.textp = gatep;

000446  aa  6 00104 3535 20	epp3 	pr6|68,*		gatep
000447  aa  5 00011 5431 00	sprp3	pr5|9		gate_info.textp
						STATEMENT 1 ON LINE 172
	gate_info.textl = tlth;

000450  aa  6 00126 2361 00	ldq  	pr6|86		tlth
000451  aa  5 00014 7561 00	stq  	pr5|12		gate_info.textl
						STATEMENT 1 ON LINE 173
	gate_info.stp = slp;

000452  aa  6 00112 3535 20	epp3 	pr6|74,*		slp
000453  aa  5 00016 5431 00	sprp3	pr5|14		gate_info.stp
						STATEMENT 1 ON LINE 174
	gate_info.name = gate_name;

000454  aa  6 00032 3535 20	epp3 	pr6|26,*
000455  aa  3 00002 3535 20	epp3 	pr3|2,*
000456  aa  6 00167 2351 00	lda  	pr6|119
000457  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000460  aa  3 00000 00 0005	desc9a	pr3|0,al		gate_name
000461  aa  5 00000 00 0040	desc9a	pr5|0,32		gate_info.name
						STATEMENT 1 ON LINE 175
	gate_info.user = caller_ptr;

000462  aa  6 00102 3715 20	epp5 	pr6|66,*		caller_ptr
000463  aa  6 00100 3535 20	epp3 	pr6|64,*		gp
000464  aa  3 00010 5451 00	sprp5	pr3|8		gate_info.user
						STATEMENT 1 ON LINE 177
found:	
	if gate_info.stp = null () then do;

000465  aa  6 00254 2515 00	spri1	pr6|172
000466  aa  6 00252 6535 00	spri7	pr6|170
000467  aa  6 00100 3735 20	epp7 	pr6|64,*		gp
000470  aa  7 00016 2361 00	ldq  	pr7|14		gate_info.stp
000471  aa   000333 1160 04	cmpq 	219,ic		001024 = 007777000001
000472  aa   000004 6010 04	tnz  	4,ic		000476
						STATEMENT 1 ON LINE 179
	     nentries = 0;

000473  aa  6 00032 3715 20	epp5 	pr6|26,*
000474  aa  5 00006 4501 20	stz  	pr5|6,*		nentries
						STATEMENT 1 ON LINE 180
	     return;

000475  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 181
	end;

						STATEMENT 1 ON LINE 185
	l0p = gate_info.linkp;

000476  aa  7 00012 7651 00	lprp5	pr7|10		gate_info.linkp
000477  aa  6 00120 6515 00	spri5	pr6|80		l0p
						STATEMENT 1 ON LINE 186
	llth = gate_info.linkl;

000500  aa  7 00015 2361 00	ldq  	pr7|13		gate_info.linkl
000501  aa  6 00122 7561 00	stq  	pr6|82		llth
						STATEMENT 1 ON LINE 187
	call ring_zero_peek_ (l0p, tempp, llth, code);

000502  aa  6 00120 3521 00	epp2 	pr6|80		l0p
000503  aa  6 00200 2521 00	spri2	pr6|128
000504  aa  6 00032 3535 20	epp3 	pr6|26,*
000505  aa  3 00010 3521 20	epp2 	pr3|8,*		tempp
000506  aa  6 00202 2521 00	spri2	pr6|130
000507  aa  6 00122 3521 00	epp2 	pr6|82		llth
000510  aa  6 00204 2521 00	spri2	pr6|132
000511  aa  3 00014 3521 20	epp2 	pr3|12,*		code
000512  aa  6 00206 2521 00	spri2	pr6|134
000513  aa  6 00176 6211 00	eax1 	pr6|126
000514  aa   020000 4310 07	fld  	8192,dl
000515  aa  6 00044 3701 20	epp4 	pr6|36,*
000516  la  4 00024 3521 20	epp2 	pr4|20,*		ring_zero_peek_
000517  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 188
	if code ^= 0 then return;

000520  aa  6 00032 3735 20	epp7 	pr6|26,*
000521  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000522  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 192
	slp = gate_info.stp;

000523  aa  6 00100 3715 20	epp5 	pr6|64,*		gp
000524  aa  5 00016 7651 00	lprp5	pr5|14		gate_info.stp
000525  aa  6 00112 6515 00	spri5	pr6|74		slp
						STATEMENT 1 ON LINE 193
	no_entries = divide (llth, size (gate_entry_data), 17, 0);

000526  aa  6 00122 2361 00	ldq  	pr6|82		llth
000527  aa   000010 5060 07	div  	8,dl
000530  aa  6 00134 7561 00	stq  	pr6|92		no_entries
						STATEMENT 1 ON LINE 198
	gatep = gate_info.textp;

000531  aa  6 00100 3535 20	epp3 	pr6|64,*		gp
000532  aa  3 00011 7631 00	lprp3	pr3|9		gate_info.textp
000533  aa  6 00104 2535 00	spri3	pr6|68		gatep
						STATEMENT 1 ON LINE 199
	tlth = gate_info.textl;

000534  aa  6 00100 3515 20	epp1 	pr6|64,*		gp
000535  aa  1 00014 2361 00	ldq  	pr1|12		gate_info.textl
000536  aa  6 00126 7561 00	stq  	pr6|86		tlth
						STATEMENT 1 ON LINE 200
	textp = addrel (tempp, llth);

000537  aa  6 00122 2361 00	ldq  	pr6|82		llth
000540  aa  7 00010 3521 20	epp2 	pr7|8,*		tempp
000541  aa  2 00000 3521 66	epp2 	pr2|0,*ql		tempp
000542  aa   000000 0520 03	adwp2	0,du
000543  aa  6 00130 2521 00	spri2	pr6|88		textp
						STATEMENT 1 ON LINE 201
	call ring_zero_peek_ (gatep, textp, tlth, code);

000544  aa  6 00104 3521 00	epp2 	pr6|68		gatep
000545  aa  6 00200 2521 00	spri2	pr6|128
000546  aa  6 00130 3521 00	epp2 	pr6|88		textp
000547  aa  6 00202 2521 00	spri2	pr6|130
000550  aa  6 00126 3521 00	epp2 	pr6|86		tlth
000551  aa  6 00204 2521 00	spri2	pr6|132
000552  aa  7 00014 3521 20	epp2 	pr7|12,*		code
000553  aa  6 00206 2521 00	spri2	pr6|134
000554  aa  6 00176 6211 00	eax1 	pr6|126
000555  aa   020000 4310 07	fld  	8192,dl
000556  aa  6 00044 3701 20	epp4 	pr6|36,*
000557  la  4 00024 3521 20	epp2 	pr4|20,*		ring_zero_peek_
000560  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 202
	if code ^= 0 then return;

000561  aa  6 00032 3735 20	epp7 	pr6|26,*
000562  aa  7 00014 2361 20	ldq  	pr7|12,*		code
000563  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 204
	savep = addrel (textp, tlth);

000564  aa  6 00126 2361 00	ldq  	pr6|86		tlth
000565  aa  6 00130 3521 66	epp2 	pr6|88,*ql	textp
000566  aa   000000 0520 03	adwp2	0,du
000567  aa  6 00110 2521 00	spri2	pr6|72		savep
						STATEMENT 1 ON LINE 205
	save_data = current_data;

000570  aa  6 00134 2361 00	ldq  	pr6|92		no_entries
000571  aa   000005 7360 00	qls  	5
000572  aa  7 00010 3715 20	epp5 	pr7|8,*		tempp
000573  aa  5 00000 3715 20	epp5 	pr5|0,*		tempp
000574  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
000575  aa  5 00000 00 0006	desc9a	pr5|0,ql		current_data
000576  aa  2 00000 00 0006	desc9a	pr2|0,ql		save_data
						STATEMENT 1 ON LINE 206
	current_data = current_data - static_data;

000577  aa   000001 2360 07	ldq  	1,dl
000600  aa  6 00166 7561 00	stq  	pr6|118
000601  aa   000000 0110 03	nop  	0,du
000602  aa  6 00166 2361 00	ldq  	pr6|118
000603  aa   000003 7360 00	qls  	3
000604  aa  6 00032 3735 20	epp7 	pr6|26,*
000605  aa  7 00010 3715 20	epp5 	pr7|8,*		tempp
000606  aa  5 00000 3715 20	epp5 	pr5|0,*		tempp
000607  aa   000000 6270 06	eax7 	0,ql
000610  aa  5 77770 2371 06	ldaq 	pr5|-8,ql		current_data.cpu_time
000611  aa  6 00112 3535 20	epp3 	pr6|74,*		slp
000612  aa  3 77770 1771 17	sbaq 	pr3|-8,7		static_data.cpu_time
000613  aa  5 77770 7571 17	staq 	pr5|-8,7		current_data.cpu_time
000614  aa  5 77772 2371 17	ldaq 	pr5|-6,7		current_data.vcpu_time
000615  aa  3 77772 1771 17	sbaq 	pr3|-6,7		static_data.vcpu_time
000616  aa  5 77772 7571 17	staq 	pr5|-6,7		current_data.vcpu_time
000617  aa  5 77774 3361 17	lcq  	pr5|-4,7		current_data.page_waits
000620  aa   000044 7770 00	llr  	36
000621  aa   000044 7330 00	lrs  	36
000622  aa  3 77774 0331 17	adl  	pr3|-4,7		static_data.page_waits
000623  aa   000000 5330 00	negl 	0
000624  aa  5 77774 7561 17	stq  	pr5|-4,7		current_data.page_waits
000625  aa  5 77775 3361 17	lcq  	pr5|-3,7		current_data.calls
000626  aa   000044 7770 00	llr  	36
000627  aa   000044 7330 00	lrs  	36
000630  aa  3 77775 0331 17	adl  	pr3|-3,7		static_data.calls
000631  aa   000000 5330 00	negl 	0
000632  aa  5 77775 7561 17	stq  	pr5|-3,7		current_data.calls
000633  aa  5 77776 3361 17	lcq  	pr5|-2,7		current_data.ring_alarms
000634  aa   000044 7770 00	llr  	36
000635  aa   000044 7330 00	lrs  	36
000636  aa  3 77776 0331 17	adl  	pr3|-2,7		static_data.ring_alarms
000637  aa   000000 5330 00	negl 	0
000640  aa  5 77776 7561 17	stq  	pr5|-2,7		current_data.ring_alarms
000641  aa  5 77777 3361 17	lcq  	pr5|-1,7		current_data.pad
000642  aa   000044 7770 00	llr  	36
000643  aa   000044 7330 00	lrs  	36
000644  aa  3 77777 0331 17	adl  	pr3|-1,7		static_data.pad
000645  aa   000000 5330 00	negl 	0
000646  aa  5 77777 7561 17	stq  	pr5|-1,7		current_data.pad
000647  aa  6 00166 2361 00	ldq  	pr6|118
000650  aa  6 00166 0541 00	aos  	pr6|118
000651  aa  6 00134 1161 00	cmpq 	pr6|92		no_entries
000652  aa   777730 6040 04	tmi  	-40,ic		000602
						STATEMENT 1 ON LINE 210
	linkp = addrel (tempp, -8);

000653  aa  7 00010 3521 20	epp2 	pr7|8,*		tempp
000654  aa  2 00000 3521 20	epp2 	pr2|0,*		tempp
000655  aa   777770 0520 03	adwp2	262136,du
000656  aa  6 00124 2521 00	spri2	pr6|84		linkp
						STATEMENT 1 ON LINE 211
	defp = gate_info.defp;

000657  aa  6 00100 3515 20	epp1 	pr6|64,*		gp
000660  aa  1 00013 7611 00	lprp1	pr1|11		gate_info.defp
000661  aa  6 00132 2515 00	spri1	pr6|90		defp
						STATEMENT 1 ON LINE 213
	i = lbound (table, 1);

000662  aa  6 00042 3715 20	epp5 	pr6|34,*
000663  aa  5 00002 3535 20	epp3 	pr5|2,*
000664  aa  3 00001 2361 00	ldq  	pr3|1
000665  aa  6 00140 7561 00	stq  	pr6|96		i
						STATEMENT 1 ON LINE 214
	do p = defp repeat addrel (defp, p -> definition.forward)
		while (p -> definition.forward);

000666  aa  6 00136 2515 00	spri1	pr6|94		p
000667  aa   000000 0110 03	nop  	0,du
000670  aa  6 00136 2351 20	lda  	pr6|94,*		definition.forward
000671  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000672  aa  6 00175 7551 00	sta  	pr6|125		definition.forward
000673  aa   000110 6000 04	tze  	72,ic		001003
						STATEMENT 1 ON LINE 216
	     if i > hbound (table, 1) then go to done;

000674  aa  6 00140 2361 00	ldq  	pr6|96		i
000675  aa  6 00042 3735 20	epp7 	pr6|34,*
000676  aa  7 00002 3715 20	epp5 	pr7|2,*
000677  aa  5 00002 1161 00	cmpq 	pr5|2
000700  aa   000103 6054 04	tpnz 	67,ic		001003
						STATEMENT 1 ON LINE 218
	     if p -> definition.ignore then		/* If this isn't really an entry */
		go to next_entry;

000701  aa  6 00136 3535 20	epp3 	pr6|94,*		p
000702  aa  3 00001 2351 00	lda  	pr3|1		definition.ignore
000703  aa   200000 3150 07	cana 	65536,dl
000704  aa   000071 6010 04	tnz  	57,ic		000775
						STATEMENT 1 ON LINE 220
	     if p -> definition.class ^= "0"b then	/* Test for segdef to text. */
		go to next_entry;

000705  aa  3 00001 2351 00	lda  	pr3|1		definition.class
000706  aa   000007 3150 07	cana 	7,dl
000707  aa   000066 6010 04	tnz  	54,ic		000775
						STATEMENT 1 ON LINE 223
	     namep = addrel (defp, p -> definition.symbol);

000710  aa  3 00002 2351 00	lda  	pr3|2		definition.symbol
000711  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000712  aa  6 00132 3521 61	epp2 	pr6|90,*au	defp
000713  aa   000000 0520 03	adwp2	0,du
000714  aa  6 00142 2521 00	spri2	pr6|98		namep
						STATEMENT 1 ON LINE 225
	     if acc_name.name = ".my_lp" then goto next_entry;

000715  aa  2 00000 2351 00	lda  	pr2|0		acc_name.size
000716  aa   000077 7330 00	lrs  	63
000717  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000720  aa  2 00000 20 0006	desc9a	pr2|0(1),ql	acc_name.name
000721  aa   777077 00 0006	desc9a	-449,6		000016 = 056155171137
000722  aa   000053 6000 04	tze  	43,ic		000775
						STATEMENT 1 ON LINE 226
	     if acc_name.name = ".tv_end" then goto next_entry;

000723  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000724  aa  2 00000 20 0006	desc9a	pr2|0(1),ql	acc_name.name
000725  aa   777071 00 0007	desc9a	-455,7		000014 = 056164166137
000726  aa   000047 6000 04	tze  	39,ic		000775
						STATEMENT 1 ON LINE 228
	     entryp = addrel (textp, p -> definition.value);

000727  aa  3 00001 2351 00	lda  	pr3|1		definition.value
000730  aa  6 00256 7561 00	stq  	pr6|174		acc_name.size
000731  aa  6 00174 7561 00	stq  	pr6|124
000732  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000733  aa  6 00130 3515 61	epp1 	pr6|88,*au	textp
000734  aa   000000 0510 03	adwp1	0,du
000735  aa  6 00144 2515 00	spri1	pr6|100		entryp
						STATEMENT 1 ON LINE 230
	     vrel = entryp -> gate_entry.body_ptr;

000736  aa  1 00000 2351 00	lda  	pr1|0		gate_entry.body_ptr
000737  aa  6 00146 7551 00	sta  	pr6|102		vrel
						STATEMENT 1 ON LINE 231
	     vp = addrel (textp, vrel);

000740  aa  6 00130 3521 61	epp2 	pr6|88,*au	textp
000741  aa   000000 0520 03	adwp2	0,du
000742  aa  6 00150 2521 00	spri2	pr6|104		vp
						STATEMENT 1 ON LINE 232
	     vp = addrel (vp, -1);

000743  aa   777777 0520 03	adwp2	262143,du
000744  aa  6 00150 2521 00	spri2	pr6|104		vp
						STATEMENT 1 ON LINE 233
	     datarel = vp -> gate_body.info_ptr;

000745  aa  2 00000 2351 00	lda  	pr2|0		gate_body.info_ptr
000746  aa   000022 7350 00	als  	18
000747  aa  6 00152 7551 00	sta  	pr6|106		datarel
						STATEMENT 1 ON LINE 234
	     if datarel = "0"b then goto next_entry;

000750  aa   000025 6000 04	tze  	21,ic		000775
						STATEMENT 1 ON LINE 235
	     gate_datap = addrel (linkp, datarel);

000751  aa  6 00124 3521 61	epp2 	pr6|84,*au	linkp
000752  aa   000000 0520 03	adwp2	0,du
000753  aa  6 00164 2521 00	spri2	pr6|116		gate_datap
						STATEMENT 1 ON LINE 237
	     table (i).entryp = addr (acc_name.name);

000754  aa  5 00003 2361 00	ldq  	pr5|3
000755  aa  5 00001 4021 00	mpy  	pr5|1
000756  aa  6 00257 7561 00	stq  	pr6|175
000757  aa  5 00003 2361 00	ldq  	pr5|3
000760  aa  6 00140 4021 00	mpy  	pr6|96		i
000761  aa  6 00257 1761 00	sbq  	pr6|175
000762  aa   000001 7270 07	lxl7 	1,dl
000763  aa  6 00142 3715 20	epp5 	pr6|98,*		acc_name.name
000764  aa  5 00000 5005 17	a9bd 	pr5|0,7
000765  aa  6 00032 3735 20	epp7 	pr6|26,*
000766  aa  7 00004 5451 66	sprp5	pr7|4,*ql		table.entryp
						STATEMENT 1 ON LINE 238
	     table (i).entryl = acc_name.size;

000767  aa   000000 6260 06	eax6 	0,ql
000770  aa  6 00256 2361 00	ldq  	pr6|174		acc_name.size
000771  aa  7 00004 3535 20	epp3 	pr7|4,*
000772  aa  3 00001 7561 16	stq  	pr3|1,6		table.entryl
						STATEMENT 1 ON LINE 239
	     table (i).datap = gate_datap;

000773  aa  3 00002 5421 16	sprp2	pr3|2,6		table.datap
						STATEMENT 1 ON LINE 241
	     i = i + 1;

000774  aa  6 00140 0541 00	aos  	pr6|96		i
						STATEMENT 1 ON LINE 242
next_entry:
	end;

000775  aa  6 00260 6515 00	spri5	pr6|176
000776  aa  6 00175 2351 00	lda  	pr6|125		definition.forward
000777  aa  6 00132 3521 61	epp2 	pr6|90,*au	defp
001000  aa   000000 0520 03	adwp2	0,du
001001  aa  6 00136 2521 00	spri2	pr6|94		p
001002  aa   777666 7100 04	tra  	-74,ic		000670
						STATEMENT 1 ON LINE 245
done:
	nentries = i - lbound (table, 1);

001003  aa  6 00140 2361 00	ldq  	pr6|96		i
001004  aa  6 00042 3735 20	epp7 	pr6|34,*
001005  aa  7 00002 3715 20	epp5 	pr7|2,*
001006  aa  5 00001 1761 00	sbq  	pr5|1
001007  aa  6 00032 3535 20	epp3 	pr6|26,*
001010  aa  3 00006 7561 20	stq  	pr3|6,*		nentries
						STATEMENT 1 ON LINE 248
	if reset_sw then				/* If reset desired ... */
	     static_data = save_data;

001011  aa  3 00012 2351 20	lda  	pr3|10,*		reset_sw
001012  aa   400000 3150 03	cana 	131072,du
001013  aa   000010 6000 04	tze  	8,ic		001023
001014  aa  6 00134 2361 00	ldq  	pr6|92		no_entries
001015  aa   000005 7360 00	qls  	5
001016  aa  6 00112 3515 20	epp1 	pr6|74,*		slp
001017  aa  6 00110 3715 20	epp5 	pr6|72,*		savep
001020  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
001021  aa  5 00000 00 0006	desc9a	pr5|0,ql		save_data
001022  aa  1 00000 00 0006	desc9a	pr1|0,ql		static_data
						STATEMENT 1 ON LINE 251
	return;

001023  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 256
     end get_gate_data_;

  END PROCEDURE get_gate_data_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
