	COMPILATION LISTING OF SEGMENT reader_driver_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1340.9 mst Fri
	    Options: optimize map

        1 /****^  ************************************************************
        2*        *                                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                 *
        4*        *                                                          *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982  *
        6*        *                                                          *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1980. *
        8*        *                                                          *
        9*        ************************************************************ */
       10 
       11 
       12 
       13 /* format: style2 */
       14 reader_driver_:
       15      procedure;
       16 
       17 	return;					/* this is not a legal entry */
       18 
       19 /* Standard reader device driver control module for the I/O daemon. */
       20 
       21 /* Stolen from punch_driver_ 12 24 79 */
       22 /* Cleaned up for installation October 1980 */
       23 /* Coded by Benson I. Margulies, give or take the above */
       24 /* Modified: February 23, 1985 by C. Marker to use version 5 message segments */
       25 
       26 
       27 /****^  HISTORY COMMENTS:
       28*  1) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       29*     audit(88-10-17,Wallman), install(88-10-28,MR12.2-1199):
       30*     Upgraded to version 5 iod tables.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 /*        BASED  */
       35 
       36 	dcl     sys_dir		 char (168) based (iodd_static.sys_dir_ptr);
       37 
       38 /*	AUTOMATIC VARIABLES */
       39 
       40 	dcl     age		 fixed bin;
       41 	dcl     date_string		 char (24);
       42 	dcl     code		 fixed bin (35);
       43 	dcl     i			 fixed bin;	/* general index variable */
       44 	dcl     io_stat		 bit (72) aligned;	/* ios_ status code */
       45 	dcl     major_args		 char (major_args_length) based (major_args_ptr);
       46 	dcl     major_args_ptr	 ptr;
       47 	dcl     major_args_length	 fixed bin;
       48 	dcl     major_args_name	 char (256) varying;
       49 	dcl     retry_sw		 bit (1);
       50 
       51 	dcl     1 st		 aligned based (addr (io_stat)),
       52 						/* breakdown of status code */
       53 		2 code		 fixed bin (35),
       54 		2 flags		 bit (36);
       55 
       56 	dcl     station		 char (32);
       57 
       58 /*	EXTERNAL ENTRIES    */
       59 
       60 	dcl     add_char_offset_	 entry (ptr, fixed bin (21)) returns (ptr) reducible;
       61 	dcl     date_time_		 entry (fixed bin (71), char (*));
       62 	dcl     expand_pathname_$component
       63 				 entry (char (*), char (*), char (*), char (*), fixed bin (35));
       64 	dcl     initiate_file_$component
       65 				 entry (char (*), char (*), char (*), bit (*), ptr, fixed bin (24),
       66 				 fixed bin (35));
       67 	dcl     iodd_listen_	 entry (ptr);
       68 	dcl     iodd_msg_		 entry options (variable);
       69 	dcl     iodd_parse_$args	 entry (char (*) var, char (*)) returns (char (256) var);
       70 	dcl     ios_$setsize	 entry (char (*) aligned, fixed bin (21), bit (72) aligned);
       71 	dcl     ios_$attach		 entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned,
       72 				 bit (72) aligned);
       73 	dcl     ios_$detach		 entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
       74 	dcl     ios_$getsize	 entry (char (*) aligned, fixed bin, bit (72) aligned);
       75 	dcl     pool_manager_$init	 entry (char (*), fixed bin, bit (36) aligned, fixed bin (35));
       76 	dcl     pool_manager_$clean_pool
       77 				 entry (char (*), fixed bin, fixed bin, fixed bin (35));
       78 	dcl     read_cards_		 entry (char (*), ptr, char (*), bit (1) aligned, fixed bin (35));
       79 	dcl     read_cards_$set_rqt	 entry (char (*), char (*), fixed bin (35));
       80 	dcl     read_cards_$set_station
       81 				 entry (char (*), fixed bin (35));
       82 
       83 /*	INTERNAL STATIC   */
       84 
       85 
       86 	dcl     pool_dir		 char (168) internal static;
       87 	dcl     meter_sw		 bit (1) int static;/* TRUE - if we are to keep metering data (future) */
       88 	dcl     p			 ptr int static;
       89 	dcl     both		 fixed bin int static options (constant) init (0);
       90 	dcl     master		 fixed bin int static options (constant) init (1);
       91 	dcl     slave		 fixed bin int static options (constant) init (2);
       92 	dcl     normal		 fixed bin int static options (constant) init (1);
       93 	dcl     error		 fixed bin int static options (constant) init (2);
       94 	dcl     whoami		 char (25) int static options (constant) init ("reader_driver_");
       95 	dcl     terminals		 (2) int static char (32);
       96 	dcl     DEFAULT_STATION	 char (6) init ("reader") int static options (constant);
       97 
       98 	dcl     card_dims		 (3) aligned int static /* format stream (switch) data structure */ char (32)
       99 				 init ("mcc_", "viipunch_", "raw_") options (constant);
      100 
      101 /*	BUILTINS    */
      102 
      103 	dcl     (addr, clock, convert, divide, rtrim)
      104 				 builtin;
      105 
      106 /*	CONDITIONS   */
      107 
      108 	dcl     (cleanup, card_command_level)
      109 				 condition;
      110 
      111 
      112 /*	EXTERNAL STATIC -- ERROR TABLE ENTRIES     */
      113 
      114 	dcl     error_table_$action_not_performed
      115 				 fixed bin (35) ext static;
      116 	dcl     error_table_$fatal_error
      117 				 fixed bin (35) ext static;
      118 	dcl     error_table_$ionmat	 fixed bin (35) ext static;
      119 
      120 	dcl     1 card_info		 aligned static like card_stream_info;
      121 





      122 
      123 init:
      124      entry (arg_p);
      125 
      126 	dcl     arg_p		 ptr;
      127 
      128 	stat_p = arg_p;				/* put the arg into static for easy reference */
      129 	text_strings_ptr = iodd_static.text_strings_ptr;	/* get ptr to i/o daemon table text area */
      130 	p = iodd_static.driver_ptr;			/* get current driver status ptr */
      131 	terminals (master) = iodd_static.master_input;
      132 	terminals (slave) = "Undefined";
      133 	retry_sw = "1"b;				/* retry attachments once on error */
      134 
      135 	if iodd_static.attach_type ^= ATTACH_TYPE_IOM
      136 	then do;					/* this driver expects an IOM channel */
      137 		code = error_table_$fatal_error;
      138 		call iodd_msg_ (error, master, code, whoami,
      139 		     "This driver requires a reader attached through the IOM.");
      140 		return;				/* quit now */
      141 	     end;
      142 
      143 	if iodd_static.assigned_devices > 1
      144 	then do;					/* be sure all is correct */
      145 		code = error_table_$fatal_error;
      146 		call iodd_msg_ (error, master, code, whoami,
      147 		     "Multiple minor devices are not supported by the reader driver.");
      148 		return;
      149 	     end;
      150 
      151 /* see if user wants major args to be found in a segment */
      152 	major_args_ptr = add_char_offset_ (addr (text_strings.chars), (iodd_static.major_args.first_char));
      153 	major_args_length = iodd_static.major_args.total_chars;
      154 	major_args_name = iodd_parse_$args ("indirect=", major_args);
      155 	if major_args_name ^= ""
      156 	then do;					/* yes, grab that segment */
      157 		call initiate_the_file (major_args_name, major_args_ptr, major_args_length, "major_args", code);
      158 		if code ^= 0
      159 		then go to clean_out;
      160 	     end;
      161 
      162 	iodd_static.device_dim = iodd_parse_$args ("dim=", major_args);
      163 						/* see if a dim was specified */
      164 	if iodd_static.device_dim = ""
      165 	then iodd_static.device_dim = "crz";		/* no, use the default */
      166 	iodd_static.dev_out_stream = "Undefined";
      167 	iodd_static.dev_io_stream = iodd_static.dev_out_stream;
      168 						/* make them the same */
      169 	iodd_static.dev_in_stream = "card_in_stream";
      170 
      171 /* TIME TO GET STATION ID */
      172 
      173 	station = iodd_parse_$args ("station=", major_args);
      174 	if station = ""
      175 	then station = DEFAULT_STATION;
      176 	call read_cards_$set_station (station, code);
      177 	if code ^= 0
      178 	then do;
      179 		call iodd_msg_ (error, master, code, whoami, "Fatal Error: Could not set station to ^a.", station);
      180 		return;
      181 	     end;
      182 	call read_cards_$set_rqt ("printer", "punch", code);
      183 						/* make the rje active functions work right */
      184 
      185 	if code ^= 0
      186 	then do;
      187 		call iodd_msg_ (error, master, code, whoami, "Fatal Error: Unable to set default request types.");
      188 		return;
      189 	     end;
      190 
      191 attach:
      192 	call ios_$attach (iodd_static.dev_in_stream, iodd_static.device_dim, iodd_static.attach_name, "", io_stat);
      193 	if st.code ^= 0
      194 	then do;
      195 		if st.code = error_table_$ionmat & retry_sw
      196 		then do;				/* can we try again */
      197 retry:
      198 			retry_sw = "0"b;		/* yes, but only once */
      199 			call detach_all;		/* clear the slate */
      200 			go to attach;
      201 		     end;
      202 		call iodd_msg_ (2, master, st.code, whoami, "Fatal Error: Unable to attach channel ^a",
      203 		     iodd_static.attach_name);
      204 		go to clean_out;
      205 	     end;
      206 	if iodd_static.test_entry
      207 	then call ios_$setsize (iodd_static.dev_in_stream, 972, io_stat);
      208 	card_info.control_stream = "mcc_card_input_";	/* we use this to read control cards */
      209 	card_info.n_streams = 4;			/* we will support 4 input formats */
      210 
      211 	card_info.format (1) = "mcc";			/* first describe the MCC format stream */
      212 	card_info.name (1) = "mcc_card_input_";		/* this is also the control stream */
      213 	card_info.format (2) = "viipunch";		/* next we have the 7 punch format */
      214 	card_info.name (2) = "viipunch_card_input_";
      215 
      216 	card_info.format (3) = "raw";			/* next is the raw card format */
      217 	card_info.name (3) = "raw_card_input_";
      218 
      219 	card_info.format (4) = "rmcc";		/* last is rmcc for compatability with remote input */
      220 	card_info.name (4) = "mcc_card_input_";		/* this is the same as mcc format */
      221 
      222 	if iodd_static.test_entry
      223 	then pool_dir = rtrim (iodd_static.sys_dir_ptr -> sys_dir) || ">card_pool";
      224 	else pool_dir = "System_Card_Pool";
      225 	call pool_manager_$init (pool_dir, 10, "01000"b, code);
      226 	if code ^= 0
      227 	then do;
      228 		call iodd_msg_ (2, master, code, whoami, "Fatal Error: cannot initialize card pool.");
      229 		go to clean_out;
      230 	     end;
      231 	on cleanup call detach_all;			/* for reinit, no_coord, logout, new_device, etc... */
      232 
      233 /*	set up the reader code formatting dims corresponding to the dprint_msg outer_module variable */
      234 
      235 	do i = 1 to 3;
      236 	     call ios_$attach (card_info.name (i), card_dims (i), iodd_static.dev_in_stream, "", io_stat);
      237 	     if st.code ^= 0
      238 	     then do;
      239 		     if st.code = error_table_$ionmat & retry_sw
      240 		     then go to retry;		/* start_over */
      241 		     call iodd_msg_ (2, master, st.code, whoami, "Fatal Error: Unable to attach ^a to ^a.",
      242 			card_info.name (i), iodd_static.dev_in_stream);
      243 		     go to clean_out;
      244 		end;
      245 	end;
      246 
      247 	do i = 1 to card_info.n_streams;
      248 	     call ios_$getsize (card_info.name (i), card_info.el_size (i), io_stat);
      249 	     if st.code ^= 0
      250 	     then do;
      251 		     call iodd_msg_ (2, master, st.code, whoami, "Fatal Error: Invalid getsize call for dim ^a.",
      252 			card_dims (i));
      253 		     go to clean_out;
      254 		end;
      255 	end;
      256 
      257 	if iodd_static.ctl_term.attached
      258 	then do;
      259 		call iodd_msg_ (2, master, st.code, whoami, "The reader driver does not support a ctl terminal.");
      260 		go to clean_out;
      261 	     end;
      262 
      263 	meter_sw = "0"b;				/* no metering  (future) */
      264 
      265 	call date_time_ (clock (), date_string);	/* get set for ready message */
      266 
      267 	call iodd_msg_ (1, both, 0, "", "^/^a driver ready for station ^a at ^16a^/", p -> driver_status.dev_name_label,
      268 	     station, date_string);
      269 
      270 	call iodd_listen_ (stat_p);			/* iodd_listen_ will never return */
      271 
      272 clean_out:					/* this label is for error recovery */
      273 	call detach_all;
      274 	return;
      275 
      276 request:
      277      entry;
      278 
      279 /*
      280*   This is the entry which is called by the iodd_listen_ procedure when a request
      281*   for this driver has been received from the coordinator.
      282*
      283*   The purpose of the code for this entry of the reader driver is to
      284*   complain bitterly!! */
      285 
      286 	call iodd_msg_ (2, master, 0, "", "The reader device can't accept requests.");
      287 
      288 	return;
      289 
      290 command:
      291      entry (source, state, arg_list_p, c_code);
      292 
      293 	dcl     source		 fixed bin;	/* 1 = master console, 2 = slave */
      294 	dcl     state		 fixed bin;	/* 0 = not quite ready to handle a request */
      295 						/* 1 = drivers are ready */
      296 						/* 2 = command entered after a quit */
      297 	dcl     arg_list_p		 ptr;		/* ptr to structure returned by parse_command_ */
      298 	dcl     c_code		 fixed bin (35);	/* error code: zero if command handled correctly */
      299 						/* error_table_ code for bad syntax or unknown command */
      300 	dcl     1 arg_list		 aligned based (arg_list_p),
      301 						/* parse_command_ structure */
      302 		2 max_tokens	 fixed bin,	/* space allocated, do not change */
      303 		2 n_tokens	 fixed bin,	/* number of tokens from command line (including cmd) */
      304 		2 command		 char (64) var,	/* the first token is the command */
      305 		2 arg		 (n_tokens - 1) char (64) var;
      306 						/* the other tokens are args to the command */
      307 
      308 	if command = "help"
      309 	then do;
      310 		call iodd_msg_ (normal, source, 0, "", "^/** Commands for the reader driver **^/");
      311 		call iodd_msg_ (normal, source, 0, "", "clean_pool <days allowed to remain>");
      312 		call iodd_msg_ (normal, source, 0, "", "read_cards");
      313 
      314 		c_code = 0;			/* it was understood */
      315 	     end;
      316 	if command = "read_cards" | command = "readcards"
      317 	then do;
      318 		c_code = 0;
      319 		call iodd_msg_ (normal, source, 0, "", "Card input started.");
      320 
      321 		on card_command_level goto abort_read;	/* grab control after record quota overflow */
      322 
      323 		call read_cards_ (pool_dir, addr (card_info), terminals (source), (iodd_static.test_entry), code);
      324 		if code ^= 0
      325 		then do;
      326 			call iodd_msg_ (normal, source, code, whoami, "Check card deck format.");
      327 			c_code = code;
      328 			return;
      329 		     end;
      330 		return;
      331 
      332 abort_read:
      333 		call iodd_msg_ (normal, source, 0, "", "Use the ""clean_pool"" command and retry card input.");
      334 		go to cmd_error;
      335 	     end;
      336 
      337 	if command = "clean_pool" | command = "cleanpool"
      338 	then do;					/* garbage collect the card pool */
      339 		if arg_list.n_tokens < 2
      340 		then do;				/* we must have an age arg */
      341 			call iodd_msg_ (normal, source, 0, "",
      342 			     "Argument missing: days allowed to remain in the pool.");
      343 			go to cmd_error;
      344 		     end;
      345 		age = convert (age, arg_list.arg (1));	/* convert to binary */
      346 		if age < 1
      347 		then do;				/* be sure the value is right */
      348 			call iodd_msg_ (normal, source, 0, "", "Invalid argument: ^a", arg (1));
      349 			go to cmd_error;
      350 		     end;
      351 		call pool_manager_$clean_pool (pool_dir, age, 10, code);
      352 						/* let pool_manager_ do the work */
      353 		if code ^= 0
      354 		then call iodd_msg_ (normal, source, code, whoami, "Unable to clean the card pool.");
      355 		c_code = code;
      356 		return;
      357 	     end;
      358 
      359 	return;					/* return any undefined commands without changing anything */
      360 
      361 cmd_error:
      362 	c_code = error_table_$action_not_performed;
      363 	return;
      364 
      365 
      366 detach_all:
      367      proc;
      368 
      369 /* cleanup proc to detach all possible streams we could have attached */
      370 
      371 	call ios_$detach (iodd_static.dev_in_stream, "", "", io_stat);
      372 	do i = 1 to card_info.n_streams;
      373 	     call ios_$detach (card_info.name (i), "", "", io_stat);
      374 	end;
      375 	return;
      376 
      377      end detach_all;
      378 
      379 
      380 initiate_the_file:
      381      proc (pathname_string, args_ptr, args_length, message, code);
      382 
      383 	dcl     pathname_string	 char (256) varying;
      384 	dcl     args_ptr		 ptr;
      385 	dcl     args_length		 fixed bin;
      386 	dcl     message		 char (*);
      387 	dcl     code		 fixed bin (35);
      388 
      389 	dcl     dirname		 char (168);
      390 	dcl     entname		 char (32);
      391 	dcl     compname		 char (32);
      392 	dcl     args_bc		 fixed bin (24);
      393 
      394 	call expand_pathname_$component ((pathname_string), dirname, entname, compname, code);
      395 	if code ^= 0
      396 	then return;
      397 	call initiate_file_$component (dirname, entname, compname, R_ACCESS, args_ptr, args_bc, code);
      398 	if code ^= 0
      399 	then return;
      400 	args_length = divide (args_bc + 8, 9, 17, 0);
      401 
      402      end initiate_the_file;
      403 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      404 
      405 
  2     1 /* BEGIN INCLUDE FILE ... card_stream_info.incl.pl1 */
  2     2 
  2     3 /* This is the info structure passed to read_cards_ which defines the data streams
  2     4*   used to interpret user card decks according to the Multics card input facility. */
  2     5 
  2     6 dcl  stream_info_ptr ptr;
  2     7 
  2     8 dcl 1 card_stream_info aligned based (stream_info_ptr),
  2     9     2 control_stream char (32),			/* stream used for control card reading */
  2    10     2 n_streams fixed bin,				/* number of data streams active in the list */
  2    11     2 data_streams (5),				/* array of streams for different card formats */
  2    12       3 format char (12),				/* name of the stream format (e.g. mcc, raw) */
  2    13       3 name char (32),				/* name of the stream as attached */
  2    14       3 el_size fixed bin;				/* element size for the stream */
  2    15 
  2    16 /* END INCLUDE FILE ... card_stream_info.incl.pl1 */
      406 
      407 
  3     1 /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  3     7*     Ancient History
  3     8*     Coded by Robert S. Coren August 1973
  3     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  3    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  3    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  3    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  3    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  3    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  3    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  3    16*     to denote accounting ^= nothing.
  3    17*                                                   END HISTORY COMMENTS */
  3    18 
  3    19 
  3    20 /* status data for a logical device driver */
  3    21 
  3    22 /* format: style4 */
  3    23 
  3    24 dcl  driver_status_ptr ptr;
  3    25 dcl  1 driver_status aligned based (driver_status_ptr),
  3    26        2 req_type_label char (32),			/* string to describe the request type */
  3    27        2 dev_name_label char (32),			/* string to describe the device */
  3    28        2 device_id char (32),				/* minor device name used by this logical driver */
  3    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  3    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  3    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  3    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  3    33        2 request_pending bit (36),			/* locking word for communication with coord */
  3    34 						/* 0 = ready for a request  */
  3    35 						/* driver pid = don't bug me */
  3    36 						/* coord  pid = got a request */
  3    37        2 status_flags,
  3    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  3    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  3    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  3    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  3    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  3    43          3 pad bit (31) unal,
  3    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  3    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  3    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  3    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  3    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  3    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  3    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  3    51 						/* for this logical driver */
  3    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  3    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  3    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  3    55        2 dev_out_stream char (32),			/* output stream for minor device */
  3    56        2 dev_in_stream char (32),			/* input stream for minor device */
  3    57        2 elem_size fixed bin,				/* element size for the stream */
  3    58        2 message_type fixed bin,			/* expected format of user request */
  3    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  3    60        2 forms_validation_ptr ptr,			/* forms validation data */
  3    61        2 dev_ptr1 ptr,				/* another one */
  3    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  3    63        2 dev_fb2 fixed bin,				/* and another */
  3    64        2 dev_fb3 fixed bin,				/* and another */
  3    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  3    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  3    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  3    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  3    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  3    70        2 generic_type char (32),			/* generic type of this minor device */
  3    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  3    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  3    73        2 desc_pad (13) fixed bin,
  3    74        2 message fixed bin;				/* place-holder for copy of request message */
  3    75 
  3    76 
  3    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
      408 
      409 
  4     1 /* BEGIN INCLUDE FILE ... iod_constants.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(88-08-31,Brunelle), approve(88-08-31,MCR7911),
  4     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4     7*     Created.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10 /* This file contains constants used by the I/O Daemon software in various tables */
  4    11 
  4    12 /* format: style4 */
  4    13 
  4    14 /* literals for use with idte.attach_type & iodd_static.attach_type */
  4    15 dcl  (ATTACH_TYPE_IOM init (1),
  4    16      ATTACH_TYPE_TTY init (2),
  4    17      ATTACH_TYPE_DIAL init (3),
  4    18      ATTACH_TYPE_VARIABLE_LINE init (4)) fixed bin int static options (constant);
  4    19 
  4    20 /* literals for use with idte.ctl_attach_type & iodd_static.ctl_attach_type */
  4    21 dcl  (CTL_ATTACH_TYPE_TTY init (1),
  4    22      CTL_ATTACH_TYPE_DIAL init (2),
  4    23      CTL_ATTACH_TYPE_MC init (3)) fixed bin int static options (constant);
  4    24 
  4    25 /* literals for use with idte.paper_type & iodd_static.paper_type */
  4    26 dcl  (PAPER_TYPE_DEFAULT init (-1),
  4    27      PAPER_TYPE_SINGLE init (1),
  4    28      PAPER_TYPE_CONTINUOUS init (2)) fixed bin int static options (constant);
  4    29 
  4    30 /* END INCLUDE FILE ... iod_constants.incl.pl1 */
      410 
      411 
  5     1 /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Created by J. Stern, 1/20/75
  5     9*     Modified by J. C. Whitmore April 1978 for enhancements
  5    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  5    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  5    12*     q_group_tab
  5    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  5    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    15*     Change version number to reflect changes in q_group_tab and
  5    16*     iod_device_tab for laser printer support.  Added font tables.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 /* format: style4 */
  5    21 
  5    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  5    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  5    24        2 version char (8),				/* version of this structure */
  5    25        2 date_time_compiled fixed bin (71),
  5    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  5    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  5    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  5    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  5    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  5    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  5    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  5    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  5    34        2 text_strings_offset fixed bin (18),
  5    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  5    36 
  5    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  5    38 dcl  text_strings_ptr ptr;
  5    39 dcl  1 text_strings aligned based (text_strings_ptr),
  5    40        2 length fixed bin,
  5    41        2 chars char (1 refer (text_strings.length)) unaligned;
  5    42 
  5    43 /* this defines text offsets used to locate i/o daemon tables strings in
  5    44*   the text_strings structure */
  5    45 dcl  1 text_offset based,
  5    46        2 first_char fixed bin (18) unsigned unaligned,
  5    47        2 total_chars fixed bin (18) unsigned unaligned;
  5    48 
  5    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  5    50 
  5    51 
  5    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      412 
      413 
  6     1 /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  6     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  6     7*     Add support for logout_on_hangup option.
  6     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    10*     Add head/tail_sheet entry variables and paper_type variable.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 /* format: style4 */
  6    14 
  6    15 dcl  stat_p int static ptr;
  6    16 
  6    17 dcl  1 iodd_static based (stat_p) aligned,
  6    18 
  6    19 /*    The first part is set only once for a device driver */
  6    20 
  6    21        2 ithp ptr,					/* pointer to iod tables header */
  6    22        2 ltp ptr,					/* pointer to line table */
  6    23        2 idtp ptr,					/* pointer to device tab */
  6    24        2 mdtp ptr,					/* pointer to minor device table */
  6    25        2 qgtp ptr,					/* pointer to q_group table */
  6    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  6    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  6    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  6    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  6    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  6    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  6    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  6    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  6    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  6    35        2 log_stream char (32),			/* stream name used for log output */
  6    36        2 master_input char (32),			/* master console input stream for commands */
  6    37        2 master_output char (32),			/* master console output stream for messages */
  6    38        2 master_out ptr,				/* master output iocbp */
  6    39        2 master_in ptr,				/* master input iocbp */
  6    40        2 log_iocbp ptr,				/* log output iocbp */
  6    41        2 error_io ptr,				/* error i/o iocbp */
  6    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  6    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  6    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  6    45        2 device_dim char (32),			/* dim which drives the major device */
  6    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  6    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  6    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  6    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  6    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  6    51        2 major_device char (32),			/* name of the major device */
  6    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  6    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  6    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  6    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  6    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  6    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  6    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  6    59 
  6    60 /*    driver module entrypoints are defined by the following entry variables */
  6    61 
  6    62        2 driver_init entry variable options (variable),
  6    63        2 driver_request entry variable options (variable),
  6    64        2 driver_command entry variable options (variable),
  6    65        2 driver_default_handler entry variable options (variable),
  6    66 
  6    67 /*    entrypoints for head/tail_sheet_ entries */
  6    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  6    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  6    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  6    71 
  6    72        2 paper_type fixed bin,			/* type of paper being used */
  6    73 						/* 1 = single sheet */
  6    74 						/* 2 = continuous forms */
  6    75 
  6    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  6    77 
  6    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  6    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  6    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  6    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  6    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  6    83        2 output_device char (32),			/* name of minor device currently in use */
  6    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  6    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  6    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  6    87        2 segptr ptr,				/* ptr to current user segment being processed */
  6    88        2 flags,					/* control flags */
  6    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  6    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  6    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  6    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  6    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  6    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  6    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  6    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  6    97          3 step bit (1) unal,				/* run in step mode */
  6    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  6    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  6   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  6   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  6   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  6   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  6   104          3 pad bit (21) unal,				/* unused space */
  6   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  6   106          3 slave_input char (32),			/* slave input stream name */
  6   107          3 slave_output char (32),			/* slave output stream name */
  6   108          3 slave_pad fixed bin,			/* allocation breakage */
  6   109          3 slave_in ptr,				/* slave input iocbp */
  6   110          3 slave_out ptr,				/* slave output iocbp */
  6   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  6   112          3 active bit (1) unal,			/* on if there is a slave */
  6   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  6   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  6   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  6   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  6   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  6   118          3 priv2 bit (1) unal,
  6   119          3 priv3 bit (1) unal,
  6   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  6   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  6   122        2 ctl_term,					/* control terminal data */
  6   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  6   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  6   125          3 ctl_pad fixed bin,				/* allocation breakage */
  6   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  6   127          3 ctl_input char (32),			/* ctl input stream name */
  6   128          3 ctl_output char (32),			/* ctl output stream name */
  6   129          3 ctl_io char (32),				/* ctl i/o stream name */
  6   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  6   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  6   132          3 ctl_device char (32),			/* ctl terminal device name */
  6   133          3 form_type char (16),			/* format type if printing forms */
  6   134          3 attached bit (1) unal,			/* ctl term attached to process */
  6   135          3 forms bit (1) unal,			/* on if printing forms */
  6   136          3 pad bit (34) unal,
  6   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  6   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  6   139 
  6   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
      414 
      415 
  7     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  7     2 /* format: style3,idind30 */
  7     3 
  7     4 /* structure returned when message is read from a message segment */
  7     5 
  7     6 
  7     7 dcl	mseg_message_info_ptr	pointer;
  7     8 
  7     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  7    10 	  2 version		char (8) aligned,
  7    11 	  2 message_code		fixed bin,
  7    12 	  2 control_flags		unaligned,
  7    13 	    3 own			bit (1),
  7    14 	    3 delete		bit (1),
  7    15 	    3 pad			bit (34),
  7    16 	  2 ms_ptr		ptr,		/* pointer to message */
  7    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  7    18 	  2 ms_id			bit (72),		/* unique ID of message */
  7    19 						/* input in some cases */
  7    20 	  2 ms_access_class		bit (72),		/* message access class */
  7    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  7    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  7    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  7    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  7    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  7    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  7    27 
  7    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  7    29 
  7    30 declare	(
  7    31 	MSEG_READ_FIRST		init (1),
  7    32 	MSEG_READ_LAST		init (2),
  7    33 	MSEG_READ_SPECIFIED		init (3),
  7    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  7    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  7    36 	fixed bin int static options (constant);
  7    37 
  7    38 declare  (MSEG_READ_OWN		init ("1"b),
  7    39 	MSEG_READ_DELETE		init ("01"b)
  7    40 	)			bit (36) aligned internal static options (constant);
  7    41 
  7    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      416 
      417 
  8     1 /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
  8     2 
  8     3 /* Descriptor associated with an I/O daemon request */
  8     4 /* Coded August 1973 by Robert S. Coren */
  8     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
  8     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
  8     7 
  8     8 dcl  1 request_descriptor based aligned,
  8     9 	2 mseg_message_info_copy like mseg_message_info,
  8    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
  8    11 	2 q fixed bin,		/* priority queue in which request was submitted */
  8    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
  8    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
  8    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
  8    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
  8    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
  8    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
  8    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
  8    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
  8    20 	2 driver_data bit(252),	/* driver maintained data */
  8    21 	2 flags,
  8    22 	   (3 continued,		/* unfinished by one driver and given to another */
  8    23 	    3 finished,
  8    24 	    3 restarted,
  8    25 	    3 cancelled,
  8    26 	    3 dont_delete,
  8    27 	    3 saved,		/* not to be freed */
  8    28 	    3 keep_in_queue,	/* keep request in queue */
  8    29 	    3 series_restart,	/* this request is part of restarted series */
  8    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
  8    31 	    3 pad bit(27) unal,
  8    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
  8    33 
  8    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
      418 
      419 
      420      end reader_driver_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1234.0  reader_driver_.pl1                >special_ldd>install>MR12.2-1199>reader_driver_.pl1
404          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
406          2    09/09/75  1333.7  card_stream_info.incl.pl1         >ldd>include>card_stream_info.incl.pl1
408          3    10/28/88  1226.9  driver_status.incl.pl1            >special_ldd>install>MR12.2-1199>driver_status.incl.pl1
410          4    10/28/88  1227.9  iod_constants.incl.pl1            >special_ldd>install>MR12.2-1199>iod_constants.incl.pl1
412          5    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
414          6    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
416          7    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
418          8    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTACH_TYPE_IOM                        constant        fixed bin(17,0)          initial dcl 4-15 ref 135
DEFAULT_STATION                 000030 constant        char(6)                  initial packed unaligned dcl 96 ref 174
R_ACCESS                        000116 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 397*
add_char_offset_                000216 constant        entry                    external dcl 60 ref 152
addr                                                   builtin function         dcl 103 ref 152 152 193 195 202 237 239 241 249 251
                                                                                  259 323 323
age                             000100 automatic       fixed bin(17,0)          dcl 40 set ref 345* 345 346 351*
arg                      23            based           varying char(64)         array level 2 dcl 300 set ref 345 348*
arg_list                               based           structure                level 1 dcl 300
arg_list_p                             parameter       pointer                  dcl 297 ref 290 308 316 316 337 337 339 345 348
arg_p                                  parameter       pointer                  dcl 126 ref 123 128
args_bc                         000352 automatic       fixed bin(24,0)          dcl 392 set ref 397* 400
args_length                            parameter       fixed bin(17,0)          dcl 385 set ref 380 400*
args_ptr                               parameter       pointer                  dcl 384 set ref 380 397*
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 6-17 ref 143
attach_name             136            based           char(32)                 level 2 dcl 6-17 set ref 191* 202*
attach_type             146            based           fixed bin(17,0)          level 2 dcl 6-17 ref 135
attached                436            based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 257
both                            000107 constant        fixed bin(17,0)          initial dcl 89 set ref 267*
c_code                                 parameter       fixed bin(35,0)          dcl 298 set ref 290 314* 318* 327* 355* 361*
card_command_level              000240 stack reference condition                dcl 108 ref 321
card_dims                       000000 constant        char(32)                 initial array dcl 98 set ref 236* 251*
card_info                       000106 internal static structure                level 1 dcl 120 set ref 323 323
card_stream_info                       based           structure                level 1 dcl 2-8
chars                     1            based           char                     level 2 packed packed unaligned dcl 5-39 set ref 152
                                                                                  152
cleanup                         000232 stack reference condition                dcl 108 ref 231
clock                                                  builtin function         dcl 103 ref 265 265
code                                   based           fixed bin(35,0)          level 2 in structure "st" dcl 51 in procedure
                                                                                  "reader_driver_" set ref 193 195 202* 237 239 241*
                                                                                  249 251* 259*
code                                   parameter       fixed bin(35,0)          dcl 387 in procedure "initiate_the_file" set ref 380
                                                                                  394* 395 397* 398
code                            000107 automatic       fixed bin(35,0)          dcl 42 in procedure "reader_driver_" set ref 137*
                                                                                  138* 145* 146* 157* 158 176* 177 179* 182* 185
                                                                                  187* 225* 226 228* 323* 324 326* 327 351* 353 353*
                                                                                  355
command                   2            based           varying char(64)         level 2 dcl 300 ref 308 316 316 337 337
compname                        000342 automatic       char(32)                 packed unaligned dcl 391 set ref 394* 397*
control_stream                  000106 internal static char(32)                 level 2 dcl 120 set ref 208*
convert                                                builtin function         dcl 103 ref 345
ctl_term                344            based           structure                level 2 dcl 6-17
data_streams             11     000106 internal static structure                array level 2 dcl 120
date_string                     000101 automatic       char(24)                 packed unaligned dcl 41 set ref 265* 267*
date_time_                      000220 constant        entry                    external dcl 61 ref 265
dev_in_stream           106            based           char(32)                 level 2 dcl 6-17 set ref 169* 191* 206* 236* 241*
                                                                                  371*
dev_io_stream            76            based           char(32)                 level 2 dcl 6-17 set ref 167*
dev_name_label           10            based           char(32)                 level 2 dcl 3-25 set ref 267*
dev_out_stream          116            based           char(32)                 level 2 dcl 6-17 set ref 166* 167
device_dim              126            based           char(32)                 level 2 dcl 6-17 set ref 162* 164 164* 191*
dirname                         000260 automatic       char(168)                packed unaligned dcl 389 set ref 394* 397*
divide                                                 builtin function         dcl 103 ref 400
driver_ptr              304            based           pointer                  level 2 dcl 6-17 ref 130
driver_status                          based           structure                level 1 dcl 3-25
el_size                  24     000106 internal static fixed bin(17,0)          array level 3 dcl 120 set ref 248*
entname                         000332 automatic       char(32)                 packed unaligned dcl 390 set ref 394* 397*
error                           000120 constant        fixed bin(17,0)          initial dcl 93 set ref 138* 146* 179* 187*
error_table_$action_not_performed
                                000256 external static fixed bin(35,0)          dcl 114 ref 361
error_table_$fatal_error        000260 external static fixed bin(35,0)          dcl 116 ref 137 145
error_table_$ionmat             000262 external static fixed bin(35,0)          dcl 118 ref 195 239
expand_pathname_$component      000222 constant        entry                    external dcl 62 ref 394
first_char              164            based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 6-17
                                                                                  ref 152
flags                   310            based           structure                level 2 dcl 6-17
format                   11     000106 internal static char(12)                 array level 3 dcl 120 set ref 211* 213* 216* 219*
i                               000110 automatic       fixed bin(17,0)          dcl 43 set ref 235* 236 236 241* 247* 248 248 251*
                                                                                  372* 373*
initiate_file_$component        000224 constant        entry                    external dcl 64 ref 397
io_stat                         000112 automatic       bit(72)                  dcl 44 set ref 191* 193 195 202 206* 236* 237 239
                                                                                  241 248* 249 251 259 371* 373*
iodd_listen_                    000226 constant        entry                    external dcl 67 ref 270
iodd_msg_                       000230 constant        entry                    external dcl 68 ref 138 146 179 187 202 228 241 251
                                                                                  259 267 286 310 311 312 319 326 332 341 348 353
iodd_parse_$args                000232 constant        entry                    external dcl 69 ref 154 162 173
iodd_static                            based           structure                level 1 dcl 6-17
ios_$attach                     000236 constant        entry                    external dcl 71 ref 191 236
ios_$detach                     000240 constant        entry                    external dcl 73 ref 371 373
ios_$getsize                    000242 constant        entry                    external dcl 74 ref 248
ios_$setsize                    000234 constant        entry                    external dcl 70 ref 206
length                                 based           fixed bin(17,0)          level 2 dcl 5-39 ref 152 152
major_args              164            based           structure                level 2 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 6-17 in procedure "reader_driver_"
major_args                             based           char                     packed unaligned dcl 45 in procedure
                                                                                  "reader_driver_" set ref 154* 162* 173*
major_args_length               000116 automatic       fixed bin(17,0)          dcl 47 set ref 153* 154 154 157* 162 162 173 173
major_args_name                 000117 automatic       varying char(256)        dcl 48 set ref 154* 155 157*
major_args_ptr                  000114 automatic       pointer                  dcl 46 set ref 152* 154 157* 162 173
master                          000122 constant        fixed bin(17,0)          initial dcl 90 set ref 131 138* 146* 179* 187* 202*
                                                                                  228* 241* 251* 259* 286*
master_input             46            based           char(32)                 level 2 dcl 6-17 ref 131
message                                parameter       char                     packed unaligned dcl 386 ref 380
meter_sw                        000062 internal static bit(1)                   packed unaligned dcl 87 set ref 263*
mseg_message_info                      based           structure                level 1 dcl 7-9
n_streams                10     000106 internal static fixed bin(17,0)          level 2 dcl 120 set ref 209* 247 372
n_tokens                  1            based           fixed bin(17,0)          level 2 dcl 300 ref 339
name                     14     000106 internal static char(32)                 array level 3 dcl 120 set ref 212* 214* 217* 220*
                                                                                  236* 241* 248* 373*
normal                          000122 constant        fixed bin(17,0)          initial dcl 92 set ref 310* 311* 312* 319* 326* 332*
                                                                                  341* 348* 353*
p                               000064 internal static pointer                  dcl 88 set ref 130* 267
pathname_string                        parameter       varying char(256)        dcl 383 ref 380 394
pool_dir                        000010 internal static char(168)                packed unaligned dcl 86 set ref 222* 224* 225* 323*
                                                                                  351*
pool_manager_$clean_pool        000246 constant        entry                    external dcl 76 ref 351
pool_manager_$init              000244 constant        entry                    external dcl 75 ref 225
read_cards_                     000250 constant        entry                    external dcl 78 ref 323
read_cards_$set_rqt             000252 constant        entry                    external dcl 79 ref 182
read_cards_$set_station         000254 constant        entry                    external dcl 80 ref 176
request_descriptor                     based           structure                level 1 dcl 8-8
retry_sw                        000220 automatic       bit(1)                   packed unaligned dcl 49 set ref 133* 195 197* 239
rtrim                                                  builtin function         dcl 103 ref 222
slave                                  constant        fixed bin(17,0)          initial dcl 91 ref 132
source                                 parameter       fixed bin(17,0)          dcl 293 set ref 290 310* 311* 312* 319* 323 326*
                                                                                  332* 341* 348* 353*
st                                     based           structure                level 1 dcl 51
stat_p                          000214 internal static pointer                  dcl 6-15 set ref 128* 129 130 131 135 143 152 153
                                                                                  162 164 164 166 167 167 169 191 191 191 202 206
                                                                                  206 222 222 236 241 257 270* 323 371
state                                  parameter       fixed bin(17,0)          dcl 294 ref 290
station                         000221 automatic       char(32)                 packed unaligned dcl 56 set ref 173* 174 174* 176*
                                                                                  179* 267*
sys_dir                                based           char(168)                packed unaligned dcl 36 ref 222
sys_dir_ptr              22            based           pointer                  level 2 dcl 6-17 ref 222
terminals                       000066 internal static char(32)                 array packed unaligned dcl 95 set ref 131* 132* 323*
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 206 222
                                                                                  323
text_offset                            based           structure                level 1 packed packed unaligned dcl 5-45
text_strings                           based           structure                level 1 dcl 5-39
text_strings_ptr         14            based           pointer                  level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "reader_driver_" ref 129
text_strings_ptr                000246 automatic       pointer                  dcl 5-38 in procedure "reader_driver_" set ref 129*
                                                                                  152 152
total_chars             164(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 6-17
                                                                                  ref 153
whoami                          000032 constant        char(25)                 initial packed unaligned dcl 94 set ref 138* 146*
                                                                                  179* 187* 202* 228* 241* 251* 259* 326* 353*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATTACH_TYPE_DIAL                       internal static fixed bin(17,0)          initial dcl 4-15
ATTACH_TYPE_TTY                        internal static fixed bin(17,0)          initial dcl 4-15
ATTACH_TYPE_VARIABLE_LINE              internal static fixed bin(17,0)          initial dcl 4-15
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CTL_ATTACH_TYPE_DIAL                   internal static fixed bin(17,0)          initial dcl 4-21
CTL_ATTACH_TYPE_MC                     internal static fixed bin(17,0)          initial dcl 4-21
CTL_ATTACH_TYPE_TTY                    internal static fixed bin(17,0)          initial dcl 4-21
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 5-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 7-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 7-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 7-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 7-30
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PAPER_TYPE_CONTINUOUS                  internal static fixed bin(17,0)          initial dcl 4-26
PAPER_TYPE_DEFAULT                     internal static fixed bin(17,0)          initial dcl 4-26
PAPER_TYPE_SINGLE                      internal static fixed bin(17,0)          initial dcl 4-26
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
driver_status_ptr                      automatic       pointer                  dcl 3-24
iod_tables_hdr                         based           structure                level 1 dcl 5-23
ithp                                   automatic       pointer                  dcl 5-22
mseg_message_info_ptr                  automatic       pointer                  dcl 7-7
stream_info_ptr                        automatic       pointer                  dcl 2-6

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_read                      002657 constant        label                    dcl 332 ref 321
attach                          001255 constant        label                    dcl 191 ref 200
clean_out                       002227 constant        label                    dcl 272 ref 158 204 229 243 253 260
cmd_error                       003144 constant        label                    dcl 361 ref 334 343 349
command                         002306 constant        entry                    external dcl 290
detach_all                      003152 constant        entry                    internal dcl 366 ref 199 231 272
init                            000545 constant        entry                    external dcl 123
initiate_the_file               003247 constant        entry                    internal dcl 380 ref 157
reader_driver_                  000534 constant        entry                    external dcl 14
request                         002235 constant        entry                    external dcl 276
retry                           001316 constant        label                    dcl 197 ref 239

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3720        4204    3426        3730
Length      4656    3426       264         436     272         206

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
reader_driver_                      580 external procedure  is an external procedure.  
on unit on line 231                  64 on unit               
on unit on line 321                  64 on unit               
detach_all                           86 internal procedure  is called by several nonquick procedures.  
initiate_the_file                       internal procedure  shares stack frame of external procedure reader_driver_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 pool_dir                    reader_driver_
000062 meter_sw                    reader_driver_
000064 p                           reader_driver_
000066 terminals                   reader_driver_
000106 card_info                   reader_driver_
000214 stat_p                      reader_driver_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
reader_driver_           000100 age                         reader_driver_
                         000101 date_string                 reader_driver_
                         000107 code                        reader_driver_
                         000110 i                           reader_driver_
                         000112 io_stat                     reader_driver_
                         000114 major_args_ptr              reader_driver_
                         000116 major_args_length           reader_driver_
                         000117 major_args_name             reader_driver_
                         000220 retry_sw                    reader_driver_
                         000221 station                     reader_driver_
                         000246 text_strings_ptr            reader_driver_
                         000260 dirname                     initiate_the_file
                         000332 entname                     initiate_the_file
                         000342 compname                    initiate_the_file
                         000352 args_bc                     initiate_the_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry           any_to_any_truncate_
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              date_time_                    expand_pathname_$component    initiate_file_$component
iodd_listen_                  iodd_msg_                     iodd_parse_$args              ios_$attach
ios_$detach                   ios_$getsize                  ios_$setsize                  pool_manager_$clean_pool
pool_manager_$init            read_cards_                   read_cards_$set_rqt           read_cards_$set_station

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$fatal_error      error_table_$ionmat




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000533        17 000541       123 000542       128 000552       129 000557       130 000561       131 000563
    132 000570       133 000575       135 000577       137 000602       138 000604       140 000636       143 000637
    145 000642       146 000644       148 000676       152 000677       153 000717       154 000724       155 000753
    157 000760       158 000770       162 000772       164 001030       166 001037       167 001042       169 001045
    173 001050       174 001104       176 001113       177 001130       179 001132       180 001171       182 001172
    185 001217       187 001221       188 001254       191 001255       193 001305       195 001311       197 001316
    199 001317       200 001323       202 001324       204 001366       206 001367       208 001416       209 001422
    211 001424       212 001427       213 001432       214 001435       216 001440       217 001443       219 001446
    220 001451       222 001454       224 001510       225 001514       226 001544       228 001546       229 001604
    231 001605       235 001627       236 001635       237 001671       239 001675       241 001702       243 001752
    245 001753       247 001755       248 001765       249 002007       251 002013       253 002057       255 002060
    257 002062       259 002067       260 002124       263 002125       265 002126       267 002145       270 002220
    272 002227       274 002233       276 002234       286 002242       288 002300       290 002301       308 002313
    310 002323       311 002357       312 002414       314 002453       316 002455       318 002471       319 002472
    321 002526       323 002545       324 002611       326 002613       327 002652       328 002655       330 002656
    332 002657       334 002714       337 002715       339 002727       341 002732       343 002766       345 002767
    346 002777       348 003002       349 003052       351 003053       353 003101       355 003137       356 003142
    359 003143       361 003144       363 003150       366 003151       371 003157       372 003204       373 003216
    374 003243       375 003246       380 003247       394 003260       395 003322       397 003327       398 003367
    400 003373       402 003377


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
