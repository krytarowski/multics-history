	COMPILATION LISTING OF SEGMENT prtdim_write
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 02/02/88  1646.2 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 
       12 /* Printer DIM write module: responsible for actually sending print lines to the line printer and handling statuses
       13*   returned from the printer by IOI */
       14 
       15 /* Created:  31 October 1974 by Noel I. Morris */
       16 /* Modified: 16 March 1977 by Noel I. Morris */
       17 /* Modified: June 1978 by J. C. Whitmore to suppress multiple error messages */
       18 /* Modified: 7 August 1980 by Art Beattie to send error messages every N times and wait */
       19 /* Modified: 27 November 1981 by G. Palter to fix entry number 0028 (phx04610) on the io_daemon error list:
       20*      A power fault on a local printer will reset the VFC to the default state (6 lines/inch).  The entry in
       21*      prt_status_table_ for "power fault" does not indicate that the VFC and train image are lost -- the fix for this bug
       22*      is to add a new flag which is used by the printer DIM to indicate a VFC and image reload should be done after the
       23*      operator readies the printer (the next special interrupt) */
       24 /* Modified 83-10-10 for urmpc/eurc partitioning, E. N. Kittlitz */
       25 
       26 
       27 prtdim_write:
       28      procedure (arg_sdb_ptr, wkspptr, offset, nelem, nelemt, iostatus);
       29 
       30 dcl  arg_sdb_ptr ptr,				/* pointer to stream data block */
       31      wkspptr ptr,					/* pointer to caller's data */
       32      offset fixed bin (24),				/* offset into caller data */
       33      nelem fixed bin (24),				/* number of elements to transmit */
       34      nelemt fixed bin (24),				/* number of elements actually transmitted */
       35      iostatus bit (72) aligned;			/* IOS status */
       36 
       37 dcl  rcode fixed bin (35),				/* error code */
       38      cur_page fixed bin,				/* current page number */
       39      lp ptr,					/* pointer to next DCW block */
       40      prev_lp ptr,					/* pointer to last DCW block */
       41      dp ptr,					/* pointer to place for data */
       42      lth fixed bin (18),				/* remaining length of input */
       43      inptr ptr,					/* pointer to rest of input */
       44      char_cnt fixed bin (18),				/* count of characters in output */
       45      word_cnt fixed bin (18),				/* count of words in output */
       46      temp_iom_stat bit (72) aligned,			/* temp area for iom status */
       47      errmess char (256) var,				/* error message on bad status */
       48      tra bit (36) aligned;				/* prototype TDCW */
       49 
       50 dcl  last_iom_stat bit (72) aligned;			/* last status an error msg was printed for */
       51 dcl  max_err_stat_count fixed bin init (10) int static options (constant); /* max no. of errors between reporting */
       52 dcl  same_err_stat_count fixed bin;			/* counter for the same error status from printer */
       53 
       54 dcl (paper_low_flag init ("000000000000000001"b),		/* status flag for paper low */
       55      image_flag init ("000000000000000010"b),		/* status flag for destroyed train image */
       56      vfc_flag init ("000000000000000100"b),		/* status flag for destroyed VFC image */
       57      slew_error init ("000000000000001000"b),		/* status flag for slew error on prev slew */
       58      power_fault_flag init ("000000000000010000"b))	/* status flag for power fault */
       59      bit (18) aligned static options (constant);
       60 
       61 dcl  dev_stat_bits bit (72) aligned int static options (constant) /* bits used by analyze_device_stat_ */
       62      init ("377700770000"b3 || (12) "0"b3);		/* bit string in octal to mask all but */
       63 						/* power, maj, sub, channel and central status bits */
       64 
       65 dcl  prt_conv_ entry (ptr, fixed bin (18), ptr, fixed bin (18), ptr),
       66      ioi_$connect entry (fixed bin, fixed bin (18), fixed bin (35)),
       67      ipc_$block entry (ptr, ptr, fixed bin (35)),
       68      convert_ipc_code_ entry (fixed bin (35)),
       69      analyze_device_stat_$rs entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned),
       70      analyze_system_fault_ entry (char (*) aligned, bit (72) aligned),
       71      prtdim_util$load_image entry (ptr, fixed bin (35)),
       72      prtdim_util$load_vfc entry (ptr, fixed bin (35)),
       73      com_err_ entry options (variable);
       74 
       75 dcl  prt_status_table_$prt_status_table_ ext;
       76 
       77 
       78 dcl  wksp char (1) based unal;			/* used for getting pointer to input string */
       79 
       80 dcl  error_table_$net_timeout ext fixed bin (35);
       81 dcl  error_table_$request_pending fixed bin (35) ext static;
       82 
       83 dcl 1 dcws aligned based (lp),			/* DCW/data block */
       84     2 idcw bit (36),				/* instruction DCW */
       85     2 ddcw bit (36),				/* data xfer DCW */
       86     2 tdcw bit (36),				/* Transfer DCW or terminate DCW */
       87     2 data;					/* data follows the DCW's */
       88 
       89 dcl 1 ipc_message aligned,
       90     2 chname fixed bin (71),				/* Chan over which message arrived */
       91     2 message fixed bin (71),				/* 2-word event message */
       92     2 sender bit (36),				/* Sending process */
       93     2 origin,					/* Origin of event message */
       94       3 devsignal bit (18),				/* 1 = device signal */
       95       3 ring bit (18),				/* Senders ring number */
       96     2 channel_index fixed bin;
       97 
       98 dcl (addr, addrel, bin, bit, divide, rel, string, substr, unspec) builtin;
       99 
  1     1 /* BEGIN INCLUDE FILE ... prt_sdb.incl.pl1 */
  1     2 /* Note: there is a corresponding prt_sdb.incl.alm */
  1     3 
  1     4 /* Created 10/28/74 by Noel I. Morris	*/
  1     5 /* Modified 3/15/77 by Noel I. Morris	*/
  1     6 /* Modified 1/25/78 by J. C. Whitmore to merge prtdim and spooling_dim versions */
  1     7 /* Modified: 27 November 1981 by G. Palter to add reload_vfc_train_after_special flag */
  1     8 /* Modified: 16 August 1983 by E. N. Kittlitz for new printer dim */
  1     9 
  1    10 dcl  sdb_ptr ptr;					/* pointer to stream data block */
  1    11 
  1    12 dcl 1 sdb aligned based (sdb_ptr),			/* printer stream data block */
  1    13     2 outer_module_name char (32) aligned,
  1    14     2 device_name_list_ptr pointer,
  1    15     2 device_name,
  1    16       3 next_device_ptr pointer,
  1    17       3 name_size fixed bin (17),
  1    18       3 name char (32) aligned,
  1    19     2 ev_list aligned,				/* Event list for ipc_ */
  1    20       3 count fixed bin (17),				/* Event count = Always one */
  1    21       3 evchan fixed bin (71),			/* Event channel name */
  1    22     2 stream_name char (32),				/* stream name of this attachment */
  1    23     2 areap ptr,					/* pointer to system free area */
  1    24     2 info like prt_info aligned,			/* printer info */
  1    25     2 conv_info like pci aligned,			/* conversion info */
  1    26     2 chars_printed fixed bin (35),			/* input chars processed since "reset" */
  1    27     2 stop_every fixed bin,				/* non-zero to stop after number of pages */
  1    28     2 stop_counter fixed bin,				/* page stop counter */
  1    29     2 mode,					/* additional modes */
  1    30      (3 single_page bit (1),				/* "1"b to stop after each page */
  1    31       3 noprint bit (1),				/* "1"b to suppress printing */
  1    32       3 pad bit (34)) unal,
  1    33     2 rcp_id bit (36),				/* RCP attachment ID */
  1    34     2 wsegp ptr,					/* pointer to IOI working segment */
  1    35     2 running bit (1),				/* "1"b if channel running */
  1    36     2 bgin fixed bin (18),				/* index to oldest print line */
  1    37     2 stop fixed bin (18),				/* index to next print line */
  1    38     2 prev fixed bin (18),				/* index to previous print line */
  1    39     2 wait_flag bit (1) aligned,			/* non-zero if waiting for special */
  1    40     2 marker_count fixed bin,				/* counter for marker status insertion */
  1    41     2 paper_low bit (1) aligned,			/* "1"b if paper low */
  1    42     2 error_count fixed bin,				/* error counter */
  1    43     2 buffer_ptr ptr,				/* pointer to output buffer (spooler) */
  1    44     2 spool_info (56) fixed bin,			/* place to store spooling_info */
  1    45     2 reload_vfc_train_after_special bit (1) aligned,	/* "1"b if VFC/train images should be reloaded after next
  1    46*						   special interrupt */
  1    47     2 max_dcw_size fixed bin (12) uns unal,		/* max wordcount of dcw */
  1    48     2 max_dcws fixed bin (6) uns unal,			/* max dcws per idcw/buffer */
  1    49     2 n_dcws fixed bin (6) uns unal,			/* current limit of dcws/buffer */
  1    50     2 b_begin fixed bin (3) uns unal,			/* buffer index */
  1    51     2 b_stop fixed bin (3) uns unal,			/* likewise */
  1    52     2 max_buffers fixed bin (3) uns unal,		/* number of buffers allocated */
  1    53     2 n_buffers fixed bin (3) uns unal,			/* number of buffers in use now */
  1    54     2 data_begin fixed bin (18) uns unal,		/* first data word */
  1    55     2 data_end fixed bin (18) uns unal,			/* size of working space in words */
  1    56     2 status_ptr ptr unal,				/* ioi status area */
  1    57     2 flags aligned,
  1    58       3 aborting bit (1) unal,			/* next attempt to do i/o gets error and resets */
  1    59       3 eurc bit (1) unal,				/* true if we know we are using EURC */
  1    60       3 flags_pad bit (16) unal,
  1    61     2 version fixed bin unal,      
  1    62     2 status_table ptr unal,				/* for analyze_device_stat_ */
  1    63     2 null_line_data bit (36) aligned,
  1    64     2 null_line_dcw bit (36) aligned,
  1    65     2 alarm_time fixed bin (71) unaligned;		/* current timer_manager_ limit */
  1    66 dcl  prt_bufferp ptr;
  1    67 
  1    68 dcl 1 prt_buffer aligned based (prt_bufferp),
  1    69     2 header,
  1    70       3 number fixed bin (6) uns unal,
  1    71       3 busy bit (1) unal,
  1    72       3 pad bit (4) unal,
  1    73       3 dcw_count fixed bin (7) uns unal,
  1    74       3 data_ends fixed bin (18) uns unal,
  1    75     2 idcw bit (36),
  1    76     2 ddcw (sdb.max_dcws + 1) bit (36) aligned;
  1    77 
  1    78 dcl  wseg (0:sdb.data_end - 1) bit (36) aligned based (sdb.wsegp);	/* the IOI buffer segment */
  1    79 dcl 1 prt_buffers (0:sdb.max_buffers - 1) aligned like prt_buffer based (sdb.wsegp);
  1    80 
  1    81 /* NOTE:	The Spooling_dim IO Module also uses this include file,
  1    82*	as it uses the printer stream also. If changes are made to this include file,
  1    83*	see to it that the changes are also reflected in the Spooling_dim procedures.
  1    84*	The spooling_dim uses the standard printer_dim order and changemode procedures.
  1    85*	JCW 1/25/78  */
  1    86 
  1    87 /* END INCLUDE FILE ... prt_sdb.incl.pl1 */
      100 
      101 
  2     1 
  2     2 /* Begin include file ...... prt_info.incl.pl1 */
  2     3 /* last modified 6/12/75 by Noel I. Morris	*/
  2     4 
  2     5 dcl  pip ptr;					/* pointer to printer info structure */
  2     6 
  2     7 dcl 1 prt_info based (pip) aligned,			/* printer info structure */
  2     8     2 devname char (4),				/* name of device */
  2     9     2 devx fixed bin,				/* device index */
  2    10     2 model fixed bin,				/* printer model number */
  2    11     2 type fixed bin,				/* printer type number */
  2    12     2 train fixed bin,				/* print train ID */
  2    13     2 line_length fixed bin,				/* max length of printed line */
  2    14     2 print_idcw bit (36),				/* IDCW to print 1 line */
  2    15     2 term_idcw bit (36);				/* IDCW to stop printer channel */
  2    16 
  2    17 /* End of include file ...... prt_info.incl.pl1 */
  2    18 
      102 
      103 
  3     1 
  3     2 /* BEGIN INCLUDE FILE ... prt_conv_info.incl.pl1 */
  3     3 /* Modified: 12 September 1980 by G. Palter */
  3     4 
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
  3     8*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  3     9*     Add modes.line_nbrs, flags.(eol eof)  bits for eor -nb.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 dcl  pcip ptr;					/* pointer to conversion info structure */
  3    14 
  3    15 dcl 1 pci based (pcip) aligned,			/* printer conversion info structure */
  3    16     2 cv_proc ptr,					/* pointer to character conversion procedure */
  3    17     2 lmarg fixed bin,				/* left margin indentation */
  3    18     2 rmarg fixed bin,				/* right margin limit */
  3    19     2 page_length fixed bin,				/* number of lines on page */
  3    20     2 phys_line_length fixed bin,			/* physical width of paper */
  3    21     2 phys_page_length fixed bin,			/* physical length of paper */
  3    22     2 lpi fixed bin,				/* lines per inch */
  3    23     2 sheets_per_page fixed bin,			/* sheets of paper per logical page */
  3    24     2 line_count fixed bin,				/* count of converted lines */
  3    25     2 page_count fixed bin,				/* count of converted pages */
  3    26     2 func fixed bin,				/* special conversion function */
  3    27 						/* 0 => normal conversion */
  3    28 						/* 1 => change NL to FF */
  3    29 						/* 2 => change NL to top inside page */
  3    30 						/* 3 => change NL to end of page */
  3    31                                                             /* 4 => change NL to top of outside page */
  3    32     (2 modes,					/* conversion modes */
  3    33      3 overflow_off bit (1),				/* "1"b to suppress end of page overflow */
  3    34       3 single_space bit (1),				/* "1"b to change all forms advance chars to NL */
  3    35       3 non_edited bit (1),				/* "1"b to print ASCII control chars */
  3    36       3 truncate bit (1),				/* "1"b to truncate lines that are too long */
  3    37       3 esc bit (1),				/* "1"b to process ESC character */
  3    38       3 ctl_char bit (1),				/* "1"b to output control characters */
  3    39       3 line_nbrs bit (1),				/* "1"b to output line numbers */
  3    40       3 pci_pad bit (5),
  3    41     2 flags,					/* flags internal to prt_conv_ */
  3    42       3 ignore_next_ff bit (1),			/* ON => prt_conv_ just output a FF; ignore next character if
  3    43*						   it's a FF */
  3    44       3 eol bit (1),				/* "1"b = end-of-line encountered */
  3    45       3 eof bit (1),				/* "1"b = end-of-segment encountered */
  3    46       3 flags_pad bit (3),
  3    47     2 coroutine_modes,
  3    48       3 upper_case bit(1),				/* "1"b to convert to upper case */
  3    49       3 ht bit(1),					/* "1"b to skip tab conversion */
  3    50       3 coroutine_pad bit(13),
  3    51       3 slew_table_idx bit(3) ) unal,			/* slew table index */
  3    52     2 top_label_line char (136),			/* contains an optional top of page label */
  3    53     2 bot_label_line char (136),			/* contains an optional bottom of page label */
  3    54     2 top_label_length fixed bin,			/* length of top label line */
  3    55     2 bot_label_length fixed bin,			/* length of bottom label line */
  3    56     2 form_stops (256) unal,				/* logical form stops */
  3    57       3 lbits bit (9),				/* leftmost bits */
  3    58       3 rbits bit (9),				/* rightmost bits */
  3    59 
  3    60 /* The following items are for internal use by the print conversion procedure.
  3    61*   They should be zeroed once and then never referenced again.		*/
  3    62 
  3    63     2 level fixed bin,				/* overstrike level */
  3    64     2 pos fixed bin,				/* print position at end of incomplete line */
  3    65     2 line fixed bin,				/* current line number */
  3    66     2 slew_residue fixed bin,				/* number of lines remaining to be slewed */
  3    67     2 label_nelem fixed bin,				/* characters remaining in label */
  3    68     2 label_wksp ptr,				/* pointer to label being processed */
  3    69     2 sav_pos fixed bin,				/* position saved during label processing */
  3    70     2 esc_state fixed bin,				/* state of ESC processing */
  3    71     2 esc_num fixed bin,				/* number following ESC sequence */
  3    72     2 temp bit (36);				/* conversion proc temporary */
  3    73 
  3    74 /* End of include file ...... prt_conv_info.incl.pl1 */
  3    75 
      104 
      105 
      106 
  4     1 
  4     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  4     3 /* Last modified 3/24/75 by Noel I. Morris */
  4     4 
  4     5 dcl  isp ptr;					/* pointer to status structure */
  4     6 
  4     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  4     8     2 completion,					/* completion flags */
  4     9      (3 st bit (1),					/* "1"b if status returned */
  4    10       3 er bit (1),					/* "1"b if status indicates error condition */
  4    11       3 run bit (1),				/* "1"b if channel still running */
  4    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  4    13     2 level fixed bin (3),				/* IOM interrupt level */
  4    14     2 offset fixed bin (18),				/* DCW list offset */
  4    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  4    16     2 iom_stat bit (72),				/* IOM status */
  4    17     2 lpw bit (72);					/* LPW residue */
  4    18 
  4    19 dcl  imp ptr;					/* pointer to message structure */
  4    20 
  4    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  4    22    (2 completion like istat.completion,			/* completion flags */
  4    23     2 pad bit (11),
  4    24     2 level bit (3),				/* interrupt level */
  4    25     2 offset bit (18),				/* DCW list offset */
  4    26     2 status bit (36)) unal;				/* first 36 bits of status */
  4    27 
  4    28 /* End of include file ...... ioi_stat.incl.pl1 */
  4    29 
      107 
  5     1 
  5     2 /* Begin include file ...... status_flags.incl.pl1 */
  5     3 /* created 6/11/75 by Noel I. Morris	*/
  5     4 
  5     5 dcl (backup_flag init ("100000000000000000"b),		/* indicates retry of previous operation */
  5     6      init_flag init ("010000000000000000"b),		/* indicates backup if failure during initiation */
  5     7      report_flag init ("001000000000000000"b),		/* indicates error should be reported */
  5     8      halt_flag init ("000100000000000000"b),		/* indicates error caused device to halt */
  5     9      eurc_no_backup_flag init ("000010000000000000"b))	/* indicates eurc device should ignore backup_flag */
  5    10 	bit (18) aligned static;
  5    11 
  5    12 /* End of include file ...... status_flags.incl.pl1 */
  5    13 
      108 
      109 
  6     1 
  6     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  6     3 
  6     4 dcl  pcwp ptr;					/* pointer to PCW */
  6     5 
  6     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  6     7      (2 command bit (6),				/* device command */
  6     8       2 device bit (6),				/* device code */
  6     9       2 ext bit (6),				/* address extension */
  6    10       2 code bit (3),				/* should be "111"b for PCW */
  6    11       2 mask bit (1),				/* channel mask bit */
  6    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  6    13       2 chan_cmd bit (6),				/* type of I/O operation */
  6    14       2 count bit (6),				/* record count or control character */
  6    15       2 mbz1 bit (3),
  6    16       2 channel bit (6),				/* channel number */
  6    17       2 mbz2 bit (27)) unal;
  6    18 
  6    19 dcl  idcwp ptr;					/* pointer to IDCW */
  6    20 
  6    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  6    22      (2 command bit (6),				/* device command */
  6    23       2 device bit (6),				/* device code */
  6    24       2 ext bit (6),				/* address extension */
  6    25       2 code bit (3),				/* should be "111"b for PCW */
  6    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  6    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  6    28       2 chan_cmd bit (6),				/* type of I/O operation */
  6    29       2 count bit (6)) unal;				/* record count or control character */
  6    30 
  6    31 /* End include file ...... iom_pcw.incl.pl1 */
  6    32 
      110 
  7     1 
  7     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  7     3 
  7     4 dcl  dcwp ptr,					/* pointer to DCW */
  7     5      tdcwp ptr;					/* pointer to TDCW */
  7     6 
  7     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  7     8      (2 address bit (18),				/* address for data transfer */
  7     9       2 char_pos bit (3),				/* character position */
  7    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  7    11       2 type bit (2),				/* DCW type */
  7    12       2 tally bit (12)) unal;				/* tally for data transfer */
  7    13 
  7    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  7    15      (2 address bit (18),				/* address to transfer to */
  7    16       2 mbz1 bit (4),
  7    17       2 type bit (2),				/* should be "10"b for TDCW */
  7    18       2 mbz2 bit (9),
  7    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  7    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  7    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  7    22 
  7    23 /* End of include file ...... iom_dcw.incl.pl1 */
  7    24 
      111 
      112 
      113 	iostatus = "0"b;				/* Clear IOS status. */
      114 
      115 	sdb_ptr = arg_sdb_ptr;			/* Copy pointer to stream data block. */
      116 	pip = addr (sdb.info);			/* Get pointer to printer info structure. */
      117 	pcip = addr (sdb.conv_info);			/* Get pointer to conversion info structure. */
      118 	last_iom_stat = ""b;			/* start clean on each write */
      119 	same_err_stat_count = 0;
      120 
      121 	rcode = 0;				/* Clear the error code. */
      122 	nelemt = 0;				/* Zero elements transmitted. */
      123 	lth = nelem;				/* Get initial length of input string. */
      124 	inptr = addr (substr (wkspptr -> wksp, offset+1, 1)); /* Get pointer to input string. */
      125 
      126 	do while (lth > 0);				/* Loop until all elements transmitted. */
      127 	     cur_page = pci.page_count;		/* Remember current page count. */
      128 
      129 	     if sdb.stop > sdb.bgin then		/* If adding to end of workspace segment ... */
      130 		call set_io;			/* Add some more. */
      131 	     else if sdb.stop + 68 < sdb.bgin then	/* If adding to beginning of workspace segment ... */
      132 		call set_io;
      133 	     else if sdb.prev = sdb.bgin then		/* If cold starting ... */
      134 		call set_io;
      135 
      136 	     else					/* Cannot add more lines.  Wait for I/O completion. */
      137 	     call wait_io;
      138 
      139 	     if rcode ^= 0 then do;
      140 		substr (iostatus, 1, 36) = unspec (rcode);
      141 		substr (iostatus, 41, 1) = "1"b;
      142 		sdb.chars_printed = sdb.chars_printed + nelem - lth; /* boost the number done */
      143 		return;
      144 	     end;
      145 
      146 	     if cur_page ^= pci.page_count then do;	/* If going to a new page ... */
      147 		sdb.stop_counter = sdb.stop_counter + 1; /* Bump the page stop counter. */
      148 
      149 		if sdb.single_page | (sdb.stop_every ^= 0 & sdb.stop_counter >= sdb.stop_every) then do;
      150 		     sdb.stop_counter = 0;		/* If time to stop ... */
      151 		     sdb.chars_printed = sdb.chars_printed + nelem - lth; /* boost the number done */
      152 		     substr (iostatus, 1, 36) = unspec (error_table_$request_pending);
      153 		     return;
      154 		end;
      155 	     end;
      156 	end;
      157 
      158 	sdb.chars_printed = sdb.chars_printed + nelem - lth; /* boost the number done */
      159 	return;
      160 
      161 set_io:	proc;					/* procedure to set new DCW and data block */
      162 
      163 
      164 	     lp = addr (wseg (sdb.stop));		/* Get ptr to place for next DCW block. */
      165 	     dp = addr (lp -> dcws.data);		/* Get pointer to place for data. */
      166 
      167 	     call prt_conv_ (inptr, lth, dp, char_cnt, pcip); /* Perform code conversion. */
      168 	     word_cnt = divide (char_cnt + 3, 4, 18, 0);	/* Compute number of words to write. */
      169 	     nelemt = nelem - lth;			/* Update the number of elements xmitted. */
      170 
      171 	     if sdb.noprint then return;		/* Just return if print suppressed. */
      172 
      173 	     dcws.tdcw = prt_info.term_idcw;		/* Set terminator at end of block. */
      174 
      175 	     dcwp = addr (dcws.ddcw);			/* Get pointer to data transfer DCW. */
      176 	     string (dcw) = "0"b;			/* Clear the DCW. */
      177 	     dcw.address = rel (dp);			/* Set address to point to data. */
      178 	     dcw.tally = bit (bin (word_cnt, 12));	/* Set tally of DCW. */
      179 
      180 	     dcws.idcw = prt_info.print_idcw;		/* Set the IDCW to print line. */
      181 
      182 	     if sdb.running then do;			/* If channel is running ... */
      183 		sdb.marker_count = sdb.marker_count + word_cnt; /* Bump the marker count. */
      184 		if sdb.marker_count > 512 then do;	/* If workspace segment more than half filled ... */
      185 		     idcwp = addr (dcws.idcw);	/* Get pointer to IDCW for printing line. */
      186 		     idcw.control = "11"b;		/* Set marker bits in IDCW. */
      187 		     sdb.marker_count = 0;		/* Reset the count. */
      188 		end;
      189 	     end;
      190 
      191 	     if sdb.prev ^= sdb.stop then do;		/* If previous line queued ... */
      192 		tdcwp = addr (tra);			/* Get pointer to prototype TDCW. */
      193 		tra = "0"b;			/* Clear it. */
      194 		tdcw.address = bit (bin (sdb.stop, 18)); /* Set target of transfer. */
      195 		tdcw.type = "10"b;			/* Identify as TDCW. */
      196 
      197 		prev_lp = addr (wseg (sdb.prev));	/* Get pointer to previous line. */
      198 		prev_lp -> dcws.tdcw = tra;		/* Copy into list. */
      199 	     end;
      200 
      201 	     sdb.prev = sdb.stop;			/* Save index to this line. */
      202 	     sdb.stop = sdb.stop + word_cnt + 3;	/* Get offset of first word past current block. */
      203 	     if sdb.stop + 68 >= 1024 then sdb.stop = 0;	/* Lap if buffer size exceeded. */
      204 
      205 	     if ^sdb.running then call start_io;	/* If channel stopped, start it up again. */
      206 
      207 	     return;
      208 
      209 
      210 	end set_io;
      211 
      212 start_io:	proc;					/* procedure to start up printer */
      213 
      214 	     if ^sdb.wait_flag then if sdb.prev ^= sdb.stop then do; /* If not waiting for special and something to do ... */
      215 		     sdb.marker_count = 0;		/*  Reset marker count. */
      216 		     sdb.running = "1"b;		/* Indicate device now running. */
      217 
      218 		     call ioi_$connect (prt_info.devx, sdb.bgin, rcode); /* Fire up the device. */
      219 
      220 		end;
      221 
      222 	     return;
      223 
      224 
      225 	end start_io;
      226 
      227 
      228 
      229 wait_io:	proc;					/* procedure to wait for I/O completion */
      230 
      231 
      232 	     if ^sdb.running then			/* If printer not running ... */
      233 		call start_io;			/* Get it in motion. */
      234 
      235 	     call ipc_$block (addr (sdb.ev_list), addr (ipc_message), rcode);
      236 	     if rcode ^= 0 then do;			/* Wait for I/O completion. */
      237 		call convert_ipc_code_ (rcode);
      238 		return;
      239 	     end;
      240 
      241 	     call stat_check;			/* Examine status and set flags. */
      242 
      243 	     return;
      244 
      245 
      246 	end wait_io;
      247 
      248 stat_check: proc;					/* Printer status check entry  -  a la Dijkstra */
      249 
      250 dcl  flags bit (18) aligned,
      251      found_dcw bit (1) aligned,
      252      lx fixed bin (18);
      253 
      254 	     flags = "0"b;				/* Clear flags. */
      255 
      256 	     imp = addr (ipc_message.message);		/* get pointer to ioi message */
      257 	     if imess.level = "111"b then do;		/* if a special interupt... */
      258 		sdb.wait_flag = "0"b;		/* not waiting any more */
      259 		if sdb.reload_vfc_train_after_special then do;	/* whatever required operator intervention ... */
      260 		     call prtdim_util$load_image (sdb_ptr, (0));	/* ... also destroyed the train and VFC images */
      261 		     call prtdim_util$load_vfc (sdb_ptr, (0));
      262 		     sdb.reload_vfc_train_after_special = "0"b;
      263 		end;
      264 		return;
      265 	     end;
      266 
      267 	     if imess.st then do;			/* if status present */
      268 		if imess.time_out then do;		/* if caused by time out */
      269 		     rcode = error_table_$net_timeout;	/* indicate error */
      270 		     sdb.running = "0"b;		/* not running any more */
      271 		     return;
      272 		end;
      273 
      274 		if bin (imess.level) <= 5 then do;	/* If terminate, marker, or system fault ... */
      275 		     temp_iom_stat = imess.status;	/* copy status to double word */
      276 		     lx = bin (imess.offset);		/* Copy list index for this status */
      277 
      278 		     if imess.er then do;		/* If error occurred ... */
      279 			if imess.level = "001"b then do; /* If system fault ... */
      280 			     call analyze_system_fault_ (prt_info.devname, temp_iom_stat);
      281 			     sdb.wait_flag = "1"b;	/* Wait for operator intervention. */
      282 			     sdb.error_count = sdb.error_count + 1;
      283 			end;
      284 			else do;			/* If terminate ... */
      285 			     call analyze_device_stat_$rs (errmess, addr (prt_status_table_$prt_status_table_),
      286 				temp_iom_stat, flags);
      287 
      288 			     if flags & paper_low_flag then
      289 				if pci.overflow_off then /* If in overflow_off mode ... */
      290 				     flags = flags | report_flag | halt_flag;
      291 						/* Stop now to avoid printing on perf. */
      292 				else if ^sdb.paper_low then do; /* Report paper low only once. */
      293 				     sdb.paper_low = "1"b;
      294 				     flags = flags | report_flag;
      295 				end;
      296 
      297 			     if flags & power_fault_flag then	/* power fault: VFC/train images no longer valid */
      298 				sdb.reload_vfc_train_after_special = "1"b;
      299 
      300 			     if flags & report_flag then do; /* If error should be reported ... */
      301 				sdb.error_count = sdb.error_count + 1;
      302 
      303 				if (temp_iom_stat & dev_stat_bits) ^= last_iom_stat then do; /* if not reported */
      304 				     last_iom_stat = (temp_iom_stat & dev_stat_bits); /* save for next error */
      305 				     same_err_stat_count = 1;
      306 				     call com_err_ (0, prt_info.devname, errmess);
      307 				end;
      308 				else do;
      309 				     same_err_stat_count = same_err_stat_count + 1;
      310 						/* Allow only a resonable amount of unreported */
      311 						/* errors to occur.  Then report again. */
      312 						/* Also want to report again if need to wait. */
      313 				     if same_err_stat_count >= max_err_stat_count | (flags&halt_flag) ^= "0"b
      314 				     then do;
      315 					sdb.wait_flag = "1"b;
      316 					call com_err_ (0, prt_info.devname, errmess);
      317 				     end;
      318 				end;
      319 			     end;
      320 			     sdb.wait_flag = ((flags & halt_flag) ^= "0"b) | sdb.wait_flag;
      321 						/* Decide if operator intervention required. */
      322 
      323 			     if flags & image_flag then do; /* If train image destroyed ... */
      324 				call prtdim_util$load_image (sdb_ptr, rcode);
      325 				if rcode ^= 0 then return;
      326 			     end;
      327 
      328 			     if flags & vfc_flag then do; /* If VFC image destroyed ... */
      329 				call prtdim_util$load_vfc (sdb_ptr, rcode);
      330 				if rcode ^= 0 then return;
      331 			     end;
      332 			end;
      333 
      334 			if sdb.wait_flag then do;
      335 			     same_err_stat_count = 0;
      336 			     call com_err_ (0, prt_info.devname, "***** OPERATOR INTERVENTION REQUIRED^/");
      337 			end;
      338 
      339 		     end;
      340 
      341 		     else				/* If no error ... */
      342 		     sdb.paper_low = "0"b;		/* Reset paper low flag. */
      343 
      344 		     idcwp = addr (wseg (lx));	/* Get pointer to last DCW processed. */
      345 		     found_dcw = "0"b;		/* Clear flag. */
      346 
      347 		     if flags & backup_flag then do while (idcw.code ^= "111"b);
      348 			lx = lx - 1;		/* Back up to last print IDCW. */
      349 			idcwp = addrel (idcwp, -1);
      350 		     end;
      351 
      352 		     else if bin (imess.level) <= 3 then /* If termination status ... */
      353 			do while (^found_dcw);	/* Search for terminate IDCW or TDCW. */
      354 			if string (idcw) = prt_info.term_idcw then do;
      355 			     lx, sdb.prev = sdb.stop; /* If end of list, reset. */
      356 			     found_dcw = "1"b;
      357 			end;
      358 			else if idcw.code = "111"b then do; /* If at print IDCW ... */
      359 			     found_dcw = "1"b;	/* Stay at this point. */
      360 			end;
      361 			else if idcwp -> tdcw.type = "10"b then do;
      362 			     lx = bin (idcwp -> tdcw.address, 18);
      363 			     found_dcw = "1"b;	/* If TDCW, follow the thread. */
      364 			end;
      365 			else do;			/* Must be IOTD DCW. */
      366 			     lx = lx + 1;		/* Step to third DCW slot. */
      367 			     idcwp = addrel (idcwp, 1);
      368 			end;
      369 		     end;
      370 		     else;			/* Don't do anything for marker status. */
      371 
      372 		     sdb.bgin = lx;			/* Set new starting point. */
      373 		     sdb.running = imess.run;		/* Set running flag. */
      374 		end;
      375 
      376 	     end;
      377 
      378 	     return;
      379 
      380 	end stat_check;
      381 
      382 prtdim_resetwrite: entry (arg_sdb_ptr, iostatus);		/* entry to scrap unprinted information */
      383 
      384 
      385 	iostatus = "0"b;
      386 
      387 	sdb_ptr = arg_sdb_ptr;
      388 	pip = addr (sdb.info);
      389 	pcip = addr (sdb.conv_info);
      390 
      391 	rcode = 0;
      392 
      393 	do while (sdb.running);			/* Wait for printer to stop. */
      394 	     call wait_io;
      395 	     if rcode ^= 0 then do;
      396 		substr (iostatus, 1, 36) = unspec (rcode);
      397 		return;
      398 	     end;
      399 	end;
      400 
      401 	sdb.prev,
      402 	     sdb.bgin,
      403 	     sdb.stop = 0;				/* Reset all indices. */
      404 
      405 	return;					/* Output all scrapped. */
      406 
      407 runout:	entry (arg_sdb_ptr, iostatus);		/* entry to disgorge unprinted information */
      408 
      409 
      410 	iostatus = "0"b;
      411 
      412 	sdb_ptr = arg_sdb_ptr;
      413 	pip = addr (sdb.info);
      414 	pcip = addr (sdb.conv_info);
      415 
      416 	rcode = 0;
      417 
      418 	do while (sdb.prev ^= sdb.stop);		/* Force connects until all caught up. */
      419 	     call wait_io;				/* Start printer and wait for completion. */
      420 	     if rcode ^= 0 then do;
      421 		substr (iostatus, 1, 36) = unspec (rcode);
      422 		return;
      423 	     end;
      424 	end;
      425 
      426 	return;					/* Output all flushed. */
      427 
      428 
      429 
      430      end prtdim_write;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/02/88  1535.7  prtdim_write.pl1                  >special_ldd>install>MR12.2-1019>prtdim_write.pl1
100          1    11/04/83  1107.6  prt_sdb.incl.pl1                  >ldd>include>prt_sdb.incl.pl1
102          2    08/29/75  1310.5  prt_info.incl.pl1                 >ldd>include>prt_info.incl.pl1
104          3    02/02/88  1529.2  prt_conv_info.incl.pl1            >special_ldd>install>MR12.2-1019>prt_conv_info.incl.pl1
107          4    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
108          5    09/13/83  1258.2  status_flags.incl.pl1             >ldd>include>status_flags.incl.pl1
110          6    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
111          7    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 98 ref 116 117 124 164 165 175 185 192 197 235
                                                                                  235 235 235 256 285 285 344 388 389 413 414
addrel                                                 builtin function         dcl 98 ref 349 367
address                                based           bit(18)                  level 2 in structure "tdcw" packed unaligned
                                                                                  dcl 7-14 in procedure "prtdim_write" set ref 194*
                                                                                  362
address                                based           bit(18)                  level 2 in structure "dcw" packed unaligned dcl 7-7
                                                                                  in procedure "prtdim_write" set ref 177*
analyze_device_stat_$rs         000020 constant        entry                    external dcl 65 ref 285
analyze_system_fault_           000022 constant        entry                    external dcl 65 ref 280
arg_sdb_ptr                            parameter       pointer                  dcl 30 ref 27 115 382 387 407 412
backup_flag                            constant        bit(18)                  initial dcl 5-5 ref 347
bgin                    423            based           fixed bin(18,0)          level 2 dcl 1-12 set ref 129 131 133 218* 372* 401*
bin                                                    builtin function         dcl 98 ref 178 194 274 276 352 362
bit                                                    builtin function         dcl 98 ref 178 194
char_cnt                        000114 automatic       fixed bin(18,0)          dcl 37 set ref 167* 168
chars_printed           412            based           fixed bin(35,0)          level 2 dcl 1-12 set ref 142* 142 151* 151 158* 158
code                      0(18)        based           bit(3)                   level 2 packed unaligned dcl 6-21 ref 347 358
com_err_                        000030 constant        entry                    external dcl 65 ref 306 316 336
completion                             based           structure                level 2 in structure "imess" packed unaligned
                                                                                  dcl 4-21 in procedure "prtdim_write"
completion                             based           structure                level 2 in structure "istat" dcl 4-7 in procedure
                                                                                  "prtdim_write"
control                   0(22)        based           bit(2)                   level 2 packed unaligned dcl 6-21 set ref 186*
conv_info                54            based           structure                level 2 dcl 1-12 set ref 117 389 414
convert_ipc_code_               000016 constant        entry                    external dcl 65 ref 237
cur_page                        000101 automatic       fixed bin(17,0)          dcl 37 set ref 127* 146
data                      3            based           fixed bin(17,0)          level 2 dcl 83 set ref 165
dcw                                    based           structure                level 1 dcl 7-7 set ref 176*
dcwp                            000250 automatic       pointer                  dcl 7-4 set ref 175* 176 177 178
dcws                                   based           structure                level 1 dcl 83
ddcw                      1            based           bit(36)                  level 2 dcl 83 set ref 175
dev_stat_bits                   000000 constant        bit(72)                  initial dcl 61 ref 303 304
devname                                based           char(4)                  level 2 dcl 2-7 set ref 280* 306* 316* 336*
devx                      1            based           fixed bin(17,0)          level 2 dcl 2-7 set ref 218*
divide                                                 builtin function         dcl 98 ref 168
dp                              000106 automatic       pointer                  dcl 37 set ref 165* 167* 177
er                        0(01)        based           bit(1)                   level 3 packed unaligned dcl 4-21 ref 278
errmess                         000120 automatic       varying char(256)        dcl 37 set ref 285* 306* 316*
error_count             431            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 282* 282 301* 301
error_table_$net_timeout        000034 external static fixed bin(35,0)          dcl 80 ref 269
error_table_$request_pending    000036 external static fixed bin(35,0)          dcl 81 ref 152
ev_list                  26            based           structure                level 2 dcl 1-12 set ref 235 235
flags                           000306 automatic       bit(18)                  dcl 250 set ref 254* 285* 288 288* 288 294* 294 297
                                                                                  300 313 320 323 328 347
found_dcw                       000307 automatic       bit(1)                   dcl 250 set ref 345* 352 356* 359* 363*
halt_flag                              constant        bit(18)                  initial dcl 5-5 ref 288 313 320
idcw                                   based           bit(36)                  level 2 in structure "dcws" dcl 83 in procedure
                                                                                  "prtdim_write" set ref 180* 185
idcw                                   based           structure                level 1 dcl 6-21 in procedure "prtdim_write" set ref
                                                                                  354
idcwp                           000246 automatic       pointer                  dcl 6-19 set ref 185* 186 344* 347 349* 349 354 358
                                                                                  361 362 367* 367
image_flag                             constant        bit(18)                  initial dcl 54 ref 323
imess                                  based           structure                level 1 dcl 4-21
imp                             000244 automatic       pointer                  dcl 4-19 set ref 256* 257 267 268 274 275 276 278
                                                                                  279 352 373
info                     44            based           structure                level 2 dcl 1-12 set ref 116 388 413
inptr                           000112 automatic       pointer                  dcl 37 set ref 124* 167*
ioi_$connect                    000012 constant        entry                    external dcl 65 ref 218
iostatus                               parameter       bit(72)                  dcl 30 set ref 27 113* 140* 141* 152* 382 385* 396*
                                                                                  407 410* 421*
ipc_$block                      000014 constant        entry                    external dcl 65 ref 235
ipc_message                     000226 automatic       structure                level 1 dcl 89 set ref 235 235
istat                                  based           structure                level 1 dcl 4-7
last_iom_stat                   000222 automatic       bit(72)                  dcl 50 set ref 118* 303 304*
level                     0(15)        based           bit(3)                   level 2 packed unaligned dcl 4-21 ref 257 274 279
                                                                                  352
lp                              000102 automatic       pointer                  dcl 37 set ref 164* 165 173 175 180 185
lth                             000110 automatic       fixed bin(18,0)          dcl 37 set ref 123* 126 142 151 158 167* 169
lx                              000310 automatic       fixed bin(18,0)          dcl 250 set ref 276* 344 348* 348 355* 362* 366* 366
                                                                                  372
marker_count            427            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 183* 183 184 187* 215*
max_err_stat_count                     constant        fixed bin(17,0)          initial dcl 51 ref 313
message                   2     000226 automatic       fixed bin(71,0)          level 2 dcl 89 set ref 256
mode                    415            based           structure                level 2 dcl 1-12
modes                    14            based           structure                level 2 packed unaligned dcl 3-15
nelem                                  parameter       fixed bin(24,0)          dcl 30 ref 27 123 142 151 158 169
nelemt                                 parameter       fixed bin(24,0)          dcl 30 set ref 27 122* 169*
noprint                 415(01)        based           bit(1)                   level 3 packed unaligned dcl 1-12 ref 171
offset                                 parameter       fixed bin(24,0)          dcl 30 in procedure "prtdim_write" ref 27 124
offset                    0(18)        based           bit(18)                  level 2 in structure "imess" packed unaligned
                                                                                  dcl 4-21 in procedure "prtdim_write" ref 276
overflow_off             14            based           bit(1)                   level 3 packed unaligned dcl 3-15 ref 288
page_count               12            based           fixed bin(17,0)          level 2 dcl 3-15 ref 127 146
paper_low               430            based           bit(1)                   level 2 dcl 1-12 set ref 292 293* 341*
paper_low_flag                         constant        bit(18)                  initial dcl 54 ref 288
pci                                    based           structure                level 1 dcl 3-15
pcip                            000242 automatic       pointer                  dcl 3-13 set ref 117* 127 146 167* 288 389* 414*
pip                             000240 automatic       pointer                  dcl 2-5 set ref 116* 173 180 218 280 306 316 336 354
                                                                                  388* 413*
power_fault_flag                       constant        bit(18)                  initial dcl 54 ref 297
prev                    425            based           fixed bin(18,0)          level 2 dcl 1-12 set ref 133 191 197 201* 214 355*
                                                                                  401* 418
prev_lp                         000104 automatic       pointer                  dcl 37 set ref 197* 198
print_idcw                6            based           bit(36)                  level 2 dcl 2-7 ref 180
prt_buffer                             based           structure                level 1 dcl 1-68
prt_conv_                       000010 constant        entry                    external dcl 65 ref 167
prt_info                               based           structure                level 1 dcl 2-7
prt_status_table_$prt_status_table_
                                000032 external static fixed bin(17,0)          dcl 75 set ref 285 285
prtdim_util$load_image          000024 constant        entry                    external dcl 65 ref 260 324
prtdim_util$load_vfc            000026 constant        entry                    external dcl 65 ref 261 329
rcode                           000100 automatic       fixed bin(35,0)          dcl 37 set ref 121* 139 140 218* 235* 236 237* 269*
                                                                                  324* 325 329* 330 391* 395 396 416* 420 421
rel                                                    builtin function         dcl 98 ref 177
reload_vfc_train_after_special
                        524            based           bit(1)                   level 2 dcl 1-12 set ref 259 262* 297*
report_flag                            constant        bit(18)                  initial dcl 5-5 ref 288 294 300
run                       0(02)        based           bit(1)                   level 3 packed unaligned dcl 4-21 ref 373
running                 422            based           bit(1)                   level 2 dcl 1-12 set ref 182 205 216* 232 270* 373*
                                                                                  393
same_err_stat_count             000224 automatic       fixed bin(17,0)          dcl 52 set ref 119* 305* 309* 309 313 335*
sdb                                    based           structure                level 1 dcl 1-12
sdb_ptr                         000236 automatic       pointer                  dcl 1-10 set ref 115* 116 117 129 129 131 131 133
                                                                                  133 142 142 147 147 149 149 149 149 150 151 151
                                                                                  158 158 164 164 171 182 183 183 184 187 191 191
                                                                                  194 197 197 201 201 202 202 203 203 205 214 214
                                                                                  214 215 216 218 232 235 235 258 259 260* 261* 262
                                                                                  270 281 282 282 292 293 297 301 301 315 320 320
                                                                                  324* 329* 334 341 344 355 355 372 373 387* 388 389
                                                                                  393 401 401 401 412* 413 414 418 418
single_page             415            based           bit(1)                   level 3 packed unaligned dcl 1-12 ref 149
st                                     based           bit(1)                   level 3 packed unaligned dcl 4-21 ref 267
status                    1            based           bit(36)                  level 2 packed unaligned dcl 4-21 ref 275
stop                    424            based           fixed bin(18,0)          level 2 dcl 1-12 set ref 129 131 164 191 194 201
                                                                                  202* 202 203 203* 214 355 401* 418
stop_counter            414            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 147* 147 149 150*
stop_every              413            based           fixed bin(17,0)          level 2 dcl 1-12 ref 149 149
string                                                 builtin function         dcl 98 set ref 176* 354
substr                                                 builtin function         dcl 98 set ref 124 140* 141* 152* 396* 421*
tally                     0(24)        based           bit(12)                  level 2 packed unaligned dcl 7-7 set ref 178*
tdcw                      2            based           bit(36)                  level 2 in structure "dcws" dcl 83 in procedure
                                                                                  "prtdim_write" set ref 173* 198*
tdcw                                   based           structure                level 1 dcl 7-14 in procedure "prtdim_write"
tdcwp                           000252 automatic       pointer                  dcl 7-4 set ref 192* 194 195
temp_iom_stat                   000116 automatic       bit(72)                  dcl 37 set ref 275* 280* 285* 303 304
term_idcw                 7            based           bit(36)                  level 2 dcl 2-7 ref 173 354
time_out                  0(03)        based           bit(1)                   level 3 packed unaligned dcl 4-21 ref 268
tra                             000221 automatic       bit(36)                  dcl 37 set ref 192 193* 198
type                      0(22)        based           bit(2)                   level 2 packed unaligned dcl 7-14 set ref 195* 361
unspec                                                 builtin function         dcl 98 ref 140 152 396 421
vfc_flag                               constant        bit(18)                  initial dcl 54 ref 328
wait_flag               426            based           bit(1)                   level 2 dcl 1-12 set ref 214 258* 281* 315* 320* 320
                                                                                  334
wksp                                   based           char(1)                  unaligned dcl 78 set ref 124
wkspptr                                parameter       pointer                  dcl 30 ref 27 124
word_cnt                        000115 automatic       fixed bin(18,0)          dcl 37 set ref 168* 178 183 202
wseg                                   based           bit(36)                  array dcl 1-78 set ref 164 197 344
wsegp                   420            based           pointer                  level 2 dcl 1-12 ref 164 197 344

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
eurc_no_backup_flag                    internal static bit(18)                  initial dcl 5-5
init_flag                              internal static bit(18)                  initial dcl 5-5
isp                                    automatic       pointer                  dcl 4-5
pcw                                    based           structure                level 1 dcl 6-6
pcwp                                   automatic       pointer                  dcl 6-4
prt_bufferp                            automatic       pointer                  dcl 1-66
prt_buffers                            based           structure                array level 1 dcl 1-79
slew_error                             internal static bit(18)                  initial dcl 54

NAMES DECLARED BY EXPLICIT CONTEXT.
prtdim_resetwrite               000212 constant        entry                    external dcl 382
prtdim_write                    000034 constant        entry                    external dcl 27
runout                          000260 constant        entry                    external dcl 407
set_io                          000322 constant        entry                    internal dcl 161 ref 129 131 133
start_io                        000463 constant        entry                    internal dcl 212 ref 205 232
stat_check                      000553 constant        entry                    internal dcl 248 ref 241
wait_io                         000512 constant        entry                    internal dcl 229 ref 136 394 419

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1476        1536    1277        1506
Length      2066    1277        40         314     177           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
prtdim_write                        272 external procedure  is an external procedure.  
set_io                                  internal procedure  shares stack frame of external procedure prtdim_write.  
start_io                                internal procedure  shares stack frame of external procedure prtdim_write.  
wait_io                                 internal procedure  shares stack frame of external procedure prtdim_write.  
stat_check                              internal procedure  shares stack frame of external procedure prtdim_write.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
prtdim_write             000100 rcode                       prtdim_write
                         000101 cur_page                    prtdim_write
                         000102 lp                          prtdim_write
                         000104 prev_lp                     prtdim_write
                         000106 dp                          prtdim_write
                         000110 lth                         prtdim_write
                         000112 inptr                       prtdim_write
                         000114 char_cnt                    prtdim_write
                         000115 word_cnt                    prtdim_write
                         000116 temp_iom_stat               prtdim_write
                         000120 errmess                     prtdim_write
                         000221 tra                         prtdim_write
                         000222 last_iom_stat               prtdim_write
                         000224 same_err_stat_count         prtdim_write
                         000226 ipc_message                 prtdim_write
                         000236 sdb_ptr                     prtdim_write
                         000240 pip                         prtdim_write
                         000242 pcip                        prtdim_write
                         000244 imp                         prtdim_write
                         000246 idcwp                       prtdim_write
                         000250 dcwp                        prtdim_write
                         000252 tdcwp                       prtdim_write
                         000306 flags                       stat_check
                         000307 found_dcw                   stat_check
                         000310 lx                          stat_check

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
analyze_device_stat_$rs       analyze_system_fault_         com_err_                      convert_ipc_code_
ioi_$connect                  ipc_$block                    prt_conv_                     prtdim_util$load_image
prtdim_util$load_vfc

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$net_timeout      error_table_$request_pending  prt_status_table_$prt_status_table_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000026       113 000044       115 000047       116 000052       117 000054       118 000056       119 000057
    121 000060       122 000061       123 000062       124 000064       126 000071       127 000074       129 000077
    131 000105       133 000112       136 000117       139 000120       140 000122       141 000124       142 000127
    143 000140       146 000141       147 000145       149 000147       150 000156       151 000157       152 000167
    153 000172       156 000173       158 000174       159 000205       382 000206       385 000222       387 000226
    388 000232       389 000234       391 000236       393 000237       394 000243       395 000244       396 000246
    397 000250       399 000251       401 000252       405 000255       407 000256       410 000270       412 000274
    413 000300       414 000302       416 000304       418 000305       419 000312       420 000313       421 000315
    422 000317       424 000320       426 000321       161 000322       164 000323       165 000327       167 000331
    168 000350       169 000354       171 000360       173 000365       175 000371       176 000373       177 000374
    178 000376       180 000403       182 000405       183 000410       184 000412       185 000415       186 000417
    187 000421       191 000422       192 000425       193 000427       194 000430       195 000435       197 000441
    198 000443       201 000445       202 000447       203 000453       205 000457       207 000462       212 000463
    214 000464       215 000472       216 000473       218 000475       222 000511       229 000512       232 000513
    235 000517       236 000537       237 000541       238 000550       241 000551       243 000552       248 000553
    254 000554       256 000555       257 000557       258 000565       259 000567       260 000571       261 000603
    262 000615       264 000617       267 000620       268 000623       269 000626       270 000631       271 000633
    274 000634       275 000643       276 000646       278 000651       279 000654       280 000657       281 000674
    282 000677       283 000700       285 000701       288 000730       292 000746       293 000751       294 000753
    297 000755       300 000764       301 000770       303 000772       304 000776       305 001001       306 001003
    307 001025       309 001026       313 001027       315 001036       316 001040       320 001062       323 001070
    324 001074       325 001105       328 001110       329 001114       330 001125       334 001130       335 001133
    336 001134       339 001161       341 001162       344 001164       345 001170       347 001171       348 001203
    349 001205       350 001210       352 001212       354 001224       355 001230       356 001234       357 001236
    358 001237       359 001244       360 001246       361 001247       362 001254       363 001257       364 001261
    366 001262       367 001263       369 001266       372 001267       373 001272       378 001276


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
