	COMPILATION LISTING OF SEGMENT heals_cpu_reports_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/27/84  0745.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* Coded March 1976 by A. Downing.
        8*   This routine is responsible for printing heals cpu error messages that
        9*   are found in the heals log. */
       10 /* Modified 11-82 by F. W. Martinson to fix bugs in report column alignment
       11*   and pointer register reporting */
       12 heals_cpu_reports_: proc (datap, code);
  1     1 /* heals_arg_info.incl.pl1 contains the declaration
  1     2*   of the argument structure passed between heals releated utilities.
  1     3*   Created January 1976 by A. R. Downing */
  1     4 dcl 1 heals_arg_info aligned,
  1     5     2 iocbp ptr,
  1     6     2 report_iocbp ptr,
  1     7     2 err_nb fixed bin (35),
  1     8     2 info_selection bit (72) unal,
  1     9     2 report_name char (64) varying,
  1    10     2 heals_log_path_name char (168),			/* path name of the heals log */
  1    11     2 system_id char (32) varying,
  1    12     2 installation_id char (32) varying,
  1    13     2 from_seq fixed bin (35),			/* beginning seq_num */
  1    14     2 to_seq fixed bin (35),				/* ending seq_num */
  1    15     2 from_time fixed bin (71),			/* beginning of desired time period */
  1    16     2 to_time fixed bin (71);				/* end of desired time period */
  1    17 						/* end heals_arg_info. */
       13 
  2     1 /* Begin include file ..... syserr_message.incl.pl1 */
  2     2 
  2     3 /* Format of a syserr message */
  2     4 
  2     5 /* Created October 1975 by Larry Johnson */
  2     6 
  2     7 dcl  syserr_msgp ptr;				/* Base for include file */
  2     8 
  2     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  2    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  2    11     2 time fixed bin (71) unal,			/* Time message logged at */
  2    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  2    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  2    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  2    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  2    16     2 pad bit (60) unal,				/* RESERVED! */
  2    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  2    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  2    19 
  2    20 
  2    21 /* End include file ..... syserr_message.incl.pl1 */
       14 
  3     1 /* begin heals_message.incl.pl1 */
  3     2 /* Produced March 1976 by A. Downing. */
  3     3 dcl 1 heals_message based (heals_message_p) aligned,
  3     4     2 tally fixed bin (35),
  3     5     2 rest_of_record aligned,
  3     6       3 seq_num fixed bin (35),			/* Sequence number of this message. */
  3     7       3 time fixed bin (71) unal,			/* Time message logged at */
  3     8       3 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  3     9       3 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  3    10       3 data_size fixed bin (11) unal,			/* Size of binary data */
  3    11       3 data_code fixed bin (11) unal,			/* format type code */
  3    12       3 pad bit (60) unal,
  3    13       3 text char (0 refer (heals_message.text_len)),	/* Text of expanded message - kept in ASCII. */
  3    14       3 data (0 refer (heals_message.data_size)) bit (36);	/* Binary data area */
  3    15 dcl  heals_message_p ptr;
  3    16 						/* end heals_message.incl.pl1 */
       15 
  4     1 /*  */
  4     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  4     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  4     4 /* Modified 07/07/76 by Morris for fault register data */
  4     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  4     6 /* Modified '82 to make values constant */
  4     7 
  4     8 /* words 0-15 pointer registers */
  4     9 
  4    10 dcl  mcp ptr;
  4    11 
  4    12 dcl 1 mc based (mcp) aligned,
  4    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  4    14    (2 regs,					/* registers */
  4    15       3 x (0:7) bit (18),				/* index registers */
  4    16       3 a bit (36),					/* accumulator */
  4    17       3 q bit (36),					/* q-register */
  4    18       3 e bit (8),					/* exponent */
  4    19       3 pad1 bit (28),
  4    20       3 t bit (27),					/* timer register */
  4    21       3 pad2 bit (6),
  4    22       3 ralr bit (3),				/* ring alarm register */
  4    23 
  4    24     2 scu (0:7) bit (36),
  4    25 
  4    26     2 mask bit (72),				/* mem controller mask at time of fault */
  4    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  4    28     2 errcode fixed bin (35),				/* fault handler's error code */
  4    29     2 fim_temp,
  4    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  4    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  4    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  4    33     2 fault_reg bit (36),				/* fault register */
  4    34     2 pad2 bit (1),
  4    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  4    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  4    37     2 fault_time bit (54),				/* time of fault */
  4    38 
  4    39     2 eis_info (0:7) bit (36)) unaligned;
  4    40 
  4    41 
  4    42 dcl (apx fixed bin init (0),
  4    43      abx fixed bin init (1),
  4    44      bpx fixed bin init (2),
  4    45      bbx fixed bin init (3),
  4    46      lpx fixed bin init (4),
  4    47      lbx fixed bin init (5),
  4    48      spx fixed bin init (6),
  4    49      sbx fixed bin init (7)) internal static options (constant);
  4    50 
  4    51 
  4    52 
  4    53 
  4    54 dcl  scup ptr;
  4    55 
  4    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  4    57 
  4    58 
  4    59 /*	WORD (0)		*/
  4    60 
  4    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  4    62       3 prr bit (3),				/* procedure ring register */
  4    63       3 psr bit (15),				/* procedure segment register */
  4    64       3 p bit (1),					/* procedure privileged bit */
  4    65 
  4    66     2 apu,					/* APPENDING UNIT STATUS */
  4    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  4    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  4    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  4    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  4    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  4    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  4    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  4    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  4    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  4    76       3 ptw bit (1),				/* Fetch of PTW */
  4    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  4    78       3 fap bit (1),				/* Fetch of final address paged */
  4    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  4    80       3 fabs bit (1),				/* Fetch of final address absolute */
  4    81 
  4    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  4    83 
  4    84 
  4    85 /*	WORD (1)		*/
  4    86 
  4    87     2 fd,						/* FAULT  DATA */
  4    88       3 iro bit (1),				/* illegal ring order */
  4    89       3 oeb bit (1),				/* out of execute bracket */
  4    90       3 e_off bit (1),				/* no execute */
  4    91       3 orb bit (1),				/* out of read bracket */
  4    92       3 r_off bit (1),				/* no read */
  4    93       3 owb bit (1),				/* out of write bracket */
  4    94       3 w_off bit (1),				/* no write */
  4    95       3 no_ga bit (1),				/* not a gate */
  4    96       3 ocb bit (1),				/* out of call bracket */
  4    97       3 ocall bit (1),				/* outward call */
  4    98       3 boc bit (1),				/* bad outward call */
  4    99       3 inret bit (1),				/* inward return */
  4   100       3 crt bit (1),				/* cross ring transfer */
  4   101       3 ralr bit (1),				/* ring alarm register */
  4   102       3 am_er bit (1),				/* associative memory fault */
  4   103       3 oosb bit (1),				/* out of segment bounds */
  4   104       3 paru bit (1),				/* processor parity upper */
  4   105       3 parl bit (1),				/* processor parity lower */
  4   106       3 onc_1 bit (1),				/* op not complete type 1 */
  4   107       3 onc_2 bit (1),				/* op not complete type 2 */
  4   108 
  4   109     2 port_stat,					/* PORT  STATUS */
  4   110       3 ial bit (4),				/* illegal action lines */
  4   111       3 iac bit (3),				/* illegal action channel */
  4   112       3 con_chan bit (3),				/* connect channel */
  4   113 
  4   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  4   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  4   116 
  4   117 
  4   118 /*	WORD (2)		*/
  4   119 
  4   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  4   121       3 trr bit (3),				/* temporary ring register */
  4   122       3 tsr bit (15),				/* temporary segment register */
  4   123 
  4   124     2 pad2 bit (9),
  4   125 
  4   126     2 cpu_no bit (3),				/* CPU number */
  4   127 
  4   128     2 delta bit (6),				/* tally modification DELTA */
  4   129 
  4   130 
  4   131 /*	WORD (3)		*/
  4   132 
  4   133     2 word3 bit (18),
  4   134 
  4   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  4   136       3 tsna,					/* Word 1 status */
  4   137         4 prn bit (3),				/* Word 1  PR  number */
  4   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  4   139       3 tsnb,					/* Word 2  status */
  4   140         4 prn bit (3),				/* Word 2  PR  number */
  4   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  4   142       3 tsnc,					/* Word 3  status */
  4   143         4 prn bit (3),				/* Word 3  PR  number */
  4   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  4   145 
  4   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  4   147 
  4   148 
  4   149 /* 	WORD (4)		*/
  4   150 
  4   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  4   152 
  4   153     2 ir,						/* INDICATOR  REGISTERS */
  4   154       3 zero bit (1),				/* zero indicator */
  4   155       3 neg bit (1),				/* negative indicator */
  4   156       3 carry bit (1),				/* carryry indicator */
  4   157       3 ovfl bit (1),				/* overflow indicator */
  4   158       3 eovf bit (1),				/* eponent overflow */
  4   159       3 eufl bit (1),				/* exponent underflow */
  4   160       3 oflm bit (1),				/* overflow mask */
  4   161       3 tro bit (1),				/* tally runout */
  4   162       3 par bit (1),				/* parity error */
  4   163       3 parm bit (1),				/* parity mask */
  4   164       3 bm bit (1),					/* ^bar mode */
  4   165       3 tru bit (1),				/* truncation mode */
  4   166       3 mif bit (1),				/* multi-word instruction mode */
  4   167       3 abs bit (1),				/* absolute mode */
  4   168       3 hex bit (1),				/* hexadecimal exponent mode */
  4   169       3 pad bit (3),
  4   170 
  4   171 
  4   172 /*	WORD (5)		*/
  4   173 
  4   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  4   175 
  4   176     2 cu,						/* CONTROL UNIT STATUS */
  4   177       3 rf bit (1),					/* on first cycle of repeat instr */
  4   178       3 rpt bit (1),				/* repeat instruction */
  4   179       3 rd bit (1),					/* repeat double instruction */
  4   180       3 rl bit (1),					/* repeat link instruciton */
  4   181       3 pot bit (1),				/* IT  modification */
  4   182       3 pon bit (1),				/* return type instruction */
  4   183       3 xde bit (1),				/* XDE from Even location */
  4   184       3 xdo bit (1),				/* XDE from Odd  location */
  4   185       3 poa bit (1),				/* operation preparation */
  4   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  4   187       3 its bit (1),				/* ITS modification */
  4   188       3 if bit (1),					/* fault occured during instruction fetch */
  4   189 
  4   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  4   191 
  4   192 
  4   193 /*	WORDS (6,7)	*/
  4   194 
  4   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  4   196 
  4   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  4   198 
  4   199 
  4   200 
  4   201 
  4   202 
  4   203 
  4   204 /*	ALTERNATE   SCU  DECLARATION		*/
  4   205 
  4   206 
  4   207 dcl 1 scux based (scup) aligned,
  4   208 
  4   209    (2 pad0 bit (36),
  4   210 
  4   211     2 fd,						/* GROUP II  FAULT DATA */
  4   212       3 isn bit (1),				/* illegal segment number */
  4   213       3 ioc bit (1),				/* illegal op  code  */
  4   214       3 ia_am bit (1),				/* illegal address - modifier */
  4   215       3 isp bit (1),				/* illegal slave  procedure */
  4   216       3 ipr bit (1),				/* illegal procedure */
  4   217       3 nea bit (1),				/* non existent address */
  4   218       3 oobb bit (1),				/* out of bounds */
  4   219       3 pad bit (29),
  4   220 
  4   221     2 pad2 bit (36),
  4   222 
  4   223     2 pad3a bit (18),
  4   224 
  4   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  4   226       3 prn bit (3),				/* PR  number */
  4   227       3 prv bit (1),				/* PR  valid bit */
  4   228 
  4   229     2 pad3b bit (6)) unaligned,
  4   230 
  4   231     2 pad45 (0:1) bit (36),
  4   232 
  4   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  4   234 
  4   235 
  4   236 
  4   237 /*  END INCLUDE FILE   mc.incl.pl1 */
       16 /*mc for machine conditions.*/
       17 dcl  datap ptr;
       18 dcl  code fixed bin (35);
       19 dcl  bin_clock fixed bin (71) init (clock_ ());
       20 dcl  runtime char (16) init ("");
       21 dcl						/* declare temporary registers */
       22      index_regs (0:7) bit (36) aligned,			/* actually each index fits in right half */
       23      exponent_register bit (36) aligned,		/* put in right end of word */
       24      timer_register bit (36) aligned,			/* put in right end */
       25      fault_reg bit (36) aligned,
       26      ralr bit (36) aligned;				/* 3 last bits for ring alarm reg */
       27 dcl  hist_reg (0:127) bit (36) aligned based (hist_reg_ptr);
       28 dcl (i, j) fixed bin;
       29 dcl  hist_reg_ptr ptr init (null ());
       30 dcl 1 arg_info aligned based (datap) like heals_arg_info;
       31 dcl  error_table_$end_of_info ext static fixed bin (35);
       32 dcl  error_table_$long_record ext static fixed bin (35);
       33 dcl  title char (132) varying int static aligned init
       34     ("^-cpu_error report for Multics system ^a.");
       35 dcl (time1, time2) char (16);
       36 dcl  dummy_p (8) ptr aligned,
       37      even_word_buf fixed bin (71) aligned dim (8) based;
       38 dcl  buffer char (2048) aligned;
       39 dcl  buf_p ptr init (null ());
       40 dcl  buf_len fixed bin (21);
       41 dcl  act_len fixed bin (21);
       42 dcl  clock_ entry returns (fixed bin (71));
       43 dcl  date_time_ entry (fixed bin (71), char (*));
       44 dcl  com_err_ entry options (variable);
       45 dcl  ioa_$ioa_switch entry options (variable);
       46 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
       47 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       48 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       49 dcl  iox_$close entry (ptr, fixed bin (35));
       50 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
       51 dcl  hran_$hranl entry (ptr, ptr, bit (1));
       52 dcl  hran_$hrlgnd entry (ptr);
       53 dcl (addr, addrel, index, null) builtin;
       54 dcl  cleanup condition;
       55 dcl  cpu_fault_count fixed bin (21) init (0);
       56 
       57 	call date_time_ (bin_clock, runtime);
       58 	buf_p, heals_message_p = addr (buffer);
       59 	buf_len = length (buffer);
       60 	syserr_msgp = addr (heals_message.rest_of_record);
       61 	arg_info.err_nb = 0;
       62 	on cleanup begin;
       63 	     arg_info.err_nb = -1;
       64 	     call clean_up;
       65 	end;
       66 	if arg_info.report_iocbp = null () then do;
       67 	     arg_info.err_nb = -1;
       68 	     call com_err_ (0, "heals_cpu_reports_",
       69 		"the report stream is not open.");
       70 	     return;
       71 	end;
       72 	call date_time_ ((arg_info.from_time), time1);
       73 	call date_time_ ((arg_info.to_time), time2);
       74 	call ioa_$ioa_switch (arg_info.report_iocbp,
       75 	     "^|CPU_ERROR_REPORT:^8xfrom^x^16a^7xto^x^16a
       76 HEALS RUN OF ^16a ON SYSTEM ^a^3/",
       77 	     time1, time2, runtime, arg_info.system_id);
       78 	do while ("1"b);
       79 	     call iox_$read_record (arg_info.iocbp,
       80 		buf_p, buf_len, act_len, code);
       81 	     if code ^= 0 then
       82 		if code = error_table_$end_of_info then go to copying_done;
       83 		else do;
       84 		     if code = error_table_$long_record then
       85 			arg_info.err_nb = 16;
       86 		     else arg_info.err_nb = -1;
       87 		     call clean_up;
       88 		     return;
       89 		end;
       90 	     else;
       91 	     if heals_message.time > arg_info.to_time then go to copying_done; /* finished */
       92 	     if index (heals_message.text, "hardware_fault:") > 0 then do;
       93 		unspec (addr (dummy_p) -> even_word_buf) = unspec (heals_message.data);
       94 		mcp = addr (heals_message.data (1));
       95 		hist_reg_ptr = addrel (mcp, size (mc)); /* point at history register data */
       96 		if cpu_fault_count = 0 then
       97 		     call hran_$hrlgnd (arg_info.report_iocbp);
       98 		call date_time_ ((heals_message.time), time1);
       99 		call ioa_$ioa_switch (arg_info.report_iocbp,
      100 		     "^|syserr sequence #^d, at ^a;", heals_message.seq_num, time1);
      101 		call ioa_$ioa_switch (arg_info.report_iocbp,
      102 		     "syserr_log text: ^a", heals_message.text);
      103 		call ioa_$ioa_switch (arg_info.report_iocbp,
      104 		     "^/scu_data:^2-^x^2(^4(^w^x^)^/^2-^x^)", mc.scu);
      105 		call ioa_$ioa_switch (arg_info.report_iocbp,
      106 		     "pointer registers:^1-^x^2(^4(^12p^2x^)^/^2-^x^)", dummy_p);
      107 
      108 /* copy register data into aligned fields */
      109 		index_regs (*) = ""b;
      110 		exponent_register, timer_register, ralr = ""b;
      111 		substr (index_regs (*), 19, 18) = mc.x (*); /* copy */
      112 		substr (exponent_register, 29, 8) = mc.e; /* copy */
      113 		substr (timer_register, 10, 27) = mc.t; /* copy */
      114 		substr (ralr, 34, 3) = mc.ralr;	/* copy */
      115 		fault_reg = mc.fault_reg;		/* copy */
      116 						/* data copied into aligned fields for ioa_ */
      117 
      118 		call ioa_$ioa_switch (arg_info.report_iocbp,
      119 		     "index registers:^1-^x^2(^4(^6w^x^)^/^2-^x^)", index_regs);
      120 		call ioa_$ioa_switch (arg_info.report_iocbp,
      121 		     "^/a: ^w q: ^w  exp: ^3w timer: ^9w ring_alarm: ^1w",
      122 		     mc.a, mc.q, exponent_register, timer_register, ralr);
      123 		call ioa_$ioa_switch (arg_info.report_iocbp,
      124 		     "^/eis_info:^2-^x^2(^4(^w^x^)^/^2-^x^)", mc.eis_info);
      125 		call ioa_$ioa_switch (arg_info.report_iocbp,
      126 		     "fault register:^1-^1x^w", fault_reg);
      127 		call ioa_$ioa_switch (arg_info.report_iocbp, "^/NUM^-OU registers^2-^7xCU registers");
      128 		j = 0;
      129 		do i = 0 by 2 to 30;
      130 		     j = j+1;
      131 		     call ioa_$ioa_switch (arg_info.report_iocbp, "^o^-^w ^w^12x^w ^w",
      132 			j, hist_reg (i), hist_reg (i+1),
      133 			hist_reg (i+32), hist_reg (i+33));
      134 		end;
      135 		call ioa_$ioa_switch (arg_info.report_iocbp, "^/NUM^-DU registers^3-AU registers");
      136 		do i = 64 by 2 to 94;
      137 		     j = j+1;
      138 		     call ioa_$ioa_switch (arg_info.report_iocbp, "^o^-^w ^w^12x^w ^w",
      139 			j-16, hist_reg (i), hist_reg (i+1),
      140 			hist_reg (i+32), hist_reg (i+33));
      141 		end;
      142 		call ioa_$ioa_switch (arg_info.report_iocbp, "");
      143 		call hran_$hranl (hist_reg_ptr, arg_info.report_iocbp, "0"b);
      144 		cpu_fault_count = cpu_fault_count + 1;
      145 	     end;					/* end of copying onc fault record */
      146 	end;					/* end of while loop */
      147 copying_done:
      148 	arg_info.err_nb = 0;
      149 	if cpu_fault_count = 0 then
      150 	     call ioa_$ioa_switch (arg_info.report_iocbp,
      151 	     "^/^-NO CPU FAULTS FOUND DURING SPECIFIED TIME RANGE.");
      152 	call ioa_$ioa_switch (arg_info.report_iocbp,
      153 	     "^/END: CPU_ERROR_REPORT");
      154 	call clean_up;
      155 
      156 clean_up:	proc;
      157 	     if arg_info.iocbp ^= null () then
      158 		call iox_$close (arg_info.iocbp, code);
      159 	     return;
      160 	end clean_up;
      161 	return;
      162      end heals_cpu_reports_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/27/84  0745.2  heals_cpu_reports_.pl1            >spec>on>heals>heals_cpu_reports_.pl1
13           1    11/02/76  1752.0  heals_arg_info.incl.pl1           >ldd>include>heals_arg_info.incl.pl1
14           2    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
15           3    10/25/77  1258.3  heals_message.incl.pl1            >ldd>include>heals_message.incl.pl1
16           4    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        24            based           bit(36)                  level 3 packed unaligned dcl 4-12 set ref 120*
act_len                         001321 automatic       fixed bin(21,0)          dcl 41 set ref 79*
addr                                                   builtin function         dcl 53 ref 58 60 93 94
addrel                                                 builtin function         dcl 53 ref 95
arg_info                               based           structure                level 1 dcl 30
bin_clock                       000240 automatic       fixed bin(71,0)          initial dcl 19 set ref 19* 57*
buf_len                         001320 automatic       fixed bin(21,0)          dcl 40 set ref 59* 79*
buf_p                           001316 automatic       pointer                  initial dcl 39 set ref 39* 58* 79*
buffer                          000316 automatic       char(2048)               dcl 38 set ref 58 59
cleanup                         001322 stack reference condition                dcl 54 ref 62
clock_                          000014 constant        entry                    external dcl 42 ref 19
code                                   parameter       fixed bin(35,0)          dcl 18 set ref 12 79* 81 81 84 157*
com_err_                        000020 constant        entry                    external dcl 44 ref 68
cpu_fault_count                 001330 automatic       fixed bin(21,0)          initial dcl 55 set ref 55* 96 144* 144 149
data                                   based           bit(36)                  array level 3 dcl 3-3 set ref 93 94
data_size                 4(24)        based           fixed bin(11,0)          level 3 packed unaligned dcl 3-3 set ref 93
datap                                  parameter       pointer                  dcl 17 ref 12 61 63 66 67 72 73 74 74 79 84 86 91 96
                                                                                  99 101 103 105 118 120 123 125 127 131 135 138 142
                                                                                  143 147 149 152 157 157
date_time_                      000016 constant        entry                    external dcl 43 ref 57 72 73 98
dummy_p                         000276 automatic       pointer                  array dcl 36 set ref 93 105*
e                        26            based           bit(8)                   level 3 packed unaligned dcl 4-12 ref 112
eis_info                 50            based           bit(36)                  array level 2 packed unaligned dcl 4-12 set ref 123*
err_nb                    4            based           fixed bin(35,0)          level 2 dcl 30 set ref 61* 63* 67* 84* 86* 147*
error_table_$end_of_info        000010 external static fixed bin(35,0)          dcl 31 ref 81
error_table_$long_record        000012 external static fixed bin(35,0)          dcl 32 ref 84
even_word_buf                          based           fixed bin(71,0)          array dcl 36 set ref 93*
exponent_register               000256 automatic       bit(36)                  dcl 21 set ref 110* 112* 120*
fault_reg                45            based           bit(36)                  level 2 in structure "mc" packed unaligned dcl 4-12
                                                                                  in procedure "heals_cpu_reports_" ref 115
fault_reg                       000260 automatic       bit(36)                  dcl 21 in procedure "heals_cpu_reports_" set ref
                                                                                  115* 125*
from_time               126            based           fixed bin(71,0)          level 2 dcl 30 ref 72
heals_arg_info                  000100 automatic       structure                level 1 dcl 1-4
heals_message                          based           structure                level 1 dcl 3-3
heals_message_p                 000234 automatic       pointer                  dcl 3-15 set ref 58* 60 91 92 93 94 98 99 101
hist_reg                               based           bit(36)                  array dcl 27 set ref 131* 131* 131* 131* 138* 138*
                                                                                  138* 138*
hist_reg_ptr                    000264 automatic       pointer                  initial dcl 29 set ref 29* 95* 131 131 131 131 138
                                                                                  138 138 138 143*
hran_$hranl                     000030 constant        entry                    external dcl 51 ref 143
hran_$hrlgnd                    000032 constant        entry                    external dcl 52 ref 96
i                               000262 automatic       fixed bin(17,0)          dcl 28 set ref 129* 131 131 131 131* 136* 138 138
                                                                                  138 138*
index                                                  builtin function         dcl 53 ref 92
index_regs                      000246 automatic       bit(36)                  array dcl 21 set ref 109* 111* 118*
ioa_$ioa_switch                 000022 constant        entry                    external dcl 45 ref 74 99 101 103 105 118 120 123
                                                                                  125 127 131 135 138 142 149 152
iocbp                                  based           pointer                  level 2 dcl 30 set ref 79* 157 157*
iox_$close                      000026 constant        entry                    external dcl 49 ref 157
iox_$read_record                000024 constant        entry                    external dcl 48 ref 79
j                               000263 automatic       fixed bin(17,0)          dcl 28 set ref 128* 130* 130 131* 137* 137 138
mc                                     based           structure                level 1 dcl 4-12 set ref 95
mcp                             000236 automatic       pointer                  dcl 4-10 set ref 94* 95 95 103 111 112 113 114 115
                                                                                  120 120 123
null                                                   builtin function         dcl 53 ref 29 39 66 157
q                        25            based           bit(36)                  level 3 packed unaligned dcl 4-12 set ref 120*
ralr                            000261 automatic       bit(36)                  dcl 21 in procedure "heals_cpu_reports_" set ref
                                                                                  110* 114* 120*
ralr                     27(33)        based           bit(3)                   level 3 in structure "mc" packed unaligned dcl 4-12
                                                                                  in procedure "heals_cpu_reports_" ref 114
regs                     20            based           structure                level 2 packed unaligned dcl 4-12
report_iocbp              2            based           pointer                  level 2 dcl 30 set ref 66 74* 96* 99* 101* 103* 105*
                                                                                  118* 120* 123* 125* 127* 131* 135* 138* 142* 143*
                                                                                  149* 152*
rest_of_record            1            based           structure                level 2 dcl 3-3 set ref 60
runtime                         000242 automatic       char(16)                 initial unaligned dcl 20 set ref 20* 57* 74*
scu                      30            based           bit(36)                  array level 2 packed unaligned dcl 4-12 set ref 103*
seq_num                   1            based           fixed bin(35,0)          level 3 dcl 3-3 set ref 99*
syserr_msgp                     000232 automatic       pointer                  dcl 2-7 set ref 60*
system_id               102            based           varying char(32)         level 2 dcl 30 set ref 74*
t                        27            based           bit(27)                  level 3 packed unaligned dcl 4-12 ref 113
text                      7            based           char                     level 3 dcl 3-3 set ref 92 101*
text_len                  4(12)        based           fixed bin(11,0)          level 3 packed unaligned dcl 3-3 set ref 92 93 94
                                                                                  101 101
time                      2            based           fixed bin(71,0)          level 3 packed unaligned dcl 3-3 set ref 91 98
time1                           000266 automatic       char(16)                 unaligned dcl 35 set ref 72* 74* 98* 99*
time2                           000272 automatic       char(16)                 unaligned dcl 35 set ref 73* 74*
timer_register                  000257 automatic       bit(36)                  dcl 21 set ref 110* 113* 120*
to_time                 130            based           fixed bin(71,0)          level 2 dcl 30 ref 73 91
x                        20            based           bit(18)                  array level 3 packed unaligned dcl 4-12 ref 111

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abx                                    internal static fixed bin(17,0)          initial dcl 4-42
apx                                    internal static fixed bin(17,0)          initial dcl 4-42
bbx                                    internal static fixed bin(17,0)          initial dcl 4-42
bpx                                    internal static fixed bin(17,0)          initial dcl 4-42
iox_$attach_ioname              000000 constant        entry                    external dcl 46
iox_$detach_iocb                000000 constant        entry                    external dcl 50
iox_$open                       000000 constant        entry                    external dcl 47
lbx                                    internal static fixed bin(17,0)          initial dcl 4-42
lpx                                    internal static fixed bin(17,0)          initial dcl 4-42
sbx                                    internal static fixed bin(17,0)          initial dcl 4-42
scu                                    based           structure                level 1 dcl 4-56
scup                                   automatic       pointer                  dcl 4-54
scux                                   based           structure                level 1 dcl 4-207
spx                                    internal static fixed bin(17,0)          initial dcl 4-42
syserr_msg                             based           structure                level 1 dcl 2-9
title                                  internal static varying char(132)        initial dcl 33

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        001670 constant        entry                    internal dcl 156 ref 64 87 154
copying_done                    001611 constant        label                    dcl 147 ref 81 91
heals_cpu_reports_              000307 constant        entry                    external dcl 12

NAMES DECLARED BY CONTEXT OR IMPLICATION.
length                                                 builtin function         ref 59
size                                                   builtin function         ref 95
substr                                                 builtin function         set ref 111 112* 113* 114*
unspec                                                 builtin function         ref 93 93

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2062        2116    1715        2072
Length      2376    1715        34         243     144           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
heals_cpu_reports_                  846 external procedure  is an external procedure.  
on unit on line 62                   64 on unit               
clean_up                             70 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
heals_cpu_reports_       000100 heals_arg_info              heals_cpu_reports_
                         000232 syserr_msgp                 heals_cpu_reports_
                         000234 heals_message_p             heals_cpu_reports_
                         000236 mcp                         heals_cpu_reports_
                         000240 bin_clock                   heals_cpu_reports_
                         000242 runtime                     heals_cpu_reports_
                         000246 index_regs                  heals_cpu_reports_
                         000256 exponent_register           heals_cpu_reports_
                         000257 timer_register              heals_cpu_reports_
                         000260 fault_reg                   heals_cpu_reports_
                         000261 ralr                        heals_cpu_reports_
                         000262 i                           heals_cpu_reports_
                         000263 j                           heals_cpu_reports_
                         000264 hist_reg_ptr                heals_cpu_reports_
                         000266 time1                       heals_cpu_reports_
                         000272 time2                       heals_cpu_reports_
                         000276 dummy_p                     heals_cpu_reports_
                         000316 buffer                      heals_cpu_reports_
                         001316 buf_p                       heals_cpu_reports_
                         001320 buf_len                     heals_cpu_reports_
                         001321 act_len                     heals_cpu_reports_
                         001330 cpu_fault_count             heals_cpu_reports_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      date_time_                    hran_$hranl
hran_$hrlgnd                  ioa_$ioa_switch               iox_$close                    iox_$read_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$long_record




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000303        19 000314        20 000322        29 000325        39 000327        55 000330        57 000331
     58 000346        59 000352        60 000354        61 000356        62 000362        63 000376        64 000404
     65 000411        66 000412        67 000421        68 000423        70 000456        72 000457        73 000476
     74 000520        78 000561        79 000562        81 000603        84 000611        86 000620        87 000624
     88 000630        91 000631        92 000641        93 000653        94 000670        95 000672        96 000675
     98 000706        99 000730       101 000764       103 001022       105 001052       109 001101       110 001112
    111 001115       112 001136       113 001143       114 001146       115 001152       118 001154       120 001203
    123 001250       125 001300       127 001327       128 001352       129 001353       130 001357       131 001360
    134 001431       135 001434       136 001457       137 001465       138 001466       141 001542       142 001545
    143 001567       144 001607       146 001610       147 001611       149 001615       152 001637       154 001662
    161 001666       156 001667       157 001675       159 001714


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
