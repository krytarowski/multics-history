	COMPILATION LISTING OF SEGMENT output_request_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1327.9 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 output_request_: proc (a_stream_name, a_element_size, a_stat_p, a_banner_proc, a_code);
       14 
       15 /* General procedure for doing output for an I/O daemon device driver */
       16 
       17 /* Rewritten from old procedure "io_daemon" in August 1973 by Robert S. Coren */
       18 /* Modified in March 1975 by J.C. Whitmore during driver restructuring */
       19 /* Modified in December 1975 by M. A. Braida to include new restart capabilities and update the accounting mechanism */
       20 /* modified 05/76 by THVV for set_kst_attributes & force deactivation */
       21 /* Modified 06/76 by J. C. Whitmore to fix translate hardware bug */
       22 /* Modified June 1976 by J. L. Homan to accommodate charging by line count instead of block count. */
       23 /* modified July 1976 by THVV for message notification */
       24 /* Modified Nov 1977 by J. C. Whitmore  for minor bug fixed and remote driver compatability */
       25 /* Modified Mar 1978 by J. C. Whitmore for new dprint_msg format and driver upgrade */
       26 /* Modified Aug 1978 by J. C. Whitmore for: auto defer by time estimate, separation of charge queue and request queue,
       27*   no deletion if device error occurs, and further upgrade. */
       28 /* Modified Nov 1978 by J. C. Whitmore to add path to device error msg and to notify user on deferring request */
       29 /* Modified Mar 1979 by J. C. Whitmore to correct string size on some assignments */
       30 /* Modified by J. C. Whitmore, 1/80, to limit the scope of system_privileges_ for send mail (V5.4) */
       31 /* Modified: February 23, 1985 by C. Marker if the page labels are not the same as the access class of the segment a message will be logged.  Changed to use version 5 message segments */
       32 
       33 
       34 /****^  HISTORY COMMENTS:
       35*  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
       36*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
       37*     Changed to implement line numbered output.
       38*  2) change(88-06-03,Brunelle), approve(88-06-03,MCR7911),
       39*     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
       40*     Upgraded to version 5 I/O daemon tables.
       41*                                                   END HISTORY COMMENTS */
       42 
       43 
       44 	dcl     a_stream_name	 char (*);	/* stream to write the output on */
       45 	dcl     a_element_size	 fixed bin;	/* number of bits in each stream element */
       46 	dcl     a_stat_p		 ptr;		/* the value of stat_p from caller */
       47 	dcl     a_banner_proc	 entry;		/* procedure to be called for head and tail banners */
       48 	dcl     a_code		 fixed bin (35);	/* error code....used for driver_fatal_error */
       49 
       50 /* AUTOMATIC */
       51 
       52 	dcl     abort_msg		 char (256) var;	/* string for bad error messages */
       53 	dcl     access_class	 bit (72) aligned;	/* access class of user file */
       54 	dcl     auth		 bit (72) aligned;	/* authorization used to set banner access class */
       55 	dcl     auth_string		 char (680);	/* string form of auth */
       56 	dcl     banner_proc		 entry variable options (variable); /* proc to be called for messages */
       57 	dcl     chgsw		 bit (1) aligned;	/* do we charge for this request/copy */
       58 	dcl     code		 fixed bin (35);
       59 	dcl     copies_left		 fixed bin;
       60 	dcl     delete_msg		 char (32);
       61 	dcl     desc_ptr		 ptr;
       62 	dcl     dest		 char (24) aligned;
       63 	dcl     device_error	 bit (1);
       64 	dcl     dr_ptr		 ptr;		/* pointer to driver status segment */
       65 	dcl     el_size		 fixed bin;
       66 	dcl     ename		 char (32) aligned; /* entry name of file for output */
       67 	dcl     err_mess		 char (200) var;
       68 	dcl     fcbp		 ptr;
       69 	dcl     full_path		 char (168) aligned;
       70 	dcl     head		 char (64) aligned;
       71 	dcl     header_sw		 bit (1);
       72 	dcl     i			 fixed bin;	/* random variable */
       73 	dcl     iocbp		 ptr;		/* iocb pointer for request stream */
       74 	dcl     l			 fixed bin;
       75 	dcl     last_error_count	 fixed bin;
       76 	dcl     lg_msg		 char (100) aligned;
       77 	dcl     mailname		 char (32) aligned;
       78 	dcl     max_comp		 fixed bin;	/* highest msf component number */
       79 	dcl     msg		 char (256) aligned;
       80 	dcl     new_clock		 fixed bin (71);
       81 	dcl     new_cpu		 fixed bin (52);
       82 	dcl     new_pp		 fixed bin;
       83 	dcl     new_rate		 fixed bin;
       84 	dcl     new_waits		 fixed bin (35);
       85 	dcl     nret		 fixed bin;
       86 	dcl     old_clock		 fixed bin (71);
       87 	dcl     oldmodes		 char (256);
       88 	dcl     old_cpu		 fixed bin (52);
       89 	dcl     old_pp		 fixed bin;
       90 	dcl     old_rate		 fixed bin;
       91 	dcl     old_waits		 fixed bin (35);
       92 	dcl     pverb		 char (5) aligned;
       93 	dcl     req_stream		 char (32);
       94 	dcl     save_code		 fixed bin (35);
       95 	dcl     seconds		 fixed bin;	/* number of seconds to do one copy */
       96 	dcl     segp		 ptr;
       97 	dcl     start_segp		 pointer;
       98 	dcl     short_msg		 char (8) aligned;
       99 	dcl     time_est		 fixed bin;	/* number of seconds estimated to do request */
      100 	dcl     total_bits		 fixed bin (35);
      101 	dcl     user_dir		 char (168) aligned;/* directory containing users' segment */
      102 	dcl     val		 fixed bin;	/* for validation level */
      103 
      104 /* INTERNAL STATIC */
      105 
      106 	dcl     bad_chars		 char (4) int static;
      107 	dcl     err_label		 label int static;	/* point of return from condition handler */
      108 	dcl     fault_name		 char (32) aligned int static;
      109 	dcl     first_call		 bit (1) static init ("1"b); /* TRUE on first call */
      110 	dcl     privileged		 bit (1) static init ("1"b); /* TRUE if we can call phcs_ */
      111 	dcl     sys_priv		 bit (1) static init ("1"b); /* True if process can call system_privilege_ */
      112 	dcl     request_data_p	 ptr int static;	/* ptr to REQUEST for set_single_copy entrry */
      113 
      114 
      115 /*	CONSTANTS 	*/
      116 
      117 	dcl     both		 fixed bin int static options (constant) init (0);
      118 	dcl     error		 fixed bin int static options (constant) init (2);
      119 	dcl     error_msg		 fixed bin int static options (constant) init (3); /* value for print error message */
      120 	dcl     factor		 float bin int static options (constant) init (0.75e0); /* smoothing factor for rate estimate */
      121 	dcl     header		 fixed bin int static options (constant) init (1); /* value for header wanted */
      122 	dcl     id		 char (24) int static options (constant) init ("output_request_");
      123 	dcl     log		 fixed bin int static options (constant) init (0);
      124 	dcl     master		 fixed bin int static options (constant) init (1);
      125 	dcl     quiet		 bit (1) int static options (constant) init ("0"b);
      126 	dcl     restart_source	 fixed bin int static init (1);
      127 	dcl     slave		 fixed bin int static options (constant) init (2);
      128 	dcl     stars		 char (40) int static options (constant) aligned init ((40)"*"); /* For error messages */
      129 	dcl     tail		 fixed bin int static options (constant) init (2); /* value for tail wanted */
      130 	dcl     tell_user		 bit (1) int static options (constant) init ("1"b);
      131 
      132 	dcl     NL		 char (1) int static options (constant) init ("
      133 ");
      134 	dcl     TAB		 char (1) int static options (constant) init ("	"); /* the tab character */
      135 	dcl     VT		 char (1) int static options (constant) init ("");						/* the vertical  tab */
      136 	dcl     FF		 char (1) int static options (constant) init ("");						/* and the form feed */
      137 
      138 /* EXTERNAL STATIC */
      139 
      140 	dcl     access_operations_$io_daemon_set_page_labels bit (36) aligned external static;
      141 
      142 	dcl     error_table_$improper_data_format fixed bin (35) ext static;
      143 	dcl     error_table_$noentry	 fixed bin (35) ext static;
      144 	dcl     error_table_$moderr	 fixed bin (35) ext static;
      145 	dcl     error_table_$dirseg	 ext static fixed bin (35);
      146 	dcl     error_table_$ai_restricted ext static fixed bin (35);
      147 
      148 
      149 /* EXTERNAL ENTRIES */
      150 
      151 	dcl     access_audit_gate_$log_obj_ptr_user entry options (variable);
      152 	dcl     aim_check_$equal	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      153 	dcl     aim_check_$greater	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      154 	dcl     clock_		 ext entry returns (fixed bin (71)); /* gets clock time */
      155 	dcl     continue_to_signal_	 entry (fixed bin (35));
      156 	dcl     convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
      157 	dcl     convert_authorization_$to_string entry (bit (72) aligned, char (*), fixed bin (35));
      158 	dcl     convert_status_code_	 ext entry (fixed bin (35), char (8) aligned, char (100) aligned);
      159 	dcl     cpu_time_and_paging_	 entry (fixed bin (35), fixed bin (52), fixed bin);
      160 	dcl     cu_$level_get	 entry (fixed bin);
      161 	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
      162 	dcl     date_time_		 entry (fixed bin (71), char (*) aligned);
      163 	dcl     hcs_$fs_get_mode	 ext entry (ptr, fixed bin (5), fixed bin (35));
      164 	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35));
      165 	dcl     hcs_$get_access_class	 entry (char (*) aligned, char (*) aligned, bit (72) aligned, fixed bin (35));
      166 	dcl     hcs_$get_user_effmode	 entry (char (*) aligned, char (*) aligned, char (*) aligned,
      167 				 fixed bin, fixed bin (5), fixed bin (35));
      168 	dcl     hcs_$status_minf	 entry (char (*) aligned, char (*) aligned, fixed bin, fixed bin (2), fixed bin (24), fixed bin (35));
      169 	dcl     io_daemon_account_	 entry (entry, ptr);
      170 	dcl     ioa_$ioa_stream	 entry options (variable);
      171 	dcl     ioa_$rsnnl		 entry options (variable);
      172 	dcl     iodd_msg_		 entry options (variable);
      173 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      174 	dcl     iox_$modes		 entry (ptr, char (*), char (*), fixed bin (35));
      175 	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
      176 	dcl     iox_$look_iocb	 entry (char (*), ptr, fixed bin (35));
      177 	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (24), fixed bin (35));
      178 	dcl     msf_manager_$close	 entry (ptr);
      179 	dcl     msf_manager_$get_ptr	 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      180 	dcl     msf_manager_$open	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
      181 	dcl     phcs_$deactivate	 entry (ptr, fixed bin (35));
      182 	dcl     phcs_$set_kst_attributes entry (fixed bin, ptr, fixed bin (35));
      183 	dcl     read_allowed_	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      184 	dcl     send_mail_$access_class entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned, fixed bin (35));
      185 	dcl     system_privilege_$ipc_priv_on entry (fixed bin (35));
      186 	dcl     system_privilege_$ipc_priv_off entry (fixed bin (35));
      187 	dcl     system_privilege_$ring1_priv_on entry (fixed bin (35));
      188 	dcl     system_privilege_$ring1_priv_off entry (fixed bin (35));
      189 
      190 /* STRUCTURES */
      191 
      192 	dcl     1 ksta		 like kst_attributes aligned int static;
      193 
      194 	dcl     1 counts_data	 aligned like counts;
      195 
      196 
      197 
      198 /* BUILTINS */
      199 
      200 	dcl     (addr, bit, divide, fixed, length, null, substr, ltrim, rtrim, translate) builtin;
      201 	dcl     (baseno, binary, string, unspec, float, min, char) builtin;
      202 
      203 
      204 /* CONDITIONS */
      205 
      206 	dcl     (cleanup, linkage_error, daemon_again, daemon_again_slave, daemon_kill,
      207 	        daemon_save, daemon_defer, daemon_cancel, any_other) condition;
      208 
      209 /* output_request_: proc (a_stream_name,  a_element_size, a_stat_p, a_banner_proc, a_code);  MAIN ENTRY      */
      210 
      211 /* copy arguments and initialize pointers and control switches */
      212 
      213 	stat_p = a_stat_p;
      214 	sdb_ptr = null ();
      215 	banner_proc = a_banner_proc;			/* no charging yet */
      216 
      217 	chgsw = "0"b;
      218 	fcbp, segp, start_segp = null;
      219 	req_stream = a_stream_name;
      220 	el_size = a_element_size;
      221 	a_code = 0;				/* set to zero for now */
      222 	if first_call then do;			/* Conduct an experiment to see about phcs_ */
      223 		bad_chars = TAB || NL || VT || FF;	/* define the bad chars for labels */
      224 		on linkage_error begin;
      225 			privileged = "0"b;
      226 			go to tough;
      227 		     end;
      228 		string (ksta) = "0"b;
      229 		call phcs_$set_kst_attributes (binary (baseno (stat_p), 18), addr (ksta), (0));
      230 						/* This is a NOP - structure is 0 */
      231 		ksta.set.tpd, ksta.value.tpd = "1"b;	/* Dont put on bulkstore just for lil ole me */
      232 		ksta.set.explicit_deactivate_ok, ksta.value.explicit_deactivate_ok = "1"b;
      233 		ksta.set.allow_write = "1"b;		/* Dont let me wreck user seg by accident */
      234 		ksta.set.tus, ksta.value.tus = "1"b;	/* Save a vtoc write */
      235 tough:		revert linkage_error;
      236 		first_call = "0"b;			/* Now we know */
      237 	     end;
      238 	last_error_count = -1;			/* invalid error count, hasn't been set */
      239 
      240 	dr_ptr = iodd_static.driver_ptr;		/* get ptr to the current driver status seg */
      241 	desc_ptr = addr (dr_ptr -> driver_status.descriptor); /* and to the request descriptor */
      242 	mseg_message_info_ptr = desc_ptr;		/* first part of desciptor is mseg_message_info */
      243 	dmp = addr (dr_ptr -> driver_status.message);	/* set dprint_msg default pointer */
      244 	request_data_p = addr (REQUEST);		/* get ready to handle "single copy" request */
      245 	driver_data_p = addr (desc_ptr -> request_descriptor.driver_data); /* get ptr to printer_driver_data */
      246 	orderp = addr (counts_data);			/* set auto ref ptr to counts structure */
      247 	header_sw = ""b;
      248 
      249 	call iox_$look_iocb (req_stream, iocbp, code);
      250 	if code ^= 0 then do;
      251 		call driver_fatal_error (code, "Unable to find iocb pointer for output stream.");
      252 		go to clean_out;
      253 	     end;
      254 
      255 	on cleanup call clean_proc;			/* establish a cleanup handler */
      256 	sdb_ptr = iocbp;
      257 	err_label = abort_request;
      258 
      259 /* Set up master structure used by this pgm. */
      260 
      261 	string (REQUEST.control_flags) = ""b;		/* clear all the flags */
      262 	REQUEST.requestor = mseg_message_info.sender_id;
      263 	REQUEST.continued = desc_ptr -> request_descriptor.continued;
      264 	REQUEST.restarted = desc_ptr -> request_descriptor.restarted;
      265 	REQUEST.priority_request = desc_ptr -> request_descriptor.priority_request;
      266 	REQUEST.separator = "1"b;			/* we always want a print separator first time */
      267 	REQUEST.device_name = dr_ptr -> driver_status.dev_name_label;
      268 	REQUEST.request_type = dr_ptr -> driver_status.req_type_label;
      269 	REQUEST.queue = desc_ptr -> request_descriptor.q;
      270 	REQUEST.charge_queue = desc_ptr -> request_descriptor.charge_q; /* coord may want a priority rate */
      271 	REQUEST.request_no = desc_ptr -> request_descriptor.seq_id; /* coord assigned the number */
      272 	REQUEST.restart_no = desc_ptr -> request_descriptor.prev_seq_id;
      273 						/* previous number of request (0 = not restarted) */
      274 	REQUEST.contd_no = desc_ptr -> request_descriptor.contd_seq_id;
      275 						/* previous number of continued request (0 = not continued) */
      276 	REQUEST.dpmp = dmp;
      277 	if dprint_msg.delete_sw then REQUEST.delete = 1;
      278 	else REQUEST.delete = 0;
      279 	REQUEST.bit_count = 0;
      280 	REQUEST.line_count = 0;
      281 	REQUEST.page_count = 0;
      282 	REQUEST.line_nbrs = dprint_msg.line_nbrs;
      283 	REQUEST.copies = dprint_msg.copies;
      284 	if ^(REQUEST.continued | REQUEST.restarted) then
      285 	     print_driver_data.copies_done = 0;		/* no copies assumed, unless continued or restarted */
      286 						/* if none completed, it's not continued */
      287 	else if print_driver_data.copies_done < 1 then REQUEST.continued = "0"b;
      288 	print_driver_data.copies_done = min (print_driver_data.copies_done, REQUEST.copies - 1);
      289 						/* be sure we do at least one copy */
      290 	copies_left = REQUEST.copies - print_driver_data.copies_done; /* might be partly done */
      291 	REQUEST.copy_no = print_driver_data.copies_done + 1; /* we start with the next copy */
      292 	REQUEST.notify = dprint_msg.notify;
      293 	REQUEST.output_mode = "";			/* clear in case of error message */
      294 	REQUEST.total_charge = 0e0;
      295 	REQUEST.charge = 0e0;
      296 	REQUEST.time_start_request = clock_ ();
      297 	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);
      298 
      299 	if dprint_msg.output_module = 1 then do;
      300 		REQUEST.punsw = 0;
      301 		pverb = "print";
      302 	     end;
      303 	else do;
      304 		REQUEST.punsw = 1;
      305 		pverb = "punch";
      306 	     end;
      307 
      308 	l = length (rtrim (REQUEST.requestor)) - 2;	/* get length of Person.Project */
      309 	mailname = substr (REQUEST.requestor, 1, l);
      310 	unspec (send_mail_info) = "0"b;
      311 	send_mail_info.version = send_mail_info_version_2;
      312 	send_mail_info.wakeup = "1"b;
      313 	send_mail_info.always_add = "1"b;
      314 	send_mail_info.sent_from = REQUEST.request_type;
      315 
      316 /* get pathname of file for operator and error messages */
      317 
      318 	user_dir = dprint_msg.dirname;
      319 	ename = dprint_msg.ename;
      320 	call ioa_$rsnnl ("^a^[>^]^a", full_path, l, user_dir, (user_dir ^= ">"), ename);
      321 
      322 	REQUEST.full_path = translate (full_path, "", bad_chars); /* force a page fault - HARDWARE BUG WRITEAROUND */
      323 	full_path = translate (full_path, "", bad_chars); /* remove bad chars for banner */
      324 	dprint_msg.destination = translate (dprint_msg.destination, "", bad_chars);
      325 	dprint_msg.heading = translate (dprint_msg.heading, "", bad_chars);
      326 	REQUEST.full_path = full_path;		/* save the clean copy */
      327 
      328 /*  record the processing of this request in the log  */
      329 
      330 	head = dprint_msg.heading;
      331 	if substr (head, 1, 5) = " for " then /* see if dprint added something */
      332 	     head = substr (head, 6);			/* if so get rid of it */
      333 	if head ^= "" then call ioa_$rsnnl ("(for ""^a"" ", msg, l, head);
      334 	else do;
      335 		l = 1;				/* no heading, get ready for a dest msg */
      336 		msg = "(";
      337 	     end;
      338 
      339 	dest = dprint_msg.destination;
      340 	if dest ^= "" then call ioa_$rsnnl ("^vaat ""^a"")", msg, l, (l), substr (msg, 1, l), dest);
      341 	else if l = 1 then msg = "";			/* no head or dest case */
      342 	else substr (msg, l, 1) = ")";		/* heading only case */
      343 
      344 	call iodd_msg_ (log, both, 0, "",		/* let the subr do the work */
      345 	     "Request ^d ^a q^d:  ^a^/^2x^[(^d copies) ^;^s^]^[priority ^d ^;^s^]from ^a ^a",
      346 	     REQUEST.request_no, REQUEST.request_type, REQUEST.queue, full_path, (copies_left > 1), copies_left,
      347 	     REQUEST.priority_request, REQUEST.charge_queue, REQUEST.requestor, msg);
      348 
      349 	err_mess = full_path;			/* let this sit here in case */
      350 
      351 /* Find the access class to use for the banner */
      352 
      353 	if aim_check_$greater (mseg_message_info.sender_authorization, dr_ptr -> driver_status.min_banner) then
      354 	     auth = mseg_message_info.sender_authorization;
      355 	else auth = dr_ptr -> driver_status.min_banner;	/* mark the output with auth */
      356 
      357 	call convert_authorization_$to_string (auth, auth_string, code); /* get string form */
      358 	if code ^= 0 then do;			/* oops....bad news */
      359 		call fatal_error (tell_user);		/* tell the operator, and user */
      360 		go to clean_out;			/* drop the request */
      361 	     end;
      362 
      363 	l = length (rtrim (auth_string));		/* how long is the string */
      364 	if l > 132 then do;				/* when too long for one line */
      365 		call convert_authorization_$from_string (access_class, "system_high", code);
      366 		if code ^= 0 then do;		/* oops....bad news */
      367 			call fatal_error (tell_user); /* tell the operator, and user */
      368 			go to clean_out;		/* drop the request */
      369 		     end;
      370 		if aim_check_$equal (auth, access_class) then auth_string = "SYSTEM HIGH"; /* this is shorter */
      371 	     end;
      372 
      373 	REQUEST.access_class_string = char (auth_string, length (REQUEST.access_class_string));
      374 						/* save all we can for the label */
      375 
      376 /* check the requestor's access to the pathname he specified */
      377 
      378 	val = mseg_message_info.sender_level;
      379 
      380 	call check_user_access (user_dir, ename, code);	/* use the internal proc to do the work */
      381 	if code ^= 0 then do;			/* oops....bad news */
      382 		call fatal_error (tell_user);		/* tell the operator, and user */
      383 		go to clean_out;			/* drop the request */
      384 	     end;
      385 
      386 	call open_file (user_dir, ename, fcbp, max_comp, code); /* one call does a lot */
      387 	if code ^= 0 then do;			/* oops....bad news */
      388 		call fatal_error (tell_user);		/* tell the operator, and user */
      389 		go to clean_out;			/* drop the request */
      390 	     end;
      391 
      392 	on daemon_again begin;			/* to restart the current request.... */
      393 		restart_source = master;		/* talking to the master terminal */
      394 		go to check_reprint_copies;
      395 	     end;
      396 	on daemon_again_slave begin;			/* to restart the current request.... */
      397 		restart_source = slave;		/* talking to slave terminal */
      398 		go to check_reprint_copies;
      399 	     end;
      400 	on daemon_save begin;
      401 		REQUEST.saved = "1"b;
      402 		if ^header_sw then go to clean_out;
      403 		else go to save_request;
      404 	     end;
      405 	on daemon_defer go to defer_request;		/* save it for later */
      406 	on daemon_kill go to flush_request;		/* flush the current request */
      407 	on daemon_cancel go to flush_request;		/* likewise,  the cancelled flag has been set */
      408 
      409 	iodd_static.request_in_progress = "1"b;		/* ready to accept kill, cancel etc. */
      410 						/* now we can restart this request if necessary */
      411 
      412 /* with the true total bitcount, we can make an estimate of the time needed to do the request */
      413 
      414 	if dr_ptr -> driver_status.bit_rate_est > 0 then do;
      415 		total_bits = REQUEST.bit_count * copies_left; /* total is bits per copy times copies */
      416 		time_est = divide (total_bits, dr_ptr -> driver_status.bit_rate_est, 17, 0);
      417 
      418 		if (dr_ptr -> driver_status.defer_time_limit > 0) & /* if a limit is defined, check it */
      419 		     (time_est > dr_ptr -> driver_status.defer_time_limit + 6) then do; /* allow 6 sec fuzz */
      420 						/* so estimate will look bigger than limit in msg */
      421 			if REQUEST.priority_request then /* priority requests go any way */
      422 			     msg = "Defer time limit suspended for priority request.";
      423 			else if REQUEST.restarted then /* can't defer what is not in the queue */
      424 			     msg = "Restarted request exceeds time limit but cannot be deferred.";
      425 			else do;			/* drop this one */
      426 				desc_ptr -> request_descriptor.keep_in_queue = "1"b;
      427 				call iodd_msg_ (log, both, 0, "",
      428 				     "**Deferring request ^d. Time estimate: ^.1f mins.",
      429 				     REQUEST.request_no, float (time_est) / 60.0e0);
      430 				call ioa_$rsnnl ("Deferring request for ^a.^/Time estimate: ^.1f minutes.", msg, l,
      431 				     REQUEST.full_path, float (time_est) / 60.0e0);
      432 				call notify_user (substr (msg, 1, l));
      433 				go to clean_out;
      434 			     end;
      435 		     end;
      436 		else msg = "";
      437 
      438 		if time_est > 60 | msg ^= "" then /* tell operator if request will exceed 1 minute */
      439 		     call iodd_msg_ (log, slave, 0, "",
      440 			"  Time estimate for request ^d:  ^.1f mins.^[^/^2x^a^]",
      441 			REQUEST.request_no, float (time_est) / 60.0e0, (msg ^= ""), msg);
      442 	     end;
      443 
      444 	if REQUEST.copy_no > 1 then call iodd_msg_ (log, both, 0, "",
      445 		"  Starting request ^d at copy ^d of ^d.", REQUEST.request_no, REQUEST.copy_no, REQUEST.copies);
      446 
      447 	go to start_request;			/* begin the output of the request */
      448 
      449 restart_this_request:
      450 
      451 /* 	this is the point where we come to restart the current request */
      452 
      453 	REQUEST.continued = "1"b;			/* make this look like a continuation */
      454 	REQUEST.contd_no = REQUEST.request_no;		/* of this request */
      455 	REQUEST.charge = 0e0;
      456 	REQUEST.time_start_request = clock_ ();
      457 	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);
      458 
      459 start_request:
      460 
      461 	REQUEST.cpu_time = 0;			/* reset the usage data */
      462 	REQUEST.real_time = 0;
      463 	REQUEST.page_waits = 0;
      464 	REQUEST.pre_pages = 0;
      465 	REQUEST.copy_no = print_driver_data.copies_done + 1; /* initialize copy-counter */
      466 
      467 	call iox_$control (iocbp, "get_error_count", addr (last_error_count), code); /* start checking for errors */
      468 	if code ^= 0 then last_error_count = -1;	/* value not defined */
      469 
      470 	call check_labels (user_dir, ename, start_segp, code);
      471 	if code ^= 0 then do;			/* oops....bad news */
      472 		call fatal_error (tell_user);		/* tell the operator, and user */
      473 		go to clean_out;			/* drop the request */
      474 	     end;
      475 
      476 	do while (REQUEST.copies >= REQUEST.copy_no);	/* once around for each copy */
      477 
      478 	     call banner_proc (req_stream, header, addr (REQUEST), code); /* print header banner */
      479 	     if code ^= 0 then do;			/* I/O error trying to print header */
      480 		     call driver_fatal_error (code, "I/O ERROR -- trying to print header.");
      481 		     go to clean_out;		/* abort this request completely */
      482 		end;
      483 
      484 	     REQUEST.separator = "0"b;		/* separator bar was for first banner only */
      485 	     header_sw = "1"b;			/* header was ok, do tail */
      486 	     call iox_$control (iocbp, "runout", null, code); /* be sure head sheet is done before clock reading */
      487 
      488 	     call cpu_time_and_paging_ (old_waits, old_cpu, old_pp); /* keep time and page waits for accounting */
      489 	     old_clock = clock_ ();			/* time copy started */
      490 
      491 	     call output_file (code);			/* this will do it */
      492 	     if code ^= 0 then do;
      493 		     call driver_fatal_error (code, (err_mess));
      494 		     go to clean_out;
      495 		end;
      496 
      497 	     call iox_$control (iocbp, "runout", null, code); /* be sure copy is done before counting it */
      498 
      499 	     if ^desc_ptr -> request_descriptor.saved then /* if leaving this til later, don't charge now */
      500 		if REQUEST.copies > print_driver_data.copies_charged then do;
      501 			chgsw = "1"b;		/* user honestly deserves these charges */
      502 			print_driver_data.copies_charged = print_driver_data.copies_charged + 1;
      503 		     end;
      504 		else chgsw = "0"b;
      505 	     else chgsw = "0"b;
      506 
      507 	     call charge_for_work;			/* do the accounting so we can put price on tail */
      508 
      509 	     if last_error_count = -1 then device_error = ""b; /* no error data */
      510 	     else do;
      511 		     call iox_$control (iocbp, "get_error_count", addr (i), code);
      512 		     if code ^= 0 | i > last_error_count then device_error = "1"b;
      513 		     else device_error = "0"b;	/* we can figure the transfer rate */
      514 		end;
      515 
      516 	     if ^(iodd_static.quit_during_request | device_error) then do; /* can we update the rate estimate? */
      517 		     old_rate = dr_ptr -> driver_status.bit_rate_est; /* get the last value */
      518 		     seconds = divide (REQUEST.real_time, 1000000, 17); /* see how many seconds have passed */
      519 		     if seconds < 1 then new_rate = old_rate; /* avoid divide by zero */
      520 		     else new_rate = divide (REQUEST.bit_count, seconds, 17, 0); /* get bits/sec */
      521 		     if old_rate > 0 then /* use first good rate to start the estimate */
      522 			new_rate = fixed (old_rate * factor + new_rate * (1e0 - factor)); /* use exp smoothing */
      523 		     dr_ptr -> driver_status.bit_rate_est = new_rate; /* put back new value */
      524 		end;
      525 
      526 	     call banner_proc (req_stream, tail, addr (REQUEST), code); /* this will put on the tail banner */
      527 	     if code ^= 0 then do;			/* some type of error..don't do it again */
      528 		     call driver_fatal_error (code, "I/O ERROR -- attempting to write tail banner.");
      529 		     go to clean_out;
      530 		end;
      531 
      532 	     print_driver_data.copies_done = print_driver_data.copies_done + 1;
      533 	     REQUEST.copy_no = REQUEST.copy_no + 1;	/* get ready for next copy */
      534 	     header_sw = "0"b;
      535 	end;					/* done with this copy...check for more in while loop */
      536 
      537 	call iodd_msg_ (log, both, 0, "",
      538 	     "  Charge for request ^d:  $^.2f,  ^[(^d lines,  ^d pages^;(^d cards^s^]^[ per copy)^;)^]",
      539 	     REQUEST.request_no, REQUEST.total_charge, (REQUEST.punsw = 0),
      540 	     REQUEST.line_count, REQUEST.page_count, (copies_left > 1));
      541 
      542 	if REQUEST.notify then do;
      543 		call ioa_$rsnnl ("^aed ^a $^.2f queue ^d ^a ^d", abort_msg, l,
      544 		     pverb, REQUEST.full_path, REQUEST.total_charge,
      545 		     REQUEST.queue, REQUEST.device_name, REQUEST.request_no);
      546 		call notify_user (substr (abort_msg, 1, l));
      547 	     end;
      548 
      549 clean_out:					/* get ready for the next users' request */
      550 
      551 	if last_error_count > -1 then do;		/* if error count is defined */
      552 		call iox_$control (iocbp, "get_error_count", addr (i), code);
      553 		if code ^= 0 | i > last_error_count then /* if errors are possible */
      554 		     if ^desc_ptr -> request_descriptor.dont_delete then do; /* and user not told about it */
      555 			     if REQUEST.delete = 1 then do; /* tell user we cancelled his delete request */
      556 				     desc_ptr -> request_descriptor.dont_delete = "1"b;
      557 				     call ioa_$rsnnl ("Device error during request ^d.  Segment ^a will not be deleted.",
      558 					msg, l, REQUEST.request_no, REQUEST.full_path);
      559 				     call notify_user (substr (msg, 1, l));
      560 				end;
      561 			end;
      562 	     end;
      563 
      564 	call clean_proc;				/* get junk out of the address space */
      565 
      566 	desc_ptr -> request_descriptor.finished = "1"b;	/* mark it as done */
      567 	iodd_static.request_in_progress = "0"b;		/* no more commands can be effective */
      568 	call iox_$control (iocbp, "runout", null, code);	/* make device disgorge */
      569 	return;
      570 
      571 
      572 check_reprint_copies:				/* on restart, we transfer back here to release the */
      573 						/* stack frame with the dim, so the slave can again write */
      574 						/* to the remote device and ask a question */
      575 
      576 	call restart_request (restart_source);		/* this will do the work */
      577 						/* and ask the operator how many copies were good */
      578 
      579 	go to restart_this_request;			/* now go back and restart the request */
      580 
      581 /*  This is where the condition handlers "go to" when something has gone wrong */
      582 
      583 flush_request:					/* kill and cancel handlers jump back here */
      584 
      585 	msg = "Operator aborted output";		/* message for kill and cancel */
      586 	chgsw = "0"b;				/* can't charge */
      587 	go to no_delete;
      588 
      589 abort_request:					/* unclaimed signals transfer to here */
      590 
      591 	chgsw = ""b;				/* assume we can't charge user */
      592 
      593 	msg = """" || rtrim (fault_name) || """ condition occured"; /* format basic message */
      594 
      595 	if fault_name = "seg_fault_error" & /* user deleted seg, charge for what was done */
      596 	     iodd_static.segptr ^= null then do;
      597 		chgsw = "1"b;
      598 		delete_msg = "";			/* forget to tell user we won't delete his seg */
      599 	     end;
      600 	else do;
      601 no_delete:
      602 		if REQUEST.delete ^= 0
      603 		then delete_msg = "; segment will not be deleted";
      604 		else delete_msg = "";
      605 	     end;
      606 
      607 	call ioa_$rsnnl ("^a during processing of ^a request^a.", err_mess, l,
      608 	     msg, pverb, delete_msg);
      609 
      610 	code = 0;
      611 
      612 	call fatal_error (tell_user);			/* this will clean things up a bit */
      613 
      614 	go to clean_out;				/* now drop the request */
      615 
      616 
      617 defer_request:					/* leave this in the queue for a while */
      618 
      619 	err_mess = "Operator deferred request until a later time.";
      620 	chgsw = ""b;
      621 	code = 0;
      622 
      623 	call fatal_error (tell_user);
      624 
      625 	go to clean_out;
      626 
      627 
      628 save_request:
      629 
      630 	err_mess = "Processing suspended by operator.";
      631 	chgsw = "0"b;
      632 	code = 0;
      633 
      634 	call fatal_error (quiet);			/* abort gently */
      635 
      636 	go to clean_out;
      637 
      638 /* ======================================================================================= */
      639 /* ==============================    INTERNAL PROCEDURES    ============================== */
      640 /* ======================================================================================= */
      641 
      642 fatal_error: proc (notify);
      643 
      644 	dcl     notify		 bit (1);
      645 
      646 	save_code = code;				/* hold this for now */
      647 	REQUEST.notify = REQUEST.notify | notify;	/* set notify flag by arg if off */
      648 	desc_ptr -> request_descriptor.dont_delete = "1"b;/* make sure we don't delete user seg */
      649 
      650 	if ^REQUEST.notify & ^header_sw then do;	/* try to tell requestor */
      651 		call banner_proc (req_stream, header, addr (REQUEST), code);
      652 		if code = 0 then header_sw = "1"b;	/* all was well */
      653 	     end;
      654 
      655 	if header_sw then call charge_for_work;		/* update REQUEST data if possible */
      656 
      657 	call error_write (save_code, err_mess);
      658 
      659 	if header_sw then /* if we owe a tail banner, do it */
      660 	     call banner_proc (req_stream, tail, addr (REQUEST), code);
      661 
      662 	call iodd_msg_ (log, both, 0, "",
      663 	     "Processing of request ^d terminated.", REQUEST.request_no);
      664 
      665 	return;					/* let the caller flush the request */
      666 
      667      end fatal_error;
      668 
      669 /* ===================================== */
      670 
      671 error_write: proc (code, message);			/* for writing error messages to console &
      672*						   request stream */
      673 	dcl     code		 fixed bin (35);
      674 	dcl     message		 char (*) varying;
      675 
      676 	short_msg, lg_msg = "";			/* clear any junk */
      677 	if code ^= 0 then call convert_status_code_ (code, short_msg, lg_msg);
      678 
      679 	call ioa_$rsnnl ("Request for ^a. ^a ^a", msg, l, REQUEST.full_path, lg_msg, message);
      680 
      681 	if REQUEST.notify then /* this lets us be quiet about save and defer */
      682 	     call notify_user (substr (msg, 1, l));
      683 
      684 	call iodd_msg_ (log, both, 0, "", "**Request ^d: ^a ^a", REQUEST.request_no, lg_msg, message);
      685 
      686 	if header_sw then do;			/* must not do a "reset" or line and page count is lost */
      687 		call ioa_$rsnnl ("^2/^a^a^/io_daemon: ^a ^a^/^a^a^2/", abort_msg, l, VT,
      688 		     stars, lg_msg, message, stars, VT);
      689 		call banner_proc (req_stream, error_msg, addr (abort_msg), code); /* put out error msg to media */
      690 	     end;
      691 	return;
      692 
      693      end error_write;
      694 
      695 check_labels:
      696      procedure (user_dir, ename, segptr, code);
      697 
      698 /* Internal procedure to check that the top and bottom labels are
      699*   the access class of the segment. */
      700 
      701 	dcl     access_class	 bit (72) aligned;
      702 	dcl     code		 fixed bin (35);
      703 	dcl     ename		 char (*) aligned;
      704 	dcl     level		 fixed bin;
      705 	dcl     user_dir		 char (*) aligned;
      706 	dcl     segptr		 pointer;
      707 	dcl     sys_info$access_class_floor bit (72) aligned external static;
      708 
      709 
      710 	dcl     1 local_audit_user_info aligned like audit_user_info;
      711 	dcl     1 local_audit_eventflags aligned like audit_event_flags;
      712 
      713 	code = 0;
      714 
      715 	if dprint_msg.top_label ^= dprint_msg.bottom_label then do;
      716 LOG_AUDIT_MESSAGE:
      717 		call cu_$level_get (level);
      718 		unspec (local_audit_user_info) = ""b;
      719 		local_audit_user_info.version = audit_user_info_version_1;
      720 		local_audit_user_info.user_id = mseg_message_info.sender_id;
      721 		local_audit_user_info.ring = mseg_message_info.sender_level;
      722 		local_audit_user_info.process_id = mseg_message_info.sender_process_id;
      723 		local_audit_user_info.authorization = mseg_message_info.sender_authorization;
      724 		local_audit_user_info.authorization_range (1) = sys_info$access_class_floor;
      725 		local_audit_user_info.authorization_range (2) = mseg_message_info.sender_max_authorization;
      726 		local_audit_user_info.audit_flags = mseg_message_info.sender_audit;
      727 
      728 		unspec (local_audit_eventflags) = ""b;
      729 		local_audit_eventflags.grant = "1"b;
      730 
      731 		call access_audit_gate_$log_obj_ptr_user ("output_request_",
      732 		     level, unspec (local_audit_eventflags),
      733 		     access_operations_$io_daemon_set_page_labels,
      734 		     segptr, 0, null (), 0, addr (local_audit_user_info));
      735 
      736 		return;
      737 	     end;
      738 
      739 	call hcs_$get_access_class (user_dir, ename, access_class, code);
      740 	if code ^= 0 then return;
      741 
      742 	call convert_authorization_$from_string (authorization, rtrim (dprint_msg.top_label), code);
      743 	if code ^= 0 then do;
      744 		code = 0;
      745 		goto LOG_AUDIT_MESSAGE;		/* This isn't an access class */
      746 	     end;
      747 
      748 	if ^(aim_check_$equal (access_class, authorization)) then goto LOG_AUDIT_MESSAGE;
      749 
      750 	return;
      751      end check_labels;
      752 
      753 notify_user: proc (message);
      754 
      755 	dcl     message		 char (*) aligned;
      756 	dcl     (ipc_ind, r1_ind, ec)	 fixed bin (35);
      757 
      758 	ipc_ind, r1_ind = -1;			/* set to non-zero to test call */
      759 
      760 	if ^sys_priv then go to send_it;		/* if they failed once, .... */
      761 
      762 	on linkage_error begin;
      763 		sys_priv = "0"b;			/* stop trying if we fail */
      764 		go to revert_handler;		/* send the message if possible */
      765 	     end;
      766 
      767 	on any_other begin;
      768 		if r1_ind = 0 then call system_privilege_$ring1_priv_off (r1_ind);
      769 		if ipc_ind = 0 then call system_privilege_$ipc_priv_off (ipc_ind);
      770 		r1_ind, ipc_ind = -1;
      771 		call continue_to_signal_ (ec);
      772 	     end;
      773 
      774 	call system_privilege_$ring1_priv_on (r1_ind);
      775 
      776 	call system_privilege_$ipc_priv_on (ipc_ind);
      777 
      778 revert_handler:
      779 
      780 	revert linkage_error;
      781 
      782 send_it:
      783 
      784 	call send_mail_$access_class (mailname, message, addr (send_mail_info),
      785 	     mseg_message_info.sender_authorization, ec);
      786 
      787 	if r1_ind = 0 then call system_privilege_$ring1_priv_off (r1_ind);
      788 
      789 	if ipc_ind = 0 then call system_privilege_$ipc_priv_off (ipc_ind);
      790 
      791 	return;
      792 
      793      end notify_user;
      794 
      795 charge_for_work: proc;
      796 
      797 /* Accounting section, done at end of processing each copy of output. */
      798 
      799 	counts.line_count = 0;			/* Clear these items so that if the order is unknown.. */
      800 	counts.page_count = 0;			/* .. (like if card dim doesn't do them) we still go */
      801 	counts.line = 0;
      802 	call iox_$control (iocbp, "get_count", orderp, code);
      803 	new_clock = clock_ ();
      804 	call cpu_time_and_paging_ (new_waits, new_cpu, new_pp);
      805 
      806 	if counts.line_count > 0 then
      807 	     REQUEST.line_count = counts.line_count;
      808 	else REQUEST.line_count = divide (REQUEST.bit_count + 699, 700, 24, 0); /* Use block count
      809*						   if dim returns zero line count */
      810 	if counts.line = 1 then REQUEST.page_count = counts.page_count - 1; /* if ending with a FF */
      811 	else REQUEST.page_count = counts.page_count;
      812 	REQUEST.cpu_time = new_cpu - old_cpu;
      813 	REQUEST.real_time = new_clock - old_clock;
      814 	REQUEST.page_waits = fixed (new_waits - old_waits, 35);
      815 	REQUEST.pre_pages = fixed (new_pp - old_pp, 35);
      816 
      817 	if chgsw then do;
      818 		if dr_ptr -> driver_status.have_accounting then do;
      819 			call io_daemon_account_ (dr_ptr -> driver_status.acct_entry, addr (REQUEST));
      820 		     end;
      821 		else do;
      822 			REQUEST.price_per_n_lines,	/* zap all charges to zero */
      823 			     REQUEST.price_per_n_pages,
      824 			     REQUEST.charge = 0e0;
      825 			REQUEST.no_accounting = "1"b; /* and flag it */
      826 		     end;
      827 	     end;
      828 	else REQUEST.charge = 0e0;			/* reset any undefined values */
      829 
      830 	REQUEST.total_charge = REQUEST.total_charge + REQUEST.charge;
      831 
      832 	return;
      833 
      834      end charge_for_work;
      835 
      836 check_user_access: proc (user_dir, ename, ec);
      837 
      838 /* Internal procedure to check that the requestor has at least "r" access to
      839*   the specified segment */
      840 
      841 	dcl     user_dir		 char (*) aligned;
      842 	dcl     ename		 char (*) aligned;
      843 	dcl     code		 fixed bin (35);
      844 	dcl     ec		 fixed bin (35);
      845 	dcl     mode		 fixed bin (5);
      846 	dcl     access_class	 bit (72) aligned;
      847 
      848 	call hcs_$get_user_effmode (user_dir, ename, REQUEST.requestor, val, mode, code);
      849 	if code ^= 0 then do;
      850 		if code = error_table_$noentry then err_mess = ""; /* simple case, just say no entry */
      851 		else err_mess = "Unable to get user's mode.";
      852 		ec = code;
      853 		return;
      854 	     end;
      855 
      856 	if (bit (mode, 5) & "01000"b) = "0"b then do;
      857 		err_mess = "User does not have read access.";
      858 		ec = error_table_$moderr;
      859 		return;
      860 	     end;
      861 
      862 	call hcs_$get_access_class (user_dir, ename, access_class, code);
      863 	if code ^= 0 then do;
      864 		err_mess = "Unable to get access class of segment.";
      865 		ec = code;
      866 		return;
      867 	     end;
      868 
      869 	if ^read_allowed_ (mseg_message_info.sender_authorization, access_class) then do;
      870 		ec = error_table_$ai_restricted;
      871 		err_mess = "User not allowed to read segment.";
      872 		return;
      873 	     end;
      874 
      875 	ec = 0;					/* ok, user passed the checks */
      876 
      877 	return;
      878 
      879      end check_user_access;
      880 
      881 open_file: proc (user_dir, ename, fcbp, max_comp, code);
      882 
      883 	dcl     user_dir		 char (*) aligned;
      884 	dcl     ename		 char (*) aligned;
      885 	dcl     fcbp		 ptr;
      886 	dcl     max_comp		 fixed bin;
      887 	dcl     code		 fixed bin (35);
      888 
      889 	dcl     comp_dir		 char (168) aligned;
      890 	dcl     comp_name		 char (32) aligned;
      891 	dcl     type		 fixed bin (2);
      892 	dcl     dir		 fixed bin int static options (constant) init (2);
      893 	dcl     dir_len		 fixed bin;
      894 	dcl     bc		 fixed bin (24);
      895 	dcl     mode		 fixed bin (5);
      896 	dcl     mult_ind		 fixed bin;
      897 
      898 	REQUEST.bit_count = 0;
      899 
      900 	call hcs_$status_minf (user_dir, ename, 1, type, bc, code); /* see what kind of a thing it is */
      901 	if code ^= 0 then do;
      902 		err_mess = char ("Driver cannot get status of file: " || full_path, length (err_mess));
      903 		return;
      904 	     end;
      905 
      906 	if type = dir then /* directory */
      907 	     if bc < 1 then do;			/* it was a directory */
      908 		     code = error_table_$dirseg;
      909 		     return;
      910 		end;
      911 	     else max_comp = bc - 1;			/* MSF - highest component is bitcount less one */
      912 	else max_comp = 0;				/* SSF - highest component is 0 */
      913 
      914 	call msf_manager_$open (user_dir, ename, fcbp, code);
      915 	if code ^= 0 then do;
      916 		err_mess = "Unable to open file: " || full_path;
      917 		return;
      918 	     end;
      919 
      920 	do mult_ind = 0 to max_comp;			/* now we look at each component */
      921 
      922 	     call msf_manager_$get_ptr (fcbp, mult_ind, "0"b, segp, bc, code);
      923 	     if code ^= 0 then do;			/* we failed, don't try to do partial files */
      924 		     call ioa_$rsnnl ("Unable to get pointer to file component: ^d.", err_mess, dir_len, mult_ind);
      925 		     return;
      926 		end;
      927 
      928 	     if mult_ind = 0 then start_segp = segp;	/* this is a pointer to the first component */
      929 
      930 /*		we got a pointer to something...where is it */
      931 /*		and does the requestor have access to it? */
      932 
      933 	     call hcs_$fs_get_path_name (segp, comp_dir, dir_len, comp_name, code);
      934 	     if code ^= 0 then do;
      935 		     err_mess = "Could not get file component pathname.";
      936 		     return;
      937 		end;
      938 
      939 	     call check_user_access (comp_dir, comp_name, code);
      940 	     if code ^= 0 then do;			/* he tried to pull a fast one and got caught */
      941 		     err_mess = err_mess || "  " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
      942 						/* most of err_mess was set by check_user_access */
      943 		     return;
      944 		end;
      945 
      946 	     if bc < el_size then do;			/* must be at least one element per component */
      947 		     code = error_table_$improper_data_format; /* choose a good error message */
      948 		     err_mess = "Zero length segment: " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
      949 		     return;
      950 		end;
      951 
      952 	     REQUEST.bit_count = REQUEST.bit_count + bc;	/* total the bits for accounting */
      953 
      954 	     call hcs_$fs_get_mode (segp, mode, code);	/*  make sure daemon has access  */
      955 	     if code ^= 0 then do;
      956 		     err_mess = "Driver process does not have access to segment.";
      957 		     return;
      958 		end;
      959 
      960 	     if (bit (mode, 5) & "01000"b) = "0"b then do;
      961 		     err_mess = "Driver process does not have read access to segment.";
      962 		     code = error_table_$moderr;	/* give some access violation code */
      963 		     return;
      964 		end;
      965 	end;
      966 
      967 
      968 /* Now we know that the file is there and that the requestor has the correct access to it.
      969*   The continued operation of the driver now assumes that the file will remain the same
      970*   until the driver is done.  That is, the access will not change, the number of components will not
      971*   change, and the size of each component will not change.  */
      972 
      973 
      974      end open_file;
      975 
      976 output_file: proc (ec);
      977 
      978 	dcl     ec		 fixed bin (35);	/* you guessed it, error code */
      979 
      980 	dcl     bc		 fixed bin (24);
      981 	dcl     comp_no		 fixed bin;	/* current msf component number */
      982 	dcl     max_el		 fixed bin (24);
      983 
      984 
      985 	ec = 0;					/* clear the error code */
      986 
      987 	segp = null;				/* don't try to deactivate */
      988 	comp_no = 0;				/* start at the begining of msf */
      989 	oldmodes = "";
      990 	if REQUEST.line_nbrs then do;
      991 		call iox_$modes (iocbp, "line_nbrs", oldmodes, code);
      992 		if code ^= 0 then do;
      993 			err_mess = "Setting line_nbrs mode";
      994 			return;
      995 		     end;
      996 	     end;
      997 
      998 next_comp:					/* done with last component */
      999 
     1000 	if segp ^= null & privileged then
     1001 	     call phcs_$deactivate (segp, (0));		/* so try to deactivate the seg */
     1002 
     1003 	call msf_manager_$get_ptr (fcbp, comp_no, "0"b, segp, bc, ec); /* get ptr to seg */
     1004 	if segp = null then do;
     1005 		err_mess = "Invalid seg ptr to component.";
     1006 		return;
     1007 	     end;
     1008 
     1009 	if privileged then /* .. do it (gently if possible) */
     1010 	     call phcs_$set_kst_attributes (binary (baseno (segp), 18), addr (ksta), (0));
     1011 
     1012 	iodd_static.segptr = segp;			/* tell signal handler what segment we are using */
     1013 	max_el = divide (bc + el_size - 1, el_size, 24, 0); /* see now many elements to write out */
     1014 
     1015 	call iox_$put_chars (iocbp, segp, max_el, ec);	/* This is the actual output of segment */
     1016 	iodd_static.segptr = null;			/* not referencing user seg now */
     1017 	if ec ^= 0 then do;
     1018 		err_mess = "IO error during output of file.";
     1019 		return;
     1020 	     end;
     1021 
     1022 	if comp_no < max_comp then do;		/* are we at real end of file */
     1023 		comp_no = comp_no + 1;		/* go on to the next component */
     1024 		go to next_comp;			/* deactivate old and get new */
     1025 	     end;
     1026 
     1027 	if REQUEST.line_nbrs then
     1028 	     if oldmodes ^= "" then call iox_$modes (iocbp, oldmodes, "", (0));
     1029 	if privileged & (REQUEST.copies = REQUEST.copy_no | max_comp > 0) then
     1030 	     call phcs_$deactivate (segp, (0));		/* try to deactivate */
     1031 	segp = null;
     1032 
     1033 	return;
     1034 
     1035      end output_file;
     1036 
     1037 
     1038 driver_fatal_error: proc (code, err_msg);
     1039 
     1040 /* Internal procedure to print messages when there is an IO error on the output stream */
     1041 
     1042 	dcl     code		 fixed bin (35);
     1043 	dcl     err_msg		 char (*);
     1044 
     1045 	call iodd_msg_ (error, both, code, id,
     1046 	     "^a ^/Driver returning to command level.  Request is deferred.", err_msg);
     1047 
     1048 	desc_ptr -> request_descriptor.dont_delete = "1"b;/* give a reprieve....in case */
     1049 	desc_ptr -> request_descriptor.keep_in_queue = "1"b; /* defer it if possible */
     1050 
     1051 	a_code = code;				/* report driver_fatal_error */
     1052 
     1053 	return;
     1054 
     1055      end driver_fatal_error;
     1056 
     1057 restart_request: proc (source);
     1058 
     1059 /* internal procedure used to question operator regarding the restart of current request */
     1060 
     1061 	dcl     source		 fixed bin;
     1062 
     1063 	dcl     answer		 char (120);
     1064 	dcl     cnt_msg		 char (24);	/* space to specify a continued request */
     1065 	dcl     copies_good		 fixed bin (35);	/* operator response to number of good copies */
     1066 	dcl     nelt		 fixed bin;
     1067 	dcl     input_iocbp		 ptr;
     1068 	dcl     output_stream	 char (32);
     1069 	dcl     code		 fixed bin (35);
     1070 	dcl     pg_count_msg	 char (30);	/* space to specify pages per copy */
     1071 	dcl     restrt_msg		 char (30);	/* space that the request is to be restarted */
     1072 
     1073 
     1074 /* set up input/output stream for the master terminal */
     1075 
     1076 	if source = master then do;
     1077 		input_iocbp = iodd_static.master_in;
     1078 		output_stream = iodd_static.master_output;
     1079 	     end;
     1080 
     1081 /* set up input/output stream for the slave terminal */
     1082 
     1083 	else do;
     1084 		source = slave;			/* just to be sure */
     1085 		input_iocbp = iodd_static.slave.slave_in;
     1086 		output_stream = iodd_static.slave.slave_output;
     1087 	     end;
     1088 
     1089 
     1090 /* is there a need to query the operator? */
     1091 
     1092 	if REQUEST.punsw = 1 | print_driver_data.copies_done = 0 | REQUEST.copies = 1 then do;
     1093 
     1094 		restrt_msg = "";
     1095 		REQUEST.separator = "1"b;
     1096 		print_driver_data.copies_done = 0;
     1097 
     1098 	     end;
     1099 
     1100 	else do;					/* must query operator */
     1101 
     1102 		if REQUEST.page_count > 0 then /* is there a non zero page count? */
     1103 		     call ioa_$rsnnl (" (^d pages each)", pg_count_msg, nret, REQUEST.page_count);
     1104 		else pg_count_msg = "";
     1105 
     1106 		if REQUEST.continued then /* is this a continued request? */
     1107 		     cnt_msg = " (continued request)";
     1108 		else cnt_msg = "";
     1109 
     1110 ask_how_many_good:					/* tell operator how many were done */
     1111 		call ioa_$ioa_stream (output_stream, "^d of ^d copies^a were done^a.  How many were good?",
     1112 		     print_driver_data.copies_done, REQUEST.copies, pg_count_msg, cnt_msg);
     1113 						/* now let's see what the operator tells us */
     1114 		answer = "";			/* first make the answer all blank */
     1115 		call iox_$get_line (input_iocbp, addr (answer), 10, nelt, code);
     1116 		if code ^= 0 then do;
     1117 			copies_good = 0;
     1118 			go to tell_operator;
     1119 		     end;
     1120 
     1121 		answer = ltrim (rtrim (answer, NL || " ")); /* remove leading spaces and NL chars */
     1122 
     1123 		copies_good = cv_dec_check_ (answer, code);
     1124 
     1125 		if code ^= 0 then do;		/* was the answer a number? */
     1126 bad_no:			call ioa_$ioa_stream (output_stream, "Please specify a number between 0 and ^d",
     1127 			     print_driver_data.copies_done);
     1128 			go to ask_how_many_good;
     1129 		     end;
     1130 
     1131 		if copies_good < 0 | copies_good > print_driver_data.copies_done then go to bad_no;
     1132 
     1133 tell_operator:	print_driver_data.copies_done = copies_good; /* update the record of finished copies */
     1134 
     1135 		if copies_good = 0 then REQUEST.separator = "1"b;
     1136 
     1137 		call ioa_$rsnnl (" from copy number ^d", restrt_msg, nret, copies_good + 1);
     1138 
     1139 	     end;
     1140 
     1141 	call ioa_$ioa_stream (output_stream, "Restarting request^a.", restrt_msg);
     1142 
     1143 	return;
     1144 
     1145      end restart_request;
     1146 
     1147 
     1148 clean_proc: proc;
     1149 
     1150 	iodd_static.segptr = null;			/* tell signal handler we are done with it */
     1151 
     1152 	if fcbp ^= null then do;
     1153 		if segp ^= null then
     1154 		     if privileged then call phcs_$deactivate (segp, (0));
     1155 		call msf_manager_$close (fcbp);
     1156 	     end;
     1157 
     1158 	segp, fcbp = null;				/* because this is used for several functions */
     1159 
     1160 	return;
     1161 
     1162      end clean_proc;
     1163 
     1164 
     1165 
     1166 error_during_request: entry (cond);			/* for coming back after signal */
     1167 
     1168 	dcl     cond		 char (*);
     1169 
     1170 	fault_name = cond;
     1171 
     1172 	go to err_label;
     1173 
     1174 
     1175 
     1176 set_single_copy: entry;
     1177 
     1178 /*  to abort multiple copies if the single command must be used */
     1179 
     1180 	request_data_p -> ordata.copies = 1;		/* make it fall out of the loop after tail sheet */
     1181 
     1182 	return;
     1183  /* begin include file - access_audit_eventflags.incl.pl1 */
  1     2 /* NOTE: This include file has an ALM counterpart made with cif.
  1     3*Keep it up to date. */
  1     4 
  1     5 dcl 1 audit_event_flags	based aligned,
  1     6       2 special_op	bit (1) unal,  /* special sys operation */
  1     7       2 grant	bit (1) unal,  /* operation was successful */
  1     8       2 admin_op	bit (1) unal,  /* administrative operation */
  1     9       2 priv_op	bit (1) unal,  /* privileged operation */
  1    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  1    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  1    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  1    13       2 pad	bit (29) unal;
  1    14 
  1    15 /* end include file - access_audit_eventflags.incl.pl1 */
     1183 
     1184  /* begin include file - access_audit_user_info.incl.pl1 */
  2     2 
  2     3 /* 85-01-21 EJ Sharpe - changed (min max)_auth to auth range */
  2     4 /* 85-01-07 EJ Sharpe - added min_authorization */
  2     5 /* 84-10-09 EJ Sharpe - created */
  2     6 
  2     7 /* The structure defined here is passed to the access_audit_
  2     8*entrypoints which deal with proxy users:
  2     9**/
  2    10 
  2    11 dcl audit_user_info_ptr	pointer;
  2    12 
  2    13 dcl 1 audit_user_info  based (audit_user_info_ptr) aligned,
  2    14       2 version		char (8),
  2    15       2 user_id		char (32),
  2    16       2 ring		fixed bin (3) uns unal,
  2    17       2 pad		bit (33) unal,
  2    18       2 process_id		bit (36) aligned,
  2    19       2 authorization	bit (72) aligned,
  2    20       2 authorization_range	(2) bit (72) aligned,
  2    21       2 audit_flags		bit (36) aligned;
  2    22 
  2    23 dcl audit_user_info_version_1	char (8) init ("adtusrv1")
  2    24 	internal static options (constant);
  2    25 
  2    26 /* end include file - access_audit_user_info.incl.pl1 */
     1184 
     1185  /* BEGIN INCLUDE FILE ... dprint_msg.incl.pl1 */
  3     2 /* Modified: November 1983 by C. Marker Added no_separator. */
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  3     6*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  3     7*     Add line_nbrs bit for line-numbered printouts, version 4.
  3     8*  2) change(88-02-05,Farley), approve(88-02-05,PBF7686), audit(88-02-05,GWMay),
  3     9*     install(88-02-05,MR12.2-1022):
  3    10*     Corrected alignment of line_nbrs, was aligned s/b unaligned..
  3    11*  3) change(88-08-23,Farley), approve(88-09-16,MCR7911),
  3    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  3    13*     Increased size of forms field to 64 characters (was only 24), which
  3    14*     updates the version to 5.
  3    15*                                                   END HISTORY COMMENTS */
  3    16 
  3    17 
  3    18 dcl  dmp ptr;					/* ptr to message */
  3    19 
  3    20 dcl 1 dprint_msg based (dmp) aligned,			/* structure of a IO daemon print or punch request */
  3    21     2 header like queue_msg_hdr,			/* header for all standard queue messages */
  3    22     2 version fixed bin,				/* version of the dprint_msg used */
  3    23     2 copies fixed bin,				/* number of copies user requested */
  3    24     2 bit_count fixed bin (35),			/* the bitcount of the segment at request time */
  3    25     2 output_module fixed bin,			/* 1=print, 2=7punch, 3= mcc, 4=raw */
  3    26     2 control,					/* control flags. */
  3    27       3 nep bit (1) unal,				/* TRUE if printing over perforations */
  3    28       3 single bit (1) unal,				/* TRUE if ignore FF and VT */
  3    29       3 non_edited bit (1) unal,			/* TRUE if printing in non-edited mode */
  3    30       3 truncate bit (1) unal,			/* TRUE if truncating lines at line length */
  3    31       3 esc bit (1) unal,				/* TRUE if text escapes are to be processed */
  3    32       3 center_top_label bit (1) unal,			/* TRUE if top label to be centered */
  3    33       3 center_bottom_label bit (1) unal,		/* TRUE if bottom label to be centered */
  3    34       3 no_separator bit(1) unal,                           /* TRUE if the inner head a tail sheets of multiple copies are to be suppressed. */
  3    35       3 line_nbrs bit (1) unal,			/* TRUE if line numbers wanted */
  3    36       3 padding bit (27) unal,
  3    37     2 lmargin fixed bin,				/* indent from the left */
  3    38     2 line_lth fixed bin,				/* logical line length */
  3    39     2 page_lth fixed bin,				/* logical page length */
  3    40     2 heading_lth fixed bin,				/* number of chars in heading */
  3    41     2 top_label_lth fixed bin,			/* number of chars in the top label */
  3    42     2 bottom_label_lth fixed bin,			/* number of chars in bottom label */
  3    43     2 chan_stop_path_lth fixed bin,			/* number of chars in channel stop pathname */
  3    44     2 forms_name_lth fixed bin,			/* number of chars in forms name */
  3    45     2 future_fb_values (7) fixed bin,			/* make future versions possible */
  3    46     2 forms char (24),				/* name of special forms, or blank */
  3    47     2 destination char (24),				/* routing for output */
  3    48     2 heading char (head_max_lth refer (dprint_msg.heading_lth)), /* heading on page 1 */
  3    49     2 top_label char (label_max_lth refer (dprint_msg.top_label_lth)), /* top page heading for each page */
  3    50     2 bottom_label char (label_max_lth refer (dprint_msg.bottom_label_lth)), /* bottom page heading */
  3    51     2 chan_stop_path char (path_max_lth refer (dprint_msg.chan_stop_path_lth)), /* path of rqti seg with channel stops */
  3    52     2 forms_name char (forms_max_lth refer (dprint_msg.forms_name_lth)); /* forms name string */
  3    53 
  3    54 
  3    55 dcl  (
  3    56      head_max_lth init (64),				/* allocation size for heading */
  3    57      label_max_lth init (136),			/* allocation size for label fields */
  3    58      path_max_lth init (168),				/* allocation size for pathname fields */
  3    59      forms_max_lth init (64)				/* allocation size for forms name string */
  3    60      ) fixed bin int static options (constant);
  3    61 
  3    62 dcl  (
  3    63      dprint_msg_version_3 init (3),
  3    64      dprint_msg_version_4 init (4),
  3    65      dprint_msg_version_5 init (5)			/* current version */
  3    66      ) fixed bin int static options (constant);
  3    67 
  3    68 /* END INCLUDE FILE ... dprint_msg.incl.pl1 */
     1185 
     1186  /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  4     7*     Ancient History
  4     8*     Coded by Robert S. Coren August 1973
  4     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  4    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  4    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  4    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  4    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  4    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  4    16*     to denote accounting ^= nothing.
  4    17*                                                   END HISTORY COMMENTS */
  4    18 
  4    19 
  4    20 /* status data for a logical device driver */
  4    21 
  4    22 /* format: style4 */
  4    23 
  4    24 dcl  driver_status_ptr ptr;
  4    25 dcl  1 driver_status aligned based (driver_status_ptr),
  4    26        2 req_type_label char (32),			/* string to describe the request type */
  4    27        2 dev_name_label char (32),			/* string to describe the device */
  4    28        2 device_id char (32),				/* minor device name used by this logical driver */
  4    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  4    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  4    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  4    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  4    33        2 request_pending bit (36),			/* locking word for communication with coord */
  4    34 						/* 0 = ready for a request  */
  4    35 						/* driver pid = don't bug me */
  4    36 						/* coord  pid = got a request */
  4    37        2 status_flags,
  4    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  4    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  4    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  4    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  4    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  4    43          3 pad bit (31) unal,
  4    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  4    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  4    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  4    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  4    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  4    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  4    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  4    51 						/* for this logical driver */
  4    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  4    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  4    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  4    55        2 dev_out_stream char (32),			/* output stream for minor device */
  4    56        2 dev_in_stream char (32),			/* input stream for minor device */
  4    57        2 elem_size fixed bin,				/* element size for the stream */
  4    58        2 message_type fixed bin,			/* expected format of user request */
  4    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  4    60        2 forms_validation_ptr ptr,			/* forms validation data */
  4    61        2 dev_ptr1 ptr,				/* another one */
  4    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  4    63        2 dev_fb2 fixed bin,				/* and another */
  4    64        2 dev_fb3 fixed bin,				/* and another */
  4    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  4    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  4    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  4    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  4    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  4    70        2 generic_type char (32),			/* generic type of this minor device */
  4    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  4    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  4    73        2 desc_pad (13) fixed bin,
  4    74        2 message fixed bin;				/* place-holder for copy of request message */
  4    75 
  4    76 
  4    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
     1186 
     1187  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Created by J. Stern, 1/20/75
  5     9*     Modified by J. C. Whitmore April 1978 for enhancements
  5    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  5    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  5    12*     q_group_tab
  5    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  5    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    15*     Change version number to reflect changes in q_group_tab and
  5    16*     iod_device_tab for laser printer support.  Added font tables.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 /* format: style4 */
  5    21 
  5    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  5    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  5    24        2 version char (8),				/* version of this structure */
  5    25        2 date_time_compiled fixed bin (71),
  5    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  5    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  5    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  5    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  5    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  5    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  5    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  5    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  5    34        2 text_strings_offset fixed bin (18),
  5    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  5    36 
  5    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  5    38 dcl  text_strings_ptr ptr;
  5    39 dcl  1 text_strings aligned based (text_strings_ptr),
  5    40        2 length fixed bin,
  5    41        2 chars char (1 refer (text_strings.length)) unaligned;
  5    42 
  5    43 /* this defines text offsets used to locate i/o daemon tables strings in
  5    44*   the text_strings structure */
  5    45 dcl  1 text_offset based,
  5    46        2 first_char fixed bin (18) unsigned unaligned,
  5    47        2 total_chars fixed bin (18) unsigned unaligned;
  5    48 
  5    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  5    50 
  5    51 
  5    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
     1187 
     1188  /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  6     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  6     7*     Add support for logout_on_hangup option.
  6     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    10*     Add head/tail_sheet entry variables and paper_type variable.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 /* format: style4 */
  6    14 
  6    15 dcl  stat_p int static ptr;
  6    16 
  6    17 dcl  1 iodd_static based (stat_p) aligned,
  6    18 
  6    19 /*    The first part is set only once for a device driver */
  6    20 
  6    21        2 ithp ptr,					/* pointer to iod tables header */
  6    22        2 ltp ptr,					/* pointer to line table */
  6    23        2 idtp ptr,					/* pointer to device tab */
  6    24        2 mdtp ptr,					/* pointer to minor device table */
  6    25        2 qgtp ptr,					/* pointer to q_group table */
  6    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  6    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  6    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  6    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  6    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  6    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  6    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  6    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  6    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  6    35        2 log_stream char (32),			/* stream name used for log output */
  6    36        2 master_input char (32),			/* master console input stream for commands */
  6    37        2 master_output char (32),			/* master console output stream for messages */
  6    38        2 master_out ptr,				/* master output iocbp */
  6    39        2 master_in ptr,				/* master input iocbp */
  6    40        2 log_iocbp ptr,				/* log output iocbp */
  6    41        2 error_io ptr,				/* error i/o iocbp */
  6    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  6    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  6    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  6    45        2 device_dim char (32),			/* dim which drives the major device */
  6    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  6    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  6    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  6    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  6    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  6    51        2 major_device char (32),			/* name of the major device */
  6    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  6    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  6    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  6    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  6    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  6    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  6    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  6    59 
  6    60 /*    driver module entrypoints are defined by the following entry variables */
  6    61 
  6    62        2 driver_init entry variable options (variable),
  6    63        2 driver_request entry variable options (variable),
  6    64        2 driver_command entry variable options (variable),
  6    65        2 driver_default_handler entry variable options (variable),
  6    66 
  6    67 /*    entrypoints for head/tail_sheet_ entries */
  6    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  6    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  6    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  6    71 
  6    72        2 paper_type fixed bin,			/* type of paper being used */
  6    73 						/* 1 = single sheet */
  6    74 						/* 2 = continuous forms */
  6    75 
  6    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  6    77 
  6    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  6    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  6    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  6    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  6    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  6    83        2 output_device char (32),			/* name of minor device currently in use */
  6    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  6    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  6    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  6    87        2 segptr ptr,				/* ptr to current user segment being processed */
  6    88        2 flags,					/* control flags */
  6    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  6    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  6    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  6    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  6    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  6    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  6    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  6    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  6    97          3 step bit (1) unal,				/* run in step mode */
  6    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  6    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  6   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  6   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  6   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  6   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  6   104          3 pad bit (21) unal,				/* unused space */
  6   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  6   106          3 slave_input char (32),			/* slave input stream name */
  6   107          3 slave_output char (32),			/* slave output stream name */
  6   108          3 slave_pad fixed bin,			/* allocation breakage */
  6   109          3 slave_in ptr,				/* slave input iocbp */
  6   110          3 slave_out ptr,				/* slave output iocbp */
  6   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  6   112          3 active bit (1) unal,			/* on if there is a slave */
  6   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  6   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  6   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  6   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  6   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  6   118          3 priv2 bit (1) unal,
  6   119          3 priv3 bit (1) unal,
  6   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  6   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  6   122        2 ctl_term,					/* control terminal data */
  6   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  6   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  6   125          3 ctl_pad fixed bin,				/* allocation breakage */
  6   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  6   127          3 ctl_input char (32),			/* ctl input stream name */
  6   128          3 ctl_output char (32),			/* ctl output stream name */
  6   129          3 ctl_io char (32),				/* ctl i/o stream name */
  6   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  6   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  6   132          3 ctl_device char (32),			/* ctl terminal device name */
  6   133          3 form_type char (16),			/* format type if printing forms */
  6   134          3 attached bit (1) unal,			/* ctl term attached to process */
  6   135          3 forms bit (1) unal,			/* on if printing forms */
  6   136          3 pad bit (34) unal,
  6   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  6   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  6   139 
  6   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
     1188 
     1189  /* BEGIN INCLUDE FILE  kst_attributes.incl.pl1 WRITTEN 03/26/76  by  R. Bratt */
  7     2 
  7     3 dcl  kstap ptr;
  7     4 
  7     5 dcl 1 kst_attributes aligned based (kstap),
  7     6     2 set unaligned,				/* SPECIFIES WHICH ATTRIBUTES TO SET */
  7     7       3 (allow_write,
  7     8      tms,
  7     9      tus,
  7    10      tpd,
  7    11      audit,
  7    12      explicit_deactivate_ok) bit (1),
  7    13       3 pad bit (39),
  7    14     2 value unaligned,				/* SPECIFIES THE VALUE OF THE ATTRIBUTES TO BE SET */
  7    15       3 (allow_write,				/* allow write permission in sdw */
  7    16      tms,						/* don't update dtm */
  7    17      tus,						/* don't update dtu */
  7    18      tpd,						/* don't put on PD */
  7    19      audit,					/* audit */
  7    20      explicit_deactivate_ok) bit (1),			/* allow demand deactivation */
  7    21       3 pad bit (30);
  7    22 
  7    23 /* END INCLUDE FILE kst_attributes.incl.pl1                      */
     1189 
     1190  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  8     2 /* format: style3,idind30 */
  8     3 
  8     4 /* structure returned when message is read from a message segment */
  8     5 
  8     6 
  8     7 dcl	mseg_message_info_ptr	pointer;
  8     8 
  8     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  8    10 	  2 version		char (8) aligned,
  8    11 	  2 message_code		fixed bin,
  8    12 	  2 control_flags		unaligned,
  8    13 	    3 own			bit (1),
  8    14 	    3 delete		bit (1),
  8    15 	    3 pad			bit (34),
  8    16 	  2 ms_ptr		ptr,		/* pointer to message */
  8    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  8    18 	  2 ms_id			bit (72),		/* unique ID of message */
  8    19 						/* input in some cases */
  8    20 	  2 ms_access_class		bit (72),		/* message access class */
  8    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  8    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  8    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  8    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  8    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  8    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  8    27 
  8    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  8    29 
  8    30 declare	(
  8    31 	MSEG_READ_FIRST		init (1),
  8    32 	MSEG_READ_LAST		init (2),
  8    33 	MSEG_READ_SPECIFIED		init (3),
  8    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  8    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  8    36 	fixed bin int static options (constant);
  8    37 
  8    38 declare  (MSEG_READ_OWN		init ("1"b),
  8    39 	MSEG_READ_DELETE		init ("01"b)
  8    40 	)			bit (36) aligned internal static options (constant);
  8    41 
  8    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     1190 
     1191  /* BEGIN INCLUDE FILE ... output_request_data.incl.pl1 */
  9     2 
  9     3 /* Modified by R. McDonald May 1980 to include page charges (UNCA) */
  9     4 /* Modified by C. Marker October 1983 added no_separator */
  9     5 
  9     6 
  9     7 /****^  HISTORY COMMENTS:
  9     8*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  9     9*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  9    10*     Add the line_nbrs bit for line-numbered output.
  9    11*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  9    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  9    13*     Added single_sheet bit to denote if continuous paper.
  9    14*                                                   END HISTORY COMMENTS */
  9    15 
  9    16 
  9    17      dcl	   1 ordata	      based (ordatap) aligned,
  9    18 	     2 dpmp	      ptr,		/* Ptr to dprint_msg */
  9    19 	     2 requestor	      char (32),		/* Person.Proj.tag requesting */
  9    20 	     2 full_path	      char (168),		/* source of the output */
  9    21 	     2 queue	      fixed bin,		/* Queue requested. */
  9    22 	     2 copies	      fixed bin,		/* Copies requested. */
  9    23 	     2 copy_no	      fixed bin,		/* Number this copy */
  9    24 	     2 request_no	      fixed bin (35),	/* Number request assigned by coord */
  9    25 	     2 restart_no	      fixed bin (35),	/* old number of restarted request (0 = not restarted) */
  9    26 	     2 request_type	      char (32),		/* Name of device class wanted. */
  9    27 	     2 access_class_string char (280),		/* Access class - size limit for two printer lines */
  9    28 	     2 punsw	      fixed bin,		/* 0 = print, 1= punch */
  9    29 	     2 delete	      fixed bin,		/* 1= delete, 0= don't */
  9    30 	     2 device_name	      char (32),		/* Name of physical device used */
  9    31 	     2 output_mode	      char (128),		/* user's mode string for ios_$changemode */
  9    32 	     2 time_start_request fixed bin (71),	/* Clock time when picked request */
  9    33 	     2 date_time_start_request char (24),	/* .. in chars too */
  9    34 	     2 line_count	      fixed bin (24),	/* Line count returned by DIM */
  9    35 	     2 page_count	      fixed bin,		/* Page count returned by DIM */
  9    36 	     2 cpu_time	      fixed bin (71),	/* Total CPU usage while printing */
  9    37 	     2 real_time	      fixed bin (71),	/* Total realtime while printing */
  9    38 	     2 page_waits	      fixed bin,		/* Total page-waits while printing */
  9    39 	     2 pre_pages	      fixed bin,		/* Total pre-pages (???) .. */
  9    40 	     2 bit_count	      fixed bin (24),	/* Number of bits transmitted. */
  9    41 	     2 charge	      float bin,		/* What the thing cost. */
  9    42 	     2 control_flags,
  9    43 	       3 continued	      bit (1) unal,		/* request started by one driver and given to another */
  9    44 	       3 restarted	      bit (1) unal,		/* request is restarted */
  9    45 	       3 separator	      bit (1) unal,		/* used to determine necessity of a separator page  */
  9    46 	       3 notify	      bit (1) unal,		/* if should confirm to user */
  9    47 	       3 saved	      bit (1) unal,		/* request was suspended by operator, we'll save it */
  9    48 	       3 priority_request bit (1) unal,		/* operator said run now!! */
  9    49 	       3 no_separator     bit (1) unal,		/* suppress inner head and tail sheets when printing multiple copies */
  9    50 	       3 line_nbrs	      bit (1) unal,		/* if line-numbered output requested */
  9    51 	       3 single_sheet     bit (1) unal,		/* ON if single_sheet output */
  9    52 	       3 padding	      bit (27) unal,	/* not used */
  9    53 	     2 contd_no	      fixed bin (35),	/* old number of continued request (0 = not continued) */
  9    54 	     2 total_charge	      float bin,		/* total charge for all copies */
  9    55 	     2 price_per_n_lines  float bin,		/* line price rate used to compute charge */
  9    56 	     2 n_lines_for_price  fixed bin,		/* number of lines price is based on */
  9    57 	     2 charge_queue	      fixed bin,		/* base charge rate on this queue */
  9    58 	     2 price_per_n_pages  float bin,		/* page charge rate used to compute charge */
  9    59 	     2 n_pages_for_price  fixed bin,		/* number of pages price is based on */
  9    60 	     2 rs_number	      fixed bin (9) unsigned unaligned, /* rate_structure number used */
  9    61 	     2 rs_unavailable     bit (1) unaligned,	/* 1=>couldn't read SAT */
  9    62 	     2 no_accounting      bit (1) unaligned,	/* 1=>accounting:nothing in iod_tables */
  9    63 	     2 pad_bits	      bit (25) unaligned,
  9    64 	     2 line_nbr	      fixed bin (35),	/* current line number */
  9    65 	     2 pad_space	      (6) fixed bin (35);	/* save some room to grow */
  9    66 
  9    67      dcl	   ordatap	      ptr;		/* Ptr to above structure */
  9    68 
  9    69      dcl	   1 REQUEST	      like ordata aligned;	/* If wanted, a place to put the above thing */
  9    70 
  9    71 /* END INCLUDE FILE ... output_request_data.incl.pl1 */
     1191 
     1192  /* BEGIN INCLUDE FILE ... print_driver_data.incl.pl1 */
 10     2 
 10     3 
 10     4 dcl  driver_data_p ptr;
 10     5 
 10     6 /* the following structure must not be more than  252 bits (7 words) long, since it is the definition
 10     7*   of the driver data field in the request_descriptor.incl.pl1 */
 10     8 
 10     9 dcl 1 print_driver_data aligned based (driver_data_p),	/* defines driver data of request_descriptor */
 10    10     2 copies_done fixed bin (17) unal,			/* number of copies already printed */
 10    11     2 copies_charged fixed bin (17) unal,		/* number of copies already charged */
 10    12     2 pad fixed bin (35),				/* the only spare room */
 10    13     2 checkpoint,					/* the latest valid print checkpoint */
 10    14       3 comp_no fixed bin (17),			/* MSF component at top of page_no */
 10    15       3 offset fixed bin (24),			/* last character before top of page_no */
 10    16       3 page_no fixed bin (24),			/* next physical page to be printed */
 10    17       3 line_count fixed bin (24),			/* number of lines printed at this point */
 10    18       3 file_offset fixed bin (33);			/* characters from the start of the file */
 10    19 
 10    20 /* END INCLUDE FILE ... print_driver_data.incl.pl1 */
     1192 
     1193  
 11     2 /* BEGIN INCLUDE FILE ... prt_conv_info.incl.pl1 */
 11     3 /* Modified: 12 September 1980 by G. Palter */
 11     4 
 11     5 
 11     6 /****^  HISTORY COMMENTS:
 11     7*  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
 11     8*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
 11     9*     Add modes.line_nbrs, flags.(eol eof)  bits for eor -nb.
 11    10*                                                   END HISTORY COMMENTS */
 11    11 
 11    12 
 11    13 dcl  pcip ptr;					/* pointer to conversion info structure */
 11    14 
 11    15 dcl 1 pci based (pcip) aligned,			/* printer conversion info structure */
 11    16     2 cv_proc ptr,					/* pointer to character conversion procedure */
 11    17     2 lmarg fixed bin,				/* left margin indentation */
 11    18     2 rmarg fixed bin,				/* right margin limit */
 11    19     2 page_length fixed bin,				/* number of lines on page */
 11    20     2 phys_line_length fixed bin,			/* physical width of paper */
 11    21     2 phys_page_length fixed bin,			/* physical length of paper */
 11    22     2 lpi fixed bin,				/* lines per inch */
 11    23     2 sheets_per_page fixed bin,			/* sheets of paper per logical page */
 11    24     2 line_count fixed bin,				/* count of converted lines */
 11    25     2 page_count fixed bin,				/* count of converted pages */
 11    26     2 func fixed bin,				/* special conversion function */
 11    27 						/* 0 => normal conversion */
 11    28 						/* 1 => change NL to FF */
 11    29 						/* 2 => change NL to top inside page */
 11    30 						/* 3 => change NL to end of page */
 11    31                                                             /* 4 => change NL to top of outside page */
 11    32     (2 modes,					/* conversion modes */
 11    33      3 overflow_off bit (1),				/* "1"b to suppress end of page overflow */
 11    34       3 single_space bit (1),				/* "1"b to change all forms advance chars to NL */
 11    35       3 non_edited bit (1),				/* "1"b to print ASCII control chars */
 11    36       3 truncate bit (1),				/* "1"b to truncate lines that are too long */
 11    37       3 esc bit (1),				/* "1"b to process ESC character */
 11    38       3 ctl_char bit (1),				/* "1"b to output control characters */
 11    39       3 line_nbrs bit (1),				/* "1"b to output line numbers */
 11    40       3 pci_pad bit (5),
 11    41     2 flags,					/* flags internal to prt_conv_ */
 11    42       3 ignore_next_ff bit (1),			/* ON => prt_conv_ just output a FF; ignore next character if
 11    43*						   it's a FF */
 11    44       3 eol bit (1),				/* "1"b = end-of-line encountered */
 11    45       3 eof bit (1),				/* "1"b = end-of-segment encountered */
 11    46       3 flags_pad bit (3),
 11    47     2 coroutine_modes,
 11    48       3 upper_case bit(1),				/* "1"b to convert to upper case */
 11    49       3 ht bit(1),					/* "1"b to skip tab conversion */
 11    50       3 coroutine_pad bit(13),
 11    51       3 slew_table_idx bit(3) ) unal,			/* slew table index */
 11    52     2 top_label_line char (136),			/* contains an optional top of page label */
 11    53     2 bot_label_line char (136),			/* contains an optional bottom of page label */
 11    54     2 top_label_length fixed bin,			/* length of top label line */
 11    55     2 bot_label_length fixed bin,			/* length of bottom label line */
 11    56     2 form_stops (256) unal,				/* logical form stops */
 11    57       3 lbits bit (9),				/* leftmost bits */
 11    58       3 rbits bit (9),				/* rightmost bits */
 11    59 
 11    60 /* The following items are for internal use by the print conversion procedure.
 11    61*   They should be zeroed once and then never referenced again.		*/
 11    62 
 11    63     2 level fixed bin,				/* overstrike level */
 11    64     2 pos fixed bin,				/* print position at end of incomplete line */
 11    65     2 line fixed bin,				/* current line number */
 11    66     2 slew_residue fixed bin,				/* number of lines remaining to be slewed */
 11    67     2 label_nelem fixed bin,				/* characters remaining in label */
 11    68     2 label_wksp ptr,				/* pointer to label being processed */
 11    69     2 sav_pos fixed bin,				/* position saved during label processing */
 11    70     2 esc_state fixed bin,				/* state of ESC processing */
 11    71     2 esc_num fixed bin,				/* number following ESC sequence */
 11    72     2 temp bit (36);				/* conversion proc temporary */
 11    73 
 11    74 /* End of include file ...... prt_conv_info.incl.pl1 */
 11    75 
     1193 
     1194  
 12     2 /* Begin include file ...... prt_info.incl.pl1 */
 12     3 /* last modified 6/12/75 by Noel I. Morris	*/
 12     4 
 12     5 dcl  pip ptr;					/* pointer to printer info structure */
 12     6 
 12     7 dcl 1 prt_info based (pip) aligned,			/* printer info structure */
 12     8     2 devname char (4),				/* name of device */
 12     9     2 devx fixed bin,				/* device index */
 12    10     2 model fixed bin,				/* printer model number */
 12    11     2 type fixed bin,				/* printer type number */
 12    12     2 train fixed bin,				/* print train ID */
 12    13     2 line_length fixed bin,				/* max length of printed line */
 12    14     2 print_idcw bit (36),				/* IDCW to print 1 line */
 12    15     2 term_idcw bit (36);				/* IDCW to stop printer channel */
 12    16 
 12    17 /* End of include file ...... prt_info.incl.pl1 */
 12    18 
     1194 
     1195  /* Begin include file ...... prt_order_info.incl.pl1 */
 13     2 /*	Created 3/15/77 by Noel I. Morris	*/
 13     3 
 13     4 dcl  orderp ptr;					/* pointer to order info structure */
 13     5 
 13     6 dcl 1 counts based (orderp) aligned,			/* structure used in "get_count"  order */
 13     7     2 line fixed bin,				/* line number */
 13     8     2 page_length fixed bin,				/* length of page */
 13     9     2 lmarg fixed bin,				/* left margin indentation */
 13    10     2 rmarg fixed bin,				/* line length */
 13    11     2 line_count fixed bin,				/* count of lines printed */
 13    12     2 page_count fixed bin;				/* count of pages printed */
 13    13 
 13    14 dcl 1 position_data based (orderp) aligned,		/* structure for "get_position" & "set_position" orders */
 13    15     2 line_number fixed bin (35),			/* current line on the page */
 13    16     2 page_number fixed bin (35),			/* current page number */
 13    17     2 total_lines fixed bin (35),			/* lines printed since reset */
 13    18     2 total_chars fixed bin (35),			/* chars processed since reset */
 13    19     2 pad(4) fixed bin;				/* for the future */
 13    20 
 13    21 dcl 1 page_labels based (orderp) aligned,		/* structure used in "page_labels" order */
 13    22     2 top_label char (136),				/* label for top of page */
 13    23     2 bottom_label char (136);			/* label for bottom of page */
 13    24 
 13    25 dcl  channel_stops (256) bit (16) based (orderp) unal;	/* structure used in "channel_stops" order */
 13    26 
 13    27 dcl 1 paper_info based (orderp) aligned,		/* structure used in "paper_info" order */
 13    28     2 phys_page_length fixed bin,			/* physical page length */
 13    29     2 phys_line_length fixed bin,			/* physical line length */
 13    30     2 lines_per_inch fixed bin;			/* lines per inch spacing */
 13    31 
 13    32 dcl  ret_error_count fixed bin based (orderp);		/* variable used for "get_error_count" order */
 13    33 
 13    34 /* End of include file ...... prt_order_info.incl.pl1 */
     1195 
     1196  /* BEGIN INCLUDE FILE ... prt_sdb.incl.pl1 */
 14     2 /* Note: there is a corresponding prt_sdb.incl.alm */
 14     3 
 14     4 /* Created 10/28/74 by Noel I. Morris	*/
 14     5 /* Modified 3/15/77 by Noel I. Morris	*/
 14     6 /* Modified 1/25/78 by J. C. Whitmore to merge prtdim and spooling_dim versions */
 14     7 /* Modified: 27 November 1981 by G. Palter to add reload_vfc_train_after_special flag */
 14     8 /* Modified: 16 August 1983 by E. N. Kittlitz for new printer dim */
 14     9 
 14    10 dcl  sdb_ptr ptr;					/* pointer to stream data block */
 14    11 
 14    12 dcl 1 sdb aligned based (sdb_ptr),			/* printer stream data block */
 14    13     2 outer_module_name char (32) aligned,
 14    14     2 device_name_list_ptr pointer,
 14    15     2 device_name,
 14    16       3 next_device_ptr pointer,
 14    17       3 name_size fixed bin (17),
 14    18       3 name char (32) aligned,
 14    19     2 ev_list aligned,				/* Event list for ipc_ */
 14    20       3 count fixed bin (17),				/* Event count = Always one */
 14    21       3 evchan fixed bin (71),			/* Event channel name */
 14    22     2 stream_name char (32),				/* stream name of this attachment */
 14    23     2 areap ptr,					/* pointer to system free area */
 14    24     2 info like prt_info aligned,			/* printer info */
 14    25     2 conv_info like pci aligned,			/* conversion info */
 14    26     2 chars_printed fixed bin (35),			/* input chars processed since "reset" */
 14    27     2 stop_every fixed bin,				/* non-zero to stop after number of pages */
 14    28     2 stop_counter fixed bin,				/* page stop counter */
 14    29     2 mode,					/* additional modes */
 14    30      (3 single_page bit (1),				/* "1"b to stop after each page */
 14    31       3 noprint bit (1),				/* "1"b to suppress printing */
 14    32       3 pad bit (34)) unal,
 14    33     2 rcp_id bit (36),				/* RCP attachment ID */
 14    34     2 wsegp ptr,					/* pointer to IOI working segment */
 14    35     2 running bit (1),				/* "1"b if channel running */
 14    36     2 bgin fixed bin (18),				/* index to oldest print line */
 14    37     2 stop fixed bin (18),				/* index to next print line */
 14    38     2 prev fixed bin (18),				/* index to previous print line */
 14    39     2 wait_flag bit (1) aligned,			/* non-zero if waiting for special */
 14    40     2 marker_count fixed bin,				/* counter for marker status insertion */
 14    41     2 paper_low bit (1) aligned,			/* "1"b if paper low */
 14    42     2 error_count fixed bin,				/* error counter */
 14    43     2 buffer_ptr ptr,				/* pointer to output buffer (spooler) */
 14    44     2 spool_info (56) fixed bin,			/* place to store spooling_info */
 14    45     2 reload_vfc_train_after_special bit (1) aligned,	/* "1"b if VFC/train images should be reloaded after next
 14    46*						   special interrupt */
 14    47     2 max_dcw_size fixed bin (12) uns unal,		/* max wordcount of dcw */
 14    48     2 max_dcws fixed bin (6) uns unal,			/* max dcws per idcw/buffer */
 14    49     2 n_dcws fixed bin (6) uns unal,			/* current limit of dcws/buffer */
 14    50     2 b_begin fixed bin (3) uns unal,			/* buffer index */
 14    51     2 b_stop fixed bin (3) uns unal,			/* likewise */
 14    52     2 max_buffers fixed bin (3) uns unal,		/* number of buffers allocated */
 14    53     2 n_buffers fixed bin (3) uns unal,			/* number of buffers in use now */
 14    54     2 data_begin fixed bin (18) uns unal,		/* first data word */
 14    55     2 data_end fixed bin (18) uns unal,			/* size of working space in words */
 14    56     2 status_ptr ptr unal,				/* ioi status area */
 14    57     2 flags aligned,
 14    58       3 aborting bit (1) unal,			/* next attempt to do i/o gets error and resets */
 14    59       3 eurc bit (1) unal,				/* true if we know we are using EURC */
 14    60       3 flags_pad bit (16) unal,
 14    61     2 version fixed bin unal,      
 14    62     2 status_table ptr unal,				/* for analyze_device_stat_ */
 14    63     2 null_line_data bit (36) aligned,
 14    64     2 null_line_dcw bit (36) aligned,
 14    65     2 alarm_time fixed bin (71) unaligned;		/* current timer_manager_ limit */
 14    66 dcl  prt_bufferp ptr;
 14    67 
 14    68 dcl 1 prt_buffer aligned based (prt_bufferp),
 14    69     2 header,
 14    70       3 number fixed bin (6) uns unal,
 14    71       3 busy bit (1) unal,
 14    72       3 pad bit (4) unal,
 14    73       3 dcw_count fixed bin (7) uns unal,
 14    74       3 data_ends fixed bin (18) uns unal,
 14    75     2 idcw bit (36),
 14    76     2 ddcw (sdb.max_dcws + 1) bit (36) aligned;
 14    77 
 14    78 dcl  wseg (0:sdb.data_end - 1) bit (36) aligned based (sdb.wsegp);	/* the IOI buffer segment */
 14    79 dcl 1 prt_buffers (0:sdb.max_buffers - 1) aligned like prt_buffer based (sdb.wsegp);
 14    80 
 14    81 /* NOTE:	The Spooling_dim IO Module also uses this include file,
 14    82*	as it uses the printer stream also. If changes are made to this include file,
 14    83*	see to it that the changes are also reflected in the Spooling_dim procedures.
 14    84*	The spooling_dim uses the standard printer_dim order and changemode procedures.
 14    85*	JCW 1/25/78  */
 14    86 
 14    87 /* END INCLUDE FILE ... prt_sdb.incl.pl1 */
     1196 
     1197  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
 15     2 
 15     3 /* This is the message header used for standard system queue messages, namely:
 15     4*   IO daemon requests, absentee requests, retrieval requests.
 15     5**/
 15     6 
 15     7 /* Written by Jerry Whitmore, Spring 1978.
 15     8*   Modified by T. Casey, November 1978, to add values for state.
 15     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
 15    10**/
 15    11 
 15    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
 15    13     2 msg_time fixed bin (71),			/* date and time of request */
 15    14     2 hdr_version fixed bin,				/* version of this declaration */
 15    15     2 dirname char (168),				/* directory name */
 15    16     2 ename char (32),				/* entry name of file requested */
 15    17     2 message_type fixed bin,				/* message format descriptor   */
 15    18 						/* 0 = absentee request        */
 15    19 						/* 1 = print request           */
 15    20 						/* 2 = punch request           */
 15    21 						/* 3 = tape request            */
 15    22 						/* 4 = retrieval request       */
 15    23     2 bit_flags,
 15    24       3 delete_sw bit (1) unal,			/* delete file when done */
 15    25       3 notify bit (1) unal,				/* user wants to be notified */
 15    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
 15    27       3 padding bit (33) unal,
 15    28     2 state fixed bin,				/* stage of processing after being queued:
 15    29*						   0 = initial unprocessed state, 1 = deferred,
 15    30*						   2 = in state transition, 3 = eligible, 4 = running,
 15    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
 15    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
 15    33     2 std_length fixed bin,				/* length of std msg for this type */
 15    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
 15    35     2 hdr_pad (3) fixed bin;
 15    36 
 15    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
 15    38 
 15    39 /* Values for queue_msg_hdr.state */
 15    40 
 15    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
 15    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
 15    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
 15    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
 15    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
 15    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
 15    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
 15    48 
 15    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
     1197 
     1198  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 16     2 
 16     3 /* Descriptor associated with an I/O daemon request */
 16     4 /* Coded August 1973 by Robert S. Coren */
 16     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 16     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 16     7 
 16     8 dcl  1 request_descriptor based aligned,
 16     9 	2 mseg_message_info_copy like mseg_message_info,
 16    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 16    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 16    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 16    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 16    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 16    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 16    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 16    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 16    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 16    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 16    20 	2 driver_data bit(252),	/* driver maintained data */
 16    21 	2 flags,
 16    22 	   (3 continued,		/* unfinished by one driver and given to another */
 16    23 	    3 finished,
 16    24 	    3 restarted,
 16    25 	    3 cancelled,
 16    26 	    3 dont_delete,
 16    27 	    3 saved,		/* not to be freed */
 16    28 	    3 keep_in_queue,	/* keep request in queue */
 16    29 	    3 series_restart,	/* this request is part of restarted series */
 16    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 16    31 	    3 pad bit(27) unal,
 16    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 16    33 
 16    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
     1198 
     1199  /*  BEGIN  send_mail_info include file */
 17     2 
 17     3 dcl send_mail_info_version_2 fixed bin init(2);
 17     4 
 17     5 dcl 1 send_mail_info aligned,
 17     6      2 version fixed bin,  /* = 2 */
 17     7      2 sent_from char(32) aligned,
 17     8      2 switches,
 17     9       3 wakeup bit(1) unal,
 17    10       3 mbz1 bit(1) unal,
 17    11       3 always_add bit(1) unal,
 17    12       3 never_add bit(1) unal,
 17    13       3 notify bit(1) unal,
 17    14       3 acknowledge bit(1) unal,
 17    15       3 mbz bit(30) unal;
 17    16 
 17    17 /*  END  send_mail_info include file */
     1199 
     1200 
     1201      end output_request_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1229.6  output_request_.pl1               >special_ldd>install>MR12.2-1199>output_request_.pl1
1183         1    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
1184         2    02/12/85  1429.5  access_audit_user_info.incl.pl1   >ldd>include>access_audit_user_info.incl.pl1
1185         3    10/28/88  1227.6  dprint_msg.incl.pl1               >special_ldd>install>MR12.2-1199>dprint_msg.incl.pl1
1186         4    10/28/88  1226.9  driver_status.incl.pl1            >special_ldd>install>MR12.2-1199>driver_status.incl.pl1
1187         5    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
1188         6    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
1189         7    04/29/76  1104.2  kst_attributes.incl.pl1           >ldd>include>kst_attributes.incl.pl1
1190         8    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
1191         9    10/28/88  1226.4  output_request_data.incl.pl1      >special_ldd>install>MR12.2-1199>output_request_data.incl.pl1
1192        10    09/28/78  1359.8  print_driver_data.incl.pl1        >ldd>include>print_driver_data.incl.pl1
1193        11    02/04/88  2009.3  prt_conv_info.incl.pl1            >ldd>include>prt_conv_info.incl.pl1
1194        12    08/29/75  1310.5  prt_info.incl.pl1                 >ldd>include>prt_info.incl.pl1
1195        13    09/28/78  1359.8  prt_order_info.incl.pl1           >ldd>include>prt_order_info.incl.pl1
1196        14    11/04/83  1107.6  prt_sdb.incl.pl1                  >ldd>include>prt_sdb.incl.pl1
1197        15    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
1198        16    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
1199        17    04/27/78  1504.4  send_mail_info.incl.pl1           >ldd>include>send_mail_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FF                                     constant        char(1)                  initial packed unaligned dcl 136 ref 223
NL                                     constant        char(1)                  initial packed unaligned dcl 132 ref 223 1121
REQUEST                         001366 automatic       structure                level 1 dcl 9-69 set ref 244 478 478 526 526 651 651
                                                                                  659 659 819 819
TAB                                    constant        char(1)                  initial packed unaligned dcl 134 ref 223
VT                              000002 constant        char(1)                  initial packed unaligned dcl 135 set ref 223 687*
                                                                                  687*
a_banner_proc                          parameter       entry variable           dcl 47 ref 13 215
a_code                                 parameter       fixed bin(35,0)          dcl 48 set ref 13 221* 1051*
a_element_size                         parameter       fixed bin(17,0)          dcl 45 ref 13 220
a_stat_p                               parameter       pointer                  dcl 46 ref 13 213
a_stream_name                          parameter       char                     packed unaligned dcl 44 ref 13 219
abort_msg                       000100 automatic       varying char(256)        dcl 52 set ref 543* 546 546 687* 689 689
access_audit_gate_$log_obj_ptr_user
                                000056 constant        entry                    external dcl 151 ref 731
access_class                    002024 automatic       bit(72)                  dcl 846 in procedure "check_user_access" set ref
                                                                                  862* 869*
access_class                    001756 automatic       bit(72)                  dcl 701 in procedure "check_labels" set ref 739*
                                                                                  748*
access_class                    000202 automatic       bit(72)                  dcl 53 in procedure "output_request_" set ref 365*
                                                                                  370*
access_class_string     101     001366 automatic       char(280)                level 2 dcl 9-69 set ref 373* 373
access_operations_$io_daemon_set_page_labels
                                000042 external static bit(36)                  dcl 140 set ref 731*
acct_entry               60            based           entry variable           level 2 dcl 4-25 set ref 819*
addr                                                   builtin function         dcl 200 ref 229 229 241 243 244 245 246 467 467 478
                                                                                  478 511 511 526 526 552 552 651 651 659 659 689
                                                                                  689 731 731 782 782 819 819 1009 1009 1115 1115
aim_check_$equal                000060 constant        entry                    external dcl 152 ref 370 748
aim_check_$greater              000062 constant        entry                    external dcl 153 ref 353
allow_write                     000035 internal static bit(1)                   level 3 packed packed unaligned dcl 192 set ref 233*
always_add               11(02) 001721 automatic       bit(1)                   level 3 packed packed unaligned dcl 17-5 set ref
                                                                                  313*
answer                          002144 automatic       char(120)                packed unaligned dcl 1063 set ref 1114* 1115 1115
                                                                                  1121* 1121 1123*
any_other                       000000 stack reference condition                dcl 206 ref 767
audit_event_flags                      based           structure                level 1 dcl 1-5
audit_flags              22     001761 automatic       bit(36)                  level 2 dcl 710 set ref 726*
audit_user_info                        based           structure                level 1 dcl 2-13
audit_user_info_version_1       000000 constant        char(8)                  initial packed unaligned dcl 2-23 ref 719
auth                            000204 automatic       bit(72)                  dcl 54 set ref 353* 355* 357* 370*
auth_string                     000206 automatic       char(680)                packed unaligned dcl 55 set ref 357* 363 370* 373
authorization            14     001761 automatic       bit(72)                  level 2 dcl 710 set ref 723* 742* 748*
authorization_range      16     001761 automatic       bit(72)                  array level 2 dcl 710 set ref 724* 725*
bad_chars                       000010 internal static char(4)                  packed unaligned dcl 106 set ref 223* 322 323 324
                                                                                  325
banner_proc                     000460 automatic       entry variable           dcl 56 set ref 215* 478 526 651 659 689
baseno                                                 builtin function         dcl 201 ref 229 229 1009 1009
bc                              002132 automatic       fixed bin(24,0)          dcl 980 in procedure "output_file" set ref 1003*
                                                                                  1013
bc                              002120 automatic       fixed bin(24,0)          dcl 894 in procedure "open_file" set ref 900* 906
                                                                                  911 922* 946 952
binary                                                 builtin function         dcl 201 ref 229 229 1009 1009
bit                                                    builtin function         dcl 200 ref 856 960
bit_count               302     001366 automatic       fixed bin(24,0)          level 2 dcl 9-69 set ref 279* 415 520 808 898* 952*
                                                                                  952
bit_flags                66            based           structure                level 3 dcl 3-20
bit_rate_est            132            based           fixed bin(35,0)          level 2 dcl 4-25 set ref 414 416 517 523*
both                            000101 constant        fixed bin(17,0)          initial dcl 117 set ref 344* 427* 444* 537* 662*
                                                                                  684* 1045*
bottom_label                           based           char                     level 2 dcl 3-20 ref 715
bottom_label_lth        110            based           fixed bin(17,0)          level 2 dcl 3-20 ref 715
char                                                   builtin function         dcl 201 ref 373 902
charge                  303     001366 automatic       float bin(27)            level 2 dcl 9-69 set ref 295* 455* 822* 828* 830
charge_q                 37(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 16-8 ref 270
charge_queue            311     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 270* 344*
chgsw                           000464 automatic       bit(1)                   dcl 57 set ref 217* 501* 504* 505* 586* 589* 597*
                                                                                  620* 631* 817
cleanup                         001302 stack reference condition                dcl 206 ref 255
clock_                          000064 constant        entry                    external dcl 154 ref 296 456 489 803
cnt_msg                         002202 automatic       char(24)                 packed unaligned dcl 1064 set ref 1106* 1108* 1110*
code                            000465 automatic       fixed bin(35,0)          dcl 58 in procedure "output_request_" set ref 249*
                                                                                  250 251* 357* 358 365* 366 380* 381 386* 387 467*
                                                                                  468 470* 471 478* 479 480* 486* 491* 492 493* 497*
                                                                                  511* 512 526* 527 528* 552* 553 568* 610* 621*
                                                                                  632* 646 651* 652 659* 802* 991* 992
code                                   parameter       fixed bin(35,0)          dcl 673 in procedure "error_write" set ref 671 677
                                                                                  677* 689*
code                            002022 automatic       fixed bin(35,0)          dcl 843 in procedure "check_user_access" set ref
                                                                                  848* 849 850 852 862* 863 865
code                            002224 automatic       fixed bin(35,0)          dcl 1069 in procedure "restart_request" set ref
                                                                                  1115* 1116 1123* 1125
code                                   parameter       fixed bin(35,0)          dcl 887 in procedure "open_file" set ref 881 900*
                                                                                  901 908* 914* 915 922* 923 933* 934 939* 940 947*
                                                                                  954* 955 962*
code                                   parameter       fixed bin(35,0)          dcl 1042 in procedure "driver_fatal_error" set ref
                                                                                  1038 1045* 1051
code                                   parameter       fixed bin(35,0)          dcl 702 in procedure "check_labels" set ref 695 713*
                                                                                  739* 740 742* 743 744*
comp_dir                        002034 automatic       char(168)                dcl 889 set ref 933* 939* 941 948
comp_name                       002106 automatic       char(32)                 dcl 890 set ref 933* 939* 941 948
comp_no                         002133 automatic       fixed bin(17,0)          dcl 981 set ref 988* 1003* 1022 1023* 1023
cond                                   parameter       char                     packed unaligned dcl 1168 ref 1166 1170
contd_no                305     001366 automatic       fixed bin(35,0)          level 2 dcl 9-69 set ref 274* 454*
contd_seq_id             34            based           fixed bin(35,0)          level 2 dcl 16-8 ref 274
continue_to_signal_             000066 constant        entry                    external dcl 155 ref 771
continued               304     001366 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 9-69 in procedure "output_request_"
                                                                                  set ref 263* 284 287* 449* 1106
continued                53            based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 16-8 in procedure
                                                                                  "output_request_" ref 263
control                 102            based           structure                level 2 dcl 3-20
control_flags           304     001366 automatic       structure                level 2 dcl 9-69 set ref 261*
convert_authorization_$from_string
                                000070 constant        entry                    external dcl 156 ref 365 742
convert_authorization_$to_string
                                000072 constant        entry                    external dcl 157 ref 357
convert_status_code_            000074 constant        entry                    external dcl 158 ref 677
copies                   77            based           fixed bin(17,0)          level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "output_request_" ref 283
copies                   65     001366 automatic       fixed bin(17,0)          level 2 in structure "REQUEST" dcl 9-69 in procedure
                                                                                  "output_request_" set ref 283* 288 290 444* 476
                                                                                  499 1029 1092 1110*
copies                   65            based           fixed bin(17,0)          level 2 in structure "ordata" dcl 9-17 in procedure
                                                                                  "output_request_" set ref 1180*
copies_charged            0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 10-9 set ref 499
                                                                                  502* 502
copies_done                            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 10-9 set ref
                                                                                  284* 287 288* 288 290 291 465 532* 532 1092 1096*
                                                                                  1110* 1126* 1131 1133*
copies_good                     002210 automatic       fixed bin(35,0)          dcl 1065 set ref 1117* 1123* 1131 1131 1133 1135
                                                                                  1137
copies_left                     000466 automatic       fixed bin(17,0)          dcl 59 set ref 290* 344 344* 415 537
copy_no                  66     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 291* 444 444* 465* 476 533*
                                                                                  533 1029
counts                                 based           structure                level 1 dcl 13-6
counts_data                     001273 automatic       structure                level 1 dcl 194 set ref 246
cpu_time                274     001366 automatic       fixed bin(71,0)          level 2 dcl 9-69 set ref 459* 812*
cpu_time_and_paging_            000076 constant        entry                    external dcl 159 ref 488 804
cu_$level_get                   000100 constant        entry                    external dcl 160 ref 716
cv_dec_check_                   000102 constant        entry                    external dcl 161 ref 1123
daemon_again                    001316 stack reference condition                dcl 206 ref 392
daemon_again_slave              001324 stack reference condition                dcl 206 ref 396
daemon_cancel                   001354 stack reference condition                dcl 206 ref 407
daemon_defer                    001346 stack reference condition                dcl 206 ref 405
daemon_kill                     001332 stack reference condition                dcl 206 ref 406
daemon_save                     001340 stack reference condition                dcl 206 ref 400
date_time_                      000104 constant        entry                    external dcl 162 ref 297 457
date_time_start_request
                        264     001366 automatic       char(24)                 level 2 dcl 9-69 set ref 297* 457*
defer_time_limit        133            based           fixed bin(35,0)          level 2 dcl 4-25 ref 418 418
delete                  210     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 277* 278* 555 601
delete_msg                      000467 automatic       char(32)                 packed unaligned dcl 60 set ref 598* 601* 604* 607*
delete_sw                66            based           bit(1)                   level 4 packed packed unaligned dcl 3-20 ref 277
desc_ptr                        000500 automatic       pointer                  dcl 61 set ref 241* 242 245 263 264 265 269 270 271
                                                                                  272 274 426 499 553 556 566 648 1048 1049
descriptor              146            based           structure                level 2 dcl 4-25 set ref 241
dest                            000502 automatic       char(24)                 dcl 62 set ref 339* 340 340*
destination             130            based           char(24)                 level 2 dcl 3-20 set ref 324* 324 339
dev_name_label           10            based           char(32)                 level 2 dcl 4-25 ref 267
device_error                    000510 automatic       bit(1)                   packed unaligned dcl 63 set ref 509* 512* 513* 516
device_name             211     001366 automatic       char(32)                 level 2 dcl 9-69 set ref 267* 543*
dir                                    constant        fixed bin(17,0)          initial dcl 892 ref 906
dir_len                         002117 automatic       fixed bin(17,0)          dcl 893 set ref 924* 933* 941 948
dirname                   3            based           char(168)                level 3 dcl 3-20 ref 318
divide                                                 builtin function         dcl 200 ref 416 518 520 808 1013
dmp                             001362 automatic       pointer                  dcl 3-18 set ref 243* 276 277 282 283 292 299 318
                                                                                  319 324 324 325 325 330 339 715 715 742 742
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 16-8 set ref 553
                                                                                  556* 648* 1048*
dpmp                            001366 automatic       pointer                  level 2 dcl 9-69 set ref 276*
dprint_msg                             based           structure                level 1 dcl 3-20
dr_ptr                          000512 automatic       pointer                  dcl 64 set ref 240* 241 243 267 268 353 355 414 416
                                                                                  418 418 517 523 818 819
driver_data              44            based           bit(252)                 level 2 dcl 16-8 set ref 245
driver_data_p                   001712 automatic       pointer                  dcl 10-4 set ref 245* 284 287 288 288 290 291 465
                                                                                  499 502 502 532 532 1092 1096 1110 1126 1131 1133
driver_ptr              304            based           pointer                  level 2 dcl 6-17 ref 240
driver_status                          based           structure                level 1 dcl 4-25
ec                                     parameter       fixed bin(35,0)          dcl 978 in procedure "output_file" set ref 976 985*
                                                                                  1003* 1015* 1017
ec                              000102 automatic       fixed bin(35,0)          dcl 756 in procedure "notify_user" set ref 771* 782*
ec                                     parameter       fixed bin(35,0)          dcl 844 in procedure "check_user_access" set ref 836
                                                                                  852* 858* 865* 870* 875*
el_size                         000514 automatic       fixed bin(17,0)          dcl 65 set ref 220* 946 1013 1013
ename                                  parameter       char                     dcl 842 in procedure "check_user_access" set ref 836
                                                                                  848* 862*
ename                    55            based           char(32)                 level 3 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "output_request_" ref 319
ename                                  parameter       char                     dcl 703 in procedure "check_labels" set ref 695 739*
ename                                  parameter       char                     dcl 884 in procedure "open_file" set ref 881 900*
                                                                                  914*
ename                           000515 automatic       char(32)                 dcl 66 in procedure "output_request_" set ref 319*
                                                                                  320* 380* 386* 470*
err_label                       000012 internal static label variable           dcl 107 set ref 257* 1172
err_mess                        000525 automatic       varying char(200)        dcl 67 set ref 349* 493 607* 617* 628* 657* 850*
                                                                                  851* 857* 864* 871* 902* 902 916* 924* 935* 941*
                                                                                  941 948* 956* 961* 993* 1005* 1018*
err_msg                                parameter       char                     packed unaligned dcl 1043 set ref 1038 1045*
error                           000110 constant        fixed bin(17,0)          initial dcl 118 set ref 1045*
error_msg                       000106 constant        fixed bin(17,0)          initial dcl 119 set ref 689*
error_table_$ai_restricted      000054 external static fixed bin(35,0)          dcl 146 ref 870
error_table_$dirseg             000052 external static fixed bin(35,0)          dcl 145 ref 908
error_table_$improper_data_format
                                000044 external static fixed bin(35,0)          dcl 142 ref 947
error_table_$moderr             000050 external static fixed bin(35,0)          dcl 144 ref 858 962
error_table_$noentry            000046 external static fixed bin(35,0)          dcl 143 ref 850
explicit_deactivate_ok
                          0(05) 000035 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 192 in procedure "output_request_" set ref
                                                                                  232*
explicit_deactivate_ok
                          1(14) 000035 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 192 in procedure "output_request_" set ref
                                                                                  232*
factor                                 constant        float bin(27)            initial dcl 120 ref 521 521
fault_name                      000016 internal static char(32)                 dcl 108 set ref 593 595 1170*
fcbp                                   parameter       pointer                  dcl 885 in procedure "open_file" set ref 881 914*
                                                                                  922*
fcbp                            000610 automatic       pointer                  dcl 68 in procedure "output_request_" set ref 218*
                                                                                  386* 1003* 1152 1155* 1158*
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 16-8 set ref
                                                                                  566*
first_call                      000026 internal static bit(1)                   initial packed unaligned dcl 109 set ref 222 236*
fixed                                                  builtin function         dcl 200 ref 521 814 815
flags                    53            based           structure                level 2 in structure "request_descriptor" dcl 16-8
                                                                                  in procedure "output_request_"
flags                   310            based           structure                level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "output_request_"
float                                                  builtin function         dcl 201 ref 427 430 438
full_path                       000612 automatic       char(168)                dcl 69 in procedure "output_request_" set ref 320*
                                                                                  322 323* 323 326 344* 349 902 916
full_path                12     001366 automatic       char(168)                level 2 in structure "REQUEST" dcl 9-69 in procedure
                                                                                  "output_request_" set ref 322* 326* 430* 543* 557*
                                                                                  679*
grant                     0(01) 002004 automatic       bit(1)                   level 2 packed packed unaligned dcl 711 set ref 729*
have_accounting          47(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-25 ref 818
hcs_$fs_get_mode                000106 constant        entry                    external dcl 163 ref 954
hcs_$fs_get_path_name           000110 constant        entry                    external dcl 164 ref 933
hcs_$get_access_class           000112 constant        entry                    external dcl 165 ref 739 862
hcs_$get_user_effmode           000114 constant        entry                    external dcl 166 ref 848
hcs_$status_minf                000116 constant        entry                    external dcl 168 ref 900
head                            000664 automatic       char(64)                 dcl 70 set ref 330* 331 331* 331 333 333*
header                                 based           structure                level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "output_request_"
header                          000113 constant        fixed bin(17,0)          initial dcl 121 in procedure "output_request_" set
                                                                                  ref 478* 651*
header_sw                       000704 automatic       bit(1)                   packed unaligned dcl 71 set ref 247* 402 485* 534*
                                                                                  650 652* 655 659 686
heading                 136            based           char                     level 2 dcl 3-20 set ref 325* 325 330
heading_lth             106            based           fixed bin(17,0)          level 2 dcl 3-20 ref 325 325 330 715 715 742 742
i                               000705 automatic       fixed bin(17,0)          dcl 72 set ref 511 511 512 552 552 553
id                              000003 constant        char(24)                 initial packed unaligned dcl 122 set ref 1045*
input_iocbp                     002212 automatic       pointer                  dcl 1067 set ref 1077* 1085* 1115*
io_daemon_account_              000120 constant        entry                    external dcl 169 ref 819
ioa_$ioa_stream                 000122 constant        entry                    external dcl 170 ref 1110 1126 1141
ioa_$rsnnl                      000124 constant        entry                    external dcl 171 ref 320 333 340 430 543 557 607 679
                                                                                  687 924 1102 1137
iocbp                           000706 automatic       pointer                  dcl 73 set ref 249* 256 467* 486* 497* 511* 552*
                                                                                  568* 802* 991* 1015* 1027*
iodd_msg_                       000126 constant        entry                    external dcl 172 ref 344 427 438 444 537 662 684
                                                                                  1045
iodd_static                            based           structure                level 1 dcl 6-17
iox_$control                    000130 constant        entry                    external dcl 173 ref 467 486 497 511 552 568 802
iox_$get_line                   000134 constant        entry                    external dcl 175 ref 1115
iox_$look_iocb                  000136 constant        entry                    external dcl 176 ref 249
iox_$modes                      000132 constant        entry                    external dcl 174 ref 991 1027
iox_$put_chars                  000140 constant        entry                    external dcl 177 ref 1015
ipc_ind                         000100 automatic       fixed bin(35,0)          dcl 756 set ref 758* 769 769* 770* 776* 789 789*
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 16-8 set ref
                                                                                  426* 1049*
kst_attributes                         based           structure                level 1 dcl 7-5
ksta                            000035 internal static structure                level 1 dcl 192 set ref 228* 229 229 1009 1009
l                               000710 automatic       fixed bin(17,0)          dcl 74 set ref 308* 309 320* 333* 335* 340* 340 340
                                                                                  340 341 342 363* 364 430* 432 432 543* 546 546
                                                                                  557* 559 559 607* 679* 681 681 687*
last_error_count                000711 automatic       fixed bin(17,0)          dcl 75 set ref 238* 467 467 468* 509 512 549 553
length                                                 builtin function         dcl 200 ref 308 363 373 902
level                           001760 automatic       fixed bin(17,0)          dcl 704 set ref 716* 731*
lg_msg                          000712 automatic       char(100)                dcl 76 set ref 676* 677* 679* 684* 687*
line                                   based           fixed bin(17,0)          level 2 dcl 13-6 set ref 801* 810
line_count                4            based           fixed bin(17,0)          level 2 in structure "counts" dcl 13-6 in procedure
                                                                                  "output_request_" set ref 799* 806 806
line_count              272     001366 automatic       fixed bin(24,0)          level 2 in structure "REQUEST" dcl 9-69 in procedure
                                                                                  "output_request_" set ref 280* 537* 806* 808*
line_nbrs               304(07) 001366 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 9-69 in procedure "output_request_"
                                                                                  set ref 282* 990 1027
line_nbrs               102(08)        based           bit(1)                   level 3 in structure "dprint_msg" packed packed
                                                                                  unaligned dcl 3-20 in procedure "output_request_"
                                                                                  ref 282
linkage_error                   001310 stack reference condition                dcl 206 ref 224 235 762 778
local_audit_eventflags          002004 automatic       structure                level 1 dcl 711 set ref 728* 731 731
local_audit_user_info           001761 automatic       structure                level 1 dcl 710 set ref 718* 731 731
log                             000101 constant        fixed bin(17,0)          initial dcl 123 set ref 344* 427* 438* 444* 537*
                                                                                  662* 684*
ltrim                                                  builtin function         dcl 200 ref 1121
mailname                        000743 automatic       char(32)                 dcl 77 set ref 309* 782*
master                                 constant        fixed bin(17,0)          initial dcl 124 ref 393 1076
master_in                70            based           pointer                  level 2 dcl 6-17 ref 1077
master_output            56            based           char(32)                 level 2 dcl 6-17 ref 1078
max_comp                        000753 automatic       fixed bin(17,0)          dcl 78 in procedure "output_request_" set ref 386*
                                                                                  1022 1029
max_comp                               parameter       fixed bin(17,0)          dcl 886 in procedure "open_file" set ref 881 911*
                                                                                  912* 920
max_el                          002134 automatic       fixed bin(24,0)          dcl 982 set ref 1013* 1015*
message                 240            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "output_request_" set ref 243
message                                parameter       varying char             dcl 674 in procedure "error_write" set ref 671 679*
                                                                                  684* 687*
message                                parameter       char                     dcl 755 in procedure "notify_user" set ref 753 782*
min                                                    builtin function         dcl 201 ref 288
min_banner               55            based           bit(72)                  level 2 dcl 4-25 set ref 353* 355
mode                            002121 automatic       fixed bin(5,0)           dcl 895 in procedure "open_file" set ref 954* 960
mode                            002023 automatic       fixed bin(5,0)           dcl 845 in procedure "check_user_access" set ref
                                                                                  848* 856
mseg_message_info                      based           structure                level 1 dcl 8-9
mseg_message_info_ptr           001364 automatic       pointer                  dcl 8-7 set ref 242* 262 353 353 378 720 721 722 723
                                                                                  725 726 782 869
msf_manager_$close              000142 constant        entry                    external dcl 178 ref 1155
msf_manager_$get_ptr            000144 constant        entry                    external dcl 179 ref 922 1003
msf_manager_$open               000146 constant        entry                    external dcl 180 ref 914
msg                             000754 automatic       char(256)                dcl 79 set ref 333* 336* 340* 340 340 341* 342* 344*
                                                                                  421* 423* 430* 432 432 436* 438 438 438* 557* 559
                                                                                  559 583* 593* 607* 679* 681 681
mult_ind                        002122 automatic       fixed bin(17,0)          dcl 896 set ref 920* 922* 924* 928*
nelt                            002211 automatic       fixed bin(17,0)          dcl 1066 set ref 1115*
new_clock                       001054 automatic       fixed bin(71,0)          dcl 80 set ref 803* 813
new_cpu                         001056 automatic       fixed bin(52,0)          dcl 81 set ref 804* 812
new_pp                          001060 automatic       fixed bin(17,0)          dcl 82 set ref 804* 815
new_rate                        001061 automatic       fixed bin(17,0)          dcl 83 set ref 519* 520* 521* 521 523
new_waits                       001062 automatic       fixed bin(35,0)          dcl 84 set ref 804* 814
no_accounting           314(10) 001366 automatic       bit(1)                   level 2 packed packed unaligned dcl 9-69 set ref
                                                                                  825*
notify                   66(01)        based           bit(1)                   level 4 in structure "dprint_msg" packed packed
                                                                                  unaligned dcl 3-20 in procedure "output_request_"
                                                                                  ref 292
notify                                 parameter       bit(1)                   packed unaligned dcl 644 in procedure "fatal_error"
                                                                                  ref 642 647
notify                  304(03) 001366 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 9-69 in procedure "output_request_"
                                                                                  set ref 292* 542 647* 647 650 681
nret                            001063 automatic       fixed bin(17,0)          dcl 85 set ref 1102* 1137*
null                                                   builtin function         dcl 200 ref 214 218 486 486 497 497 568 568 595 731
                                                                                  731 987 998 1004 1016 1031 1150 1152 1153 1158
old_clock                       001064 automatic       fixed bin(71,0)          dcl 86 set ref 489* 813
old_cpu                         001166 automatic       fixed bin(52,0)          dcl 88 set ref 488* 812
old_pp                          001170 automatic       fixed bin(17,0)          dcl 89 set ref 488* 815
old_rate                        001171 automatic       fixed bin(17,0)          dcl 90 set ref 517* 519 521 521
old_waits                       001172 automatic       fixed bin(35,0)          dcl 91 set ref 488* 814
oldmodes                        001066 automatic       char(256)                packed unaligned dcl 87 set ref 989* 991* 1027 1027*
ordata                                 based           structure                level 1 dcl 9-17
orderp                          001714 automatic       pointer                  dcl 13-4 set ref 246* 799 800 801 802* 806 806 810
                                                                                  810 811
output_mode             221     001366 automatic       char(128)                level 2 dcl 9-69 set ref 293*
output_module           101            based           fixed bin(17,0)          level 2 dcl 3-20 ref 299
output_stream                   002214 automatic       char(32)                 packed unaligned dcl 1068 set ref 1078* 1086* 1110*
                                                                                  1126* 1141*
page_count              273     001366 automatic       fixed bin(17,0)          level 2 in structure "REQUEST" dcl 9-69 in procedure
                                                                                  "output_request_" set ref 281* 537* 810* 811* 1102
                                                                                  1102*
page_count                5            based           fixed bin(17,0)          level 2 in structure "counts" dcl 13-6 in procedure
                                                                                  "output_request_" set ref 800* 810 811
page_waits              300     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 463* 814*
pci                                    based           structure                level 1 dcl 11-15
pg_count_msg                    002225 automatic       char(30)                 packed unaligned dcl 1070 set ref 1102* 1104* 1110*
phcs_$deactivate                000150 constant        entry                    external dcl 181 ref 998 1029 1153
phcs_$set_kst_attributes        000152 constant        entry                    external dcl 182 ref 229 1009
pre_pages               301     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 464* 815*
prev_seq_id              35            based           fixed bin(35,0)          level 2 dcl 16-8 ref 272
price_per_n_lines       307     001366 automatic       float bin(27)            level 2 dcl 9-69 set ref 822*
price_per_n_pages       312     001366 automatic       float bin(27)            level 2 dcl 9-69 set ref 822*
print_driver_data                      based           structure                level 1 dcl 10-9
priority_request        304(05) 001366 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 9-69 in procedure "output_request_"
                                                                                  set ref 265* 344* 421
priority_request         53(08)        based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 16-8 in procedure
                                                                                  "output_request_" ref 265
privileged                      000027 internal static bit(1)                   initial packed unaligned dcl 110 set ref 225* 998
                                                                                  1009 1029 1153
process_id               13     001761 automatic       bit(36)                  level 2 dcl 710 set ref 722*
prt_buffer                             based           structure                level 1 dcl 14-68
prt_info                               based           structure                level 1 dcl 12-7
punsw                   207     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 300* 304* 537 1092
pverb                           001174 automatic       char(5)                  dcl 92 set ref 301* 305* 543* 607*
q                        33            based           fixed bin(17,0)          level 2 dcl 16-8 ref 269
queue                    64     001366 automatic       fixed bin(17,0)          level 2 dcl 9-69 set ref 269* 344* 543*
queue_msg_hdr                          based           structure                level 1 dcl 15-12
quiet                                  constant        bit(1)                   initial packed unaligned dcl 125 set ref 634*
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 516
r1_ind                          000101 automatic       fixed bin(35,0)          dcl 756 set ref 758* 768 768* 770* 774* 787 787*
read_allowed_                   000154 constant        entry                    external dcl 183 ref 869
real_time               276     001366 automatic       fixed bin(71,0)          level 2 dcl 9-69 set ref 462* 518 813*
req_stream                      001176 automatic       char(32)                 packed unaligned dcl 93 set ref 219* 249* 478* 526*
                                                                                  651* 659* 689*
req_type_label                         based           char(32)                 level 2 dcl 4-25 ref 268
request_data_p                  000032 internal static pointer                  dcl 112 set ref 244* 1180
request_descriptor                     based           structure                level 1 dcl 16-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 set ref
                                                                                  409* 567*
request_no               67     001366 automatic       fixed bin(35,0)          level 2 dcl 9-69 set ref 271* 344* 427* 438* 444*
                                                                                  454 537* 543* 557* 662* 684*
request_type             71     001366 automatic       char(32)                 level 2 dcl 9-69 set ref 268* 314 344*
requestor                 2     001366 automatic       char(32)                 level 2 dcl 9-69 set ref 262* 308 309 344* 848*
restart_no               70     001366 automatic       fixed bin(35,0)          level 2 dcl 9-69 set ref 272*
restart_source                  000034 internal static fixed bin(17,0)          initial dcl 126 set ref 393* 397* 572*
restarted               304(01) 001366 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 9-69 in procedure "output_request_"
                                                                                  set ref 264* 284 423
restarted                53(02)        based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 16-8 in procedure
                                                                                  "output_request_" ref 264
restrt_msg                      002235 automatic       char(30)                 packed unaligned dcl 1071 set ref 1094* 1137* 1141*
ring                     12     001761 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 710 set
                                                                                  ref 721*
rtrim                                                  builtin function         dcl 200 ref 308 363 593 742 742 1121
save_code                       001206 automatic       fixed bin(35,0)          dcl 94 set ref 646* 657*
saved                    53(05)        based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 16-8 in procedure
                                                                                  "output_request_" ref 499
saved                   304(04) 001366 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 9-69 in procedure "output_request_"
                                                                                  set ref 401*
sdb_ptr                         001716 automatic       pointer                  dcl 14-10 set ref 214* 256*
seconds                         001207 automatic       fixed bin(17,0)          dcl 95 set ref 518* 519 520
segp                            001210 automatic       pointer                  dcl 96 set ref 218* 922* 928 933* 954* 987* 998 998*
                                                                                  1003* 1004 1009 1009 1012 1015* 1029* 1031* 1153
                                                                                  1153* 1158*
segptr                                 parameter       pointer                  dcl 706 in procedure "check_labels" set ref 695 731*
segptr                  306            based           pointer                  level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "output_request_" set ref 595 1012*
                                                                                  1016* 1150*
send_mail_$access_class         000156 constant        entry                    external dcl 184 ref 782
send_mail_info                  001721 automatic       structure                level 1 dcl 17-5 set ref 310* 782 782
send_mail_info_version_2        001720 automatic       fixed bin(17,0)          initial dcl 17-3 set ref 311 17-3*
sender_audit             31            based           bit(36)                  level 2 dcl 8-9 ref 726
sender_authorization     25            based           bit(72)                  level 2 dcl 8-9 set ref 353* 353 723 782* 869*
sender_id                13            based           char(32)                 level 2 packed packed unaligned dcl 8-9 ref 262 720
sender_level             24            based           fixed bin(17,0)          level 2 dcl 8-9 ref 378 721
sender_max_authorization
                         27            based           bit(72)                  level 2 dcl 8-9 ref 725
sender_process_id        23            based           bit(36)                  level 2 dcl 8-9 ref 722
sent_from                 1     001721 automatic       char(32)                 level 2 dcl 17-5 set ref 314*
separator               304(02) 001366 automatic       bit(1)                   level 3 packed packed unaligned dcl 9-69 set ref
                                                                                  266* 484* 1095* 1135*
seq_id                   32            based           fixed bin(35,0)          level 2 dcl 16-8 ref 271
set                             000035 internal static structure                level 2 packed packed unaligned dcl 192
short_msg                       001214 automatic       char(8)                  dcl 98 set ref 676* 677*
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "output_request_"
slave                           000110 constant        fixed bin(17,0)          initial dcl 127 in procedure "output_request_" set
                                                                                  ref 397 438* 1084
slave_in                334            based           pointer                  level 3 dcl 6-17 ref 1085
slave_output            322            based           char(32)                 level 3 dcl 6-17 ref 1086
source                                 parameter       fixed bin(17,0)          dcl 1061 set ref 1057 1076 1084*
stars                           010415 constant        char(40)                 initial dcl 128 set ref 687* 687*
start_segp                      001212 automatic       pointer                  dcl 97 set ref 218* 470* 928*
stat_p                          000040 internal static pointer                  dcl 6-15 set ref 213* 229 229 240 409 516 567 595
                                                                                  1012 1016 1077 1078 1085 1086 1150
status_flags             47            based           structure                level 2 dcl 4-25
string                                                 builtin function         dcl 201 set ref 228* 261*
substr                                                 builtin function         dcl 200 set ref 309 331 331 340 340 342* 432 432 546
                                                                                  546 559 559 681 681 941 948
switches                 11     001721 automatic       structure                level 2 dcl 17-5
sys_info$access_class_floor     000170 external static bit(72)                  dcl 707 ref 724
sys_priv                        000030 internal static bit(1)                   initial packed unaligned dcl 111 set ref 760 763*
system_privilege_$ipc_priv_off  000162 constant        entry                    external dcl 186 ref 769 789
system_privilege_$ipc_priv_on   000160 constant        entry                    external dcl 185 ref 776
system_privilege_$ring1_priv_off
                                000166 constant        entry                    external dcl 188 ref 768 787
system_privilege_$ring1_priv_on 000164 constant        entry                    external dcl 187 ref 774
tail                            000110 constant        fixed bin(17,0)          initial dcl 129 set ref 526* 659*
tell_user                              constant        bit(1)                   initial packed unaligned dcl 130 set ref 359* 367*
                                                                                  382* 388* 472* 612* 623*
text_offset                            based           structure                level 1 packed packed unaligned dcl 5-45
time_est                        001216 automatic       fixed bin(17,0)          dcl 99 set ref 416* 418 427 430 438 438
time_start_request      262     001366 automatic       fixed bin(71,0)          level 2 dcl 9-69 set ref 296* 297* 456* 457*
top_label                              based           char                     level 2 dcl 3-20 ref 715 742 742
top_label_lth           107            based           fixed bin(17,0)          level 2 dcl 3-20 ref 715 715 742 742
total_bits                      001217 automatic       fixed bin(35,0)          dcl 100 set ref 415* 416
total_charge            306     001366 automatic       float bin(27)            level 2 dcl 9-69 set ref 294* 537* 543* 830* 830
tpd                       1(12) 000035 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 192 in procedure "output_request_" set ref
                                                                                  231*
tpd                       0(03) 000035 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 192 in procedure "output_request_" set ref
                                                                                  231*
translate                                              builtin function         dcl 200 ref 322 323 324 325
tus                       0(02) 000035 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 192 in procedure "output_request_" set ref
                                                                                  234*
tus                       1(11) 000035 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 192 in procedure "output_request_" set ref
                                                                                  234*
type                            002116 automatic       fixed bin(2,0)           dcl 891 set ref 900* 906
unspec                                                 builtin function         dcl 201 set ref 310* 718* 728* 731 731
user_dir                               parameter       char                     dcl 705 in procedure "check_labels" set ref 695 739*
user_dir                        001220 automatic       char(168)                dcl 101 in procedure "output_request_" set ref 318*
                                                                                  320* 320 380* 386* 470*
user_dir                               parameter       char                     dcl 883 in procedure "open_file" set ref 881 900*
                                                                                  914*
user_dir                               parameter       char                     dcl 841 in procedure "check_user_access" set ref 836
                                                                                  848* 862*
user_id                   2     001761 automatic       char(32)                 level 2 dcl 710 set ref 720*
val                             001272 automatic       fixed bin(17,0)          dcl 102 set ref 378* 848*
value                     1(09) 000035 internal static structure                level 2 packed packed unaligned dcl 192
version                         001721 automatic       fixed bin(17,0)          level 2 in structure "send_mail_info" dcl 17-5
                                                                                  in procedure "output_request_" set ref 311*
version                         001761 automatic       char(8)                  level 2 in structure "local_audit_user_info" dcl 710
                                                                                  in procedure "check_labels" set ref 719*
wakeup                   11     001721 automatic       bit(1)                   level 3 packed packed unaligned dcl 17-5 set ref
                                                                                  312*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 5-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 8-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 8-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 8-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 8-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 8-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 8-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 8-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 8-30
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 15-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 15-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 15-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 15-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 15-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 15-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 15-41
audit_user_info_ptr                    automatic       pointer                  dcl 2-11
channel_stops                          based           bit(16)                  array packed unaligned dcl 13-25
dprint_msg_version_3                   internal static fixed bin(17,0)          initial dcl 3-62
dprint_msg_version_4                   internal static fixed bin(17,0)          initial dcl 3-62
dprint_msg_version_5                   internal static fixed bin(17,0)          initial dcl 3-62
driver_status_ptr                      automatic       pointer                  dcl 4-24
forms_max_lth                          internal static fixed bin(17,0)          initial dcl 3-55
head_max_lth                           internal static fixed bin(17,0)          initial dcl 3-55
iod_tables_hdr                         based           structure                level 1 dcl 5-23
ithp                                   automatic       pointer                  dcl 5-22
kstap                                  automatic       pointer                  dcl 7-3
label_max_lth                          internal static fixed bin(17,0)          initial dcl 3-55
ordatap                                automatic       pointer                  dcl 9-67
page_labels                            based           structure                level 1 dcl 13-21
paper_info                             based           structure                level 1 dcl 13-27
path_max_lth                           internal static fixed bin(17,0)          initial dcl 3-55
pcip                                   automatic       pointer                  dcl 11-13
pip                                    automatic       pointer                  dcl 12-5
position_data                          based           structure                level 1 dcl 13-14
prt_bufferp                            automatic       pointer                  dcl 14-66
prt_buffers                            based           structure                array level 1 dcl 14-79
queue_msg_hdr_version_1                internal static fixed bin(17,0)          initial dcl 15-37
ret_error_count                        based           fixed bin(17,0)          dcl 13-32
sdb                                    based           structure                level 1 dcl 14-12
text_strings                           based           structure                level 1 dcl 5-39
text_strings_ptr                       automatic       pointer                  dcl 5-38
wseg                                   based           bit(36)                  array dcl 14-78

NAMES DECLARED BY EXPLICIT CONTEXT.
LOG_AUDIT_MESSAGE               005341 constant        label                    dcl 716 ref 745 748
abort_request                   004366 constant        label                    dcl 589 ref 257
ask_how_many_good               007732 constant        label                    dcl 1110 ref 1128
bad_no                          010076 constant        label                    dcl 1126 ref 1131
charge_for_work                 006047 constant        entry                    internal dcl 795 ref 507 655
check_labels                    005274 constant        entry                    internal dcl 695 ref 470
check_reprint_copies            004351 constant        label                    dcl 572 ref 394 398
check_user_access               006227 constant        entry                    internal dcl 836 ref 380 939
clean_out                       004157 constant        label                    dcl 549 ref 252 360 368 383 389 402 433 473 481 494
                                                                                  529 614 625 636
clean_proc                      010226 constant        entry                    internal dcl 1148 ref 255 564
defer_request                   004524 constant        label                    dcl 617 ref 405
driver_fatal_error              007524 constant        entry                    internal dcl 1038 ref 251 480 493 528
error_during_request            004553 constant        entry                    external dcl 1166
error_write                     004770 constant        entry                    internal dcl 671 ref 657
fatal_error                     004614 constant        entry                    internal dcl 642 ref 359 367 382 388 472 612 623 634
flush_request                   004361 constant        label                    dcl 583 ref 406 407
next_comp                       007271 constant        label                    dcl 998 ref 1024
no_delete                       004447 constant        label                    dcl 601 ref 587
notify_user                     005632 constant        entry                    internal dcl 753 ref 432 546 559 681
open_file                       006442 constant        entry                    internal dcl 881 ref 386
output_file                     007214 constant        entry                    internal dcl 976 ref 491
output_request_                 001130 constant        entry                    external dcl 13
restart_request                 007611 constant        entry                    internal dcl 1057 ref 572
restart_this_request            003217 constant        label                    dcl 449 ref 579
revert_handler                  005763 constant        label                    dcl 778 ref 764
save_request                    004536 constant        label                    dcl 628 ref 403
send_it                         005764 constant        label                    dcl 782 ref 760
set_single_copy                 004601 constant        entry                    external dcl 1176
start_request                   003251 constant        label                    dcl 459 ref 447
tell_operator                   010131 constant        label                    dcl 1133 ref 1118
tough                           001274 constant        label                    dcl 235 ref 226

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11354       11546   10434       11364
Length     12530   10434       172         745     717          32

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
output_request_                    1747 external procedure  is an external procedure.  
on unit on line 224                  64 on unit               
on unit on line 255                  64 on unit               
on unit on line 392                  64 on unit               
on unit on line 396                  64 on unit               
on unit on line 400                  64 on unit               
on unit on line 405                  64 on unit               
on unit on line 406                  64 on unit               
on unit on line 407                  64 on unit               
fatal_error                             internal procedure  shares stack frame of external procedure output_request_.  
error_write                             internal procedure  shares stack frame of external procedure output_request_.  
check_labels                            internal procedure  shares stack frame of external procedure output_request_.  
notify_user                         110 internal procedure  is called during a stack extension, and enables or reverts conditions.  
on unit on line 762                  64 on unit               
on unit on line 767                  68 on unit               
charge_for_work                         internal procedure  shares stack frame of external procedure output_request_.  
check_user_access                       internal procedure  shares stack frame of external procedure output_request_.  
open_file                               internal procedure  shares stack frame of external procedure output_request_.  
output_file                             internal procedure  shares stack frame of external procedure output_request_.  
driver_fatal_error                  108 internal procedure  is called during a stack extension.  
restart_request                         internal procedure  shares stack frame of external procedure output_request_.  
clean_proc                           74 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 bad_chars                   output_request_
000012 err_label                   output_request_
000016 fault_name                  output_request_
000026 first_call                  output_request_
000027 privileged                  output_request_
000030 sys_priv                    output_request_
000032 request_data_p              output_request_
000034 restart_source              output_request_
000035 ksta                        output_request_
000040 stat_p                      output_request_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
notify_user              000100 ipc_ind                     notify_user
                         000101 r1_ind                      notify_user
                         000102 ec                          notify_user
output_request_          000100 abort_msg                   output_request_
                         000202 access_class                output_request_
                         000204 auth                        output_request_
                         000206 auth_string                 output_request_
                         000460 banner_proc                 output_request_
                         000464 chgsw                       output_request_
                         000465 code                        output_request_
                         000466 copies_left                 output_request_
                         000467 delete_msg                  output_request_
                         000500 desc_ptr                    output_request_
                         000502 dest                        output_request_
                         000510 device_error                output_request_
                         000512 dr_ptr                      output_request_
                         000514 el_size                     output_request_
                         000515 ename                       output_request_
                         000525 err_mess                    output_request_
                         000610 fcbp                        output_request_
                         000612 full_path                   output_request_
                         000664 head                        output_request_
                         000704 header_sw                   output_request_
                         000705 i                           output_request_
                         000706 iocbp                       output_request_
                         000710 l                           output_request_
                         000711 last_error_count            output_request_
                         000712 lg_msg                      output_request_
                         000743 mailname                    output_request_
                         000753 max_comp                    output_request_
                         000754 msg                         output_request_
                         001054 new_clock                   output_request_
                         001056 new_cpu                     output_request_
                         001060 new_pp                      output_request_
                         001061 new_rate                    output_request_
                         001062 new_waits                   output_request_
                         001063 nret                        output_request_
                         001064 old_clock                   output_request_
                         001066 oldmodes                    output_request_
                         001166 old_cpu                     output_request_
                         001170 old_pp                      output_request_
                         001171 old_rate                    output_request_
                         001172 old_waits                   output_request_
                         001174 pverb                       output_request_
                         001176 req_stream                  output_request_
                         001206 save_code                   output_request_
                         001207 seconds                     output_request_
                         001210 segp                        output_request_
                         001212 start_segp                  output_request_
                         001214 short_msg                   output_request_
                         001216 time_est                    output_request_
                         001217 total_bits                  output_request_
                         001220 user_dir                    output_request_
                         001272 val                         output_request_
                         001273 counts_data                 output_request_
                         001362 dmp                         output_request_
                         001364 mseg_message_info_ptr       output_request_
                         001366 REQUEST                     output_request_
                         001712 driver_data_p               output_request_
                         001714 orderp                      output_request_
                         001716 sdb_ptr                     output_request_
                         001720 send_mail_info_version_2    output_request_
                         001721 send_mail_info              output_request_
                         001756 access_class                check_labels
                         001760 level                       check_labels
                         001761 local_audit_user_info       check_labels
                         002004 local_audit_eventflags      check_labels
                         002022 code                        check_user_access
                         002023 mode                        check_user_access
                         002024 access_class                check_user_access
                         002034 comp_dir                    open_file
                         002106 comp_name                   open_file
                         002116 type                        open_file
                         002117 dir_len                     open_file
                         002120 bc                          open_file
                         002121 mode                        open_file
                         002122 mult_ind                    open_file
                         002132 bc                          output_file
                         002133 comp_no                     output_file
                         002134 max_el                      output_file
                         002144 answer                      restart_request
                         002202 cnt_msg                     restart_request
                         002210 copies_good                 restart_request
                         002211 nelt                        restart_request
                         002212 input_iocbp                 restart_request
                         002214 output_stream               restart_request
                         002224 code                        restart_request
                         002225 pg_count_msg                restart_request
                         002235 restrt_msg                  restart_request

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars
call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other
return_mac          fl2_to_fx1          tra_ext_1           tra_ext_2           enable_op           shorten_stack
ext_entry           ext_entry_desc      int_entry           int_entry_desc      set_chars_eis       divide_fx3
translate_3         verify_for_rtrim

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_gate_$log_obj_ptr_user                         aim_check_$equal              aim_check_$greater
clock_                        continue_to_signal_           convert_authorization_$from_string
convert_authorization_$to_string                            convert_status_code_          cpu_time_and_paging_
cu_$level_get                 cv_dec_check_                 date_time_                    hcs_$fs_get_mode
hcs_$fs_get_path_name         hcs_$get_access_class         hcs_$get_user_effmode         hcs_$status_minf
io_daemon_account_            ioa_$ioa_stream               ioa_$rsnnl                    iodd_msg_
iox_$control                  iox_$get_line                 iox_$look_iocb                iox_$modes
iox_$put_chars                msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
phcs_$deactivate              phcs_$set_kst_attributes      read_allowed_                 send_mail_$access_class
system_privilege_$ipc_priv_off                              system_privilege_$ipc_priv_on
system_privilege_$ring1_priv_off                            system_privilege_$ring1_priv_on

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$io_daemon_set_page_labels                error_table_$ai_restricted    error_table_$dirseg
error_table_$improper_data_format                           error_table_$moderr           error_table_$noentry
sys_info$access_class_floor




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
17    3 001117        13 001123       213 001144       214 001151       215 001153       217 001160       218 001161
    219 001165       220 001172       221 001174       222 001175       223 001177       224 001210       225 001224
    226 001225       228 001230       229 001234       231 001255       232 001262       233 001266       234 001270
    235 001274       236 001275       238 001277       240 001301       241 001304       242 001306       243 001307
    244 001311       245 001313       246 001315       247 001317       249 001320       250 001340       251 001342
    252 001361       255 001362       256 001404       257 001406       261 001412       262 001413       263 001417
    264 001424       265 001431       266 001436       267 001440       268 001444       269 001447       270 001451
    271 001455       272 001457       274 001461       276 001463       277 001465       278 001473       279 001474
    280 001475       281 001476       282 001477       283 001504       284 001506       287 001515       288 001523
    290 001536       291 001544       292 001547       293 001554       294 001557       295 001561       296 001562
    297 001570       299 001605       300 001611       301 001612       302 001614       304 001615       305 001617
    308 001621       309 001634       310 001637       311 001642       312 001644       313 001646       314 001650
    318 001653       319 001656       320 001661       322 001726       323 001743       324 001760       325 001776
    326 002014       330 002020       331 002023       333 002032       335 002070       336 002072       339 002075
    340 002101       341 002156       342 002166       344 002171       349 002277       353 002304       355 002331
    357 002335       358 002356       359 002360       360 002362       363 002363       364 002375       365 002377
    366 002425       367 002427       368 002431       370 002432       373 002453       378 002456       380 002461
    381 002464       382 002466       383 002470       386 002471       387 002474       388 002476       389 002500
    392 002501       393 002515       394 002517       396 002522       397 002536       398 002540       400 002543
    401 002557       402 002562       403 002567       405 002572       406 002611       407 002630       409 002647
    414 002653       415 002656       416 002661       418 002663       421 002675       423 002704       426 002713
    427 002716       430 002765       432 003025       433 003044       435 003046       436 003047       438 003052
    444 003145       447 003216       449 003217       454 003221       455 003223       456 003225       457 003234
    459 003251       462 003253       463 003254       464 003255       465 003256       467 003262       468 003314
    470 003320       471 003323       472 003325       473 003327       476 003330       478 003333       479 003361
    480 003363       481 003402       484 003403       485 003405       486 003407       488 003437       489 003452
    491 003461       492 003463       493 003465       494 003511       497 003513       499 003543       501 003555
    502 003557       503 003562       504 003563       505 003565       507 003566       509 003567       511 003574
    512 003626       513 003636       516 003637       517 003646       518 003651       519 003656       520 003663
    521 003666       523 003705       526 003707       527 003735       528 003737       529 003756       532 003757
    533 003765       534 003766       535 003767       537 003770       542 004061       543 004064       546 004137
    547 004156       549 004157       552 004162       553 004214       555 004225       556 004230       557 004232
    559 004266       560 004305       564 004306       566 004312       567 004315       568 004321       569 004350
    572 004351       579 004360       583 004361       586 004364       587 004365       589 004366       593 004367
    595 004427       597 004441       598 004443       599 004446       601 004447       604 004455       607 004460
    610 004520       612 004521       614 004523       617 004524       620 004531       621 004532       623 004533
    625 004535       628 004536       631 004543       632 004544       634 004545       636 004547      1166 004550
   1170 004567      1172 004576      1176 004600      1180 004607      1182 004613       642 004614       646 004616
    647 004620       648 004627       650 004632       651 004637       652 004665       655 004671       657 004674
    659 004677       662 004727       665 004767       671 004770       676 005001       677 005006       679 005024
    681 005066       684 005110       686 005166       687 005170       689 005244       691 005273       695 005274
    713 005312       715 005314       716 005341       718 005350       719 005353       720 005356       721 005362
    722 005367       723 005371       724 005375       725 005403       726 005407       728 005411       729 005412
    731 005414       736 005475       739 005476       740 005524       742 005530       743 005604       744 005610
    745 005611       748 005612       750 005630       753 005631       758 005645       760 005650       762 005652
    763 005666       764 005667       767 005672       768 005706       769 005717       770 005731       771 005735
    772 005744       774 005745       776 005754       778 005763       782 005764       787 006024       789 006035
    791 006046       795 006047       799 006050       800 006052       801 006053       802 006054       803 006105
    804 006114       806 006127       808 006134       810 006140       811 006147       812 006151       813 006154
    814 006157       815 006165       817 006170       818 006172       819 006176       820 006211       822 006212
    825 006216       827 006220       828 006221       830 006223       832 006226       836 006227       848 006245
    849 006304       850 006306       851 006313       852 006320       853 006323       856 006324       857 006332
    858 006337       859 006343       862 006344       863 006373       864 006375       865 006402       866 006405
    869 006406       870 006425       871 006431       872 006436       875 006437       877 006441       881 006442
    898 006460       900 006461       901 006522       902 006525       903 006547       906 006551       908 006557
    909 006562       911 006563       912 006566       914 006567       915 006615       916 006620       917 006634
    920 006636       922 006645       923 006671       924 006674       925 006723       928 006724       933 006730
    934 006761       935 006764       936 006771       939 006772       940 007012       941 007015       943 007071
    946 007073       947 007076       948 007101       949 007143       952 007145       954 007146       955 007161
    956 007164       957 007171       960 007172       961 007200       962 007205       963 007210       965 007211
    974 007213       976 007214       985 007216       987 007217       988 007221       989 007222       990 007225
    991 007230       992 007261       993 007263       994 007270       998 007271      1003 007311      1004 007335
   1005 007341      1006 007346      1009 007347      1012 007373      1013 007377      1015 007404      1016 007421
   1017 007425      1018 007430      1019 007435      1022 007436      1023 007441      1024 007442      1027 007443
   1029 007477      1031 007520      1033 007522      1038 007523      1045 007537      1048 007576      1049 007602
   1051 007604      1053 007610      1057 007611      1076 007613      1077 007616      1078 007622      1079 007626
   1084 007627      1085 007631      1086 007635      1092 007641      1094 007652      1095 007655      1096 007657
   1098 007662      1102 007663      1104 007715      1106 007720      1108 007727      1110 007732      1114 007772
   1115 007775      1116 010020      1117 010022      1118 010023      1121 010024      1123 010055      1125 010074
   1126 010076      1128 010122      1131 010123      1133 010131      1135 010135      1137 010141      1141 010200
   1143 010224      1148 010225      1150 010233      1152 010236      1153 010242      1155 010261      1158 010271
   1160 010275


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
