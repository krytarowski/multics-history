	COMPILATION LISTING OF SEGMENT online_355_dump_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/21/86  1507.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 /* format: off */
       11 
       12 online_355_dump_: proc (a_dumpp, number);
       13 
       14 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
       15*   *
       16*   *	online_355_dump_
       17*   *
       18*   *	This is a subroutine to produce a dump suitable for printing from a fnp
       19*   *	fdump. This subroutine is called with a pointer to the dump to be printed
       20*   *	and with the stream name "od_output_" already attached to the output device.
       21*   *
       22*   *	Originally written by Dick Snyder 05/31/73
       23*   *	Modified for new 355 software by Robert Coren 04/01/75
       24*   *	Modified for multiple 355s by Robert Coren 10/08/75
       25*   *	Modified for new communications region and to add crash message by Robert Coren 06/24/76
       26*   *	Modified 79 May 16 by Art Beattie to support 64K fnp dumps.
       27*   *
       28*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
       29 
       30 
       31 /****^  HISTORY COMMENTS:
       32*  1) change(85-05-31,Farley), approve(86-07-10,MCR7247),
       33*     audit(86-07-18,Fawcett), install(86-07-21,MR12.0-1099):
       34*     Allow for upto 256k FNP memory sizes (phx19295).
       35*                                                   END HISTORY COMMENTS */
       36 
       37 
       38 /*	EXTERNAL ENTRIES		*/
       39 
       40 
       41 dcl  ios_$write ext entry (char (*), ptr, fixed bin, fixed bin, fixed bin, bit (72) aligned);
       42 dcl  com_err_ ext entry options (variable);
       43 dcl  ioa_$rsnnl ext entry options (variable);
       44 dcl  ioa_$rs ext entry options (variable);
       45 dcl  format_355_dump_line_$line ext entry (ptr, fixed bin, ptr, ptr, fixed bin, ptr, fixed bin);
       46 dcl  format_355_dump_line_ ext entry (ptr, fixed bin, ptr);
       47 dcl  date_time_ entry (fixed bin (71), char (*));
       48 dcl  format_fnp_trace_msg_ entry (ptr, ptr, char (*) var);
       49 dcl  get_fnp_name_ entry (fixed bin) returns (char (32));
       50 
       51 
       52 /*	AUTOMATIC STORAGE 		*/
       53 
       54 
       55 dcl  faultp pointer;				/* points to fault data */
       56 dcl  a_dumpp pointer;
       57 dcl  number fixed bin;				/* fnp identifier */
       58 dcl  st bit (72) aligned;				/* ios status word */
       59 dcl  st_code fixed bin based (statp);			/* overlay for left half of st */
       60 dcl  statp pointer;					/* points to st */
       61 dcl  dumpp pointer;					/* argument copied to local variable for better code */
       62 dcl (i, k, nelemt);					/* scratch temps */
       63 dcl  retstring char (132);				/* string returned by ioa_$rsnnl */
       64 dcl  retp pointer;					/* points to retstring */
       65 dcl  retl fixed bin;				/* number of valid chars in retstring */
       66 dcl  date_time_bound char (24);
       67 dcl  date_time_booted char (24);
       68 dcl  type char (5);					/* fault type */
       69 dcl  octal char (200);				/* string written by format_355_dump_line_ */
       70 dcl  octalp pointer;				/* points to octal */
       71 dcl  next_module_start fixed bin;			/* address of base of a module */
       72 dcl  dup_copy bit (144) based;			/* for copying 8 fnp words */
       73 dcl  mem_size fixed bin (18) unsigned;			/* size of fnp memory */
       74 dcl  mod_chain fixed bin;				/* start of module chain */
       75 dcl  locs_to_dump fixed bin (18) unsigned;		/* number of words left to dump */
       76 dcl  rel_addr fixed bin init (0);			/* rell address in current module being dumped */
       77 dcl  curlp pointer;					/* points to current line being dumped in fnp image */
       78 dcl  dupp pointer;					/* points to last non-duplicate line */
       79 dcl  cur_loc fixed bin init (0);			/* current loc being dumped in fnp image */
       80 dcl  cur_chain fixed bin (18) unsigned;			/* offset in dump of current module chain block */
       81 dcl  modx fixed bin;				/* current index into module chain */
       82 dcl  module_name char (12);
       83 dcl  module_num fixed bin;
       84 dcl  die_ptr ptr;
       85 dcl  reasonp ptr;
       86 dcl  ch_val fixed bin;
       87 dcl  trace_edit char (128) var;
       88 dcl  print_trace bit (1) init ("1"b);			/* ON - try printing trace data */
       89 
       90 /*	BASED			*/
       91 
       92 dcl  bit36 bit (36) unal based;			/* used to overlay module name in fnp module chain */
       93 dcl  first_200_words bit (7200) aligned based (dumpp);	/* used to check if fnp core is all zero */
       94 
       95 dcl  message_offsets (1) bit (18) aligned based;		/* list of message offsets (per module) */
       96 
       97 dcl 1 die_reason based (reasonp) aligned,
       98     2 length fixed bin (8) unaligned,
       99     2 msg char (0 refer (die_reason.length)) unaligned;
      100 
      101 dcl 1 die_word based (die_ptr),			/* format of illegal op word used to crash fnp */
      102     2 mod_num bit (4) unaligned,
      103     2 op_code bit (5) unaligned,
      104     2 reason fixed bin (8) unaligned;
      105 
      106 dcl  dump_chars (16) bit (9) unaligned based (curlp);
      107 
      108 /*	STRUCTURES		*/
      109 
      110 dcl 1 core_fnpb aligned based (dumpp),			/* overlay for fnp dump in 18 bit pieces */
      111     2 words (0: MEM_256K - 1) bit (18) unaligned;
      112 
      113 dcl 1 core_fnp aligned based (dumpp),			/* overlay for fnp dump in packed fixed bin */
      114     2 words (0: MEM_256K - 1) fixed bin (17) unaligned;
      115 
      116 
      117 dcl 1 dump_line aligned,				/* dump line */
      118     2 abs_addr char (6) unaligned,			/* absolute fnp address */
      119     2 star char (1) unaligned,			/* duplicate line indicator */
      120     2 space1 char (1) unaligned,			/* blank */
      121     2 module char (4) unaligned,			/* module name */
      122     2 space2 char (1) unaligned,			/* blank */
      123     2 rel_addr char (6) unaligned,			/* rel address in module */
      124     2 space3 char (3) unaligned,			/* blanks */
      125     2 eight_words char (55) unaligned,			/* dump line itself */
      126     2 space4 char (2) unaligned,			/* blanks */
      127     2 ascii (16) char (1) unaligned,			/* ascii of dump_line */
      128     2 nl char (1) unaligned;				/* new line */
      129 
      130 dcl 1 fault_data aligned based (faultp),		/* to overlay fault data in fnp */
      131     2 regs (9) fixed bin (17) unaligned,
      132     2 fault_number fixed bin (17) unaligned,
      133     2 fault_name bit (18) unaligned;
      134 
      135 dcl 1 octal_overlay (50) unaligned based (addr (octal)),	/* to get at 6 chars at a time in octal */
      136     2 word char (6) unaligned,			/* octal representation of 1 fnp word */
      137     2 space char (1) unaligned;			/* a space */
      138 
      139 dcl 1 modch aligned,				/* information provided by module chain */
      140     2 nmodules fixed bin,
      141     2 entries (30),
      142       3 name char (4),
      143       3 address fixed bin (24);
      144 
      145 /*	INTERNAL STATIC */
      146 
      147 dcl  MEM_24K fixed bin (19) uns int static options (constant) init (24576);
      148 dcl  MEM_32K fixed bin (19) uns int static options (constant) init (32768);
      149 dcl  MEM_64K fixed bin (19) uns int static options (constant) init (65536);
      150 dcl  MEM_128K fixed bin (19) uns int static options (constant) init (131072);
      151 dcl  MEM_256K fixed bin (19) uns int static options (constant) init (262144);
      152 
      153 dcl  die_op bit (5) int static options (constant) init ("01001"b);
      154 
      155 dcl  faults (0: 10) char (16) int static options (constant) init (
      156      "POWER OFF ", "POWER ON  ", "MEMORY PARITY", "ILLEGAL OPCODE", "OVERFLOW  ",
      157      "STORE FAULT", "DIVIDE CHECK", "ILLEGAL INT", "EXTRA INT ", "IOM FAULT", "CONSOLE ABORT");
      158 
      159 dcl  xlate (0: 63) char (1) int static init (		/* bcd to ascii xlation table */
      160 
      161      "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[", "#", "@", ":", ">", "?",
      162 
      163      " ", "A", "B", "C", "D", "E", "F", "G", "H", "I", "&", ".", "]", "(", "<", "^",
      164 
      165      "|", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "-", "$", "*", ")", ";", "'",
      166 
      167      "+", "/", "S", "T", "U", "V", "W", "X", "Y", "Z", "_", ",", "%", "=", """", "!");
      168 
      169 dcl  end_of_table bit (18) int static init ("101010101010101000"b); /* physical end of trace table pattern */
      170 dcl  logical_end bit (18) int static init ("101010101010101010"b); /* logical end of trace table pattern */
      171 dcl  nl char (1) int static options (constant) init ("
      172 ");
      173 
      174 
      175 
      176 /*	EXTERNAL STATIC */
      177 
      178 dcl  od355_msgs$ fixed bin ext static;
      179 
      180 dcl 1 od355_msgs$die_list (8) ext static aligned,
      181     2 name char (12),
      182     2 offset fixed bin;
      183 
      184 /* BUILTINS */
      185 
      186 dcl (addr, addrel, bin, bit, fixed, length, ptr, string, substr, unspec) builtin;
      187 
      188 /* INCLUDE FILES */
      189 
  1     1 /* BEGIN INCLUDE FILE ... mcs_memory_map.incl.pl1 */
  1     2 
  1     3 /* This include file descibes MCS memory layout.
  1     4*
  1     5*   Created 6/2/76 by Mike Grady
  1     6*   Modified 1979 June 1 by Art Beattie to add new cells in comm_reg.
  1     7*   Modified June 1982 by Robert Coren to add some more new cells in comm_reg and
  1     8*    change some of them to fixed bin (18) unsigned.
  1     9**/
  1    10 
  1    11 dcl 1 mem_array aligned based (memp),			/* as an array of 18 bit words */
  1    12     2 mem (0:65535) bit (18) unaligned;
  1    13 
  1    14 
  1    15 dcl 1 low_mem aligned based (memp),			/* detail of low memory */
  1    16     2 interrupt_vectors (0:255) bit (18) unal,		/* loc 0-377 octal */
  1    17     2 interrupt_cells (16) bit (18) unal,		/* loc 400-417 octal */
  1    18     2 iom_fault_status (16) bit (18) unal,		/* loc 420-437 octal */
  1    19     2 processor_fault_vectors (8) bit (18) unal,		/* loc 440-447 octal */
  1    20     2 chan_mailbox (24) bit (18) unal,			/* loc 450-477 octal */
  1    21     2 lsla_mailbox (0:5) like hwcm,			/* LSLA hardware comm regions, loc 500-637 octal */
  1    22     2 comm_reg unal,				/* software communications region for MCS system */
  1    23       3 crldt fixed bin (71) aligned,			/* date and time binder produced this image */
  1    24       3 crbdt fixed bin (71) aligned,			/* date and time image was booted into FNP */
  1    25       3 crbuf fixed bin (17) unal,			/* base of free buffer pool */
  1    26       3 crmem fixed bin (18) unsigned unal,		/* last loc of mem configured */
  1    27       3 crnbf fixed bin (17) unal,			/* free buffers in pool now */
  1    28       3 criom fixed bin (17) unal,			/* pointer to iom table */
  1    29       3 crnhs fixed bin (17) unal,			/* number of HSLAs */
  1    30       3 crnls fixed bin (17) unal,			/* number of LSLAs */
  1    31       3 crcon bit (18) unal,				/* console enable switch */
  1    32       3 crmod fixed bin (17) unal,			/* base of module chain */
  1    33       3 crnxa fixed bin (17) unal,			/* pointer to head of free space chain */
  1    34       3 crtra bit (18) unal,				/* trace entry enable mask */
  1    35       3 crtrb fixed bin (18) unsigned unal,		/* base of trace table */
  1    36       3 crtrc fixed bin (18) unsigned unal,		/* next trace table entry pointer */
  1    37       3 crreg fixed bin (17) unal,			/* pointer to fault reg storage area */
  1    38       3 crttb fixed bin (17) unal,			/* pointer to tib table base */
  1    39       3 crtte fixed bin (17) unal,			/* last addr in tib table */
  1    40       3 crdly fixed bin (17) unal,			/* pointer to delay table chain */
  1    41       3 crver char (4) unal,				/* mcs version number */
  1    42       3 crbrk fixed bin (17) unal,			/* pointer to breakpoint control table */
  1    43       3 crtsw bit (18) unal,				/* trace switch (zero=trace on) */
  1    44       3 crnxs fixed bin (17) unal,			/* pointer to next free small block */
  1    45       3 crnbs fixed bin (17) unal,			/* number of buffers devoted to small space */
  1    46       3 crcct fixed bin (17) unal,			/* pointer to first cct descriptor */
  1    47       3 crskd fixed bin (17) unal,			/* pointer to scheduler data block */
  1    48       3 cretb fixed bin (17) unal,			/* pointer to list of echo-negotiation bit tables */
  1    49       3 crcpt fixed bin (17) unal,			/* pointer to cpu page table */
  1    50       3 crpte fixed bin (17) unal,			/* pointer to variable cpu page table entry */
  1    51       3 crtsz fixed bin (17) unal,			/* size of trace data buffer */
  1    52       3 crmet bit (18) unal,				/* metering enabled */
  1    53       3 crtdt bit (18) unal,				/* 0 if no COLTS channel; set to TIB address if it exists */
  1    54       3 crbtm bit (18) unal,				/* address of time meters for buffer allocation/freeing */
  1    55       3 crnxe fixed bin (18) unsigned unal,		/* next available space in extended memory */
  1    56       3 crbpe fixed bin (17) unal,			/* buffer paging window table entry */
  1    57       3 pad (39) bit (18) unal,
  1    58       3 crcpr char (28) unal,				/* image copyright notice */
  1    59       3 crash_location bit (18) unal,			/* offset used for unresolved REF's */
  1    60       3 crash_opcode bit (18) unal,			/* crash instruction */
  1    61     2 hsla_mailbox (0:2),				/* loc 1000-3777 octal */
  1    62       3 subchannel (0:31) like hwcm;			/* HSLA hardware comm regions */
  1    63 
  1    64 dcl 1 icw aligned based,				/* Standard FNP Indirect Control Word */
  1    65     2 xfer_mode bit (3) unal,				/* transfer mode, bit-36 for dia */
  1    66     2 fnp_addr bit (15) unal,				/* address in fnp */
  1    67     2 pad bit (6) unal,				/* padding, exhaust bit */
  1    68     2 tally bit (12) unal;
  1    69 
  1    70 dcl 1 hwcm aligned based (hwcmp),			/* Standard hardware comm region */
  1    71     2 ricw0 like icw,				/* primary receive icw */
  1    72     2 ricw1 like icw,				/* secondary receive icw */
  1    73     2 sicw0 like icw,				/* primary send icw */
  1    74     2 sicw1 like icw,				/* secondary send icw */
  1    75     2 baw bit (18) unal,				/* base address word */
  1    76     2 sfcmp bit (18) unal,				/* pointer to sfcm for this channel */
  1    77     2 mask_reg bit (36) unal,				/* maskregister, subch 0 only */
  1    78     2 stat_icw like icw,				/* status icw */
  1    79     2 config_pcw bit (36) unal;			/* subchannel configuration */
  1    80 
  1    81 /* Tables used to describe the configuration of the FNP */
  1    82 
  1    83 dcl 1 iom_table (0: 15) unaligned based (itblp),		/* FNP IOM table */
  1    84     2 flags,
  1    85       3 mpx_chan bit (1) unal,			/* multiplexed channel */
  1    86       3 pad bit (6) unal,
  1    87       3 char_len bit (2) unal,
  1    88       3 dev_type bit (5) unal,			/* device type on this channel */
  1    89       3 dev_speed bit (4) unal,			/* for those devices with speed (LSLA) */
  1    90     2 table bit (18) unal;				/* pointer to secondary table for mpx_chan */
  1    91 
  1    92 dcl 1 lsla_table (0:52) based (tblp) unal,		/* LSLA table, entry one per slot */
  1    93     2 flags,
  1    94       3 pad1 bit (11) unal,
  1    95       3 ibm_code bit (1) unal,			/* if 6-bit odd parity */
  1    96       3 pad2 bit (3) unal,
  1    97       3 slot_id bit (3) unal,				/* slot type this slot */
  1    98     2 tib_addr fixed bin (17) unal;			/* pointer to tib */
  1    99 
  1   100 dcl 1 hsla_table (0:31) based (tblp) unal,		/* HSLA table, entry one per subchannel */
  1   101     2 flags,
  1   102       3 conc_chan bit (1) unal,			/* concentrator attached to this channnel */
  1   103       3 private_line bit (1) unal,			/* indicates direct connect or pl modem for sync chan */
  1   104       3 async bit (1) unal,				/* on if async channel */
  1   105       3 option1 bit (1) unal,				/* three option specification bits */
  1   106       3 option2 bit (1) unal,
  1   107       3 modem_type bit (4) unal,			/* indicator of type of modem on this channel */
  1   108       3 line_type bit (5) unal,			/* line type of this channel */
  1   109       3 dev_speed bit (4) unal,			/* speed of this subchannel */
  1   110     2 tib_addr fixed bin (17) unal;			/* addr of tib for this subchannel */
  1   111 
  1   112 dcl (memp, itblp, tblp, hwcmp) ptr;
  1   113 
  1   114 dcl (DIA init ("00010"b),				/* dev_type definitions */
  1   115      HSLA init ("00011"b),
  1   116      LSLA init ("00100"b),
  1   117      CONSOLE init ("00101"b),
  1   118      PRINTER init ("00110"b)) bit (5) int static options (constant);
  1   119 
  1   120 /* END INCLUDE FILE mcs_memory_map.incl.pl1 */
      190 
      191 
      192 	memp,
      193 	     dumpp = a_dumpp;			/* copy argument for better access code */
      194 	statp = addr (st);				/* init random pointers */
      195 	octalp = addr (octal);
      196 	retp = addr (retstring);
      197 
      198 	if first_200_words = "0"b then return;		/* assume in this case there's no core */
      199 
      200 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      201*   *
      202*   *	PRINT OUT DUMP HEADER
      203*   *
      204*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      205 
      206 	call date_time_ (comm_reg.crldt, date_time_bound);
      207 	call date_time_ (comm_reg.crbdt, date_time_booted);
      208 
      209 	call ioa_$rsnnl ("^2/^3-DATANET FNP MEMORY DUMP^2/FNP ^a, MCS Version ^a^/Bound ^a^/Booted ^a^3/",
      210 	     retstring, retl, get_fnp_name_ (number), comm_reg.crver,
      211 	     date_time_bound, date_time_booted);	/* format dump header */
      212 	call ios_$write ("od_output_", retp, 0, retl, nelemt, st); /* output the string */
      213 	if st_code ^= 0 then do;			/* error? */
      214 err:
      215 	     call com_err_ (st_code, "online_355_dump_", "Attempted to write to output file."); /* bitch */
      216 	     return;
      217 	end;
      218 
      219 
      220 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      221*   *
      222*   *	PRINT OUT FAULT DATA
      223*   *
      224*   *	Print cause of fault, and regs in the following order:
      225*   *
      226*   *	IC, Indicators, A, Q, X1, X2, X3, Enable Register, Elapsed Timer
      227*   *
      228*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      229 
      230 	faultp = addr (core_fnp.words (comm_reg.crreg));	/* make pointer to fault data */
      231 	if fault_data.fault_number > 7 then type = "ABORT"; /* not a processor fault */
      232 	else type = "FAULT";
      233 						/* format fault/abort message */
      234 	if fault_data.fault_number = 3		/* illegal opcode */
      235 	then do;
      236 	     die_ptr = addr (core_fnp.words (fault_data.regs (1) - 1)); /* get word it died on */
      237 	     if die_word.op_code = die_op		/* software-induced crash */
      238 	     then do;
      239 		module_num = bin (die_word.mod_num, 4);
      240 		module_name = od355_msgs$die_list (module_num).name;
      241 
      242 		reasonp = ptr (addr (od355_msgs$), od355_msgs$die_list (module_num).offset);
      243 		reasonp = ptr (reasonp, reasonp -> message_offsets (die_word.reason));
      244 
      245 		call ioa_$rsnnl ("CRASH REASON:^2/^a: ^a^3/", retstring, retl, module_name, reasonp -> die_reason.msg);
      246 		call ios_$write ("od_output_", retp, 0, retl, nelemt, st);
      247 		if st_code ^= 0 then go to err;
      248 	     end;
      249 	end;
      250 
      251 	if fault_data.regs (1) = 0 then		/* no fault if IC = 0 */
      252 	     call ioa_$rsnnl ("^a: ^a^2/", retstring, retl, type, "NONE      ");
      253 	else call ioa_$rsnnl ("^a: ^a^2/", retstring, retl, type, faults (fault_data.fault_number));
      254 	call ios_$write ("od_output_", retp, 0, retl, nelemt, st); /* output it */
      255 	if st_code ^= 0 then go to err;		/* error */
      256 
      257 	call format_355_dump_line_ (addr (fault_data.regs (1)), 9, octalp); /* get regs in octal */
      258 						/* format regs output line */
      259 	call ioa_$rsnnl ("IC ^a, IR ^a, A ^a, Q ^a, X1 ^a, X2 ^a, X3 ^a, ER ^a, ET ^a^/",
      260 	     retstring, retl, octal_overlay (1).word, octal_overlay (2).word, octal_overlay (3).word,
      261 	     octal_overlay (4).word, octal_overlay (5).word, octal_overlay (6).word, octal_overlay (7).word,
      262 	     octal_overlay (8).word, octal_overlay (9).word);
      263 
      264 	call ios_$write ("od_output_", retp, 0, retl, nelemt, st); /* output it */
      265 	if st_code ^= 0 then go to err;		/* error */
      266 
      267 	mem_size = comm_reg.crmem;			/* copy out fnp mem size for better code */
      268 	if mem_size ^= MEM_24K - 1 then		/* check for clobbered mem size */
      269 	     if mem_size ^= MEM_32K - 1 then
      270 		if mem_size ^= MEM_64K - 1 then
      271 		     if mem_size ^= MEM_128K - 1 then
      272 			if mem_size ^= MEM_256K - 1
      273 			then do;			/* memory really messed up */
      274 			     mem_size = MEM_64K - 1;	/* use 64K if clobbered */
      275 			     print_trace = "0"b;	/* better not try to do trace */
      276 			end;
      277 			else;
      278 		     else;
      279 		else;
      280 	     else;
      281 	else;
      282 
      283 /* * * * * * * * * * * * * * * * * * * * * * *  * * * * *
      284*   *
      285*   *	PRINT OUT MODULE CHAIN
      286*   *
      287*   *	Search through fnp module chain and print out module names
      288*   *	and starting addresses, also saving them for later use.
      289*   *
      290*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      291 
      292 
      293 	modch.nmodules = 0;
      294 	cur_chain = comm_reg.crmod;			/* get beginning of module chain */
      295 	if cur_chain ^= 0
      296 	then if cur_chain < mem_size then do;		/* if there's anything in it, print header */
      297 		call ioa_$rs ("^3/MODULE CHAIN", retstring, retl);
      298 		call ios_$write ("od_output_", retp, 0, retl, nelemt, st);
      299 	     end;
      300 
      301 	do i = 1 by 1 while (cur_chain > 0 & cur_chain < mem_size);
      302 	     modch.address (i) = core_fnp.words (cur_chain+3); /* get address from chain entry */
      303 						/* convert bcd module name */
      304 	     do k = 1 to 4;				/* in module chain block */
      305 						/* get ascii translation */
      306 		substr (modch.name (i), k, 1) = xlate (fixed (substr (addr (core_fnpb.words (cur_chain+1)) -> bit36,
      307 		     (k-1)*6+1, 6), 6));
      308 	     end;
      309 	     modch.nmodules = modch.nmodules + 1;
      310 
      311 	     call ioa_$rs ("^6x^4a  ^5o", retstring, retl, modch.name (i), modch.address (i));
      312 	     call ios_$write ("od_output_", retp, 0, retl, nelemt, st);
      313 
      314 	     cur_chain = core_fnp.words (cur_chain);	/* chase chain */
      315 	end;
      316 
      317 	modch.address (i) = MEM_32K;			/* no module is loaded above 32K */
      318 	modch.name (i) = "";
      319 	modch.address (i+1) = MEM_256K + 1;		/* mark last entry so address won't pass it */
      320 
      321 
      322 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      323*   *
      324*   *	PRINT OUT CONTENTS OF TRACE TABLE
      325*   *
      326*   *	Find the oldest entry in the trace table and then print all
      327*   *	the entries in order of age. The first word of an entry is a coded 18-bit
      328*   *	word which consists of three fields. The first 6 bits contain the number
      329*   *	of the module that made the entry; the next 6 bits contain
      330*   *	the trace type within the module; and the last 6 bits contain
      331*   *	the number of data words in the entry. This word is followed by
      332*   *	an 18-bit clock time and a variable number of data items.
      333*   *	The logical end of the trace table is marked by a word containing
      334*   *	the pattern 525252(8).
      335*   *
      336*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      337 
      338 
      339 
      340 	if print_trace then do;
      341 	     mod_chain = comm_reg.crmod;		/* do validity checking on trace pointers */
      342 	     if comm_reg.crtrb <= mod_chain | comm_reg.crtrb > mem_size |
      343 	     comm_reg.crtrc <= mod_chain | comm_reg.crtrc > mem_size
      344 	     then go to skip_trace_print;
      345 
      346 	     if core_fnp.words (comm_reg.crtrc) = 0 then go to skip_trace_print;
      347 
      348 	     call ioa_$rsnnl ("^3/^3-TRACE TABLE^3/", retstring, retl); /* format trace table header */
      349 	     call ios_$write ("od_output_", retp, 0, retl, nelemt, st); /* output it */
      350 	     if st_code ^= 0 then go to err;		/* error */
      351 
      352 	     i = comm_reg.crtrc;			/* put current trace index in i */
      353 trace_start:
      354 	     if core_fnpb.words (i) = end_of_table then do; /* at end of trace table? */
      355 
      356 		i = comm_reg.crtrb;			/* reset trace index to start of table */
      357 		go to trace_start;			/* look some more */
      358 	     end;
      359 
      360 	     if core_fnpb.words (i) = logical_end then go to trace_done; /* found end of table */
      361 
      362 	     call format_fnp_trace_msg_ (addr (core_fnpb.words (i)), addr (modch), trace_edit);
      363 	     retstring = trace_edit || nl;
      364 	     call ios_$write ("od_output_", retp, 0, length (trace_edit) + 1, nelemt, st);
      365 	     if st_code ^= 0 then go to err;
      366 
      367 	     i = i + bin (substr (core_fnpb.words (i), 13, 6)) + 2; /* bump to next entry */
      368 						/* (include header and time words) */
      369 	     go to trace_start;
      370 	end;
      371 	else do;
      372 
      373 skip_trace_print:
      374 	     call ioa_$rsnnl ("^3/Dump of trace data not attempted.  The comm_reg appears to be inconsistent.", retstring, retl);
      375 	     call ios_$write ("od_output_", retp, 0, retl, nelemt, st);
      376 	     if st_code ^= 0 then go to err;
      377 	end;
      378 
      379 trace_done:
      380 
      381 
      382 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      383*   *
      384*   *	DUMP CONTENTS OF MEMORY
      385*   *
      386*   *	Each print line will consist of four fields. The first is the
      387*   *	absolute address being printed followed possibly by a "*" if
      388*   *	some lines were skipped due to duplication. The second is the
      389*   *	name of the module in the area being dumped (or blanks if no
      390*   *	module. The third is the relative address within that module,
      391*   *	and the fourth is the octal representation of 8 18 bit words.
      392*   *
      393*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      394 
      395 
      396 
      397 	dump_line.space1, dump_line.space2, dump_line.space3, dump_line.space4,
      398 	     dump_line.module, dump_line.star = "";	/* init blanks */
      399 	dump_line.nl = nl;
      400 	call ioa_$rsnnl ("^|^3-MEMORY DUMP^3/", retstring, retl); /* output header */
      401 	call ios_$write ("od_output_", retp, 0, retl, nelemt, st);
      402 	if st_code ^= 0 then go to err;		/* error */
      403 
      404 	locs_to_dump = mem_size;			/* get size of fnp core */
      405 	modx = 1;					/* initialize module chain index */
      406 	next_module_start = modch.address (1);		/* and next module's starting address */
      407 
      408 	curlp = dumpp;				/* init current line pointer for dup line checking */
      409 	go to skip_dup_test;
      410 mem_dump_loop:
      411 	if curlp -> dup_copy = dupp -> dup_copy then do;	/* check for duplicate lines */
      412 	     dump_line.star = "*";			/* print out a star on next line to show dup */
      413 	     go to dup_line;
      414 	end;
      415 
      416 skip_dup_test:
      417 	dupp = curlp;				/* save prt to current line for dup checking */
      418 	call format_355_dump_line_$line (curlp, 8, addr (dump_line.eight_words),
      419 	     addr (dump_line.abs_addr), cur_loc, addr (dump_line.rel_addr), rel_addr); /* format a dump line */
      420 
      421 	do i = 1 to 16;				/* format ascii data */
      422 	     ch_val = fixed (dump_chars (i), 17);
      423 	     if ch_val < 32 | ch_val > 126 then ch_val = 32;
      424 	     unspec (dump_line.ascii (i)) = bit (fixed (ch_val, 9), 9);
      425 	end;
      426 	call ios_$write ("od_output_", addr (dump_line), 0, length (string (dump_line)), nelemt, st); /* output the line */
      427 	if st_code ^= 0 then go to err;		/* error */
      428 	dump_line.star = " ";
      429 
      430 dup_line:
      431 	rel_addr = rel_addr + 8;			/* bump rel and abs addresses */
      432 	cur_loc = cur_loc +8;
      433 	locs_to_dump = locs_to_dump - 8;		/* see if done yet */
      434 	if locs_to_dump <= 0 then do;
      435 
      436 	     if dump_line.star = "*" then do;		/* last line of dump always gets displayed */
      437 		rel_addr = rel_addr - 8;
      438 		cur_loc = cur_loc - 8;
      439 		go to skip_dup_test;
      440 	     end;
      441 	     call ioa_$rsnnl ("^/**DUMP FINISHED**^|", retstring, retl); /* let there be no misunderstanding */
      442 	     call ios_$write ("od_output_", retp, 0, retl, nelemt, st);
      443 	     if st_code ^= 0 then go to err;
      444 
      445 	     return;				/* all done */
      446 	end;
      447 
      448 	curlp = addrel (curlp, 4);			/* bump pointer to next line */
      449 	if cur_loc >= next_module_start then do;	/* if we are dumping a new module */
      450 
      451 	     if cur_loc >= MEM_32K then rel_addr = cur_loc; /* reset relative address */
      452 	     else rel_addr = cur_loc - next_module_start;
      453 	     dump_line.module = modch.name (modx);	/* set name */
      454 	     modx = modx + 1;			/* point to next chain entry */
      455 	     next_module_start = modch.address (modx);
      456 
      457 skip_chain_code:
      458 	end;
      459 	go to mem_dump_loop;			/* continue on */
      460 
      461 
      462      end online_355_dump_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/21/86  1507.9  online_355_dump_.pl1              >spec>install>1099>online_355_dump_.pl1
190          1    09/03/82  1045.1  mcs_memory_map.incl.pl1           >ldd>include>mcs_memory_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MEM_128K                               constant        fixed bin(19,0)          initial unsigned dcl 150 ref 268
MEM_24K                                constant        fixed bin(19,0)          initial unsigned dcl 147 ref 268
MEM_256K                               constant        fixed bin(19,0)          initial unsigned dcl 151 ref 268 319
MEM_32K                                constant        fixed bin(19,0)          initial unsigned dcl 148 ref 268 317 451
MEM_64K                                constant        fixed bin(19,0)          initial unsigned dcl 149 ref 268 274
a_dumpp                                parameter       pointer                  dcl 56 ref 12 192
abs_addr                        000353 automatic       char(6)                  level 2 packed unaligned dcl 117 set ref 418 418
addr                                                   builtin function         dcl 186 ref 194 195 196 230 236 242 257 257 259 259
                                                                                  259 259 259 259 259 259 259 306 362 362 362 362
                                                                                  418 418 418 418 418 418 426 426
addrel                                                 builtin function         dcl 186 ref 448
address                   2     000403 automatic       fixed bin(24,0)          array level 3 dcl 139 set ref 302* 311* 317* 319*
                                                                                  406 455
ascii                    23(27) 000353 automatic       char(1)                  array level 2 packed unaligned dcl 117 set ref 424*
bin                                                    builtin function         dcl 186 ref 239 367
bit                                                    builtin function         dcl 186 ref 424
bit36                                  based           bit(36)                  unaligned dcl 92 ref 306
ch_val                          000310 automatic       fixed bin(17,0)          dcl 86 set ref 422* 423 423 423* 424
com_err_                        000012 constant        entry                    external dcl 42 ref 214
comm_reg                320            based           structure                level 2 unaligned dcl 1-15
core_fnp                               based           structure                level 1 dcl 113
core_fnpb                              based           structure                level 1 dcl 110
crbdt                   322            based           fixed bin(71,0)          level 3 dcl 1-15 set ref 207*
crldt                   320            based           fixed bin(71,0)          level 3 dcl 1-15 set ref 206*
crmem                   324(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 1-15 ref 267
crmod                   327(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 1-15 ref 294 341
crreg                   332            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-15 ref 230
crtrb                   331            based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 1-15 ref 342
                                                                                  342 356
crtrc                   331(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 1-15 ref 342
                                                                                  342 346 352
crver                   334            based           char(4)                  level 3 packed unaligned dcl 1-15 set ref 209*
cur_chain                       000275 automatic       fixed bin(18,0)          unsigned dcl 80 set ref 294* 295 295 301 301 302 306
                                                                                  314* 314
cur_loc                         000274 automatic       fixed bin(17,0)          initial dcl 79 set ref 79* 418* 432* 432 438* 438
                                                                                  449 451 451 452
curlp                           000270 automatic       pointer                  dcl 77 set ref 408* 410 416 418* 422 448* 448
date_time_                      000024 constant        entry                    external dcl 47 ref 206 207
date_time_booted                000165 automatic       char(24)                 unaligned dcl 67 set ref 207* 209*
date_time_bound                 000157 automatic       char(24)                 unaligned dcl 66 set ref 206* 209*
die_op                          002715 constant        bit(5)                   initial unaligned dcl 153 ref 237
die_ptr                         000304 automatic       pointer                  dcl 84 set ref 236* 237 239 243
die_reason                             based           structure                level 1 dcl 97
die_word                               based           structure                level 1 packed unaligned dcl 101
dump_chars                             based           bit(9)                   array unaligned dcl 106 ref 422
dump_line                       000353 automatic       structure                level 1 dcl 117 set ref 426 426 426 426
dumpp                           000106 automatic       pointer                  dcl 61 set ref 192* 198 230 236 302 306 314 346 353
                                                                                  360 362 362 367 408
dup_copy                               based           bit(144)                 unaligned dcl 72 ref 410 410
dupp                            000272 automatic       pointer                  dcl 78 set ref 410 416*
eight_words               5(18) 000353 automatic       char(55)                 level 2 packed unaligned dcl 117 set ref 418 418
end_of_table                           constant        bit(18)                  initial unaligned dcl 169 ref 353
entries                   1     000403 automatic       structure                array level 2 dcl 139
fault_data                             based           structure                level 1 dcl 130
fault_number              4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 130 ref 231 234 253
faultp                          000100 automatic       pointer                  dcl 55 set ref 230* 231 234 236 251 253 257 257
faults                          000020 constant        char(16)                 initial array unaligned dcl 155 set ref 253*
first_200_words                        based           bit(7200)                dcl 93 ref 198
fixed                                                  builtin function         dcl 186 ref 306 422 424
format_355_dump_line_           000022 constant        entry                    external dcl 46 ref 257
format_355_dump_line_$line      000020 constant        entry                    external dcl 45 ref 418
format_fnp_trace_msg_           000026 constant        entry                    external dcl 48 ref 362
get_fnp_name_                   000030 constant        entry                    external dcl 49 ref 209 209
hwcm                                   based           structure                level 1 dcl 1-70
i                               000110 automatic       fixed bin(17,0)          dcl 62 set ref 301* 302 306 311 311* 317 318 319
                                                                                  352* 353 356* 360 362 362 367* 367 367 421* 422
                                                                                  424*
icw                                    based           structure                level 1 dcl 1-64
ioa_$rs                         000016 constant        entry                    external dcl 44 ref 297 311
ioa_$rsnnl                      000014 constant        entry                    external dcl 43 ref 209 245 251 253 259 348 373 400
                                                                                  441
ios_$write                      000010 constant        entry                    external dcl 41 ref 212 246 254 264 298 312 349 364
                                                                                  375 401 426 442
k                               000111 automatic       fixed bin(17,0)          dcl 62 set ref 304* 306 306*
length                                 based           fixed bin(8,0)           level 2 in structure "die_reason" packed unaligned
                                                                                  dcl 97 in procedure "online_355_dump_" ref 245 245
length                                                 builtin function         dcl 186 in procedure "online_355_dump_" ref 364 426
                                                                                  426
locs_to_dump                    000265 automatic       fixed bin(18,0)          unsigned dcl 75 set ref 404* 433* 433 434
logical_end                            constant        bit(18)                  initial unaligned dcl 170 ref 360
low_mem                                based           structure                level 1 dcl 1-15
mem_size                        000263 automatic       fixed bin(18,0)          unsigned dcl 73 set ref 267* 268 268 268 268 268
                                                                                  274* 295 301 342 342 404
memp                            000500 automatic       pointer                  dcl 1-112 set ref 192* 206 207 209 230 267 294 341
                                                                                  342 342 342 342 346 352 356
message_offsets                        based           bit(18)                  array dcl 95 ref 243
mod_chain                       000264 automatic       fixed bin(17,0)          dcl 74 set ref 341* 342 342
mod_num                                based           bit(4)                   level 2 packed unaligned dcl 101 ref 239
modch                           000403 automatic       structure                level 1 dcl 139 set ref 362 362
module                    2     000353 automatic       char(4)                  level 2 packed unaligned dcl 117 set ref 379* 453*
module_name                     000277 automatic       char(12)                 unaligned dcl 82 set ref 240* 245*
module_num                      000302 automatic       fixed bin(17,0)          dcl 83 set ref 239* 240 242
modx                            000276 automatic       fixed bin(17,0)          dcl 81 set ref 405* 453 454* 454 455
msg                       0(09)        based           char                     level 2 packed unaligned dcl 97 set ref 245*
name                      1     000403 automatic       char(4)                  array level 3 in structure "modch" dcl 139
                                                                                  in procedure "online_355_dump_" set ref 306* 311*
                                                                                  318* 453
name                            000034 external static char(12)                 array level 2 in structure "od355_msgs$die_list"
                                                                                  dcl 180 in procedure "online_355_dump_" ref 240
nelemt                          000112 automatic       fixed bin(17,0)          dcl 62 set ref 212* 246* 254* 264* 298* 312* 349*
                                                                                  364* 375* 401* 426* 442*
next_module_start               000262 automatic       fixed bin(17,0)          dcl 71 set ref 406* 449 452 455*
nl                       27(27) 000353 automatic       char(1)                  level 2 in structure "dump_line" packed unaligned
                                                                                  dcl 117 in procedure "online_355_dump_" set ref
                                                                                  399*
nl                              002714 constant        char(1)                  initial unaligned dcl 171 in procedure
                                                                                  "online_355_dump_" ref 363 399
nmodules                        000403 automatic       fixed bin(17,0)          level 2 dcl 139 set ref 293* 309* 309
number                                 parameter       fixed bin(17,0)          dcl 57 set ref 12 209* 209*
octal                           000176 automatic       char(200)                unaligned dcl 69 set ref 195 259 259 259 259 259 259
                                                                                  259 259 259
octal_overlay                          based           structure                array level 1 packed unaligned dcl 135
octalp                          000260 automatic       pointer                  dcl 70 set ref 195* 257*
od355_msgs$                     000032 external static fixed bin(17,0)          dcl 178 set ref 242
od355_msgs$die_list             000034 external static structure                array level 1 dcl 180
offset                    3     000034 external static fixed bin(17,0)          array level 2 dcl 180 ref 242
op_code                   0(04)        based           bit(5)                   level 2 packed unaligned dcl 101 ref 237
print_trace                     000352 automatic       bit(1)                   initial unaligned dcl 88 set ref 88* 275* 340
ptr                                                    builtin function         dcl 186 ref 242 243
reason                    0(09)        based           fixed bin(8,0)           level 2 packed unaligned dcl 101 ref 243
reasonp                         000306 automatic       pointer                  dcl 85 set ref 242* 243* 243 243 245
regs                                   based           fixed bin(17,0)          array level 2 packed unaligned dcl 130 set ref 236
                                                                                  251 257 257
rel_addr                  3(09) 000353 automatic       char(6)                  level 2 in structure "dump_line" packed unaligned
                                                                                  dcl 117 in procedure "online_355_dump_" set ref
                                                                                  418 418
rel_addr                        000266 automatic       fixed bin(17,0)          initial dcl 76 in procedure "online_355_dump_" set
                                                                                  ref 76* 418* 430* 430 437* 437 451* 452*
retl                            000156 automatic       fixed bin(17,0)          dcl 65 set ref 209* 212* 245* 246* 251* 253* 254*
                                                                                  259* 264* 297* 298* 311* 312* 348* 349* 373* 375*
                                                                                  400* 401* 441* 442*
retp                            000154 automatic       pointer                  dcl 64 set ref 196* 212* 246* 254* 264* 298* 312*
                                                                                  349* 364* 375* 401* 442*
retstring                       000113 automatic       char(132)                unaligned dcl 63 set ref 196 209* 245* 251* 253*
                                                                                  259* 297* 311* 348* 363* 373* 400* 441*
space1                    1(27) 000353 automatic       char(1)                  level 2 packed unaligned dcl 117 set ref 379*
space2                    3     000353 automatic       char(1)                  level 2 packed unaligned dcl 117 set ref 379*
space3                    4(27) 000353 automatic       char(3)                  level 2 packed unaligned dcl 117 set ref 379*
space4                   23(09) 000353 automatic       char(2)                  level 2 packed unaligned dcl 117 set ref 379*
st                              000102 automatic       bit(72)                  dcl 58 set ref 194 212* 246* 254* 264* 298* 312*
                                                                                  349* 364* 375* 401* 426* 442*
st_code                                based           fixed bin(17,0)          dcl 59 set ref 213 214* 247 255 265 350 365 376 402
                                                                                  427 443
star                      1(18) 000353 automatic       char(1)                  level 2 packed unaligned dcl 117 set ref 379* 412*
                                                                                  428* 436
statp                           000104 automatic       pointer                  dcl 60 set ref 194* 213 214 247 255 265 350 365 376
                                                                                  402 427 443
string                                                 builtin function         dcl 186 ref 426 426
substr                                                 builtin function         dcl 186 set ref 306* 306 367
trace_edit                      000311 automatic       varying char(128)        dcl 87 set ref 362* 363 364
type                            000174 automatic       char(5)                  unaligned dcl 68 set ref 231* 232* 251* 253*
unspec                                                 builtin function         dcl 186 set ref 424*
word                                   based           char(6)                  array level 2 packed unaligned dcl 135 set ref 259*
                                                                                  259* 259* 259* 259* 259* 259* 259* 259*
words                                  based           fixed bin(17,0)          array level 2 in structure "core_fnp" packed
                                                                                  unaligned dcl 113 in procedure "online_355_dump_"
                                                                                  set ref 230 236 302 314 346
words                                  based           bit(18)                  array level 2 in structure "core_fnpb" packed
                                                                                  unaligned dcl 110 in procedure "online_355_dump_"
                                                                                  set ref 306 353 360 362 362 367
xlate                           000000 constant        char(1)                  initial array unaligned dcl 159 ref 306

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONSOLE                                internal static bit(5)                   initial unaligned dcl 1-114
DIA                                    internal static bit(5)                   initial unaligned dcl 1-114
HSLA                                   internal static bit(5)                   initial unaligned dcl 1-114
LSLA                                   internal static bit(5)                   initial unaligned dcl 1-114
PRINTER                                internal static bit(5)                   initial unaligned dcl 1-114
hsla_table                             based           structure                array level 1 packed unaligned dcl 1-100
hwcmp                                  automatic       pointer                  dcl 1-112
iom_table                              based           structure                array level 1 packed unaligned dcl 1-83
itblp                                  automatic       pointer                  dcl 1-112
lsla_table                             based           structure                array level 1 packed unaligned dcl 1-92
mem_array                              based           structure                level 1 dcl 1-11
tblp                                   automatic       pointer                  dcl 1-112

NAMES DECLARED BY EXPLICIT CONTEXT.
dup_line                        002544 constant        label                    dcl 430 ref 413
err                             000526 constant        label                    dcl 214 ref 247 255 265 350 365 376 402 427 443
mem_dump_loop                   002361 constant        label                    dcl 410 ref 459
online_355_dump_                000320 constant        entry                    external dcl 12
skip_chain_code                 002705 constant        label                    dcl 457
skip_dup_test                   002372 constant        label                    dcl 416 ref 409 439
skip_trace_print                002150 constant        label                    dcl 373 ref 342 346
trace_done                      002237 constant        label                    dcl 379 ref 360
trace_start                     002001 constant        label                    dcl 353 ref 357 369

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3054        3112    2716        3064
Length      3330    2716        36         201     136           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
online_355_dump_                    450 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
online_355_dump_         000100 faultp                      online_355_dump_
                         000102 st                          online_355_dump_
                         000104 statp                       online_355_dump_
                         000106 dumpp                       online_355_dump_
                         000110 i                           online_355_dump_
                         000111 k                           online_355_dump_
                         000112 nelemt                      online_355_dump_
                         000113 retstring                   online_355_dump_
                         000154 retp                        online_355_dump_
                         000156 retl                        online_355_dump_
                         000157 date_time_bound             online_355_dump_
                         000165 date_time_booted            online_355_dump_
                         000174 type                        online_355_dump_
                         000176 octal                       online_355_dump_
                         000260 octalp                      online_355_dump_
                         000262 next_module_start           online_355_dump_
                         000263 mem_size                    online_355_dump_
                         000264 mod_chain                   online_355_dump_
                         000265 locs_to_dump                online_355_dump_
                         000266 rel_addr                    online_355_dump_
                         000270 curlp                       online_355_dump_
                         000272 dupp                        online_355_dump_
                         000274 cur_loc                     online_355_dump_
                         000275 cur_chain                   online_355_dump_
                         000276 modx                        online_355_dump_
                         000277 module_name                 online_355_dump_
                         000302 module_num                  online_355_dump_
                         000304 die_ptr                     online_355_dump_
                         000306 reasonp                     online_355_dump_
                         000310 ch_val                      online_355_dump_
                         000311 trace_edit                  online_355_dump_
                         000352 print_trace                 online_355_dump_
                         000353 dump_line                   online_355_dump_
                         000403 modch                       online_355_dump_
                         000500 memp                        online_355_dump_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      date_time_                    format_355_dump_line_         format_355_dump_line_$line
format_fnp_trace_msg_         get_fnp_name_                 ioa_$rs                       ioa_$rsnnl
ios_$write

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
od355_msgs$                   od355_msgs$die_list




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000314        76 000325        79 000326        88 000327       192 000331       194 000336       195 000340
    196 000342       198 000344       206 000352       207 000367       209 000405       212 000463       213 000524
    214 000526       216 000556       230 000557       231 000566       232 000577       234 000602       236 000605
    237 000616       239 000622       240 000630       242 000642       243 000647       245 000660       246 000723
    247 000764       251 000766       253 001034       254 001076       255 001137       257 001141       259 001160
    264 001251       265 001312       267 001314       268 001320       274 001340       275 001342       293 001343
    294 001344       295 001350       297 001353       298 001400       301 001441       302 001450       304 001465
    306 001473       308 001521       309 001523       311 001524       312 001563       314 001624       315 001635
    317 001637       318 001644       319 001646       340 001651       341 001653       342 001660       346 001676
    348 001706       349 001732       350 001773       352 001775       353 002001       356 002013       357 002017
    360 002020       362 002022       363 002047       364 002065       365 002132       367 002134       369 002147
    373 002150       375 002174       376 002235       379 002237       399 002254       400 002256       401 002305
    402 002346       404 002350       405 002352       406 002354       408 002356       409 002360       410 002361
    412 002367       413 002371       416 002372       418 002374       421 002433       422 002441       423 002452
    424 002460       425 002471       426 002473       427 002540       428 002542       430 002544       432 002546
    433 002547       434 002551       436 002553       437 002560       438 002562       439 002564       441 002565
    442 002614       443 002655       445 002657       448 002660       449 002663       451 002666       452 002672
    453 002674       454 002700       455 002701       459 002705


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
