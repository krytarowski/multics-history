	COMPILATION LISTING OF SEGMENT iodd_signal_handler_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1336.4 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 iodd_signal_handler_: proc;
       13 
       14 /* Unclaimed signal handler for I/O Daemon driver process. In "test"
       15*   mode it will invoke the "debug" command; otherwise it will attempt
       16*   to move on to whatever is to be done next.
       17**/
       18 
       19 /* Coded September 1973 by Robert S. Coren */
       20 /* Modified January 1975 by J. C. Whitmore to work with iodd_ */
       21 /* Modified November 1975 by M. A. Braida to special case seg_fault_error on user's segment */
       22 /* Modified Sept 1977 by J. C. Whitmore to not terminate driver status segs (now done by iodd_) */
       23 /* Modified by J. C. Whitmore, 11/78, to use iodd_msg_ instead of ioa_ for messages */
       24 /* Modified by J. C. Whitmore, 3/79, to correct a misplaced end statement */
       25 /* Modified BIM 84-01-06 for default_restart, quiet_restart */
       26 /* Modified by C. Marker, 02/23/85, to use version 5 message segments */
       27 
       28 
       29 /****^  HISTORY COMMENTS:
       30*  1) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       31*     audit(88-10-19,Wallman), install(88-10-28,MR12.2-1199):
       32*     Upgraded to version 5 iod tables.
       33*                                                   END HISTORY COMMENTS */
       34 
       35 
       36 	dcl     bel_string		 char (40) aligned int static;
       37 	dcl     stars		 char (50) aligned int static options (constant) init ((5)"**********");
       38 	dcl     condition		 char (32);	/* fixed length string for condition name */
       39 	dcl     io_stat		 bit (72) aligned;
       40 	dcl     ec		 fixed bin (35);	/* error code */
       41 
       42 	dcl     ios_$attach		 entry (char (*) aligned, char (*), char (*), char (*), bit (72) aligned);
       43 	dcl     ios_$order		 entry (char (*), char (*), ptr, bit (72) aligned);
       44 	dcl     iodd_msg_		 entry options (variable);
       45 	dcl     new_proc		 entry ();
       46 	dcl     iodd_quit_handler_$command_level entry ();
       47 	dcl     debug		 entry;
       48 	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2) aligned);
       49 	dcl     condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char (*), ptr, ptr);
       50 	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
       51 	dcl     continue_to_signal_	 entry (fixed bin (35));
       52 	dcl     get_system_free_area_	 entry (ptr);
       53 
       54 	dcl     areap		 ptr;
       55 	dcl     msgp		 ptr;
       56 	dcl     msg_len		 fixed bin;
       57 	dcl     err_message		 char (msg_len) based (msgp);
       58 	dcl     sys_area		 area (262144) based (areap);
       59 
       60 	dcl     id		 char (24) int static options (constant) init ("iodd_signal_handler_");
       61 	dcl     master		 fixed bin int static options (constant) init (1);
       62 	dcl     both		 fixed bin int static options (constant) init (0);
       63 	dcl     error		 fixed bin int static options (constant) init (2);
       64 	dcl     normal		 fixed bin int static options (constant) init (1);
       65 
       66 	dcl     recursion_count	 fixed bin int static init (0); /* depth of signals */
       67 
       68 	dcl     (null, fixed, addr, baseno) builtin;
       69 
       70 	dcl     (resume, any_other, cleanup, daemon_again, daemon_new_device) condition;
       71 
       72 
       73 
       74 	dcl     1 local_condition_info aligned like condition_info;
       75 
       76 /*  */
       77 	on cleanup call ios_$order ("user_i/o", "start", null, io_stat);
       78 
       79 	local_condition_info.version = condition_info_version_1; /* version of the condition_info structure */
       80 
       81 	call find_condition_info_ (null (), addr (local_condition_info), ec); /* get condition data */
       82 
       83 	condition = local_condition_info.condition_name;	/* change to fixed string for the compiler */
       84 
       85 	if condition = "alrm" then do;		/* pass these on...quits will never come here */
       86 pass_on:		call continue_to_signal_ (ec);	/* pass the condition on to someone else */
       87 		return;
       88 	     end;
       89 	condition_info_header_ptr = local_condition_info.info_ptr;
       90 	if condition = "cput" then goto pass_on;
       91 	if condition = "finish" then goto pass_on;
       92 	if iodd_static.test_entry
       93 	then if condition = "mme2" then go to pass_on;	/* to be able to use debug */
       94 	     else if condition = "program_interrupt" then go to pass_on;
       95 	if condition = "command_error" then return;
       96 	if condition = "command_question" then return;
       97 	if condition_info_header_ptr ^= null
       98 	then if condition_info_header.quiet_restart |
       99 		condition_info_header.default_restart
      100 	     then go to pass_on;
      101 
      102 	if condition = "daemon_new_device" then go to proc_dies; /* this procedure should never see this */
      103 
      104 /*	that's all for the benign system conditions, time to be careful */
      105 
      106 	if ^iodd_static.recursion_flag then recursion_count = 0; /* coming from known state? */
      107 
      108 	iodd_static.recursion_flag = "1"b;		/* start watching for trouble */
      109 
      110 	recursion_count = recursion_count + 1;		/* increment the counter */
      111 
      112 	if recursion_count > 4 then call new_proc;	/* maximum trouble, calls for drastic action */
      113 
      114 	if recursion_count = 3 then
      115 	     call iodd_msg_ (error, both, 0, id, "recursive errors, driver may new_proc.");
      116 
      117 	if condition = "no_coord" then /* for this condition.... */
      118 	     if iodd_static.no_coord_flag then do;	/* be sure process is ready to accept */
      119 
      120 /*		This condition is signalled if the coordinator process has gone away. We will attempt */
      121 /*		to reinitialize, but not until the coordinator process id recorded in iodc_data */
      122 /*		has changed (signifying the advent of a new coordinator). */
      123 
      124 		     iodd_static.re_init_in_progress = "1"b; /* let others know what happened */
      125 
      126 		     call iodd_msg_ (error, both, 0, id, """no_coord"" condition signalled.");
      127 
      128 		     go to iodd_static.no_coord_label;	/* invoke all the cleanup handlers */
      129 
      130 		end;
      131 
      132 	if condition = "re_init" | condition = "resume" then do;
      133 		on any_other signal daemon_new_device;
      134 
      135 /*		This condition is signalled when the driver is in trouble.  We will attempt */
      136 /*		to reinitialize the device specified by the operator without asking */
      137 /*		him to input the device again. */
      138 
      139 		iodd_static.re_init_in_progress = "1"b;
      140 		call iodd_msg_ (error, both, 0, id, "Driver starting reinitialization");
      141 
      142 		go to iodd_static.re_init_label;	/* first catch the cleanup handlers */
      143 	     end;
      144 
      145 
      146 	if condition = "io_error" then do;		/* in this case we have to be careful about */
      147 						/* writing on the slave stream to avoid another error */
      148 						/* the control terminal probably got hung up */
      149 		call timer_manager_$sleep (5, "11"b);	/* give the hangup handler a chance */
      150 
      151 		iodd_static.master_hold = "1"b;	/* force operator attention */
      152 
      153 		if recursion_count > 3 then go to proc_dies; /* multiple times is too much */
      154 		call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat); /* only talk to the master */
      155 		if iodd_static.slave.active | iodd_static.ctl_term.attached then do;
      156 			iodd_static.forms = "0"b;	/* can't simulate forms now */
      157 			iodd_static.slave.allow_quits = "0"b;
      158 			iodd_static.slave.accept_input = "0"b;
      159 			iodd_static.slave.print_errors = "0"b;
      160 
      161 			call iodd_msg_ (error, both, 0, id,
      162 			     "^/^a^/Condition ""io_error"" signalled.  Slave functions have been terminated.^/^a",
      163 			     stars, stars);
      164 		     end;
      165 
      166 		if request_in_progress then do;	/* maybe we can continue */
      167 			call iodd_msg_ (normal, both, 0, "", "Current request will be restarted.");
      168 			signal daemon_again;	/* restart the request */
      169 		     end;
      170 	     end;
      171 
      172 	if condition = "seg_fault_error" then do;	/* find out if current segment caused the condition */
      173 
      174 		mcp = local_condition_info.mc_ptr;	/* set machine condition ptr */
      175 		scup = addr (mc.scu);		/* find segment number in machine condition */
      176 		if fixed (baseno (iodd_static.segptr), 17, 0) = fixed (scu.tpr.tsr, 17, 0) then
      177 		     /* if the segment numbers are the same ... */
      178 		     go to driver_default;		/* skip the long error message */
      179 	     end;
      180 
      181 	call get_system_free_area_ (areap);
      182 
      183 	msgp = null;
      184 	call condition_interpreter_ (areap, msgp, msg_len, 3, local_condition_info.mc_ptr, condition, local_condition_info.wc_ptr, local_condition_info.info_ptr);
      185 
      186 	if msgp ^= null then do;
      187 		call iodd_msg_ (error, both, 0, id, err_message);
      188 		free msgp -> err_message in (sys_area);
      189 	     end;
      190 	else call iodd_msg_ (error, both, 0, id, "^a condition signalled.", condition);
      191 
      192 	if condition = "stack"
      193 	then go to proc_dies;			/* we will not attempt to deal with this */
      194 
      195 	on resume go to continue;			/* to get around CP in test mode */
      196 
      197 	if iodd_static.test_entry
      198 	then do;					/* give programmer chance to find out what happened */
      199 		if ^iodd_static.initialized then do;	/* be careful about blocking before init is done */
      200 			call iodd_msg_ (error, master, 0, id, "Warning - initialization is not complete");
      201 						/* some commands won't work */
      202 			call iodd_msg_ (normal, master, 0, "", "Calling debug");
      203 			call debug;		/* this should do the trick */
      204 		     end;
      205 		else call iodd_quit_handler_$command_level (); /* give programmer a shot */
      206 		return;				/* assume problem was fixed, so start */
      207 	     end;
      208 
      209 continue:
      210 
      211 	revert resume;				/* drop the handler...we may signal it */
      212 	if recursion_count > 1 then
      213 	     call iodd_msg_ (error, both, 0, id,
      214 		"^a^/Condition ^a signalled while handling unclaimed signal.^/^a^a",
      215 		stars, condition, stars, bel_string);
      216 
      217 	if recursion_count > 2 then do;		/* after two conditions, give up */
      218 proc_dies:
      219 		on any_other call new_proc;		/* dont take chances, we are in trouble */
      220 
      221 		call iodd_msg_ (error, both, 0, id, "New process will be created.");
      222 		call new_proc ();
      223 	     end;
      224 
      225 driver_default:
      226 
      227 	if iodd_static.initialized then do;		/* is there enough data to do more? */
      228 
      229 		call driver_default_handler (addr (local_condition_info)); /* see if the driver module needs the condition */
      230 						/* the driver module is responsible for cleaning up */
      231 						/* any requests in progress */
      232 		signal resume;			/* if we return, pass back to iodd_listen_ */
      233 	     end;
      234 	else do;					/* no data, tell someone and commit suicide */
      235 		call iodd_msg_ (error, both, 0, id, "^a^/Condition ^a occured before full initialization.",
      236 		     stars, condition);
      237 		signal daemon_new_device;
      238 	     end;
      239 	go to proc_dies;				/* this should never happen, but .... */
      240 
      241 init: entry (a_ptr);
      242 
      243 	dcl     a_ptr		 ptr;
      244 
      245 	stat_p = a_ptr;
      246 	if iodd_static.test_entry then bel_string = "";	/* null for testing */
      247 	else bel_string = (40)"";			/* 40 bells (007(8)) */
      248 
      249 	return;
      250  /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  1     2 
  1     3 /* Structure for find_condition_info_.
  1     4*
  1     5*   Written 1-Mar-79 by M. N. Davidoff.
  1     6**/
  1     7 
  1     8 /* automatic */
  1     9 
  1    10      declare condition_info_ptr     pointer;
  1    11 
  1    12 /* based */
  1    13 
  1    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  1    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 condition_name     char (32) varying,	/* name of condition */
  1    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  1    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  1    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  1    21 	     2 flags	      unaligned,
  1    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  1    23 	       3 pad1	      bit (35),
  1    24 	     2 pad2	      bit (36),
  1    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  1    26 	     2 pad3	      (4) bit (36);
  1    27 
  1    28 /* internal static */
  1    29 
  1    30      declare condition_info_version_1
  1    31 			      fixed binary internal static options (constant) initial (1);
  1    32 
  1    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      250 
      251  /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  2     2 /* format: style2 */
  2     3 
  2     4      declare condition_info_header_ptr
  2     5 			      pointer;
  2     6      declare 1 condition_info_header
  2     7 			      aligned based (condition_info_header_ptr),
  2     8 	     2 length	      fixed bin,		/* length in words of this structure */
  2     9 	     2 version	      fixed bin,		/* version number of this structure */
  2    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  2    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  2    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  2    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  2    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  2    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  2    16 	       3 pad	      bit (32) unaligned,
  2    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  2    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  2    19 
  2    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      251 
      252  /* BEGIN INCLUDE FILE ... driver_ptr_list.incl.pl1   */
  3     2 
  3     3 /* This is a list of pointers to the driver status segments used by this process */
  3     4 
  3     5 
  3     6 
  3     7 dcl list_ptr pointer;		/* should be set to iodd_static.driver_list_ptr */
  3     8 
  3     9 dcl 1 driver_ptr_list based(list_ptr),
  3    10        2 number fixed bin,		/* number of pointer entries */
  3    11        2 list_pad fixed bin,		/* pad to even word boundry */
  3    12        2 stat_seg(0 refer(driver_ptr_list.number)),
  3    13           3 stat_segp ptr;		/* pointer to driver status seg(i) */
  3    14 
  3    15 
  3    16 /* END INCLUDE FILE ... driver_ptr_list.incl.pl1  */
      252 
      253  /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  4     7*     Ancient History
  4     8*     Coded by Robert S. Coren August 1973
  4     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  4    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  4    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  4    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  4    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  4    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  4    16*     to denote accounting ^= nothing.
  4    17*                                                   END HISTORY COMMENTS */
  4    18 
  4    19 
  4    20 /* status data for a logical device driver */
  4    21 
  4    22 /* format: style4 */
  4    23 
  4    24 dcl  driver_status_ptr ptr;
  4    25 dcl  1 driver_status aligned based (driver_status_ptr),
  4    26        2 req_type_label char (32),			/* string to describe the request type */
  4    27        2 dev_name_label char (32),			/* string to describe the device */
  4    28        2 device_id char (32),				/* minor device name used by this logical driver */
  4    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  4    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  4    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  4    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  4    33        2 request_pending bit (36),			/* locking word for communication with coord */
  4    34 						/* 0 = ready for a request  */
  4    35 						/* driver pid = don't bug me */
  4    36 						/* coord  pid = got a request */
  4    37        2 status_flags,
  4    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  4    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  4    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  4    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  4    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  4    43          3 pad bit (31) unal,
  4    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  4    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  4    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  4    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  4    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  4    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  4    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  4    51 						/* for this logical driver */
  4    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  4    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  4    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  4    55        2 dev_out_stream char (32),			/* output stream for minor device */
  4    56        2 dev_in_stream char (32),			/* input stream for minor device */
  4    57        2 elem_size fixed bin,				/* element size for the stream */
  4    58        2 message_type fixed bin,			/* expected format of user request */
  4    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  4    60        2 forms_validation_ptr ptr,			/* forms validation data */
  4    61        2 dev_ptr1 ptr,				/* another one */
  4    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  4    63        2 dev_fb2 fixed bin,				/* and another */
  4    64        2 dev_fb3 fixed bin,				/* and another */
  4    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  4    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  4    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  4    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  4    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  4    70        2 generic_type char (32),			/* generic type of this minor device */
  4    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  4    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  4    73        2 desc_pad (13) fixed bin,
  4    74        2 message fixed bin;				/* place-holder for copy of request message */
  4    75 
  4    76 
  4    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
      253 
      254  /* BEGIN INCLUDE FILE. . . iod_event_message.incl.pl1 */
  5     2 
  5     3 /* Format of event message used to signal io_daemon coordinator */
  5     4 /* and the acknowledge message for signalling the driver */
  5     5 
  5     6 dcl event_message fixed bin(71);
  5     7 
  5     8 dcl 1 ev_msg based aligned,
  5     9 	2 code fixed bin(17) unal,		/* Purpose of wakeup: */
  5    10 					/* 0 = request completed */
  5    11 					/* 1 = request completed, new request wanted */
  5    12 					/* 2 = restart */
  5    13 					/* 3 = save  */
  5    14 					/* 4 = logout */
  5    15 	2 minor_dev_index fixed bin(17) unal,	/* minor device index for driver sending this message */
  5    16 	2 seq_id fixed bin(35);		/* id of request to be restarted/saved */
  5    17 
  5    18 dcl 1 ack_msg aligned based,			/* driver command acknowledgement message */
  5    19 	2 code fixed bin (35),		/* error_table_ code */
  5    20 	2 num fixed bin (35);		/* number for further info */
  5    21 
  5    22 /* END INCLUDE FILE. . . iod_event_message.incl.pl1 */
      254 
      255  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  6     7*     Ancient History
  6     8*     Created by J. Stern, 1/20/75
  6     9*     Modified by J. C. Whitmore April 1978 for enhancements
  6    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  6    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  6    12*     q_group_tab
  6    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    15*     Change version number to reflect changes in q_group_tab and
  6    16*     iod_device_tab for laser printer support.  Added font tables.
  6    17*                                                   END HISTORY COMMENTS */
  6    18 
  6    19 
  6    20 /* format: style4 */
  6    21 
  6    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  6    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  6    24        2 version char (8),				/* version of this structure */
  6    25        2 date_time_compiled fixed bin (71),
  6    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  6    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  6    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  6    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  6    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  6    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  6    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  6    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  6    34        2 text_strings_offset fixed bin (18),
  6    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  6    36 
  6    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  6    38 dcl  text_strings_ptr ptr;
  6    39 dcl  1 text_strings aligned based (text_strings_ptr),
  6    40        2 length fixed bin,
  6    41        2 chars char (1 refer (text_strings.length)) unaligned;
  6    42 
  6    43 /* this defines text offsets used to locate i/o daemon tables strings in
  6    44*   the text_strings structure */
  6    45 dcl  1 text_offset based,
  6    46        2 first_char fixed bin (18) unsigned unaligned,
  6    47        2 total_chars fixed bin (18) unsigned unaligned;
  6    48 
  6    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  6    50 
  6    51 
  6    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      255 
      256  /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  7     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  7     7*     Add support for logout_on_hangup option.
  7     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  7     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  7    10*     Add head/tail_sheet entry variables and paper_type variable.
  7    11*                                                   END HISTORY COMMENTS */
  7    12 
  7    13 /* format: style4 */
  7    14 
  7    15 dcl  stat_p int static ptr;
  7    16 
  7    17 dcl  1 iodd_static based (stat_p) aligned,
  7    18 
  7    19 /*    The first part is set only once for a device driver */
  7    20 
  7    21        2 ithp ptr,					/* pointer to iod tables header */
  7    22        2 ltp ptr,					/* pointer to line table */
  7    23        2 idtp ptr,					/* pointer to device tab */
  7    24        2 mdtp ptr,					/* pointer to minor device table */
  7    25        2 qgtp ptr,					/* pointer to q_group table */
  7    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  7    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  7    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  7    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  7    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  7    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  7    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  7    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  7    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  7    35        2 log_stream char (32),			/* stream name used for log output */
  7    36        2 master_input char (32),			/* master console input stream for commands */
  7    37        2 master_output char (32),			/* master console output stream for messages */
  7    38        2 master_out ptr,				/* master output iocbp */
  7    39        2 master_in ptr,				/* master input iocbp */
  7    40        2 log_iocbp ptr,				/* log output iocbp */
  7    41        2 error_io ptr,				/* error i/o iocbp */
  7    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  7    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  7    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  7    45        2 device_dim char (32),			/* dim which drives the major device */
  7    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  7    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  7    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  7    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  7    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  7    51        2 major_device char (32),			/* name of the major device */
  7    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  7    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  7    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  7    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  7    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  7    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  7    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  7    59 
  7    60 /*    driver module entrypoints are defined by the following entry variables */
  7    61 
  7    62        2 driver_init entry variable options (variable),
  7    63        2 driver_request entry variable options (variable),
  7    64        2 driver_command entry variable options (variable),
  7    65        2 driver_default_handler entry variable options (variable),
  7    66 
  7    67 /*    entrypoints for head/tail_sheet_ entries */
  7    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  7    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  7    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  7    71 
  7    72        2 paper_type fixed bin,			/* type of paper being used */
  7    73 						/* 1 = single sheet */
  7    74 						/* 2 = continuous forms */
  7    75 
  7    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  7    77 
  7    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  7    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  7    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  7    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  7    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  7    83        2 output_device char (32),			/* name of minor device currently in use */
  7    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  7    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  7    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  7    87        2 segptr ptr,				/* ptr to current user segment being processed */
  7    88        2 flags,					/* control flags */
  7    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  7    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  7    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  7    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  7    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  7    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  7    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  7    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  7    97          3 step bit (1) unal,				/* run in step mode */
  7    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  7    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  7   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  7   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  7   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  7   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  7   104          3 pad bit (21) unal,				/* unused space */
  7   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  7   106          3 slave_input char (32),			/* slave input stream name */
  7   107          3 slave_output char (32),			/* slave output stream name */
  7   108          3 slave_pad fixed bin,			/* allocation breakage */
  7   109          3 slave_in ptr,				/* slave input iocbp */
  7   110          3 slave_out ptr,				/* slave output iocbp */
  7   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  7   112          3 active bit (1) unal,			/* on if there is a slave */
  7   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  7   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  7   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  7   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  7   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  7   118          3 priv2 bit (1) unal,
  7   119          3 priv3 bit (1) unal,
  7   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  7   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  7   122        2 ctl_term,					/* control terminal data */
  7   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  7   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  7   125          3 ctl_pad fixed bin,				/* allocation breakage */
  7   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  7   127          3 ctl_input char (32),			/* ctl input stream name */
  7   128          3 ctl_output char (32),			/* ctl output stream name */
  7   129          3 ctl_io char (32),				/* ctl i/o stream name */
  7   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  7   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  7   132          3 ctl_device char (32),			/* ctl terminal device name */
  7   133          3 form_type char (16),			/* format type if printing forms */
  7   134          3 attached bit (1) unal,			/* ctl term attached to process */
  7   135          3 forms bit (1) unal,			/* on if printing forms */
  7   136          3 pad bit (34) unal,
  7   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  7   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  7   139 
  7   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
      256 
      257  /*  */
  8     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  8     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  8     4 /* Modified 07/07/76 by Morris for fault register data */
  8     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  8     6 /* Modified '82 to make values constant */
  8     7 
  8     8 /* words 0-15 pointer registers */
  8     9 
  8    10 dcl  mcp ptr;
  8    11 
  8    12 dcl 1 mc based (mcp) aligned,
  8    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  8    14    (2 regs,					/* registers */
  8    15       3 x (0:7) bit (18),				/* index registers */
  8    16       3 a bit (36),					/* accumulator */
  8    17       3 q bit (36),					/* q-register */
  8    18       3 e bit (8),					/* exponent */
  8    19       3 pad1 bit (28),
  8    20       3 t bit (27),					/* timer register */
  8    21       3 pad2 bit (6),
  8    22       3 ralr bit (3),				/* ring alarm register */
  8    23 
  8    24     2 scu (0:7) bit (36),
  8    25 
  8    26     2 mask bit (72),				/* mem controller mask at time of fault */
  8    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  8    28     2 errcode fixed bin (35),				/* fault handler's error code */
  8    29     2 fim_temp,
  8    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  8    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  8    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  8    33     2 fault_reg bit (36),				/* fault register */
  8    34     2 pad2 bit (1),
  8    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  8    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  8    37     2 fault_time bit (54),				/* time of fault */
  8    38 
  8    39     2 eis_info (0:7) bit (36)) unaligned;
  8    40 
  8    41 
  8    42 dcl (apx fixed bin init (0),
  8    43      abx fixed bin init (1),
  8    44      bpx fixed bin init (2),
  8    45      bbx fixed bin init (3),
  8    46      lpx fixed bin init (4),
  8    47      lbx fixed bin init (5),
  8    48      spx fixed bin init (6),
  8    49      sbx fixed bin init (7)) internal static options (constant);
  8    50 
  8    51 
  8    52 
  8    53 
  8    54 dcl  scup ptr;
  8    55 
  8    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  8    57 
  8    58 
  8    59 /*	WORD (0)		*/
  8    60 
  8    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  8    62       3 prr bit (3),				/* procedure ring register */
  8    63       3 psr bit (15),				/* procedure segment register */
  8    64       3 p bit (1),					/* procedure privileged bit */
  8    65 
  8    66     2 apu,					/* APPENDING UNIT STATUS */
  8    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  8    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  8    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  8    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  8    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  8    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  8    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  8    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  8    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  8    76       3 ptw bit (1),				/* Fetch of PTW */
  8    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  8    78       3 fap bit (1),				/* Fetch of final address paged */
  8    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  8    80       3 fabs bit (1),				/* Fetch of final address absolute */
  8    81 
  8    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  8    83 
  8    84 
  8    85 /*	WORD (1)		*/
  8    86 
  8    87     2 fd,						/* FAULT  DATA */
  8    88       3 iro bit (1),				/* illegal ring order */
  8    89       3 oeb bit (1),				/* out of execute bracket */
  8    90       3 e_off bit (1),				/* no execute */
  8    91       3 orb bit (1),				/* out of read bracket */
  8    92       3 r_off bit (1),				/* no read */
  8    93       3 owb bit (1),				/* out of write bracket */
  8    94       3 w_off bit (1),				/* no write */
  8    95       3 no_ga bit (1),				/* not a gate */
  8    96       3 ocb bit (1),				/* out of call bracket */
  8    97       3 ocall bit (1),				/* outward call */
  8    98       3 boc bit (1),				/* bad outward call */
  8    99       3 inret bit (1),				/* inward return */
  8   100       3 crt bit (1),				/* cross ring transfer */
  8   101       3 ralr bit (1),				/* ring alarm register */
  8   102       3 am_er bit (1),				/* associative memory fault */
  8   103       3 oosb bit (1),				/* out of segment bounds */
  8   104       3 paru bit (1),				/* processor parity upper */
  8   105       3 parl bit (1),				/* processor parity lower */
  8   106       3 onc_1 bit (1),				/* op not complete type 1 */
  8   107       3 onc_2 bit (1),				/* op not complete type 2 */
  8   108 
  8   109     2 port_stat,					/* PORT  STATUS */
  8   110       3 ial bit (4),				/* illegal action lines */
  8   111       3 iac bit (3),				/* illegal action channel */
  8   112       3 con_chan bit (3),				/* connect channel */
  8   113 
  8   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  8   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  8   116 
  8   117 
  8   118 /*	WORD (2)		*/
  8   119 
  8   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  8   121       3 trr bit (3),				/* temporary ring register */
  8   122       3 tsr bit (15),				/* temporary segment register */
  8   123 
  8   124     2 pad2 bit (9),
  8   125 
  8   126     2 cpu_no bit (3),				/* CPU number */
  8   127 
  8   128     2 delta bit (6),				/* tally modification DELTA */
  8   129 
  8   130 
  8   131 /*	WORD (3)		*/
  8   132 
  8   133     2 word3 bit (18),
  8   134 
  8   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  8   136       3 tsna,					/* Word 1 status */
  8   137         4 prn bit (3),				/* Word 1  PR  number */
  8   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  8   139       3 tsnb,					/* Word 2  status */
  8   140         4 prn bit (3),				/* Word 2  PR  number */
  8   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  8   142       3 tsnc,					/* Word 3  status */
  8   143         4 prn bit (3),				/* Word 3  PR  number */
  8   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  8   145 
  8   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  8   147 
  8   148 
  8   149 /* 	WORD (4)		*/
  8   150 
  8   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  8   152 
  8   153     2 ir,						/* INDICATOR  REGISTERS */
  8   154       3 zero bit (1),				/* zero indicator */
  8   155       3 neg bit (1),				/* negative indicator */
  8   156       3 carry bit (1),				/* carryry indicator */
  8   157       3 ovfl bit (1),				/* overflow indicator */
  8   158       3 eovf bit (1),				/* eponent overflow */
  8   159       3 eufl bit (1),				/* exponent underflow */
  8   160       3 oflm bit (1),				/* overflow mask */
  8   161       3 tro bit (1),				/* tally runout */
  8   162       3 par bit (1),				/* parity error */
  8   163       3 parm bit (1),				/* parity mask */
  8   164       3 bm bit (1),					/* ^bar mode */
  8   165       3 tru bit (1),				/* truncation mode */
  8   166       3 mif bit (1),				/* multi-word instruction mode */
  8   167       3 abs bit (1),				/* absolute mode */
  8   168       3 hex bit (1),				/* hexadecimal exponent mode */
  8   169       3 pad bit (3),
  8   170 
  8   171 
  8   172 /*	WORD (5)		*/
  8   173 
  8   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  8   175 
  8   176     2 cu,						/* CONTROL UNIT STATUS */
  8   177       3 rf bit (1),					/* on first cycle of repeat instr */
  8   178       3 rpt bit (1),				/* repeat instruction */
  8   179       3 rd bit (1),					/* repeat double instruction */
  8   180       3 rl bit (1),					/* repeat link instruciton */
  8   181       3 pot bit (1),				/* IT  modification */
  8   182       3 pon bit (1),				/* return type instruction */
  8   183       3 xde bit (1),				/* XDE from Even location */
  8   184       3 xdo bit (1),				/* XDE from Odd  location */
  8   185       3 poa bit (1),				/* operation preparation */
  8   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  8   187       3 its bit (1),				/* ITS modification */
  8   188       3 if bit (1),					/* fault occured during instruction fetch */
  8   189 
  8   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  8   191 
  8   192 
  8   193 /*	WORDS (6,7)	*/
  8   194 
  8   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  8   196 
  8   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  8   198 
  8   199 
  8   200 
  8   201 
  8   202 
  8   203 
  8   204 /*	ALTERNATE   SCU  DECLARATION		*/
  8   205 
  8   206 
  8   207 dcl 1 scux based (scup) aligned,
  8   208 
  8   209    (2 pad0 bit (36),
  8   210 
  8   211     2 fd,						/* GROUP II  FAULT DATA */
  8   212       3 isn bit (1),				/* illegal segment number */
  8   213       3 ioc bit (1),				/* illegal op  code  */
  8   214       3 ia_am bit (1),				/* illegal address - modifier */
  8   215       3 isp bit (1),				/* illegal slave  procedure */
  8   216       3 ipr bit (1),				/* illegal procedure */
  8   217       3 nea bit (1),				/* non existent address */
  8   218       3 oobb bit (1),				/* out of bounds */
  8   219       3 pad bit (29),
  8   220 
  8   221     2 pad2 bit (36),
  8   222 
  8   223     2 pad3a bit (18),
  8   224 
  8   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  8   226       3 prn bit (3),				/* PR  number */
  8   227       3 prv bit (1),				/* PR  valid bit */
  8   228 
  8   229     2 pad3b bit (6)) unaligned,
  8   230 
  8   231     2 pad45 (0:1) bit (36),
  8   232 
  8   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  8   234 
  8   235 
  8   236 
  8   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      257 
      258  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  9     2 /* format: style3,idind30 */
  9     3 
  9     4 /* structure returned when message is read from a message segment */
  9     5 
  9     6 
  9     7 dcl	mseg_message_info_ptr	pointer;
  9     8 
  9     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  9    10 	  2 version		char (8) aligned,
  9    11 	  2 message_code		fixed bin,
  9    12 	  2 control_flags		unaligned,
  9    13 	    3 own			bit (1),
  9    14 	    3 delete		bit (1),
  9    15 	    3 pad			bit (34),
  9    16 	  2 ms_ptr		ptr,		/* pointer to message */
  9    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  9    18 	  2 ms_id			bit (72),		/* unique ID of message */
  9    19 						/* input in some cases */
  9    20 	  2 ms_access_class		bit (72),		/* message access class */
  9    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  9    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  9    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  9    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  9    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  9    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  9    27 
  9    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  9    29 
  9    30 declare	(
  9    31 	MSEG_READ_FIRST		init (1),
  9    32 	MSEG_READ_LAST		init (2),
  9    33 	MSEG_READ_SPECIFIED		init (3),
  9    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  9    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  9    36 	fixed bin int static options (constant);
  9    37 
  9    38 declare  (MSEG_READ_OWN		init ("1"b),
  9    39 	MSEG_READ_DELETE		init ("01"b)
  9    40 	)			bit (36) aligned internal static options (constant);
  9    41 
  9    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      258 
      259  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 10     2 
 10     3 /* Descriptor associated with an I/O daemon request */
 10     4 /* Coded August 1973 by Robert S. Coren */
 10     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 10     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 10     7 
 10     8 dcl  1 request_descriptor based aligned,
 10     9 	2 mseg_message_info_copy like mseg_message_info,
 10    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 10    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 10    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 10    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 10    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 10    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 10    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 10    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 10    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 10    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 10    20 	2 driver_data bit(252),	/* driver maintained data */
 10    21 	2 flags,
 10    22 	   (3 continued,		/* unfinished by one driver and given to another */
 10    23 	    3 finished,
 10    24 	    3 restarted,
 10    25 	    3 cancelled,
 10    26 	    3 dont_delete,
 10    27 	    3 saved,		/* not to be freed */
 10    28 	    3 keep_in_queue,	/* keep request in queue */
 10    29 	    3 series_restart,	/* this request is part of restarted series */
 10    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 10    31 	    3 pad bit(27) unal,
 10    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 10    33 
 10    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
      259 
      260 
      261      end iodd_signal_handler_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1233.0  iodd_signal_handler_.pl1          >special_ldd>install>MR12.2-1199>iodd_signal_handler_.pl1
250          1    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
251          2    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
252          3    08/29/75  1310.5  driver_ptr_list.incl.pl1          >ldd>include>driver_ptr_list.incl.pl1
253          4    10/28/88  1226.9  driver_status.incl.pl1            >special_ldd>install>MR12.2-1199>driver_status.incl.pl1
254          5    09/28/78  1359.8  iod_event_message.incl.pl1        >ldd>include>iod_event_message.incl.pl1
255          6    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
256          7    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
257          8    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
258          9    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
259         10    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_ptr                                  parameter       pointer                  dcl 243 ref 241 245
accept_input            342(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  158*
action_flags              2            based           structure                level 2 dcl 2-6
active                  342            based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 155
addr                                                   builtin function         dcl 68 ref 81 81 175 229 229
allow_quits             342(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  157*
any_other                       000130 stack reference condition                dcl 70 ref 133 218
areap                           000114 automatic       pointer                  dcl 54 set ref 181* 184* 188
attached                436            based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 155
baseno                                                 builtin function         dcl 68 ref 176
bel_string                      000010 internal static char(40)                 dcl 36 set ref 212* 246* 247*
both                            000037 constant        fixed bin(17,0)          initial dcl 62 set ref 114* 126* 140* 161* 167* 187*
                                                                                  190* 212* 221* 235*
cleanup                         000136 stack reference condition                dcl 70 ref 77
condition                       000100 automatic       char(32)                 packed unaligned dcl 38 set ref 83* 85 90 91 92 94
                                                                                  95 96 102 117 132 132 146 172 184* 190* 192 212*
                                                                                  235*
condition_info                         based           structure                level 1 dcl 1-14
condition_info_header                  based           structure                level 1 dcl 2-6
condition_info_header_ptr       000212 automatic       pointer                  dcl 2-4 set ref 89* 97 97 97
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 1-30 ref 79
condition_interpreter_          000044 constant        entry                    external dcl 49 ref 184
condition_name            3     000160 automatic       varying char(32)         level 2 dcl 74 set ref 83
continue_to_signal_             000050 constant        entry                    external dcl 51 ref 86
ctl_term                344            based           structure                level 2 dcl 7-17
daemon_again                    000144 stack reference condition                dcl 70 ref 168
daemon_new_device               000152 stack reference condition                dcl 70 ref 133 237
debug                           000040 constant        entry                    external dcl 47 ref 203
default_restart           2(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-6 ref 97
driver_default_handler
                        224            based           entry variable           level 2 dcl 7-17 ref 229
ec                              000112 automatic       fixed bin(35,0)          dcl 40 set ref 81* 86*
err_message                            based           char                     packed unaligned dcl 57 set ref 187* 188
error                           000043 constant        fixed bin(17,0)          initial dcl 63 set ref 114* 126* 140* 161* 187* 190*
                                                                                  200* 212* 221* 235*
find_condition_info_            000046 constant        entry                    external dcl 50 ref 81
fixed                                                  builtin function         dcl 68 ref 176 176
flags                   310            based           structure                level 2 dcl 7-17
forms                   436(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  156*
get_system_free_area_           000052 constant        entry                    external dcl 52 ref 181
id                              000000 constant        char(24)                 initial packed unaligned dcl 60 set ref 114* 126*
                                                                                  140* 161* 187* 190* 200* 212* 221* 235*
info_ptr                 14     000160 automatic       pointer                  level 2 dcl 74 set ref 89 184*
initialized             310            based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 199 225
io_stat                         000110 automatic       bit(72)                  dcl 39 set ref 77* 154*
iodd_msg_                       000032 constant        entry                    external dcl 44 ref 114 126 140 161 167 187 190 200
                                                                                  202 212 221 235
iodd_quit_handler_$command_level
                                000036 constant        entry                    external dcl 46 ref 205
iodd_static                            based           structure                level 1 dcl 7-17
ios_$attach                     000026 constant        entry                    external dcl 42 ref 154
ios_$order                      000030 constant        entry                    external dcl 43 ref 77
local_condition_info            000160 automatic       structure                level 1 dcl 74 set ref 81 81 229 229
master                          000045 constant        fixed bin(17,0)          initial dcl 61 set ref 200* 202*
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  151*
mc                                     based           structure                level 1 dcl 8-12
mc_ptr                          000160 automatic       pointer                  level 2 dcl 74 set ref 174 184*
mcp                             000214 automatic       pointer                  dcl 8-10 set ref 174* 175
mseg_message_info                      based           structure                level 1 dcl 9-9
msg_len                         000120 automatic       fixed bin(17,0)          dcl 56 set ref 184* 187 187 188 188
msgp                            000116 automatic       pointer                  dcl 55 set ref 183* 184* 186 187 188
new_proc                        000034 constant        entry                    external dcl 45 ref 112 218 222
no_coord_flag           310(04)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 117
no_coord_label           32            based           label variable           level 2 dcl 7-17 ref 128
normal                          000045 constant        fixed bin(17,0)          initial dcl 64 set ref 167* 202*
null                                                   builtin function         dcl 68 ref 77 77 81 81 97 183 186
print_errors            342(03)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  159*
quiet_restart             2(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-6 ref 97
re_init_in_progress     310(11)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  124* 139*
re_init_label            26            based           label variable           level 2 dcl 7-17 ref 142
recursion_count                 000022 internal static fixed bin(17,0)          initial dcl 66 set ref 106* 110* 110 112 114 153 212
                                                                                  217
recursion_flag          310(03)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref 106
                                                                                  108*
request_descriptor                     based           structure                level 1 dcl 10-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 166
resume                          000122 stack reference condition                dcl 70 ref 195 209 232
scu                                    based           structure                level 1 dcl 8-56 in procedure "iodd_signal_handler_"
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 8-12 in procedure
                                                                                  "iodd_signal_handler_" set ref 175
scup                            000216 automatic       pointer                  dcl 8-54 set ref 175* 176
segptr                  306            based           pointer                  level 2 dcl 7-17 ref 176
slave                   312            based           structure                level 2 dcl 7-17
stars                           002011 constant        char(50)                 initial dcl 37 set ref 161* 161* 212* 212* 235*
stat_p                          000024 internal static pointer                  dcl 7-15 set ref 92 106 108 117 124 128 139 142 151
                                                                                  155 155 156 157 158 159 166 176 197 199 225 229
                                                                                  245* 246
sys_area                               based           area(262144)             dcl 58 ref 188
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 92 197
                                                                                  246
text_offset                            based           structure                level 1 packed packed unaligned dcl 6-45
timer_manager_$sleep            000042 constant        entry                    external dcl 48 ref 149
tpr                       2            based           structure                level 2 packed packed unaligned dcl 8-56
tsr                       2(03)        based           bit(15)                  level 3 packed packed unaligned dcl 8-56 ref 176
version                   2     000160 automatic       fixed bin(17,0)          level 2 dcl 74 set ref 79*
wc_ptr                   16     000160 automatic       pointer                  level 2 dcl 74 set ref 184*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 6-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 9-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 9-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 9-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 9-30
abx                                    internal static fixed bin(17,0)          initial dcl 8-42
ack_msg                                based           structure                level 1 dcl 5-18
apx                                    internal static fixed bin(17,0)          initial dcl 8-42
bbx                                    internal static fixed bin(17,0)          initial dcl 8-42
bpx                                    internal static fixed bin(17,0)          initial dcl 8-42
condition_info_ptr                     automatic       pointer                  dcl 1-10
driver_ptr_list                        based           structure                level 1 unaligned dcl 3-9
driver_status                          based           structure                level 1 dcl 4-25
driver_status_ptr                      automatic       pointer                  dcl 4-24
ev_msg                                 based           structure                level 1 dcl 5-8
event_message                          automatic       fixed bin(71,0)          dcl 5-6
iod_tables_hdr                         based           structure                level 1 dcl 6-23
ithp                                   automatic       pointer                  dcl 6-22
lbx                                    internal static fixed bin(17,0)          initial dcl 8-42
list_ptr                               automatic       pointer                  dcl 3-7
lpx                                    internal static fixed bin(17,0)          initial dcl 8-42
mseg_message_info_ptr                  automatic       pointer                  dcl 9-7
sbx                                    internal static fixed bin(17,0)          initial dcl 8-42
scux                                   based           structure                level 1 dcl 8-207
spx                                    internal static fixed bin(17,0)          initial dcl 8-42
text_strings                           based           structure                level 1 dcl 6-39
text_strings_ptr                       automatic       pointer                  dcl 6-38

NAMES DECLARED BY EXPLICIT CONTEXT.
continue                        001517 constant        label                    dcl 209 set ref 195
driver_default                  001664 constant        label                    dcl 225 ref 176
init                            001761 constant        entry                    external dcl 241
iodd_signal_handler_            000317 constant        entry                    external dcl 12
pass_on                         000425 constant        label                    dcl 86 ref 90 91 92 94 97
proc_dies                       001602 constant        label                    dcl 218 ref 102 153 192 239

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2240        2314    2026        2250
Length      2760    2026        54         430     211          16

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iodd_signal_handler_                292 external procedure  is an external procedure.  
on unit on line 77                   88 on unit               
on unit on line 133                  70 on unit               
on unit on line 195                  64 on unit               
on unit on line 218                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 bel_string                  iodd_signal_handler_
000022 recursion_count             iodd_signal_handler_
000024 stat_p                      iodd_signal_handler_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
iodd_signal_handler_     000100 condition                   iodd_signal_handler_
                         000110 io_stat                     iodd_signal_handler_
                         000112 ec                          iodd_signal_handler_
                         000114 areap                       iodd_signal_handler_
                         000116 msgp                        iodd_signal_handler_
                         000120 msg_len                     iodd_signal_handler_
                         000160 local_condition_info        iodd_signal_handler_
                         000212 condition_info_header_ptr   iodd_signal_handler_
                         000214 mcp                         iodd_signal_handler_
                         000216 scup                        iodd_signal_handler_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           tra_ext_2
signal_op           enable_op           ext_entry           int_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_interpreter_        continue_to_signal_           debug                         find_condition_info_
get_system_free_area_         iodd_msg_                     iodd_quit_handler_$command_level
ios_$attach                   ios_$order                    new_proc                      timer_manager_$sleep

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000316        77 000324        79 000374        81 000376        83 000415        85 000421        86 000425
     87 000434        89 000435        90 000437        91 000443        92 000447        94 000460        95 000464
     96 000470        97 000474       102 000504       106 000510       108 000514       110 000516       112 000517
    114 000526       117 000565       124 000576       126 000600       128 000633       132 000637       133 000647
    139 000667       140 000673       142 000726       146 000732       149 000736       151 000753       153 000757
    154 000762       155 001025       156 001035       157 001037       158 001041       159 001043       161 001045
    166 001106       167 001113       168 001146       172 001151       174 001155       175 001157       176 001162
    181 001175       183 001204       184 001206       186 001250       187 001254       188 001310       189 001315
    190 001316       192 001361       195 001365       197 001404       199 001411       200 001414       202 001447
    203 001504       204 001511       205 001512       206 001516       209 001517       212 001520       217 001576
    218 001602       221 001623       222 001657       225 001664       229 001671       232 001703       233 001706
    235 001707       237 001752       239 001755       241 001756       245 001766       246 001773       247 002002
    249 002005


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
