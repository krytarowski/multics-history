	COMPILATION LISTING OF SEGMENT vpn_cv_uid_path_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/28/84  1121.3 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 vpn_cv_uid_path_:
       12      procedure (P_uid_path_ptr, P_pathname, P_code);
       13 
       14 	entry_sw = "0"b;
       15 	goto COMMON;
       16 
       17 vpn_cv_uid_path_$ent:
       18      entry (P_uid_path_ptr, P_pathname, P_entry_uid, P_code);
       19 
       20 	entry_sw = "1"b;
       21 	goto COMMON;
       22 
       23 
       24 /* vpn_cv_uid_path_   -- a labyrinth of heuristics and suspicion */
       25 /* converts uid pathname to some real one for vtoc_pathname */
       26 /* Bernard Greenberg   05/76 */
       27 /* Cleaned up 06/21/81, W. Olin Sibert */
       28 /* Modified 1984-08-15 BIM to correctly update parent dir name. */
       29 
       30 
       31 dcl  P_uid_path_ptr pointer parameter;
       32 dcl  P_pathname char (*) parameter;
       33 dcl  P_entry_uid bit (36) aligned parameter;
       34 dcl  P_code fixed bin (35) parameter;
       35 
       36 dcl  entry_sw bit (1) aligned;
       37 dcl  depth fixed bin;
       38 dcl  level fixed bin;
       39 dcl  start fixed bin;
       40 dcl  uid_path_ptr pointer;
       41 dcl  input_uid_path (0 : 15) bit (36) aligned based (uid_path_ptr);
       42 dcl  uid_path (0 : 16) bit (36) aligned;		/* One larger, to make room for entry UID */
       43 dcl  dirp (0 : 16) pointer unaligned;
       44 
       45 dcl  rzdp pointer;
       46 dcl  refetch_count fixed bin;
       47 dcl  lookup_failures fixed bin;
       48 dcl  dir_size fixed bin (18);
       49 dcl 1 local_dir aligned like dir automatic;
       50 dcl 1 local_area aligned like area automatic;
       51 dcl 1 local_entry aligned like entry automatic;
       52 
       53 dcl  pathname char (512) varying;
       54 dcl  parent_dname char (512);
       55 dcl  parent_ename char (32);
       56 dcl  code fixed bin (35);
       57 dcl  real_code fixed bin (35);
       58 dcl  stop bit (1) aligned;
       59 
       60 dcl  com_err_ entry options (variable);
       61 dcl  pathname_ entry (character (*), character (*)) returns(character (168));
       62 dcl  phcs_$initiate entry (char (*), char (*), char (*), fixed bin (2), fixed bin (1), pointer, fixed bin (35));
       63 dcl  phcs_$ring_0_peek entry (pointer, pointer, fixed bin (18));
       64 dcl  phcs_$terminate_noname entry (pointer, fixed bin (35));
       65 
       66 dcl  error_table_$action_not_performed fixed bin (35) external static;
       67 dcl  error_table_$bad_uidpath fixed bin (35) external static;
       68 dcl  error_table_$dirseg fixed bin (35) external static;
       69 dcl  error_table_$incorrect_access fixed bin (35) external static;
       70 dcl  error_table_$no_dir fixed bin (35) external static;
       71 dcl  error_table_$noentry fixed bin (35) external static;
       72 dcl  error_table_$notadir fixed bin (35) external static;
       73 dcl  error_table_$vtoce_connection_fail fixed bin (35) external static;
       74 
       75 dcl  WHOAMI char (32) internal static options (constant) init ("vpn_cv_uid_path_");
       76 
       77 dcl  seg_fault_error condition;
       78 
       79 dcl (addr, binary, hbound, lbound, null, pointer, rtrim, size, unspec) builtin;
       80 
       81 /*  */
       82 
       83 COMMON:	uid_path_ptr = P_uid_path_ptr;
       84 
       85 	if unspec (input_uid_path) = ""b then do;	/* The ROOT has a UID path of all zeros */
       86 	     if ^entry_sw then do;			/* Just return it */
       87 REALLY_IS_ROOT:	P_pathname = ">";
       88 		P_code = 0;
       89 		return;
       90 		end;
       91 
       92 	     if P_entry_uid = "777777777777"b3 then goto REALLY_IS_ROOT;
       93 	     end; 				/* Fall through if wrong */
       94 
       95 	if input_uid_path (0) ^= "777777777777"b3 then do; /* Must start with the ROOT */
       96 	     P_code = error_table_$bad_uidpath;
       97 	     P_pathname = "--INVALID-UID-PATH--";
       98 	     return;
       99 	     end;
      100 
      101 	do depth = hbound (input_uid_path, 1) to 0 by -1	/* Find out how deep the tree is */
      102 		while (input_uid_path (depth) = ""b);
      103 	     end;
      104 
      105 	unspec (uid_path) = ""b;
      106 	do level = 0 to depth;			/* copy from the input */
      107 	     uid_path (level) = input_uid_path (level);
      108 	     end;
      109 
      110 	if entry_sw then do;			/* And add entry UID if needed */
      111 	     depth = depth + 1;
      112 	     uid_path (depth) = P_entry_uid;
      113 	     end;
      114 
      115 	on condition (seg_fault_error) begin;
      116 	     pathname = pathname || "(-SEG-FAULT-ERROR-)>-????-";
      117 	     stop = "1"b;
      118 	     real_code = error_table_$vtoce_connection_fail;
      119 	     goto NEXT_LEVEL;
      120 	     end;
      121 
      122 	dp = addr (local_dir);			/* These are the local copies we work with */
      123 	ep = addr (local_entry);
      124 	areap = addr (local_area);
      125 	dirp (*) = null ();
      126 	lookup_failures = 0;
      127 	start = 1;				/* Start with first non-root directory */
      128 
      129 START_OVER:
      130 	pathname = "";
      131 	parent_dname = ">";
      132 	parent_ename = "";
      133 	real_code = 0;
      134 	stop = "0"b;
      135 
      136 	do level = start to depth;
      137 	     if stop then pathname = pathname || ">-????-"; /* Can't find out any more */
      138 
      139 	     else do;				/* Otherwise, try to look it up */
      140 		call phcs_$initiate (parent_dname, parent_ename, "", 0, 0, rzdp, code);
      141 		if rzdp = null () then call cant_get_parent ();
      142 
      143 		else do;
      144 		     dirp (level) = rzdp;
      145 		     refetch_count = 0;
      146 RESTART_THIS_DIRECTORY:  call lookup_in_parent ();
      147 		     end;
      148 		end;
      149 
      150 NEXT_LEVEL:
      151 	     end; 				/* of loop looking up UIDs */
      152 
      153 MAIN_RETURN:
      154 	call terminate_dirs ();
      155 
      156 	P_pathname = pathname;			/* Copy output parameters */
      157 	P_code = real_code;
      158 	return;
      159 
      160 /*  */
      161 
      162 cant_get_parent: proc ();
      163 
      164 /* This procedure is called when the parent directory cannot be initiated for lookup.
      165*   It sets flags, adjusts the pathname, and returns. This first check goes off when
      166*   the directory is renamed between when it was found last time (by lookup in its parent)
      167*   and when we went to look for it this time. If this happens, we just punt and start
      168*   the whole lookup over again.
      169*   */
      170 
      171 	if code = error_table_$no_dir | code = error_table_$noentry then do;
      172 	     if lookup_failures > 6 then do;
      173 		call com_err_ (0, WHOAMI, "Names changing too fast: ^a", pathname_ (parent_dname, parent_ename));
      174 		real_code = error_table_$action_not_performed;
      175 		goto MAIN_RETURN;
      176 		end;
      177 
      178 	     lookup_failures = lookup_failures + 1;
      179 	     call terminate_dirs ();
      180 	     goto START_OVER;
      181 	     end;
      182 
      183 	stop = "1"b;			/* Don't try actually looking any more */
      184 	real_code = code;			/* Remember the first error */
      185 
      186 	if code = error_table_$dirseg then do;
      187 	     real_code = error_table_$incorrect_access; /* Adjust the code */
      188 	     pathname = pathname || ">-NO-ACCESS-";
      189 	     end;
      190 
      191 	else if code = error_table_$vtoce_connection_fail then
      192 	     pathname = pathname || ">-CONNECTION-FAILURE-";
      193 
      194 	else pathname = pathname || ">-CANT-GET-";
      195 
      196 	return;
      197 	end cant_get_parent;
      198 
      199 /*  */
      200 
      201 lookup_in_parent: proc ();
      202 
      203 /* This procedure performs the lookup of the target UID in its parent directory. */
      204 
      205 dcl  dirsw bit (1) aligned;
      206 dcl  ename char (32);
      207 
      208 
      209 	dir_size = 262143;				/* Until we find out for real */
      210 
      211 	call copy_from_dir (""b, dp, size (dir));	/* Get the header */
      212 	if dir.uid ^= uid_path (level - 1) then 	/* Not there any more */
      213 	     call refetch_dir ();
      214 
      215 	if dir.arearp = ""b then			/* Protect against bogus values */
      216 	     call refetch_dir ();
      217 
      218 	call copy_from_dir ((dir.arearp), areap, size (area));
      219 	dir_size = area.lu; 			/* This is the last used word in the directory */
      220 
      221 	call uid_to_ename (uid_path (level), ename, dirsw, code);
      222 	if code ^= 0 then do;
      223 	     stop = "1"b;				/* Do this no more */
      224 	     pathname = pathname || ">-NOT-LISTED-";
      225 	     if level = depth then			/* Final component */
      226 		real_code = error_table_$noentry;
      227 	     else real_code = error_table_$no_dir;
      228 	     return;
      229 	     end;
      230 
      231 	if parent_dname ^= ">" then			/* Update the parent dname & ename */
      232 	     parent_dname = rtrim (parent_dname) || ">";
      233 	parent_dname = rtrim (parent_dname) || parent_ename;
      234 	parent_ename = ename;
      235 
      236 	pathname = pathname || ">";
      237 	pathname = pathname || rtrim (ename);
      238 
      239 	if (level < depth) & (^dirsw) then do;
      240 	     stop = "1"b;				/* Stop if next entry isn't a directory */
      241 	     pathname = pathname || "(-NOT-A-DIR-)";
      242 	     real_code = error_table_$notadir;
      243 	     end;
      244 
      245 	return;
      246 	end lookup_in_parent;
      247 
      248 /*  */
      249 
      250 uid_to_ename: proc (P_uid, P_ename, P_dirsw, P_code);
      251 
      252 dcl  P_uid bit (36) aligned parameter;
      253 dcl  P_ename char (32) parameter;
      254 dcl  P_dirsw bit (1) aligned parameter;
      255 dcl  P_code fixed bin (35) parameter;
      256 
      257 dcl  e_rel bit (18) aligned;
      258 dcl  branch_count fixed bin;
      259 dcl  entry_count fixed bin;
      260 
      261 
      262 	entry_count = 0;
      263 	branch_count = 0;
      264 
      265 	do e_rel = dp -> dir.entryfrp
      266 		repeat (entry.efrp)
      267 		while (e_rel ^= ""b);
      268 
      269 	     call copy_from_dir (e_rel, ep, size (entry));
      270 
      271 	     if entry.bs then branch_count = branch_count + 1;
      272 	     if entry.uid = P_uid then do;
      273 		P_ename = addr (entry.primary_name) -> names.name;
      274 		P_dirsw = entry.dirsw;
      275 		P_code = 0;
      276 		return;
      277 		end;
      278 
      279 	     entry_count = entry_count + 1;
      280 	     if entry_count > 3121 then call refetch_dir (); /* No good */
      281 	     end;
      282 
      283 	if branch_count < (dir.seg_count + dir.dir_count) then call refetch_dir ();
      284 
      285 	P_code = 1;				  /* Indicate failure */
      286 	return;
      287 
      288 	end uid_to_ename;
      289 
      290 /*  */
      291 
      292 copy_from_dir: proc (P_offset, P_ptr, P_size);
      293 
      294 /* Procedure to copy things from the directory, avoiding OOB faults, etc. */
      295 
      296 dcl  P_offset bit (18) aligned parameter;
      297 dcl  P_ptr pointer parameter;
      298 dcl  P_size fixed bin (18) parameter;
      299 
      300 
      301 	if binary (P_offset, 18) + P_size > dir_size then
      302 	     call refetch_dir ();
      303 
      304 	call phcs_$ring_0_peek (pointer (rzdp, P_offset), P_ptr, P_size);
      305 
      306 	return;
      307 	end copy_from_dir;
      308 
      309 
      310 
      311 
      312 refetch_dir: proc ();
      313 
      314 /* This procedure is called to restart processing of the current directory.
      315*   If it is called too many times, we will give up, instead. It performs the
      316*   restart by a non-local goto into the main loop.
      317*   */
      318 
      319 	refetch_count = refetch_count + 1;
      320 
      321 	if refetch_count > 6 then do;
      322 	     call com_err_ (0, WHOAMI, "Unable to get a consistent copy of ^a>^a",
      323 		parent_dname, parent_ename);
      324 	     real_code = error_table_$action_not_performed;
      325 	     goto MAIN_RETURN;
      326 	     end;
      327 
      328 	goto RESTART_THIS_DIRECTORY;
      329 
      330 	end refetch_dir;
      331 
      332 /*  */
      333 
      334 terminate_dirs: proc ();
      335 
      336 /* This procedure terminates all the directories we have initiated. This is localized, and done
      337*   all at once when the whole lookup is finished, to avoid the following scenario:
      338*
      339*   1) >dir1 is initiated.
      340*   2) The UID of dir2 is found in >dir1
      341*   3) >dir1 is terminated, and removed from the address space because
      342*      it has no (currently initiated) inferiors.
      343*   4) >dir1>dir2 is initiated: this requires initiating dir1 AGAIN,
      344*      as part of the initiation and lookup process.
      345*
      346*   By performing all the terminations at once, all the directories in the pathname get initiated
      347*   only once in the lookup. Unfortunately, we can't just leave them initiated and wait for the
      348*   KST garbage collector to terminate them, because phcs_$initiate is not the same as an ordinary
      349*   directory initiation.
      350*   */
      351 
      352 dcl  idx fixed bin;
      353 dcl  this_dirp pointer;
      354 
      355 
      356 /* Loop backwards, to avoid "Attempt to terminate with inferiors" error. */
      357 
      358 	do idx = hbound (dirp, 1) to lbound (dirp, 1) by -1;
      359 	     if dirp (idx) ^= null () then do;
      360 		this_dirp = dirp (idx);
      361 		dirp (idx) = null ();
      362 		call phcs_$terminate_noname (this_dirp, (0));
      363 		end;
      364 	     end;
      365 
      366 	return;
      367 	end terminate_dirs;
      368 
      369  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  1     2 /* Modified 8/74 for NSS */
  1     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  1     4 /* Modified 3/82 BIM for change pclock */
  1     5 /* format: style3 */
  1     6 
  1     7 /* Template for the directory header. Length = 64 words. */
  1     8 
  1     9 dcl  dp ptr;
  1    10 
  1    11 dcl 1 dir based (dp) aligned,
  1    12 
  1    13    2 modify bit (36),				/* Process ID of last modifier */
  1    14    2 type bit (18) unaligned,			/* type of object = dir header */
  1    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  1    16     2 dtc (3),					/* date-time checked by salvager array */
  1    17       3 date bit (36),				/* the date */
  1    18       3 error bit (36),				/* what errors were discovered */
  1    19 
  1    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  1    21 
  1    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  1    23 
  1    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  1    25 
  1    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  1    27 
  1    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  1    29     2 version_number fixed bin (17),			/* version number of header */
  1    30 
  1    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  1    32     2 pad2 bit (18),
  1    33 
  1    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  1    35     2 pad3 bit (18),
  1    36 
  1    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  1    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  1    39 
  1    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  1    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  1    42 
  1    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  1    44     2 dir_count fixed bin (17),			/* number of directory branches */
  1    45 
  1    46     2 lcount fixed bin (17),				/* number of links */
  1    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  1    48 
  1    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  1    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  1    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  1    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  1    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  1    54     2 pad4 bit (14),
  1    55 
  1    56     2 iacl_count (0:7),
  1    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  1    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  1    59 
  1    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  1    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  1    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  1    63 
  1    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  1    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  1    66 
  1    67     2 htsize fixed bin (17),				/* size of hash table */
  1    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  1    69 
  1    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  1    71     2 pad6 fixed bin (17),
  1    72 
  1    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  1    74     2 pad7 bit (18)) unaligned,
  1    75 
  1    76     2 dts bit (36),					/* date-time directory last salvaged */
  1    77 
  1    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  1    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  1    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  1    81     2 checksum bit (36),				/* checksummed from uid on */
  1    82     2 owner bit (36);				/* uid of parent dir */
  1    83 
  1    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  1    85 
  1    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      369 
      370  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  2     2 
  2     3 /* Template for names of branches or links. Length = 14 words. */
  2     4 
  2     5 dcl np ptr;
  2     6 
  2     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  2     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  2     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  2    10 
  2    11     2 type bit (18) unaligned,			/* type = dir name */
  2    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  2    13 
  2    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  2    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  2    16 
  2    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  2    18     2 pad3 bit (18) unal,
  2    19 
  2    20     2 name char(32) aligned,
  2    21 
  2    22     2 checksum bit (36),				/* checksum from entry_rp */
  2    23 
  2    24     2 owner bit (36);				/* uid of entry */
  2    25 
  2    26 
  2    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      370 
      371  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  3     2 
  3     3 
  3     4 /* Template for an entry. Length = 38 words */
  3     5 
  3     6 dcl  ep ptr;
  3     7 
  3     8 dcl 1 entry based (ep) aligned,
  3     9 
  3    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  3    12 
  3    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  3    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  3    15 
  3    16     2 uid bit (36),					/* unique id of entry */
  3    17 
  3    18     2 dtem bit (36),				/* date-time entry modified */
  3    19 
  3    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  3    21     2 pad0 bit (17),
  3    22     2 nnames fixed bin (17),				/* number of names for this entry */
  3    23 
  3    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    26 
  3    27     2 author,					/* user who created branch */
  3    28       3 pers_rp bit (18),				/* name of user who created branch */
  3    29       3 proj_rp bit (18),				/* project of user who created branch */
  3    30 
  3    31       3 tag char (1),				/* tag of user who created branch */
  3    32       3 pad1 char (3),
  3    33 
  3    34     2 primary_name bit (504),				/* first name on name list */
  3    35 
  3    36     2 dtd bit (36),					/* date time dumped */
  3    37 
  3    38     2 pad2 bit (36),
  3    39 
  3    40 
  3    41 /* the declarations below are for branch only */
  3    42 
  3    43 
  3    44     2 pvid bit (36),				/* physical volume id */
  3    45 
  3    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    47     2 pad3 bit (18),
  3    48 
  3    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  3    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  3    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  3    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  3    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  3    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  3    55     2 audit_flag bit (1),				/* segment must be audited for security */
  3    56     2 security_oosw bit (1),				/* security out of service switch */
  3    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  3    58     2 master_dir bit (1),				/* TRUE for master directory */
  3    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  3    60     2 pad4 bit (11),
  3    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  3    62 
  3    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  3    64 
  3    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  3    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  3    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  3    68 
  3    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  3    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  3    71 
  3    72     2 bc_author,					/* user who last set the bit count */
  3    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  3    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  3    75 
  3    76       3 tag char (1),				/* tag of user who set the bit count */
  3    77       3 pad5 bit (2),
  3    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  3    79 
  3    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  3    81 
  3    82     2 pad6 bit (36),
  3    83 
  3    84     2 checksum bit (36),				/* checksum from dtd */
  3    85 
  3    86     2 owner bit (36);				/* uid of containing directory */
  3    87 
  3    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      371 
      372  /*     BEGIN INCLUDE FILE ... dir_allocation_area.incl.pl1 ... last modified December 1973 */
  4     2 
  4     3 dcl  areap ptr;
  4     4 
  4     5 dcl 1 area based (areap) aligned,
  4     6     2 nsizes fixed bin (18),				/* Number of types. */
  4     7     2 lu fixed bin (18),				/* Next available word in area. */
  4     8     2 lw fixed bin (18),				/* Last usable word. */
  4     9     2 array (100) aligned,				/* Array of types. */
  4    10       3 fptr bit (18) unaligned,			/* Free pointer for this size. */
  4    11       3 size fixed bin (17) unaligned;			/* Size. */
  4    12 
  4    13 /*     END INCLUDE FILE ... dir_allocation_area.incl.pl1 */
      372 
      373 
      374 	end vpn_cv_uid_path_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/28/84  0942.0  vpn_cv_uid_path_.pl1              >special_ldd>online>41-0>vpn_cv_uid_path_.pl1
369          1    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
370          2    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
371          3    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
372          4    10/15/76  1242.9  dir_allocation_area.incl.pl1      >ldd>include>dir_allocation_area.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_code                                 parameter       fixed bin(35,0)          dcl 34 in procedure "vpn_cv_uid_path_" set ref 11 17
                                                                                  88* 96* 157*
P_code                                 parameter       fixed bin(35,0)          dcl 255 in procedure "uid_to_ename" set ref 250 275*
                                                                                  285*
P_dirsw                                parameter       bit(1)                   dcl 254 set ref 250 274*
P_ename                                parameter       char(32)                 unaligned dcl 253 set ref 250 273*
P_entry_uid                            parameter       bit(36)                  dcl 33 ref 17 92 112
P_offset                               parameter       bit(18)                  dcl 296 ref 292 301 304 304
P_pathname                             parameter       char                     unaligned dcl 32 set ref 11 17 87* 97* 156*
P_ptr                                  parameter       pointer                  dcl 297 set ref 292 304*
P_size                                 parameter       fixed bin(18,0)          dcl 298 set ref 292 301 304*
P_uid                                  parameter       bit(36)                  dcl 252 ref 250 272
P_uid_path_ptr                         parameter       pointer                  dcl 31 ref 11 17 83
WHOAMI                          000000 constant        char(32)                 initial unaligned dcl 75 set ref 173* 322*
addr                                                   builtin function         dcl 79 ref 122 123 124 273
area                                   based           structure                level 1 dcl 4-5 ref 218 218
areap                           001120 automatic       pointer                  dcl 4-3 set ref 124* 218* 218 218 219
arearp                   24            based           bit(18)                  level 2 packed unaligned dcl 1-11 ref 215 218
binary                                                 builtin function         dcl 79 ref 301
branch_count                    001165 automatic       fixed bin(17,0)          dcl 258 set ref 263* 271* 271 283
bs                        4            based           bit(1)                   level 2 packed unaligned dcl 3-8 ref 271
code                            001102 automatic       fixed bin(35,0)          dcl 56 set ref 140* 171 171 184 186 191 221* 222
com_err_                        000010 constant        entry                    external dcl 60 ref 173 322
depth                           000101 automatic       fixed bin(17,0)          dcl 37 set ref 101* 101* 106 111* 111 112 136 225
                                                                                  239
dir                                    based           structure                level 1 dcl 1-11 ref 211 211
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-11 ref 283
dir_size                        000154 automatic       fixed bin(18,0)          dcl 48 set ref 209* 219* 301
dirp                            000127 automatic       pointer                  array unaligned dcl 43 set ref 125* 144* 358 358 359
                                                                                  360 361*
dirsw                           001144 automatic       bit(1)                   dcl 205 in procedure "lookup_in_parent" set ref 221*
                                                                                  239
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed unaligned
                                                                                  dcl 3-8 in procedure "vpn_cv_uid_path_" ref 274
dp                              001114 automatic       pointer                  dcl 1-9 set ref 122* 211* 211 211 212 215 218 265
                                                                                  283 283
e_rel                           001164 automatic       bit(18)                  dcl 257 set ref 265* 265* 269*
efrp                                   based           bit(18)                  level 2 packed unaligned dcl 3-8 ref 281
ename                           001145 automatic       char(32)                 unaligned dcl 206 set ref 221* 234 237
entry                                  based           structure                level 1 dcl 3-8 set ref 269 269
entry_count                     001166 automatic       fixed bin(17,0)          dcl 259 set ref 262* 279* 279 280
entry_sw                        000100 automatic       bit(1)                   dcl 36 set ref 14* 20* 86 110
entryfrp                 16            based           bit(18)                  level 2 packed unaligned dcl 1-11 ref 265
ep                              001116 automatic       pointer                  dcl 3-6 set ref 123* 269* 269 269 271 272 273 274
                                                                                  281
error_table_$action_not_performed
                                000022 external static fixed bin(35,0)          dcl 66 ref 174 324
error_table_$bad_uidpath        000024 external static fixed bin(35,0)          dcl 67 ref 96
error_table_$dirseg             000026 external static fixed bin(35,0)          dcl 68 ref 186
error_table_$incorrect_access   000030 external static fixed bin(35,0)          dcl 69 ref 187
error_table_$no_dir             000032 external static fixed bin(35,0)          dcl 70 ref 171 227
error_table_$noentry            000034 external static fixed bin(35,0)          dcl 71 ref 171 225
error_table_$notadir            000036 external static fixed bin(35,0)          dcl 72 ref 242
error_table_$vtoce_connection_fail
                                000040 external static fixed bin(35,0)          dcl 73 ref 118 191
hbound                                                 builtin function         dcl 79 ref 101 358
idx                             001212 automatic       fixed bin(17,0)          dcl 352 set ref 358* 359 360 361*
input_uid_path                         based           bit(36)                  array dcl 41 ref 85 95 101 101 107
lbound                                                 builtin function         dcl 79 ref 358
level                           000102 automatic       fixed bin(17,0)          dcl 38 set ref 106* 107 107* 136* 144* 212 221 225
                                                                                  239
local_area                      000255 automatic       structure                level 1 dcl 50 set ref 124
local_dir                       000155 automatic       structure                level 1 dcl 49 set ref 122
local_entry                     000424 automatic       structure                level 1 dcl 51 set ref 123
lookup_failures                 000153 automatic       fixed bin(17,0)          dcl 47 set ref 126* 172 178* 178
lu                        1            based           fixed bin(18,0)          level 2 dcl 4-5 ref 219
name                      4            based           char(32)                 level 2 dcl 2-7 ref 273
names                                  based           structure                level 1 dcl 2-7
null                                                   builtin function         dcl 79 ref 125 141 359 361
parent_dname                    000672 automatic       char(512)                unaligned dcl 54 set ref 131* 140* 173* 173* 231
                                                                                  231* 231 233* 233 322*
parent_ename                    001072 automatic       char(32)                 unaligned dcl 55 set ref 132* 140* 173* 173* 233
                                                                                  234* 322*
pathname                        000471 automatic       varying char(512)        dcl 53 set ref 116* 116 129* 137* 137 156 188* 188
                                                                                  191* 191 194* 194 224* 224 236* 236 237* 237 241*
                                                                                  241
pathname_                       000012 constant        entry                    external dcl 61 ref 173 173
phcs_$initiate                  000014 constant        entry                    external dcl 62 ref 140
phcs_$ring_0_peek               000016 constant        entry                    external dcl 63 ref 304
phcs_$terminate_noname          000020 constant        entry                    external dcl 64 ref 362
pointer                                                builtin function         dcl 79 ref 304 304
primary_name             10            based           bit(504)                 level 2 packed unaligned dcl 3-8 set ref 273
real_code                       001103 automatic       fixed bin(35,0)          dcl 57 set ref 118* 133* 157 174* 184* 187* 225*
                                                                                  227* 242* 324*
refetch_count                   000152 automatic       fixed bin(17,0)          dcl 46 set ref 145* 319* 319 321
rtrim                                                  builtin function         dcl 79 ref 231 233 237
rzdp                            000150 automatic       pointer                  dcl 45 set ref 140* 141 144 304 304
seg_count                22            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-11 ref 283
seg_fault_error                 001106 stack reference condition                dcl 77 ref 115
size                                                   builtin function         dcl 79 ref 211 211 218 218 269 269
start                           000103 automatic       fixed bin(17,0)          dcl 39 set ref 127* 136
stop                            001104 automatic       bit(1)                   dcl 58 set ref 117* 134* 137 183* 223* 240*
this_dirp                       001214 automatic       pointer                  dcl 353 set ref 360* 362*
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 1-11 in procedure
                                                                                  "vpn_cv_uid_path_" ref 212
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 3-8 in procedure
                                                                                  "vpn_cv_uid_path_" ref 272
uid_path                        000106 automatic       bit(36)                  array dcl 42 set ref 105* 107* 112* 212 221*
uid_path_ptr                    000104 automatic       pointer                  dcl 40 set ref 83* 85 95 101 101 107
unspec                                                 builtin function         dcl 79 set ref 85 105*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
np                                     automatic       pointer                  dcl 2-5
version_number_2                       internal static fixed bin(17,0)          initial dcl 1-84

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000175 constant        label                    dcl 83 ref 15 21
MAIN_RETURN                     000470 constant        label                    dcl 153 ref 175 325
NEXT_LEVEL                      000466 constant        label                    dcl 150 ref 119
REALLY_IS_ROOT                  000207 constant        label                    dcl 87 ref 92
RESTART_THIS_DIRECTORY          000465 constant        label                    dcl 146 ref 328
START_OVER                      000352 constant        label                    dcl 129 ref 180
cant_get_parent                 000503 constant        entry                    internal dcl 162 ref 141
copy_from_dir                   001213 constant        entry                    internal dcl 292 ref 211 218 269
lookup_in_parent                000647 constant        entry                    internal dcl 201 ref 146
refetch_dir                     001245 constant        entry                    internal dcl 312 ref 212 215 280 283 301
terminate_dirs                  001313 constant        entry                    internal dcl 334 ref 153 179
uid_to_ename                    001122 constant        entry                    internal dcl 250 ref 221
vpn_cv_uid_path_                000127 constant        entry                    external dcl 11
vpn_cv_uid_path_$ent            000154 constant        entry                    external dcl 17

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1606        1650    1401        1616
Length      2130    1401        42         244     205           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vpn_cv_uid_path_                    840 external procedure  is an external procedure.  
on unit on line 115                  64 on unit               
cant_get_parent                         internal procedure  shares stack frame of external procedure vpn_cv_uid_path_.  
lookup_in_parent                        internal procedure  shares stack frame of external procedure vpn_cv_uid_path_.  
uid_to_ename                            internal procedure  shares stack frame of external procedure vpn_cv_uid_path_.  
copy_from_dir                           internal procedure  shares stack frame of external procedure vpn_cv_uid_path_.  
refetch_dir                             internal procedure  shares stack frame of external procedure vpn_cv_uid_path_.  
terminate_dirs                          internal procedure  shares stack frame of external procedure vpn_cv_uid_path_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vpn_cv_uid_path_         000100 entry_sw                    vpn_cv_uid_path_
                         000101 depth                       vpn_cv_uid_path_
                         000102 level                       vpn_cv_uid_path_
                         000103 start                       vpn_cv_uid_path_
                         000104 uid_path_ptr                vpn_cv_uid_path_
                         000106 uid_path                    vpn_cv_uid_path_
                         000127 dirp                        vpn_cv_uid_path_
                         000150 rzdp                        vpn_cv_uid_path_
                         000152 refetch_count               vpn_cv_uid_path_
                         000153 lookup_failures             vpn_cv_uid_path_
                         000154 dir_size                    vpn_cv_uid_path_
                         000155 local_dir                   vpn_cv_uid_path_
                         000255 local_area                  vpn_cv_uid_path_
                         000424 local_entry                 vpn_cv_uid_path_
                         000471 pathname                    vpn_cv_uid_path_
                         000672 parent_dname                vpn_cv_uid_path_
                         001072 parent_ename                vpn_cv_uid_path_
                         001102 code                        vpn_cv_uid_path_
                         001103 real_code                   vpn_cv_uid_path_
                         001104 stop                        vpn_cv_uid_path_
                         001114 dp                          vpn_cv_uid_path_
                         001116 ep                          vpn_cv_uid_path_
                         001120 areap                       vpn_cv_uid_path_
                         001144 dirsw                       lookup_in_parent
                         001145 ename                       lookup_in_parent
                         001164 e_rel                       uid_to_ename
                         001165 branch_count                uid_to_ename
                         001166 entry_count                 uid_to_ename
                         001212 idx                         terminate_dirs
                         001214 this_dirp                   terminate_dirs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              tra_ext             enable
shorten_stack       ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      pathname_                     phcs_$initiate                phcs_$ring_0_peek
phcs_$terminate_noname

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_uidpath      error_table_$dirseg
error_table_$incorrect_access error_table_$no_dir           error_table_$noentry          error_table_$notadir
error_table_$vtoce_connection_fail




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000123        14 000145        15 000146        17 000147        20 000172        21 000174        83 000175
     85 000201        86 000205        87 000207        88 000215        89 000216        92 000217        95 000222
     96 000225        97 000230        98 000235       101 000236       103 000244       105 000247       106 000252
    107 000257       108 000261       110 000263       111 000265       112 000266       115 000272       116 000306
    117 000321       118 000323       119 000325       122 000330       123 000332       124 000334       125 000336
    126 000347       127 000350       129 000352       131 000353       132 000356       133 000361       134 000362
    136 000363       137 000373       140 000410       141 000453       144 000461       145 000464       146 000465
    150 000466       153 000470       156 000471       157 000500       158 000502       162 000503       171 000504
    172 000512       173 000515       174 000566       175 000571       178 000572       179 000573       180 000574
    183 000575       184 000577       186 000600       187 000602       188 000604       189 000616       191 000617
    194 000634       196 000646       201 000647       209 000650       211 000652       212 000660       215 000666
    218 000673       219 000703       221 000706       222 000723       223 000725       224 000727       225 000741
    227 000750       228 000753       231 000754       233 001006       234 001035       236 001041       237 001050
    239 001074       240 001102       241 001104       242 001116       245 001121       250 001122       262 001124
    263 001125       265 001126       269 001135       271 001141       272 001146       273 001152       274 001156
    275 001161       276 001162       279 001163       280 001164       281 001170       283 001174       285 001207
    286 001212       292 001213       301 001215       304 001223       306 001244       312 001245       319 001246
    321 001247       322 001252       324 001306       325 001311       328 001312       334 001313       358 001314
    359 001320       360 001323       361 001326       362 001330       364 001342       366 001345


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
