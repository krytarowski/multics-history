	COMPILATION LISTING OF SEGMENT remote_punch_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/19/88  1415.4 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 remote_punch_: proc;
       13 
       14 /* remote_punch_: An I/O module for communicating with a remote punch or its equivilent. */
       15 
       16 /* Coded March 1977 by David Vinograd */
       17 /* Modified for user TTFs and cleaned up May 1978 by D. Vinograd */
       18 /* Modified by J. C. Whitmore, 11/78, to make the attach options consistent among all remote_xxx_ dims */
       19 /* Modified by J. C. Whitmore, 10/79, to support binary_punch mode (control order) */
       20 /* Modified by J. C. Whitmore,  2/80, to do full record IO to terminal dim */
       21 
       22 
       23 /****^  HISTORY COMMENTS:
       24*  1) change(87-11-23,Beattie), approve(87-12-21,MCR7821),
       25*     audit(88-01-13,Brunelle), install(88-01-19,MR12.2-1014):
       26*     Prevent splitting of card images that span component boundaries
       27*     of MSFs. (phx21014)
       28*                                                   END HISTORY COMMENTS */
       29 
       30 
       31 /* format: style4 */
       32 
       33 /* Parameters */
       34 
       35 dcl  a_iocbp ptr parameter;
       36 dcl  a_option (*) char (*) var parameter;		/* Options for attach */
       37 dcl  a_sw bit (1) parameter;				/* com_err_ switch for attach */
       38 dcl  a_code fixed bin (35) parameter;
       39 dcl  a_mode fixed bin parameter;			/* The open mode */
       40 dcl  a_data_ptr ptr parameter;
       41 dcl  a_data_count fixed bin (24) parameter;
       42 dcl  a_pos_type fixed bin parameter;
       43 dcl  a_pos_value fixed bin (24) parameter;
       44 dcl  a_order char (*) parameter;
       45 dcl  a_infop ptr parameter;
       46 dcl  old_modes char (*) parameter;
       47 dcl  new_modes char (*) parameter;
       48 
       49 /* Attach entry point */
       50 
       51 remote_punch_attach: entry (a_iocbp, a_option, a_sw, a_code);
       52 
       53 	iocbp = a_iocbp;
       54 	com_err_sw = a_sw | static_com_err_sw;
       55 	code, a_code = 0;
       56 
       57 	adp = null;
       58 	if iocbp -> iocb.attach_descrip_ptr ^= null then do;
       59 	     code = error_table_$not_detached;
       60 	     call abort_attach (code, "Switch name: ^a", iocbp -> iocb.name);
       61 	end;
       62 
       63 	if areap = null then do;			/* first time called, make attach area */
       64 	     call get_temp_segment_ (remote_device_name, areap, code); /* Temp segment for attach data area */
       65 	     if code ^= 0 then call abort_attach (code, "Unable to allocate temp segment.", "");
       66 	     areap -> my_area = empty ();		/* initialize the area */
       67 	end;
       68 
       69 	on cleanup call clean_up_handler;		/* be sure to free attach data on abort */
       70 
       71 	allocate ad in (my_area) set (adp);		/* create the attach data for this switch */
       72 
       73 /* Initialize attach data variables */
       74 
       75 	ad.bits = "0"b;
       76 	ad.fixed = 0;
       77 	ad.ptrs = null;
       78 	ad.chars = "";
       79 	ad.edited = "1"b;				/* always default to the edited mode */
       80 	ad.stream_output = "1"b;			/* use the stream interface until records are fully defined */
       81 	ad.card_ll = 80;				/* default number of columns per card */
       82 	ad.device_type = PUNCH_DEVICE;		/* default to output to a punch device */
       83 
       84 /* Process attach options */
       85 
       86 	if hbound (a_option, 1) < 1 then do;		/* Must be at least one */
       87 	     code = error_table_$wrong_no_of_args;
       88 	     call abort_attach (code, "Bad attach description.", "");
       89 	end;
       90 
       91 	terminal_attach_options = "";
       92 	my_options = "";
       93 	terminal_attach_desc = "";
       94 	terminal_attach_name = "";
       95 
       96 	device_type = "";				/* mark as no -device option given */
       97 
       98 	on conversion begin;
       99 	     code = error_table_$bad_arg;
      100 	     call abort_attach (code, "Attach option conversion error.", "");
      101 	end;
      102 
      103 	do idx = 1 to hbound (a_option, 1);
      104 	     if a_option (idx) = "-runout_spacing" | a_option (idx) = "-runsp" then do; /* skip it and next option */
      105 		dummy = get_arg (idx);
      106 		my_options = my_options || " -runsp " || dummy;
      107 	     end;
      108 	     else if a_option (idx) = "-htab" | a_option (idx) = "-horizontal_tab" then do;
      109 		ad.htab = "1"b;			/* allow tabs to be sent to remote */
      110 		my_options = my_options || " -htab";
      111 	     end;
      112 	     else if a_option (idx) = "-non_edited" then do;
      113 		ad.edited = "0"b;			/* allow ctl chars to be sent to remote */
      114 		my_options = my_options || " -non_edited";
      115 	     end;
      116 	     else if a_option (idx) = "-card_ll" then do;
      117 		dummy = get_arg (idx);
      118 		my_options = my_options || " -card_ll " || dummy;
      119 		ad.card_ll = convert (ad.card_ll, dummy); /* get it into fixed bin form */
      120 	     end;
      121 	     else if a_option (idx) = "-physical_page_length" | a_option (idx) = "-ppl" then do; /* absorb this too */
      122 		dummy = get_arg (idx);
      123 		my_options = my_options || " -ppl " || dummy;
      124 	     end;
      125 	     else if a_option (idx) = "-device" then do;
      126 		device_type = get_arg (idx);		/* record this */
      127 		my_options = my_options || " -device " || rtrim (device_type);
      128 	     end;
      129 	     else if a_option (idx) = "-terminal" then
      130 		ad.terminal = get_arg (idx);
      131 	     else terminal_attach_options = terminal_attach_options || space || a_option (idx);
      132 	end;
      133 
      134 /* Attach through terminal dim */
      135 
      136 	if ad.terminal = "" then do;			/* must specify the next level */
      137 	     code = error_table_$badopt;
      138 	     call abort_attach (code, "Missing option -terminal.", "");
      139 	end;
      140 
      141 	if device_type = "" then device_type = "punch";	/* choose the default if not specified */
      142 	else do;					/* otherwise check it out more ... */
      143 	     if device_type = "reader_simulator" then do;
      144 		device_type = "reader";		/* we are to simulate the reader of a workstation */
      145 		ad.device_type = READER_DEVICE;
      146 	     end;
      147 	     else if device_type ^= "punch" then do;	/* the only other one we will accept */
      148 		code = error_table_$bad_arg;
      149 		call abort_attach (code, "Invalid -device option: ^a", (device_type));
      150 	     end;
      151 	end;
      152 
      153 	if ad.card_ll < 1 | ad.card_ll > 160 then do;	/* validate the line length */
      154 	     code = error_table_$bad_arg;
      155 	     call abort_attach (code, "Invalid card line length", "");
      156 	end;
      157 
      158 	attach_count = attach_count + 1;		/* new attach name each time */
      159 	if attach_count > 999 then attach_count = 1;
      160 	terminal_attach_name = remote_device_name || ltrim (character (attach_count));
      161 
      162 	ad.attach_desc = remote_device_name || " -terminal " || ad.terminal ||
      163 	     terminal_attach_options || my_options;
      164 	terminal_attach_desc = ad.terminal || terminal_attach_options || " -device " || rtrim (device_type);
      165 
      166 	call iox_$attach_ioname ((terminal_attach_name), ad.terminal_iocbp, (terminal_attach_desc), code);
      167 	if code ^= 0 then call abort_attach (code, "Unable to attach to terminal ", "");
      168 
      169 /* Now mask and complete the iocb */
      170 
      171 	mask = "0"b;
      172 
      173 	on any_other call handler;
      174 
      175 	call hcs_$set_ips_mask ("0"b, mask);
      176 
      177 	iocbp -> iocb.attach_descrip_ptr = addr (ad.attach_desc);
      178 	iocbp -> iocb.open_descrip_ptr = null;
      179 	iocbp -> iocb.attach_data_ptr = adp;
      180 	iocbp -> iocb.open = remote_punch_open;
      181 	iocbp -> iocb.detach_iocb = remote_punch_detach;
      182 
      183 	call iox_$propagate (iocbp);
      184 
      185 	revert cleanup;				/* we are now comitted; require a detach */
      186 
      187 	call hcs_$reset_ips_mask (mask, mask);
      188 
      189 	revert any_other;
      190 
      191 attach_return:
      192 
      193 	a_code = code;
      194 
      195 	return;
      196 
      197 /* Detach entry point */
      198 
      199 remote_punch_detach: entry (a_iocbp, a_code);
      200 
      201 	iocbp = a_iocbp;
      202 	a_code = 0;
      203 	adp = iocbp -> iocb.attach_data_ptr;
      204 
      205 	if adp = null then do;
      206 	     a_code = error_table_$not_attached;
      207 	     return;
      208 	end;
      209 
      210 	if iocbp -> iocb.open_descrip_ptr ^= null then do;
      211 	     a_code = error_table_$not_closed;
      212 	     return;
      213 	end;
      214 
      215 /*	First, kill the switch defination known by iox_ */
      216 
      217 	mask = "0"b;
      218 
      219 	on any_other call handler;
      220 
      221 	call hcs_$set_ips_mask ("0"b, mask);
      222 
      223 	iocbp -> iocb.attach_descrip_ptr = null;
      224 
      225 	call iox_$propagate (iocbp);
      226 
      227 	call hcs_$reset_ips_mask (mask, mask);
      228 
      229 	revert any_other;
      230 
      231 /*	Now kill the terminal IO switch.  If this fails, there isn't anything we can do about it.  */
      232 /*	So, ignore any errors ... we tried at least. */
      233 
      234 	call iox_$detach_iocb (ad.terminal_iocbp, ignore);
      235 
      236 	if ad.stat_term_rec_ptr ^= null then do;
      237 	     free ad.stat_term_rec_ptr -> terminal_io_record in (my_area);
      238 	     ad.stat_term_rec_ptr = null;
      239 	end;
      240 
      241 	free adp -> ad in (my_area);
      242 
      243 	adp = null;
      244 
      245 	return;
      246 
      247 /* Open entry point */
      248 
      249 remote_punch_open: entry (a_iocbp, a_mode, a_sw, a_code);
      250 
      251 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      252 	a_code = 0;
      253 	adp = iocbp -> iocb.attach_data_ptr;
      254 
      255 	if adp = null then do;
      256 	     a_code = error_table_$not_attached;
      257 	     return;
      258 	end;
      259 
      260 	if iocbp -> iocb.open_descrip_ptr ^= null then do;
      261 	     a_code = error_table_$not_closed;
      262 	     return;
      263 	end;
      264 
      265 	open_mode = a_mode;
      266 	if ^((open_mode = Stream_output) | (open_mode = Stream_input_output)) then do;
      267 	     a_code = error_table_$bad_mode;
      268 	     return;
      269 	end;
      270 
      271 	call iox_$open (ad.terminal_iocbp, Sequential_output, "0"b, a_code); /* try for record interface first */
      272 	if a_code = 0 then ad.stream_output = "0"b;	/* we have it, so use it */
      273 	else do;
      274 	     ad.stream_output = "1"b;			/* this is all that's left if it works */
      275 	     call iox_$open (ad.terminal_iocbp, Stream_output, "0"b, a_code);
      276 	     if a_code ^= 0 then return;		/* too bad, abort the open */
      277 	end;
      278 
      279 	ad.open_description = rtrim (iox_modes (open_mode));
      280 
      281 	mask = "0"b;
      282 
      283 	on any_other call handler;
      284 
      285 	call hcs_$set_ips_mask ("0"b, mask);
      286 
      287 	iocbp -> iocb.put_chars = write_elements;
      288 	iocbp -> iocb.get_chars = iox_$err_no_operation;
      289 	iocbp -> iocb.get_line = iox_$err_no_operation;
      290 	iocbp -> iocb.control = remote_punch_control;
      291 	iocbp -> iocb.modes = remote_punch_modes;
      292 	iocbp -> iocb.position = remote_punch_position;
      293 	iocbp -> iocb.close = remote_punch_close;
      294 	iocbp -> iocb.open_descrip_ptr = addr (ad.open_description);
      295 
      296 	call iox_$propagate (iocbp);
      297 
      298 	call hcs_$reset_ips_mask (mask, mask);
      299 
      300 	return;
      301 
      302 /* Close entry point */
      303 
      304 remote_punch_close: entry (a_iocbp, a_code);
      305 
      306 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      307 	a_code = 0;
      308 	adp = iocbp -> iocb.attach_data_ptr;
      309 
      310 	if adp = null then do;
      311 	     a_code = error_table_$not_attached;
      312 	     return;
      313 	end;
      314 
      315 	if iocbp -> iocb.open_descrip_ptr = null then do;
      316 	     a_code = error_table_$not_open;
      317 	     return;
      318 	end;
      319 
      320 /*	Try to close the terminal IO switch.  If it fails, there isn't anything we can do about it. */
      321 /*	So just ignore the error code.  Our switch will be closed successfully. */
      322 
      323 	call iox_$close (ad.terminal_iocbp, ignore);
      324 
      325 	mask = "0"b;
      326 
      327 	on any_other call handler;
      328 
      329 	call hcs_$set_ips_mask ("0"b, mask);
      330 
      331 	iocbp -> iocb.open_descrip_ptr = null;
      332 	iocbp -> iocb.open = remote_punch_open;
      333 	iocbp -> iocb.detach_iocb = remote_punch_detach;
      334 	iocbp -> iocb.control = iox_$err_no_operation;
      335 	iocbp -> iocb.position = iox_$err_no_operation;
      336 	iocbp -> iocb.modes = iox_$err_no_operation;
      337 	iocbp -> iocb.put_chars = iox_$err_no_operation;
      338 	iocbp -> iocb.get_chars = iox_$err_no_operation;
      339 	iocbp -> iocb.get_line = iox_$err_no_operation;
      340 
      341 	call iox_$propagate (iocbp);
      342 
      343 	call hcs_$reset_ips_mask (mask, mask);
      344 
      345 	return;
      346 
      347 /* Put_chars entry point */
      348 
      349 write_elements: entry (a_iocbp, a_data_ptr, a_data_count, a_code);
      350 
      351 /* This entry takes data defined by the data ptr and the data length count as stream input and breaks
      352*   the data into card image records for the terminal IO module.  Both character and binary card images
      353*   are supported by remote_punch_.  This module can be called for each component of an MSF and card
      354*   images will not be broken.  The "runout" control order flushes the last card if present in the
      355*   output buffer. */
      356 
      357 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      358 	code, a_code = 0;
      359 	adp = iocbp -> iocb.attach_data_ptr;
      360 
      361 	if adp = null then do;
      362 	     a_code = error_table_$not_attached;
      363 	     return;
      364 	end;
      365 
      366 	if ad.binary then max_size = BITS_PER_SEGMENT;	/* max bit count */
      367 	else max_size = CHARS_PER_SEGMENT;		/* max char count */
      368 
      369 	if a_data_count < 0 | a_data_count > max_size then do;
      370 	     a_code = error_table_$bad_arg;
      371 	     return;
      372 	end;
      373 
      374 	call iox_$control (ad.terminal_iocbp, "select_device", addr (punch_device), code);
      375 	if code ^= 0 then go to put_chars_ret;
      376 
      377 	remaining_count = a_data_count;		/* This is decremented as data is sent */
      378 	wp = a_data_ptr;				/* set local pointer to callers workspace */
      379 	in_pos = 1;				/* start with the first input element */
      380 
      381 	if ad.binary then do;			/* for binary punch output */
      382 	     if ad.stat_term_rec_ptr = null then do;	/* if we haven't already done this */
      383 		terminal_io_record_element_size = 1;	/* setup for allocation of output record */
      384 		terminal_io_record_n_elements = 960;	/* max record length of 960 bits in binary mode */
      385 		call allocate_tio_rec;		/* make an output record block */
      386 		terminal_io_record.binary = "1"b;	/* mark this as a binary record */
      387 	     end;
      388 	     else terminal_io_record_ptr = ad.stat_term_rec_ptr;
      389 
      390 	     do while (remaining_count > 0);
      391 
      392 		if ad.rec_len > 0 then do;		/* there is data here from last call */
      393 		     data_len = min (960 - ad.rec_len, remaining_count);
      394 		     substr (terminal_io_record_data_bits, ad.rec_len + 1) = substr (wp -> bit_string, in_pos, data_len);
      395 		     ad.rec_len = ad.rec_len + data_len;
      396 		     if ad.rec_len < 960 then go to put_chars_ret;
      397 		     call send_binary;
      398 		     in_pos = in_pos + data_len;
      399 		     remaining_count = remaining_count - data_len;
      400 		end;				/* data here from last call */
      401 
      402 		else do;
      403 		     ad.rec_len = min (960, remaining_count); /* records are 1 to 960 bits long */
      404 		     terminal_io_record_data_bits = substr (wp -> bit_string, in_pos, ad.rec_len);
      405 						/* define the record and pad with zeros */
      406 		     if ad.rec_len < 960 then go to put_chars_ret;
      407 						/* there may be mor in a later call */
      408 
      409 		     call send_binary;
      410 		     in_pos = in_pos + ad.rec_len;	/* bump the workspace index */
      411 		     remaining_count = remaining_count - ad.rec_len; /* and decrement the remainder count */
      412 		end;				/* no data in buffer from previous call */
      413 	     end;					/* while data to send */
      414 	end;					/* if binary to send */
      415 
      416 	else do;					/* for character output */
      417 	     if ad.stat_term_rec_ptr = null then do;	/* done only once per file */
      418 		terminal_io_record_element_size = 9;	/* 9 bits per character in the record */
      419 		terminal_io_record_n_elements = ad.card_ll; /* max record size */
      420 		call allocate_tio_rec;		/* make an output record block */
      421 		residue = 0;			/* space residue from HT processing */
      422 		ad.tab_idx = 1;			/* virtual carriage position for tab calc */
      423 	     end;
      424 	     else terminal_io_record_ptr = ad.stat_term_rec_ptr;
      425 
      426 	     if ad.out_pos > 1 then go to next_char;	/* we already have some data in output record */
      427 
      428 	     do while (remaining_count > 0);
      429 		terminal_io_record.n_elements = ad.card_ll; /* reset to max length each time */
      430 		terminal_io_record_data_chars = "";	/* clear the card image, we need spaces for tab padding */
      431 		ad.out_pos = 1;			/* build card image starting in col 1 */
      432 		if residue > 0 then do;
      433 		     ad.out_pos = ad.out_pos + residue; /* move over extra spaces */
      434 		     residue = 0;			/* reset the space residue */
      435 		end;
      436 
      437 
      438 next_char:	if remaining_count <= 0 then go to put_chars_ret;
      439 						/* if done with input due to editing, just stop */
      440 						/* may get more */
      441 		char = substr (wp -> char_string, in_pos, 1); /* pickup next character */
      442 
      443 		in_pos = in_pos + 1;		/* bump the index */
      444 		remaining_count = remaining_count - 1;	/* and decrement the remainder */
      445 
      446 		if rank (char) < rank (" ") then do;	/* look for control chars */
      447 		     if char = CR | char = NL | char = VT | char = FF then do; /* card terminators */
      448 			ad.tab_idx = 1;		/* reset the virtual carriage */
      449 			go to send;		/* send off the card */
      450 		     end;
      451 		     if char = HT then do;		/* for tabs, put out spaces, let terminal compress */
      452 			if ^ad.htab then do;	/* if not sending the tab char, pad it out */
      453 			     tab_stop = divide (ad.tab_idx + 9, 10, 0) * 10 + 1; /* 11, 21, 31,  ... */
      454 			     count = tab_stop - ad.tab_idx; /* spaces we are to move */
      455 			     ad.tab_idx = tab_stop;	/* move the virtual carriage to new stop */
      456 			     if ad.out_pos + count > ad.card_ll then do; /* fold spaces? */
      457 				residue = (ad.out_pos - 1) + count - ad.card_ll; /* save the extra for later */
      458 				go to send;	/* and send off this card image */
      459 			     end;
      460 			     ad.out_pos = ad.out_pos + count; /* just step over spaces already there */
      461 			     go to next_char;	/* and go on to the next character */
      462 			end;
      463 		     end;
      464 		     else if ad.edited then go to next_char;
      465 						/* edit out back space and ctl chars not handled */
      466 		end;				/* if control character */
      467 		else if rank (char) > rank ("~") then go to next_char; /* drop all above 176 octal */
      468 
      469 		substr (terminal_io_record_data_chars, ad.out_pos, 1) = char; /* put the char into the output record */
      470 
      471 		ad.out_pos = ad.out_pos + 1;		/* that position is used up */
      472 		ad.tab_idx = ad.tab_idx + 1;		/* also move the virtual carriage */
      473 		if ad.out_pos <= ad.card_ll then go to next_char; /* fill up the card through col ad.card_ll */
      474 		else if remaining_count > 0 then do;	/* check for terminating char if more input */
      475 		     char = substr (wp -> char_string, in_pos, 1); /* get the next char */
      476 		     if char = CR | char = NL | char = VT | char = FF then do;
      477 			remaining_count = remaining_count - 1; /* skip over the terminator */
      478 			in_pos = in_pos + 1;
      479 		     end;
      480 		end;
      481 send:
      482 		call send_chars;
      483 	     end;					/* start a new card image */
      484 	end;					/* character output */
      485 
      486 put_chars_ret:
      487 	a_code = code;
      488 
      489 	return;
      490 
      491 /* Control entry point */
      492 
      493 remote_punch_control: entry (a_iocbp, a_order, a_infop, a_code);
      494 
      495 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      496 	adp = iocbp -> iocb.attach_data_ptr;
      497 
      498 	if adp = null then do;
      499 	     code = error_table_$not_attached;
      500 	     return;
      501 	end;
      502 
      503 	infop = a_infop;
      504 	order = a_order;
      505 	code, a_code = 0;
      506 
      507 	if order = "reset" then do;
      508 	     ad.records_sent = 0;			/* reset the accounting data */
      509 	     ad.binary = "0"b;			/* back to the default of character output */
      510 	     ad.rec_len, ad.out_pos = 0;		/* forget any held output */
      511 	     if ad.stat_term_rec_ptr ^= null then do;
      512 		free ad.stat_term_rec_ptr -> terminal_io_record in (my_area);
      513 		ad.stat_term_rec_ptr = null;
      514 	     end;
      515 	     go to pass_it_on;			/* let it go to the terminal also */
      516 	end;
      517 	else if order = "binary_punch" then do;
      518 						/* cannot allow ad.binary to change during an IO */
      519 	     if ad.binary & ad.rec_len > 0 then go to noop_error;
      520 	     else if ad.out_pos > 1 then go to noop_error;
      521 
      522 	     call iox_$control (ad.terminal_iocbp, order, infop, code); /* see if terminal can do it */
      523 	     if code = 0 then ad.binary = "1"b;		/* set binary mode only if terminal agrees on binary */
      524 	     else ad.binary = "0"b;			/* otherwise, keep character mode */
      525 	end;
      526 	else if order = "get_count" then do;		/* give the accounting data */
      527 	     if infop ^= null then do;
      528 		infop -> counts.line_count = ad.records_sent; /* use the line count as card count */
      529 		infop -> counts.page_count = 0;	/* not valid data for a punch */
      530 	     end;
      531 	     else
      532 
      533 noop_error:
      534 		code = error_table_$no_operation;
      535 	end;
      536 	else if order = "runout" then do;
      537 	     if ad.binary & ad.rec_len > 0 then call send_binary;
      538 	     else if ad.out_pos > 1 then call send_chars;
      539 	     if ad.stat_term_rec_ptr ^= null then do;
      540 		free ad.stat_term_rec_ptr -> terminal_io_record in (my_area);
      541 		ad.stat_term_rec_ptr = null;
      542 	     end;
      543 	     go to pass_it_on;
      544 	end;
      545 	else do;
      546 pass_it_on:
      547 	     call iox_$control (ad.terminal_iocbp, order, infop, code);
      548 	end;
      549 
      550 	a_code = code;
      551 
      552 	return;
      553 
      554 /* Modes entry point */
      555 
      556 remote_punch_modes: entry (a_iocbp, new_modes, old_modes, a_code);
      557 
      558 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      559 	adp = iocbp -> iocb.attach_data_ptr;
      560 	a_code = 0;
      561 
      562 	if adp = null then do;
      563 	     a_code = error_table_$not_attached;
      564 	     return;
      565 	end;
      566 
      567 	call iox_$modes (ad.terminal_iocbp, new_modes, old_modes, a_code);
      568 
      569 	return;
      570 
      571 /* Position entry point */
      572 
      573 remote_punch_position: entry (a_iocbp, a_pos_type, a_pos_value, a_code);
      574 
      575 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      576 	adp = iocbp -> iocb.attach_data_ptr;
      577 
      578 	if adp = null then do;
      579 	     a_code = error_table_$not_attached;
      580 	     return;
      581 	end;
      582 
      583 	a_code = 0;
      584 
      585 	call iox_$position (ad.terminal_iocbp, a_pos_type, a_pos_value, a_code);
      586 
      587 	return;
      588 
      589 
      590 
      591 
      592 
      593 flip_com_err_sw: entry;				/* entry to flip the com_err_sw */
      594 
      595 
      596 	static_com_err_sw = ^static_com_err_sw;		/* that's it */
      597 
      598 	return;
      599 
      600 get_arg: proc (idx) returns (char (*));
      601 
      602 dcl  idx fixed bin;
      603 
      604 	idx = idx + 1;				/* advance the option index to the option arg */
      605 	if idx > hbound (a_option, 1) then do;		/* check the range */
      606 	     code = error_table_$noarg;
      607 	     call abort_attach (code, "No argument after ^a.", (a_option (idx - 1)));
      608 	end;
      609 	return (a_option (idx));
      610 
      611      end get_arg;
      612 
      613 
      614 
      615 
      616 abort_attach: proc (code, str1, str2);
      617 
      618 dcl  (str1, str2) char (*) aligned;
      619 dcl  code fixed bin (35);
      620 
      621 /* This proc handles attach errors */
      622 
      623 	if com_err_sw then call com_err_ (code, remote_device_name, str1, str2);
      624 
      625 	call clean_up_handler;
      626 
      627 	go to attach_return;
      628 
      629      end abort_attach;
      630 
      631 clean_up_handler: proc;
      632 
      633 	if adp ^= null then do;
      634 	     if ad.terminal_iocbp ^= null then call iox_$detach_iocb (ad.terminal_iocbp, ignore);
      635 	     free adp -> ad in (my_area);
      636 	     if ad.stat_term_rec_ptr ^= null then do;
      637 		free ad.stat_term_rec_ptr -> terminal_io_record in (my_area);
      638 		ad.stat_term_rec_ptr = null;
      639 	     end;
      640 	     adp = null;
      641 	end;
      642 
      643 	return;
      644 
      645      end clean_up_handler;
      646 
      647 
      648 handler: proc;
      649 
      650 /* This proc handles faults that occur while masked */
      651 
      652 	if mask then call hcs_$reset_ips_mask (mask, mask);
      653 
      654 	mask = "0"b;
      655 
      656 	call continue_to_signal_ (ignore);
      657 
      658 	return;
      659 
      660      end handler;
      661 
      662 
      663 
      664 allocate_tio_rec: proc;
      665 
      666 	allocate terminal_io_record in (my_area) set (ad.stat_term_rec_ptr);
      667 	terminal_io_record_ptr = ad.stat_term_rec_ptr;
      668 
      669 	unspec (terminal_io_record) = "0"b;		/* clear any garbage */
      670 
      671 	terminal_io_record.version = terminal_io_record_version_1; /* announce our view of the record structure */
      672 	terminal_io_record.device_type = ad.device_type;	/* inform the terminal dim if we are a reader or punch */
      673 	terminal_io_record.element_size = terminal_io_record_element_size; /* set by our caller */
      674 	terminal_io_record.n_elements = terminal_io_record_n_elements;
      675 
      676 	return;
      677 
      678      end allocate_tio_rec;
      679 
      680 send_binary: proc;
      681 
      682 	terminal_io_record.n_elements = ad.rec_len;	/* set the data record size */
      683 
      684 	if ad.stream_output then			/* for the stream interface to the terminal */
      685 	     call iox_$put_chars (ad.terminal_iocbp, addr (terminal_io_record.bits), ad.rec_len, code);
      686 	else do;
      687 	     call iox_$write_record (ad.terminal_iocbp, terminal_io_record_ptr,
      688 		4 * currentsize (terminal_io_record), code);
      689 	end;
      690 	if code ^= 0 then go to put_chars_ret;
      691 
      692 	ad.records_sent = ad.records_sent + 1;		/* account for all records we send */
      693 	ad.rec_len = 0;				/* not holding any data */
      694 
      695      end send_binary;
      696 
      697 
      698 
      699 
      700 send_chars: proc;
      701 
      702 	terminal_io_record.n_elements = ad.out_pos - 1;	/* define the final length of this record */
      703 	if ad.stream_output then
      704 	     call iox_$put_chars (ad.terminal_iocbp, addr (terminal_io_record.bits), ad.out_pos - 1, code);
      705 	else call iox_$write_record (ad.terminal_iocbp, terminal_io_record_ptr,
      706 		4 * currentsize (terminal_io_record), code);
      707 	if code ^= 0 then go to put_chars_ret;
      708 	ad.records_sent = ad.records_sent + 1;		/* for the accounting, only count successful writes */
      709 	ad.out_pos = 1;				/* start in column 1 */
      710 
      711      end send_chars;
      712 
      713 /* Automatic */
      714 
      715 dcl  code fixed bin (35);
      716 dcl  com_err_sw bit (1);				/* Set if com_err_ sould be called on attach error */
      717 dcl  count fixed bin;				/* number of spaces to move to tab stop */
      718 dcl  device_type char (32);				/* temp for value of the -device att opt */
      719 dcl  dummy char (32) var;
      720 dcl  idx fixed bin;					/* index variable for do loops */
      721 dcl  ignore fixed bin (35);
      722 dcl  in_pos fixed bin (24);				/* index of next element in callers data */
      723 dcl  infop ptr;
      724 dcl  iocbp ptr;
      725 dcl  mask bit (36) aligned;				/* For setting ips mask */
      726 dcl  max_size fixed bin (24); dcl char char (1);		/* test char for editing output */
      727 dcl  my_options char (64) var;			/* this should be small */
      728 dcl  open_mode fixed bin;
      729 dcl  order char (32);
      730 dcl  data_len fixed bin;				/* length of data to fill out current output record */
      731 dcl  remaining_count fixed bin (24);			/* number of data elements to be punched */
      732 dcl  residue fixed bin;				/* spaces to be added to next card image */
      733 dcl  tab_stop fixed bin;				/* next tab stop for tab calculations */
      734 dcl  terminal_attach_desc char (256) var;
      735 dcl  terminal_attach_name char (32) var;
      736 dcl  terminal_attach_options char (256) var;
      737 dcl  wp ptr;					/* input data workspace pointer */
      738 
      739 /* Internal Static	*/
      740 
      741 dcl  attach_count fixed bin int static init (0);
      742 dcl  areap ptr int static init (null);
      743 dcl  static_com_err_sw bit (1) int static init ("0"b);	/* for testing attach options */
      744 
      745 /* Based variables */
      746 
      747 dcl  my_area area (WORDS_PER_SEGMENT) based (areap);
      748 
      749 dcl  bit_string bit (BITS_PER_SEGMENT) based;		/* input data for binary punching */
      750 dcl  char_string char (CHARS_PER_SEGMENT) based;		/* input data for character punching */
      751 
      752 /* Constants */
      753 
      754 dcl  remote_device_name char (13) int static options (constant) init ("remote_punch_");
      755 dcl  punch_device char (32) int static options (constant) init ("punch");
      756 dcl  space char (1) static init (" ") int options (constant);
      757 dcl  HT char (1) int static options (constant) init ("	");
      758 dcl  NL char (1) int static options (constant) init ("
      759 ");
      760 dcl  CR char (1) int static options (constant) init ("");
      761 dcl  VT char (1) int static options (constant) init ("");
      762 dcl  FF char (1) int static options (constant) init ("");
      763 
      764 /* External stuff */
      765 
      766 dcl  continue_to_signal_ entry (fixed bin (35));
      767 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
      768 dcl  hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned);
      769 dcl  hcs_$set_ips_mask entry (bit (36) aligned, bit (36) aligned);
      770 dcl  com_err_ entry options (variable);
      771 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
      772 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      773 dcl  iox_$close entry (ptr, fixed bin (35));
      774 dcl  iox_$open entry (ptr, fixed bin, bit (36), fixed bin (35));
      775 dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
      776 dcl  iox_$write_record entry (ptr, ptr, fixed bin, fixed bin (35));
      777 dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
      778 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      779 dcl  iox_$propagate entry (ptr);
      780 dcl  iox_$position entry (ptr, fixed bin, fixed bin (24), fixed bin (35));
      781 dcl  iox_$err_no_operation entry;
      782 
      783 dcl  error_table_$bad_arg ext fixed bin (35);
      784 dcl  error_table_$bad_mode ext fixed bin (35);
      785 dcl  error_table_$not_attached ext fixed bin (35);
      786 dcl  error_table_$not_open ext fixed bin (35);
      787 dcl  error_table_$not_closed ext fixed bin (35);
      788 dcl  error_table_$not_detached ext fixed bin (35);
      789 dcl  error_table_$wrong_no_of_args ext fixed bin (35);
      790 dcl  error_table_$noarg ext fixed bin (35);
      791 dcl  error_table_$badopt ext fixed bin (35);
      792 dcl  error_table_$no_operation ext fixed bin (35);
      793 
      794 
      795 /* Conditions and Builtins */
      796 
      797 dcl  (addr, character, convert, currentsize, divide, empty, hbound, ltrim, min, null, rank, rtrim, substr, unspec) builtin;
      798 
      799 dcl  (any_other, cleanup, conversion) condition;
      800 
      801 dcl  adp ptr;
      802 
      803 dcl  1 ad aligned based (adp),
      804        2 fixed,
      805          3 device_type fixed bin,			/* one of the codes defined in terminal_io_record.incl.pl1 */
      806          3 records_sent fixed bin,			/* for accounting, card images sent */
      807          3 card_ll fixed bin,				/* number of columns per card starting in col 1 */
      808          3 out_pos fixed bin,				/* next available output buffer element index */
      809          3 rec_len fixed bin,				/* length of bits in record */
      810          3 tab_idx fixed bin,				/* virtual carriage position for tab calculations */
      811        2 bits,
      812          3 binary bit (1) unal,			/* TRUE when in binary punch mode */
      813          3 edited bit (1) unal,			/* TRUE when character editing is to be done */
      814          3 htab bit (1) unal,				/* TRUE when HT chars are allowed to be sent */
      815          3 stream_output bit (1) unal,			/* TRUE if stream interface to terminal is needed */
      816        2 ptrs,
      817          3 terminal_iocbp ptr,			/* iocbp for terminal dim of this attachment */
      818          3 stat_term_rec_ptr ptr,			/* pointer to data record */
      819        2 chars,
      820          3 terminal char (32) var,			/* name of the terminal dim */
      821          3 attach_desc char (256) var,			/* attach description of this attachment */
      822          3 open_description char (24) var;		/* open desc for this attachment */
      823 
      824 dcl  1 counts aligned based (infop),			/* accounting data for caller */
      825        2 line fixed bin,				/* for printers */
      826        2 page_len fixed bin,				/*     "        */
      827        2 lmarg fixed bin,				/*     "         */
      828        2 rmarg fixed bin,				/*     "        */
      829        2 line_count fixed bin,			/* this is the relavent information */
      830        2 page_count fixed bin;			/* this could be used, set to zero */
      831 
  1     1 /* BEGIN INCLUDE FILE ... terminal_io_record.incl.pl1 */
  1     2 /* Created:  November 1979 by G. Palter */
  1     3 /* Modified: 26 March 1982 by G. Palter to make the structure more compatible with use of the like attribute */
  1     4 
  1     5 
  1     6 /* Record format used by I/O modules designed for communcation with remote I/O daemon stations */
  1     7 
  1     8 dcl 1 terminal_io_record aligned based (terminal_io_record_ptr),
  1     9       2 header,
  1    10         3 version fixed binary,
  1    11         3 device_type fixed binary,			/* type of device sending/receiving this record --
  1    12*						   reader/printer/punch/teleprinter */
  1    13         3 slew_control,				/* slew control data: used for printer and teleprinter only */
  1    14 	4 slew_type fixed binary (18) unaligned unsigned,	/* type of slewing operation before/after this line --
  1    15*						   by-count/top-of-form/inside-page/outside-page/to-channel */
  1    16 	4 slew_count fixed binary (18) unaligned unsigned,/* # of lines if by count; channel # if to channel */
  1    17         3 flags,
  1    18 	4 binary bit (1) unaligned,			/* ON => data in record should be written in binary mode */
  1    19 	4 preslew bit (1) unaligned,			/* ON => perform above slew before printing data;
  1    20*						   OFF => perform above slew after printing data */
  1    21 	4 pad bit (34) unaligned,
  1    22         3 element_size fixed binary,			/* # of bits in a data element */
  1    23         3 n_elements fixed binary (24),			/* # of elements in the record */
  1    24       2 data,					/* force word alignment */
  1    25         3 bits (terminal_io_record_n_elements refer (terminal_io_record.n_elements))
  1    26 	  bit (terminal_io_record_element_size refer (terminal_io_record.element_size)) unaligned;
  1    27 
  1    28 dcl  terminal_io_record_ptr pointer;
  1    29 
  1    30 dcl  terminal_io_record_element_size fixed binary;	/* used for allocating terminal_io_record structures */
  1    31 dcl  terminal_io_record_n_elements fixed binary (24);
  1    32 
  1    33 
  1    34 /* Manifest constants */
  1    35 
  1    36 dcl  terminal_io_record_version_1 fixed binary static options (constant) initial (1);
  1    37 
  1    38 dcl (TELEPRINTER_DEVICE	initial (1),
  1    39      READER_DEVICE		initial (2),
  1    40      PRINTER_DEVICE		initial (3),
  1    41      PUNCH_DEVICE		initial (4))
  1    42 	fixed binary static options (constant);
  1    43 
  1    44 dcl (SLEW_BY_COUNT		initial (1),
  1    45      SLEW_TO_TOP_OF_PAGE	initial (2),
  1    46      SLEW_TO_INSIDE_PAGE	initial (3),		/* skip to top of next inside page (head sheet) */
  1    47      SLEW_TO_OUTSIDE_PAGE	initial (4),		/* skip to top of next outside page (tail sheet) */
  1    48      SLEW_TO_CHANNEL	initial (5))		/* skip to specified channel stop */
  1    49 	fixed binary static options (constant);
  1    50 
  1    51 
  1    52 /* Data in record as a character string (terminal_io_record.element_size = 9) */
  1    53 
  1    54 dcl  terminal_io_record_data_chars character (terminal_io_record.n_elements) unaligned
  1    55 	based (addr (terminal_io_record.bits));
  1    56 
  1    57 dcl  terminal_io_record_data_chars_varying_max_len fixed binary (21);  /* Set this before using the varying string. */
  1    58 dcl  terminal_io_record_data_chars_varying character (terminal_io_record_data_chars_varying_max_len) varying
  1    59 	based (addr (terminal_io_record.n_elements));	/* varying string consists of length and data */
  1    60 
  1    61 
  1    62 /* Data in record as a bit string (terminal_io_record.element_size = 1) */
  1    63 
  1    64 dcl terminal_io_record_data_bits bit (terminal_io_record.n_elements) unaligned based (addr (terminal_io_record.bits));
  1    65 
  1    66 /* END INCLUDE FILE ... terminal_io_record.incl.pl1 */
      832 
      833 
  2     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  2     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  2     3*      version number to IOX2. */
  2     4 /* format: style2 */
  2     5 
  2     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  2     7 	     2 version	      character (4) aligned,	/* IOX2 */
  2     8 	     2 name	      char (32),		/* I/O name of this block. */
  2     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    17 						/* open(p,mode,not_used,s) */
  2    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    24 						/* put_chars(p,bufptr,buflen,s) */
  2    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    26 						/* modes(p,newmode,oldmode,s) */
  2    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    28 						/* position(p,u1,u2,s) */
  2    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    30 						/* control(p,order,infptr,s) */
  2    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    34 						/* write_record(p,bufptr,buflen,s) */
  2    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    36 						/* rewrite_record(p,bufptr,buflen,s) */
  2    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    39 						/* seek_key(p,key,len,s) */
  2    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    41 						/* read_key(p,key,len,s) */
  2    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  2    43 						/* read_length(p,len,s) */
  2    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  2    45 						/* open_file(p,mode,desc,not_used,s) */
  2    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  2    47 						/* close_file(p,desc,s) */
  2    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  2    49 						/* detach(p,desc,s) */
  2    50 
  2    51      declare iox_$iocb_version_sentinel
  2    52 			      character (4) aligned external static;
  2    53 
  2    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      834 
      835 
  3     1 /* Begin include file ..... iox_modes.incl.pl1 */
  3     2 
  3     3 /* Written by C. D. Tavares, 03/17/75 */
  3     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  3     5 
  3     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  3     7     ("stream_input", "stream_output", "stream_input_output",
  3     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  3     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  3    10      "direct_input", "direct_output", "direct_update");
  3    11 
  3    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  3    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  3    14 
  3    15 dcl (Stream_input initial (1),
  3    16      Stream_output initial (2),
  3    17      Stream_input_output initial (3),
  3    18      Sequential_input initial (4),
  3    19      Sequential_output initial (5),
  3    20      Sequential_input_output initial (6),
  3    21      Sequential_update initial (7),
  3    22      Keyed_sequential_input initial (8),
  3    23      Keyed_sequential_output initial (9),
  3    24      Keyed_sequential_update initial (10),
  3    25      Direct_input initial (11),
  3    26      Direct_output initial (12),
  3    27      Direct_update initial (13)) fixed bin int static options (constant);
  3    28 
  3    29 /* End include file ..... iox_modes.incl.pl1 */
      836 
      837 
  4     1 /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
  4     5*     install(86-11-21,MR12.0-1223):
  4     6*     created.
  4     7*                                                   END HISTORY COMMENTS */
  4     8 
  4     9 /* format: off */
  4    10 
  4    11 /* ************************************************************************ */
  4    12 /*							      */
  4    13 /* Function: Provides constants for commonly used Multics system values.    */
  4    14 /*							      */
  4    15 /* Usage: These values are available for use in place of "magic" numbers    */
  4    16 /*        (unexplained numbers) in programming applications.	      */
  4    17 /*							      */
  4    18 /* Definitions:						      */
  4    19 /*							      */
  4    20 /*   PER             bit     character/byte     word     page     segment   */
  4    21 /*		 					      */
  4    22 /*   bits              1            9             36     36864    9400320   */
  4    23 /*   characters/bytes	      1	           4      4096    1044480   */
  4    24 /*   words				 1      1024     261120   */
  4    25 /*   pages				           1        255   */
  4    26 /*   segments						  1   */
  4    27 /*							      */
  4    28 /*  The base values for a bit, char, word and page are determined by the    */
  4    29 /*  Multics hardware implementation.  The other values are calculated from  */
  4    30 /*  their relation to one another as shown in the matrix above.	      */
  4    31 /*							      */
  4    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
  4    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
  4    34 /*		  = 9 * 4					      */
  4    35 /*		  = 36					      */
  4    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
  4    37 /*		  = 9 * 4 * 1024				      */
  4    38 /*		  = 36864					      */
  4    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
  4    40 /*		    PAGES_PER_SEGMENT			      */
  4    41 /*		  = 9 * 4 * 1024 * 255			      */
  4    42 /*		  = 9400320				      */
  4    43 /*							      */
  4    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
  4    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
  4    46 /*		  = 4 * 1024				      */
  4    47 /*		  = 4096					      */
  4    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
  4    49 /*		  = 4 * 1024 * 255				      */
  4    50 /*		  = 1044480				      */
  4    51 /*							      */
  4    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
  4    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
  4    54 /*		  = 1024 * 255				      */
  4    55 /*		  = 261120				      */
  4    56 /*							      */
  4    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
  4    58 /*							      */
  4    59 /* ************************************************************************ */
  4    60 
  4    61        declare BITS_PER_CHAR		fixed bin (4) internal static
  4    62 				options (constant) initial (9);
  4    63 
  4    64        declare BITS_PER_WORD		fixed bin (6) internal static
  4    65 				options (constant) initial (36);
  4    66 
  4    67        declare BITS_PER_PAGE		fixed bin (16) internal static
  4    68 				options (constant) initial (36864);
  4    69 
  4    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
  4    71 				options (constant) initial (9400320);
  4    72 
  4    73        declare CHARS_PER_WORD		fixed bin (3) internal static
  4    74 				options (constant) initial (4);
  4    75 
  4    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
  4    77 				options (constant) initial (4096);
  4    78 
  4    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
  4    80 				options (constant) initial (1044480);
  4    81 
  4    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
  4    83 
  4    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
  4    85 				options (constant) initial (1024);
  4    86 
  4    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
  4    88 
  4    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
  4    90 				options (constant) initial (261120);
  4    91 
  4    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
  4    93 				options (constant) initial (255);
  4    94 
  4    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
  4    96 
      838 
      839 
      840      end remote_punch_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/19/88  1330.0  remote_punch_.pl1                 >special_ldd>install>MR12.2-1014>remote_punch_.pl1
832          1    11/12/82  1624.8  terminal_io_record.incl.pl1       >ldd>include>terminal_io_record.incl.pl1
834          2    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
836          3    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
838          4    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_SEGMENT                000001 constant        fixed bin(24,0)          initial dcl 4-70 ref 366 394 404
CHARS_PER_SEGMENT               000000 constant        fixed bin(21,0)          initial dcl 4-79 ref 367 441 475
CR                                     constant        char(1)                  initial unaligned dcl 760 ref 447 476
FF                                     constant        char(1)                  initial unaligned dcl 762 ref 447 476
HT                                     constant        char(1)                  initial unaligned dcl 757 ref 451
NL                                     constant        char(1)                  initial unaligned dcl 758 ref 447 476
PUNCH_DEVICE                           constant        fixed bin(17,0)          initial dcl 1-38 ref 82
READER_DEVICE                          constant        fixed bin(17,0)          initial dcl 1-38 ref 145
Sequential_output               000002 constant        fixed bin(17,0)          initial dcl 3-15 set ref 271*
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 3-15 ref 266
Stream_output                   000162 constant        fixed bin(17,0)          initial dcl 3-15 set ref 266 275*
VT                                     constant        char(1)                  initial unaligned dcl 761 ref 447 476
WORDS_PER_SEGMENT                      constant        fixed bin(21,0)          initial dcl 4-89 ref 66
a_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 51 55* 191* 199 202* 206* 211* 249
                                                                                  252* 256* 261* 267* 271* 272 275* 276 304 307*
                                                                                  311* 316* 349 358* 362* 370* 486* 493 505* 550*
                                                                                  556 560* 563* 567* 573 579* 583* 585*
a_data_count                           parameter       fixed bin(24,0)          dcl 41 ref 349 369 369 377
a_data_ptr                             parameter       pointer                  dcl 40 ref 349 378
a_infop                                parameter       pointer                  dcl 45 ref 493 503
a_iocbp                                parameter       pointer                  dcl 35 ref 51 53 199 201 249 251 304 306 349 357 493
                                                                                  495 556 558 573 575
a_mode                                 parameter       fixed bin(17,0)          dcl 39 ref 249 265
a_option                               parameter       varying char             array dcl 36 ref 51 86 103 104 104 108 108 112 116
                                                                                  121 121 125 129 131 605 607 609
a_order                                parameter       char                     unaligned dcl 44 ref 493 504
a_pos_type                             parameter       fixed bin(17,0)          dcl 42 set ref 573 585*
a_pos_value                            parameter       fixed bin(24,0)          dcl 43 set ref 573 585*
a_sw                                   parameter       bit(1)                   unaligned dcl 37 ref 51 54 249
actual_iocb_ptr          12            based           pointer                  level 2 dcl 2-6 ref 251 306 357 495 558 575
ad                                     based           structure                level 1 dcl 803 set ref 71 241 635
addr                                                   builtin function         dcl 797 ref 177 294 374 374 394 404 430 469 684 684
                                                                                  703 703
adp                             000434 automatic       pointer                  dcl 801 set ref 57* 71* 75 76 77 78 79 80 81 82 109
                                                                                  113 119 119 129 136 145 153 153 162 162 164 166
                                                                                  177 179 203* 205 234 236 237 238 241 243* 253* 255
                                                                                  271 272 274 275 279 294 308* 310 323 359* 361 366
                                                                                  374 381 382 388 392 393 394 395 395 396 403 404
                                                                                  406 410 411 417 419 422 424 426 429 431 433 433
                                                                                  448 452 453 454 455 456 456 457 457 460 460 464
                                                                                  469 471 471 472 472 473 473 496* 498 508 509 510
                                                                                  510 511 512 513 519 519 520 522 523 524 528 537
                                                                                  537 538 539 540 541 546 559* 562 567 576* 578 585
                                                                                  633 634 634 635 636 637 638 640* 666 667 672 682
                                                                                  684 684 684 687 692 692 693 702 703 703 703 705
                                                                                  708 708 709
any_other                       000412 stack reference condition                dcl 799 ref 173 189 219 229 283 327
areap                           000012 internal static pointer                  initial dcl 742 set ref 63 64* 66 71 237 241 512 540
                                                                                  635 637 666
attach_count                    000010 internal static fixed bin(17,0)          initial dcl 741 set ref 158* 158 159 159* 160
attach_data_ptr          16            based           pointer                  level 2 dcl 2-6 set ref 179* 203 253 308 359 496 559
                                                                                  576
attach_desc              25            based           varying char(256)        level 3 dcl 803 set ref 162* 177
attach_descrip_ptr       14            based           pointer                  level 2 dcl 2-6 set ref 58 177* 223*
binary                    3            based           bit(1)                   level 4 in structure "terminal_io_record" packed
                                                                                  unaligned dcl 1-8 in procedure "remote_punch_" set
                                                                                  ref 386*
binary                    6            based           bit(1)                   level 3 in structure "ad" packed unaligned dcl 803
                                                                                  in procedure "remote_punch_" set ref 366 381 509*
                                                                                  519 523* 524* 537
bit_string                             based           bit                      unaligned dcl 749 ref 394 404
bits                      6            based           structure                level 2 in structure "ad" dcl 803 in procedure
                                                                                  "remote_punch_" set ref 75*
bits                      6            based           bit                      array level 3 in structure "terminal_io_record"
                                                                                  packed unaligned dcl 1-8 in procedure
                                                                                  "remote_punch_" set ref 394 404 430 469 684 684
                                                                                  703 703
card_ll                   2            based           fixed bin(17,0)          level 3 dcl 803 set ref 81* 119* 119 153 153 419 429
                                                                                  456 457 473
char                            000136 automatic       char(1)                  unaligned dcl 726 set ref 441* 446 447 447 447 447
                                                                                  451 467 469 475* 476 476 476 476
char_string                            based           char                     unaligned dcl 750 ref 441 475
character                                              builtin function         dcl 797 ref 160
chars                    14            based           structure                level 2 dcl 803 set ref 78*
cleanup                         000420 stack reference condition                dcl 799 ref 69 185
close                    36            based           entry variable           level 2 dcl 2-6 set ref 293*
code                            000100 automatic       fixed bin(35,0)          dcl 715 in procedure "remote_punch_" set ref 55* 59*
                                                                                  60* 64* 65 65* 87* 88* 99* 100* 137* 138* 148*
                                                                                  149* 154* 155* 166* 167 167* 191 358* 374* 375 486
                                                                                  499* 505* 522* 523 531* 546* 550 606* 607* 684*
                                                                                  687* 690 703* 705* 707
code                                   parameter       fixed bin(35,0)          dcl 619 in procedure "abort_attach" set ref 616 623*
com_err_                        000026 constant        entry                    external dcl 770 ref 623
com_err_sw                      000101 automatic       bit(1)                   unaligned dcl 716 set ref 54* 623
continue_to_signal_             000016 constant        entry                    external dcl 766 ref 656
control                  66            based           entry variable           level 2 dcl 2-6 set ref 290* 334*
conversion                      000426 stack reference condition                dcl 799 ref 98
convert                                                builtin function         dcl 797 ref 119
count                           000102 automatic       fixed bin(17,0)          dcl 717 set ref 454* 456 457 460
counts                                 based           structure                level 1 dcl 824
currentsize                                            builtin function         dcl 797 ref 687 705
data                      6            based           structure                level 2 dcl 1-8
data_len                        000171 automatic       fixed bin(17,0)          dcl 730 set ref 393* 394 395 398 399
detach_iocb              26            based           entry variable           level 2 dcl 2-6 set ref 181* 333*
device_type               1            based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 1-8
                                                                                  in procedure "remote_punch_" set ref 672*
device_type                     000103 automatic       char(32)                 unaligned dcl 718 in procedure "remote_punch_" set
                                                                                  ref 96* 126* 127 141 141* 143 144* 147 149 164
device_type                            based           fixed bin(17,0)          level 3 in structure "ad" dcl 803 in procedure
                                                                                  "remote_punch_" set ref 82* 145* 672
divide                                                 builtin function         dcl 797 ref 453
dummy                           000113 automatic       varying char(32)         dcl 719 set ref 105* 106 117* 118 119 122* 123
edited                    6(01)        based           bit(1)                   level 3 packed unaligned dcl 803 set ref 79* 113*
                                                                                  464
element_size              4            based           fixed bin(17,0)          level 3 dcl 1-8 set ref 237 394 404 430 469 512 540
                                                                                  637 666* 669 673* 684 684 687 703 703 705
empty                                                  builtin function         dcl 797 ref 66
error_table_$bad_arg            000056 external static fixed bin(35,0)          dcl 783 ref 99 148 154 370
error_table_$bad_mode           000060 external static fixed bin(35,0)          dcl 784 ref 267
error_table_$badopt             000076 external static fixed bin(35,0)          dcl 791 ref 137
error_table_$no_operation       000100 external static fixed bin(35,0)          dcl 792 ref 531
error_table_$noarg              000074 external static fixed bin(35,0)          dcl 790 ref 606
error_table_$not_attached       000062 external static fixed bin(35,0)          dcl 785 ref 206 256 311 362 499 563 579
error_table_$not_closed         000066 external static fixed bin(35,0)          dcl 787 ref 211 261
error_table_$not_detached       000070 external static fixed bin(35,0)          dcl 788 ref 59
error_table_$not_open           000064 external static fixed bin(35,0)          dcl 786 ref 316
error_table_$wrong_no_of_args   000072 external static fixed bin(35,0)          dcl 789 ref 87
fixed                                  based           structure                level 2 dcl 803 set ref 76*
flags                     3            based           structure                level 3 dcl 1-8
get_chars                46            based           entry variable           level 2 dcl 2-6 set ref 288* 338*
get_line                 42            based           entry variable           level 2 dcl 2-6 set ref 289* 339*
get_temp_segment_               000020 constant        entry                    external dcl 767 ref 64
hbound                                                 builtin function         dcl 797 ref 86 103 605
hcs_$reset_ips_mask             000022 constant        entry                    external dcl 768 ref 187 227 298 343 652
hcs_$set_ips_mask               000024 constant        entry                    external dcl 769 ref 175 221 285 329
header                                 based           structure                level 2 dcl 1-8
htab                      6(02)        based           bit(1)                   level 3 packed unaligned dcl 803 set ref 109* 452
idx                             000124 automatic       fixed bin(17,0)          dcl 720 in procedure "remote_punch_" set ref 103*
                                                                                  104 104 105* 108 108 112 116 117* 121 121 122* 125
                                                                                  126* 129 129* 131*
idx                                    parameter       fixed bin(17,0)          dcl 602 in procedure "get_arg" set ref 600 604* 604
                                                                                  605 607 609
ignore                          000125 automatic       fixed bin(35,0)          dcl 721 set ref 234* 323* 634* 656*
in_pos                          000126 automatic       fixed bin(24,0)          dcl 722 set ref 379* 394 398* 398 404 410* 410 441
                                                                                  443* 443 475 478* 478
infop                           000130 automatic       pointer                  dcl 723 set ref 503* 522* 527 528 529 546*
iocb                                   based           structure                level 1 dcl 2-6
iocbp                           000132 automatic       pointer                  dcl 724 set ref 53* 58 60 177 178 179 180 181 183*
                                                                                  201* 203 210 223 225* 251* 253 260 287 288 289 290
                                                                                  291 292 293 294 296* 306* 308 315 331 332 333 334
                                                                                  335 336 337 338 339 341* 357* 359 495* 496 558*
                                                                                  559 575* 576
iox_$attach_ioname              000030 constant        entry                    external dcl 771 ref 166
iox_$close                      000034 constant        entry                    external dcl 773 ref 323
iox_$control                    000046 constant        entry                    external dcl 778 ref 374 522 546
iox_$detach_iocb                000032 constant        entry                    external dcl 772 ref 234 634
iox_$err_no_operation           000054 constant        entry                    external dcl 781 ref 288 289 334 335 336 337 338 339
iox_$modes                      000044 constant        entry                    external dcl 777 ref 567
iox_$open                       000036 constant        entry                    external dcl 774 ref 271 275
iox_$position                   000052 constant        entry                    external dcl 780 ref 585
iox_$propagate                  000050 constant        entry                    external dcl 779 ref 183 225 296 341
iox_$put_chars                  000040 constant        entry                    external dcl 775 ref 684 703
iox_$write_record               000042 constant        entry                    external dcl 776 ref 687 705
iox_modes                       000003 constant        char(24)                 initial array dcl 3-6 ref 279
line_count                4            based           fixed bin(17,0)          level 2 dcl 824 set ref 528*
ltrim                                                  builtin function         dcl 797 ref 160
mask                            000134 automatic       bit(36)                  dcl 725 set ref 171* 175* 187* 187* 217* 221* 227*
                                                                                  227* 281* 285* 298* 298* 325* 329* 343* 343* 652
                                                                                  652* 652* 654*
max_size                        000135 automatic       fixed bin(24,0)          dcl 726 set ref 366* 367* 369
min                                                    builtin function         dcl 797 ref 393 403
modes                    56            based           entry variable           level 2 dcl 2-6 set ref 291* 336*
my_area                                based           area                     dcl 747 set ref 66* 71 237 241 512 540 635 637 666
my_options                      000137 automatic       varying char(64)         dcl 727 set ref 92* 106* 106 110* 110 114* 114 118*
                                                                                  118 123* 123 127* 127 162
n_elements                5            based           fixed bin(24,0)          level 3 dcl 1-8 set ref 237 394 404 429* 430 469 512
                                                                                  540 637 666* 669 674* 682* 687 702* 705
name                      1            based           char(32)                 level 2 dcl 2-6 set ref 60*
new_modes                              parameter       char                     unaligned dcl 47 set ref 556 567*
null                                                   builtin function         dcl 797 ref 57 58 63 77 178 205 210 223 236 238 243
                                                                                  255 260 310 315 331 361 382 417 498 511 513 527
                                                                                  539 541 562 578 633 634 636 638 640
old_modes                              parameter       char                     unaligned dcl 46 set ref 556 567*
open                     32            based           entry variable           level 2 dcl 2-6 set ref 180* 332*
open_descrip_ptr         20            based           pointer                  level 2 dcl 2-6 set ref 178* 210 260 294* 315 331*
open_description        126            based           varying char(24)         level 3 dcl 803 set ref 279* 294
open_mode                       000160 automatic       fixed bin(17,0)          dcl 728 set ref 265* 266 266 279
order                           000161 automatic       char(32)                 unaligned dcl 729 set ref 504* 507 517 522* 526 536
                                                                                  546*
out_pos                   3            based           fixed bin(17,0)          level 3 dcl 803 set ref 426 431* 433* 433 456 457
                                                                                  460* 460 469 471* 471 473 510* 520 538 702 703
                                                                                  709*
page_count                5            based           fixed bin(17,0)          level 2 dcl 824 set ref 529*
position                 62            based           entry variable           level 2 dcl 2-6 set ref 292* 335*
ptrs                     10            based           structure                level 2 dcl 803 set ref 77*
punch_device                    000121 constant        char(32)                 initial unaligned dcl 755 set ref 374 374
put_chars                52            based           entry variable           level 2 dcl 2-6 set ref 287* 337*
rank                                                   builtin function         dcl 797 ref 446 446 467 467
rec_len                   4            based           fixed bin(17,0)          level 3 dcl 803 set ref 392 393 394 395* 395 396
                                                                                  403* 404 406 410 411 510* 519 537 682 684* 693*
records_sent              1            based           fixed bin(17,0)          level 3 dcl 803 set ref 508* 528 692* 692 708* 708
remaining_count                 000172 automatic       fixed bin(24,0)          dcl 731 set ref 377* 390 393 399* 399 403 411* 411
                                                                                  428 438 444* 444 474 477* 477
remote_device_name              000131 constant        char(13)                 initial unaligned dcl 754 set ref 64* 160 162 623*
residue                         000173 automatic       fixed bin(17,0)          dcl 732 set ref 421* 432 433 434* 457*
rtrim                                                  builtin function         dcl 797 ref 127 164 279
space                           005074 constant        char(1)                  initial unaligned dcl 756 ref 131
stat_term_rec_ptr        12            based           pointer                  level 3 dcl 803 set ref 236 237 238* 382 388 417 424
                                                                                  511 512 513* 539 540 541* 636 637 638* 666* 667
static_com_err_sw               000014 internal static bit(1)                   initial unaligned dcl 743 set ref 54 596* 596
str1                                   parameter       char                     dcl 618 set ref 616 623*
str2                                   parameter       char                     dcl 618 set ref 616 623*
stream_output             6(03)        based           bit(1)                   level 3 packed unaligned dcl 803 set ref 80* 272*
                                                                                  274* 684 703
substr                                                 builtin function         dcl 797 set ref 394* 394 404 441 469* 475
tab_idx                   5            based           fixed bin(17,0)          level 3 dcl 803 set ref 422* 448* 453 454 455* 472*
                                                                                  472
tab_stop                        000174 automatic       fixed bin(17,0)          dcl 733 set ref 453* 454 455
terminal                 14            based           varying char(32)         level 3 dcl 803 set ref 129* 136 162 164
terminal_attach_desc            000175 automatic       varying char(256)        dcl 734 set ref 93* 164* 166
terminal_attach_name            000276 automatic       varying char(32)         dcl 735 set ref 94* 160* 166
terminal_attach_options         000307 automatic       varying char(256)        dcl 736 set ref 91* 131* 131 162 164
terminal_io_record                     based           structure                level 1 dcl 1-8 set ref 237 512 540 637 666 669* 687
                                                                                  705
terminal_io_record_data_bits           based           bit                      unaligned dcl 1-64 set ref 394* 404*
terminal_io_record_data_chars          based           char                     unaligned dcl 1-54 set ref 430* 469*
terminal_io_record_element_size 000440 automatic       fixed bin(17,0)          dcl 1-30 set ref 383* 418* 666 666 673
terminal_io_record_n_elements   000441 automatic       fixed bin(24,0)          dcl 1-31 set ref 384* 419* 666 666 674
terminal_io_record_ptr          000436 automatic       pointer                  dcl 1-28 set ref 386 388* 394 394 404 404 424* 429
                                                                                  430 430 469 469 667* 669 671 672 673 674 682 684
                                                                                  684 687* 687 702 703 703 705* 705
terminal_io_record_version_1           constant        fixed bin(17,0)          initial dcl 1-36 ref 671
terminal_iocbp           10            based           pointer                  level 3 dcl 803 set ref 166* 234* 271* 275* 323*
                                                                                  374* 522* 546* 567* 585* 634 634* 684* 687* 703*
                                                                                  705*
unspec                                                 builtin function         dcl 797 set ref 669*
version                                based           fixed bin(17,0)          level 3 dcl 1-8 set ref 671*
wp                              000410 automatic       pointer                  dcl 737 set ref 378* 394 404 441 475

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 4-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 4-67
BITS_PER_WORD                          internal static fixed bin(6,0)           initial dcl 4-64
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 4-76
CHARS_PER_WORD                         internal static fixed bin(3,0)           initial dcl 4-73
Direct_input                           internal static fixed bin(17,0)          initial dcl 3-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 3-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 3-15
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 4-92
PRINTER_DEVICE                         internal static fixed bin(17,0)          initial dcl 1-38
SLEW_BY_COUNT                          internal static fixed bin(17,0)          initial dcl 1-44
SLEW_TO_CHANNEL                        internal static fixed bin(17,0)          initial dcl 1-44
SLEW_TO_INSIDE_PAGE                    internal static fixed bin(17,0)          initial dcl 1-44
SLEW_TO_OUTSIDE_PAGE                   internal static fixed bin(17,0)          initial dcl 1-44
SLEW_TO_TOP_OF_PAGE                    internal static fixed bin(17,0)          initial dcl 1-44
Sequential_input                       internal static fixed bin(17,0)          initial dcl 3-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 3-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 3-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 3-15
TELEPRINTER_DEVICE                     internal static fixed bin(17,0)          initial dcl 1-38
WORDS_PER_PAGE                         internal static fixed bin(11,0)          initial dcl 4-84
iox_$iocb_version_sentinel             external static char(4)                  dcl 2-51
short_iox_modes                        internal static char(4)                  initial array dcl 3-12
terminal_io_record_data_chars_varying  based           varying char             dcl 1-58
terminal_io_record_data_chars_varying_max_len
                                       automatic       fixed bin(21,0)          dcl 1-57

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_attach                    004455 constant        entry                    internal dcl 616 ref 60 65 88 100 138 149 155 167
                                                                                  607
allocate_tio_rec                004647 constant        entry                    internal dcl 664 ref 385 420
attach_return                   002343 constant        label                    dcl 191 ref 627
clean_up_handler                004536 constant        entry                    internal dcl 631 ref 69 625
flip_com_err_sw                 004320 constant        entry                    external dcl 593
get_arg                         004333 constant        entry                    internal dcl 600 ref 105 117 122 126 129
handler                         004616 constant        entry                    internal dcl 648 ref 173 219 283 327
next_char                       003503 constant        label                    dcl 438 ref 426 461 464 467 473
noop_error                      004051 constant        label                    dcl 531 ref 519 520
pass_it_on                      004115 constant        label                    dcl 546 ref 515 543
put_chars_ret                   003653 constant        label                    dcl 486 ref 375 396 406 438 690 707
remote_punch_                   000403 constant        entry                    external dcl 12
remote_punch_attach             000416 constant        entry                    external dcl 51
remote_punch_close              003024 constant        entry                    external dcl 304 ref 293
remote_punch_control            003663 constant        entry                    external dcl 493 ref 290
remote_punch_detach             002352 constant        entry                    external dcl 199 ref 181 333
remote_punch_modes              004152 constant        entry                    external dcl 556 ref 291
remote_punch_open               002536 constant        entry                    external dcl 249 ref 180 332
remote_punch_position           004251 constant        entry                    external dcl 573 ref 292
send                            003651 constant        label                    dcl 481 ref 449 458
send_binary                     004714 constant        entry                    internal dcl 680 ref 397 409 537
send_chars                      004775 constant        entry                    internal dcl 700 ref 481 538
write_elements                  003207 constant        entry                    external dcl 349 ref 287

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5604        5706    5075        5614
Length      6274    5075       102         352     507           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
remote_punch_                       544 external procedure  is an external procedure.  
on unit on line 69                   64 on unit               
on unit on line 98                   90 on unit               
on unit on line 173                  64 on unit               
on unit on line 219                  64 on unit               
on unit on line 283                  64 on unit               
on unit on line 327                  64 on unit               
get_arg                              90 internal procedure  uses returns(char(*)) or returns(bit(*)).  
abort_attach                         84 internal procedure  is called during a stack extension.  
clean_up_handler                     70 internal procedure  is called by several nonquick procedures.  
handler                              70 internal procedure  is called by several nonquick procedures.  
allocate_tio_rec                        internal procedure  shares stack frame of external procedure remote_punch_.  
send_binary                             internal procedure  shares stack frame of external procedure remote_punch_.  
send_chars                              internal procedure  shares stack frame of external procedure remote_punch_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 attach_count                remote_punch_
000012 areap                       remote_punch_
000014 static_com_err_sw           remote_punch_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
remote_punch_            000100 code                        remote_punch_
                         000101 com_err_sw                  remote_punch_
                         000102 count                       remote_punch_
                         000103 device_type                 remote_punch_
                         000113 dummy                       remote_punch_
                         000124 idx                         remote_punch_
                         000125 ignore                      remote_punch_
                         000126 in_pos                      remote_punch_
                         000130 infop                       remote_punch_
                         000132 iocbp                       remote_punch_
                         000134 mask                        remote_punch_
                         000135 max_size                    remote_punch_
                         000136 char                        remote_punch_
                         000137 my_options                  remote_punch_
                         000160 open_mode                   remote_punch_
                         000161 order                       remote_punch_
                         000171 data_len                    remote_punch_
                         000172 remaining_count             remote_punch_
                         000173 residue                     remote_punch_
                         000174 tab_stop                    remote_punch_
                         000175 terminal_attach_desc        remote_punch_
                         000276 terminal_attach_name        remote_punch_
                         000307 terminal_attach_options     remote_punch_
                         000410 wp                          remote_punch_
                         000434 adp                         remote_punch_
                         000436 terminal_io_record_ptr      remote_punch_
                         000440 terminal_io_record_element_size
                                                            remote_punch_
                         000441 terminal_io_record_n_elements
                                                            remote_punch_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      return_chars_eis    any_to_any_truncate_op_alloc_
op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           get_temp_segment_             hcs_$reset_ips_mask
hcs_$set_ips_mask             iox_$attach_ioname            iox_$close                    iox_$control
iox_$detach_iocb              iox_$err_no_operation         iox_$modes                    iox_$open
iox_$position                 iox_$propagate                iox_$put_chars                iox_$write_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_mode         error_table_$badopt           error_table_$no_operation
error_table_$noarg            error_table_$not_attached     error_table_$not_closed       error_table_$not_detached
error_table_$not_open         error_table_$wrong_no_of_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000402        51 000410        53 000434        54 000440        55 000447        57 000451        58 000453
     59 000456        60 000460        63 000504        64 000511        65 000531        66 000556        69 000562
     71 000604        75 000612        76 000622        77 000630        78 000633        79 000636        80 000640
     81 000642        82 000644        86 000646        87 000653        88 000656        91 000704        92 000705
     93 000706        94 000707        96 000710        98 000713        99 000727       100 000732       101 000756
    103 000757       104 000771       105 001016       106 001046       107 001103       108 001105       109 001117
    110 001122       111 001134       112 001135       113 001142       114 001145       115 001157       116 001160
    117 001165       118 001215       119 001252       120 001264       121 001265       122 001277       123 001327
    124 001364       125 001366       126 001373       127 001417       128 001466       129 001470       131 001527
    132 001567       136 001572       137 001600       138 001603       141 001626       143 001636       144 001642
    145 001645       146 001647       147 001650       148 001654       149 001657       153 001705       154 001713
    155 001716       158 001744       159 001746       160 001753       162 002017       164 002072       166 002152
    167 002217       171 002245       173 002246       175 002270       177 002303       178 002307       179 002311
    180 002313       181 002317       183 002322       185 002331       187 002332       189 002342       191 002343
    195 002345       199 002346       201 002362       202 002366       203 002367       205 002371       206 002375
    207 002400       210 002401       211 002405       212 002410       217 002411       219 002412       221 002434
    223 002447       225 002452       227 002461       229 002471       234 002472       236 002504       237 002511
    238 002521       241 002524       243 002526       245 002530       249 002531       251 002546       252 002553
    253 002554       255 002556       256 002562       257 002565       260 002566       261 002572       262 002575
    265 002576       266 002600       267 002604       268 002607       271 002610       272 002627       274 002635
    275 002640       276 002657       279 002661       281 002713       283 002714       285 002736       287 002751
    288 002756       289 002762       290 002764       291 002767       292 002772       293 002775       294 003000
    296 003003       298 003011       300 003021       304 003022       306 003034       307 003041       308 003042
    310 003044       311 003050       312 003053       315 003054       316 003060       317 003063       323 003064
    325 003075       327 003076       329 003120       331 003133       332 003136       333 003142       334 003145
    335 003151       336 003153       337 003155       338 003157       339 003161       341 003163       343 003171
    345 003201       349 003202       357 003217       358 003224       359 003226       361 003230       362 003234
    363 003237       366 003240       367 003246       369 003250       370 003254       371 003257       374 003260
    375 003312       377 003314       378 003317       379 003322       381 003324       382 003330       383 003334
    384 003336       385 003340       386 003341       387 003344       388 003345       390 003347       392 003352
    393 003355       394 003363       395 003375       396 003377       397 003402       398 003403       399 003405
    400 003407       403 003410       404 003415       406 003425       409 003430       410 003431       411 003434
    413 003436       414 003437       417 003440       418 003444       419 003446       420 003450       421 003451
    422 003452       423 003455       424 003456       426 003460       428 003464       429 003466       430 003472
    431 003475       432 003477       433 003501       434 003502       438 003503       441 003505       443 003513
    444 003514       446 003516       447 003526       448 003537       449 003542       451 003543       452 003545
    453 003551       454 003557       455 003561       456 003563       457 003567       458 003574       460 003575
    461 003577       463 003600       464 003601       466 003605       467 003606       469 003612       471 003620
    472 003621       473 003622       474 003625       475 003627       476 003635       477 003646       478 003650
    481 003651       483 003652       486 003653       489 003655       493 003656       495 003701       496 003706
    498 003710       499 003714       500 003717       503 003720       504 003723       505 003730       507 003732
    508 003736       509 003737       510 003741       511 003743       512 003747       513 003757       515 003762
    517 003763       519 003767       520 003774       522 003777       523 004023       524 004031       525 004034
    526 004035       527 004041       528 004045       529 004047       530 004050       531 004051       535 004054
    536 004055       537 004061       538 004070       539 004074       540 004101       541 004111       543 004114
    546 004115       550 004142       552 004144       556 004145       558 004175       559 004202       560 004204
    562 004205       563 004211       564 004214       567 004215       569 004243       573 004244       575 004261
    576 004266       578 004270       579 004274       580 004277       583 004300       585 004301       587 004316
    593 004317       596 004325       598 004331       600 004332       604 004340       605 004342       606 004350
    607 004352       608 004425       609 004426       616 004454       623 004475       625 004525       627 004532
    631 004535       633 004543       634 004550       635 004565       636 004570       637 004576       638 004606
    640 004612       643 004614       648 004615       652 004623       654 004635       656 004637       658 004646
    664 004647       666 004650       667 004667       669 004670       671 004703       672 004705       673 004707
    674 004711       676 004713       680 004714       682 004715       684 004721       687 004744       690 004767
    692 004771       693 004773       695 004774       700 004775       702 004776       703 005003       705 005031
    707 005054       708 005056       709 005060       711 005062


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
