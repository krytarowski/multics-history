	COMPILATION LISTING OF SEGMENT rcp_list
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/25/86  1206.4 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
       14*     audit(85-12-19,CLJones):
       15*     Support for MCA.
       16*                                                   END HISTORY COMMENTS */
       17 rcp_list: procedure;
       18 
       19 /*	This program is a command that lists data copied from RCP.
       20*   *	Created on 12/26/74 by Bill Silver.
       21*   *	Modified on 04/10/78 by Michael R. Jordan to add -unattached as part of preloaded volume effort.
       22*   *	Modified on 12/09/78 by Michael R. Jordan to add -reserved and speed qualifier for tapes.
       23*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
       24*   *      Modified 1984-09-19 stop using decimal_date_time_. JAFalksen
       25*   *	Modified 1985-02-07 add support or the MCA (the 8th device)
       26*   *	In order to use this command one must have access to the gate rcp_sys_.
       27*   *	If this command is called with no arguments it will type out information
       28*   *	obtained from RCP for all devices of all types.  Note, the formline_ control
       29*   *	"^-" is not used since this command will usually be executed via system_control_
       30*   *	and the message coordinator.
       31*   *	The following arguments are valid:
       32*   *
       33*   *	(list)		Ignored.  Needed by system control when called by operator.
       34*   *	(-long)   (-lg)	Type all info known about device or device type.
       35*   *	(-type)   (-tp)	Type info about all devices of this one type.
       36*   *	(-device) (-dv)	Type info about this one ddevice.
       37*   *	(-mounts) (-mnt)	List pending mount requests.
       38*   *	(-unattached) (-unat) List unattached, but loaded volumes.
       39*   *	(-reserved) (-resv)	List information about reservations.
       40**/
       41 
       42 /*		AUTOMATIC  DATA		*/
       43 
       44 	dcl     arg_len		 fixed bin;	/* Length of argument. */
       45 	dcl     arg_ptr		 ptr;		/* Pointer to current argument. */
       46 	dcl     argx		 fixed bin;	/* Number  of current argument. */
       47 	dcl     density_comment	 char (30) varying; /* Used to print density capabilities. */
       48 	dcl     density_ptr		 ptr;		/* Pointer to density characteristics. */
       49 	dcl     device_name		 char (32);	/* Device name. */
       50 	dcl     device_type		 char (32);	/* Device type name. */
       51 	dcl     dtypex		 fixed bin;	/* Device type index. */
       52 	dcl     ecode		 fixed bin (35);	/* error_table_ code. */
       53 	dcl     (i, j)		 fixed bin;	/* Work variables. */
       54 	dcl     list_index		 fixed bin;	/* Used to decide what to type. */
       55 	dcl     long_flag		 bit (1);		/* ON => type everything we can. */
       56 	dcl     max_copy_size	 fixed bin (19);	/* Max size of copy buffer. */
       57 	dcl     num_args		 fixed bin;	/* Number of command arguments. */
       58 	dcl     num_mounts		 fixed bin;	/* Number of pending mount requests */
       59 	dcl     num_reserved	 fixed bin;	/* Number of resources reserved. */
       60 	dcl     num_unattached	 fixed bin;	/* Number of unattached, loaded volumes. */
       61 	dcl     option		 char (12);	/* Command option name. */
       62 	dcl     option_code		 fixed bin;	/* Used to describe option's value argument. */
       63 	dcl     speed_comment	 char (30) varying; /* Used to print speed capabilities. */
       64 	dcl     speed_ptr		 ptr;		/* Pointer to speed qualifier for tape drives. */
       65 	dcl     time_string		 char (24);	/* used to print out state time. */
       66 	dcl     volume_name		 char (32);
       67 
       68 /*		BASED  DATA		*/
       69 
       70 	dcl     argument		 char (arg_len) based (arg_ptr); /* Used to reference command argument. */
       71 
       72 	dcl     based_density	 bit (5) based (density_ptr) aligned;
       73 
       74 	dcl     based_speed		 bit (3) based (speed_ptr) aligned;
       75 
       76 
       77 /*		INTERNAL STATIC DATA	*/
       78 
       79 	dcl     temp_seg_ptr	 ptr /* Pointer to rcp_list_seg. */
       80 				 internal static init (null ());
       81 
       82 	dcl     brief_options	 (7) char (5) /* Brief form of command options. */
       83 				 internal static init ("ls", "-lg", "-tp", "-dv", "-mnt", "-unat", "-resv");
       84 
       85 	dcl     long_options	 (7) char (12) /* Long form of command options. */
       86 				 internal static init ("list", "-long", "-type", "-device", "-mounts", "-unattached", "-reserved");
       87 
       88 	dcl     option_codes	 (7) fixed bin /* 0 => no value arg,  1 => value arg. */
       89 				 internal static init (0, 0, 1, 1, 0, 0, 0);
       90 
       91 	dcl     device_states	 (0:4) char (15) /* States of an RCPD device entry. */
       92 				 internal static init ("free", "assigned", "deleted", "storage system", "reserved");
       93 
       94 	dcl     density_names	 (5) char (5) varying /* Descriptions of tape densities. */
       95 				 internal static init ("200 ", "556 ", "800 ", "1600 ", "6250 ");
       96 
       97 	dcl     speed_names		 (3) char (4) varying /* Tape drive speed names. */
       98 				 internal static init ("75 ", "125 ", "200 ");
       99 
      100 
      101 /*		EXTERNAL ENTRIES CALLED	*/
      102 
      103 	dcl     (addr, hbound, index, null, substr) builtin;
      104 
      105 	dcl     (error_table_$badopt,
      106 	        error_table_$name_not_found,
      107 	        error_table_$odd_no_of_args,
      108 	        error_table_$wrong_no_of_args) fixed bin (35) external;
      109 
      110 	dcl     sys_info$time_correction_constant fixed bin (71) ext;
      111 
      112 	dcl     com_err_		 entry options (variable);
      113 	dcl     cu_$arg_count	 entry (fixed bin);
      114 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
      115 	dcl     date_time_		 entry (fixed bin (71), char (*));
      116 	dcl     date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
      117 	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      118 	dcl     ioa_		 entry options (variable);
      119 	dcl     rcp_sys_$copy_data	 entry (ptr, fixed bin (19), fixed bin (35));
      120 	dcl     resource_info_$get_dtypex entry (char (*), char (*), fixed bin, fixed bin (35));
      121 
  1     1 /*	Begin  include file ... rcp_data_info.incl.pl1
  1     2*   *
  1     3*   *	Created on 04/03/75 by Bill Silver.
  1     4*   *	Modified on 04/24/78 by Michael R. Jordan to add the attached and loaded bits.
  1     5*   *	Modified on 11/19/78 by Michael R. Jordan to add reservation information and volume entries (version 2).
  1     6*   *	Modified 6/79 by Michael R. Jordan for 32 character device types (version 3).
  1     7*   *	This include file is used to copy data from rcp_data.
  1     8**/
  1     9 dcl  rdi_ptr ptr;					/* Pointer to base of the rdi structure. */
  1    10 dcl  ddtype_ptr ptr;				/* Points to a ddtype entry. */
  1    11 dcl  ddevice_ptr ptr;				/* Points to a ddevice entry. */
  1    12 dcl  dvolume_ptr ptr;				/* Points to a dvolume entry. */
  1    13 
  1    14 dcl  rdi_version_3 fixed bin static internal options (constant) init (3); /* Version number of this structure. */
  1    15 
  1    16 dcl 1 rdi based (rdi_ptr) aligned,			/* Beginning of rcp_data_info structure. */
  1    17     2 head like rdi_header,				/* Header of this structure. */
  1    18     2 ddtypes (0 refer (rdi.tot_ddtypes))		/* One entry per device type. */
  1    19      like ddtype,					/* See structure below. */
  1    20     2 ddevices (0 refer (rdi.tot_ddevices))		/* One entry per configured device. */
  1    21      like ddevice,					/* See structure below. */
  1    22     2 dvolumes (0 refer (rdi.tot_dvolumes))		/* One entry per "known" volume. */
  1    23      like dvolume,					/* See structure below. */
  1    24     2 end bit (36) aligned;				/* End of rcp_data_info. */
  1    25 
  1    26 dcl 1 rdi_header based aligned,			/* Header of RCP Data Info structure. */
  1    27     2 version_num fixed bin,				/* The version number of this structure. */
  1    28     2 tot_ddtypes fixed bin,				/* Total number of ddtype entries. */
  1    29     2 tot_ddevices fixed bin,				/* Total number of ddevice entries. */
  1    30     2 tot_dvolumes fixed bin;				/* Total number of dvolume entries. */
  1    31 
  1    32 dcl 1 ddtype based (ddtype_ptr) aligned,		/* Entry for one device type. */
  1    33     2 device_type char (32),				/* Name of this device type. */
  1    34     2 max_concurrent fixed bin,			/* Max num of concurrently assigned devices. */
  1    35     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  1    36     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  1    37     2 first_devicex fixed bin;			/* Index of first device of this type. */
  1    38 
  1    39 dcl 1 ddevice based (ddevice_ptr) aligned,		/* Entry for one device. */
  1    40     2 device_name char (8),				/* Name of device associated with this entry. */
  1    41     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  1    42     2 dtypex fixed bin,				/* Device type index. */
  1    43     2 model fixed bin,				/* Device model number. */
  1    44     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  1    45     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  1    46     2 state_time fixed bin (71),			/* Time device put into current state. */
  1    47     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted. */
  1    48     2 iom_num fixed bin,				/* IOM number for this device. */
  1    49     2 chan_num fixed bin,				/* Channel number for this device. */
  1    50     2 num_channels fixed bin,				/* Num channels that may address device. */
  1    51     2 flags,					/* Special info flags. */
  1    52      (3 reservable bit (1),				/* ON => may be reserved for system process. */
  1    53       3 reserved bit (1),				/* ON => assigned to a system process. */
  1    54       3 mounting bit (1),				/* ON => mount pending. */
  1    55       3 writing bit (1),				/* ON => mounting for writing. */
  1    56       3 attached bit (1),				/* ON => device is attached. */
  1    57       3 loaded bit (1)) unal,				/* ON => device is loaded. */
  1    58     2 group_id char (32),				/* Process group ID. */
  1    59     2 reservation_id fixed bin (71),			/* Reservation id. */
  1    60     2 reserved_by char (32);				/* Group id of user who reserved this device. */
  1    61 
  1    62 dcl 1 dvolume based (dvolume_ptr) aligned,		/* Entry for one volume. */
  1    63     2 process_id bit (36),				/* "0"b => unassigned. */
  1    64     2 volume_name char (32),				/* Volume name. */
  1    65     2 vtypex fixed bin,				/* Volume type index. */
  1    66     2 group_id char (32),				/* This is used for the reserved_for field. */
  1    67     2 reserved_by char (32),
  1    68     2 reservation_id fixed bin (71),
  1    69     2 state_time fixed bin (71),			/* Same as for a device. */
  1    70     2 state fixed bin,				/* Same as for a device. */
  1    71     2 unassign_state fixed bin,			/* State to return when unassigning. */
  1    72     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  1    73 
  1    74 /*	End of include file ... rcp_data_info.incl.pl1	*/
      122 
      123 
  2     1 /* BEGIN INCLUDE FILE ... console_device_specs.incl.pl1 ... 7/15/81, MRJ */
  2     2 
  2     3 /*
  2     4*
  2     5*   The following array defines supported console device model numbers.
  2     6*   Once the index to this array is known it is then used to get the 
  2     7*   'console model index' from the next array.
  2     8*
  2     9**/
  2    10 
  2    11 
  2    12 dcl  CONSOLE_MODEL_NUMBER (8) fixed bin static options (constant)
  2    13      init (8030, 8031, 6001, 6002, 6004, 6005, 6601, 6000);
  2    14 /*          ibm   ibm   emc   scc   emc   scc   lcc   scc */
  2    15 
  2    16 
  2    17 /*
  2    18*
  2    19*
  2    20*   The following array is used to get the 'console model index' that is used
  2    21*   throughout the system to identify which console type is being supported.
  2    22*
  2    23*
  2    24**/
  2    25 
  2    26 
  2    27 dcl  CONSOLE_MODEL_INDEX (8) fixed bin static options (constant)
  2    28      init (1, 1, 2, 3, 2, 3, 4, 3);
  2    29 
  2    30 
  2    31 /*
  2    32*
  2    33*   The following array is indexed by the 'console model index' to determine if
  2    34*   the device is only cabable of BCD support (no ASCII support).
  2    35*
  2    36**/
  2    37 
  2    38 
  2    39 dcl  CONSOLE_IS_BCD (4) bit (1) static options (constant)
  2    40      init ((1)(1)"1"b, (3)(1)"0"b);
  2    41 
  2    42 
  2    43 /*
  2    44*
  2    45*   The following array is indexed by the 'console model index' to determine
  2    46*   if prompting is required by default.  This is true for those consoles where
  2    47*   there is no 'input' light.
  2    48*
  2    49**/
  2    50 
  2    51 
  2    52 dcl  CONSOLE_PROMPT_BY_DEFAULT (4) bit (1) static options (constant)
  2    53      init ((3)(1)"0"b, (1)(1)"1"b);
  2    54 
  2    55 
  2    56 /*
  2    57*
  2    58*   The following array gives the GCOS device type for the specified 'console
  2    59*   model index'.
  2    60*
  2    61**/
  2    62 
  2    63 
  2    64 dcl  CONSOLE_GCOS_TYPE (4) bit (6) static options (constant)
  2    65      init ("30"b3, "31"b3, "31"b3, "31"b3);
  2    66 
  2    67 
  2    68 /* END INCLUDE FILE ... console_device_specs.incl.pl1 */
      124 
      125 
      126 /*	Beginning of the rcp_list command.
      127**/
      128 	ecode,					/* Initialize. */
      129 	     list_index = 0;
      130 	long_flag = "0"b;
      131 	max_copy_size = 64 * 1024;			/* For now just some big number. */
      132 
      133 	call cu_$arg_count (num_args);		/* Get number of command arguments. */
      134 
      135 	do argx = 1 to num_args;			/* Look at each one of them. */
      136 	     call PROCESS_ARG;			/* Go process this argument. */
      137 	     if ecode ^= 0				/* Was there an error with this argument? */
      138 	     then return;				/* Yes, abort the command. */
      139 	end;
      140 
      141 	if temp_seg_ptr = null ()			/* Do we have a temp seg yet? */
      142 	then do;					/* No, get one now. */
      143 		call hcs_$make_seg ("", "rcp_list_seg", "", 01010b, temp_seg_ptr, ecode);
      144 		if temp_seg_ptr = null ()		/* Segment should be there */
      145 		then do;				/* But it wasn't. */
      146 			call com_err_ (ecode, "rcp_list", "Error making rcp_list_seg.");
      147 			return;
      148 		     end;
      149 	     end;
      150 
      151 /*	We will call RCP to copy data from RCP into our buffer segment.
      152*   *	What we output depends upon the long_flag and the list_index.
      153*   *	The following values are used.
      154*   *	     0.	Output header and all devices of all types.
      155*   *	     1.	All devices of specified type.
      156*   *	     2.	The specified ddevice.
      157**/
      158 	rdi_ptr = temp_seg_ptr;			/* RDI structure goes at base of temp seg. */
      159 	rdi.version_num = rdi_version_3;		/* Fill in version number. */
      160 
      161 	call rcp_sys_$copy_data (rdi_ptr, max_copy_size, ecode);
      162 	if ecode ^= 0
      163 	then do;
      164 		call com_err_ (ecode, "rcp_list", "Error getting data from RCP.");
      165 		return;
      166 	     end;
      167 	goto RCPD (list_index);			/* Go to correct routine based on list_index. */
      168 
      169 RCPD (0):						/* Header and all device types. */
      170 	call ioa_ ("^/List of RCP data:");
      171 	if long_flag
      172 	then call ioa_ ("Number of devices   =  ^d", rdi.tot_ddevices);
      173 	do dtypex = 1 to rdi.tot_ddtypes;		/* Output info about all device types. */
      174 	     ddtype_ptr = addr (rdi.ddtypes (dtypex));
      175 	     call LIST_DTYPE;			/* Output info about this device type. */
      176 	end;
      177 	return;
      178 
      179 RCPD (1):						/* Output info about specified device type. */
      180 	do dtypex = 1 to rdi.tot_ddtypes;		/* Look for specified device type. */
      181 	     ddtype_ptr = addr (rdi.ddtypes (dtypex));
      182 	     if ddtype.device_type = device_type	/* Is this the specified device type */
      183 	     then do;				/* Yes. */
      184 		     call LIST_DTYPE;
      185 		     return;
      186 		end;
      187 	end;
      188 	ecode = error_table_$name_not_found;
      189 	call com_err_ (ecode, "rcp_list", "Device type = ^a", device_type);
      190 	return;
      191 
      192 RCPD (2):						/* Output info about specified ddevice. */
      193 	do i = 1 to rdi.tot_ddevices;			/* Look for specified ddevice. */
      194 	     ddevice_ptr = addr (rdi.ddevices (i));
      195 	     if ddevice.device_name = device_name	/* Is this the specified device? */
      196 	     then do;				/* Yes. */
      197 		     ddtype_ptr = addr (rdi.ddtypes (ddevice.dtypex));
      198 		     call LIST_DEVICE;
      199 		     return;
      200 		end;
      201 	end;
      202 	ecode = error_table_$name_not_found;
      203 	call com_err_ (ecode, "rcp_list", "Device name = ^a", device_name);
      204 	return;
      205 
      206 RCPD (3):						/* List pending mount requests. */
      207 	if long_flag				/* If -long, get number of mounts first. */
      208 	then do;
      209 		num_mounts = 0;
      210 		do i = 1 to rdi.tot_ddevices;		/* Test each device. */
      211 		     ddevice_ptr = addr (rdi.ddevices (i));
      212 		     if ddevice.flags.mounting
      213 		     then num_mounts = num_mounts + 1;
      214 		end;
      215 		if num_mounts = 0
      216 		then do;
      217 			call ioa_ ("No pending mounts");
      218 			return;
      219 		     end;
      220 		if num_mounts = 1
      221 		then call ioa_ ("1 pending mount");
      222 		else call ioa_ ("^d pending mounts", num_mounts);
      223 	     end;
      224 
      225 	num_mounts = 0;				/* Reset number of mounts. */
      226 	do i = 1 to rdi.tot_ddevices;			/* Test devices again. */
      227 	     ddevice_ptr = addr (rdi.ddevices (i));
      228 	     if ddevice.flags.mounting		/* Is there a mount pending for this device? */
      229 	     then do;				/* Yes, list it. */
      230 		     num_mounts = num_mounts + 1;	/* Count mounts. */
      231 		     if ^long_flag
      232 		     then call ioa_ ("^a on ^a", ddevice.volume_name, ddevice.device_name);
      233 		     else call ioa_ ("Mount of ^a with^[out^] ^[ring^;protect^] pending on ^a for ^a",
      234 			     ddevice.volume_name,
      235 			     ((ddevice.dtypex = 1) & (^ddevice.flags.writing)) | ((ddevice.dtypex = 2) & (ddevice.flags.writing)),
      236 			     ddevice.dtypex, ddevice.device_name, ddevice.group_id);
      237 		end;
      238 	end;
      239 	if num_mounts = 0
      240 	then call ioa_ ("No pending mounts");
      241 	return;
      242 
      243 RCPD (4):						/* List unattached, loaded volume names. */
      244 	num_unattached = 0;				/* Reset number of volumes in this state. */
      245 
      246 	do i = 1 to rdi.head.tot_ddevices;
      247 	     ddevice_ptr = addr (rdi.ddevices (i));
      248 	     if ddevice.flags.loaded then /* If there is a volume loaded here ... */
      249 		if ^ddevice.flags.attached then do;	/* and it is unattached, report this one. */
      250 			if num_unattached = 0 then
      251 			     call ioa_ ("DEVICE^-VOLUME^-USER^/");
      252 			call ioa_ ("^a^-^a^-^a", ddevice.device_name, ddevice.volume_name, ddevice.group_id);
      253 			num_unattached = num_unattached + 1;
      254 		     end;
      255 	end;
      256 
      257 	if num_unattached = 0
      258 	then call ioa_ ("No unattached, loaded volumes present.");
      259 	return;
      260 
      261 RCPD (5):						/* List reservation information. */
      262 	num_reserved = 0;				/* Reset number of resources in this state. */
      263 
      264 	do i = 1 to rdi.head.tot_ddevices;		/* First look at the devices. */
      265 	     ddevice_ptr = addr (rdi.ddevices (i));
      266 	     if ddevice.reservation_id ^= 0 then do;	/* This one looks like a good one to list. */
      267 		     call LIST_RESERVATION (ddevice.reservation_id, ddevice.group_id, ddevice.reserved_by);
      268 		     num_reserved = num_reserved + 1;
      269 		end;
      270 	end;
      271 
      272 	do i = 1 to rdi.head.tot_dvolumes;		/* Then make sure we haven't missed any volumes. */
      273 	     dvolume_ptr = addr (rdi.dvolumes (i));
      274 	     if dvolume.reservation_id ^= 0 then do;	/* List this one. */
      275 		     call LIST_RESERVATION (dvolume.reservation_id, dvolume.group_id, dvolume.reserved_by);
      276 		     num_reserved = num_reserved + 1;
      277 		end;
      278 	end;
      279 
      280 	if num_reserved = 0
      281 	then call ioa_ ("No reservations.");
      282 	return;
      283 
      284 LIST_DTYPE: procedure;
      285 
      286 /*	This procedure is called to output data from RCP about a device type.
      287*   *	It will output data about every device of this type.
      288**/
      289 	if ^long_flag				/* Are we in long mode? */
      290 	then if ddtype.num_devices > 0		/* No, print only if device type has devices. */
      291 	     then call ioa_ ("^/Device type: ""^a"" ", ddtype.device_type);
      292 	     else ;
      293 	else do;					/* Long mode. */
      294 		call ioa_ ("^/Device type: ""^a"" ", ddtype.device_type);
      295 		call ioa_ ("Number of devices   =  ^d", ddtype.num_devices);
      296 		call ioa_ ("Max concurrent      =  ^d", ddtype.max_concurrent);
      297 		call ioa_ ("System reserved     =  ^d", ddtype.num_reserved);
      298 	     end;
      299 
      300 /* Process every device entry of this type. */
      301 	do i = ddtype.first_devicex to (ddtype.first_devicex + ddtype.num_devices - 1);
      302 	     ddevice_ptr = addr (rdi.ddevices (i));
      303 	     call LIST_DEVICE;
      304 	end;
      305 
      306      end LIST_DTYPE;
      307 
      308 LIST_DEVICE: procedure;
      309 
      310 /*	This procedure is called to output data from RCP about one device.
      311*   *	Some of the information it will type is dependent upon the type of the device.
      312**/
      313 	call ioa_ ("^5x^a device: ^a", ddtype.device_type, ddevice.device_name);
      314 
      315 	call ioa_ ("^10xState     =  ^a", device_states (ddevice.state));
      316 	call date_time_ (ddevice.state_time, time_string);
      317 	call ioa_ ("^10xTime      =  ^a", time_string);
      318 
      319 	if ddevice.state = 1			/* Is device assigned? */
      320 	then call ioa_ ("^10xUser      =  ^a", ddevice.group_id);
      321 
      322 	volume_name = ddevice.volume_name;		/* Save volume name. */
      323 	if ddevice.flags.mounting			/* Is volume being mounted? */
      324 	then do;					/* Yes. */
      325 		if volume_name = " "		/* No volume name implies svratch volume. */
      326 		then volume_name = "scratch";
      327 		call ioa_ ("^10xMount pending for volume: ^a", volume_name);
      328 	     end;
      329 	else if volume_name ^= " "
      330 	then call ioa_ ("^10xVolume    =  ^a", volume_name);
      331 
      332 	if ^long_flag				/* Does user want extra information? */
      333 	then return;				/* No. */
      334 
      335 	if ddevice.flags.reservable
      336 	then call ioa_ ("^10xDevice reservable to system processes");
      337 	if ddevice.flags.reserved
      338 	then call ioa_ ("^10xDevice assigned to a system process");
      339 
      340 	call ioa_ ("^10xIOM #     =  ^d", ddevice.iom_num);
      341 	call ioa_ ("^10xChannel   =  ^d (10)", ddevice.chan_num);
      342 
      343 	goto DTYPE (ddevice.dtypex);			/* Other data depends upon device type. */
      344 
      345 DTYPE (1):					/* TAPE */
      346 	call ioa_ ("^10xModel     =  ^d", ddevice.model);
      347 	call ioa_ ("^10xChannels  =  ^d", ddevice.num_channels);
      348 	call ioa_ ("^10xTracks    =  ^d", ddevice.qualifiers (1));
      349 	density_ptr = addr (ddevice.qualifiers (2));
      350 	density_comment = "";
      351 	do j = 1 to hbound (density_names, 1);		/* Test for each possible density setting. */
      352 	     if substr (based_density, j, 1)		/* If capable of this density add to the list. */
      353 	     then density_comment = density_comment || density_names (j);
      354 	end;
      355 	call ioa_ ("^10xDensities =  ^a", density_comment);
      356 	speed_ptr = addr (ddevice.qualifiers (3));
      357 	speed_comment = "";
      358 	do j = 1 to hbound (speed_names, 1);		/* Test for each possible speed setting. */
      359 	     if substr (based_speed, j, 1)		/* If capable of this speed add to the list. */
      360 	     then speed_comment = speed_comment || speed_names (j);
      361 	end;
      362 	call ioa_ ("^10xSpeed     =  ^a", speed_comment);
      363 	return;
      364 
      365 DTYPE (2):					/* DISK */
      366 	call ioa_ ("^10xModel     =  ^d", ddevice.model);
      367 	call ioa_ ("^10xChannels  =  ^d", ddevice.num_channels);
      368 	return;
      369 
      370 DTYPE (4):					/* PRINTER */
      371 	call ioa_ ("^10xModel     =  ^d", ddevice.model);
      372 	call ioa_ ("^10xTrain     =  ^d", ddevice.qualifiers (1));
      373 	if ddevice.qualifiers (2) = -1		/* -1 => no line length specified on PRPH card. */
      374 	then call ioa_ ("^10xLine Len  =  not specified");
      375 	else call ioa_ ("^10xLine Len  =  ^d", ddevice.qualifiers (2));
      376 	return;
      377 
      378 DTYPE (3): DTYPE (5): DTYPE (6): DTYPE (7): DTYPE (8):	/* CONSOLE, PUNCH, READER, SPECIAL, MCA */
      379 	call ioa_ ("^10xModel     =  ^d", ddevice.model);
      380 
      381      end LIST_DEVICE;
      382 
      383 LIST_RESERVATION: procedure (arg_rid, for, by);
      384 
      385 
      386 	dcl     arg_rid		 fixed bin (71);
      387 	dcl     by		 char (32) aligned; /* User who made the reservation. */
      388 	dcl     for		 char (32) aligned; /* User for whom the reservation was made. */
      389 	dcl     header_printed	 bit (1);		/* Bit to tell whether we have printed resource class. */
      390 	dcl     k			 fixed bin;
      391 	dcl     rid		 fixed bin (71);	/* Reservation to list. */
      392 	dcl     rid_string		 char (32);	/* String representation of reservation id. */
      393 
      394 
      395 	rid = arg_rid;				/* copy reservation id */
      396 
      397 
      398 	rid_string = date_time_$format ("request_id", rid + sys_info$time_correction_constant, "", "");
      399 	if long_flag then /* Print full reservation id. */
      400 	     call ioa_ ("Reservation ^a (claimed) for ^a^[ by ^a^]", rid_string, for, (by ^= for), by);
      401 	else call ioa_ ("Reservation ^a (claimed) for ^a^[ by ^a^]", substr (rid_string, 7, 6), for, (by ^= for), by);
      402 
      403 
      404 	header_printed = "0"b;
      405 	do k = 1 to rdi.head.tot_ddevices;		/* Look at all device entries. */
      406 	     ddevice_ptr = addr (rdi.ddevices (k));
      407 	     if ddevice.reservation_id = rid then do;	/* Got one. */
      408 		     if ^header_printed then do;	/* Print header. */
      409 			     call ioa_ ("^5xDevices");
      410 			     header_printed = "1"b;
      411 			end;
      412 		     call ioa_ ("^10x^a", ddevice.device_name);
      413 		     ddevice.reservation_id = 0;	/* Make sure we don't see this one again. */
      414 		end;
      415 	end;
      416 
      417 
      418 	header_printed = "0"b;
      419 	do k = 1 to rdi.head.tot_dvolumes;		/* Look at all vol entries. */
      420 	     dvolume_ptr = addr (rdi.dvolumes (k));
      421 	     if dvolume.reservation_id = rid then do;	/* Got one. */
      422 		     if ^header_printed then do;	/* Print header. */
      423 			     call ioa_ ("^5xVolumes");
      424 			     header_printed = "1"b;
      425 			end;
      426 		     call ioa_ ("^10x^a", dvolume.volume_name);
      427 		     dvolume.reservation_id = 0;	/* So we don't see this one again. */
      428 		end;
      429 	end;
      430 
      431 
      432 	return;
      433 
      434 
      435      end LIST_RESERVATION;
      436 
      437 PROCESS_ARG: procedure;
      438 
      439 /*	This procedure is called to process one command option argument.  If this option
      440*   *	argument is followed by a value argument then we process that argument also.
      441**/
      442 	call cu_$arg_ptr (argx, arg_ptr, arg_len, ecode);
      443 	if ecode ^= 0				/* Did we get a pointer to this argument? */
      444 	then do;					/* No. */
      445 		call com_err_ (ecode, "rcp_list", "Error getting argument ^d", argx);
      446 		return;
      447 	     end;
      448 	option = argument;				/* Save command option argument. */
      449 	do i = 1 to hbound (long_options, 1);		/* See if command option is valid. */
      450 	     if (option = brief_options (i)) | /* Is it this brief option name? */
      451 		(option = long_options (i))		/* Or this long option name? */
      452 	     then do;				/* Yes, one of them. */
      453 		     call GET_VALUE (i);		/* Get any accompanying value argument. */
      454 		     if ecode ^= 0			/* Check for errors. */
      455 		     then return;
      456 		     goto OPTION (i);		/* Go process this option. */
      457 		end;
      458 	end;
      459 	ecode = error_table_$badopt;			/* Option is not known. */
      460 	call com_err_ (ecode, "rcp_list", "Control argument: ^a", option);
      461 	return;
      462 
      463 OPTION (1):					/* "list" */
      464 	return;					/* Ignore. */
      465 
      466 OPTION (2):					/* "-lg" or "-long" */
      467 	long_flag = "1"b;				/* User wants long output format. */
      468 	return;
      469 
      470 OPTION (3):					/* "-tp" or "-type" */
      471 	list_index = 1;				/* 1 => list one device type. */
      472 	call resource_info_$get_dtypex (argument, device_type, dtypex, ecode);
      473 	if ecode ^= 0 then do;
      474 		call com_err_ (ecode, "rcp_list", "^a", argument);
      475 		return;
      476 	     end;
      477 
      478 	return;
      479 
      480 OPTION (4):					/* "-dv" or "-device" */
      481 	list_index = 2;				/* 2 => list one device. */
      482 	device_name = argument;			/* Get specified device name. */
      483 	return;
      484 
      485 OPTION (5):					/* "-mnt" or "-mounts" */
      486 	list_index = 3;				/* 3 => list mounts pending. */
      487 	return;
      488 
      489 OPTION (6):					/* "-unat" or "-unattached" */
      490 	list_index = 4;				/* 4 => list unattached, loaded volume names. */
      491 	return;
      492 
      493 OPTION (7):					/* "-reserved" or "-resv" */
      494 	list_index = 5;				/* 5 => list resreved resources. */
      495 	return;
      496 
      497      end PROCESS_ARG;
      498 
      499 GET_VALUE: procedure (option_num);
      500 
      501 /*	This procedure is called to get any value argument associated with this option.
      502*   *	Processing of the value argument depends upon the option code value associated
      503*   *	with this option.  The option code values are:
      504*   *	     0.	This option argument has no accompanying value argument.
      505*   *	     1.	This option argument has a string type value argument.
      506**/
      507 	dcl     option_num		 fixed bin;	/* Number that identifies this option. */
      508 
      509 	option_code = option_codes (option_num);	/* Get code value for this option. */
      510 
      511 	if option_code = 0				/* Is there an accompanying argument value? */
      512 	then return;				/* No, nothing else to do. */
      513 
      514 /* Get accompanying argument value. */
      515 	if argx = num_args				/* Is this the last argument? */
      516 	then do;					/* Yes, value argument missing. */
      517 		ecode = error_table_$odd_no_of_args;
      518 		call com_err_ (ecode, "rcp_list", "No value argument for ^a", option);
      519 		return;
      520 	     end;
      521 
      522 	argx = argx + 1;				/* Get the next argument. */
      523 	call cu_$arg_ptr (argx, arg_ptr, arg_len, ecode);
      524 	if ecode ^= 0
      525 	then do;
      526 		call com_err_ (ecode, "rcp_list", "Error getting argument ^d", argx);
      527 		return;
      528 	     end;
      529 
      530 	if index (argument, "-") = 1			/* Is next argument a control option? */
      531 	then do;					/* Yes, value argument is missing. */
      532 		ecode = error_table_$wrong_no_of_args;
      533 		call com_err_ (ecode, "rcp_list", "No value argument for ^a", option);
      534 		return;
      535 	     end;
      536 
      537      end GET_VALUE;
      538 
      539      end rcp_list;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/25/86  1206.4  rcp_list.pl1                      >special_ldd>install>MR12.0-1033>rcp_list.pl1
122          1    11/21/79  1510.7  rcp_data_info.incl.pl1            >ldd>include>rcp_data_info.incl.pl1
124          2    08/24/81  0955.0  console_device_specs.incl.pl1     >ldd>include>console_device_specs.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 103 ref 174 181 194 197 211 227 247 265 273 302
                                                                                  349 356 406 420
arg_len                         000100 automatic       fixed bin(17,0)          dcl 44 set ref 442* 448 472 472 474 474 482 523* 530
arg_ptr                         000102 automatic       pointer                  dcl 45 set ref 442* 448 472 474 482 523* 530
arg_rid                                parameter       fixed bin(71,0)          dcl 386 ref 383 395
argument                               based           char                     unaligned dcl 70 set ref 448 472* 474* 482 530
argx                            000104 automatic       fixed bin(17,0)          dcl 46 set ref 135* 442* 445* 515 522* 522 523* 526*
attached                 30(04)        based           bit(1)                   level 3 packed unaligned dcl 1-39 ref 248
based_density                          based           bit(5)                   dcl 72 ref 352
based_speed                            based           bit(3)                   dcl 74 ref 359
brief_options                   000106 constant        char(5)                  initial array unaligned dcl 82 ref 450
by                                     parameter       char(32)                 dcl 387 set ref 383 399 399* 401 401*
chan_num                 26            based           fixed bin(17,0)          level 2 dcl 1-39 set ref 341*
com_err_                        000050 constant        entry                    external dcl 112 ref 146 164 189 203 445 460 474 518
                                                                                  526 533
cu_$arg_count                   000052 constant        entry                    external dcl 113 ref 133
cu_$arg_ptr                     000054 constant        entry                    external dcl 114 ref 442 523
date_time_                      000056 constant        entry                    external dcl 115 ref 316
date_time_$format               000060 constant        entry                    external dcl 116 ref 398
ddevice                                based           structure                level 1 dcl 1-39
ddevice_ptr                     000214 automatic       pointer                  dcl 1-11 set ref 194* 195 197 211* 212 227* 228 231
                                                                                  231 233 233 233 233 233 233 233 233 247* 248 248
                                                                                  252 252 252 265* 266 267 267 267 302* 313 315 316
                                                                                  319 319 322 323 335 337 340 341 343 345 347 348
                                                                                  349 356 365 367 370 372 373 375 378 406* 407 412
                                                                                  413
ddevices                               based           structure                array level 2 dcl 1-16 set ref 194 211 227 247 265
                                                                                  302 406
ddtype                                 based           structure                level 1 dcl 1-32
ddtype_ptr                      000212 automatic       pointer                  dcl 1-10 set ref 174* 181* 182 197* 289 289 294 295
                                                                                  296 297 301 301 301 313
ddtypes                   4            based           structure                array level 2 dcl 1-16 set ref 174 181 197
density_comment                 000105 automatic       varying char(30)         dcl 47 set ref 350* 352* 352 355*
density_names                   000033 constant        varying char(5)          initial array dcl 94 ref 351 352
density_ptr                     000116 automatic       pointer                  dcl 48 set ref 349* 352
device_name                     000120 automatic       char(32)                 unaligned dcl 49 in procedure "rcp_list" set ref 195
                                                                                  203* 482*
device_name                            based           char(8)                  level 2 in structure "ddevice" dcl 1-39 in procedure
                                                                                  "rcp_list" set ref 195 231* 233* 252* 313* 412*
device_states                   000012 internal static char(15)                 initial array unaligned dcl 91 set ref 315*
device_type                     000130 automatic       char(32)                 unaligned dcl 50 in procedure "rcp_list" set ref 182
                                                                                  189* 472*
device_type                            based           char(32)                 level 2 in structure "ddtype" dcl 1-32 in procedure
                                                                                  "rcp_list" set ref 182 289* 294* 313*
dtypex                          000140 automatic       fixed bin(17,0)          dcl 51 in procedure "rcp_list" set ref 173* 174*
                                                                                  179* 181* 472*
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "ddevice" dcl 1-39 in procedure
                                                                                  "rcp_list" set ref 197 233 233 233* 343
dvolume                                based           structure                level 1 dcl 1-62
dvolume_ptr                     000216 automatic       pointer                  dcl 1-12 set ref 273* 274 275 275 275 420* 421 426
                                                                                  427
dvolumes                               based           structure                array level 2 dcl 1-16 set ref 273 420
ecode                           000141 automatic       fixed bin(35,0)          dcl 52 set ref 128* 137 143* 146* 161* 162 164* 188*
                                                                                  189* 202* 203* 442* 443 445* 454 459* 460* 472*
                                                                                  473 474* 517* 518* 523* 524 526* 532* 533*
error_table_$badopt             000036 external static fixed bin(35,0)          dcl 105 ref 459
error_table_$name_not_found     000040 external static fixed bin(35,0)          dcl 105 ref 188 202
error_table_$odd_no_of_args     000042 external static fixed bin(35,0)          dcl 105 ref 517
error_table_$wrong_no_of_args   000044 external static fixed bin(35,0)          dcl 105 ref 532
first_devicex            13            based           fixed bin(17,0)          level 2 dcl 1-32 ref 301 301
flags                    30            based           structure                level 2 dcl 1-39
for                                    parameter       char(32)                 dcl 388 set ref 383 399* 399 401* 401
group_id                 31            based           char(32)                 level 2 in structure "ddevice" dcl 1-39 in procedure
                                                                                  "rcp_list" set ref 233* 252* 267* 319*
group_id                 12            based           char(32)                 level 2 in structure "dvolume" dcl 1-62 in procedure
                                                                                  "rcp_list" set ref 275*
hbound                                                 builtin function         dcl 103 ref 351 358 449
hcs_$make_seg                   000062 constant        entry                    external dcl 117 ref 143
head                                   based           structure                level 2 dcl 1-16
header_printed                  000256 automatic       bit(1)                   unaligned dcl 389 set ref 404* 408 410* 418* 422
                                                                                  424*
i                               000142 automatic       fixed bin(17,0)          dcl 53 set ref 192* 194* 210* 211* 226* 227* 246*
                                                                                  247* 264* 265* 272* 273* 301* 302* 449* 450 450
                                                                                  453* 456*
index                                                  builtin function         dcl 103 ref 530
ioa_                            000064 constant        entry                    external dcl 118 ref 169 171 217 220 222 231 233 239
                                                                                  250 252 257 280 289 294 295 296 297 313 315 317
                                                                                  319 327 329 335 337 340 341 345 347 348 355 362
                                                                                  365 367 370 372 373 375 378 399 401 409 412 423
                                                                                  426
iom_num                  25            based           fixed bin(17,0)          level 2 dcl 1-39 set ref 340*
j                               000143 automatic       fixed bin(17,0)          dcl 53 set ref 351* 352 352* 358* 359 359*
k                               000257 automatic       fixed bin(17,0)          dcl 390 set ref 405* 406* 419* 420*
list_index                      000144 automatic       fixed bin(17,0)          dcl 54 set ref 128* 167 470* 480* 485* 489* 493*
loaded                   30(05)        based           bit(1)                   level 3 packed unaligned dcl 1-39 ref 248
long_flag                       000145 automatic       bit(1)                   unaligned dcl 55 set ref 130* 171 206 231 289 332
                                                                                  399 466*
long_options                    000061 constant        char(12)                 initial array unaligned dcl 85 ref 449 450
max_concurrent           10            based           fixed bin(17,0)          level 2 dcl 1-32 set ref 296*
max_copy_size                   000146 automatic       fixed bin(19,0)          dcl 56 set ref 131* 161*
model                    13            based           fixed bin(17,0)          level 2 dcl 1-39 set ref 345* 365* 370* 378*
mounting                 30(02)        based           bit(1)                   level 3 packed unaligned dcl 1-39 ref 212 228 323
null                                                   builtin function         dcl 103 ref 141 144
num_args                        000147 automatic       fixed bin(17,0)          dcl 57 set ref 133* 135 515
num_channels             27            based           fixed bin(17,0)          level 2 dcl 1-39 set ref 347* 367*
num_devices              12            based           fixed bin(17,0)          level 2 dcl 1-32 set ref 289 295* 301
num_mounts                      000150 automatic       fixed bin(17,0)          dcl 58 set ref 209* 212* 212 215 220 222* 225* 230*
                                                                                  230 239
num_reserved             11            based           fixed bin(17,0)          level 2 in structure "ddtype" dcl 1-32 in procedure
                                                                                  "rcp_list" set ref 297*
num_reserved                    000151 automatic       fixed bin(17,0)          dcl 59 in procedure "rcp_list" set ref 261* 268* 268
                                                                                  276* 276 280
num_unattached                  000152 automatic       fixed bin(17,0)          dcl 60 set ref 243* 250 253* 253 257
option                          000153 automatic       char(12)                 unaligned dcl 61 set ref 448* 450 450 460* 518* 533*
option_code                     000156 automatic       fixed bin(17,0)          dcl 62 set ref 509* 511
option_codes                    000052 constant        fixed bin(17,0)          initial array dcl 88 ref 509
option_num                             parameter       fixed bin(17,0)          dcl 507 ref 499 509
qualifiers               15            based           fixed bin(35,0)          array level 2 dcl 1-39 set ref 348* 349 356 372* 373
                                                                                  375*
rcp_sys_$copy_data              000066 constant        entry                    external dcl 119 ref 161
rdi                                    based           structure                level 1 dcl 1-16
rdi_header                             based           structure                level 1 dcl 1-26
rdi_ptr                         000210 automatic       pointer                  dcl 1-9 set ref 158* 159 161* 171 173 174 179 181
                                                                                  192 194 197 210 211 226 227 246 247 264 265 272
                                                                                  273 302 405 406 419 420
rdi_version_3                          constant        fixed bin(17,0)          initial dcl 1-14 ref 159
reservable               30            based           bit(1)                   level 3 packed unaligned dcl 1-39 ref 335
reservation_id           42            based           fixed bin(71,0)          level 2 in structure "ddevice" dcl 1-39 in procedure
                                                                                  "rcp_list" set ref 266 267* 407 413*
reservation_id           32            based           fixed bin(71,0)          level 2 in structure "dvolume" dcl 1-62 in procedure
                                                                                  "rcp_list" set ref 274 275* 421 427*
reserved                 30(01)        based           bit(1)                   level 3 packed unaligned dcl 1-39 ref 337
reserved_by              44            based           char(32)                 level 2 in structure "ddevice" dcl 1-39 in procedure
                                                                                  "rcp_list" set ref 267*
reserved_by              22            based           char(32)                 level 2 in structure "dvolume" dcl 1-62 in procedure
                                                                                  "rcp_list" set ref 275*
resource_info_$get_dtypex       000070 constant        entry                    external dcl 120 ref 472
rid                             000260 automatic       fixed bin(71,0)          dcl 391 set ref 395* 398 407 421
rid_string                      000262 automatic       char(32)                 unaligned dcl 392 set ref 398* 399* 401 401
speed_comment                   000157 automatic       varying char(30)         dcl 63 set ref 357* 359* 359 362*
speed_names                     000025 constant        varying char(4)          initial array dcl 97 ref 358 359
speed_ptr                       000170 automatic       pointer                  dcl 64 set ref 356* 359
state                    24            based           fixed bin(17,0)          level 2 dcl 1-39 ref 315 319
state_time               22            based           fixed bin(71,0)          level 2 dcl 1-39 set ref 316*
substr                                                 builtin function         dcl 103 ref 352 359 401 401
sys_info$time_correction_constant
                                000046 external static fixed bin(71,0)          dcl 110 ref 398
temp_seg_ptr                    000010 internal static pointer                  initial dcl 79 set ref 141 143* 144 158
time_string                     000172 automatic       char(24)                 unaligned dcl 65 set ref 316* 317*
tot_ddevices              2            based           fixed bin(17,0)          level 3 dcl 1-16 set ref 171* 192 210 226 246 264
                                                                                  273 405 420
tot_ddtypes               1            based           fixed bin(17,0)          level 3 dcl 1-16 ref 173 179 194 211 227 247 265 273
                                                                                  302 406 420
tot_dvolumes              3            based           fixed bin(17,0)          level 3 dcl 1-16 ref 272 419
version_num                            based           fixed bin(17,0)          level 3 dcl 1-16 set ref 159*
volume_name                     000200 automatic       char(32)                 unaligned dcl 66 in procedure "rcp_list" set ref
                                                                                  322* 325 325* 327* 329 329*
volume_name               2            based           char(32)                 level 2 in structure "ddevice" dcl 1-39 in procedure
                                                                                  "rcp_list" set ref 231* 233* 252* 322
volume_name               1            based           char(32)                 level 2 in structure "dvolume" dcl 1-62 in procedure
                                                                                  "rcp_list" set ref 426*
writing                  30(03)        based           bit(1)                   level 3 packed unaligned dcl 1-39 ref 233 233

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONSOLE_GCOS_TYPE                      internal static bit(6)                   initial array unaligned dcl 2-64
CONSOLE_IS_BCD                         internal static bit(1)                   initial array unaligned dcl 2-39
CONSOLE_MODEL_INDEX                    internal static fixed bin(17,0)          initial array dcl 2-27
CONSOLE_MODEL_NUMBER                   internal static fixed bin(17,0)          initial array dcl 2-12
CONSOLE_PROMPT_BY_DEFAULT              internal static bit(1)                   initial array unaligned dcl 2-52

NAMES DECLARED BY EXPLICIT CONTEXT.
DTYPE                           000006 constant        label                    array(8) dcl 345 set ref 343
GET_VALUE                       004074 constant        entry                    internal dcl 499 ref 453
LIST_DEVICE                     002224 constant        entry                    internal dcl 308 ref 198 303
LIST_DTYPE                      002033 constant        entry                    internal dcl 284 ref 175 184
LIST_RESERVATION                003217 constant        entry                    internal dcl 383 ref 267 275
OPTION                          000016 constant        label                    array(7) dcl 463 ref 456
PROCESS_ARG                     003606 constant        entry                    internal dcl 437 ref 136
RCPD                            000000 constant        label                    array(0:5) dcl 169 ref 167
rcp_list                        000573 constant        entry                    external dcl 17

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4502        4574    4304        4512
Length      5066    4304        72         255     175          26

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_list                            500 external procedure  is an external procedure.  
LIST_DTYPE                              internal procedure  shares stack frame of external procedure rcp_list.  
LIST_DEVICE                             internal procedure  shares stack frame of external procedure rcp_list.  
LIST_RESERVATION                        internal procedure  shares stack frame of external procedure rcp_list.  
PROCESS_ARG                             internal procedure  shares stack frame of external procedure rcp_list.  
GET_VALUE                               internal procedure  shares stack frame of external procedure rcp_list.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 temp_seg_ptr                rcp_list
000012 device_states               rcp_list

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_list                 000100 arg_len                     rcp_list
                         000102 arg_ptr                     rcp_list
                         000104 argx                        rcp_list
                         000105 density_comment             rcp_list
                         000116 density_ptr                 rcp_list
                         000120 device_name                 rcp_list
                         000130 device_type                 rcp_list
                         000140 dtypex                      rcp_list
                         000141 ecode                       rcp_list
                         000142 i                           rcp_list
                         000143 j                           rcp_list
                         000144 list_index                  rcp_list
                         000145 long_flag                   rcp_list
                         000146 max_copy_size               rcp_list
                         000147 num_args                    rcp_list
                         000150 num_mounts                  rcp_list
                         000151 num_reserved                rcp_list
                         000152 num_unattached              rcp_list
                         000153 option                      rcp_list
                         000156 option_code                 rcp_list
                         000157 speed_comment               rcp_list
                         000170 speed_ptr                   rcp_list
                         000172 time_string                 rcp_list
                         000200 volume_name                 rcp_list
                         000210 rdi_ptr                     rcp_list
                         000212 ddtype_ptr                  rcp_list
                         000214 ddevice_ptr                 rcp_list
                         000216 dvolume_ptr                 rcp_list
                         000256 header_printed              LIST_RESERVATION
                         000257 k                           LIST_RESERVATION
                         000260 rid                         LIST_RESERVATION
                         000262 rid_string                  LIST_RESERVATION

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   date_time_
date_time_$format             hcs_$make_seg                 ioa_                          rcp_sys_$copy_data
resource_info_$get_dtypex

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$name_not_found   error_table_$odd_no_of_args   error_table_$wrong_no_of_args
sys_info$time_correction_constant




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000572       128 000600       130 000602       131 000603       133 000605       135 000613       136 000623
    137 000624       139 000626       141 000630       143 000635       144 000676       146 000703       147 000730
    158 000731       159 000733       161 000735       162 000747       164 000751       165 000777       167 001000
    169 001002       171 001016       173 001041       174 001051       175 001055       176 001056       177 001060
    179 001061       181 001071       182 001075       184 001101       185 001102       187 001103       188 001105
    189 001110       190 001144       192 001145       194 001155       195 001170       197 001174       198 001200
    199 001201       201 001202       202 001204       203 001207       204 001243       206 001244       209 001246
    210 001247       211 001257       212 001272       214 001276       215 001300       217 001302       218 001321
    220 001322       222 001344       225 001364       226 001365       227 001375       228 001410       230 001413
    231 001414       233 001441       238 001521       239 001523       241 001544       243 001545       246 001546
    247 001557       248 001572       250 001600       252 001621       253 001653       255 001654       257 001656
    259 001674       261 001675       264 001676       265 001707       266 001722       267 001724       268 001736
    270 001737       272 001741       273 001751       274 001772       275 001774       276 002006       278 002007
    280 002011       282 002032       284 002033       289 002034       292 002064       294 002065       295 002110
    296 002131       297 002152       301 002173       302 002205       303 002220       304 002221       306 002223
    308 002224       313 002225       315 002254       316 002300       317 002316       319 002341       322 002365
    323 002371       325 002374       327 002403       328 002423       329 002424       332 002453       335 002456
    337 002476       340 002516       341 002537       343 002563       345 002566       347 002611       348 002632
    349 002656       350 002661       351 002662       352 002667       354 002711       355 002713       356 002733
    357 002736       358 002737       359 002745       361 002767       362 002771       363 003014       365 003015
    367 003040       368 003061       370 003062       372 003105       373 003126       375 003147       376 003172
    378 003173       381 003216       383 003217       395 003221       398 003223       399 003266       401 003334
    404 003403       405 003404       406 003415       407 003430       408 003433       409 003435       410 003453
    412 003455       413 003474       415 003477       418 003501       419 003502       420 003513       421 003534
    422 003537       423 003541       424 003556       426 003560       427 003600       429 003603       432 003605
    437 003606       442 003607       443 003624       445 003626       446 003660       448 003661       449 003666
    450 003673       453 003707       454 003711       456 003714       458 003716       459 003720       460 003723
    461 003754       463 003755       466 003756       468 003760       470 003761       472 003763       473 004013
    474 004015       475 004051       478 004052       480 004053       482 004055       483 004062       485 004063
    487 004065       489 004066       491 004070       493 004071       495 004073       499 004074       509 004076
    511 004101       515 004103       517 004106       518 004111       519 004145       522 004146       523 004147
    524 004164       526 004166       527 004220       530 004221       532 004235       533 004240       534 004274
    537 004275


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
