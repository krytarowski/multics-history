	COMPILATION LISTING OF SEGMENT lib_node_path_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0859.2 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 
       12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       13 	/*									*/
       14 	/* N__a_m_e:  lib_node_path_							*/
       15 	/*									*/
       16 	/*      This procedure returns the path name of the entry represented by a library node.	*/
       17 	/*									*/
       18 	/* U__s_a_g_e									*/
       19 	/*									*/
       20 	/*      dcl  lib_node_path_ entry (ptr, char(168) varying, char(32) varying);		*/
       21 	/*									*/
       22 	/*      call lib_node_path_ (Pnode, directory, entry);				*/
       23 	/*									*/
       24 	/* 1) Pnode	is a pointer to the library node representing the entry whose path	*/
       25 	/*		name is to be returned. (In)					*/
       26 	/* 2) directory	is the directory portion of the path name. (Out)			*/
       27 	/* 3) entry	is the entry portion of the path name. (Out)			*/
       28 	/*									*/
       29 	/*									*/
       30 	/* E__n_t_r_y:  lib_node_path_$absolute						*/
       31 	/*									*/
       32 	/* This entry points returns an absolute pathname, include archive component names.	*/
       33 	/*									*/
       34 	/* U__s_a_g_e:									*/
       35 	/*									*/
       36 	/*      dcl lib_node_path_$absolute (ptr, char(200) varying);			*/
       37 	/*      call lib_node_path_$absolute (Pnode, pathname);				*/
       38 	/*									*/
       39 	/* where:									*/
       40 	/* 1) Pnode	is as above. (In)						*/
       41 	/* 2) pathname	is the absolute pathname. (Out)				*/
       42 	/*									*/
       43 	/* S__t_a_t_u_s									*/
       44 	/*									*/
       45 	/* 0) Created:  Aug, 1973 by G. C. Dixon					*/
       46 	/* 1) Modified: Dec, 1980 by G. C. Dixon - add $absolute entry point.			*/
       47 	/*									*/
       48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       49 
       50 
       51 
       52 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       53 
       54 
       55 lib_node_path_:	procedure (APnode, dir, ent);
       56 
       57      dcl	APnode			ptr,		/* ptr to node whose path is to be obtained. (In)	*/
       58 	dir			char(168) varying,	/* directory part of path. (Out)		*/
       59 	ent			char(32) varying;	/* entry part of path. (Out)			*/
       60 
       61      dcl	i			fixed bin,	/* a do-group index.			*/
       62 	path			char(200) varying;	/* path name of the node.			*/
       63 
       64      dcl (addr, index, length, null, reverse, rtrim, substr)
       65 				builtin;
       66 
       67 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       68 
       69 
       70 	path = recurse (APnode);			/* get path name of the node.			*/
       71 	
       72 	i = index (path, "::");			/* Look for archive component name in path.	*/
       73 	if i > 0 then do;				/* If one found, treat it as the entryname.	*/
       74 	     dir = substr(path, 1, i-1);
       75 	     ent = substr (path, i+2);
       76 	     end;
       77 	else do;
       78 	     i = length(path) + 1 - index (reverse (path), ">");
       79 	     if i = 1 then				/* special case the root.			*/
       80 		dir = ">";
       81 	     else dir = substr (path, 1, i-1);
       82 	     ent = substr (path, i+1);
       83 	     end;
       84 	return;
       85 
       86 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       87 
       88 
       89 absolute: entry (APnode) returns (char(200) varying);
       90 
       91 	return (recurse (APnode));
       92 
       93 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       94 
       95 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       96 
       97 
       98 recurse:	procedure (APnode)				/* This internal procedure constructs the path	*/
       99 	returns	(char(200) varying);		/* name of the node.			*/
      100 
      101      dcl	APnode			ptr;		/* ptr to the node whose path name is desired.	*/
      102 
      103 	Pnode = APnode;				/* address the node in question.		*/
      104 	if node.Pparent = null then			/* is this a root node of the tree?		*/
      105 	     go to root_node;			/* if so, then return path name assoc with it.	*/
      106 	else if addr (node.Pparent -> node.Svalid) -> Svalid.link_target then do;
      107 						/* else, does node's parent have a path name	*/
      108 	     Pnode = node.Pparent;			/* assoc with it?  Return that path name.	*/
      109 root_node:     return (link_node.link_target);
      110 	     end;
      111 	else do;					/* otherwise, concatenate parent node's path	*/
      112 						/* with primary name of this node.		*/
      113 	     do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      114 		end;				/* address the node's name descriptor.		*/
      115 	     if node.T = Tarchive_comp then
      116 		return (recurse (node.Pparent) || "::" || rtrim (Dnames.names(1)));
      117 	     else return (recurse (node.Pparent) || ">" || rtrim (Dnames.names(1)));
      118 
      119 	     end;
      120 
      121 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      122 
  1     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  1     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  1     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  1    10 	/* called the node target.							*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  1    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  1    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  1    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  1    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  1    19 	/*									*/
  1    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    21 
  1    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    23 	/*									*/
  1    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  1    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  1    26 	/* both types of nodes are the same length.					*/
  1    27 	/*									*/
  1    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    29 
  1    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  1    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    35 						/*             (= node.Svalid & Srequirements)	*/
  1    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    37 	  2 switches		unaligned,
  1    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    40 						/* 	     entry before lib_access_mode_$set.	*/
  1    41 	    3 pad			bit(22),
  1    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    49 						/*	     in this directory;  if off, records*/
  1    50 						/*	     charged against 1st superior	*/
  1    51 						/*	     directory with switch on.	*/
  1    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    58 
  1    59 						/* From here on, link_nodes differ from nodes	*/
  1    60 						/*  for other types of node targets.		*/
  1    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  1    62 
  1    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    64 	/*									*/
  1    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  1    66 	/*									*/
  1    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    68 
  1    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  1    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    74 						/*             (= node.Svalid & Srequirements)	*/
  1    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    76 	  2 switches		unaligned,
  1    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    79 						/* 	     entry before lib_access_mode_$set.	*/
  1    80 	    3 pad			bit(22),
  1    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    88 						/*	     in this directory;  if off, records*/
  1    89 						/*	     charged against 1st superior	*/
  1    90 						/*	     directory with switch on.	*/
  1    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    97 
  1    98 						/* From here on, other nodes differ from	*/
  1    99 						/*  link_nodes.				*/
  1   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  1   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  1   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  1   103 	  2 pad1 (1)		fixed bin,
  1   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  1   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  1   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  1   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  1   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  1   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  1   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  1   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  1   112 						/*             component from the base of archive.*/
  1   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  1   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  1   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   119 						/*	     updated.			*/
  1   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   121 						/*	     directories with Sterminal_account	*/
  1   122 						/*	     on.				*/
  1   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  1   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   128 						/*	     updated.			*/
  1   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   130 						/*	     directories with Sterminal_account	*/
  1   131 						/*	     on.				*/
  1   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  1   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  1   134 	  2 pad2 (5)		fixed bin,
  1   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  1   136 
  1   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   138 	/*									*/
  1   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  1   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  1   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  1   142 	/* descriptors are the only ones that have been defined.				*/
  1   143 	/*									*/
  1   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   145 
  1   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  1   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  1   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  1   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  1   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  1   152 
  1   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  1   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  1   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  1   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   163 	    3 zero_pad		bit(36),
  1   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  1   167 	Vacl_1			fixed bin int static options(constant) init (1),
  1   168 						/* version:   version of ACL descriptor.	*/
  1   169 	Tacl			fixed bin int static options(constant) init (7);
  1   170 						/* attribute: type of a segment ACL descriptor.	*/
  1   171 
  1   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  1   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  1   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  1   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  1   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  1   186 						/* version:   version of directory ACL descriptor.*/
  1   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  1   188 						/* attribute: type of a directory ACL descriptor.	*/
  1   189 
  1   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  1   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  1   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  1   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  1   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  1   206 						/* version:   version of dir IACL descriptor.	*/
  1   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  1   208 
  1   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  1   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  1   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  1   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   221 	    3 zero_pad		bit(36),
  1   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  1   225 	Viacl_1			fixed bin int static options(constant) init (1),
  1   226 						/* version:   version of segment IACL descriptor.	*/
  1   227 	Tiacl			fixed bin int static options(constant) init (10);
  1   228 						/* attribute: type of a segment IACL descriptor.	*/
  1   229 
  1   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  1   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  1   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  1   236 	  2 names (Nnames refer (Dnames.N))
  1   237 				char(32),		/* attribute: names.			*/
  1   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  1   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  1   240 	Vnames_1			fixed bin int static options(constant) init (1),
  1   241 						/* version:   version of names descriptor.	*/
  1   242 	Tnames			fixed bin int static options(constant) init (1);
  1   243 						/* attribute: type of a name descriptor.	*/
  1   244 
  1   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  1   246 						/* nodes.					*/
  1   247 	  2 header,
  1   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  1   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  1   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  1   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  1   255 				like node,
  1   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  1   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  1   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  1   259 						/* version:   version of nodes descriptor.	*/
  1   260 	Tnodes			fixed bin int static options(constant) init (2);
  1   261 						/* attribute: type of a node descriptor.	*/
  1   262 
  1   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  1   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  1   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   268 	  2 info,
  1   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  1   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  1   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  1   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  1   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  1   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  1   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  1   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  1   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  1   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  1   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  1   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  1   281 	    3 format		aligned,
  1   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  1   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  1   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  1   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  1   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  1   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  1   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  1   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  1   290 	      4 pad		bit(28) unal,
  1   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  1   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  1   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  1   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  1   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  1   296 	    3 cversion,				/* attribite: compiler version string.		*/
  1   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  1   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  1   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  1   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  1   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  1   306 	Vobj_1			fixed bin int static options(constant) init (1),
  1   307 						/* version:   version of object_info_ descriptor.	*/
  1   308 	Tobj			fixed bin int static options(constant) init (3);
  1   309 						/* attribute: type of a node descriptor.	*/
  1   310 
  1   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  1   312 						/* library root search_proc attribute descriptor.	*/
  1   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  1   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  1   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  1   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  1   320 						/* version:   version of search_proc info descrip.*/
  1   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  1   322 						/* attribute: type of a search_proc descriptor.	*/
  1   323 
  1   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  1   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  1   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  1   330 						/*            output.			*/
  1   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  1   332 	  2 info			char(Luser refer (Duser.L)),
  1   333 						/* attribute: user info string.		*/
  1   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  1   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  1   336 	Vuser_1			fixed bin int static options(constant) init (1),
  1   337 						/* version:   version of user info descriptor.	*/
  1   338 	Tuser			fixed bin int static options(constant) init (6);
  1   339 						/* attribute: type of a user descriptor.	*/
  1   340 
  2     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the switches which request/validate the fields	*/
  2     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  2     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  2    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  2    11 	/* descriptor commands to obtain information about entries in a library.		*/
  2    12 	/*									*/
  2    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  2    14 	/* is requested for output.							*/
  2    15 	/*									*/
  2    16 	/* S__t_a_t_u_s									*/
  2    17 	/*									*/
  2    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  2    19 	/*									*/
  2    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 
  2    22 
  2    23      dcl	1 Svalid_req		aligned based,
  2    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  2    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  2    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  2    27 
  2    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  2    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  2    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  2    31 
  2    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  2    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  2    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  2    35 
  2    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  2    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  2    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  2    39 
  2    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  2    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  2    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  2    43 
  2    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  2    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  2    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  2    47 
  2    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  2    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  2    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  2    51 
  2    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  2    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  2    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  2    55 
  2    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  2    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  2    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  2    59 
  2    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  2    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  2    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  2    63 
  2    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  2    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  2    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  2    67 
  2    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  2    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  2    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  2    71 
  2    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  2    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  2    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  2    75 
  2    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  2    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  2    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  2    79 	  2 pad			bit(26) unal,
  2    80 
  2    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  2    82 
  2    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  2    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  2    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  2    86 
  2    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    88 	/*									*/
  2    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  2    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  2    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  2    92 	/*									*/
  2    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    94 
  2    95 
  2    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  2    97 	Srequirements		bit(72) aligned;
  2    98 
  2    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   341 
  1   342 
  1   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  1   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  1   345 
  3     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the control switches used by library descriptor	*/
  3     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  3     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  3    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  3    11 	/* to the lib_descriptor_ subroutine.						*/
  3    12 	/*									*/
  3    13 	/* S__t_a_t_u_s									*/
  3    14 	/*									*/
  3    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  3    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  3    17 	/*									*/
  3    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    19 
  3    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  3    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  3    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  3    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  3    24 
  3    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  3    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  3    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    28 						/*         nodes of the tree, and about all the	*/
  3    29 						/*	 nodes below the parent.		*/
  3    30 
  3    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    32 						/*         nodes of the tree.			*/
  3    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  3    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  3    35 
  3    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  3    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  3    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  3    39 						/*         deletion.			*/
  3    40 
  3    41 	  2 pad			bit(10) unal,
  3    42 
  3    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  3    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  3    45 
  3    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  3    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  3    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  3    49 
  3    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  3    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  3    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  3    53 
  3    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  3    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  3    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  3    57 
  3    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  3    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  3    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  3    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  3    62 
  3    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   346 
  1   347 
  1   348 
  1   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   350 	/*									*/
  1   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  1   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  1   353 	/* that:		mod (type, 2) = 1;						*/
  1   354 	/*									*/
  1   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   356 
  1   357 
  1   358      dcl (Tlink			init (0),
  1   359 	Tsegment			init (1),
  1   360 	Tdirectory		init (2),
  1   361 	Tmsf			init (3),
  1   362 	Tmsf_comp			init (4),
  1   363 	Tarchive			init (5),
  1   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  1   365 
  1   366 
  1   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   368 	/*									*/
  1   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  1   370 	/* Both brief and long string arrays are provided.				*/
  1   371 	/*									*/
  1   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   373 
  1   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  1   375 				"link",
  1   376 				"segment",
  1   377 				"directory",
  1   378 				"multisegment file",
  1   379 				"multi-segment file component",
  1   380 				"archive",
  1   381 				"archive component"),
  1   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  1   383 				"link",
  1   384 				"segment",
  1   385 				"directory",
  1   386 				"msf",
  1   387 				"msf comp",
  1   388 				"archive",
  1   389 				"arch comp");
  1   390 
  1   391 
  1   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      123 
      124 
      125 	end recurse;
      126 
      127 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      128 
      129 	end lib_node_path_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0819.1  lib_node_path_.pl1                >special_ldd>on>6588>lib_node_path_.pl1
123          1    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
1-341        2    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
1-346        3    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APnode                                 parameter       pointer                  dcl 57 in procedure "lib_node_path_" set ref 55 70*
                                                                                  89 91*
APnode                                 parameter       pointer                  dcl 101 in procedure "recurse" ref 98 103
Dnames                                 based           structure                level 1 unaligned dcl 1-230
PD                        2            based           pointer                  level 2 dcl 1-69 ref 113
PDnames                         000102 automatic       pointer                  dcl 1-230 set ref 113* 113* 114 115 117
Pnext                     2            based           pointer                  level 2 dcl 1-230 ref 114
Pnode                           000100 automatic       pointer                  dcl 1-69 set ref 103* 104 106 108* 108 109 113 115
                                                                                  115 117
Pparent                                based           pointer                  level 2 dcl 1-69 set ref 104 106 108 115* 117*
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 1-69 in procedure
                                                                                  "recurse" set ref 106
Svalid                                 based           structure                level 1 dcl 1-343 in procedure "recurse"
Svalid_req                             based           structure                level 1 dcl 2-23
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 1-230 in procedure
                                                                                  "recurse" ref 113
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 1-69 in procedure
                                                                                  "recurse" ref 115
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 1-358 ref 115
Tnames                                 constant        fixed bin(17,0)          initial dcl 1-230 ref 113
addr                                                   builtin function         dcl 64 ref 106
dir                                    parameter       varying char(168)        dcl 57 set ref 55 74* 79* 81*
ent                                    parameter       varying char(32)         dcl 57 set ref 55 75* 82*
i                               000100 automatic       fixed bin(17,0)          dcl 61 set ref 72* 73 74 75 78* 79 81 82
index                                                  builtin function         dcl 64 ref 72 78
length                                                 builtin function         dcl 64 ref 78
link_node                              based           structure                level 1 unaligned dcl 1-30
link_target               0(15)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 1-343 in procedure "recurse" ref 106
link_target              27            based           varying char(168)        level 2 in structure "link_node" dcl 1-30
                                                                                  in procedure "recurse" ref 109
names                     5            based           char(32)                 array level 2 packed unaligned dcl 1-230 ref 115 117
node                                   based           structure                level 1 unaligned dcl 1-69
null                                                   builtin function         dcl 64 ref 104
path                            000101 automatic       varying char(200)        dcl 61 set ref 70* 72 74 75 78 78 81 82
reverse                                                builtin function         dcl 64 ref 78
rtrim                                                  builtin function         dcl 64 ref 115 117
substr                                                 builtin function         dcl 64 ref 74 75 81 82

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 1-146
Dacl                                   based           structure                level 1 unaligned dcl 1-153
Ddir_acl                               based           structure                level 1 unaligned dcl 1-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 1-190
Diacl                                  based           structure                level 1 unaligned dcl 1-209
Dnodes                                 based           structure                level 1 unaligned dcl 1-245
Dobj                                   based           structure                level 1 unaligned dcl 1-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 1-311
Duser                                  based           structure                level 1 unaligned dcl 1-324
Luser                                  automatic       fixed bin(17,0)          dcl 1-324
Nacls                                  automatic       fixed bin(17,0)          dcl 1-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 1-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 1-190
Niacls                                 automatic       fixed bin(17,0)          dcl 1-209
Nnames                                 automatic       fixed bin(17,0)          dcl 1-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 1-245
PD                                     automatic       pointer                  dcl 1-146
PDacl                                  automatic       pointer                  dcl 1-153
PDdir_acl                              automatic       pointer                  dcl 1-172
PDdir_iacl                             automatic       pointer                  dcl 1-190
PDiacl                                 automatic       pointer                  dcl 1-209
PDnodes                                automatic       pointer                  dcl 1-245
PDobj                                  automatic       pointer                  dcl 1-263
PDsearch_proc                          automatic       pointer                  dcl 1-311
PDuser                                 automatic       pointer                  dcl 1-324
S                                      based           structure                level 1 dcl 2-96
Sc                                     based           structure                level 1 dcl 3-20
Scontrol                               automatic       bit(36)                  dcl 3-20
Sreq                                   based           structure                level 1 dcl 1-343
Srequirements                          automatic       bit(72)                  dcl 2-96
Tacl                                   internal static fixed bin(17,0)          initial dcl 1-153
Tarchive                               internal static fixed bin(17,0)          initial dcl 1-358
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 1-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 1-190
Tdirectory                             internal static fixed bin(17,0)          initial dcl 1-358
Tiacl                                  internal static fixed bin(17,0)          initial dcl 1-209
Tlink                                  internal static fixed bin(17,0)          initial dcl 1-358
Tmsf                                   internal static fixed bin(17,0)          initial dcl 1-358
Tmsf_comp                              internal static fixed bin(17,0)          initial dcl 1-358
Tnodes                                 internal static fixed bin(17,0)          initial dcl 1-245
Tobj                                   internal static fixed bin(17,0)          initial dcl 1-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 1-311
Tsegment                               internal static fixed bin(17,0)          initial dcl 1-358
Tuser                                  internal static fixed bin(17,0)          initial dcl 1-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 1-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 1-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 1-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 1-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 1-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 1-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 1-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 1-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 1-324
brief_node_type                        internal static varying char(12)         initial array dcl 1-374
node_type                              internal static varying char(32)         initial array dcl 1-374

NAMES DECLARED BY EXPLICIT CONTEXT.
absolute                        000173 constant        entry                    external dcl 89
lib_node_path_                  000020 constant        entry                    external dcl 55
recurse                         000231 constant        entry                    internal dcl 98 ref 70 91 115 117
root_node                       000253 constant        label                    dcl 109 ref 104

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       512         522     451         522
Length       740     451        10         202      40           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_node_path_                      177 external procedure  is an external procedure.  
recurse                             130 internal procedure  calls itself recursively.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_node_path_           000100 i                           lib_node_path_
                         000101 path                        lib_node_path_
recurse                  000100 Pnode                       recurse
                         000102 PDnames                     recurse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_int_this       call_int_other      return              signal
ext_entry           int_entry

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     55 000014        70 000027        72 000040        73 000052        74 000053        75 000065        76 000103
     78 000104        79 000122        81 000133        82 000145        84 000160        89 000167        91 000201
     98 000230       103 000236       104 000242       106 000246       108 000252       109 000253       113 000263
    114 000272       115 000275       117 000364


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
