	COMPILATION LISTING OF SEGMENT convert_old_log
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/09/85  1130.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* format: style5 */
        8 convert_old_log:
        9         procedure options (variable);
       10 
       11 
       12 /**** Modification history:
       13*      Created 1984-12-18, BIM: from the old print_log command.
       14*      Modified 1985-01-20, BIM: to be run after the first bootload.
       15*      Modified 1985 Jan 21, Art Beattie: display old log names in error messages
       16*      and as conversion progresses. */
       17 
       18         dcl     absolute_pathname_	entry (character (*), character (*),
       19 				fixed binary (35));
       20         dcl     expand_pathname_	entry (character (*), character (*),
       21 				character (*), fixed binary (35));
       22         dcl     initiate_file_	entry (character (*), character (*),
       23 				bit (*), pointer, fixed binary (24),
       24 				fixed binary (35));
       25         dcl     terminate_file_	entry (pointer, fixed binary (24),
       26 				bit (*), fixed binary (35));
       27         declare pathname_		entry (character (*), character (*))
       28 				returns (character (168));
       29         dcl     com_err_		entry options (variable);
       30         dcl     cu_$arg_list_ptr	entry returns (pointer);
       31         dcl     ioa_		entry () options (variable);
       32         declare sub_err_		entry () options (variable);
       33         declare ssu_$standalone_invocation
       34 				entry (ptr, char (*), char (*), ptr,
       35 				entry, fixed bin (35));
       36         declare ssu_$destroy_invocation entry (ptr);
       37         declare ssu_$arg_count	entry (ptr, fixed bin);
       38         declare ssu_$arg_ptr		entry (ptr, fixed bin, ptr,
       39 				fixed bin (21));
       40         declare ssu_$abort_line	entry () options (variable);
       41         dcl     log_read_$open	entry (character (*), character (*),
       42 				pointer, fixed binary (35));
       43         dcl     log_read_$close	entry (pointer, fixed binary (35));
       44         dcl     log_write_$open_for_migrate
       45 				entry (character (*), character (*),
       46 				bit (1) aligned, pointer,
       47 				fixed binary (35));
       48         dcl     log_write_$close	entry (pointer, fixed binary (35));
       49         dcl     log_write_$general	entry (pointer, fixed binary (35),
       50 				fixed binary, fixed binary,
       51 				character (10) var, pointer,
       52 				fixed binary (35));
       53         dcl     log_segment_$finish_message
       54 				entry (pointer, pointer,
       55 				fixed binary (35));
       56         dcl     copy_		entry (pointer);
       57 
       58 
       59         dcl     code		fixed bin (35);
       60         dcl     argument		char (al) based (ap) unaligned;
       61         dcl     ap			ptr;
       62         dcl     al			fixed bin (21);
       63         dcl     old_log_x		fixed bin;
       64         dcl     an			fixed bin;
       65         dcl     n_args		fixed bin;
       66         dcl     total_messages	fixed bin;
       67         dcl     sci_ptr		pointer;
       68 
       69         dcl     COMMAND_NAME		char (32) int static
       70 				options (constant)
       71 				init ("convert_old_log");
       72         dcl     error_table_$badopt	ext fixed bin (35);
       73         dcl     error_table_$too_many_args
       74 				fixed bin (35) ext static;
       75         dcl     error_table_$noarg	fixed bin (35) ext static;
       76 
       77         dcl     cleanup		condition;
       78         dcl     no_write_permission	condition;
       79 
       80         declare 1 opt		aligned,
       81 	        2 log_write_ptr	pointer,
       82 	        2 log_read_ptr	pointer,
       83 	        2 pathnames		unaligned,
       84 		3 old_log		unaligned,
       85 		  4 dir_name	char (168),
       86 		  4 entryname	char (32),
       87 		  4 history_dir	char (168),
       88 		3 new_log		unaligned,
       89 		  4 dir_name	char (168),
       90 		  4 entryname	char (32),
       91 		  4 history_dir	char (168),
       92 	        2 n_old_logs	fixed bin,
       93 	        2 old_log_ptrs	(200) pointer,
       94 	        2 old_log_names	(200) char (32);
       95 
       96         declare (addr, length, rtrim)	builtin;
       97 
       98 
       99         call ssu_$standalone_invocation (sci_ptr, COMMAND_NAME, "1.0",
      100 	  cu_$arg_list_ptr (), SSU_ABORT, code);
      101         if code ^= 0 then
      102 	      do;
      103 	      call com_err_ (code, COMMAND_NAME,
      104 		"Failed to create ssu_ invocation");
      105 	      return;
      106 	      end;
      107 
      108         call ssu_$arg_count (sci_ptr, n_args);
      109 
      110         opt.log_write_ptr = null ();
      111         opt.pathnames = "";
      112         opt.old_log_ptrs (*) = null ();
      113         opt.n_old_logs = 0;
      114 
      115         on cleanup call clean_up;
      116 
      117         if n_args = 0 then
      118 	      call ssu_$abort_line (sci_ptr, 0,
      119 		"Usage: ^a OLD_LOG_PATHNAME {-old_history_dir OLD_LOG_DIR_PATH -new_dir NEW_LOG_DIR_PATH -new_history_dir NEW_LOG_HISTORY_PATH}"
      120 		, COMMAND_NAME);
      121 
      122         do an = 1 to n_args;
      123 	      call ssu_$arg_ptr (sci_ptr, an, ap, al);
      124 	      if index (argument, "-") ^= 1 then
      125 		    do;
      126 		    if opt.old_log.dir_name ^= "" then
      127 			  call ssu_$abort_line (sci_ptr,
      128 			      error_table_$too_many_args,
      129 			      "Only one log pathname may be given. ^a is the second."
      130 			      , argument);
      131 		    call expand_pathname_ (argument, opt.old_log.dir_name,
      132 		        opt.old_log.entryname, code);
      133 		    if code ^= 0 then
      134 			  call ssu_$abort_line (sci_ptr, code, "^a",
      135 			      argument);
      136 		    end;
      137 	      else if (argument = "-old_history_dir") | (argument = "-ohd")
      138 		then
      139 		    do;
      140 		    call get_next_arg (
      141 		        "pathname of a dir full of old logs following -history."
      142 		        );
      143 		    call absolute_pathname_ (argument,
      144 		        opt.old_log.history_dir, code);
      145 		    if code ^= 0 then
      146 			  call ssu_$abort_line (sci_ptr, code, "^a",
      147 			      argument);
      148 		    end;
      149 	      else if (argument = "-new_dir") | (argument = "-nd") then
      150 		    do;
      151 		    call get_next_arg (
      152 		        "target directory for converted log.");
      153 		    call absolute_pathname_ (argument, opt.new_log.dir_name,
      154 		        code);
      155 		    if code ^= 0 then
      156 			  call ssu_$abort_line (sci_ptr, code, "^a",
      157 			      argument);
      158 		    end;
      159 	      else if (argument = "-new_history_dir") | (argument = "-nhd")
      160 		then
      161 		    do;
      162 		    call get_next_arg (
      163 		        "target directory for the second and later new log segments."
      164 		        );
      165 		    call absolute_pathname_ (argument,
      166 		        opt.new_log.history_dir, code);
      167 		    if code ^= 0 then
      168 			  call ssu_$abort_line (sci_ptr, code, "^a",
      169 			      argument);
      170 		    end;
      171 	      else
      172 		    call ssu_$abort_line (sci_ptr, error_table_$badopt,
      173 		        "^a", argument);
      174         end;
      175 
      176         if opt.old_log.dir_name = "" then
      177 	      call ssu_$abort_line (sci_ptr, error_table_$noarg,
      178 		"A log to be converted must be specified.");
      179         if opt.old_log.history_dir = "" then
      180 	      opt.old_log.history_dir = ">udd>SysAdmin>admin>history";
      181         if opt.new_log.dir_name = "" then
      182 	      opt.new_log.dir_name = ">system_control_dir>as_logs";
      183         opt.new_log.entryname = opt.old_log.entryname;
      184         if opt.new_log.history_dir = "" then
      185 	      opt.new_log.history_dir = ">udd>SysAdmin>admin>history";
      186 
      187 /**** Initiate the first (most recent) log. */
      188 
      189         call initiate_file_ (opt.old_log.dir_name, opt.old_log.entryname,
      190 	  R_ACCESS, opt.old_log_ptrs (1), (0), code);
      191         if code ^= 0 then
      192 	      call ssu_$abort_line (sci_ptr, code, "Failed to initiate ^a.",
      193 		pathname_ (opt.old_log.dir_name, opt.old_log.entryname));
      194         opt.old_log_names (1) = opt.old_log.entryname;
      195         opt.n_old_logs = 1;
      196 
      197         call add_to_history (1, opt.old_log.dir_name);  /* get the co-resident segments */
      198         call add_to_history (opt.n_old_logs, opt.old_log.history_dir);
      199 
      200 /**** We now have an array of pointers to old log segments to eat */
      201 /**** We want to write all the messages into segments in the history dir. */
      202 /**** And then move the last one and fix its header. */
      203 
      204         call log_write_$open_for_migrate (opt.new_log.history_dir,
      205 	  opt.new_log.entryname, "1"b, opt.log_write_ptr, code);
      206         if code ^= 0 then
      207 	      call ssu_$abort_line (sci_ptr, code,
      208 		"Failed to open new log ^a.",
      209 		pathname_ (opt.new_log.dir_name, opt.new_log.entryname));
      210 
      211         total_messages = 0;
      212         do old_log_x = opt.n_old_logs to 1 by -1;	      /* Work from the oldest */
      213 	      call ioa_ ("convert_old_log: Converting old log segment ^a",
      214 		opt.old_log_names (old_log_x));
      215 	      call write_one_log (opt.old_log_ptrs (old_log_x),
      216 		opt.old_log_names (old_log_x));
      217         end;
      218 
      219         call log_write_$close (opt.log_write_ptr, (0));
      220         if opt.new_log.dir_name ^= opt.new_log.history_dir then
      221 	      call fix_history_dir;
      222         call terminate_old_logs;
      223 
      224         call ioa_ ("convert_old_log: Converted ^d segments, ^d messages.",
      225 	  opt.n_old_logs, total_messages);
      226 
      227         return;
      228 
      229 
      230 get_next_arg:
      231         procedure (P_what);
      232 
      233         declare P_what		char (*);
      234 
      235         if n_args = an then
      236 	      call ssu_$abort_line (sci_ptr, error_table_$noarg, "^a", P_what)
      237 		;
      238         an = an + 1;
      239         call ssu_$arg_ptr (sci_ptr, an, ap, al);
      240         return;
      241         end get_next_arg;
      242 
      243 terminate_old_logs:
      244         procedure;
      245 
      246         declare x			fixed bin;
      247 
      248         do x = 1 to opt.n_old_logs;
      249 	      call terminate_file_ (opt.old_log_ptrs (x), (0), TERM_FILE_TERM,
      250 		(0));
      251         end;
      252         return;
      253         end terminate_old_logs;
      254 
      255 add_to_history:
      256         procedure (P_oldest_index, P_dir_name);
      257 
      258         declare P_oldest_index	fixed bin;
      259         declare P_dir_name		char (*);
      260 
      261         declare entryname		char (32);
      262         declare current_log_ptr	pointer;
      263         declare older_log_ptr		pointer;
      264 
      265         current_log_ptr = opt.old_log_ptrs (P_oldest_index);
      266         code = 0;
      267         do while ("1"b);
      268 	      entryname =
      269 		rtrim (opt.old_log.entryname) || ".-."
      270 		|| current_log_ptr -> sys_log_file.lls;
      271 	      call initiate_file_ (P_dir_name, entryname, R_ACCESS,
      272 		older_log_ptr, (0), code);
      273 	      if code ^= 0 then
      274 		    return;
      275 	      opt.n_old_logs = opt.n_old_logs + 1;
      276 	      opt.old_log_ptrs (opt.n_old_logs) = older_log_ptr;
      277 	      opt.old_log_names (opt.n_old_logs) = entryname;
      278 	      current_log_ptr = older_log_ptr;
      279         end;
      280         end add_to_history;
      281 
      282 write_one_log:
      283         procedure (P_log_ptr, P_log_name);
      284 
      285         declare P_log_ptr		pointer;
      286         declare log_ptr		pointer;
      287         declare 1 log		aligned like sys_log_file
      288 				based (log_ptr);
      289         declare x			fixed bin;
      290         declare log_name		char (32);
      291         declare P_log_name		char (*) aligned;
      292 
      293         log_name = P_log_name;
      294         log_ptr = P_log_ptr;
      295         do x = 1 to log.count;
      296 RETRY:
      297 	      total_messages = total_messages + 1;
      298 	      call log_write_$general (opt.log_write_ptr, (0),
      299 		length (rtrim (log.array (x).line)), (0), "",
      300 		log_message_ptr, code);
      301 	      if code ^= 0 then
      302 		    do;
      303 		    call sub_err_ (code, COMMAND_NAME, ACTION_CAN_RESTART,
      304 		        null (), (0),
      305 		        "Failed to add message ^d from segment ^a (^p) to log ^a."
      306 		        , x, log_name, log_ptr, opt.new_log.entryname);
      307 		    go to RETRY;
      308 		    end;
      309 	      log_message.severity = log.array (x).svty;
      310 	      log_message.time = log.array (x).time;
      311 	      log_message.text =
      312 		substr (log.array (x).line, 1, log_message.text_lth);
      313 	      call log_segment_$finish_message (
      314 		setwordno (log_message_ptr, 0), log_message_ptr, code);
      315 	      if code ^= 0 then
      316 		    call sub_err_ (code, COMMAND_NAME, ACTION_CANT_RESTART,
      317 		        null (), (0),
      318 		        "Failed to finish message ^d in new log that was obtained from old log ^a"
      319 		        , log_message.sequence, log_name);
      320         end;
      321         end write_one_log;
      322 
      323 fix_history_dir:
      324         procedure;
      325 
      326         call log_read_$open (opt.new_log.dir_name, opt.new_log.entryname,
      327 	  opt.log_read_ptr, code);
      328         if code ^= 0 then
      329 	      do;
      330 	      call com_err_ (code, "convert_old_log",
      331 		"No log named ^a found in ^a. If you create one, you must use the set_log_history_dir command to link it to the converted log."
      332 		, opt.new_log.entryname, opt.new_log.dir_name);
      333 	      return;
      334 	      end;
      335 
      336         log_segment_ptr =
      337 	  opt.log_read_ptr
      338 	  -> log_read_data
      339 	  .segments (opt.log_read_ptr -> log_read_data.very_first_log_idx)
      340 	  .ptr;
      341         on no_write_permission go to NO_WRITE;
      342         log_segment.previous_log_dir = opt.new_log.history_dir;
      343         revert no_write_permission;
      344         call log_read_$close (opt.log_read_ptr, (0));
      345         return;
      346 NO_WRITE:
      347         call com_err_ (0, "convert_old_log",
      348 	  "You lack w access to the current log ^a, so the previous log dir was not set."
      349 	  , opt.new_log.entryname);
      350         return;
      351 
      352         end fix_history_dir;
      353 
      354 
      355 clean_up:
      356         procedure;
      357 
      358         call terminate_old_logs;
      359         if opt.log_write_ptr ^= null () then
      360 	      call log_write_$close (opt.log_write_ptr, (0));
      361         if sci_ptr ^= null () then
      362 	      call ssu_$destroy_invocation (sci_ptr);
      363         return;
      364         end clean_up;
      365 
      366 SSU_ABORT:
      367         procedure;
      368 
      369         go to ABORT;
      370         end SSU_ABORT;
      371 
      372 ABORT:
      373         call clean_up;
      374         return;
      375 
  1     1 /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  1     2 
  1     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  1     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  1     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  1     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  1     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  1     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  1     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  1    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  1    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  1    12 
  1    13 declare 1 log_message         aligned based (log_message_ptr),
  1    14           2 header            aligned like log_message_header,
  1    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  1    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  1    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  1    18 
  1    19 declare   log_message_ptr pointer;
  1    20 declare   log_message_text_lth fixed bin;
  1    21 declare   log_message_data_class_lth fixed bin;
  1    22 declare   log_message_data_lth fixed bin;
  1    23 
  1    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      376 
  2     1 /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  2     2 
  2     3 declare   log_segment_ptr               pointer;
  2     4 declare   log_segment_max_size          fixed bin (18);
  2     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
  2     6 
  2     7 
  2     8 declare 1 log_segment                   aligned based (log_segment_ptr),
  2     9           2 header                      aligned like log_segment_header,
  2    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
  2    11 
  2    12 
  2    13 declare 1 log_segment_header            aligned based,
  2    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
  2    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
  2    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
  2    17 
  2    18           2 limits,
  2    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
  2    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
  2    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
  2    22             3 last_time                 fixed bin (71),
  2    23 
  2    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
  2    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
  2    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
  2    27           2 max_size                    fixed bin (18),     /* Total words in data area */
  2    28 
  2    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
  2    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
  2    31                                                             /* detect all the dead listeners after a reboot */
  2    32           2 listener (25),                                  /* Processes waiting for messages in the log */
  2    33             3 process_id                bit (36) aligned,
  2    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
  2    35 
  2    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
  2    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
  2    38 
  2    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
  2    40 
  2    41 
  2    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
  2    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
  2    44 
  2    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
      377 
  3     1 /* BEGIN INCLUDE FILE ... log_read_data.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  3     2 
  3     3 /* Added reader_procedure, area_ptr, reader_data_ptr, and entry variables 11/28/84 Steve Herbst */
  3     4 /* Added (latest earlier)_message_ptr, (first last)_held_message and get_log_uid 11/30/84 Steve Herbst */
  3     5 /* Put everything before the segments array into header 12/04/84 Steve Herbst */
  3     6 /* Added entry variables free_message, register & deregister 12/06/84 Steve Herbst */
  3     7 
  3     8 
  3     9 declare   log_read_data_ptr             pointer;
  3    10 declare   log_read_data_n_segments      fixed bin;
  3    11 
  3    12 declare 1 log_read_data                 aligned based (log_read_data_ptr),
  3    13           2 header                      aligned,
  3    14 	  3 sentinel		char (8) aligned,
  3    15             3 n_segments                fixed bin,
  3    16             3 history_complete          bit (1) aligned,
  3    17 	  3 call_procedures		bit (1) aligned,
  3    18 	  3 allocate_copies		bit (1) aligned,
  3    19             3 current_ptr               pointer,            /* Trivial optimization for positioning */
  3    20             3 current_idx               fixed bin,
  3    21 	  3 reader_data_ptr		pointer,		/* log_read_data_ptr returned by reader_proc$open */
  3    22 	  3 user_area_ptr		pointer,            /* Used in the inner ring to allocate outer ring copies. */
  3    23 	  3 latest_message		aligned like saved_message,	/* The last message returned */
  3    24 	  3 earlier_message		aligned like saved_message,	/* The one returned before latest */
  3    25 	  3 n_held_messages           fixed bin,
  3    26 	  3 first_held_message_ptr	pointer,		/* Used by $hold_message */
  3    27 	  3 last_held_message_ptr	pointer,		/* ditto */
  3    28 	  3 ev,					/* Entry variable for each operation */
  3    29 	    4 open variable entry (char (*), char (*), pointer, pointer, fixed bin (35)),
  3    30 	    4 close variable entry (pointer, fixed bin (35)),
  3    31 	    4 next_message variable entry (pointer, pointer, fixed bin (35)),
  3    32 	    4 prev_message variable entry (pointer, pointer, fixed bin (35)),
  3    33 	    4 position_sequence variable entry (pointer, fixed bin (35), bit (1) aligned, pointer, fixed bin (35)),
  3    34 	    4 position_time variable entry (pointer, fixed bin (71), bit (1) aligned, pointer, fixed bin (35)),
  3    35 	    4 update variable entry (fixed bin (35), pointer, pointer, fixed bin (35)),
  3    36 	    4 hold_message variable entry (pointer, pointer),
  3    37 	    4 free_message variable entry (pointer, pointer),
  3    38 	    4 get_log_uid variable entry (pointer, bit (36) aligned, fixed bin (35)),
  3    39 	    4 register variable entry (pointer, bit (36) aligned, fixed bin (71), fixed bin (35)),
  3    40 	    4 deregister variable entry (pointer, bit (36) aligned, fixed bin (71), fixed bin (35)),
  3    41 	  3 limits                      aligned,            /* Absolute limits of family contents */
  3    42 	    4 very_first_time           fixed bin (71),     /* Set up during initialization */
  3    43 	    4 very_last_time            fixed bin (71),
  3    44 	    4 very_first_sequence       fixed bin (35),
  3    45 	    4 very_last_sequence        fixed bin (35),
  3    46 	    4 very_first_log_idx        fixed bin,
  3    47 	    4 very_last_log_idx         fixed bin,
  3    48 
  3    49           2 segments (log_read_data_n_segments refer (log_read_data.n_segments)),
  3    50             3 dname                     char (168) unaligned,
  3    51             3 ename                     char (32) unaligned,
  3    52             3 ptr                       pointer,
  3    53             3 suffix_time               fixed bin (71),     /* Time from suffix-- all messages in log are earlier */
  3    54             3 dir_uid                   bit (36) aligned,   /* UID of parent dir */
  3    55             3 prev_missing              bit (1) aligned,
  3    56             3 damaged                   bit (1) aligned,
  3    57 
  3    58           2 pad                         fixed bin;
  3    59 
  3    60 declare 1 saved_message		aligned based,
  3    61 	2 actual_ptr		pointer,		/* Points to message in log. */
  3    62 	2 copy_ptr		pointer;		/* Points to user-ring allocated copy. */
  3    63 
  3    64 dcl  1 log_held_message_node aligned based,
  3    65        2 message aligned like saved_message,
  3    66        2 reference_count fixed bin,
  3    67        2 next_ptr ptr;
  3    68 
  3    69 declare LOG_READ_DATA_VERSION_SENTINEL char (8) int static options (constant)
  3    70         init ("logr0001") options (constant);
  3    71 
  3    72 /* END INCLUDE FILE ... log_read_data.incl.pl1 */
      378 
  4     1 /* Declaration of the system log file.
  4     2*
  4     3*   This file contains all error messages put out by the answering service */
  4     4 
  4     5 dcl 1 sys_log_file based (sys_log_ptr) aligned,
  4     6     2 count fixed bin,				/* number of messages */
  4     7     2 max fixed bin,				/* maximum number */
  4     8     2 ttime fixed bin (71),				/* date & time of last message */
  4     9     2 lep fixed bin,				/* last entry processed by daily_log_process */
  4    10     2 lls char (12),				/* suffix on last log */
  4    11     2 array (8159),
  4    12       3 time fixed bin (71),				/* time of entry */
  4    13       3 svty fixed bin,				/* severity of entry */
  4    14       3 line char (116);				/* error message. entry is 32 words */
  4    15 
  4    16 /* end of system log declaration */
      379 
      380         declare sys_log_ptr		pointer init (null ());
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      381 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      382 
  7     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      383 
      384         end convert_old_log;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/08/85  1134.6  convert_old_log.pl1               >spec>on>41-15>convert_old_log.pl1
376          1    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
377          2    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
378          3    01/21/85  0912.3  log_read_data.incl.pl1            >ldd>include>log_read_data.incl.pl1
379          4    01/05/79  1311.1  syslog.incl.pl1                   >ldd>include>syslog.incl.pl1
381          5    04/09/85  1109.7  access_mode_values.incl.pl1       >spec>on>41-15>access_mode_values.incl.pl1
382          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
383          7    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000026 constant        bit(36)                  initial dcl 6-7 set ref 315*
ACTION_CAN_RESTART              000051 constant        bit(36)                  initial dcl 6-7 set ref 303*
COMMAND_NAME                    000001 constant        char(32)                 initial unaligned dcl 69 set ref 99* 103* 117* 303*
                                                                                  315*
P_dir_name                             parameter       char                     unaligned dcl 259 set ref 255 271*
P_log_name                             parameter       char                     dcl 291 ref 282 293
P_log_ptr                              parameter       pointer                  dcl 285 ref 282 294
P_oldest_index                         parameter       fixed bin(17,0)          dcl 258 ref 255 265
P_what                                 parameter       char                     unaligned dcl 233 set ref 230 235*
R_ACCESS                        000026 constant        bit(3)                   initial unaligned dcl 5-11 set ref 189* 271*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial unaligned dcl 7-14 set ref 249*
absolute_pathname_              000010 constant        entry                    external dcl 18 ref 143 153 165
al                              000104 automatic       fixed bin(21,0)          dcl 62 set ref 123* 124 126 126 131 131 133 133 137
                                                                                  137 143 143 145 145 149 149 153 153 155 155 159
                                                                                  159 165 165 167 167 171 171 239*
an                              000106 automatic       fixed bin(17,0)          dcl 64 set ref 122* 123* 235 238* 238 239*
ap                              000102 automatic       pointer                  dcl 61 set ref 123* 124 126 131 133 137 137 143 145
                                                                                  149 149 153 155 159 159 165 167 171 239*
argument                               based           char                     unaligned dcl 60 set ref 124 126* 131* 133* 137 137
                                                                                  143* 145* 149 149 153* 155* 159 159 165* 167* 171*
array                    10            based           structure                array level 2 dcl 287
cleanup                         000114 stack reference condition                dcl 77 ref 115
code                            000100 automatic       fixed bin(35,0)          dcl 59 set ref 99* 101 103* 131* 133 133* 143* 145
                                                                                  145* 153* 155 155* 165* 167 167* 189* 191 191*
                                                                                  204* 206 206* 266* 271* 273 298* 301 303* 313* 315
                                                                                  315* 326* 328 330*
com_err_                        000022 constant        entry                    external dcl 29 ref 103 330 346
count                                  based           fixed bin(17,0)          level 2 dcl 287 ref 295
cu_$arg_list_ptr                000024 constant        entry                    external dcl 30 ref 99 99
current_log_ptr                 004374 automatic       pointer                  dcl 262 set ref 265* 268 278*
dir_name                140     000122 automatic       char(168)                level 4 in structure "opt" packed unaligned dcl 80
                                                                                  in procedure "convert_old_log" set ref 153* 181
                                                                                  181* 206* 206* 220 326* 330*
dir_name                  4     000122 automatic       char(168)                level 4 in structure "opt" packed unaligned dcl 80
                                                                                  in procedure "convert_old_log" set ref 126 131*
                                                                                  176 189* 191* 191* 197*
entryname               212     000122 automatic       char(32)                 level 4 in structure "opt" packed unaligned dcl 80
                                                                                  in procedure "convert_old_log" set ref 183* 204*
                                                                                  206* 206* 303* 326* 330* 346*
entryname                56     000122 automatic       char(32)                 level 4 in structure "opt" packed unaligned dcl 80
                                                                                  in procedure "convert_old_log" set ref 131* 183
                                                                                  189* 191* 191* 194 268
entryname                       004364 automatic       char(32)                 unaligned dcl 261 in procedure "add_to_history" set
                                                                                  ref 268* 271* 277
error_table_$badopt             000060 external static fixed bin(35,0)          dcl 72 set ref 171*
error_table_$noarg              000064 external static fixed bin(35,0)          dcl 75 set ref 176* 235*
error_table_$too_many_args      000062 external static fixed bin(35,0)          dcl 73 set ref 126*
expand_pathname_                000012 constant        entry                    external dcl 20 ref 131
header                                 based           structure                level 2 in structure "log_segment" dcl 2-8
                                                                                  in procedure "convert_old_log"
header                                 based           structure                level 2 in structure "log_message" dcl 1-13
                                                                                  in procedure "convert_old_log"
header                                 based           structure                level 2 in structure "log_read_data" dcl 3-12
                                                                                  in procedure "convert_old_log"
history_dir             222     000122 automatic       char(168)                level 4 in structure "opt" packed unaligned dcl 80
                                                                                  in procedure "convert_old_log" set ref 165* 184
                                                                                  184* 204* 220 342
history_dir              66     000122 automatic       char(168)                level 4 in structure "opt" packed unaligned dcl 80
                                                                                  in procedure "convert_old_log" set ref 143* 179
                                                                                  179* 198*
initiate_file_                  000014 constant        entry                    external dcl 22 ref 189 271
ioa_                            000026 constant        entry                    external dcl 31 ref 213 224
length                                                 builtin function         dcl 96 ref 298 298
limits                  114            based           structure                level 3 dcl 3-12
line                     13            based           char(116)                array level 3 dcl 287 ref 298 298 311
lls                       5            based           char(12)                 level 2 dcl 4-5 ref 268
log                                    based           structure                level 1 dcl 287
log_message                            based           structure                level 1 dcl 1-13
log_message_header                     based           structure                level 1 dcl 1-3
log_message_ptr                 004340 automatic       pointer                  dcl 1-19 set ref 298* 309 310 311 311 313 313 313*
                                                                                  315
log_name                        004411 automatic       char(32)                 unaligned dcl 290 set ref 293* 303* 315*
log_ptr                         004406 automatic       pointer                  dcl 286 set ref 294* 295 298 298 303* 309 310 311
log_read_$close                 000046 constant        entry                    external dcl 43 ref 344
log_read_$open                  000044 constant        entry                    external dcl 41 ref 326
log_read_data                          based           structure                level 1 dcl 3-12
log_read_ptr              2     000122 automatic       pointer                  level 2 dcl 80 set ref 326* 336 336 344*
log_segment                            based           structure                level 1 dcl 2-8
log_segment_$finish_message     000056 constant        entry                    external dcl 53 ref 313
log_segment_header                     based           structure                level 1 dcl 2-13
log_segment_ptr                 004342 automatic       pointer                  dcl 2-3 set ref 336* 342
log_write_$close                000052 constant        entry                    external dcl 48 ref 219 359
log_write_$general              000054 constant        entry                    external dcl 49 ref 298
log_write_$open_for_migrate     000050 constant        entry                    external dcl 44 ref 204
log_write_ptr                   000122 automatic       pointer                  level 2 dcl 80 set ref 110* 204* 219* 298* 359 359*
n_args                          000107 automatic       fixed bin(17,0)          dcl 65 set ref 108* 117 122 235
n_old_logs              274     000122 automatic       fixed bin(17,0)          level 2 dcl 80 set ref 113* 195* 198* 212 224* 248
                                                                                  275* 275 276 277
new_log                 140     000122 automatic       structure                level 3 packed unaligned dcl 80
no_write_permission             000000 stack reference condition                dcl 78 ref 341 343
old_log                   4     000122 automatic       structure                level 3 packed unaligned dcl 80
old_log_names          1116     000122 automatic       char(32)                 array level 2 dcl 80 set ref 194* 213* 215* 277*
old_log_ptrs            276     000122 automatic       pointer                  array level 2 dcl 80 set ref 112* 189* 215* 249* 265
                                                                                  276*
old_log_x                       000105 automatic       fixed bin(17,0)          dcl 63 set ref 212* 213 215 215*
older_log_ptr                   004376 automatic       pointer                  dcl 263 set ref 271* 276 278
opt                             000122 automatic       structure                level 1 dcl 80
pathname_                       000020 constant        entry                    external dcl 27 ref 191 191 206 206
pathnames                 4     000122 automatic       structure                level 2 packed unaligned dcl 80 set ref 111*
previous_log_dir          4            based           char(168)                level 3 packed unaligned dcl 2-8 set ref 342*
ptr                     206            based           pointer                  array level 3 dcl 3-12 ref 336
rtrim                                                  builtin function         dcl 96 ref 268 298 298
saved_message                          based           structure                level 1 dcl 3-60
sci_ptr                         000112 automatic       pointer                  dcl 67 set ref 99* 108* 117* 123* 126* 133* 145*
                                                                                  155* 167* 171* 176* 191* 206* 235* 239* 361 361*
segments                124            based           structure                array level 2 dcl 3-12
sequence                  1            based           fixed bin(35,0)          level 3 dcl 1-13 set ref 315*
severity                  2            based           fixed bin(8,0)           level 3 packed unaligned dcl 1-13 set ref 309*
ssu_$abort_line                 000042 constant        entry                    external dcl 40 ref 117 126 133 145 155 167 171 176
                                                                                  191 206 235
ssu_$arg_count                  000036 constant        entry                    external dcl 37 ref 108
ssu_$arg_ptr                    000040 constant        entry                    external dcl 38 ref 123 239
ssu_$destroy_invocation         000034 constant        entry                    external dcl 36 ref 361
ssu_$standalone_invocation      000032 constant        entry                    external dcl 33 ref 99
sub_err_                        000030 constant        entry                    external dcl 32 ref 303 315
svty                     12            based           fixed bin(17,0)          array level 3 dcl 287 ref 309
sys_log_file                           based           structure                level 1 dcl 4-5
sys_log_ptr                     004344 automatic       pointer                  initial dcl 380 set ref 380*
terminate_file_                 000016 constant        entry                    external dcl 25 ref 249
text                      6            based           char                     level 2 packed unaligned dcl 1-13 set ref 311*
text_lth                  4            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-13 ref 311 311
time                     10            based           fixed bin(71,0)          array level 3 in structure "log" dcl 287
                                                                                  in procedure "write_one_log" ref 310
time                      2(18)        based           fixed bin(53,0)          level 3 in structure "log_message" packed unaligned
                                                                                  dcl 1-13 in procedure "convert_old_log" set ref
                                                                                  310*
total_messages                  000110 automatic       fixed bin(17,0)          dcl 66 set ref 211* 224* 296* 296
very_first_log_idx      122            based           fixed bin(17,0)          level 4 dcl 3-12 ref 336
x                               004410 automatic       fixed bin(17,0)          dcl 289 in procedure "write_one_log" set ref 295*
                                                                                  298 298 303* 309 310 311*
x                               000100 automatic       fixed bin(17,0)          dcl 246 in procedure "terminate_old_logs" set ref
                                                                                  248* 249*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
LOG_READ_DATA_VERSION_SENTINEL         internal static char(8)                  initial unaligned dcl 3-69
LOG_SEGMENT_COMPLETE_MESSAGE           internal static bit(36)                  initial dcl 2-43
LOG_SEGMENT_NEW_MESSAGE                internal static bit(36)                  initial dcl 2-42
LOG_SEGMENT_VERSION_1                  internal static char(8)                  initial unaligned dcl 2-5
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 7-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 7-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 7-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
addr                                                   builtin function         dcl 96
copy_                           000000 constant        entry                    external dcl 56
log_held_message_node                  based           structure                level 1 dcl 3-64
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 1-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 1-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 1-20
log_read_data_n_segments               automatic       fixed bin(17,0)          dcl 3-10
log_read_data_ptr                      automatic       pointer                  dcl 3-9
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 2-4
terminate_file_switches                based           structure                level 1 packed unaligned dcl 7-4

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT                           002100 constant        label                    dcl 372 ref 369
NO_WRITE                        003047 constant        label                    dcl 346 ref 341
RETRY                           002435 constant        label                    dcl 296 set ref 307
SSU_ABORT                       003156 constant        entry                    internal dcl 366 ref 99 99
add_to_history                  002243 constant        entry                    internal dcl 255 ref 197 198
clean_up                        003107 constant        entry                    internal dcl 355 ref 115 372
convert_old_log                 000470 constant        entry                    external dcl 8
fix_history_dir                 002704 constant        entry                    internal dcl 323 ref 220
get_next_arg                    002105 constant        entry                    internal dcl 230 ref 140 151 162
terminate_old_logs              002172 constant        entry                    internal dcl 243 ref 222 358
write_one_log                   002404 constant        entry                    internal dcl 282 ref 215

NAMES DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 124
null                                                   builtin function         ref 110 112 303 303 315 315 359 361 380
setwordno                                              builtin function         ref 313 313
substr                                                 builtin function         ref 311

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3574        3662    3234        3604
Length      4250    3234        66         352     340           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
convert_old_log                    2598 external procedure  is an external procedure.  
on unit on line 115                  64 on unit               
get_next_arg                            internal procedure  shares stack frame of external procedure convert_old_log.  
terminate_old_logs                   86 internal procedure  is called by several nonquick procedures.  
add_to_history                          internal procedure  shares stack frame of external procedure convert_old_log.  
write_one_log                           internal procedure  shares stack frame of external procedure convert_old_log.  
fix_history_dir                     143 internal procedure  enables or reverts conditions.  
on unit on line 341                  64 on unit               
clean_up                             72 internal procedure  is called by several nonquick procedures.  
SSU_ABORT                            64 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_old_log          000100 code                        convert_old_log
                         000102 ap                          convert_old_log
                         000104 al                          convert_old_log
                         000105 old_log_x                   convert_old_log
                         000106 an                          convert_old_log
                         000107 n_args                      convert_old_log
                         000110 total_messages              convert_old_log
                         000112 sci_ptr                     convert_old_log
                         000122 opt                         convert_old_log
                         004340 log_message_ptr             convert_old_log
                         004342 log_segment_ptr             convert_old_log
                         004344 sys_log_ptr                 convert_old_log
                         004364 entryname                   add_to_history
                         004374 current_log_ptr             add_to_history
                         004376 older_log_ptr               add_to_history
                         004406 log_ptr                     write_one_log
                         004410 x                           write_one_log
                         004411 log_name                    write_one_log
terminate_old_logs       000100 x                           terminate_old_logs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      cu_$arg_list_ptr              expand_pathname_
initiate_file_                ioa_                          log_read_$close               log_read_$open
log_segment_$finish_message   log_write_$close              log_write_$general            log_write_$open_for_migrate
pathname_                     ssu_$abort_line               ssu_$arg_count                ssu_$arg_ptr
ssu_$destroy_invocation       ssu_$standalone_invocation    sub_err_                      terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg            error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      8 000467       380 000475        99 000477       101 000546       103 000550       105 000574       108 000575
    110 000606       111 000610       112 000632       113 000645       115 000646       117 000670       122 000723
    123 000733       124 000750       126 000764       131 001023       133 001053       136 001107       137 001110
    140 001120       143 001126       145 001152       148 001206       149 001207       151 001217       153 001225
    155 001251       158 001305       159 001306       162 001316       165 001324       167 001350       170 001404
    171 001405       174 001437       176 001441       179 001471       181 001500       183 001507       184 001512
    189 001521       191 001557       194 001631       195 001634       197 001636       198 001642       204 001645
    206 001700       211 001752       212 001753       213 001761       215 002002       217 002023       219 002026
    220 002040       222 002050       224 002054       227 002077       372 002100       374 002104       230 002105
    235 002116       238 002152       239 002153       240 002170       243 002171       248 002177       249 002207
    251 002240       252 002242       255 002243       265 002254       266 002261       268 002262       271 002322
    273 002363       275 002366       276 002367       277 002373       278 002401       279 002402       280 002403
    282 002404       293 002415       294 002422       295 002425       296 002435       298 002436       301 002503
    303 002505       307 002565       309 002566       310 002576       311 002601       313 002607       315 002624
    320 002700       321 002702       323 002703       326 002711       328 002736       330 002741       333 003001
    336 003002       341 003007       342 003026       343 003033       344 003034       345 003046       346 003047
    350 003105       355 003106       358 003114       359 003121       361 003140       363 003154       366 003155
    369 003163


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
