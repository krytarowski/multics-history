	COMPILATION LISTING OF SEGMENT log_output_io_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/11/85  1134.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* log_output_io_.pl1 put_chars for log_output_ */
        7 /* format: style2 */
        8 
        9 /**** Created 1984-10 BIM */
       10 /**** Modified 1984-10-22 BIM for get/set_binary_info */
       11 /**** Modified 1984-10-31 BIM for flush_pending_output */
       12 /**** Modified 1984-11-15 BIM to put back bugfix to buffer filling 
       13*      when there is a newline in the middle of output. */
       14 /**** Modified 1985-01-02, BIM: fixed partial line processing. */
       15 /**** Modified 1985-02-10, BIM: another fix: load_buffer_chain to initialize loop control correctly */
       16 /**** Modified 1985-03-25, EJ Sharpe: set return code on control entrypoint,
       17*      add flush_pending_output as io_call control */
       18 
       19 log_output_io_:
       20      procedure;
       21 
       22 
  1     1 /* BEGIN INCLUDE FILE log_output_attach_data_.incl.pl1 BIM 28-03-1981 */
  1     2 /* format: style3,idind30 */
  1     3 
  1     4 /* This is the IOX attach data block for the log_output_ io module. */
  1     5 
  1     6 declare	attach_data_ptr		pointer;
  1     7 declare	1 attach_data		aligned based (attach_data_ptr),
  1     8 	  2 open_mode		fixed bin,	/* the usual iox open mode */
  1     9 	  2 log_info_ptr		pointer,		/* log_mgr_ info pointer */
  1    10 	  2 flags			aligned,
  1    11 	  ( 3 binary_data,				/* binary being tacked onto each record */
  1    12 	    3 create_ok				/* create-if-not-found */
  1    13 	    )			bit (1) unaligned,
  1    14 	    3 pad			bit (34) unaligned,
  1    15 	  2 severity		fixed bin,	/* supplied in atd, valid only for stream */
  1    16 	  2 dir_name		character (168) unaligned,
  1    17 	  2 entryname		character (32) unaligned,
  1    18 	  2 attach_description	character (512) varying,
  1    19 	  2 open_description	character (64) varying,
  1    20 	  2 mode_string		character (64) varying,
  1    21 	  2 buffer_area_ptr		pointer,
  1    22 	  2 buffer_chain		aligned,		/* for assembling lines */
  1    23 	    3 total_buffered_length	fixed bin (21),
  1    24 	    3 head		pointer options (packed),
  1    25 	    3 tail		pointer options (packed),
  1    26 	  2 binary_data_class	char (16) varying,
  1    27 	  2 binary_data_length	fixed bin (18),
  1    28 	  2 binary_data_ptr		pointer;
  1    29 
  1    30 declare	buffer_area		area based (attach_data.buffer_area_ptr);
  1    31 declare	buffer_ptr		pointer;
  1    32 declare	buffer_length		fixed bin (21);
  1    33 declare	1 buffer			aligned based (buffer_ptr),
  1    34 	  2 length		fixed bin (21),
  1    35 	  2 next			pointer unaligned,
  1    36 	  2 data			char (buffer_length refer (buffer.length)) unaligned;
  1    37 
  1    38 
  1    39 declare	binary_data		(attach_data.binary_data_length) bit (36) aligned
  1    40 				based (attach_data.binary_data_ptr);
  1    41 
  1    42 /* END INCLUDE FILE log_output_attach_data_.incl.pl1 */
       23 
  2     1 /* Begin include file log_output_binary_info.incl.pl1 BIM 1984-10-22 */
  2     2 /* format: style3,idind30 */
  2     3 
  2     4 declare	log_output_binary_info_ptr	pointer;
  2     5 declare	1 log_output_binary_info	aligned based (log_output_binary_info_ptr),
  2     6 	  2 version		char (8) aligned,
  2     7 	  2 data_class		char (16) varying,	/* "" for no data */
  2     8 	  2 data_ptr		pointer,
  2     9 	  2 data_length		fixed bin (18);	/* in words */
  2    10 
  2    11 declare	LOG_OUTPUT_BINARY_INFO_VERSION_1
  2    12 				char (8) init ("lobi0001") int static options (constant);
  2    13 
  2    14 /* End include file log_output_binary_info.incl.pl1 */
       24 
       25 
  3     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  3     2 
  3     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  3     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  3     5 
  3     6 declare	mode_value_ptr		ptr,
  3     7 	number_of_modes		fixed bin;
  3     8 
  3     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  3    10 	  2 version		fixed bin,
  3    11 	  2 number		fixed bin,
  3    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  3    13 
  3    14 declare	mode_string_info_ptr	ptr;
  3    15 
  3    16 declare	1 mode_value		aligned based (mode_value_ptr),
  3    17 	  2 version		fixed bin,
  3    18 	  2 mode_name		char (32) unaligned,
  3    19 	  2 flags,
  3    20 	    3 boolean_valuep	bit (1) unaligned,
  3    21 	    3 numeric_valuep	bit (1) unaligned,
  3    22 	    3 char_valuep		bit (1) unaligned,
  3    23 	    3 boolean_value		bit (1) unaligned,
  3    24 	    3 pad1		bit (32) unaligned,
  3    25 	  2 numeric_value		fixed bin (35),
  3    26 	  2 char_value		char (32) varying,
  3    27 	  2 code			fixed bin (35),
  3    28 	  2 pad2			bit (36);
  3    29 
  3    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  3    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  3    32 
  3    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
       26 
  4     1 /*  START OF:	dump_segment_format.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 /* Describes the output format understood by the dump_segment_ and
  4     4*   dump_segment_$return_string subroutines. */
  4     5 
  4     6 /* Created: 10/25/83 by C Spitzer */
  4     7 
  4     8 dcl dump_segment_format bit (36) based (addr (dump_segment_format_structure));
  4     9 
  4    10 dcl 1 dump_segment_format_structure aligned,		/* if = "1"b, then */
  4    11       2 address bit (1) unaligned,			/* display address part */
  4    12       2 offset bit (1) unaligned,			/* display offset part */
  4    13       2 short bit (1) unaligned,			/* format display to have 4 words per line */
  4    14       2 bcd bit (1) unaligned,			/* interpret data as BCD */
  4    15       2 ascii bit (1) unaligned,			/* interpret data as ASCII */
  4    16       2 long bit (1) unaligned,			/* format display to have 8 words per line */
  4    17       2 ebcdic9 bit (1) unaligned,			/* interpret data as EBCDIC (9 bits) */
  4    18       2 ebcdic8 bit (1) unaligned,			/* interpret data as EBCDIC (8 bits) */
  4    19       2 bit4 bit (1) unaligned,			/* interpret data as 4 bit data */
  4    20       2 hex8 bit (1) unaligned,			/* raw data is hexadecimal (8 bit) */
  4    21       2 hex9 bit (1) unaligned,			/* raw data is hexadecimal (9 bit) */
  4    22 
  4    23 /* Beginning of MR11 understood items */
  4    24 
  4    25       2 octal bit (1) unaligned,			/* raw data is octal */
  4    26       2 header bit (1) unaligned,			/* display header */
  4    27       2 raw_data bit (1) unaligned,			/* display raw data */
  4    28       2 interpreted_data bit (1) unaligned,		/* display interpreted data */
  4    29       2 suppress_duplicates bit (1) unaligned,		/* replace duplicate lines with equal signs */
  4    30       2 command_output bit (1) unaligned,		/* if returning output, return in command-type output format */
  4    31       2 mbz bit (19) unaligned;			/* future expansion */
  4    32 
  4    33 /*  END OF:	dump_segment_format.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       27 
       28 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
       29 
  6     1 /* Begin include file ..... io_call_info.incl.pl1 */
  6     2 
  6     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  6     4*   on behalf of the io_call command. */
  6     5 /* Coded April 1976 by Larry Johnson */
  6     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  6     7 
  6     8      dcl	   io_call_infop	      ptr;
  6     9 
  6    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  6    11 	     2 version	      fixed bin,
  6    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  6    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  6    14 	     2 report	      entry variable options (variable),
  6    15 						/* Entry to ioa_ like procedure to report results */
  6    16 	     2 error	      entry variable options (variable),
  6    17 						/* Entry to com_err_ like procedure to report results */
  6    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  6    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  6    20 	     2 fill	      (5) bit (36) aligned,
  6    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  6    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  6    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  6    24 
  6    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  6    26 						/* Return string for active function */
  6    27 
  6    28 /* End include file ..... io_call_info.incl.pl1 */
       30 
       31 
       32 
       33 
       34 	declare (
       35 	        Attach_data_ptr	 pointer,
       36 	        IOCB_ptr		 pointer,
       37 	        Buffer_ptr		 pointer,
       38 	        Buffer_length	 fixed bin (21),
       39 	        Info_ptr		 pointer,
       40 	        Order_name		 char (*),
       41 	        Code		 fixed bin (35),
       42 	        (New_modes, Old_modes) character (*)
       43 	        )			 parameter;
       44 
       45 	declare buffer_string	 char (Buffer_length) based (Buffer_ptr);
       46 	declare based_pointer	 pointer based;
       47 	declare iocb_ptr		 pointer;
       48 	declare 1 IOCB		 aligned like iocb based (iocb_ptr);
       49 	declare 1 binary_info	 aligned like log_output_binary_info;
       50 	declare code		 fixed bin (35);
       51 	declare dump_segment_	 entry (pointer, pointer, fixed binary, fixed binary (18), fixed binary (18),
       52 				 bit (*));
       53 	declare log_write_$data	 entry (pointer, fixed binary, character (*), pointer, fixed binary,
       54 				 character (16) var, pointer, fixed binary (35));
       55 	declare log_write_$message	 entry (pointer, fixed binary, character (*), pointer, fixed binary (35));
       56 
  7     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  7     2 
  7     3 /* Written 05/04/78 by C. D. Tavares */
  7     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  7     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  7     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  7     7 
  7     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  7     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  7    10      iox_$close entry (pointer, fixed bin (35)),
  7    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  7    12      iox_$delete_record entry (pointer, fixed bin (35)),
  7    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  7    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  7    15      iox_$err_not_attached entry options (variable),
  7    16      iox_$err_not_closed entry options (variable),
  7    17      iox_$err_no_operation entry options (variable),
  7    18      iox_$err_not_open entry options (variable),
  7    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  7    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  7    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  7    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  7    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  7    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  7    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  7    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  7    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  7    28      iox_$propagate entry (pointer),
  7    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  7    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  7    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  7    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  7    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  7    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  7    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  7    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  7    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  7    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  7    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  7    40 
  7    41 dcl (iox_$user_output,
  7    42      iox_$user_input,
  7    43      iox_$user_io,
  7    44      iox_$error_output) external static pointer;
  7    45 
  7    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
       57 
       58 
       59 	declare (
       60 	        error_table_$unimplemented_version,
       61 	        error_table_$undefined_order_request,
       62 	        error_table_$null_info_ptr
       63 	        )			 fixed bin (35) ext static;
       64 
       65 	declare addcharno		 builtin;
       66 	declare addr		 builtin;
       67 	declare addwordno		 builtin;
       68 	declare byte		 builtin;
       69 	declare divide		 builtin;
       70 	declare hbound		 builtin;
       71 	declare index		 builtin;
       72 	declare length		 builtin;
       73 	declare null		 builtin;
       74 	declare substr		 builtin;
       75 
       76 
       77 put_chars:
       78      entry (IOCB_ptr, Buffer_ptr, Buffer_length, Code);
       79 	call setup;
       80 
       81 	call process_lines;
       82 	go to return_;
       83 
       84 flush_pending_output:
       85      entry (Attach_data_ptr, Code);
       86 
       87 	attach_data_ptr = Attach_data_ptr;
       88 	if attach_data.buffer_chain.head = null ()
       89 	then return;
       90 
       91 	call process_lines$$flush;
       92 	go to return_;
       93 
       94 
       95 modes:
       96      entry (IOCB_ptr, New_modes, Old_modes, Code);
       97 	call setup;
       98 
       99 	begin options (non_quick);			/* dont buy this stack frame for put_chars */
      100 
      101 	     declare old_msi_ptr	      pointer;
      102 	     declare temp_string	      character (64);
      103 	     declare i		      fixed bin;
      104 	     declare mode_string_$parse     entry (char (*), ptr, ptr, fixed bin (35));
      105 	     declare mode_string_$get	      entry (ptr, char (*), fixed bin (35));
      106 	     declare mode_string_$combine   entry (ptr, ptr, char (*), fixed bin (35));
      107 	     declare get_system_free_area_  entry () returns (ptr);
      108 	     declare (
      109 		   error_table_$bad_mode_value,
      110 		   error_table_$bad_mode
      111 		   )		      fixed bin (35) external static;
      112 
      113 	     Old_modes = attach_data.mode_string;	/* left around from the last time */
      114 
      115 	     call mode_string_$parse (New_modes, get_system_free_area_ (), mode_string_info_ptr, code);
      116 	     if code ^= 0
      117 	     then go to return_;
      118 
      119 	     do i = 1 to hbound (mode_string_info.modes, 1);
      120 		begin;
      121 		     declare 1 MV		      aligned like mode_value defined (mode_string_info.modes (i));
      122 		     if MV.mode_name = "severity"
      123 		     then do;
      124 			     if ^MV.numeric_valuep
      125 			     then do;
      126 				     code = error_table_$bad_mode_value;
      127 				     go to return_;
      128 				end;
      129 			     attach_data.severity = MV.numeric_value;
      130 			end;
      131 		     else do;
      132 			     code = error_table_$bad_mode;
      133 			     go to return_;
      134 			end;
      135 		end;
      136 	     end;
      137 	     call mode_string_$parse ((attach_data.mode_string), get_system_free_area_ (), old_msi_ptr, (0));
      138 						/* cant be an error, if so, null ptr */
      139 	     call mode_string_$combine (old_msi_ptr, mode_string_info_ptr, temp_string, code);
      140 	     if old_msi_ptr ^= null ()
      141 	     then free old_msi_ptr -> mode_string_info;
      142 	     free mode_string_info_ptr -> mode_string_info;
      143 	     attach_data.mode_string = temp_string;
      144 	     code = 0;
      145 	     go to return_;
      146 	end;					/* the begin block */
      147 	go to return_;
      148 
      149 
      150 control:
      151      entry (IOCB_ptr, Order_name, Info_ptr, Code);
      152 
      153 	call setup;
      154 	if Order_name = "get_binary_info"
      155 	then call get_binary_info;
      156 	else if Order_name = "set_binary_info"
      157 	then call set_binary_info;
      158 	else if Order_name = "io_call"
      159 	then call io_call;
      160 	else if Order_name = "get_log_write_data_ptr"
      161 	then do;
      162 		call check_non_null;
      163 		Info_ptr -> based_pointer = attach_data.log_info_ptr;
      164 	     end;
      165 	else if Order_name = "flush_pending_output"
      166 	then call process_lines$$flush;
      167 	else code = error_table_$undefined_order_request;
      168 
      169 	goto return_;
      170 
      171 
      172 return_:
      173 	Code = code;
      174 	return;
      175 
      176 setup:
      177      procedure;
      178 	iocb_ptr = IOCB_ptr -> iocb.actual_iocb_ptr;
      179 	attach_data_ptr = IOCB.attach_data_ptr;
      180 	code = 0;
      181      end setup;
      182 
      183 process_lines:
      184      procedure;
      185 
      186 	declare nl_index		 fixed bin (21);
      187 	declare cp		 pointer;
      188 	declare cl		 fixed bin (21);
      189 	declare caller_chars	 char (cl) based (cp);
      190 
      191 	cp = addr (buffer_string);
      192 	cl = length (buffer_string);
      193 
      194 
      195 	nl_index = index (caller_chars, byte (10));	/* where is the first, (if any) newline ? */
      196 	do while (nl_index > 0);			/* this iterates here when we have written the buffer and the first NL in the new string, and there is another. */
      197 	     if attach_data.buffer_chain.head = null ()
      198 	     then do while (nl_index > 0);
      199 		     call write_line (cp, nl_index - 1);/* zero is ok here */
      200 						/* drop the NL */
      201 		     if nl_index = length (caller_chars)
      202 		     then return;			/* all done */
      203 		     cp = addcharno (cp, nl_index);
      204 		     cl = cl - nl_index;		/* skip past newline */
      205 		     nl_index = index (caller_chars, byte (10));
      206 						/* exit when this finds none */
      207 		end;
      208 
      209 	     /*** We can punt if there is no newline here at all. */
      210 
      211 	     if nl_index = 0			/* we had no new line at all, or caller fell out of loop with leftovers */
      212 	     /*** no newlines at all. Add to the chain */
      213 	     then do;
      214 		     call add_buffer (cp, cl);	/* caller_chars, whats left of them */
      215 		     return;
      216 		end;
      217 
      218 	     /*** There is a newline here, but there is pending information. 
      219*	     We must load up all the buffered data into a buffer. */
      220 
      221 	     buffer_length = attach_data.total_buffered_length + nl_index - 1;
      222 
      223 	     /*** check for overlength here */
      224 
      225 	     allocate buffer in (buffer_area);
      226 	     buffer.next = null ();
      227 	     call load_buffer_chain_into_buffer (buffer_ptr);
      228 
      229 /**** pick up first line of new text */
      230 
      231 	     if nl_index > 1
      232 	     then substr (buffer.data, buffer.length - (nl_index - 2), nl_index - 1) =
      233 		     substr (caller_chars, 1, nl_index - 1);
      234 						/* If there were a char anf an NL, the one char goes at the last char of the buffer. NL index in that case is 2 */
      235 	     call write_line (addr (buffer.data), buffer.length);
      236 	     free buffer;				/* all gone */
      237 
      238 	     if nl_index = length (caller_chars)	/* all used */
      239 	     then return;				/* exit loop without further work */
      240 
      241 	     cp = addcharno (cp, nl_index);
      242 	     cl = cl - nl_index;
      243 	     nl_index = index (caller_chars, byte (10));
      244 	end;
      245 
      246 	/*** We still have a tail to get rid of. */
      247 
      248 	call add_buffer (cp, cl);			/* buffer remainder */
      249 	return;
      250 
      251 
      252 process_lines$$flush:
      253      entry;
      254 
      255 	buffer_length = attach_data.total_buffered_length;
      256 	if buffer_length = 0
      257 	then return;
      258 	allocate buffer;
      259 	buffer.next = null ();
      260 	call load_buffer_chain_into_buffer (buffer_ptr);
      261 	call write_line (addr (buffer.data), buffer.length);
      262 	free buffer;
      263 	return;
      264 
      265 add_buffer:
      266      procedure (dp, dl);
      267 
      268 	declare dp		 pointer;
      269 	declare dl		 fixed bin (21);
      270 	declare data		 char (dl) based (dp);
      271 
      272 	if dl = 0
      273 	then return;
      274 	buffer_length = dl;
      275 	attach_data.total_buffered_length = attach_data.total_buffered_length + dl;
      276 	allocate buffer in (buffer_area);
      277 	buffer.data = data;
      278 	buffer.next = null ();
      279 	if attach_data.buffer_chain.tail ^= null ()
      280 	then attach_data.buffer_chain.tail -> buffer.next = addr (buffer);
      281 	attach_data.buffer_chain.tail = addr (buffer);
      282 	if attach_data.buffer_chain.head = null ()
      283 	then attach_data.buffer_chain.head = addr (buffer);
      284 	return;
      285      end add_buffer;
      286 
      287 load_buffer_chain_into_buffer:
      288      procedure (target_bp);
      289 
      290 	declare target_bp		 pointer;
      291 	declare cx		 fixed bin;
      292 	declare tbp		 pointer;
      293 	declare bp		 pointer;
      294 	declare nbp		 pointer;
      295 
      296 	cx = 1;
      297 	tbp = target_bp;
      298 	nbp = attach_data.buffer_chain.head;		/* THIS SIMULATES "do until", guaranteeing one trip through loop if there is anthing in the chain */
      299 	do bp = attach_data.buffer_chain.head repeat nbp while (nbp ^= null ());
      300 	     nbp = bp -> buffer.next;			/* we will free */
      301 	     substr (tbp -> buffer.data, cx, bp -> buffer.length) = bp -> buffer.data;
      302 	     cx = cx + bp -> buffer.length;
      303 	     free bp -> buffer;
      304 
      305 	end;
      306 	attach_data.total_buffered_length = 0;		/* all gone */
      307 	attach_data.buffer_chain.head, attach_data.buffer_chain.tail = null ();
      308 	return;
      309      end load_buffer_chain_into_buffer;
      310 
      311 write_line:
      312      procedure (dp, dl);
      313 
      314 	declare dp		 pointer;
      315 	declare dl		 fixed bin (21);
      316 
      317 	declare line		 char (dl) based (dp);
      318 
      319 	if attach_data.binary_data
      320 	then call log_write_$data (attach_data.log_info_ptr, attach_data.severity, line, attach_data.binary_data_ptr,
      321 		(attach_data.binary_data_length), attach_data.binary_data_class, (null ()), code);
      322 	else call log_write_$message (attach_data.log_info_ptr, attach_data.severity, line, (null ()), code);
      323 	return;
      324      end write_line;
      325      end process_lines;
      326 
      327 get_binary_info:
      328      procedure;
      329 
      330 	call check_non_null;
      331 	log_output_binary_info_ptr = Info_ptr;
      332 	if log_output_binary_info.version ^= LOG_OUTPUT_BINARY_INFO_VERSION_1
      333 	then do;
      334 		code = error_table_$unimplemented_version;
      335 		go to return_;
      336 	     end;
      337 
      338 	log_output_binary_info.data_class = attach_data.binary_data_class;
      339 	log_output_binary_info.data_ptr = attach_data.binary_data_ptr;
      340 	log_output_binary_info.data_length = attach_data.binary_data_length;
      341 	return;
      342      end get_binary_info;
      343 
      344 set_binary_info:
      345      procedure;
      346 
      347 	call check_non_null;
      348 	log_output_binary_info_ptr = Info_ptr;
      349 	if log_output_binary_info.version ^= LOG_OUTPUT_BINARY_INFO_VERSION_1
      350 	then do;
      351 		code = error_table_$unimplemented_version;
      352 		go to return_;
      353 	     end;
      354 
      355 	if attach_data.binary_data_ptr ^= null
      356 	then free binary_data;
      357 	attach_data.binary_data_class = "";
      358 	attach_data.binary_data_ptr = null ();
      359 	attach_data.binary_data = "0"b;
      360 	if log_output_binary_info.data_class = ""
      361 	then return;
      362 	attach_data.binary_data = "1"b;
      363 	attach_data.binary_data_length = log_output_binary_info.data_length;
      364 	allocate binary_data in (buffer_area) set (attach_data.binary_data_ptr);
      365 	attach_data.binary_data_class = log_output_binary_info.data_class;
      366 	binary_data = log_output_binary_info.data_ptr -> binary_data;
      367 	return;
      368      end set_binary_info;
      369 
      370 io_call:
      371      procedure;
      372 
      373 	call check_non_null;
      374 	io_call_infop = Info_ptr;
      375 
      376 	if io_call_info.order_name = "flush_pending_output"
      377 	then call process_lines$$flush;
      378 	else if io_call_info.order_name = "get_binary_info"
      379 	then do;
      380 		if attach_data.binary_data
      381 		then do;
      382 			call io_call_info.report ("Data class ^a", attach_data.binary_data_class);
      383 			dump_segment_format_structure = "0"b;
      384 			dump_segment_format_structure.offset = "1"b;
      385 			dump_segment_format_structure.ascii = "1"b;
      386 			dump_segment_format_structure.octal = "1"b;
      387 			dump_segment_format_structure.raw_data = "1"b;
      388 			dump_segment_format_structure.interpreted_data = "1"b;
      389 			dump_segment_format_structure.suppress_duplicates = "1"b;
      390 
      391 			call dump_segment_ (iox_$user_output, attach_data.binary_data_ptr, 0, 0,
      392 			     attach_data.binary_data_length, dump_segment_format);
      393 		     end;
      394 		else call io_call_info.report ("No binary info.");
      395 	     end;
      396 	else if io_call_info.order_name = "set_binary_info"
      397 	then do;
      398 		binary_info.version = LOG_OUTPUT_BINARY_INFO_VERSION_1;
      399 		if io_call_info.args (1) = "-none"
      400 		then binary_info.data_class = "";
      401 		else do;
      402 			binary_info.data_class = io_call_info.args (1);
      403 			binary_info.data_ptr = addwordno (addr (io_call_info.args (2)), 1);
      404 			binary_info.data_length = divide (length (io_call_info.args (2)), 4, 21, 0);
      405 			call iox_$control (iocb_ptr, "set_binary_info", addr (binary_info), code);
      406 		     end;
      407 	     end;
      408 	else code = error_table_$undefined_order_request;
      409 	go to return_;
      410      end io_call;
      411 
      412 check_non_null:
      413      procedure;
      414 
      415 	if Info_ptr = null ()
      416 	then do;
      417 		code = error_table_$null_info_ptr;
      418 		go to return_;
      419 	     end;
      420 	return;
      421      end check_non_null;
      422 
      423      end log_output_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/11/85  0957.3  log_output_io_.pl1                >spec>on>41-16>log_output_io_.pl1
23           1    01/21/85  0912.2  log_output_attach_data_.incl.pl1  >ldd>include>log_output_attach_data_.incl.pl1
24           2    01/21/85  0912.3  log_output_binary_info.incl.pl1   >ldd>include>log_output_binary_info.incl.pl1
26           3    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
27           4    09/24/84  1459.2  dump_segment_format.incl.pl1      >ldd>include>dump_segment_format.incl.pl1
29           5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
30           6    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
57           7    05/23/83  0916.6  iox_entries.incl.pl1              >ldd>include>iox_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Attach_data_ptr                        parameter       pointer                  dcl 34 ref 84 87
Buffer_length                          parameter       fixed bin(21,0)          dcl 34 ref 77 191 192
Buffer_ptr                             parameter       pointer                  dcl 34 ref 77 191 192
Code                                   parameter       fixed bin(35,0)          dcl 34 set ref 77 84 95 150 172*
IOCB                                   based           structure                level 1 dcl 48
IOCB_ptr                               parameter       pointer                  dcl 34 ref 77 95 150 178
Info_ptr                               parameter       pointer                  dcl 34 ref 150 163 331 348 374 415
LOG_OUTPUT_BINARY_INFO_VERSION_1
                                000000 constant        char(8)                  initial unaligned dcl 2-11 ref 332 349 398
MV                                     defined         structure                level 1 dcl 121
New_modes                              parameter       char                     unaligned dcl 34 set ref 95 115*
Old_modes                              parameter       char                     unaligned dcl 34 set ref 95 113*
Order_name                             parameter       char                     unaligned dcl 34 ref 150 154 156 158 160 165
actual_iocb_ptr          12            based           pointer                  level 2 dcl 5-6 ref 178
addcharno                                              builtin function         dcl 65 ref 203 241
addr                                                   builtin function         dcl 66 ref 191 235 235 261 261 279 281 282 391 403
                                                                                  405 405
addwordno                                              builtin function         dcl 67 ref 403
args                     44            based           varying char             array level 2 dcl 6-10 set ref 399 402 403 404
ascii                     0(04) 000112 automatic       bit(1)                   level 2 packed unaligned dcl 4-10 set ref 385*
attach_data                            based           structure                level 1 dcl 1-7
attach_data_ptr          16            based           pointer                  level 2 in structure "IOCB" dcl 48 in procedure
                                                                                  "log_output_io_" ref 179
attach_data_ptr                 000100 automatic       pointer                  dcl 1-6 in procedure "log_output_io_" set ref 87* 88
                                                                                  113 129 137 143 163 179* 197 221 225 255 275 275
                                                                                  276 279 279 281 282 282 298 299 306 307 307 319
                                                                                  319 319 319 319 319 322 322 338 339 340 355 355
                                                                                  355 357 358 359 362 363 364 364 364 365 366 366
                                                                                  380 382 391 391
based_pointer                          based           pointer                  dcl 46 set ref 163*
binary_data               4            based           bit(1)                   level 3 in structure "attach_data" packed unaligned
                                                                                  dcl 1-7 in procedure "log_output_io_" set ref 319
                                                                                  359* 362* 380
binary_data                            based           bit(36)                  array dcl 1-39 in procedure "log_output_io_" set ref
                                                                                  355 364 366* 366
binary_data_class       341            based           varying char(16)         level 2 dcl 1-7 set ref 319* 338 357* 365* 382*
binary_data_length      346            based           fixed bin(18,0)          level 2 dcl 1-7 set ref 319 340 355 363* 364 366
                                                                                  391*
binary_data_ptr         350            based           pointer                  level 2 dcl 1-7 set ref 319* 339 355 355 358* 364*
                                                                                  366 391*
binary_info                     000120 automatic       structure                level 1 dcl 49 set ref 405 405
bp                              000200 automatic       pointer                  dcl 293 set ref 299* 300 301 301 302 303*
buffer                                 based           structure                level 1 dcl 1-33 set ref 225 236 258 262 276 279 281
                                                                                  282 303
buffer_area                            based           area(1024)               dcl 1-30 ref 225 276 364
buffer_area_ptr         334            based           pointer                  level 2 dcl 1-7 ref 225 276 364
buffer_chain            336            based           structure                level 2 dcl 1-7
buffer_length                   000104 automatic       fixed bin(21,0)          dcl 1-32 set ref 221* 225 225 255* 256 258 258 274*
                                                                                  276 276
buffer_ptr                      000102 automatic       pointer                  dcl 1-31 set ref 225* 226 227* 231 231 235 235 235
                                                                                  236 258* 259 260* 261 261 261 262 276* 277 278 279
                                                                                  281 282
buffer_string                          based           char                     unaligned dcl 45 set ref 191 192
byte                                                   builtin function         dcl 68 ref 195 205 243
caller_chars                           based           char                     unaligned dcl 189 ref 195 201 205 231 238 243
cl                              000156 automatic       fixed bin(21,0)          dcl 188 set ref 192* 195 201 204* 204 205 214* 231
                                                                                  238 242* 242 243 248*
code                     24            defined         fixed bin(35,0)          level 2 in structure "MV" dcl 121
                                                                                  in begin block on line 120 set ref 126* 132*
code                            000133 automatic       fixed bin(35,0)          dcl 50 in procedure "log_output_io_" set ref 115*
                                                                                  116 139* 144* 167* 172 180* 319* 322* 334* 351*
                                                                                  405* 408* 417*
cp                              000154 automatic       pointer                  dcl 187 set ref 191* 195 199* 201 203* 203 205 214*
                                                                                  231 238 241* 241 243 248*
cx                              000174 automatic       fixed bin(17,0)          dcl 291 set ref 296* 301 302* 302
data                                   based           char                     unaligned dcl 270 in procedure "add_buffer" ref 277
data                      2            based           char                     level 2 in structure "buffer" packed unaligned
                                                                                  dcl 1-33 in procedure "log_output_io_" set ref
                                                                                  231* 235 235 261 261 277* 301* 301
data_class                2     000120 automatic       varying char(16)         level 2 in structure "binary_info" dcl 49
                                                                                  in procedure "log_output_io_" set ref 399* 402*
data_class                2            based           varying char(16)         level 2 in structure "log_output_binary_info"
                                                                                  dcl 2-5 in procedure "log_output_io_" set ref 338*
                                                                                  360 365
data_length              12     000120 automatic       fixed bin(18,0)          level 2 in structure "binary_info" dcl 49
                                                                                  in procedure "log_output_io_" set ref 404*
data_length              12            based           fixed bin(18,0)          level 2 in structure "log_output_binary_info"
                                                                                  dcl 2-5 in procedure "log_output_io_" set ref 340*
                                                                                  363
data_ptr                 10            based           pointer                  level 2 in structure "log_output_binary_info"
                                                                                  dcl 2-5 in procedure "log_output_io_" set ref 339*
                                                                                  366
data_ptr                 10     000120 automatic       pointer                  level 2 in structure "binary_info" dcl 49
                                                                                  in procedure "log_output_io_" set ref 403*
divide                                                 builtin function         dcl 69 ref 404
dl                                     parameter       fixed bin(21,0)          dcl 315 in procedure "write_line" ref 311 319 319
                                                                                  322 322
dl                                     parameter       fixed bin(21,0)          dcl 269 in procedure "add_buffer" ref 265 272 274
                                                                                  275 277
dp                                     parameter       pointer                  dcl 268 in procedure "add_buffer" ref 265 277
dp                                     parameter       pointer                  dcl 314 in procedure "write_line" ref 311 319 322
dump_segment_                   000010 constant        entry                    external dcl 51 ref 391
dump_segment_format                    based           bit(36)                  unaligned dcl 4-8 set ref 391*
dump_segment_format_structure   000112 automatic       structure                level 1 dcl 4-10 set ref 383* 391
error_table_$bad_mode           000040 external static fixed bin(35,0)          dcl 108 ref 132
error_table_$bad_mode_value     000036 external static fixed bin(35,0)          dcl 108 ref 126
error_table_$null_info_ptr      000026 external static fixed bin(35,0)          dcl 59 ref 417
error_table_$undefined_order_request
                                000024 external static fixed bin(35,0)          dcl 59 ref 167 408
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 59 ref 334 351
flags                     4            based           structure                level 2 in structure "attach_data" dcl 1-7
                                                                                  in procedure "log_output_io_"
flags                    11            defined         structure                level 2 in structure "MV" dcl 121
                                                                                  in begin block on line 120
get_system_free_area_           000034 constant        entry                    external dcl 107 ref 115 115 137 137
hbound                                                 builtin function         dcl 70 ref 119
head                    337            based           pointer                  level 3 dcl 1-7 set ref 88 197 282 282* 298 299 307*
i                               000122 automatic       fixed bin(17,0)          dcl 103 set ref 119* 122 124 126 129 132
index                                                  builtin function         dcl 71 ref 195 205 243
interpreted_data          0(14) 000112 automatic       bit(1)                   level 2 packed unaligned dcl 4-10 set ref 388*
io_call_info                           based           structure                level 1 dcl 6-10
io_call_infop                   000114 automatic       pointer                  dcl 6-8 set ref 374* 376 378 382 394 396 399 402 403
                                                                                  404
iocb                                   based           structure                level 1 dcl 5-6
iocb_ptr                        000116 automatic       pointer                  dcl 47 set ref 178* 179 405*
iox_$control                    000016 constant        entry                    external dcl 7-8 ref 405
iox_$user_output                000020 external static pointer                  dcl 7-41 set ref 391*
length                                                 builtin function         dcl 72 in procedure "log_output_io_" ref 192 201 238
                                                                                  404
length                                 based           fixed bin(21,0)          level 2 in structure "buffer" dcl 1-33 in procedure
                                                                                  "log_output_io_" set ref 225* 231 231 235 235 235*
                                                                                  236 258* 261 261 261* 262 276* 277 301 301 301 302
                                                                                  303
line                                   based           char                     unaligned dcl 317 set ref 319* 322*
log_info_ptr              2            based           pointer                  level 2 dcl 1-7 set ref 163 319* 322*
log_output_binary_info                 based           structure                level 1 dcl 2-5
log_output_binary_info_ptr      000106 automatic       pointer                  dcl 2-4 set ref 331* 332 338 339 340 348* 349 360
                                                                                  363 365 366
log_write_$data                 000012 constant        entry                    external dcl 53 ref 319
log_write_$message              000014 constant        entry                    external dcl 55 ref 322
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 6-10 ref 399 399 402 402 403 403 404 404
mode_name                 1            defined         char(32)                 level 2 packed unaligned dcl 121 ref 122
mode_string             312            based           varying char(64)         level 2 dcl 1-7 set ref 113 137 143*
mode_string_$combine            000032 constant        entry                    external dcl 106 ref 139
mode_string_$parse              000030 constant        entry                    external dcl 104 ref 115 137
mode_string_info                       based           structure                level 1 dcl 3-9 set ref 140 142
mode_string_info_ptr            000110 automatic       pointer                  dcl 3-14 set ref 115* 119 122 124 126 129 132 139*
                                                                                  142
mode_value                             based           structure                level 1 dcl 3-16
modes                     2            based           structure                array level 2 dcl 3-9 set ref 119 122 122 124 124
                                                                                  126* 126 129 129 132* 132
nbp                             000202 automatic       pointer                  dcl 294 set ref 298* 299 300* 305
next                      1            based           pointer                  level 2 packed unaligned dcl 1-33 set ref 226* 259*
                                                                                  278* 279* 300
nl_index                        000152 automatic       fixed bin(21,0)          dcl 186 set ref 195* 196 197 199 201 203 204 205*
                                                                                  211 221 231 231 231 231 238 241 242 243*
null                                                   builtin function         dcl 73 ref 88 140 197 226 259 278 279 282 299 307
                                                                                  319 322 355 358 415
number                    1            based           fixed bin(17,0)          level 2 dcl 3-9 ref 119 140 142
numeric_value            12            defined         fixed bin(35,0)          level 2 dcl 121 ref 129
numeric_valuep           11(01)        defined         bit(1)                   level 3 packed unaligned dcl 121 ref 124
octal                     0(11) 000112 automatic       bit(1)                   level 2 packed unaligned dcl 4-10 set ref 386*
offset                    0(01) 000112 automatic       bit(1)                   level 2 packed unaligned dcl 4-10 set ref 384*
old_msi_ptr                     000100 automatic       pointer                  dcl 101 set ref 137* 139* 140 140
order_name               11            based           char(32)                 level 2 dcl 6-10 ref 376 378 396
raw_data                  0(13) 000112 automatic       bit(1)                   level 2 packed unaligned dcl 4-10 set ref 387*
report                   22            based           entry variable           level 2 dcl 6-10 ref 382 394
severity                  5            based           fixed bin(17,0)          level 2 dcl 1-7 set ref 129* 319* 322*
substr                                                 builtin function         dcl 74 set ref 231* 231 301*
suppress_duplicates       0(15) 000112 automatic       bit(1)                   level 2 packed unaligned dcl 4-10 set ref 389*
tail                    340            based           pointer                  level 3 dcl 1-7 set ref 279 279 281* 307*
target_bp                              parameter       pointer                  dcl 290 ref 287 297
tbp                             000176 automatic       pointer                  dcl 292 set ref 297* 301
temp_string                     000102 automatic       char(64)                 unaligned dcl 102 set ref 139* 143
total_buffered_length
                        336            based           fixed bin(21,0)          level 3 dcl 1-7 set ref 221 255 275* 275 306*
version                         000120 automatic       char(8)                  level 2 in structure "binary_info" dcl 49
                                                                                  in procedure "log_output_io_" set ref 398*
version                                based           char(8)                  level 2 in structure "log_output_binary_info"
                                                                                  dcl 2-5 in procedure "log_output_io_" ref 332 349

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
io_call_af_ret                         based           varying char             dcl 6-25
iox_$attach_loud                000000 constant        entry                    external dcl 7-8
iox_$attach_name                000000 constant        entry                    external dcl 7-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 7-8
iox_$close                      000000 constant        entry                    external dcl 7-8
iox_$close_file                 000000 constant        entry                    external dcl 7-8
iox_$delete_record              000000 constant        entry                    external dcl 7-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 7-8
iox_$detach                     000000 constant        entry                    external dcl 7-8
iox_$detach_iocb                000000 constant        entry                    external dcl 7-8
iox_$err_no_operation           000000 constant        entry                    external dcl 7-8
iox_$err_not_attached           000000 constant        entry                    external dcl 7-8
iox_$err_not_closed             000000 constant        entry                    external dcl 7-8
iox_$err_not_open               000000 constant        entry                    external dcl 7-8
iox_$error_output                      external static pointer                  dcl 7-41
iox_$find_iocb                  000000 constant        entry                    external dcl 7-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 7-8
iox_$get_chars                  000000 constant        entry                    external dcl 7-8
iox_$get_line                   000000 constant        entry                    external dcl 7-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51
iox_$look_iocb                  000000 constant        entry                    external dcl 7-8
iox_$modes                      000000 constant        entry                    external dcl 7-8
iox_$move_attach                000000 constant        entry                    external dcl 7-8
iox_$open                       000000 constant        entry                    external dcl 7-8
iox_$open_file                  000000 constant        entry                    external dcl 7-8
iox_$position                   000000 constant        entry                    external dcl 7-8
iox_$propagate                  000000 constant        entry                    external dcl 7-8
iox_$put_chars                  000000 constant        entry                    external dcl 7-8
iox_$read_key                   000000 constant        entry                    external dcl 7-8
iox_$read_length                000000 constant        entry                    external dcl 7-8
iox_$read_record                000000 constant        entry                    external dcl 7-8
iox_$rewrite_record             000000 constant        entry                    external dcl 7-8
iox_$seek_key                   000000 constant        entry                    external dcl 7-8
iox_$user_input                        external static pointer                  dcl 7-41
iox_$user_io                           external static pointer                  dcl 7-41
iox_$write_record               000000 constant        entry                    external dcl 7-8
mode_string_$get                000000 constant        entry                    external dcl 105
mode_string_info_version_2             internal static fixed bin(17,0)          initial dcl 3-30
mode_value_ptr                         automatic       pointer                  dcl 3-6
mode_value_version_3                   internal static fixed bin(17,0)          initial dcl 3-30
number_of_modes                        automatic       fixed bin(17,0)          dcl 3-6

NAMES DECLARED BY EXPLICIT CONTEXT.
add_buffer                      001051 constant        entry                    internal dcl 265 ref 214 248
check_non_null                  001743 constant        entry                    internal dcl 412 ref 162 330 347 373
control                         000463 constant        entry                    external dcl 150
flush_pending_output            000116 constant        entry                    external dcl 84
get_binary_info                 001320 constant        entry                    internal dcl 327 ref 154
io_call                         001443 constant        entry                    internal dcl 370 ref 158
load_buffer_chain_into_buffer   001123 constant        entry                    internal dcl 287 ref 227 260
log_output_io_                  000064 constant        entry                    external dcl 19
modes                           000144 constant        entry                    external dcl 95
process_lines                   000571 constant        entry                    internal dcl 183 ref 81
process_lines$$flush            001004 constant        entry                    internal dcl 252 ref 91 165 376
put_chars                       000077 constant        entry                    external dcl 77
return_                         000554 constant        label                    dcl 172 ref 82 92 116 127 133 145 147 169 335 352
                                                                                  409 418
set_binary_info                 001351 constant        entry                    internal dcl 344 ref 156
setup                           000557 constant        entry                    internal dcl 176 ref 79 97 153
write_line                      001176 constant        entry                    internal dcl 311 ref 199 235 261

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2240        2302    2021        2250
Length      2642    2021        42         323     216           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
log_output_io_                      268 external procedure  is an external procedure.  
begin block on line 99              113 begin block         is declared options(non_quick).  
begin block on line 120                 begin block         shares stack frame of begin block on line 99.  
setup                                   internal procedure  shares stack frame of external procedure log_output_io_.  
process_lines                           internal procedure  shares stack frame of external procedure log_output_io_.  
add_buffer                              internal procedure  shares stack frame of external procedure log_output_io_.  
load_buffer_chain_into_buffer           internal procedure  shares stack frame of external procedure log_output_io_.  
write_line                              internal procedure  shares stack frame of external procedure log_output_io_.  
get_binary_info                         internal procedure  shares stack frame of external procedure log_output_io_.  
set_binary_info                         internal procedure  shares stack frame of external procedure log_output_io_.  
io_call                                 internal procedure  shares stack frame of external procedure log_output_io_.  
check_non_null                          internal procedure  shares stack frame of external procedure log_output_io_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 99   000100 old_msi_ptr                 begin block on line 99
                         000102 temp_string                 begin block on line 99
                         000122 i                           begin block on line 99
log_output_io_           000100 attach_data_ptr             log_output_io_
                         000102 buffer_ptr                  log_output_io_
                         000104 buffer_length               log_output_io_
                         000106 log_output_binary_info_ptr  log_output_io_
                         000110 mode_string_info_ptr        log_output_io_
                         000112 dump_segment_format_structure
                                                            log_output_io_
                         000114 io_call_infop               log_output_io_
                         000116 iocb_ptr                    log_output_io_
                         000120 binary_info                 log_output_io_
                         000133 code                        log_output_io_
                         000152 nl_index                    process_lines
                         000154 cp                          process_lines
                         000156 cl                          process_lines
                         000174 cx                          load_buffer_chain_into_buffer
                         000176 tbp                         load_buffer_chain_into_buffer
                         000200 bp                          load_buffer_chain_into_buffer
                         000202 nbp                         load_buffer_chain_into_buffer

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            enter_begin         call_var_desc       call_ext_out_desc   call_ext_out        return
tra_ext             shorten_stack       ext_entry           ext_entry_desc      alloc_based         alloc_based_storage
free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dump_segment_                 get_system_free_area_         iox_$control                  log_write_$data
log_write_$message            mode_string_$combine          mode_string_$parse

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mode         error_table_$bad_mode_value   error_table_$null_info_ptr
error_table_$undefined_order_request                        error_table_$unimplemented_version
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     19 000063        77 000071        79 000107        81 000110        82 000111        84 000112        87 000126
     88 000132        91 000135        92 000136        95 000137        97 000167        99 000170       113 000173
    115 000204       116 000242       119 000250       122 000261       124 000273       126 000276       127 000302
    129 000305       130 000311       132 000312       133 000316       136 000321       137 000323       139 000373
    140 000421       142 000433       143 000442       144 000451       145 000452       147 000455       150 000456
    153 000501       154 000502       156 000513       158 000521       160 000527       162 000533       163 000534
    164 000541       165 000542       167 000550       169 000553       172 000554       174 000556       176 000557
    178 000560       179 000565       180 000567       181 000570       183 000571       191 000572       192 000576
    195 000600       196 000615       197 000620       199 000626       201 000632       203 000636       204 000641
    205 000643       207 000660       211 000661       214 000663       215 000665       221 000666       225 000672
    226 000705       227 000707       231 000711       235 000731       236 000744       238 000752       241 000756
    242 000761       243 000763       244 001000       248 001001       249 001003       252 001004       255 001005
    256 001010       258 001012       259 001023       260 001025       261 001027       262 001042       263 001050
    265 001051       272 001053       274 001056       275 001057       276 001061       277 001074       278 001103
    279 001105       281 001114       282 001116       284 001122       287 001123       296 001125       297 001127
    298 001132       299 001135       300 001144       301 001147       302 001156       303 001160       305 001165
    306 001170       307 001172       308 001175       311 001176       319 001200       322 001260       323 001317
    327 001320       330 001321       331 001322       332 001326       334 001332       335 001335       338 001336
    339 001344       340 001346       341 001350       344 001351       347 001352       348 001353       349 001357
    351 001363       352 001366       355 001367       357 001376       358 001400       359 001402       360 001404
    362 001413       363 001415       364 001417       365 001426       366 001434       367 001442       370 001443
    373 001444       374 001445       376 001451       378 001457       380 001463       382 001467       383 001507
    384 001553       385 001555       386 001557       387 001561       388 001563       389 001565       391 001567
    393 001625       394 001626       395 001642       396 001643       398 001647       399 001651       402 001660
    403 001670       404 001700       405 001703       407 001736       408 001737       409 001742       412 001743
    415 001744       417 001751       418 001754       420 001755


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
