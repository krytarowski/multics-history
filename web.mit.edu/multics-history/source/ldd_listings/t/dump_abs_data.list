	COMPILATION LISTING OF SEGMENT dump_abs_data
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/12/82  1259.7 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* DUMP_ABS_DATA - Program to dump >sc1>absentee_data
       12*   Written 751022 by PG
       13*   Modified by T. Casey, May 1978, to dump resource list information.
       14*   Modified by T. Casey, November 1978 for MR7.0 absentee enhancements.
       15*   Modified by T. Casey, June 1981, for MR9.0, to dump version 2 abs_data structure.
       16**/
       17 
       18 dump_abs_data:
       19      procedure;
       20 
       21 /* automatic */
       22 
       23 declare (adp, arg_ptr) ptr,
       24         (aix, argno, n, queuex) fixed bin,
       25          arg_len fixed bin (21),
       26          code fixed bin (35),
       27          date_time char (24),
       28          dname char (168),
       29          ename char (32),
       30          line char (136) varying,
       31          long bit (1) aligned;
       32 
       33 dcl  fq fixed bin init (-1);
       34 dcl  lq fixed bin init (4);
       35 
       36 /* based */
       37 
       38 declare  arg_string char (arg_len) based (arg_ptr);
       39 
       40 /* builtins */
       41 
       42 declare (addr, length, null, substr, unspec) builtin;
       43 
       44 /* conditions */
       45 
       46 declare  cleanup condition;
       47 
       48 /* pictures */
       49 
       50 declare  five_digits picture "zzzz9";
       51 
       52 /* internal static */
       53 
       54 declare  my_name char (13) internal static initial ("dump_abs_data");
       55 
       56 dcl  lc_reasons (0:3) char (16) int static options (constant) init (
       57      "zero",
       58      "user_limit",
       59      "project_limit",
       60      "group_limit");
       61 
       62 /* external static */
       63 
       64 dcl  error_table_$badopt ext fixed bin (35);
       65 
       66 /* entries */
       67 
       68 declare  clock_ entry () returns (fixed bin (71)),
       69          com_err_ entry options (variable),
       70          cv_dec_check_ entry (char (*) aligned, fixed bin (35)) returns (fixed bin (35)),
       71          cu_$arg_count entry returns (fixed bin),
       72          cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       73          date_time_ entry (fixed bin (71), char (*)),
       74          expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
       75          hcs_$initiate entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35)),
       76          hcs_$terminate_noname entry (ptr, fixed bin (35)),
       77          ioa_ entry options (variable);
       78 dcl  request_id_ entry (fixed bin (71)) returns (char (19));
       79 
       80 /* include files */
       81 
  1     1 /* BEGIN INCLUDE FILE abs_data.incl.pl1 */
  1     2 
  1     3 /* Absentee data is an array of entries that are threaded into a number of
  1     4*   different lists. The skip list is the only "real" list, in the sense that all
  1     5*   non-free entries are threaded into it, and the other lists (the defer, ready, cputime,
  1     6*   lc, and resource lists) each consist of subsets of the skip list. (The free list
  1     7*   does not count, as far as the logic goes, since it is just a list of free array
  1     8*   entries that can be used when a new entry is to be added to the skip list. If
  1     9*   there are no free entries, a new one is made at the end of the array.)
  1    10*
  1    11*   The skip, cputime, and readys are actually sixs, one per queue. The defer
  1    12*   list contains requests from all six queues, ordered by their deferred times. When
  1    13*   a deferred request reaches the head of the defer list, and then its time arrives,
  1    14*   it is moved to the tail of the ready list for its queue. Then it is marked as to
  1    15*   be run after the request which is currently at the end of its queue. The
  1    16*   intention is that when a request's deferred time arrives, it will be treated as
  1    17*   if it had just been entered. Requests in the ready list are ordered by their
  1    18*   deferred time, so when a request is found whose "position" in the queue (i.e.,
  1    19*   the job it must be run after) has not yet reached the head of the queue, it
  1    20*   is known that none after it can be run either. A request that is deferred indefinitely
  1    21*   is placed at the end of the defer list, and when the operator releases it, it is
  1    22*   moved into the ready list as if its time had just arrived.
  1    23*
  1    24*   The resource list, although logically a separate list, is implemented as the
  1    25*   first part of the ready list, so the two can be searched as one continuous
  1    26*   list. It contains requests waiting for resource reservations. They are ordered
  1    27*   by their original queue positions, and they are each free to run as soon as
  1    28*   their required resources become available. A request refused login by load control
  1    29*   is waiting for a "resource" - namely a free slot in its load control group.
  1    30*   Thus it is held in the resource list.
  1    31*
  1    32*   Requests in the cputime list are deferred because their cpu time limits are higher
  1    33*   than their queue's max limit for the current shift. These requests are ordered by
  1    34*   their original queue positions. Whenever the max limit for any queue is raised,
  1    35*   the cputime list for that queue is scanned from the beginning for requests that
  1    36*   can now be run, and those requests are run before any more requests are taken
  1    37*   from the queue.
  1    38*
  1    39*   Requests in the skip list but in none of the others are jobs that are running
  1    40*   now, and should be deleted from the queue after they log out.
  1    41*
  1    42*   The run list is the first part of the skip list. It exists so that jobs started by
  1    43*   the abs run operator command can have skip list entries. Such jobs can not be put
  1    44*   at the tail of the skip list, because they have been taken from an arbitrary spot
  1    45*   in the queue, for immediate running, and the last skip list entry serves as an
  1    46*   indicator of where in the queue to read the next job from.
  1    47*
  1    48*   The load control list (lc list) is a single list (i.e., not one per queue),
  1    49*   made up of entries that are on the resource list for some queue. Entries
  1    50*   are placed in this list when they are deferred by load control. The purpose of this
  1    51*   list is to remember what users, projects, and groups are having their jobs deferred
  1    52*   by load control, so we can avoid trying to log in other jobs from the same
  1    53*   users, projects, or groups, when it is certian that they will also be deferred.
  1    54*   This list is built up as we try to find a job that can log in, and it is
  1    55*   destroyed just before we go blocked with no more work to do; it is NOT
  1    56*   destroyed when we go blocked with more work to do, after sending ourselves
  1    57*   an "aum_ctl" wakeup.
  1    58*
  1    59*   This segment is maintained by absentee_utility_ and dumped by dump_abs_data.
  1    60*
  1    61*   The padding is deliberately arranged to make the header 100 octal words long,
  1    62*   and each entry 40 octal words long, for convenient reading of octal dumps.
  1    63*
  1    64*   The segment is truncated and rebuilt at each answering service startup,
  1    65*   so there is no need to maintain compatibility with old versions of the structure.
  1    66*
  1    67*   Modified by T. Casey, May 1978, for resource reservations.
  1    68*   Modified by T. Casey, November 1978, for MR7.0, adding cputime list, and queues zero and foreground.
  1    69*   Modified by T. Casey, April 1979, for MR7.0a, to add deferral_logged bit.
  1    70*   Modified by T. Casey, June 1981, for MR9.0, to add group, person, project, and lc list variables.
  1    71*
  1    72**/
  1    73 
  1    74 dcl  ABS_DATA_version_2 fixed bin int static options (constant) init (2); /* version number of this declaration */
  1    75 
  1    76 dcl 1 absentee_data aligned based (adp),		/* template of internal storage area */
  1    77 						/* adp is declared (static or automatic) by users of this file */
  1    78 
  1    79     2 version fixed bin,				/* version of this structure */
  1    80     2 last fixed bin,				/* current number of entries */
  1    81     2 tail_free fixed bin,				/* index of last free entry - if zero no free entry */
  1    82     2 head_defer fixed bin,				/* index of first deferred request */
  1    83     2 tail_defer fixed bin,				/* index of last deferred request */
  1    84     2 head_lc fixed bin,				/* index of first entry on lc list */
  1    85     2 tail_lc fixed bin,				/* index of last entry on lc list */
  1    86     2 rebuilding bit (1) unaligned,			/* on if lists being rebuilt following loop in list search */
  1    87     2 asd_pad1 bit (35) unaligned,
  1    88     2 last_rsc (-1:4) fixed bin,			/* to detect when one pass thru resource list is done */
  1    89     2 asd_pad2 (2) fixed bin,				/* pad to end of 2nd 8-word block */
  1    90 						/* begin 6-element array of 8-word blocks */
  1    91     2 queue_data (-1:4) aligned,
  1    92       3 head_ready fixed bin,				/* index of first ready request in queue */
  1    93       3 tail_ready fixed bin,				/* ........ last ready ................. */
  1    94       3 head_skip fixed bin,
  1    95       3 tail_skip fixed bin,				/* ........ last skip .................. */
  1    96       3 tail_run fixed bin,
  1    97       3 tail_resource fixed bin,
  1    98       3 head_cput fixed bin,
  1    99       3 tail_cput fixed bin,
  1   100 
  1   101 /* end of 8th 8-word block - the header is 64 words long and the entries begin at 100 octal */
  1   102 
  1   103     2 entry (0 refer (absentee_data.last)) aligned like abs_info; /* entries are 32 words long (40 octal) */
  1   104 
  1   105 dcl  aip ptr init (null);
  1   106 
  1   107 dcl 1 abs_info aligned based (aip),			/* description of each entry */
  1   108     2 next_skip fixed bin,
  1   109     2 prev_skip fixed bin,
  1   110     2 next_defer fixed bin,
  1   111     2 prev_defer fixed bin,
  1   112     2 next_ready fixed bin,
  1   113     2 prev_ready fixed bin,
  1   114     2 next_cput fixed bin,
  1   115     2 prev_cput fixed bin,
  1   116 
  1   117 /* 10 octal */
  1   118     2 prev_free fixed bin,				/* index of previous free entry in free list */
  1   119     2 queue fixed bin,
  1   120     2 switches,
  1   121       3 can_run bit (1) unaligned,			/* part of ready list - if on can run */
  1   122       3 waiting_for_resources bit (1) unaligned,		/* part of resource list */
  1   123       3 waiting_for_load_ctl bit (1) unaligned,
  1   124       3 free_list bit (1) unaligned,
  1   125       3 skip_list bit (1) unaligned,
  1   126       3 defer_list bit (1) unaligned,
  1   127       3 ready_list bit (1) unaligned,
  1   128       3 resource_list bit (1) unaligned,
  1   129       3 cput_list bit (1) unaligned,
  1   130       3 run_list bit (1) unaligned,
  1   131       3 deferral_notified bit (1) unaligned,
  1   132       3 deferral_logged bit (1) unaligned,
  1   133       3 lc_list bit (1) unaligned,			/* entry is in lc list */
  1   134     2 lc_reason fixed bin (2) unsigned unaligned,		/* 1=user limit; 2=project limit; 3=group limit */
  1   135     2 asd_pad3 bit (21) unaligned,
  1   136     2 cpu_limit fixed bin,				/* time limit, if on cput list */
  1   137     2 time fixed bin (71),				/* part of defer list - deferred time */
  1   138     2 message_id bit (72) aligned,			/* id of this request in the queue message segment */
  1   139 
  1   140 /* 20 octal */
  1   141     2 last_message_id bit (72) aligned,			/* request which must be run before this request can */
  1   142     2 request_id fixed bin (71),			/* request id of this request */
  1   143     2 group char (8),
  1   144     2 prev_lc fixed bin,				/* index of previous entry on load control (lc) list */
  1   145     2 next_lc fixed bin,				/* index of next entry on lc list */
  1   146 
  1   147 /* 30 octal */
  1   148     2 person char (22) unaligned,
  1   149     2 asd_pad4 char (1) unaligned,
  1   150     2 project char (9) unaligned;
  1   151 						/* an entry is 40 octal words long */
  1   152 
  1   153 /* END INCLUDE FILE ... abs_data.incl.pl1 */
       82 
       83 
       84 /* program */
       85 
       86 	long = "0"b;
       87 	dname = ">system_control_1";
       88 	ename = "absentee_data";
       89 	adp = null;
       90 
       91 	do argno = 1 to cu_$arg_count ();
       92 	     call cu_$arg_ptr (argno, arg_ptr, arg_len, code);
       93 	     if code = 0 then do;
       94 		if arg_string = "-lg" | arg_string = "-long" then
       95 		     long = "1"b;
       96 		else if arg_string = "-q" | arg_string = "-queue" then do;
       97 		     argno = argno + 1;
       98 		     call cu_$arg_ptr (argno, arg_ptr, arg_len, code);
       99 		     if code ^= 0 then do;
      100 			call com_err_ (code, my_name, "after -queue");
      101 			return;
      102 		     end;
      103 		     if arg_string = "fg" | arg_string = "foreground" then fq, lq = -1;
      104 		     else fq, lq = cv_dec_check_ ((arg_string), code);
      105 		     if code ^= 0 then do;
      106 badq:			call com_err_ (0, my_name, "Illegal queue number: ""^a""", arg_string);
      107 			return;
      108 		     end;
      109 		     if fq < -1 | fq > 4 then goto badq;
      110 		end;
      111 		else if substr (arg_string, 1, 1) = "-" then do;
      112 		     call com_err_ (error_table_$badopt, my_name, "^a", arg_string);
      113 		     return;
      114 		end;
      115 		else do;
      116 		     call expand_pathname_ (arg_string, dname, ename, code);
      117 		     if code ^= 0 then do;
      118 			call com_err_ (code, my_name, "^a", arg_string);
      119 			return;
      120 		     end;
      121 		end;
      122 	     end;
      123 	     else call com_err_ (code, my_name);
      124 	end;					/* end loop through args */
      125 
      126 	on cleanup call clean_up;
      127 
      128 	call hcs_$initiate (dname, ename, "", 0, 1, adp, code);
      129 	if adp = null then do;
      130 	     call com_err_ (code, my_name, "^a>^a", dname, ename);
      131 	     return;
      132 	end;
      133 
      134 	if absentee_data.version ^= ABS_DATA_version_2 then do; /* check for wrong version */
      135 	     call com_err_ (0, my_name, "Incorrect structure version (^d) in ^a>^a", absentee_data.version, dname, ename);
      136 	     return;
      137 	end;
      138 
      139 	call date_time_ (clock_ (), date_time);
      140 	call ioa_ ("^/Dump of ^a>^a - ^a^/", dname, ename, date_time);
      141 
      142 	call ioa_ ("last:^21t^d", absentee_data.last);
      143 	line = "
      144 FREE LIST:  ";
      145 	do n = absentee_data.tail_free repeat (abs_info.prev_free) while (n ^= 0);
      146 	     aip = addr (absentee_data.entry (n));
      147 	     five_digits = n;
      148 	     if length (line) > 70
      149 	     then do;
      150 		call ioa_ (line);
      151 		line = (18)" ";
      152 	     end;
      153 	     line = line || five_digits;
      154 	end;
      155 
      156 	if length (line) > length (" FREE LIST:  ")
      157 	then call ioa_ (line);
      158 
      159 	do queuex = fq to lq;
      160 	     call ioa_ ("^/QUEUE ^d", queuex);
      161 
      162 	     line = "      SKIP LIST: ";
      163 	     do n = absentee_data.queue_data (queuex).head_skip repeat (abs_info.next_skip)
      164 		     while (n ^= 0);
      165 
      166 		aip = addr (absentee_data.entry (n));
      167 		five_digits = n;
      168 		if length (line) > 70
      169 		then do;
      170 		     call ioa_ (line);
      171 		     line = (17)" ";
      172 		end;
      173 		line = line || five_digits;
      174 	     end;
      175 
      176 	     if length (line) > length ("      SKIP LIST: ")
      177 	     then call ioa_ (line);
      178 
      179 	     if absentee_data.queue_data (queuex).tail_run ^= 0 then
      180 		call ioa_ ("^2xTAIL RUN:^21t^d", absentee_data.queue_data (queuex).tail_run);
      181 
      182 	     line = "     READY LIST: ";
      183 	     do n = absentee_data.queue_data (queuex).head_ready repeat (abs_info.next_ready)
      184 		     while (n ^= 0);
      185 
      186 		aip = addr (absentee_data.entry (n));
      187 		five_digits = n;
      188 		if length (line) > 70
      189 		then do;
      190 		     call ioa_ (line);
      191 		     line = (17)" ";
      192 		end;
      193 		line = line || five_digits;
      194 	     end;
      195 
      196 	     if length (line) > length ("     READY LIST: ")
      197 	     then call ioa_ (line);
      198 
      199 	     if absentee_data.queue_data (queuex).tail_resource ^= 0 then
      200 		call ioa_ ("^2xTAIL RESOURCE:^21t^d", absentee_data.queue_data (queuex).tail_resource);
      201 
      202 	     line = "     CPUT LIST: ";
      203 	     do n = absentee_data.queue_data (queuex).head_cput repeat (abs_info.next_cput)
      204 		     while (n ^= 0);
      205 
      206 		aip = addr (absentee_data.entry (n));
      207 		five_digits = n;
      208 		if length (line) > 70
      209 		then do;
      210 		     call ioa_ (line);
      211 		     line = (17)" ";
      212 		end;
      213 		line = line || five_digits;
      214 	     end;
      215 
      216 	     if length (line) > length ("     CPUT LIST: ")
      217 	     then call ioa_ (line);
      218 	end;
      219 
      220 	line = "
      221 DEFER LIST: ";
      222 	do n = absentee_data.head_defer repeat (abs_info.next_defer) while (n ^= 0);
      223 	     aip = addr (absentee_data.entry (n));
      224 	     five_digits = n;
      225 
      226 	     if length (line) > 70
      227 	     then do;
      228 		call ioa_ (line);
      229 		line = "            ";
      230 	     end;
      231 	     line = line || five_digits;
      232 	end;
      233 
      234 	if length (line) > length (" DEFER LIST: ")
      235 	then call ioa_ (line);
      236 
      237 	do aix = 1 to absentee_data.last;
      238 	     aip = addr (absentee_data.entry (aix));
      239 
      240 	     if abs_info.queue < fq | abs_info.queue > lq then /* if user specified queue, and entry is from wrong queue */
      241 		goto skip_this_entry;		/* then skip it */
      242 
      243 /* Start of future dump_entry internal procedure */
      244 
      245 	     call ioa_ ("^/ENTRY ^d", aix);
      246 	     if abs_info.free_list then
      247 		call ioa_ ("^xFREE");
      248 	     else do;
      249 		if long then do;
      250 		     call ioa_ ("next_skip:^21t^d", abs_info.next_skip);
      251 		     call ioa_ ("prev_skip:^21t^d", abs_info.prev_skip);
      252 
      253 		     if abs_info.defer_list then do;
      254 			call ioa_ ("next_defer:^21t^d", abs_info.next_defer);
      255 			call ioa_ ("prev_defer:^21t^d", abs_info.prev_defer);
      256 		     end;
      257 
      258 		     if abs_info.ready_list then do;	/* if on ready list */
      259 			call ioa_ ("next_ready:^21t^d", abs_info.next_ready);
      260 			call ioa_ ("prev_ready:^21t^d", abs_info.prev_ready);
      261 		     end;
      262 
      263 		     if abs_info.cput_list then do;
      264 			call ioa_ ("next_cput:^21t^d", abs_info.next_cput);
      265 			call ioa_ ("prev_cput:^21t^d", abs_info.prev_cput);
      266 		     end;
      267 
      268 		     if abs_info.prev_free ^= 0
      269 		     then call ioa_ ("prev_free:^21t^d", abs_info.prev_free);
      270 		end;				/* end -long */
      271 
      272 		call ioa_ ("queue:^21t^d", abs_info.queue);
      273 
      274 /* CHANGE TO "switches:    sA, sB, ... " */
      275 		if abs_info.waiting_for_resources then
      276 		     call ioa_ ("waiting_for_resources:^21tON");
      277 		if abs_info.can_run then call ioa_ ("can_run:^21tON");
      278 
      279 		if abs_info.time ^= 0 then do;
      280 		     call date_time_ (abs_info.time, date_time);
      281 		     call ioa_ ("time:^21t^a", date_time);
      282 		end;
      283 		call ioa_ ("message_id:^21t^24.3b", abs_info.message_id);
      284 		call ioa_ ("request_id:^21t^a", request_id_ (abs_info.request_id));
      285 
      286 		if abs_info.last_message_id ^= ""b
      287 		then call ioa_ ("last_message_id:^21t^24.3b", abs_info.last_message_id);
      288 
      289 		call ioa_ ("user:^21t^a.^a^[^x(^a)^]", abs_info.person, abs_info.project,
      290 		     (abs_info.group ^= ""), abs_info.group);
      291 		if abs_info.waiting_for_load_ctl then
      292 		     call ioa_ ("deferred:^21t^a", lc_reasons (abs_info.lc_reason));
      293 	     end;
      294 
      295 /* end of future dump_entry internal procedure */
      296 
      297 skip_this_entry:
      298 	end;
      299 
      300 	call ioa_ ("^/END OF ABSENTEE_DATA");
      301 
      302 	call clean_up;
      303 	return;
      304 
      305 clean_up:
      306 	procedure;
      307 
      308 	     if adp ^= null then
      309 		call hcs_$terminate_noname (adp, code);
      310 	     return;
      311 
      312 	end clean_up;
      313 
      314 /* Make a dump_entry (aix) internal procedure, from the body of text marked above.
      315*   Call it in the 1 to last loop.
      316*   Add alternative options to print the entries in a particular list, in list order.
      317*   Implement that by calling print_entry with the indices of the elements in that list.
      318*   Add options -he (= just print the header (the lists, not the entries);
      319*   .          -nhe (= don't print the header).
      320**/
      321 
      322      end dump_abs_data;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/12/82  1045.4  dump_abs_data.pl1                 >spec>on>11/12/82>dump_abs_data.pl1
82           1    07/23/81  1735.0  abs_data.incl.pl1                 >ldd>include>abs_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABS_DATA_version_2                     constant        fixed bin(17,0)          initial dcl 1-74 ref 134
abs_info                               based           structure                level 1 dcl 1-107
absentee_data                          based           structure                level 1 dcl 1-76
addr                                                   builtin function         dcl 42 ref 146 166 186 206 223 238
adp                             000100 automatic       pointer                  dcl 23 set ref 89* 128* 129 134 135 142 145 146 163
                                                                                  166 179 179 183 186 199 199 203 206 222 223 237
                                                                                  238 308 308*
aip                             000260 automatic       pointer                  initial dcl 1-105 set ref 146* 154 166* 174 186* 194
                                                                                  206* 214 223* 232 238* 240 240 246 250 251 253 254
                                                                                  255 258 259 260 263 264 265 268 268 272 275 277
                                                                                  279 280 283 284 284 286 286 289 289 289 289 291
                                                                                  291 1-105*
aix                             000104 automatic       fixed bin(17,0)          dcl 23 set ref 237* 238 245*
arg_len                         000110 automatic       fixed bin(21,0)          dcl 23 set ref 92* 94 94 96 96 98* 103 103 104 106
                                                                                  106 111 112 112 116 116 118 118
arg_ptr                         000102 automatic       pointer                  dcl 23 set ref 92* 94 94 96 96 98* 103 103 104 106
                                                                                  111 112 116 118
arg_string                             based           char                     unaligned dcl 38 set ref 94 94 96 96 103 103 104
                                                                                  106* 111 112* 116* 118*
argno                           000105 automatic       fixed bin(17,0)          dcl 23 set ref 91* 92* 97* 97 98*
can_run                  12            based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 277
cleanup                         000250 stack reference condition                dcl 46 ref 126
clock_                          000016 constant        entry                    external dcl 68 ref 139 139
code                            000111 automatic       fixed bin(35,0)          dcl 23 set ref 92* 93 98* 99 100* 104* 105 116* 117
                                                                                  118* 123* 128* 130* 308*
com_err_                        000020 constant        entry                    external dcl 68 ref 100 106 112 118 123 130 135
cput_list                12(08)        based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 263
cu_$arg_count                   000024 constant        entry                    external dcl 68 ref 91
cu_$arg_ptr                     000026 constant        entry                    external dcl 68 ref 92 98
cv_dec_check_                   000022 constant        entry                    external dcl 68 ref 104
date_time                       000112 automatic       char(24)                 unaligned dcl 23 set ref 139* 140* 280* 281*
date_time_                      000030 constant        entry                    external dcl 68 ref 139 280
defer_list               12(05)        based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 253
dname                           000120 automatic       char(168)                unaligned dcl 23 set ref 87* 116* 128* 130* 135*
                                                                                  140*
ename                           000172 automatic       char(32)                 unaligned dcl 23 set ref 88* 116* 128* 130* 135*
                                                                                  140*
entry                   100            based           structure                array level 2 dcl 1-76 set ref 146 166 186 206 223
                                                                                  238
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 64 set ref 112*
expand_pathname_                000032 constant        entry                    external dcl 68 ref 116
five_digits                     000256 automatic       picture(5)               unaligned dcl 50 set ref 147* 153 167* 173 187* 193
                                                                                  207* 213 224* 231
fq                              000246 automatic       fixed bin(17,0)          initial dcl 33 set ref 33* 103* 104* 109 109 159 240
free_list                12(03)        based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 246
group                    26            based           char(8)                  level 2 dcl 1-107 set ref 289 289*
hcs_$initiate                   000034 constant        entry                    external dcl 68 ref 128
hcs_$terminate_noname           000036 constant        entry                    external dcl 68 ref 308
head_cput                26            based           fixed bin(17,0)          array level 3 dcl 1-76 ref 203
head_defer                3            based           fixed bin(17,0)          level 2 dcl 1-76 ref 222
head_ready               20            based           fixed bin(17,0)          array level 3 dcl 1-76 ref 183
head_skip                22            based           fixed bin(17,0)          array level 3 dcl 1-76 ref 163
ioa_                            000040 constant        entry                    external dcl 68 ref 140 142 150 156 160 170 176 179
                                                                                  190 196 199 210 216 228 234 245 246 250 251 254
                                                                                  255 259 260 264 265 268 272 275 277 281 283 284
                                                                                  286 289 291 300
last                      1            based           fixed bin(17,0)          level 2 dcl 1-76 set ref 142* 237
last_message_id          22            based           bit(72)                  level 2 dcl 1-107 set ref 286 286*
lc_reason                13            based           fixed bin(2,0)           level 2 packed unsigned unaligned dcl 1-107 ref 291
lc_reasons                      000000 constant        char(16)                 initial array unaligned dcl 56 set ref 291*
length                                                 builtin function         dcl 42 ref 148 156 156 168 176 176 188 196 196 208
                                                                                  216 216 226 234 234
line                            000202 automatic       varying char(136)        dcl 23 set ref 143* 148 150* 151* 153* 153 156 156*
                                                                                  162* 168 170* 171* 173* 173 176 176* 182* 188 190*
                                                                                  191* 193* 193 196 196* 202* 208 210* 211* 213* 213
                                                                                  216 216* 220* 226 228* 229* 231* 231 234 234*
long                            000245 automatic       bit(1)                   dcl 23 set ref 86* 94* 249
lq                              000247 automatic       fixed bin(17,0)          initial dcl 34 set ref 34* 103* 104* 159 240
message_id               20            based           bit(72)                  level 2 dcl 1-107 set ref 283*
my_name                         000010 internal static char(13)                 initial unaligned dcl 54 set ref 100* 106* 112* 118*
                                                                                  123* 130* 135*
n                               000106 automatic       fixed bin(17,0)          dcl 23 set ref 145* 145* 146 147* 163* 163* 166 167*
                                                                                  183* 183* 186 187* 203* 203* 206 207* 222* 222*
                                                                                  223 224*
next_cput                 6            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 214 264*
next_defer                2            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 232 254*
next_ready                4            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 194 259*
next_skip                              based           fixed bin(17,0)          level 2 dcl 1-107 set ref 174 250*
null                                                   builtin function         dcl 42 ref 89 129 1-105 308
person                   32            based           char(22)                 level 2 packed unaligned dcl 1-107 set ref 289*
prev_cput                 7            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 265*
prev_defer                3            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 255*
prev_free                10            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 154 268 268*
prev_ready                5            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 260*
prev_skip                 1            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 251*
project                  37(27)        based           char(9)                  level 2 packed unaligned dcl 1-107 set ref 289*
queue                    11            based           fixed bin(17,0)          level 2 dcl 1-107 set ref 240 240 272*
queue_data               20            based           structure                array level 2 dcl 1-76
queuex                          000107 automatic       fixed bin(17,0)          dcl 23 set ref 159* 160* 163 179 179 183 199 199
                                                                                  203*
ready_list               12(06)        based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 258
request_id               24            based           fixed bin(71,0)          level 2 dcl 1-107 set ref 284* 284*
request_id_                     000042 constant        entry                    external dcl 78 ref 284 284
substr                                                 builtin function         dcl 42 ref 111
switches                 12            based           structure                level 2 dcl 1-107
tail_free                 2            based           fixed bin(17,0)          level 2 dcl 1-76 ref 145
tail_resource            25            based           fixed bin(17,0)          array level 3 dcl 1-76 set ref 199 199*
tail_run                 24            based           fixed bin(17,0)          array level 3 dcl 1-76 set ref 179 179*
time                     16            based           fixed bin(71,0)          level 2 dcl 1-107 set ref 279 280*
version                                based           fixed bin(17,0)          level 2 dcl 1-76 set ref 134 135*
waiting_for_load_ctl     12(02)        based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 291
waiting_for_resources
                         12(01)        based           bit(1)                   level 3 packed unaligned dcl 1-107 ref 275

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
unspec                                                 builtin function         dcl 42

NAMES DECLARED BY EXPLICIT CONTEXT.
badq                            000614 constant        label                    dcl 106 ref 109
clean_up                        003104 constant        entry                    internal dcl 305 ref 126 302
dump_abs_data                   000371 constant        entry                    external dcl 18
skip_this_entry                 003055 constant        label                    dcl 297 ref 240

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3330        3374    3146        3340
Length      3632    3146        44         222     161           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dump_abs_data                       262 external procedure  is an external procedure.  
on unit on line 126                  64 on unit               
clean_up                             70 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 my_name                     dump_abs_data

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dump_abs_data            000100 adp                         dump_abs_data
                         000102 arg_ptr                     dump_abs_data
                         000104 aix                         dump_abs_data
                         000105 argno                       dump_abs_data
                         000106 n                           dump_abs_data
                         000107 queuex                      dump_abs_data
                         000110 arg_len                     dump_abs_data
                         000111 code                        dump_abs_data
                         000112 date_time                   dump_abs_data
                         000120 dname                       dump_abs_data
                         000172 ename                       dump_abs_data
                         000202 line                        dump_abs_data
                         000245 long                        dump_abs_data
                         000246 fq                          dump_abs_data
                         000247 lq                          dump_abs_data
                         000256 five_digits                 dump_abs_data
                         000260 aip                         dump_abs_data

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 date_time_                    expand_pathname_              hcs_$initiate
hcs_$terminate_noname         ioa_                          request_id_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000370        33 000376        34 000400    1  105 000402        86 000404        87 000405        88 000410
     89 000413        91 000414        92 000427        93 000444        94 000446        96 000463        97 000473
     98 000474        99 000511       100 000513       101 000540       103 000541       104 000557       105 000611
    106 000614       107 000650       109 000651       110 000656       111 000657       112 000663       113 000715
    116 000716       117 000746       118 000750       119 001002       122 001003       123 001004       124 001021
    126 001023       128 001045       129 001110       130 001114       131 001147       134 001150       135 001153
    136 001214       139 001215       140 001241       142 001274       143 001316       145 001323       146 001330
    147 001334       148 001344       150 001347       151 001360       153 001365       154 001377       156 001403
    159 001417       160 001426       162 001450       163 001455       166 001464       167 001470       168 001500
    170 001503       171 001514       173 001521       174 001533       176 001536       179 001552       182 001601
    183 001606       186 001615       187 001621       188 001631       190 001634       191 001645       193 001652
    194 001664       196 001670       199 001704       202 001736       203 001743       206 001752       207 001756
    208 001766       210 001771       211 002002       213 002007       214 002021       216 002025       218 002041
    220 002043       222 002050       223 002055       224 002061       226 002071       228 002074       229 002105
    231 002112       232 002124       234 002130       237 002144       238 002154       240 002160       245 002165
    246 002206       249 002226       250 002230       251 002253       253 002277       254 002303       255 002323
    258 002347       259 002353       260 002373       263 002417       264 002423       265 002446       268 002472
    272 002520       275 002543       277 002563       279 002606       280 002611       281 002626       283 002647
    284 002673       286 002725       289 002752       291 003023       297 003055       300 003057       302 003076
    303 003102       305 003103       308 003111       310 003126


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
