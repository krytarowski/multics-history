	COMPILATION LISTING OF SEGMENT test_cpu
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/22/84  1115.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       10 
       11 
       12 test_cpu:
       13      proc;
       14 
       15 /* This program calls several test cases that have been known to fail at one time or another on the
       16*   various CPUs. It is assumed that they have been fixed; this program justs checks to make sure
       17*   they indeed have been.
       18*
       19*   If no arguments are specified, all tests are run.
       20*
       21*   It is assumed new tests will be added as they are developed.
       22*
       23*   Coded.		01/10/74 by S.Webber
       24*   Updated	03/27/74 by S.Webber to add mpy_ofl, test_xed, bad_fill.
       25*   Updated	3/20/76 by S.Webber to add test_cmpc_fill, extra_fill, cmpc7
       26*   Updated	3/21/76 by S.Webber to add acv_restart, scm_tally
       27*   Updated	8/27/76 by J. A. Bush to add tests 23 to 32
       28*   Updated          8/30/80 by R. L. Coppola to add tests 33 to 42
       29*   Updated          8/30/80 by R.L. Coppola to make this and associated tests
       30*   bindable.
       31*   Updated          2/24/81 by Rich Coppola to add call to save history regs
       32*   Updated          9/01/81 by Rich Coppola to add test 43, and restructure
       33*   the entire thing.
       34*   Updated          02/15/82 by Rich Fawcett to add test 44 (scm_tro).
       35*   Updated          02/25/82 by Rich Fawcett to add test 45 (rpt_test_odd).
       36*   Updated          02/25/82 by Rich Fawcett to add test 46 (rpt_test_evn)
       37*   Updated	Apr 2, 1982 by Rich Coppola to add FCO info and determine
       38*   CPU type that a test fails on.
       39*   Updated          Nov 8, 1983 by Rich Coppola to add test 47 and beef up test 43.
       40*   Updated          Oct 1984 by Rich Fawcett to add tests 48 to 52.
       41*   Updated          Oct 1984 by Rich Fawcett to call the test cases as cpu_test_$TEST_NMAE
       42**/
       43 
       44 
       45 /* Automatic */
       46 
       47 dcl  1 ACL (1) aligned,
       48        2 access_name char (32) aligned,
       49        2 modes bit (36),
       50        2 zero bit (36) init ("0"b),
       51        2 status fixed bin (35);
       52 
       53 dcl  num_sel_tests fixed bin;
       54 dcl  targ char (tc) based (tp);
       55 dcl  temp_data char (temp_data_size) based (temp_data_ptr);
       56 dcl  temp_data_ptr ptr;
       57 dcl  temp_data_size fixed bin (21);
       58 dcl  temp_words (temp_data_size) bit (36) based (temp_data_ptr);
       59 dcl  sel_list (NUM_TESTS) fixed bin;
       60 dcl  excl_list (NUM_TESTS) fixed bin;
       61 dcl  long_sw bit (1) init ("0"b);
       62 dcl  line_length fixed bin;
       63 dcl  pdir char (168) aligned;
       64 dcl  (argcount, i, j, k, next_test, start_test, last_test, num_to_cycle, num_to_repeat) fixed bin init (0);
       65 dcl  (COND, sum, RPT, SEL, CYCL) fixed bin;
       66 dcl  tries fixed bin;
       67 dcl  (hreg_ptr, stackp, faultsp, test_data1p) ptr;
       68 dcl  tmlr_ptr ptr init (null);
       69 dcl  (TERM, sel_flag, from_flag, to_flag, cycle_flag, found_arg) bit (1) init ("0"b);
       70 dcl  tp ptr;
       71 dcl  tc fixed bin;
       72 dcl  code fixed bin (35);
       73 dcl  1 akst aligned like kst_attributes;
       74 dcl  (no_display_mc, h_sw, mc_sw, no_cond, brief_sw) bit (1) init ("0"b);
       75 dcl  hreg_state bit (1) aligned;			/* state of the process hreg switch */
       76 dcl  int_cond_name char (32);
       77 dcl  pertinent_info char (100) var init ("");
       78 dcl  FCO_required char (100) var init ("");
       79 dcl  cond_infop ptr;				/* pointer to condition info */
       80 dcl  str char (j) based (tmlr_ptr);
       81 dcl  (no_write_permission, cleanup, any_other, no_read_permission, program_interrupt) condition;
       82 dcl  STR char;
       83 dcl  (null, collate, addr, addrel, baseno, char,fixed,index,length,
       84      ltrim,rtrim,substr,unspec) builtin;
       85 
       86 /* Constants */
       87 
       88 
       89 dcl  NUM_TESTS fixed bin init (52) static options (constant);
       90 
       91 /* LIST OF TEST NAMES */
       92 
       93 dcl  test_name (52) char (40) var int static options (constant)
       94 	init ("mlrstern", "tmlr", "csl_oob", "mvn", "mvn_ofl", "tct", "sreg", "csl_onc", "test_sc2", "test_ci",
       95 	"rpd_test", "mlr_tst", "csl_test", "cmpc", "bad_fill", "mpy_ofl", "test_xed", "cmpc7", "extra_fill",
       96 	"test_cmpc_fill", "acv_restart", "scm_tally", "mvt_ascii_to_bcd", "mvt_bcd_to_ascii", "mvt_nine_to_four",
       97 	"mvt_four_to_nine", "mvt_ascii_to_ebcdic", "mvt_ebcdic_to_ascii", "ci_mod_case_2", "acv_restart_csl",
       98 	"cmpn_tst", "itp_mod", "mvnoosb", "cmpb_with_sixbit_offset", "cmpb_with_rotate", "cmpc_pgbnd", "csl_pgflt",
       99 	"scm_pgflt", "scd_con_flt", "xed_dirflt_even", "xed_dirflt_odd", "cmpc_adj_len", "cmpc_zero_ind", "scm_tro",
      100 	"rpt_test_odd", "rpt_test_evn", "scd_oob_tst","cmpb_onc","cmpc_a","cmpc_b","sreg_no_write","tnz");
      101 
      102 
      103 dcl  num_temps fixed bin int static;
      104 dcl  expected_condition (5) char (32) int static init ((5) (32)"");
      105 dcl  num_expected_cond fixed bin int static;
      106 dcl  myname char (8) int static options (constant) init ("test_cpu");
      107 dcl  mvtr_sw bit (1) int static init ("0"b);
      108 
      109 dcl  tempseg_ptr (1:3) ptr int static init ((3) null);
      110 dcl  TRUNC_and_DEACT fixed bin int static init (1);
      111 dcl  DELETE fixed bin int static init (2);
      112 dcl  TRUNCATE fixed bin int static init (3);
      113 dcl  DEACT fixed bin int static init (4);
      114 
      115 
      116 /* External  */
      117 
      118 dcl  ioa_ entry options (variable);
      119 dcl  hcs_$add_acl_entries entry (char (*) aligned, char (*), ptr, fixed bin, fixed bin (35));
      120 dcl  get_group_id_ entry returns (char (32));
      121 dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
      122 dcl  hcs_$history_regs_get entry (bit (1) aligned);
      123 dcl  hcs_$history_regs_set entry (bit (1) aligned);
      124 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      125 dcl  term_$refname entry (char (*) aligned, fixed bin (35));
      126 dcl  phcs_$deactivate entry (ptr, fixed bin (35));
      127 dcl  phcs_$set_kst_attributes entry (fixed bin (35), ptr, fixed bin (35));
      128 dcl  get_pdir_ entry returns (char (168) aligned);
      129 dcl  delete_$ptr entry (ptr, bit (6) aligned, char (*), fixed bin (35));
      130 dcl  hcs_$set_max_length_seg entry (ptr, fixed bin (19), fixed bin (35));
      131 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
      132 dcl  com_err_ entry options (variable);
      133 dcl  cu_$arg_count entry returns (fixed bin);
      134 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      135 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
      136 dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
      137 dcl  continue_to_signal_ entry (fixed bin (35));
      138 dcl  find_condition_frame_ entry (ptr) returns (ptr);
      139 dcl  cu_$stack_frame_ptr entry (ptr);
      140 dcl  dump_machine_cond_ entry (ptr, ptr, char (32) aligned, fixed bin);
      141 dcl  hran_$hranl entry (ptr, ptr, bit (1));
      142 dcl  test_data1_$ ext;
      143      
      144 
      145 
      146 /* test_cpu test cases and support routines */
      147 
      148 
      149 dcl  cpu_tests_$tmlr entry (fixed bin, ptr, fixed bin, ptr);
      150 dcl  cpu_tests_$tmlr_data char (58) aligned ext;
      151 dcl  cpu_tests_$mvn entry (ptr);
      152 dcl  cpu_tests_$tct entry (ptr);
      153 dcl  cpu_tests_$mvn_ofl entry (ptr);
      154 dcl  cpu_tests_$mlrstern entry (ptr, ptr);
      155 dcl  cpu_tests_$sreg entry;
      156 dcl  cpu_tests_$csl_onc entry (ptr);
      157 dcl  cpu_tests_$test_sc2 entry (ptr);
      158 dcl  cpu_tests_$test_ci entry;
      159 dcl  cpu_tests_$rpd_test entry;
      160 dcl  cpu_tests_$mlr_tst entry (ptr);
      161 dcl  cpu_tests_$cmpc entry;
      162 dcl  cpu_tests_$csl_test entry (ptr, ptr);
      163 dcl  cpu_tests_$csl_oob entry (ptr);
      164 dcl  cpu_tests_$bad_fill entry (ptr, ptr);
      165 dcl  cpu_tests_$mpy_ofl entry;
      166 dcl  cpu_tests_$test_xed entry;
      167 dcl  cpu_tests_$cmpc7 entry (ptr);
      168 dcl  cpu_tests_$extra_fill entry (ptr);
      169 dcl  cpu_tests_$test_cmpc_fill entry;
      170 dcl  cpu_tests_$acv_restart entry (ptr);
      171 dcl  cpu_tests_$scm_tally entry (ptr);
      172 dcl  cpu_tests_$mvt_tst_ascii_to_bcd entry;
      173 dcl  cpu_tests_$mvt_tst_bcd_to_ascii entry;
      174 dcl  cpu_tests_$mvt_tst_nine_to_four entry;
      175 dcl  cpu_tests_$mvt_tst_four_to_nine entry;
      176 dcl  cpu_tests_$mvt_tst_ascii_to_ebcdic entry;
      177 dcl  cpu_tests_$mvt_tst_ebcdic_to_ascii entry;
      178 dcl  cpu_tests_$mvt_tst_release_t_segs entry;
      179 dcl  cpu_tests_$ci_mod_case_2 entry (ptr);
      180 dcl  cpu_tests_$acv_restart_csl entry (ptr);
      181 dcl  cpu_tests_$cmpn_tst entry (ptr);
      182 dcl  cpu_tests_$itp_mod entry;
      183 dcl  cpu_tests_$mvnoosb entry (ptr);
      184 dcl  cpu_tests_$cmpb_with_sixbit_offset entry (ptr);
      185 dcl  cpu_tests_$cmpb_with_rotate entry (ptr);
      186 dcl  cpu_tests_$cmpc_pgbnd entry (ptr);
      187 dcl  cpu_tests_$csl_pgflt entry (ptr);
      188 dcl  cpu_tests_$scm_pgflt entry (ptr);
      189 dcl  (cpu_tests_$scd_con_flt,
      190       cpu_tests_$sreg_no_write) entry;
      191 dcl  cpu_tests_$xed_dirflt_even entry (ptr);
      192 dcl  cpu_tests_$xed_dirflt_odd entry (ptr);
      193 dcl  cpu_tests_$cmpc_zero_ind entry (ptr);
      194 dcl  cpu_tests_$scm_tro entry (ptr);
      195 dcl  cpu_tests_$rpt_test_odd entry (ptr);
      196 dcl  cpu_tests_$rpt_test_evn entry (ptr);
      197 dcl  cpu_tests_$scd_oob_tst entry (ptr, ptr);
      198 dcl  cpu_tests_$cmpc_adj_len entry (ptr);
      199 dcl  (cpu_tests_$cmpb_onc,
      200       cpu_tests_$cmpc_a,
      201       cpu_tests_$cmpc_b,
      202       cpu_tests_$tnz) entry (ptr);
      203     
      204 
      205 
      206 
      207 
      208 
      209 dcl  1 cond_info aligned,
  1     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  1     2*	   coded by M. Weaver 12 July 1973 */
  1     3 
  1     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  1     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  1     6 	  2 condition_name char(32) var,		/* name of condition */
  1     7 	  2 infoptr ptr,				/* ptr to software info structure */
  1     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  1     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  1    10 	  2 flags aligned,
  1    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  1    12 	    3 pad1 bit(35) unal,
  1    13 	  2 pad_word bit(36) aligned,
  1    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  1    15 	  2 pad (4) bit(36) aligned;
  1    16 
  1    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      210 
      211 
      212 
      213 
  2     1 /* BEGIN INCLUDE FILE  kst_attributes.incl.pl1 WRITTEN 03/26/76  by  R. Bratt */
  2     2 
  2     3 dcl  kstap ptr;
  2     4 
  2     5 dcl 1 kst_attributes aligned based (kstap),
  2     6     2 set unaligned,				/* SPECIFIES WHICH ATTRIBUTES TO SET */
  2     7       3 (allow_write,
  2     8      tms,
  2     9      tus,
  2    10      tpd,
  2    11      audit,
  2    12      explicit_deactivate_ok) bit (1),
  2    13       3 pad bit (39),
  2    14     2 value unaligned,				/* SPECIFIES THE VALUE OF THE ATTRIBUTES TO BE SET */
  2    15       3 (allow_write,				/* allow write permission in sdw */
  2    16      tms,						/* don't update dtm */
  2    17      tus,						/* don't update dtu */
  2    18      tpd,						/* don't put on PD */
  2    19      audit,					/* audit */
  2    20      explicit_deactivate_ok) bit (1),			/* allow demand deactivation */
  2    21       3 pad bit (30);
  2    22 
  2    23 /* END INCLUDE FILE kst_attributes.incl.pl1                      */
      214 
      215 
      216 
      217 	on cleanup call CLEANUP;
      218 
      219 
      220 
      221 /* set default options */
      222 
      223 	line_length = get_line_length_$switch (null (), code);
      224 	if line_length < 132 then
      225 	     ;
      226 	else long_sw = "1"b;
      227 
      228 
      229 	call hcs_$history_regs_get (hreg_state);	/* get current state */
      230 	if ^hreg_state then /* if off, turn them on */ call hcs_$history_regs_set ("1"b);
      231 
      232 	h_sw = "0"b;				/* set display of hregs to off */
      233 	mc_sw = "0"b;				/* set display of mach cond's to off */
      234 	no_display_mc = "1"b;
      235 
      236 	test_data1p = addr (test_data1_$);
      237 	num_to_cycle, num_to_repeat, start_test = 1;
      238 	num_sel_tests, last_test = NUM_TESTS;
      239 
      240 	do i = 1 to NUM_TESTS;			/* fill in the test selection */
      241 	     sel_list (i) = i;			/* to default values */
      242 	     excl_list (i) = -1;
      243 	end;
      244 
      245 	do i = 1 to 3;				/* ensure all are nul */
      246 	     tempseg_ptr (i) = null ();
      247 	end;
      248 
      249 
      250 
      251 /* get the arguments if given and handle the test specified */
      252 
      253 
      254 
      255 	argcount = cu_$arg_count ();			/* get argument count */
      256 
      257 	do j = 1 to argcount;			/* process args */
      258 	     call cu_$arg_ptr (j, tp, tc, code);
      259 	     if code ^= 0 then do;
      260 		call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
      261 		go to BAD_ARG;
      262 		end;
      263 command_loop:
      264 	     if targ = "-from" | targ = "-fm" then do;
      265 		j = j + 1;
      266 		call cu_$arg_ptr (j, tp, tc, code);
      267 		if code ^= 0 then do;
      268 		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
      269 		     go to BAD_ARG;
      270 		     end;
      271 
      272 		start_test = cv_dec_check_ (targ, code);
      273 		from_flag = "1"b;
      274 		if code ^= 0 then do;
      275 		     do k = 1 to NUM_TESTS while (^found_arg);
      276 			if test_name (k) = targ then do;
      277 			     found_arg = "1"b;
      278 			     start_test = k;
      279 			     end;
      280 		     end;
      281 		     if ^found_arg then do;
      282 			call com_err_ (0, myname, "test (^a) not recognized", targ);
      283 			return;
      284 			end;
      285 		     end;
      286 		end;
      287 
      288 	     else if targ = "-to" then do;
      289 		to_flag = "1"b;
      290 		j = j + 1;
      291 		call cu_$arg_ptr (j, tp, tc, code);
      292 		if code ^= 0 then do;
      293 		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
      294 		     go to BAD_ARG;
      295 		     end;
      296 
      297 		last_test = cv_dec_check_ (targ, code);
      298 		if code ^= 0 then do;
      299 		     do k = 1 to NUM_TESTS while (^found_arg);
      300 			if test_name (k) = targ then do;
      301 			     found_arg = "1"b;
      302 			     last_test = k;
      303 			     end;
      304 		     end;
      305 		     if ^found_arg then do;
      306 			call com_err_ (0, myname, "test (^a) not recognized", targ);
      307 			return;
      308 			end;
      309 		     end;
      310 		end;
      311 
      312 	     else if targ = "-repeat" | targ = "-rpt" then do;
      313 		sel_flag = "1"b;
      314 		j = j + 1;
      315 		call cu_$arg_ptr (j, tp, tc, code);
      316 		if code ^= 0 then do;
      317 		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
      318 		     go to BAD_ARG;
      319 		     end;
      320 
      321 		num_to_repeat = cv_dec_check_ (targ, code);
      322 
      323 		if code ^= 0 then do;
      324 		     call com_err_ (code, (myname),
      325 			"The ""repeat"" control_arg must be followed by a decimal number, not (^a).", targ);
      326 		     go to BAD_ARG;
      327 		     end;
      328 		end;
      329 
      330 	     else if targ = "-cycle" | targ = "-cyc" then do;
      331 		j = j + 1;
      332 		cycle_flag = "1"b;
      333 		call cu_$arg_ptr (j, tp, tc, code);
      334 
      335 		if code ^= 0 then do;
      336 		     call com_err_ (0, (myname), "Invalid or unrecognized control_arg.");
      337 		     go to BAD_ARG;
      338 		     end;
      339 
      340 		num_to_cycle = cv_dec_check_ (targ, code);
      341 
      342 		if code ^= 0 then do;
      343 		     call com_err_ (code, (myname),
      344 			"The ""-cycle"" control_arg must be followed by a decimal number, not (^a).", targ);
      345 		     go to BAD_ARG;
      346 		     end;
      347 		end;
      348 
      349 	     else if targ = "-sel" | targ = "-select" | targ = "-do" then do;
      350 		sel_flag = "1"b;
      351 		j = j + 1;
      352 
      353 		num_sel_tests = 0;
      354 		do i = 1 to NUM_TESTS;		/* zip the select array */
      355 		     sel_list (i) = NUM_TESTS + 1;
      356 		end;
      357 
      358 
      359 		do j = j to argcount;
      360 		     call cu_$arg_ptr (j, tp, tc, code);
      361 		     if code ^= 0 then do;
      362 			call com_err_ (0, (myname), "bad arg in -select");
      363 			goto BAD_ARG;
      364 			end;
      365 		     if substr (targ, 1, 1) = "-" then goto command_loop;
      366 		     num_sel_tests = num_sel_tests + 1;
      367 		     sel_list (num_sel_tests) = cv_dec_check_ (targ, code);
      368 		     if code ^= 0 then do;
      369 			found_arg = "0"b;
      370 			do k = 1 to NUM_TESTS while (^found_arg);
      371 			     if test_name (k) = targ then do;
      372 				found_arg = "1"b;
      373 				sel_list (num_sel_tests) = k;
      374 				end;
      375 			end;
      376 			if ^found_arg then do;
      377 			     call com_err_ (0, myname, "test (^a) not recognized", targ);
      378 			     return;
      379 			     end;
      380 			end;
      381 		end;
      382 		end;
      383 
      384 	     else if targ = "-excl" | targ = "-exclude" then do;
      385 		j = j + 1;
      386 
      387 		do j = j to argcount;
      388 		     call cu_$arg_ptr (j, tp, tc, code);
      389 		     if code ^= 0 then do;
      390 			call com_err_ (code, (myname), "bad arg in -exclude");
      391 			goto BAD_ARG;
      392 			end;
      393 		     if substr (targ, 1, 1) = "-" then goto command_loop;
      394 
      395 		     k = cv_dec_check_ (targ, code);
      396 
      397 		     if code ^= 0 then do;
      398 			found_arg = "0"b;
      399 			do k = 1 to NUM_TESTS while (^found_arg);
      400 			     if test_name (k) = targ then do;
      401 				found_arg = "1"b;
      402 				excl_list (k) = k;
      403 				end;
      404 			end;
      405 			if ^found_arg then do;
      406 			     call com_err_ (0, myname, "test (^a) not recognized", targ);
      407 			     return;
      408 			     end;
      409 			end;
      410 
      411 		     if (k > 1) & (k ^> NUM_TESTS) then excl_list (k) = k;
      412 		end;
      413 		end;
      414 
      415 
      416 	     else if targ = "-test_names" then do;
      417 		call ioa_ ("Test Names:");
      418 		do k = 1 to NUM_TESTS;
      419 		     call ioa_ ("^3d. ^a.", k, test_name (k));
      420 		end;
      421 		return;
      422 		end;
      423 
      424 	     else if targ = "-help" then go to USAGE;
      425 
      426 
      427 	     else if targ = "-history_regs" | targ = "-hregs" then h_sw = "1"b;
      428 
      429 
      430 	     else if targ = "-machine_conditions" | targ = "-mc" then mc_sw = "1"b;
      431 
      432 	     else if targ = "-brief" | targ = "-bf" then brief_sw = "1"b;
      433 
      434 
      435 	     else if targ = "-long" | targ = "-lg" then do;
      436 						/* turn hregs and mc on */
      437 		mc_sw, h_sw = "1"b;
      438 		call hcs_$history_regs_get (hreg_state);/* get current state */
      439 		if ^hreg_state then /* if off, turn them on */ call hcs_$history_regs_set ("1"b);
      440 		end;
      441 
      442 
      443 	     else if targ = "-stop_on_failure" | targ = "-sof" then /* don't handle any conditions */ no_cond = "1"b;
      444 
      445 
      446 	     else do;
      447 		call com_err_ (0, (myname), "Invalid or unrecognizable control_arg (^a)", targ);
      448 		go to BAD_ARG;
      449 		end;
      450 
      451 
      452 	end;					/* end process args */
      453 	if (sel_flag & from_flag) | (sel_flag & to_flag) then
      454 	     if num_to_repeat = 1 then do;
      455 		call com_err_ (0, (myname), "The -select argument cannot be used with the -to or -from arguments.");
      456 		goto BAD_ARG;
      457 		end;
      458 
      459 
      460 	go to START;
      461 
      462 
      463 
      464 BAD_ARG:
      465 	call com_err_ (0, (myname), "For a list of valid control_args type 'test_cpu -help'.");
      466 	return;
      467 USAGE:
      468 	call ioa_ ("Usage: test_cpu {-control_args}");
      469 	call ioa_ ("control_args:^/     -from TEST_NUM/NAME (-fm)   -to TEST_NUM/NAME	-test_names
      470      -exclude TEST_LIST (-excl)  -stop_on_failure (-sof)	-long (lg)");
      471 	call ioa_ ("     -history_regs (-hregs)	   -machine_conditions (-mc)	-brief (-bf)
      472      -repeat COUNT (-rpt)	   -select (-sel) TEST_LIST   -cycle COUNT^/");
      473 	return;
      474 
      475 
      476 
      477 START:
      478 	if no_cond then go to start_join;
      479 
      480 	on condition (any_other)
      481 	     begin;
      482 
      483 		TERM = "0"b;
      484 		cond_infop = addr (cond_info);
      485 		call find_condition_info_ (null (), cond_infop, code);
      486 		int_cond_name = cond_info.condition_name;
      487 
      488 		if cond_info.condition_name = "cleanup"
      489 		     | /* dont bother with these */ cond_info.condition_name = "quit"
      490 		     | cond_info.condition_name = "command_error" | cond_info.condition_name = "command_question"
      491 		     | cond_info.condition_name = "linkage_error" | cond_info.condition_name = "finish" then
      492 		     go to END_COND;
      493 
      494 
      495 		do COND = 1 to num_expected_cond while (^TERM);
      496 		     if rtrim (cond_info.condition_name) = rtrim (expected_condition (COND)) then do;
      497 			call ioa_ ("^a: Test ^a failed --^a-- condition.^/^-^-^-*** HARDWARE FAILING ***", myname,
      498 			     test_name (next_test - 1), int_cond_name);
      499 
      500 			if pertinent_info ^= "" then call ioa_ ("^a: ^a", myname, pertinent_info);
      501 			if FCO_required ^= "" then call ioa_ ("^a: ^a", myname, FCO_required);
      502 
      503 
      504 			TERM = "1"b;
      505 			if ^no_display_mc then call display_mc;
      506 			if next_test > NUM_TESTS /* error in last test? */ then go to done;
      507 			if ^sel_flag then go to test (next_test);
      508 			go to sel_loop;
      509 			end;
      510 		end;
      511 
      512 
      513 /* If we get here, some fault other than the one we expected ("normal" failure)
      514*   occurred! Here it is our duty to display the MCs and Hregs whether the
      515*   user requested them or not. */
      516 
      517 
      518 		call ioa_ (
      519 		     "^a: Test ^a encountered an unexpected ^a.^/^-^-^-*** HARDWARE FAILING ***^/^-The function under test does not normally exhibit this failure."
      520 		     , myname, test_name (next_test - 1), int_cond_name);
      521 		no_display_mc = "0"b;
      522 		mc_sw, h_sw = "1"b;
      523 		call display_mc;
      524 		if next_test > NUM_TESTS then /* did last test fail */ go to done;
      525 
      526 		if ^sel_flag then go to test (next_test);
      527 		go to sel_loop;
      528 
      529 END_COND:
      530 		call continue_to_signal_ (code);
      531 
      532 	     end;					/* end cond handler */
      533 
      534 
      535 start_join:
      536 	on condition (program_interrupt)
      537 	     begin;
      538 		call ioa_ ("test_cpu: Restarting test ^d.", next_test - 1);
      539 		go to test (next_test - 1);
      540 	     end;					/* end pi handler */
      541 
      542 
      543 	if (h_sw | mc_sw) then no_display_mc = "0"b;
      544 
      545 	if from_flag = "1"b | to_flag = "1"b then do;
      546 
      547 	     if from_flag = "0"b then start_test = 1;
      548 	     if to_flag = "0"b then last_test = NUM_TESTS;
      549 	     if start_test > last_test then do;
      550 		call com_err_ (0, (myname), " -from ^d is greater then the -to ^d .", start_test, last_test);
      551 		return;
      552 		end;
      553 
      554 	     sel_flag = "1"b;
      555 
      556 	     TERM = "0"b;
      557 	     num_sel_tests = 0;
      558 	     do i = 1 to NUM_TESTS while (^TERM);
      559 		num_sel_tests = i;
      560 		sel_list (i) = start_test;
      561 		start_test = start_test + 1;
      562 		if start_test > last_test then TERM = ^TERM;
      563 	     end;
      564 	     end;
      565 
      566 	if ^sel_flag then go to test (1);		/* normal pass */
      567 
      568 	do RPT = 1 to num_to_repeat;
      569 	     do SEL = 0 to num_sel_tests - 1 while (sel_list (SEL + 1) ^> NUM_TESTS);
      570 		go to test (sel_list (SEL + 1));
      571 sel_loop:
      572 	     end;
      573 	end;
      574 
      575 	go to done;
      576 
      577 
      578 /*	TEST 1.   mlrstern     */
      579 
      580 /* This test tests a particular failure whereby the fill  character is placed as the
      581*   first character of a new page */
      582 
      583 test (1):
      584 	next_test = 2;
      585 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude1;
      586 
      587 	if ^brief_sw then call ioa_ ("Test  1^-<mlrstern>");
      588 
      589 	call set_up_conds (3, "derail,mme1,mme4",
      590 	     "Derail = MLR failed; MME1 = MLR and CMPC failed; MME4 = CMPC failed.", "");
      591 
      592 	num_temps = 1;				/* need one temp seg */
      593 	call make_tempsegs;				/* make it */
      594 	do CYCL = 1 to num_to_cycle;
      595 	     call prepare_segment (TRUNC_and_DEACT);
      596 	     call cpu_tests_$mlrstern (test_data1p, tempseg_ptr(1));
      597 	end;
      598 	call prepare_segment (DELETE);
      599 
      600 
      601 exclude1:
      602 	if sel_flag then goto sel_loop;
      603 	if next_test > last_test then goto done;
      604 
      605 
      606 
      607 
      608 /*	TEST 2.	tmlr	*/
      609 
      610 /* This test consists of calling " which in turn calls tmlr to do a MLR instruction.
      611*   If test_tmlr notices that the MLR failed it prints out a message.	*/
      612 
      613 test (2):
      614 	next_test = 3;
      615 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude2;
      616 
      617 	if ^brief_sw then call ioa_ ("Test  2^-<tmlr>");
      618 
      619 	call set_up_conds (0, "", "", "");
      620 
      621 	num_temps = 1;				/* need one temp seg */
      622 	call make_tempsegs;				/* make it */
      623 
      624 	do CYCL = 1 to num_to_cycle;
      625 	     call prepare_segment (TRUNC_and_DEACT);
      626 
      627 	     do j = 54 to 58;
      628 		do i = 0 to 4;
      629 		     call cpu_tests_$tmlr (i, tmlr_ptr, j, tempseg_ptr (1));
      630 		     if substr (cpu_tests_$tmlr_data, 1, j) ^= str then do;
      631 			call ioa_ (
      632 			     "test tmlr; strings do not match *** HARDWARE FAILING ***^/data should be:^-^a^/data is^7x^-^a^/"
      633 			     , substr (cpu_tests_$tmlr_data, 1, j), str);
      634 			end;
      635 		     call prepare_segment (DEACT);
      636 		end;
      637 	     end;
      638 	end;
      639 	call prepare_segment (DELETE);
      640 exclude2:
      641 	if sel_flag then goto sel_loop;
      642 	if next_test > last_test then goto done;
      643 
      644 
      645 
      646 
      647 /* 	TEST 3.	csl_oob	*/
      648 
      649 /* This test consists in calling the program csl_oob, failure gives us an out_of_bounds */
      650 
      651 test (3):
      652 	next_test = 4;
      653 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude3;
      654 
      655 	if ^brief_sw then call ioa_ ("Test  3^-<csl_oob>");
      656 
      657 	call set_up_conds (1, "out_of_bounds", "Key to failure is starting Bit No. in D1.", "");
      658 
      659 	num_temps = 1;				/* need one temp seg */
      660 	call make_tempsegs;				/* make it */
      661 
      662 	do CYCL = 1 to num_to_cycle;
      663 	     call prepare_segment (TRUNC_and_DEACT);
      664 	     call cpu_tests_$csl_oob (tempseg_ptr (1));
      665 	end;
      666 
      667 	call prepare_segment (DELETE);
      668 
      669 exclude3:
      670 	if sel_flag then goto sel_loop;
      671 	if next_test > last_test then goto done;
      672 
      673 
      674 
      675 
      676 
      677 /*	TEST 4.	mvn	*/
      678 
      679 /* This test consists in a call to the routine "mvn" does not fault if the hardware works. */
      680 
      681 test (4):
      682 	next_test = 5;
      683 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude4;
      684 
      685 	if ^brief_sw then call ioa_ ("Test  4^-<mvn>");
      686 
      687 	call set_up_conds (3, "derail,mme1,mme4",
      688 	     "DERAIL = MVN failed; MME1 = MVN and CMPC failed; MME4 = CMPC failed.", "");
      689 	num_temps = 1;				/* need one temp seg */
      690 	call make_tempsegs;				/* make it */
      691 
      692 	do CYCL = 1 to num_to_cycle;
      693 	     call prepare_segment (TRUNC_and_DEACT);
      694 	     call cpu_tests_$mvn (tempseg_ptr (1));
      695 	end;
      696 
      697 	call prepare_segment (DELETE);
      698 
      699 exclude4:
      700 	if sel_flag then goto sel_loop;
      701 	if next_test > last_test then goto done;
      702 
      703 
      704 
      705 
      706 /*	TEST 5.	mvn_ofl	*/
      707 
      708 /* This test checks the moving of a number which has value 0. It should not get
      709*   an overflow */
      710 
      711 test (5):
      712 	next_test = 6;
      713 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude5;
      714 
      715 	if ^brief_sw then call ioa_ ("Test  5^-<mvn_ofl>");
      716 
      717 	call set_up_conds (1, "overflow", "", "");
      718 
      719 	num_temps = 1;				/* need one temp seg */
      720 	call make_tempsegs;				/* make it */
      721 
      722 	do CYCL = 1 to num_to_cycle;
      723 	     call prepare_segment (TRUNC_and_DEACT);
      724 	     call cpu_tests_$mvn_ofl (tempseg_ptr(1));
      725 	end;
      726 
      727 	num_temps = 1;				/* need one temp seg */
      728 	call make_tempsegs;				/* make it */
      729 
      730 
      731 exclude5:
      732 	if sel_flag then goto sel_loop;
      733 	if next_test > last_test then goto done;
      734 
      735 
      736 
      737 
      738 /*	TEST 6.	tct	*/
      739 
      740 /* This test consists in a call to the routine "tct" which gets  an op_not_complete
      741*   if the hardware fails. */
      742 
      743 test (6):
      744 	next_test = 7;
      745 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude6;
      746 
      747 	if ^brief_sw then call ioa_ ("Test  6^-<tct>");
      748 
      749 	call set_up_conds (1, "op_not_complete", "", "");
      750 
      751 	num_temps = 1;				/* need one temp seg */
      752 	call make_tempsegs;				/* make it */
      753 
      754 	do CYCL = 1 to num_to_cycle;
      755 	     call prepare_segment (TRUNC_and_DEACT);
      756 	     call cpu_tests_$tct (tempseg_ptr(1));
      757 	end;
      758 
      759 	call prepare_segment (DELETE);
      760 
      761 
      762 exclude6:
      763 	if sel_flag then goto sel_loop;
      764 	if next_test > last_test then goto done;
      765 
      766 
      767 
      768 
      769 /*	TEST 7.	sreg	*/
      770 
      771 /* This test is done by calling the program sreg which has an sreg instruction as the
      772*   last instruction on a page and the next procedure page faults.
      773*
      774*   The test fails (the hardware is broken) if we get an op-not-complete. */
      775 
      776 
      777 test (7):
      778 	next_test = 8;
      779 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude7;
      780 
      781 	if ^brief_sw then call ioa_ ("Test  7^-<sreg>");
      782 
      783 	call set_up_conds (1, "op_not_complete", "", "");
      784 
      785 	num_temps = 1;				/* need one temp seg */
      786 	call make_tempsegs;				/* make it */
      787 
      788 	do CYCL = 1 to num_to_cycle;
      789 	     call cpu_tests_$sreg ();				/* run the actual test */
      790 	end;
      791 
      792 	call prepare_segment (DELETE);
      793 
      794 exclude7:
      795 	if sel_flag then goto sel_loop;
      796 	if next_test > last_test then goto done;
      797 
      798 
      799 
      800 
      801 /*	TEST 8.	csl_onc	*/
      802 
      803 /* This test consists in calling csl_onc which gets an op_not_complete if it fails. */
      804 
      805 test (8):
      806 	next_test = 9;
      807 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude8;
      808 
      809 	if ^brief_sw then call ioa_ ("Test  8^-<csl_onc>");
      810 
      811 	call set_up_conds (1, "op_not_complete", "", "");
      812 
      813 	num_temps = 1;				/* need one temp seg */
      814 	call make_tempsegs;				/* make it */
      815 
      816 	do CYCL = 1 to num_to_cycle;
      817 	     call prepare_segment (TRUNC_and_DEACT);
      818 	     call cpu_tests_$csl_onc (tempseg_ptr (1));
      819 	end;
      820 
      821 	call prepare_segment (DELETE);
      822 
      823 exclude8:
      824 	if sel_flag then goto sel_loop;
      825 	if next_test > last_test then goto done;
      826 
      827 
      828 
      829 
      830 /*	TEST 9.	test_sc2	*/
      831 
      832 /* This test checks the sequence character tag.  A ZOP fault occurs if the hardware fails. */
      833 
      834 test (9):
      835 	next_test = 10;
      836 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude9;
      837 
      838 	if ^brief_sw then call ioa_ ("Test  9^-<test_sc2>");
      839 
      840 	call set_up_conds (1, "illegal_opcode", "", "");
      841 
      842 
      843 	num_temps = 1;				/* need one temp seg */
      844 	call make_tempsegs;				/* make it */
      845 
      846 	do CYCL = 1 to num_to_cycle;
      847 	     call prepare_segment (TRUNC_and_DEACT);
      848 	     call cpu_tests_$test_sc2 (tempseg_ptr(1));
      849 	end;
      850 
      851 	call prepare_segment (DELETE);
      852 
      853 exclude9:
      854 	if sel_flag then goto sel_loop;
      855 	if next_test > last_test then goto done;
      856 
      857 
      858 
      859 
      860 /*	TEST 10.	test_ci	*/
      861 
      862 /* This test tries out a CI modifier. The test gets a ZOP fault if the hardware fails. */
      863 
      864 test (10):
      865 	next_test = 11;
      866 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude10;
      867 
      868 	if ^brief_sw then call ioa_ ("Test 10^-<test_ci>");
      869 
      870 	call set_up_conds (1, "illegal_opcode", "", "");
      871 
      872 	num_temps = 1;				/* need one temp seg */
      873 	call make_tempsegs;				/* make it */
      874 
      875 
      876 	do CYCL = 1 to num_to_cycle;
      877 	     call cpu_tests_$test_ci ();
      878 	end;
      879 
      880 	call prepare_segment (DELETE);
      881 
      882 
      883 exclude10:
      884 	if sel_flag then goto sel_loop;
      885 	if next_test > last_test then goto done;
      886 
      887 
      888 
      889 
      890 /* 	TEST 11.	rpd_test	*/
      891 
      892 /* This test tries a particluar RPD sequence that failed on Serial 7 at MIT */
      893 
      894 test (11):
      895 	next_test = 12;
      896 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude11;
      897 
      898 	if ^brief_sw then call ioa_ ("Test 11^-<rpd_test>");
      899 
      900 	call set_up_conds (1, "illegal_opcode", "", "");
      901 
      902 	num_temps = 1;				/* need one temp seg */
      903 	call make_tempsegs;				/* make it */
      904 
      905 	do CYCL = 1 to num_to_cycle;
      906 	     call cpu_tests_$rpd_test ();
      907 	end;
      908 
      909 	call prepare_segment (DELETE);
      910 
      911 exclude11:
      912 	if sel_flag then goto sel_loop;
      913 	if next_test > last_test then goto done;
      914 
      915 
      916 
      917 
      918 /*	TEST 12.	mlr_tst	*/
      919 
      920 /* This test tries a particular MLR sequence. */
      921 
      922 test (12):
      923 	next_test = 13;
      924 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude12;
      925 
      926 	if ^brief_sw then call ioa_ ("Test 12^-<mlr_tst>");
      927 
      928 	call set_up_conds (3, "derail,mme1,mme4",
      929 	     "Derail = MLR failed; MME1 = MLR and CMPC failed; MME4 = CMPC failed.", "");
      930 
      931 
      932 /* This test interacts with the bound fault mechanism. We must create anew the testcpu_tempseg(1) each time we run the
      933*   test as well as terminate the test itself */
      934 
      935 	num_temps = 1;				/* need one temp seg */
      936 	do CYCL = 1 to num_to_cycle;
      937 	     call make_tempsegs;			/* make it */
      938 	     call term_$refname ("mlr_tst", code);
      939 	     call cpu_tests_$mlr_tst (tempseg_ptr(1));
      940 	     call prepare_segment (DELETE);
      941 	end;
      942 
      943 exclude12:
      944 	if sel_flag then goto sel_loop;
      945 	if next_test > last_test then goto done;
      946 
      947 
      948 
      949 
      950 /*	TEST 13.	csl_test	*/
      951 
      952 /* This test tries a given CSL instruction which fails across a boundsfault boundary */
      953 
      954 test (13):
      955 	next_test = 14;
      956 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude13;
      957 
      958 	if ^brief_sw then call ioa_ ("Test 13^-<csl_test>");
      959 
      960 	call set_up_conds (1, "illegal_opcode", "", "");
      961 
      962 /* This test, like test 12, interacts with the boundfault mechanism. Similar things are done */
      963 	num_temps = 1;				/* need one temp seg */
      964 	do CYCL = 1 to num_to_cycle;
      965 	     call make_tempsegs;			/* make it */
      966 	     call term_$refname ("csl_test", code);
      967 	     call cpu_tests_$csl_test (test_data1p, tempseg_ptr(1));
      968 	     call prepare_segment (DELETE);
      969 	end;
      970 
      971 exclude13:
      972 	if sel_flag then goto sel_loop;
      973 	if next_test > last_test then goto done;
      974 
      975 
      976 
      977 /*	TEST 14.  cmpc	*/
      978 
      979 /* This test tries a given cmpc insruction which fails when hit with */
      980 /* a TRO or connect fault 				*/
      981 
      982 test (14):
      983 	next_test = 15;
      984 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude14;
      985 
      986 	if ^brief_sw then call ioa_ ("Test 14^-<cmpc>");
      987 
      988 	call set_up_conds (1, "illegal_opcode", "", "");
      989 	num_temps = 1;				/* need one temp seg */
      990 	call make_tempsegs;				/* make it */
      991 
      992 	do CYCL = 1 to num_to_cycle;
      993 	     call cpu_tests_$cmpc ();
      994 	end;
      995 
      996 	call prepare_segment (DELETE);
      997 
      998 exclude14:
      999 	if sel_flag then goto sel_loop;
     1000 	if next_test > last_test then go to done;
     1001 
     1002 
     1003 
     1004 /*	TEST 15.	bad_fill	*/
     1005 
     1006 /* This test checks to see if an MLR or CMPC that ends in the first 2 words of a new page
     1007*   works correctly. */
     1008 
     1009 test (15):
     1010 	next_test = 16;
     1011 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude15;
     1012 
     1013 	if ^brief_sw then call ioa_ ("Test 15^-<bad_fill>");
     1014 
     1015 	call set_up_conds (1, "illegal_opcode", "MLR generating bad fill.", "");
     1016 	num_temps = 1;				/* need one temp seg */
     1017 	call make_tempsegs;				/* make it */
     1018 
     1019 
     1020 	do CYCL = 1 to num_to_cycle;
     1021 	     call prepare_segment (TRUNC_and_DEACT);
     1022 	     call cpu_tests_$bad_fill (test_data1p, tempseg_ptr(1));
     1023 	end;
     1024 
     1025 	call prepare_segment (DELETE);
     1026 
     1027 exclude15:
     1028 	if sel_flag then goto sel_loop;
     1029 	if next_test > last_test then goto done;
     1030 
     1031 
     1032 
     1033 
     1034 /*	TEST 16.	mpy_ofl	*/
     1035 
     1036 /* This test checks to see if an overflow fault occurs when the number -2**35 is
     1037*   multiplied by itself. An overflow should not occur. */
     1038 
     1039 test (16):
     1040 	next_test = 17;
     1041 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude16;
     1042 
     1043 	if ^brief_sw then call ioa_ ("Test 16^-<mpy_ofl>");
     1044 
     1045 	call set_up_conds (1, "fixedoverflow", "", "");
     1046 
     1047 	num_temps = 1;				/* need one temp seg */
     1048 	call make_tempsegs;				/* make it */
     1049 
     1050 	do CYCL = 1 to num_to_cycle;
     1051 	     call cpu_tests_$mpy_ofl;
     1052 	end;
     1053 
     1054 	call prepare_segment (DELETE);
     1055 
     1056 
     1057 exclude16:
     1058 	if sel_flag then goto sel_loop;
     1059 	if next_test > last_test then goto done;
     1060 
     1061 
     1062 
     1063 /* 	TEST 17.	test_xed	*/
     1064 
     1065 /* This test checks a particular XED sequence which fails to do the proper indexing
     1066*   in the executed instructions. */
     1067 
     1068 test (17):
     1069 	next_test = 18;
     1070 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude17;
     1071 
     1072 	if ^brief_sw then call ioa_ ("Test 17^-<test_xed>");
     1073 
     1074 	call set_up_conds (1, "illegal_opcode", "XED did not index properly.", "");
     1075 
     1076 	num_temps = 1;				/* need one temp seg */
     1077 	call make_tempsegs;				/* make it */
     1078 
     1079 	do CYCL = 1 to num_to_cycle;
     1080 	     call cpu_tests_$test_xed;
     1081 	end;
     1082 
     1083 	call prepare_segment (DELETE);
     1084 
     1085 
     1086 exclude17:
     1087 	if sel_flag then goto sel_loop;
     1088 	if next_test > last_test then goto done;
     1089 
     1090 
     1091 
     1092 /*	TEST 18.	cmpc7	*/
     1093 
     1094 /* This test checks a particular cmpc use where both strrings are 7 words from the end of a page */
     1095 
     1096 test (18):
     1097 	next_test = 19;
     1098 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude18;
     1099 
     1100 	if ^brief_sw then call ioa_ ("Test 18^-<cmpc7>");
     1101 
     1102 	call set_up_conds (1, "illegal_opcode", "", "");
     1103 
     1104 	num_temps = 1;				/* need one temp seg */
     1105 	call make_tempsegs;				/* make it */
     1106 
     1107 	do CYCL = 1 to num_to_cycle;
     1108 	     call cpu_tests_$cmpc7 (test_data1p);
     1109 	end;
     1110 
     1111 	call prepare_segment (DELETE);
     1112 
     1113 
     1114 exclude18:
     1115 	if sel_flag then goto sel_loop;
     1116 	if next_test > last_test then goto done;
     1117 
     1118 
     1119 
     1120 /*	TEST 19.	extra_fill	*/
     1121 
     1122 /* This test checks to see if extra fill characters are placed after a string moved by an MLR which
     1123*   starts 6 words from the end of a page */
     1124 
     1125 test (19):
     1126 	next_test = 20;
     1127 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude19;
     1128 
     1129 	if ^brief_sw then call ioa_ ("Test 19^-<extra_fill>");
     1130 
     1131 	call set_up_conds (1, "illegal_opcode", "MLR causing extra fill.", "");
     1132 
     1133 	num_temps = 1;				/* need one temp seg */
     1134 	call make_tempsegs;				/* make it */
     1135 
     1136 
     1137 	do CYCL = 1 to num_to_cycle;
     1138 	     call prepare_segment (TRUNC_and_DEACT);
     1139 	     call cpu_tests_$extra_fill (tempseg_ptr(1));
     1140 	end;
     1141 
     1142 	call prepare_segment (DELETE);
     1143 
     1144 
     1145 exclude19:
     1146 	if sel_flag then goto sel_loop;
     1147 	if next_test > last_test then goto done;
     1148 
     1149 
     1150 
     1151 /* 	TEST 20.	test_cmpc_fill	*/
     1152 
     1153 /* This test checks that the fill character used in a cmpc instruction is correct */
     1154 
     1155 test (20):
     1156 	next_test = 21;
     1157 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude20;
     1158 
     1159 	if ^brief_sw then call ioa_ ("Test 20^-<test_cmpc_fill>");
     1160 
     1161 	call set_up_conds (1, "illegal_opcode", "", "");
     1162 
     1163 	num_temps = 1;				/* need one temp seg */
     1164 	call make_tempsegs;				/* make it */
     1165 
     1166 	do CYCL = 1 to num_to_cycle;
     1167 	     call cpu_tests_$test_cmpc_fill;
     1168 	end;
     1169 
     1170 	call prepare_segment (DELETE);
     1171 
     1172 
     1173 exclude20:
     1174 	if sel_flag then goto sel_loop;
     1175 	if next_test > last_test then goto done;
     1176 
     1177 
     1178 
     1179 /*	TEST 21.	acv_restart	*/
     1180 
     1181 /* This test check that the hardware can successfully restart the machine conditions after an
     1182*   access violation fault caused by a reference to data via an EIS (mlr) instruction */
     1183 
     1184 test (21):
     1185 	next_test = 22;
     1186 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude21;
     1187 
     1188 	if ^brief_sw then call ioa_ ("Test 21^-<acv_restart>");
     1189 
     1190 	num_temps = 1;				/* need one temp seg */
     1191 	call make_tempsegs;				/* make it */
     1192 
     1193 	on no_write_permission
     1194 	     begin;
     1195 		if tries > 1 then do;
     1196 		     call ioa_ ("^a (restart did not work  *** HARDWARE FAILING ***)", test_name (next_test - 1));
     1197 		     if ^no_display_mc then /* are we in brief mode? */ call display_mc;
     1198 						/* no go print out the machine conditions */
     1199 		     revert no_write_permission;
     1200 		     go to exclude21;
     1201 		     end;
     1202 		ACL.access_name = get_group_id_ ();
     1203 		ACL.modes = "101"b;
     1204 		pdir = get_pdir_ ();
     1205 		call hcs_$add_acl_entries (pdir, "testcpu_tempseg_1", addr (ACL), 1, code);
     1206 		tries = tries + 1;
     1207 	     end;
     1208 
     1209 	do CYCL = 1 to num_to_cycle;
     1210 	     tries = 0;
     1211 	     call prepare_segment (TRUNC_and_DEACT);
     1212 	     call cpu_tests_$acv_restart (tempseg_ptr(1));
     1213 	end;
     1214 
     1215 	call prepare_segment (DELETE);
     1216 
     1217 exclude21:
     1218 	revert no_write_permission;
     1219 	if sel_flag then goto sel_loop;
     1220 	if next_test > last_test then goto done;
     1221 
     1222 
     1223 
     1224 
     1225 /* 	TEST 22.	scm_tally */
     1226 
     1227 /* This test attempts to see if the SCM instruction works with the tally runout indicator being
     1228*   set correctly. The test calls a small alm program that uses an scm instruction. Sometimes the hardware
     1229*   fails -- sometimes it doesn't. Therefore the test is run 100 times to get a slight statistical
     1230*   sampling */
     1231 
     1232 test (22):
     1233 	next_test = 23;
     1234 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude22;
     1235 
     1236 	if ^brief_sw then call ioa_ ("Test 22^-<scm_tally>");
     1237 
     1238 	call set_up_conds (1, "illegal_opcode", "SCM failed to set the tally runout indicator.", "");
     1239 
     1240 	num_temps = 1;				/* need one temp seg */
     1241 	call make_tempsegs;				/* make it */
     1242 
     1243 	do CYCL = 1 to num_to_cycle;
     1244 	     sum = 0;
     1245 	     call prepare_segment (TRUNC_and_DEACT);
     1246 	     do i = 1 to 100;
     1247 		call prepare_segment (DEACT);
     1248 		call cpu_tests_$scm_tally (tempseg_ptr(1));
     1249 	     end;
     1250 	end;
     1251 
     1252 	call prepare_segment (DELETE);
     1253 
     1254 exclude22:
     1255 	if sel_flag then goto sel_loop;
     1256 	if next_test > last_test then goto done;
     1257 
     1258 
     1259 
     1260 /* test 23. mvt_ascii_to_bcd */
     1261 /*
     1262*   This test checks nine to six (ascii to bcd) conversion using the MVT instruction. A large ascii data
     1263*   segment  is  generated  and  a  subsequent  bcd segment is generated using non EIS conversion. Three
     1264*   segments are then converted from ascii to bcd, using the MVT  instruction  and  these  segments  are
     1265*   compared  to  the  known  good bcd segment. If any compare errors are detected, the contents of both
     1266*   segments are dumped in octal at the failing location.
     1267**/
     1268 
     1269 test (23):
     1270 	next_test = 24;
     1271 	mvtr_sw = "1"b;				/* set release switch */
     1272 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude23;
     1273 
     1274 	if ^brief_sw then call ioa_ ("Test 23^-<mvt_ascii_to_bcd>");
     1275 
     1276 	call set_up_conds (0, "", "", "");
     1277 	num_temps = 1;				/* need one temp seg */
     1278 	call make_tempsegs;				/* make it */
     1279 
     1280 	do CYCL = 1 to num_to_cycle;
     1281 	     call cpu_tests_$mvt_tst_ascii_to_bcd;
     1282 	end;
     1283 
     1284 	call prepare_segment (DELETE);
     1285 
     1286 exclude23:
     1287 	if sel_flag then goto sel_loop;
     1288 	if next_test > last_test then go to done;
     1289 
     1290 
     1291 
     1292 /* test 24. mvt_six_to_nine */
     1293 /*
     1294*   This test checks six to nine (bcd to ascii) conversion using the MVT instruction. A large ascii data
     1295*   segment  is generated and then a bcd segment is generated, converting the ascii segment with non EIS
     1296*   code. The known good bcd segment is then converted to ascii, using the MVT instruction, into 3 large
     1297*   segments.  The  3  converted  segments  are  then  compared to the original ascii segment and if any
     1298*   descrepencies are found the contents of both segments are dumped in octal at the failing location.
     1299**/
     1300 
     1301 test (24):
     1302 	mvtr_sw = "1"b;				/* set release switch */
     1303 	next_test = 25;
     1304 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude24;
     1305 
     1306 	if ^brief_sw then call ioa_ ("Test 24^-<mvt_bcd_to_ascii>");
     1307 
     1308 	call set_up_conds (0, "", "", "");
     1309 	num_temps = 1;				/* need one temp seg */
     1310 	call make_tempsegs;				/* make it */
     1311 
     1312 	do CYCL = 1 to num_to_cycle;
     1313 	     call cpu_tests_$mvt_tst_bcd_to_ascii;
     1314 	end;
     1315 
     1316 	call prepare_segment (DELETE);
     1317 
     1318 
     1319 exclude24:
     1320 	if sel_flag then goto sel_loop;
     1321 	if next_test > last_test then go to done;
     1322 
     1323 
     1324 
     1325 /* test 25. mvt_nine_to_four */
     1326 /*
     1327*   This test checks 9 bit to 4 bit (decimal to packed decimal) conversion using the MVT instruction.  A
     1328*   large  segment of data is generated containing 9 bit charaters with a value of 0 to 15 in a rotating
     1329*   pattern. Then a second segment if generated, converting the 9 bit characters into 4  bit  characters
     1330*   using  non  EIS  conversion techniques. The 9 bit data is then converted to 4 bit data using the MVT
     1331*   instruction, into 3 segments and this converted data is compared to the known good 4  bit  data.  If
     1332*   any descrepencies are found, the contents of both segments are dumped in octal at the failing.
     1333**/
     1334 
     1335 test (25):
     1336 	next_test = 26;
     1337 	mvtr_sw = "1"b;				/* set release switch */
     1338 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude25;
     1339 
     1340 	if ^brief_sw then call ioa_ ("Test 25^-<mvt_nine_to_four>");
     1341 
     1342 	call set_up_conds (0, "", "", "");
     1343 	num_temps = 1;				/* need one temp seg */
     1344 	call make_tempsegs;				/* make it */
     1345 
     1346 	do CYCL = 1 to num_to_cycle;
     1347 	     call cpu_tests_$mvt_tst_nine_to_four;
     1348 	end;
     1349 	call prepare_segment (DELETE);
     1350 
     1351 exclude25:
     1352 	if sel_flag then goto sel_loop;
     1353 	if next_test > last_test then go to done;
     1354 
     1355 
     1356 
     1357 /* test 26 */
     1358 /*
     1359*   This test checks 4 bit to 9 bit (packed decimal to decimal ) conversion using the MVT instruction. 9
     1360*   bit  and  4  bit data segments are generated using non EIS conversion as described in test 25. The 4
     1361*   bit data is then converted to 9 bit with an MVT instruction into 3 segments. The 3 segments are then
     1362*   compared  to  the  original  9  bit  segment.  If  any descrepencies are found, the contents of both
     1363*   segments are dumped in octal ato the failing location.
     1364**/
     1365 
     1366 test (26):
     1367 	next_test = 27;
     1368 	mvtr_sw = "1"b;				/* set release switch */
     1369 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude26;
     1370 
     1371 	if ^brief_sw then call ioa_ ("Test 26^-<mvt_four_to_nine>");
     1372 
     1373 	call set_up_conds (0, "", "", "");
     1374 	num_temps = 1;				/* need one temp seg */
     1375 	call make_tempsegs;				/* make it */
     1376 
     1377 	do CYCL = 1 to num_to_cycle;
     1378 	     call cpu_tests_$mvt_tst_four_to_nine;
     1379 	end;
     1380 	call prepare_segment (DELETE);
     1381 
     1382 exclude26:
     1383 	if sel_flag then goto sel_loop;
     1384 	if next_test > last_test then go to done;
     1385 
     1386 
     1387 
     1388 /* test 27. mvt_ascii_to_ebcdic */
     1389 /*
     1390*   This test checks nine to nine (ascii to ebcdic) character conversion using the  MVT  instruction.  A
     1391*   large  ascii  segment  is  generated  and  then  this  segment  is converted to ebcdic using non EIS
     1392*   techniques. The ascii segment is then converted  into  3  segments  using  a  MVT  instruction.  The
     1393*   resultant  ebcdic  segments  are  compared to the know good ebcdic segment. If any descrepencies are
     1394*   found, the contents of both segments are dumped at the failing location.
     1395**/
     1396 
     1397 test (27):
     1398 	next_test = 28;
     1399 	mvtr_sw = "1"b;				/* set release switch */
     1400 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude27;
     1401 
     1402 	if ^brief_sw then call ioa_ ("Test 27^-<mvt_ascii_to_ebcdic>");
     1403 
     1404 	call set_up_conds (0, "", "", "");
     1405 	num_temps = 1;				/* need one temp seg */
     1406 	call make_tempsegs;				/* make it */
     1407 
     1408 	do CYCL = 1 to num_to_cycle;
     1409 	     call cpu_tests_$mvt_tst_ascii_to_ebcdic;
     1410 	end;
     1411 	call prepare_segment (DELETE);
     1412 
     1413 exclude27:
     1414 	if sel_flag then goto sel_loop;
     1415 	if next_test > last_test then go to done;
     1416 
     1417 
     1418 
     1419 /* test 28. mvt_ebcdic_to_ascii */
     1420 /*
     1421*   This test checks nine to nine (ebcdic to ascii) character  conversion  using  the  MVT  instruction.
     1422*   Large  ascii  and  ebcdic segments are generated using non EIS conversion techniques as described in
     1423*   test 27. The known good ebcdic segment is converted to  ascii  using  the  MVt  instruction  into  3
     1424*   segments.  The  known  good  ascii  segment  is  compared  with  the  3  converted  segments. If any
     1425*   descrepencies are found, the contents of both segments are dumped in octal at the failing location.
     1426**/
     1427 
     1428 test (28):
     1429 	next_test = 29;
     1430 	mvtr_sw = "1"b;				/* Set release switch */
     1431 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude28;
     1432 
     1433 	if ^brief_sw then call ioa_ ("Test 28^-<mvt_ebcdic_to_ascii>");
     1434 
     1435 	call set_up_conds (0, "", "", "");
     1436 	num_temps = 1;				/* need one temp seg */
     1437 	call make_tempsegs;				/* make it */
     1438 
     1439 	do CYCL = 1 to num_to_cycle;
     1440 	     call cpu_tests_$mvt_tst_ebcdic_to_ascii;
     1441 	end;
     1442 	call prepare_segment (DELETE);
     1443 
     1444 exclude28:
     1445 	if sel_flag then goto sel_loop;
     1446 	if next_test > last_test then go to done;
     1447 
     1448 
     1449 
     1450 /* test 29. ci_mod_case_2 */
     1451 /*
     1452*   This test checks character indirect modification with 2 tally words and  2  data  character  strings
     1453*   each located at a page boundary. A LDA instruction is executed on one tally word with ci mod, a cmpa
     1454*   is executed with a second tally word, ci mod. Both tally words point to a char. string  that  should
     1455*   be  equal.  If the zero indicator does not come on as a result of the cmpa, a ZOP fault is taken and
     1456*   the test failed. */
     1457 
     1458 test (29):
     1459 	next_test = 30;
     1460 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude29;
     1461 
     1462 	if ^brief_sw then call ioa_ ("Test 29^-<ci_mod_case_2>");
     1463 
     1464 	call set_up_conds (1, "illegal_opcode", "", "");
     1465 	num_temps = 1;				/* need one temp seg */
     1466 	call make_tempsegs;				/* make it */
     1467 
     1468 	do CYCL = 1 to num_to_cycle;
     1469 	     call prepare_segment (TRUNC_and_DEACT);
     1470 	     call cpu_tests_$ci_mod_case_2 (tempseg_ptr (1));
     1471 	end;
     1472 	call prepare_segment (DELETE);
     1473 
     1474 exclude29:
     1475 	if sel_flag then goto sel_loop;
     1476 	if next_test > last_test then go to done;
     1477 
     1478 
     1479 
     1480 /*	TEST 30.	acv_restart_csl	*/
     1481 
     1482 /* This test check that the hardware can successfully restart the machine conditions after an
     1483*   access violation fault caused by a reference to data via an EIS (csl) instruction */
     1484 
     1485 test (30):
     1486 	next_test = 31;
     1487 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude30;
     1488 
     1489 	if ^brief_sw then call ioa_ ("Test 30^-<acv_restart_csl>");
     1490 
     1491 	call set_up_conds (0, "", "", "");
     1492 	num_temps = 1;				/* need one temp seg */
     1493 	call make_tempsegs;				/* make it */
     1494 
     1495 	on no_write_permission
     1496 	     begin;
     1497 		if tries > 1 then do;
     1498 		     call ioa_ ("restart did not work  *** HARDWARE FAILING ***");
     1499 		     if ^no_display_mc then /* are we in brief mode? */ call display_mc;
     1500 						/* no go print out the machine conditions */
     1501 		     revert no_write_permission;
     1502 		     goto exclude30;
     1503 		     end;
     1504 		ACL.access_name = get_group_id_ ();
     1505 		ACL.modes = "101"b;
     1506 		pdir = get_pdir_ ();
     1507 		call hcs_$add_acl_entries (pdir, "testcpu_tempseg_1", addr (ACL), 1, code);
     1508 		tries = tries + 1;
     1509 	     end;
     1510 
     1511 	do CYCL = 1 to num_to_cycle;
     1512 	     tries = 0;
     1513 	     call prepare_segment (TRUNC_and_DEACT);
     1514 	     call cpu_tests_$acv_restart_csl (tempseg_ptr (1));
     1515 	end;
     1516 	call prepare_segment (DELETE);
     1517 
     1518 
     1519 exclude30:
     1520 	revert no_write_permission;
     1521 	if sel_flag then goto sel_loop;
     1522 	if next_test > last_test then goto done;
     1523 
     1524 
     1525 
     1526 /* test 31. cmpn_tst */
     1527 /* This test checks that numeric data moved with a mvn instruction can be successfully compared
     1528*   with a cmpn instruction. */
     1529 
     1530 test (31):
     1531 	next_test = 32;
     1532 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude31;
     1533 
     1534 	if ^brief_sw then call ioa_ ("Test 31^-<cmpn_tst>");
     1535 
     1536 	call set_up_conds (1, "illegal_opcode", "", "");
     1537 	num_temps = 1;				/* need one temp seg */
     1538 	call make_tempsegs;				/* make it */
     1539 
     1540 	do CYCL = 1 to num_to_cycle;
     1541 	     call prepare_segment (TRUNC_and_DEACT);
     1542 	     call cpu_tests_$cmpn_tst (tempseg_ptr (1));
     1543 	end;
     1544 	call prepare_segment (DELETE);
     1545 
     1546 exclude31:
     1547 	if sel_flag then goto sel_loop;
     1548 	if next_test > last_test then go to done;
     1549 
     1550 
     1551 /*	TEST 32. itp_mod */
     1552 
     1553 /* This test checks that an epp2,* to a word pair tahat  contains an itp modifier
     1554*   with a bit offset actually loads pr2 with the correct information */
     1555 
     1556 
     1557 test (32):
     1558 	next_test = 33;
     1559 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude32;
     1560 
     1561 	if ^brief_sw then call ioa_ ("Test 32^-<itp_mod>");
     1562 
     1563 	call set_up_conds (1, "illegal_opcode", "", "");
     1564 	num_temps = 1;				/* need one temp seg */
     1565 	call make_tempsegs;				/* make it */
     1566 
     1567 	do CYCL = 1 to num_to_cycle;
     1568 	     call cpu_tests_$itp_mod;
     1569 	end;
     1570 	call prepare_segment (DELETE);
     1571 
     1572 exclude32:
     1573 	if sel_flag then goto sel_loop;
     1574 	if next_test > last_test then go to done;
     1575 
     1576 
     1577 
     1578 
     1579 test (33):
     1580 	next_test = 34;
     1581 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude33;
     1582 
     1583 	if ^brief_sw then call ioa_ ("Test 33^-<mvnoosb>");
     1584 
     1585 	call set_up_conds (1, "out_of_bounds", "Pre-page (FPTW2) logic not working.", "");
     1586 	num_temps = 1;				/* need one temp seg */
     1587 	call make_tempsegs;				/* make it */
     1588 
     1589 	do CYCL = 1 to num_to_cycle;
     1590 	     call prepare_segment (TRUNC_and_DEACT);
     1591 	     call cpu_tests_$mvnoosb (tempseg_ptr (1));
     1592 	end;
     1593 	call prepare_segment (DELETE);
     1594 
     1595 exclude33:
     1596 	if sel_flag then goto sel_loop;
     1597 	if next_test > last_test then go to done;
     1598 
     1599 
     1600 
     1601 test (34):
     1602 	next_test = 35;
     1603 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude34;
     1604 
     1605 	if ^brief_sw then call ioa_ ("Test 34^-<cmpb_with_sixbit_offset>");
     1606 
     1607 	call set_up_conds (0, "", "", "");
     1608 	num_temps = 1;				/* need one temp seg */
     1609 	call make_tempsegs;				/* make it */
     1610 
     1611 	do CYCL = 1 to num_to_cycle;
     1612 	     call prepare_segment (TRUNC_and_DEACT);
     1613 	     call cpu_tests_$cmpb_with_sixbit_offset (tempseg_ptr (1));
     1614 	end;
     1615 	call prepare_segment (DELETE);
     1616 
     1617 exclude34:
     1618 	if sel_flag then goto sel_loop;
     1619 	if next_test > last_test then go to done;
     1620 
     1621 
     1622 
     1623 test (35):
     1624 	next_test = 36;
     1625 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude35;
     1626 
     1627 	if ^brief_sw then call ioa_ ("Test 35^-<cmpb_with_rotate>");
     1628 
     1629 	call set_up_conds (0, "", "", "");
     1630 	num_temps = 1;				/* need one temp seg */
     1631 	call make_tempsegs;				/* make it */
     1632 
     1633 	do CYCL = 1 to num_to_cycle;
     1634 	     call prepare_segment (TRUNC_and_DEACT);
     1635 	     call cpu_tests_$cmpb_with_rotate (tempseg_ptr (1));
     1636 	end;
     1637 	call prepare_segment (DELETE);
     1638 
     1639 exclude35:
     1640 	if sel_flag then goto sel_loop;
     1641 	if next_test > last_test then go to done;
     1642 
     1643 
     1644 
     1645 /*	TEST 36. cmpc_pgbnd (cmpc fails on page bound when one string is zero length) */
     1646 
     1647 /* This tests a CMPC instruction at seg|1767 (octal) for 38 chars against a 0 length string
     1648*   with blank fill. */
     1649 
     1650 test (36):
     1651 	next_test = 37;
     1652 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude36;
     1653 
     1654 	if ^brief_sw then call ioa_ ("Test 36^-<cmpc_pgbnd>");
     1655 
     1656 	call set_up_conds (1, "illegal_opcode", "", "");
     1657 	num_temps = 1;				/* need one temp seg */
     1658 	call make_tempsegs;				/* make it */
     1659 
     1660 	do CYCL = 1 to num_to_cycle;
     1661 	     call prepare_segment (TRUNC_and_DEACT);
     1662 	     call cpu_tests_$cmpc_pgbnd (tempseg_ptr (1));
     1663 	end;
     1664 	call prepare_segment (DELETE);
     1665 
     1666 exclude36:
     1667 	if sel_flag then goto sel_loop;
     1668 	if next_test > last_test then go to done;
     1669 
     1670 
     1671 
     1672 
     1673 /*	TEST 37. csl_pgflt (csl gets no_write_perm if page faults on target & source is read-only */
     1674 
     1675 test (37):
     1676 	next_test = 38;
     1677 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude37;
     1678 
     1679 	if ^brief_sw then call ioa_ ("Test 37^-<csl_pgflt>");
     1680 
     1681 	call set_up_conds (1, "no_write_permission", "", "");
     1682 	num_temps = 1;				/* need one temp seg */
     1683 	call make_tempsegs;				/* make it */
     1684 
     1685 	do CYCL = 1 to num_to_cycle;
     1686 	     call prepare_segment (TRUNC_and_DEACT);
     1687 	     call cpu_tests_$csl_pgflt (tempseg_ptr (1));
     1688 	end;
     1689 	call prepare_segment (DELETE);
     1690 
     1691 exclude37:
     1692 	if sel_flag then goto sel_loop;
     1693 	if next_test > last_test then goto done;
     1694 
     1695 
     1696 
     1697 
     1698 /*	TEST 38.  scm_pgflt (trouble with SCM instruction when operand gets a pagefault) */
     1699 
     1700 test (38):
     1701 dcl  scm_str char (1044449) based (tempseg_ptr (1));
     1702 dcl  start fixed bin (21) init (143242);
     1703 
     1704 
     1705 	next_test = 39;
     1706 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude38;
     1707 
     1708 	if ^brief_sw then call ioa_ ("Test 38^-<scm_pgflt>");
     1709 
     1710 	call set_up_conds (1, "illegal_opcode", "", "");
     1711 	num_temps = 1;				/* need one temp seg */
     1712 	call make_tempsegs;				/* make it */
     1713 
     1714 	do CYCL = 1 to num_to_cycle;
     1715 	     substr (scm_str, start, 132) = "";
     1716 	     substr (scm_str, start + 132, 1) = "
     1717 ";						/* a new line */
     1718 
     1719 	     do i = 1 to 500;
     1720 		call prepare_segment (DEACT);
     1721 		call cpu_tests_$scm_pgflt (tempseg_ptr (1));
     1722 	     end;
     1723 	end;
     1724 	call prepare_segment (DELETE);
     1725 
     1726 exclude38:
     1727 	if sel_flag then goto sel_loop;
     1728 	if next_test > last_test then go to done;
     1729 
     1730 
     1731 
     1732 
     1733 /*	TEST 39.	scd_con_flt (SCD fails very rarely when interrupted by connect fault(?)) */
     1734 
     1735 test (39):
     1736 	next_test = 40;
     1737 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude39;
     1738 
     1739 	if ^brief_sw then call ioa_ ("Test 39^-<scd_conflt>");
     1740 
     1741 	call set_up_conds (1, "illegal_opcode", "", "");
     1742 	num_temps = 1;				/* need one temp seg */
     1743 	call make_tempsegs;				/* make it */
     1744 
     1745 	do CYCL = 1 to num_to_cycle;
     1746 	     call cpu_tests_$scd_con_flt;
     1747 	end;
     1748 	call prepare_segment (DELETE);
     1749 
     1750 exclude39:
     1751 	if sel_flag then goto sel_loop;
     1752 	if next_test > last_test then go to done;
     1753 
     1754 
     1755 /*        TEST 40. xed_dirflt_even (xed on an even word bound executes the second instr
     1756*   of the op pair twice when a dir'd flt occurs on the second op.) */
     1757 
     1758 test (40):
     1759 	next_test = 41;
     1760 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude40;
     1761 
     1762 	if ^brief_sw then call ioa_ ("Test 40^-<xed_dirflt_even>");
     1763 
     1764 	call set_up_conds (1, "illegal_opcode", "", "PHAFPG174/175/934");
     1765 	num_temps = 1;				/* need one temp seg */
     1766 	call make_tempsegs;				/* make it */
     1767 
     1768 	do CYCL = 1 to num_to_cycle;
     1769 	     call prepare_segment (TRUNC_and_DEACT);
     1770 	     call cpu_tests_$xed_dirflt_even (tempseg_ptr (1));
     1771 	end;
     1772 	call prepare_segment (DELETE);
     1773 
     1774 exclude40:
     1775 	if sel_flag then goto sel_loop;
     1776 	if next_test > last_test then go to done;
     1777 
     1778 
     1779 
     1780 /*        TEST 41. xed_dirflt_odd (xed on an odd word bound skips the second instr
     1781*   of the op pair when a dir'd flt occurs on the first? op.) */
     1782 
     1783 test (41):
     1784 	next_test = 42;
     1785 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude41;
     1786 
     1787 	if ^brief_sw then call ioa_ ("Test 41^-<xed_dirflt_odd>");
     1788 
     1789 	call set_up_conds (1, "illegal_opcode", "", "PHAFPG174/175/934");
     1790 	num_temps = 1;				/* need one temp seg */
     1791 	call make_tempsegs;				/* make it */
     1792 
     1793 	do CYCL = 1 to num_to_cycle;
     1794 	     call prepare_segment (TRUNC_and_DEACT);
     1795 	     call cpu_tests_$xed_dirflt_odd (tempseg_ptr (1));
     1796 	end;
     1797 	call prepare_segment (DELETE);
     1798 
     1799 exclude41:
     1800 	if sel_flag then goto sel_loop;
     1801 	if next_test > last_test then go to done;
     1802 
     1803 
     1804 
     1805 /*        TEST 42. CMPC falsely sets the zero indicator if D2 takes a fault
     1806*   and has residue (MIF flag on), d2 (4'th fetch takes a fault).
     1807*   The level count on D2 does not get adjusted correctly on the SP&L */
     1808 
     1809 test (42):
     1810 	next_test = 42;
     1811 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude42;
     1812 
     1813 	if ^brief_sw then call ioa_ ("Test 42^-<cmpc_adj_len>");
     1814 
     1815 	call set_up_conds (1, "illegal_opcode", "", "");
     1816 	num_temps = 1;				/* need one temp seg */
     1817 	call make_tempsegs;				/* make it */
     1818 
     1819 	do CYCL = 1 to num_to_cycle;
     1820 	     call prepare_segment (TRUNC_and_DEACT);
     1821 	     call cpu_tests_$cmpc_adj_len (tempseg_ptr (1));
     1822 	end;
     1823 	call prepare_segment (DELETE);
     1824 
     1825 exclude42:
     1826 	if sel_flag then goto sel_loop;
     1827 	if next_test > last_test then go to done;
     1828 
     1829 
     1830 
     1831 /*        TEST 43. CMPC fails to set the zero indicator after returning from
     1832*   a page fault on d2. */
     1833 
     1834 test (43):
     1835 	next_test = 44;
     1836 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude43;
     1837 
     1838 	if ^brief_sw then call ioa_ ("Test 43^-<cmpc_zero_ind>");
     1839 
     1840 	call set_up_conds (1, "illegal_opcode", "", "PHAFPG192,193,194");
     1841 	num_temps = 1;				/* need one temp seg */
     1842 	call make_tempsegs;				/* make it */
     1843 
     1844 	do CYCL = 1 to num_to_cycle;
     1845 	     call prepare_segment (TRUNC_and_DEACT);
     1846 	     call cpu_tests_$cmpc_zero_ind (tempseg_ptr (1));
     1847 	end;
     1848 	call prepare_segment (DELETE);
     1849 
     1850 exclude43:
     1851 	if sel_flag then goto sel_loop;
     1852 	if next_test > last_test then go to done;
     1853 
     1854 
     1855 
     1856 
     1857 
     1858 /*        TEST 44. SCM fails to find the correct char (sets the tro and it
     1859*   should not  (simulate pl1 statment:
     1860*   index (collate (), aray_char (i));  */
     1861 
     1862 test (44):
     1863 	next_test = 45;
     1864 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude44;
     1865 
     1866 	if ^brief_sw then call ioa_ ("Test 44^-<scm_tro>");
     1867 
     1868 	call set_up_conds (1, "illegal_opcode", "", "");
     1869 	num_temps = 1;				/* need one temp seg */
     1870 	call make_tempsegs;				/* make it */
     1871 	call prepare_segment (DEACT);			/* set it set up to deactivae before we use it */
     1872 
     1873           temp_data_size = 200;
     1874 	tempseg_ptr (1) -> temp_data = collate ();
     1875 	do CYCL = 1 to num_to_cycle;
     1876 	     call prepare_segment (DEACT);
     1877 	     call cpu_tests_$scm_tro (tempseg_ptr (1));
     1878 	end;
     1879 	call prepare_segment (DELETE);
     1880 
     1881 exclude44:
     1882 	if sel_flag then goto sel_loop;
     1883 	if next_test > last_test then go to done;
     1884 
     1885 
     1886 
     1887 
     1888 
     1889 /*        TEST 45. RPT at odd location fails after a page fault on a stz when crossing page bound */
     1890 
     1891 test (45):
     1892 	next_test = 46;
     1893 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude45;
     1894 
     1895 	if ^brief_sw then call ioa_ ("Test 45^-<rpt_test_odd>");
     1896 
     1897 	call set_up_conds (1, "lockup", "", "");
     1898 	num_temps = 1;				/* need one temp seg */
     1899 	call make_tempsegs;				/* make it */
     1900 
     1901 	do CYCL = 1 to num_to_cycle;
     1902 	     call prepare_segment (DEACT);
     1903 	     call cpu_tests_$rpt_test_odd (tempseg_ptr (1));
     1904 	end;
     1905 	call prepare_segment (DELETE);
     1906 
     1907 
     1908 exclude45:
     1909 	if sel_flag then goto sel_loop;
     1910 	if next_test > last_test then go to done;
     1911 
     1912 
     1913 
     1914 
     1915 
     1916 /*        TEST 46. RPT at even location fails after a page fault on a stz when crossing page bound */
     1917 
     1918 test (46):
     1919 	next_test = 47;
     1920 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude46;
     1921 
     1922 	if ^brief_sw then call ioa_ ("Test 46^-<rpt_test_evn>");
     1923 
     1924 	call set_up_conds (1, "no_write_permission", "", "");
     1925 	num_temps = 1;				/* need one temp seg */
     1926 	call make_tempsegs;				/* make it */
     1927 
     1928 	do CYCL = 1 to num_to_cycle;
     1929 	     call prepare_segment (DEACT);
     1930 	     call cpu_tests_$rpt_test_evn (tempseg_ptr (1));
     1931 	end;
     1932 	call prepare_segment (DELETE);
     1933 
     1934 
     1935 exclude46:
     1936 	if sel_flag then goto sel_loop;
     1937 	if next_test > last_test then go to done;
     1938 
     1939 
     1940 
     1941 
     1942 
     1943 
     1944 /*        TEST 47 scd_oob_tst. The SCD would fail if arg (d3) resided in a
     1945*   different segment than D1 or D2 AND there was no match, AND the scan ended
     1946*   a few words from the end of a 64K seg AND a seg fault was taken on the seg
     1947*   described by d3. This failed on a L68.
     1948*   The failure manifested itself by continuing the scan 'till the seg grew > 256K */
     1949 
     1950 test (47):
     1951 	next_test = 48;
     1952 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude47;
     1953 
     1954 	if ^brief_sw then call ioa_ ("Test 47^-<scd_oob_tst>");
     1955 
     1956 	call set_up_conds (2, "out_of_bounds,illegal_opcode", "", "PHAFPG192,193,194");
     1957 
     1958 	num_temps = 2;				/* this test requires 2 temp_segs */
     1959 	call make_tempsegs;				/* make it */
     1960 
     1961 	call hcs_$set_max_length_seg (tempseg_ptr (2), 1024 * 64, code);
     1962 						/* make max len 64k so mct will have a chance to capture pertinent info */
     1963 	call prepare_segment (DEACT);
     1964 
     1965 	do CYCL = 1 to num_to_cycle;
     1966 	     call prepare_segment (DEACT);
     1967 	     call term_$refname ("scd_oob_tst", code);
     1968 	     call cpu_tests_$scd_oob_tst(tempseg_ptr (1), tempseg_ptr(2));
     1969 	end;
     1970 	call prepare_segment (DELETE);
     1971 
     1972 exclude47:
     1973 	if sel_flag then goto sel_loop;
     1974 	if next_test > last_test then go to done;
     1975 
     1976 
     1977 
     1978 
     1979 /*    TEST 48 cmpb_onc.
     1980*      with the right magic numbers the cmpb will onc without the correct fix.
     1981**/
     1982 
     1983 test (48):
     1984 	next_test = 48+1;
     1985 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude48;
     1986 
     1987 	if ^brief_sw then call ioa_ ("Test 48^-<cmpb_onc>");
     1988 
     1989 	call set_up_conds (2, "op_not_complete,illegal_opcode", "For DPS8M", "PHAOPD369");
     1990 
     1991 	num_temps = 1;
     1992 
     1993 	call make_tempsegs;				/* make it */
     1994 	call prepare_segment (DEACT);
     1995 
     1996 /* setup the needed data using the magic numbers */
     1997 
     1998 	temp_data_ptr = addrel(tempseg_ptr (1),1459);
     1999 	temp_data_size = 70;
     2000 	do i = 1 to temp_data_size;
     2001 	   temp_words(i) = "777777777777"b3;
     2002 	   end;
     2003 	
     2004 
     2005 	do CYCL = 1 to num_to_cycle;
     2006 	     call prepare_segment (DEACT);
     2007 	     call cpu_tests_$cmpb_onc (tempseg_ptr (1));
     2008 	end;
     2009 	call prepare_segment (DELETE);
     2010 
     2011 exclude48:
     2012 	if sel_flag then goto sel_loop;
     2013 	if next_test > last_test then go to done;
     2014 
     2015 
     2016 
     2017 
     2018 /*        TEST 49 cmpc_a.
     2019*          With the correct magic numbers and data a cmpc will not set 
     2020*	the indicators correctly
     2021**/
     2022 
     2023 test (49):
     2024 	next_test = 49+1;
     2025 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude49;
     2026 
     2027 	if ^brief_sw then call ioa_ ("Test 49^-<cmpc_a>");
     2028 
     2029 	call set_up_conds (1, "illegal_opcode", "", "FPG194");
     2030 
     2031 	num_temps = 1;
     2032 
     2033 	call make_tempsegs;				/* make it */
     2034 	call prepare_segment (DEACT);
     2035 
     2036 /*      use the correct magic numbers and data */
     2037 	temp_data_size = 253;
     2038 	temp_data_ptr = addrel(tempseg_ptr(1),4402);
     2039 	temp_data = "101";
     2040 
     2041 	temp_data_size = 3921;
     2042 	temp_data_ptr = addrel(tempseg_ptr(1),254480);
     2043 	temp_data = "101";
     2044 	
     2045 
     2046 	do CYCL = 1 to num_to_cycle;
     2047 	     call prepare_segment (DEACT);
     2048 	     call cpu_tests_$cmpc_a (tempseg_ptr (1));
     2049 	end;
     2050 	call prepare_segment (DELETE);
     2051 
     2052 exclude49:
     2053 	if sel_flag then goto sel_loop;
     2054 	if next_test > last_test then go to done;
     2055 
     2056 
     2057 
     2058 
     2059 /*        TEST 50 cmpc_b.
     2060*          With the correct magic numbers and data a cmpc will not set 
     2061*	the indicators correctly. Very similar to test 49.
     2062**/
     2063 
     2064 test (50):
     2065 	next_test = 50+1;
     2066 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude50;
     2067 
     2068 	if ^brief_sw then call ioa_ ("Test 50^-<cmpc_b>");
     2069 
     2070 	call set_up_conds (1, "illegal_opcode", "", "FPG195,FPD358");
     2071 
     2072 	num_temps = 1;
     2073 
     2074 	call make_tempsegs;				/* make it */
     2075 	call prepare_segment (DEACT);
     2076 
     2077 /*      use the correct magic numbers and data */
     2078 	temp_data_size = 253;
     2079 	temp_data_ptr = addrel(tempseg_ptr(1),4402);
     2080 	temp_data = "102";
     2081 
     2082 	temp_data_size = 3921;
     2083 	temp_data_ptr = addrel(tempseg_ptr(1),254670);
     2084 	temp_data = "102";
     2085 	
     2086 
     2087 	do CYCL = 1 to num_to_cycle;
     2088 	     call prepare_segment (DEACT);
     2089 	     call cpu_tests_$cmpc_b (tempseg_ptr (1));
     2090 	end;
     2091 	call prepare_segment (DELETE);
     2092 
     2093 exclude50:
     2094 	if sel_flag then goto sel_loop;
     2095 	if next_test > last_test then go to done;
     2096 
     2097 
     2098 
     2099 
     2100 /*        TEST 51 sreg_no_write.
     2101*          If an sreg at page bound -2 the PSR segment number will be used
     2102*	instead of the TRS if fix not installed.
     2103*	Test  sreg_no_write dose not use a temp seg.
     2104**/
     2105 
     2106 test (51):
     2107 	next_test = 51+1;
     2108 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude51;
     2109 
     2110 	if ^brief_sw then call ioa_ ("Test 51^-<sreg_no_write>");
     2111 
     2112 	call set_up_conds (1, "no_write_permission", "", "FPD312");
     2113 
     2114 	do CYCL = 1 to num_to_cycle;
     2115 	     call cpu_tests_$sreg_no_write;
     2116 	end;
     2117 
     2118 exclude51:
     2119 	if sel_flag then goto sel_loop;
     2120 	if next_test > last_test then go to done;
     2121 
     2122 
     2123 
     2124 
     2125 /*        TEST 52 tnz.
     2126*          Without fix a tnz at page bound -1 will not work
     2127**/
     2128 
     2129 test (52):
     2130 	next_test = 52+1;
     2131 	if excl_list (next_test - 1) = next_test - 1 then /* exclude this test? */ go to exclude52;
     2132 
     2133 	if ^brief_sw then call ioa_ ("Test 52^-<tnz>");
     2134 
     2135 	call set_up_conds (1, "illegal_opcode", "", "FPD354");
     2136 
     2137 	num_temps = 1;
     2138 
     2139 	call make_tempsegs;				/* make it */
     2140 	call prepare_segment (DEACT);
     2141 
     2142 	do CYCL = 1 to num_to_cycle;
     2143 	     call prepare_segment (DEACT);
     2144 	     call cpu_tests_$tnz (tempseg_ptr (1));
     2145 	end;
     2146 	call prepare_segment (DELETE);
     2147 
     2148 exclude52:
     2149 	if sel_flag then goto sel_loop;
     2150 	if next_test > last_test then go to done;
     2151 
     2152 
     2153 /* END OF TESTS */
     2154 
     2155 /*****************************************************************************/
     2156 /*  This is an example for adding test cases			       */
     2157 /*							       */
     2158 /*        TEST XX TEST_NAME.					       */
     2159 /*	What it tries to test if known.			       */
     2160 /*							       */
     2161 /*****************************************************************************/
     2162 /*
     2163*test (XX):
     2164*	next_test = XX+1;
     2165*
     2166* "**** exclude this test? **** "
     2167*	if excl_list (next_test - 1) = next_test - 1 then go to excludeXX;
     2168*
     2169*	if ^brief_sw then call ioa_ ("Test XX^-<TEST_NAME>");
     2170*
     2171*	call set_up_conds (NUM_OF_COND, "LIST_OF_COND", "", "FCO_LIST");
     2172*
     2173*	num_temps = NUMBER_OF_TEMPSEGS;
     2174*
     2175*	call make_tempsegs;			" **** make it **** "
     2176*	call prepare_segment (ACTION);
     2177*
     2178* " *****  any special data is placed here ***** "
     2179*
     2180*	do CYCL = 1 to num_to_cycle;
     2181*	     call prepare_segment (ACTION);
     2182*	     call cpu_tests_$TEST_NAME (ARGLIST);
     2183*	end;
     2184*	call prepare_segment (DELETE);
     2185*
     2186*excludeXX:
     2187*	if sel_flag then goto sel_loop;
     2188*	if next_test > last_test then go to done;
     2189**/
     2190 
     2191 
     2192 
     2193 /* This procedure creates the temp seg(s) to be used by all test cases and set up for deactivation. */
     2194 
     2195 make_tempsegs:
     2196      proc;
     2197 
     2198 dcl  i fixed bin;
     2199 
     2200 
     2201 	do i = 1 to num_temps;
     2202 	     STR = ltrim (rtrim (char (i)));
     2203 	     call hcs_$make_seg ("", "testcpu_tempseg_" || STR, "testcpu_tempseg_" || STR, 1111b, tempseg_ptr (i), code)
     2204 		;
     2205 
     2206 	     if tempseg_ptr (i) = null () then do;
     2207 
     2208 notempseg:
     2209 		call com_err_ (code, "test_cpu", "Cannot get ptr to temporary segment.");
     2210 		return;
     2211 		end;
     2212 
     2213 	     unspec (akst) = "0"b;			/* set up KST so we can deactivate the tempseg */
     2214 	     akst.set.explicit_deactivate_ok, akst.value.explicit_deactivate_ok = "1"b;
     2215 
     2216 	     on no_read_permission
     2217 		begin;
     2218 link_err:
     2219 		     call com_err_ (0, (myname), "test_cpu requires access to >sl1>phcs_.");
     2220 		     go to done;
     2221 		end;
     2222 
     2223 	     call phcs_$set_kst_attributes (fixed (baseno (tempseg_ptr (i)), 17), addr (akst), code);
     2224 						/* now set permissions */
     2225 
     2226 	     revert no_read_permission;
     2227 
     2228 	     call phcs_$deactivate (tempseg_ptr (i), code);
     2229 						/* do it now before its touched */
     2230 	     if code ^= 0 then do;			/* just quit */
     2231 		call com_err_ (code, myname, "Call to deactivate failed.");
     2232 		return;
     2233 		end;
     2234 
     2235 	end;
     2236 	return;
     2237      end;
     2238 
     2239 
     2240 
     2241 prepare_segment:
     2242      proc (operation);
     2243 
     2244 dcl  operation fixed bin;
     2245 dcl  idx fixed bin;
     2246 
     2247 	go to OP (operation);
     2248 
     2249 OP (1):						/* truncate & deactivate */
     2250 	do idx = 1 to num_temps;
     2251 	     call hcs_$truncate_seg (tempseg_ptr (idx), 0, code);
     2252 	     if code ^= 0 then do;			/* just quit */
     2253 		call com_err_ (code, myname, "Call to truncate failed.");
     2254 		return;
     2255 		end;
     2256 
     2257 	     call phcs_$deactivate (tempseg_ptr (idx), code);
     2258 						/* do it now before its touched */
     2259 	     if code ^= 0 then do;			/* just quit */
     2260 		call com_err_ (code, myname, "Call to deactivate failed.");
     2261 		return;
     2262 		end;
     2263 	end;
     2264 
     2265 	return;
     2266 
     2267 OP (2):						/* delete */
     2268 	do idx = 1 to num_temps;
     2269 	     call delete_$ptr (tempseg_ptr (idx), "100101"b, "test_cpu", code);
     2270 	end;
     2271 	return;
     2272 
     2273 OP (3):						/* truncate only */
     2274 	do idx = 1 to num_temps;
     2275 	     call hcs_$truncate_seg (tempseg_ptr (idx), 0, code);
     2276 	end;
     2277 	return;
     2278 
     2279 OP (4):						/* deactivate only */
     2280 	do idx = 1 to num_temps;
     2281 	     call phcs_$deactivate (tempseg_ptr (idx), code);
     2282 
     2283 	     if code ^= 0 then do;			/* just quit */
     2284 		call com_err_ (code, myname, "Call to deactivate failed.");
     2285 		return;
     2286 		end;
     2287 	end;
     2288 	return;
     2289 
     2290      end prepare_segment;
     2291 
     2292 
     2293 
     2294 
     2295 /* This routine is used by those test cases that need to deactivate the temp seg */
     2296 
     2297 test_cpu$deactivate_tempseg:
     2298      entry;
     2299 
     2300 dcl  idx fixed bin;
     2301 
     2302 
     2303 	do idx = 1 to num_temps;
     2304 	     call phcs_$deactivate (tempseg_ptr (idx), code);
     2305 						/* do it now before its touched */
     2306 	     if code ^= 0 then do;			/* just quit */
     2307 		call com_err_ (code, myname, "Call to deactivate failed.");
     2308 		return;
     2309 		end;
     2310 	end;
     2311 
     2312 	return;
     2313 
     2314 
     2315 done:
     2316 	call CLEANUP;
     2317 
     2318 	return;
     2319 
     2320 CLEANUP:
     2321      proc;
     2322 dcl  idx fixed bin;
     2323 
     2324 	if mvtr_sw then /* if mvt release switch set go release temp segs */ call cpu_tests_$mvt_tst_release_t_segs;
     2325 
     2326 	do idx = 1 to 3;
     2327 	     if tempseg_ptr (idx) ^= null then call delete_$ptr (tempseg_ptr (idx), "100101"b, "test_cpu", code);
     2328 	end;
     2329 
     2330 	if ^hreg_state then /* leave hreg state the way it was */ call hcs_$history_regs_set ("0"b);
     2331 	return;
     2332 
     2333      end CLEANUP;
     2334 
     2335 display_mc:
     2336      proc;
     2337 
     2338 	call cu_$stack_frame_ptr (stackp);		/* get current sstack ptr */
     2339 	faultsp = find_condition_frame_ (stackp);	/* is this the cond frame ? */
     2340 	if faultsp = null () then do;
     2341 	     call ioa_ ("^a: Cannot find condition frame.", myname);
     2342 	     return;
     2343 	     end;
     2344 
     2345 	call find_condition_info_ (faultsp, addr (cond_info), code);
     2346 	if cond_info.mcptr = null () then return;
     2347 
     2348 	if ^mc_sw then go to HREGS;
     2349 	call ioa_ ("^/MACHINE CONDITIONS AT ^p:^/", cond_info.mcptr);
     2350 	call dump_machine_cond_ (addr (cond_info), faultsp, "user_output", 2);
     2351 						/* print the MC */
     2352 
     2353 HREGS:
     2354 	if ^h_sw then return;
     2355 	if mcptr ^= null then hreg_ptr = addrel (mcptr, 96);
     2356 	if hreg_ptr = null then do;			/* no history regs to dump */
     2357 	     call ioa_ ("History Registers are not available");
     2358 	     return;
     2359 	     end;
     2360 	else do;
     2361 	     call ioa_ ("CPU HISTORY REGISTERS AT TIME OF FAULT");
     2362 	     call hran_$hranl (hreg_ptr, null, long_sw);
     2363 	     end;
     2364 
     2365 	return;
     2366      end display_mc;
     2367 
     2368 
     2369 /* This procedure will establish the number of, and type of conditions
     2370*   expected for each test case and any additional info that may be helpful
     2371*   to a user when a test case fails, including FCO(s) that may be required. */
     2372 
     2373 set_up_conds:
     2374      proc (num_to_expect, conds, add_info, fco_info);
     2375 
     2376 dcl  (num_to_expect, idx, start_idx, end_idx) fixed bin;
     2377 dcl  (conds, add_info, fco_info) char (256) var;
     2378 
     2379 	num_expected_cond = num_to_expect;
     2380 	start_idx = 1;				/* init for first pass */
     2381 	do idx = 1 to num_to_expect;
     2382 	     end_idx = index (substr (conds, start_idx), ",");
     2383 
     2384 	     if end_idx ^= 0 then			/* not the last condition name */
     2385 		expected_condition (idx) = substr (conds, start_idx, end_idx - 1);
     2386 	     else expected_condition (idx) = substr (conds, start_idx, (length (conds) - start_idx + 1));
     2387 	     start_idx = end_idx + start_idx;
     2388 	end;
     2389 
     2390 	pertinent_info = add_info;
     2391 	if fco_info ^= "" then
     2392 	     FCO_required = "FCO(s) " || fco_info || " MUST be installed for this test to run sucessfully.";
     2393 	else FCO_required = "";
     2394 	return;
     2395 
     2396      end set_up_conds;
     2397 
     2398      end test_cpu;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/22/84  1059.4  test_cpu.pl1                      >spec>on>6978-10/22/84>test_cpu.pl1
210          1    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
214          2    04/29/76  1104.2  kst_attributes.incl.pl1           >ldd>include>kst_attributes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACL                             000100 automatic       structure                array level 1 dcl 47 set ref 1205 1205 1507 1507
COND                            000204 automatic       fixed bin(17,0)          dcl 65 set ref 495* 496*
CYCL                            000210 automatic       fixed bin(17,0)          dcl 65 set ref 594* 624* 662* 692* 722* 754* 788*
                                                                                  816* 846* 876* 905* 936* 964* 992* 1020* 1050*
                                                                                  1079* 1107* 1137* 1166* 1209* 1243* 1280* 1312*
                                                                                  1346* 1377* 1408* 1439* 1468* 1511* 1540* 1567*
                                                                                  1589* 1611* 1633* 1660* 1685* 1714* 1745* 1768*
                                                                                  1793* 1819* 1844* 1875* 1901* 1928* 1965* 2005*
                                                                                  2046* 2087* 2114* 2142*
DEACT                           000074 internal static fixed bin(17,0)          initial dcl 113 set ref 635* 1247* 1720* 1871* 1876*
                                                                                  1902* 1929* 1963* 1966* 1994* 2006* 2034* 2047*
                                                                                  2075* 2088* 2140* 2143*
DELETE                          000073 internal static fixed bin(17,0)          initial dcl 111 set ref 598* 639* 667* 697* 759*
                                                                                  792* 821* 851* 880* 909* 940* 968* 996* 1025*
                                                                                  1054* 1083* 1111* 1142* 1170* 1215* 1252* 1284*
                                                                                  1316* 1349* 1380* 1411* 1442* 1472* 1516* 1544*
                                                                                  1570* 1593* 1615* 1637* 1664* 1689* 1724* 1748*
                                                                                  1772* 1797* 1823* 1848* 1879* 1905* 1932* 1970*
                                                                                  2009* 2050* 2091* 2146*
FCO_required                    000311 automatic       varying char(100)        initial dcl 78 set ref 78* 501 501* 2391* 2393*
NUM_TESTS                              constant        fixed bin(17,0)          initial dcl 89 ref 59 60 238 240 275 299 354 355 370
                                                                                  399 411 418 506 524 548 558 569
RPT                             000206 automatic       fixed bin(17,0)          dcl 65 set ref 568*
SEL                             000207 automatic       fixed bin(17,0)          dcl 65 set ref 569* 569* 570*
STR                             000376 automatic       char(1)                  unaligned dcl 82 set ref 2202* 2203 2203
TERM                            000224 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 483* 495 504*
                                                                                  556* 558 562* 562
TRUNC_and_DEACT                 000072 internal static fixed bin(17,0)          initial dcl 110 set ref 595* 625* 663* 693* 723*
                                                                                  755* 817* 847* 1021* 1138* 1211* 1245* 1469* 1513*
                                                                                  1541* 1590* 1612* 1634* 1661* 1686* 1769* 1794*
                                                                                  1820* 1845*
access_name                     000100 automatic       char(32)                 array level 2 dcl 47 set ref 1202* 1504*
add_info                               parameter       varying char(256)        dcl 2377 ref 2373 2390
addr                                                   builtin function         dcl 83 ref 236 484 1205 1205 1507 1507 2223 2223
                                                                                  2345 2345 2350 2350
addrel                                                 builtin function         dcl 83 ref 1998 2038 2042 2079 2083 2355
akst                            000236 automatic       structure                level 1 dcl 73 set ref 2213* 2223 2223
any_other                       000362 stack reference condition                dcl 81 ref 480
argcount                        000173 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 255* 257 359 387
baseno                                                 builtin function         dcl 83 ref 2223 2223
brief_sw                        000245 automatic       bit(1)                   initial unaligned dcl 74 set ref 74* 432* 587 617
                                                                                  655 685 715 747 781 809 838 868 898 926 958 986
                                                                                  1013 1043 1072 1100 1129 1159 1188 1236 1274 1306
                                                                                  1340 1371 1402 1433 1462 1489 1534 1561 1583 1605
                                                                                  1627 1654 1679 1708 1739 1762 1787 1813 1838 1866
                                                                                  1895 1922 1954 1987 2027 2068 2110 2133
char                                                   builtin function         dcl 83 ref 2202
cleanup                         000354 stack reference condition                dcl 81 ref 217
code                            000235 automatic       fixed bin(35,0)          dcl 72 set ref 223* 258* 259 266* 267 272* 274 291*
                                                                                  292 297* 298 315* 316 321* 323 324* 333* 335 340*
                                                                                  342 343* 360* 361 367* 368 388* 389 390* 395* 397
                                                                                  485* 529* 938* 966* 1205* 1507* 1961* 1967* 2203*
                                                                                  2208* 2223* 2228* 2230 2231* 2251* 2252 2253*
                                                                                  2257* 2259 2260* 2269* 2275* 2281* 2283 2284*
                                                                                  2304* 2306 2307* 2327* 2345*
collate                                                builtin function         dcl 83 ref 1874
com_err_                        000132 constant        entry                    external dcl 132 ref 260 268 282 293 306 317 324 336
                                                                                  343 362 377 390 406 447 455 464 550 2208 2218 2231
                                                                                  2253 2260 2284 2307
cond_info                       000400 automatic       structure                level 1 dcl 209 set ref 484 2345 2345 2350 2350
cond_infop                      000344 automatic       pointer                  dcl 79 set ref 484* 485*
condition_name            3     000400 automatic       varying char(32)         level 2 dcl 209 set ref 486 488 488 488 488 488 488
                                                                                  496
conds                                  parameter       varying char(256)        dcl 2377 ref 2373 2382 2384 2386 2386
continue_to_signal_             000144 constant        entry                    external dcl 137 ref 529
cpu_tests_$acv_restart          000232 constant        entry                    external dcl 170 ref 1212
cpu_tests_$acv_restart_csl      000256 constant        entry                    external dcl 180 ref 1514
cpu_tests_$bad_fill             000216 constant        entry                    external dcl 164 ref 1022
cpu_tests_$ci_mod_case_2        000254 constant        entry                    external dcl 179 ref 1470
cpu_tests_$cmpb_onc             000324 constant        entry                    external dcl 199 ref 2007
cpu_tests_$cmpb_with_rotate     000270 constant        entry                    external dcl 185 ref 1635
cpu_tests_$cmpb_with_sixbit_offset
                                000266 constant        entry                    external dcl 184 ref 1613
cpu_tests_$cmpc                 000210 constant        entry                    external dcl 161 ref 993
cpu_tests_$cmpc7                000224 constant        entry                    external dcl 167 ref 1108
cpu_tests_$cmpc_a               000326 constant        entry                    external dcl 199 ref 2048
cpu_tests_$cmpc_adj_len         000322 constant        entry                    external dcl 198 ref 1821
cpu_tests_$cmpc_b               000330 constant        entry                    external dcl 199 ref 2089
cpu_tests_$cmpc_pgbnd           000272 constant        entry                    external dcl 186 ref 1662
cpu_tests_$cmpc_zero_ind        000310 constant        entry                    external dcl 193 ref 1846
cpu_tests_$cmpn_tst             000260 constant        entry                    external dcl 181 ref 1542
cpu_tests_$csl_onc              000176 constant        entry                    external dcl 156 ref 818
cpu_tests_$csl_oob              000214 constant        entry                    external dcl 163 ref 664
cpu_tests_$csl_pgflt            000274 constant        entry                    external dcl 187 ref 1687
cpu_tests_$csl_test             000212 constant        entry                    external dcl 162 ref 967
cpu_tests_$extra_fill           000226 constant        entry                    external dcl 168 ref 1139
cpu_tests_$itp_mod              000262 constant        entry                    external dcl 182 ref 1568
cpu_tests_$mlr_tst              000206 constant        entry                    external dcl 160 ref 939
cpu_tests_$mlrstern             000172 constant        entry                    external dcl 154 ref 596
cpu_tests_$mpy_ofl              000220 constant        entry                    external dcl 165 ref 1051
cpu_tests_$mvn                  000164 constant        entry                    external dcl 151 ref 694
cpu_tests_$mvn_ofl              000170 constant        entry                    external dcl 153 ref 724
cpu_tests_$mvnoosb              000264 constant        entry                    external dcl 183 ref 1591
cpu_tests_$mvt_tst_ascii_to_bcd 000236 constant        entry                    external dcl 172 ref 1281
cpu_tests_$mvt_tst_ascii_to_ebcdic
                                000246 constant        entry                    external dcl 176 ref 1409
cpu_tests_$mvt_tst_bcd_to_ascii 000240 constant        entry                    external dcl 173 ref 1313
cpu_tests_$mvt_tst_ebcdic_to_ascii
                                000250 constant        entry                    external dcl 177 ref 1440
cpu_tests_$mvt_tst_four_to_nine 000244 constant        entry                    external dcl 175 ref 1378
cpu_tests_$mvt_tst_nine_to_four 000242 constant        entry                    external dcl 174 ref 1347
cpu_tests_$mvt_tst_release_t_segs
                                000252 constant        entry                    external dcl 178 ref 2324
cpu_tests_$rpd_test             000204 constant        entry                    external dcl 159 ref 906
cpu_tests_$rpt_test_evn         000316 constant        entry                    external dcl 196 ref 1930
cpu_tests_$rpt_test_odd         000314 constant        entry                    external dcl 195 ref 1903
cpu_tests_$scd_con_flt          000300 constant        entry                    external dcl 189 ref 1746
cpu_tests_$scd_oob_tst          000320 constant        entry                    external dcl 197 ref 1968
cpu_tests_$scm_pgflt            000276 constant        entry                    external dcl 188 ref 1721
cpu_tests_$scm_tally            000234 constant        entry                    external dcl 171 ref 1248
cpu_tests_$scm_tro              000312 constant        entry                    external dcl 194 ref 1877
cpu_tests_$sreg                 000174 constant        entry                    external dcl 155 ref 789
cpu_tests_$sreg_no_write        000302 constant        entry                    external dcl 189 ref 2115
cpu_tests_$tct                  000166 constant        entry                    external dcl 152 ref 756
cpu_tests_$test_ci              000202 constant        entry                    external dcl 158 ref 877
cpu_tests_$test_cmpc_fill       000230 constant        entry                    external dcl 169 ref 1167
cpu_tests_$test_sc2             000200 constant        entry                    external dcl 157 ref 848
cpu_tests_$test_xed             000222 constant        entry                    external dcl 166 ref 1080
cpu_tests_$tmlr                 000160 constant        entry                    external dcl 149 ref 629
cpu_tests_$tmlr_data            000162 external static char(58)                 dcl 150 ref 630 631 631
cpu_tests_$tnz                  000332 constant        entry                    external dcl 199 ref 2144
cpu_tests_$xed_dirflt_even      000304 constant        entry                    external dcl 191 ref 1770
cpu_tests_$xed_dirflt_odd       000306 constant        entry                    external dcl 192 ref 1795
cu_$arg_count                   000134 constant        entry                    external dcl 133 ref 255
cu_$arg_ptr                     000136 constant        entry                    external dcl 134 ref 258 266 291 315 333 360 388
cu_$stack_frame_ptr             000150 constant        entry                    external dcl 139 ref 2338
cv_dec_check_                   000140 constant        entry                    external dcl 135 ref 272 297 321 340 367 395
cycle_flag                      000230 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 332*
delete_$ptr                     000124 constant        entry                    external dcl 129 ref 2269 2327
dump_machine_cond_              000152 constant        entry                    external dcl 140 ref 2350
end_idx                         000574 automatic       fixed bin(17,0)          dcl 2376 set ref 2382* 2384 2384 2387
excl_list                       000117 automatic       fixed bin(17,0)          array dcl 60 set ref 242* 402* 411* 585 615 653 683
                                                                                  713 745 779 807 836 866 896 924 956 984 1011 1041
                                                                                  1070 1098 1127 1157 1186 1234 1272 1304 1338 1369
                                                                                  1400 1431 1460 1487 1532 1559 1581 1603 1625 1652
                                                                                  1677 1706 1737 1760 1785 1811 1836 1864 1893 1920
                                                                                  1952 1985 2025 2066 2108 2131
expected_condition              000011 internal static char(32)                 initial array unaligned dcl 104 set ref 496 2384*
                                                                                  2386*
explicit_deactivate_ok
                          0(05) 000236 automatic       bit(1)                   level 3 in structure "akst" packed unaligned dcl 73
                                                                                  in procedure "test_cpu" set ref 2214*
explicit_deactivate_ok
                          1(14) 000236 automatic       bit(1)                   level 3 in structure "akst" packed unaligned dcl 73
                                                                                  in procedure "test_cpu" set ref 2214*
faultsp                         000216 automatic       pointer                  dcl 67 set ref 2339* 2340 2345* 2350*
fco_info                               parameter       varying char(256)        dcl 2377 ref 2373 2391 2391
find_condition_frame_           000146 constant        entry                    external dcl 138 ref 2339
find_condition_info_            000142 constant        entry                    external dcl 136 ref 485 2345
fixed                                                  builtin function         dcl 83 ref 2223 2223
found_arg                       000231 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 275 277* 281
                                                                                  299 301* 305 369* 370 372* 376 398* 399 401* 405
from_flag                       000226 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 273* 453 545
                                                                                  547
get_group_id_                   000102 constant        entry                    external dcl 120 ref 1202 1504
get_line_length_$switch         000104 constant        entry                    external dcl 121 ref 223
get_pdir_                       000122 constant        entry                    external dcl 128 ref 1204 1506
h_sw                            000242 automatic       bit(1)                   initial unaligned dcl 74 set ref 74* 232* 427* 437*
                                                                                  522* 543 2353
hcs_$add_acl_entries            000100 constant        entry                    external dcl 119 ref 1205 1507
hcs_$history_regs_get           000106 constant        entry                    external dcl 122 ref 229 438
hcs_$history_regs_set           000110 constant        entry                    external dcl 123 ref 230 439 2330
hcs_$make_seg                   000112 constant        entry                    external dcl 124 ref 2203
hcs_$set_max_length_seg         000126 constant        entry                    external dcl 130 ref 1961
hcs_$truncate_seg               000130 constant        entry                    external dcl 131 ref 2251 2275
hran_$hranl                     000154 constant        entry                    external dcl 141 ref 2362
hreg_ptr                        000212 automatic       pointer                  dcl 67 set ref 2355* 2356 2362*
hreg_state                      000246 automatic       bit(1)                   dcl 75 set ref 229* 230 438* 439 2330
i                               000174 automatic       fixed bin(17,0)          initial dcl 64 in procedure "test_cpu" set ref 64*
                                                                                  240* 241 241 242* 245* 246* 354* 355* 558* 559
                                                                                  560* 628* 629* 1246* 1719* 2000* 2001*
i                               000100 automatic       fixed bin(17,0)          dcl 2198 in procedure "make_tempsegs" set ref 2201*
                                                                                  2202 2203 2206 2223 2223 2228*
idx                             000572 automatic       fixed bin(17,0)          dcl 2376 in procedure "set_up_conds" set ref 2381*
                                                                                  2384 2386*
idx                             000100 automatic       fixed bin(17,0)          dcl 2322 in procedure "CLEANUP" set ref 2326* 2327
                                                                                  2327*
idx                             000433 automatic       fixed bin(17,0)          dcl 2300 in procedure "test_cpu" set ref 2303* 2304*
idx                             000556 automatic       fixed bin(17,0)          dcl 2245 in procedure "prepare_segment" set ref
                                                                                  2249* 2251 2257* 2267* 2269* 2273* 2275* 2279*
                                                                                  2281*
index                                                  builtin function         dcl 83 ref 2382
int_cond_name                   000247 automatic       char(32)                 unaligned dcl 76 set ref 486* 497* 518*
ioa_                            000076 constant        entry                    external dcl 118 ref 417 419 467 469 471 497 500 501
                                                                                  518 538 587 617 631 655 685 715 747 781 809 838
                                                                                  868 898 926 958 986 1013 1043 1072 1100 1129 1159
                                                                                  1188 1196 1236 1274 1306 1340 1371 1402 1433 1462
                                                                                  1489 1498 1534 1561 1583 1605 1627 1654 1679 1708
                                                                                  1739 1762 1787 1813 1838 1866 1895 1922 1954 1987
                                                                                  2027 2068 2110 2133 2341 2349 2357 2361
j                               000175 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 257* 258* 265* 265 266*
                                                                                  290* 290 291* 314* 314 315* 331* 331 333* 351* 351
                                                                                  359* 359* 360* 385* 385 387* 387* 388* 627* 629*
                                                                                  630 630 631 631 631 631*
k                               000176 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 275* 276 278* 299* 300
                                                                                  302* 370* 371 373* 395* 399* 400 402 402* 411 411
                                                                                  411 411 418* 419* 419*
kst_attributes                         based           structure                level 1 dcl 2-5
last_test                       000201 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 238* 297* 302* 548* 549
                                                                                  550* 562 603 642 671 701 733 764 796 825 855 885
                                                                                  913 945 973 1000 1029 1059 1088 1116 1147 1175
                                                                                  1220 1256 1288 1321 1353 1384 1415 1446 1476 1522
                                                                                  1548 1574 1597 1619 1641 1668 1693 1728 1752 1776
                                                                                  1801 1827 1852 1883 1910 1937 1974 2013 2054 2095
                                                                                  2120 2150
length                                                 builtin function         dcl 83 ref 2386
line_length                     000120 automatic       fixed bin(17,0)          dcl 62 set ref 223* 224
long_sw                         000117 automatic       bit(1)                   initial unaligned dcl 61 set ref 61* 226* 2362*
ltrim                                                  builtin function         dcl 83 ref 2202
mc_sw                           000243 automatic       bit(1)                   initial unaligned dcl 74 set ref 74* 233* 430* 437*
                                                                                  522* 543 2348
mcptr                           000400 automatic       pointer                  level 2 dcl 209 set ref 2346 2349* 2355 2355
modes                    10     000100 automatic       bit(36)                  array level 2 dcl 47 set ref 1203* 1505*
mvtr_sw                         000062 internal static bit(1)                   initial unaligned dcl 107 set ref 1271* 1301* 1337*
                                                                                  1368* 1399* 1430* 2324
myname                          000070 constant        char(8)                  initial unaligned dcl 106 set ref 260 268 282* 293
                                                                                  306* 317 324 336 343 362 377* 390 406* 447 455 464
                                                                                  497* 500* 501* 518* 550 2218 2231* 2253* 2260*
                                                                                  2284* 2307* 2341*
next_test                       000177 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 497 506 507 518 524 526
                                                                                  538 539 583* 585 585 603 613* 615 615 642 651* 653
                                                                                  653 671 681* 683 683 701 711* 713 713 733 743* 745
                                                                                  745 764 777* 779 779 796 805* 807 807 825 834* 836
                                                                                  836 855 864* 866 866 885 894* 896 896 913 922* 924
                                                                                  924 945 954* 956 956 973 982* 984 984 1000 1009*
                                                                                  1011 1011 1029 1039* 1041 1041 1059 1068* 1070
                                                                                  1070 1088 1096* 1098 1098 1116 1125* 1127 1127
                                                                                  1147 1155* 1157 1157 1175 1184* 1186 1186 1196
                                                                                  1220 1232* 1234 1234 1256 1269* 1272 1272 1288
                                                                                  1303* 1304 1304 1321 1335* 1338 1338 1353 1366*
                                                                                  1369 1369 1384 1397* 1400 1400 1415 1428* 1431
                                                                                  1431 1446 1458* 1460 1460 1476 1485* 1487 1487
                                                                                  1522 1530* 1532 1532 1548 1557* 1559 1559 1574
                                                                                  1579* 1581 1581 1597 1601* 1603 1603 1619 1623*
                                                                                  1625 1625 1641 1650* 1652 1652 1668 1675* 1677
                                                                                  1677 1693 1705* 1706 1706 1728 1735* 1737 1737
                                                                                  1752 1758* 1760 1760 1776 1783* 1785 1785 1801
                                                                                  1809* 1811 1811 1827 1834* 1836 1836 1852 1862*
                                                                                  1864 1864 1883 1891* 1893 1893 1910 1918* 1920
                                                                                  1920 1937 1950* 1952 1952 1974 1983* 1985 1985
                                                                                  2013 2023* 2025 2025 2054 2064* 2066 2066 2095
                                                                                  2106* 2108 2108 2120 2129* 2131 2131 2150
no_cond                         000244 automatic       bit(1)                   initial unaligned dcl 74 set ref 74* 443* 477
no_display_mc                   000241 automatic       bit(1)                   initial unaligned dcl 74 set ref 74* 234* 505 521*
                                                                                  543* 1197 1499
no_read_permission              000000 stack reference condition                dcl 81 ref 2216 2226
no_write_permission             000346 stack reference condition                dcl 81 ref 1193 1199 1217 1495 1501 1519
null                                                   builtin function         dcl 83 ref 68 223 223 246 485 485 2206 2327 2340
                                                                                  2346 2355 2356 2362 2362
num_expected_cond               000061 internal static fixed bin(17,0)          dcl 105 set ref 495 2379*
num_sel_tests                   000113 automatic       fixed bin(17,0)          dcl 53 set ref 238* 353* 366* 366 367 373 557* 559*
                                                                                  569
num_temps                       000010 internal static fixed bin(17,0)          dcl 103 set ref 592* 621* 659* 689* 719* 727* 751*
                                                                                  785* 813* 843* 872* 902* 935* 963* 989* 1016*
                                                                                  1047* 1076* 1104* 1133* 1163* 1190* 1240* 1277*
                                                                                  1309* 1343* 1374* 1405* 1436* 1465* 1492* 1537*
                                                                                  1564* 1586* 1608* 1630* 1657* 1682* 1711* 1742*
                                                                                  1765* 1790* 1816* 1841* 1869* 1898* 1925* 1958*
                                                                                  1991* 2031* 2072* 2137* 2201 2249 2267 2273 2279
                                                                                  2303
num_to_cycle                    000202 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 237* 340* 594 624 662 692
                                                                                  722 754 788 816 846 876 905 936 964 992 1020 1050
                                                                                  1079 1107 1137 1166 1209 1243 1280 1312 1346 1377
                                                                                  1408 1439 1468 1511 1540 1567 1589 1611 1633 1660
                                                                                  1685 1714 1745 1768 1793 1819 1844 1875 1901 1928
                                                                                  1965 2005 2046 2087 2114 2142
num_to_expect                          parameter       fixed bin(17,0)          dcl 2376 ref 2373 2379 2381
num_to_repeat                   000203 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 237* 321* 453 568
operation                              parameter       fixed bin(17,0)          dcl 2244 ref 2241 2247
pdir                            000121 automatic       char(168)                dcl 63 set ref 1204* 1205* 1506* 1507*
pertinent_info                  000257 automatic       varying char(100)        initial dcl 77 set ref 77* 500 500* 2390*
phcs_$deactivate                000116 constant        entry                    external dcl 126 ref 2228 2257 2281 2304
phcs_$set_kst_attributes        000120 constant        entry                    external dcl 127 ref 2223
program_interrupt               000370 stack reference condition                dcl 81 ref 535
rtrim                                                  builtin function         dcl 83 ref 496 496 2202
scm_str                                based           char(1044449)            unaligned dcl 1700 set ref 1715* 1716*
sel_flag                        000225 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 313* 350* 453
                                                                                  453 507 526 554* 566 601 640 669 699 731 762 794
                                                                                  823 853 883 911 943 971 998 1027 1057 1086 1114
                                                                                  1145 1173 1219 1254 1286 1319 1351 1382 1413 1444
                                                                                  1474 1521 1546 1572 1595 1617 1639 1666 1691 1726
                                                                                  1750 1774 1799 1825 1850 1881 1908 1935 1972 2011
                                                                                  2052 2093 2118 2148
sel_list                        000117 automatic       fixed bin(17,0)          array dcl 59 set ref 241* 355* 367* 373* 560* 569
                                                                                  570
set                             000236 automatic       structure                level 2 packed unaligned dcl 73
stackp                          000214 automatic       pointer                  dcl 67 set ref 2338* 2339*
start                           000432 automatic       fixed bin(21,0)          initial dcl 1702 set ref 1702* 1715 1716
start_idx                       000573 automatic       fixed bin(17,0)          dcl 2376 set ref 2380* 2382 2384 2386 2386 2387*
                                                                                  2387
start_test                      000200 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 237* 272* 278* 547* 549
                                                                                  550* 560 561* 561 562
str                                    based           char                     unaligned dcl 80 set ref 630 631*
substr                                                 builtin function         dcl 83 set ref 365 393 630 631 631 1715* 1716* 2382
                                                                                  2384 2386
sum                             000205 automatic       fixed bin(17,0)          dcl 65 set ref 1244*
targ                                   based           char                     unaligned dcl 54 set ref 263 263 272* 276 282* 288
                                                                                  297* 300 306* 312 312 321* 324* 330 330 340* 343*
                                                                                  349 349 349 365 367* 371 377* 384 384 393 395* 400
                                                                                  406* 416 424 427 427 430 430 432 432 435 435 443
                                                                                  443 447*
tc                              000234 automatic       fixed bin(17,0)          dcl 71 set ref 258* 263 263 266* 272 272 276 282 282
                                                                                  288 291* 297 297 300 306 306 312 312 315* 321 321
                                                                                  324 324 330 330 333* 340 340 343 343 349 349 349
                                                                                  360* 365 367 367 371 377 377 384 384 388* 393 395
                                                                                  395 400 406 406 416 424 427 427 430 430 432 432
                                                                                  435 435 443 443 447 447
temp_data                              based           char                     unaligned dcl 55 set ref 1874* 2039* 2043* 2080*
                                                                                  2084*
temp_data_ptr                   000114 automatic       pointer                  dcl 56 set ref 1998* 2001 2038* 2039 2042* 2043
                                                                                  2079* 2080 2083* 2084
temp_data_size                  000116 automatic       fixed bin(21,0)          dcl 57 set ref 1873* 1874 1999* 2000 2037* 2039
                                                                                  2041* 2043 2078* 2080 2082* 2084
temp_words                             based           bit(36)                  array unaligned dcl 58 set ref 2001*
tempseg_ptr                     000064 internal static pointer                  initial array dcl 109 set ref 246* 596* 629* 664*
                                                                                  694* 724* 756* 818* 848* 939* 967* 1022* 1139*
                                                                                  1212* 1248* 1470* 1514* 1542* 1591* 1613* 1635*
                                                                                  1662* 1687* 1715 1716 1721* 1770* 1795* 1821*
                                                                                  1846* 1874 1877* 1903* 1930* 1961* 1968* 1968*
                                                                                  1998 2007* 2038 2042 2048* 2079 2083 2089* 2144*
                                                                                  2203* 2206 2223 2223 2228* 2251* 2257* 2269* 2275*
                                                                                  2281* 2304* 2327 2327*
term_$refname                   000114 constant        entry                    external dcl 125 ref 938 966 1967
test_data1_$                    000156 external static fixed bin(17,0)          dcl 142 set ref 236
test_data1p                     000220 automatic       pointer                  dcl 67 set ref 236* 596* 967* 1022* 1108*
test_name                       000072 constant        varying char(40)         initial array dcl 93 set ref 276 300 371 400 419*
                                                                                  497* 518* 1196*
tmlr_ptr                        000222 automatic       pointer                  initial dcl 68 set ref 68* 629* 630 631
to_flag                         000227 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 289* 453 545
                                                                                  548
tp                              000232 automatic       pointer                  dcl 70 set ref 258* 263 263 266* 272 276 282 288
                                                                                  291* 297 300 306 312 312 315* 321 324 330 330 333*
                                                                                  340 343 349 349 349 360* 365 367 371 377 384 384
                                                                                  388* 393 395 400 406 416 424 427 427 430 430 432
                                                                                  432 435 435 443 443 447
tries                           000211 automatic       fixed bin(17,0)          dcl 66 set ref 1195 1206* 1206 1210* 1497 1508* 1508
                                                                                  1512*
unspec                                                 builtin function         dcl 83 set ref 2213*
value                     1(09) 000236 automatic       structure                level 2 packed unaligned dcl 73
zero                     11     000100 automatic       bit(36)                  initial array level 2 dcl 47 set ref 47*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
TRUNCATE                               internal static fixed bin(17,0)          initial dcl 112
kstap                                  automatic       pointer                  dcl 2-3

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_ARG                         005431 constant        label                    dcl 464 ref 261 269 294 318 326 337 345 363 391 448
                                                                                  456
CLEANUP                         017660 constant        entry                    internal dcl 2320 ref 217 2315
END_COND                        006142 constant        label                    dcl 529 ref 488
HREGS                           020131 constant        label                    dcl 2353 ref 2348
OP                              000064 constant        label                    array(4) dcl 2249 ref 2247
START                           005526 constant        label                    dcl 477 ref 460
USAGE                           005461 constant        label                    dcl 467 ref 424
command_loop                    003466 constant        label                    dcl 263 ref 365 393
display_mc                      017763 constant        entry                    internal dcl 2335 ref 505 523 1197 1499
done                            017007 constant        label                    dcl 2315 ref 506 524 575 603 642 671 701 733 764 796
                                                                                  825 855 885 913 945 973 1000 1029 1059 1088 1116
                                                                                  1147 1175 1220 1256 1288 1321 1353 1384 1415 1446
                                                                                  1476 1522 1548 1574 1597 1619 1641 1668 1693 1728
                                                                                  1752 1776 1801 1827 1852 1883 1910 1937 1974 2013
                                                                                  2054 2095 2120 2150 2220
exclude1                        006504 constant        label                    dcl 601 ref 585
exclude10                       010051 constant        label                    dcl 883 ref 866
exclude11                       010153 constant        label                    dcl 911 ref 896
exclude12                       010304 constant        label                    dcl 943 ref 924
exclude13                       010430 constant        label                    dcl 971 ref 956
exclude14                       010535 constant        label                    dcl 998 ref 984
exclude15                       010660 constant        label                    dcl 1027 ref 1011
exclude16                       010761 constant        label                    dcl 1057 ref 1041
exclude17                       011071 constant        label                    dcl 1086 ref 1070
exclude18                       011177 constant        label                    dcl 1114 ref 1098
exclude19                       011320 constant        label                    dcl 1145 ref 1127
exclude2                        006714 constant        label                    dcl 640 ref 615
exclude20                       011421 constant        label                    dcl 1173 ref 1157
exclude21                       011715 constant        label                    dcl 1217 ref 1186 1200
exclude22                       012054 constant        label                    dcl 1254 ref 1234
exclude23                       012153 constant        label                    dcl 1286 ref 1272
exclude24                       012251 constant        label                    dcl 1319 ref 1304
exclude25                       012347 constant        label                    dcl 1351 ref 1338
exclude26                       012445 constant        label                    dcl 1382 ref 1369
exclude27                       012543 constant        label                    dcl 1413 ref 1400
exclude28                       012641 constant        label                    dcl 1444 ref 1431
exclude29                       012756 constant        label                    dcl 1474 ref 1460
exclude3                        007036 constant        label                    dcl 669 ref 653
exclude30                       013247 constant        label                    dcl 1519 ref 1487 1502
exclude31                       013366 constant        label                    dcl 1546 ref 1532
exclude32                       013467 constant        label                    dcl 1572 ref 1559
exclude33                       013610 constant        label                    dcl 1595 ref 1581
exclude34                       013716 constant        label                    dcl 1617 ref 1603
exclude35                       014024 constant        label                    dcl 1639 ref 1625
exclude36                       014142 constant        label                    dcl 1666 ref 1652
exclude37                       014254 constant        label                    dcl 1691 ref 1677
exclude38                       014412 constant        label                    dcl 1726 ref 1706
exclude39                       014517 constant        label                    dcl 1750 ref 1737
exclude4                        007160 constant        label                    dcl 699 ref 683
exclude40                       014636 constant        label                    dcl 1774 ref 1760
exclude41                       014754 constant        label                    dcl 1799 ref 1785
exclude42                       015072 constant        label                    dcl 1825 ref 1811
exclude43                       015214 constant        label                    dcl 1850 ref 1836
exclude44                       015344 constant        label                    dcl 1881 ref 1864
exclude45                       015462 constant        label                    dcl 1908 ref 1893
exclude46                       015600 constant        label                    dcl 1935 ref 1920
exclude47                       015772 constant        label                    dcl 1972 ref 1952
exclude48                       016150 constant        label                    dcl 2011 ref 1985
exclude49                       016320 constant        label                    dcl 2052 ref 2025
exclude5                        007272 constant        label                    dcl 731 ref 713
exclude50                       016474 constant        label                    dcl 2093 ref 2066
exclude51                       016566 constant        label                    dcl 2118 ref 2108
exclude52                       016716 constant        label                    dcl 2148 ref 2131
exclude6                        007410 constant        label                    dcl 762 ref 745
exclude7                        007515 constant        label                    dcl 794 ref 779
exclude8                        007632 constant        label                    dcl 823 ref 807
exclude9                        007744 constant        label                    dcl 853 ref 836
link_err                        017230 constant        label                    dcl 2218
make_tempsegs                   017015 constant        entry                    internal dcl 2195 ref 593 622 660 690 720 728 752
                                                                                  786 814 844 873 903 937 965 990 1017 1048 1077
                                                                                  1105 1134 1164 1191 1241 1278 1310 1344 1375 1406
                                                                                  1437 1466 1493 1538 1565 1587 1609 1631 1658 1683
                                                                                  1712 1743 1766 1791 1817 1842 1870 1899 1926 1959
                                                                                  1993 2033 2074 2139
notempseg                       017155 constant        label                    dcl 2208
prepare_segment                 017355 constant        entry                    internal dcl 2241 ref 595 598 625 635 639 663 667
                                                                                  693 697 723 755 759 792 817 821 847 851 880 909
                                                                                  940 968 996 1021 1025 1054 1083 1111 1138 1142
                                                                                  1170 1211 1215 1245 1247 1252 1284 1316 1349 1380
                                                                                  1411 1442 1469 1472 1513 1516 1541 1544 1570 1590
                                                                                  1593 1612 1615 1634 1637 1661 1664 1686 1689 1720
                                                                                  1724 1748 1769 1772 1794 1797 1820 1823 1845 1848
                                                                                  1871 1876 1879 1902 1905 1929 1932 1963 1966 1970
                                                                                  1994 2006 2009 2034 2047 2050 2075 2088 2091 2140
                                                                                  2143 2146
sel_loop                        006363 constant        label                    dcl 571 ref 508 527 601 640 669 699 731 762 794 823
                                                                                  853 883 911 943 971 998 1027 1057 1086 1114 1145
                                                                                  1173 1219 1254 1286 1319 1351 1382 1413 1444 1474
                                                                                  1521 1546 1572 1595 1617 1639 1666 1691 1726 1750
                                                                                  1774 1799 1825 1850 1881 1908 1935 1972 2011 2052
                                                                                  2093 2118 2148
set_up_conds                    020217 constant        entry                    internal dcl 2373 ref 589 619 657 687 717 749 783
                                                                                  811 840 870 900 928 960 988 1015 1045 1074 1102
                                                                                  1131 1161 1238 1276 1308 1342 1373 1404 1435 1464
                                                                                  1491 1536 1563 1585 1607 1629 1656 1681 1710 1741
                                                                                  1764 1789 1815 1840 1868 1897 1924 1956 1989 2029
                                                                                  2070 2112 2135
start_join                      006152 constant        label                    dcl 535 ref 477
test                            000000 constant        label                    array(52) dcl 583 ref 507 526 539 566 570
test_cpu                        003230 constant        entry                    external dcl 12
test_cpu$deactivate_tempseg     016725 constant        entry                    external dcl 2297

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     21570       22124   20405       21600
Length     23004   20405       334         644    1163          66

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
test_cpu                            738 external procedure  is an external procedure.  
on unit on line 217                  64 on unit               
on unit on line 480                 149 on unit               
on unit on line 535                  84 on unit               
on unit on line 1193                120 on unit             enables or reverts conditions.  
on unit on line 1495                114 on unit             enables or reverts conditions.  
make_tempsegs                       132 internal procedure  enables or reverts conditions.  
on unit on line 2216                 92 on unit               
prepare_segment                         internal procedure  shares stack frame of external procedure test_cpu.  
CLEANUP                              88 internal procedure  is called by several nonquick procedures.  
display_mc                           95 internal procedure  is called by several nonquick procedures.  
set_up_conds                            internal procedure  shares stack frame of external procedure test_cpu.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 num_temps                   test_cpu
000011 expected_condition          test_cpu
000061 num_expected_cond           test_cpu
000062 mvtr_sw                     test_cpu
000064 tempseg_ptr                 test_cpu
000072 TRUNC_and_DEACT             test_cpu
000073 DELETE                      test_cpu
000074 DEACT                       test_cpu

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
CLEANUP                  000100 idx                         CLEANUP
make_tempsegs            000100 i                           make_tempsegs
test_cpu                 000100 ACL                         test_cpu
                         000113 num_sel_tests               test_cpu
                         000114 temp_data_ptr               test_cpu
                         000116 temp_data_size              test_cpu
                         000117 long_sw                     test_cpu
                         000117 excl_list                   test_cpu
                         000117 sel_list                    test_cpu
                         000120 line_length                 test_cpu
                         000121 pdir                        test_cpu
                         000173 argcount                    test_cpu
                         000174 i                           test_cpu
                         000175 j                           test_cpu
                         000176 k                           test_cpu
                         000177 next_test                   test_cpu
                         000200 start_test                  test_cpu
                         000201 last_test                   test_cpu
                         000202 num_to_cycle                test_cpu
                         000203 num_to_repeat               test_cpu
                         000204 COND                        test_cpu
                         000205 sum                         test_cpu
                         000206 RPT                         test_cpu
                         000207 SEL                         test_cpu
                         000210 CYCL                        test_cpu
                         000211 tries                       test_cpu
                         000212 hreg_ptr                    test_cpu
                         000214 stackp                      test_cpu
                         000216 faultsp                     test_cpu
                         000220 test_data1p                 test_cpu
                         000222 tmlr_ptr                    test_cpu
                         000224 TERM                        test_cpu
                         000225 sel_flag                    test_cpu
                         000226 from_flag                   test_cpu
                         000227 to_flag                     test_cpu
                         000230 cycle_flag                  test_cpu
                         000231 found_arg                   test_cpu
                         000232 tp                          test_cpu
                         000234 tc                          test_cpu
                         000235 code                        test_cpu
                         000236 akst                        test_cpu
                         000241 no_display_mc               test_cpu
                         000242 h_sw                        test_cpu
                         000243 mc_sw                       test_cpu
                         000244 no_cond                     test_cpu
                         000245 brief_sw                    test_cpu
                         000246 hreg_state                  test_cpu
                         000247 int_cond_name               test_cpu
                         000257 pertinent_info              test_cpu
                         000311 FCO_required                test_cpu
                         000344 cond_infop                  test_cpu
                         000376 STR                         test_cpu
                         000400 cond_info                   test_cpu
                         000432 start                       test_cpu
                         000433 idx                         test_cpu
                         000556 idx                         prepare_segment
                         000572 idx                         set_up_conds
                         000573 start_idx                   set_up_conds
                         000574 end_idx                     set_up_conds

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             alloc_auto_adj      enable              shorten_stack       ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           cpu_tests_$acv_restart        cpu_tests_$acv_restart_csl
cpu_tests_$bad_fill           cpu_tests_$ci_mod_case_2      cpu_tests_$cmpb_onc           cpu_tests_$cmpb_with_rotate
cpu_tests_$cmpb_with_sixbit_offset                          cpu_tests_$cmpc               cpu_tests_$cmpc7
cpu_tests_$cmpc_a             cpu_tests_$cmpc_adj_len       cpu_tests_$cmpc_b             cpu_tests_$cmpc_pgbnd
cpu_tests_$cmpc_zero_ind      cpu_tests_$cmpn_tst           cpu_tests_$csl_onc            cpu_tests_$csl_oob
cpu_tests_$csl_pgflt          cpu_tests_$csl_test           cpu_tests_$extra_fill         cpu_tests_$itp_mod
cpu_tests_$mlr_tst            cpu_tests_$mlrstern           cpu_tests_$mpy_ofl            cpu_tests_$mvn
cpu_tests_$mvn_ofl            cpu_tests_$mvnoosb            cpu_tests_$mvt_tst_ascii_to_bcd
cpu_tests_$mvt_tst_ascii_to_ebcdic                          cpu_tests_$mvt_tst_bcd_to_ascii
cpu_tests_$mvt_tst_ebcdic_to_ascii                          cpu_tests_$mvt_tst_four_to_nine
cpu_tests_$mvt_tst_nine_to_four                             cpu_tests_$mvt_tst_release_t_segs
cpu_tests_$rpd_test           cpu_tests_$rpt_test_evn       cpu_tests_$rpt_test_odd       cpu_tests_$scd_con_flt
cpu_tests_$scd_oob_tst        cpu_tests_$scm_pgflt          cpu_tests_$scm_tally          cpu_tests_$scm_tro
cpu_tests_$sreg               cpu_tests_$sreg_no_write      cpu_tests_$tct                cpu_tests_$test_ci
cpu_tests_$test_cmpc_fill     cpu_tests_$test_sc2           cpu_tests_$test_xed           cpu_tests_$tmlr
cpu_tests_$tnz                cpu_tests_$xed_dirflt_even    cpu_tests_$xed_dirflt_odd     cu_$arg_count
cu_$arg_ptr                   cu_$stack_frame_ptr           cv_dec_check_                 delete_$ptr
dump_machine_cond_            find_condition_frame_         find_condition_info_          get_group_id_
get_line_length_$switch       get_pdir_                     hcs_$add_acl_entries          hcs_$history_regs_get
hcs_$history_regs_set         hcs_$make_seg                 hcs_$set_max_length_seg       hcs_$truncate_seg
hran_$hranl                   ioa_                          phcs_$deactivate              phcs_$set_kst_attributes
term_$refname

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cpu_tests_$tmlr_data          test_data1_$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     47 003155        59 003162        60 003166        61 003172        64 003173        68 003204        69 003206
     74 003214        77 003221        78 003222      1702 003223        12 003227       217 003236       223 003260
    224 003275       226 003301       229 003303       230 003312       232 003326       233 003327       234 003330
    236 003332       237 003335       238 003341       240 003344       241 003353       242 003355       243 003361
    245 003363       246 003371       247 003376       255 003400       257 003407       258 003417       259 003434
    260 003436       261 003465       263 003466       265 003500       266 003501       267 003516       268 003520
    269 003547       272 003550       273 003575       274 003577       275 003601       276 003613       277 003624
    278 003626       280 003630       281 003632       282 003634       283 003673       286 003674       288 003675
    289 003701       290 003703       291 003704       292 003721       293 003723       294 003752       297 003753
    298 004000       299 004002       300 004013       301 004024       302 004026       304 004030       305 004032
    306 004034       307 004073       310 004074       312 004075       313 004105       314 004107       315 004110
    316 004125       317 004127       318 004156       321 004157       323 004204       324 004206       326 004243
    328 004244       330 004245       331 004255       332 004256       333 004260       335 004275       336 004277
    337 004326       340 004327       342 004354       343 004356       345 004413       347 004414       349 004415
    350 004431       351 004433       353 004434       354 004435       355 004445       356 004451       359 004453
    360 004463       361 004500       362 004502       363 004534       365 004535       366 004542       367 004543
    368 004572       369 004574       370 004575       371 004607       372 004620       373 004622       375 004626
    376 004630       377 004632       378 004671       381 004672       382 004674       384 004675       385 004705
    387 004706       388 004715       389 004732       390 004734       391 004762       393 004763       395 004770
    397 005015       398 005017       399 005020       400 005031       401 005042       402 005044       404 005047
    405 005051       406 005053       407 005112       411 005113       412 005122       413 005124       416 005125
    417 005131       418 005146       419 005155       420 005202       421 005204       424 005205       427 005211
    430 005224       432 005237       435 005252       437 005262       438 005265       439 005274       440 005310
    443 005311       447 005324       448 005362       452 005363       453 005365       455 005400       456 005427
    460 005430       464 005431       466 005460       467 005461       469 005475       471 005511       473 005525
    477 005526       480 005530       483 005544       484 005546       485 005550       486 005564       488 005571
    495 005627       496 005642       497 005705       500 005736       501 005767       504 006020       505 006023
    506 006032       507 006041       508 006050       510 006053       518 006055       521 006107       522 006111
    523 006114       524 006121       526 006130       527 006137       529 006142       532 006151       535 006152
    538 006166       539 006211       543 006216       545 006223       547 006231       548 006235       549 006241
    550 006244       551 006302       554 006303       556 006305       557 006306       558 006307       559 006321
    560 006322       561 006326       562 006327       563 006334       566 006336       568 006340       569 006347
    570 006362       571 006363       573 006365       575 006367       583 006370       585 006372       587 006377
    589 006415       592 006434       593 006437       594 006443       595 006453       596 006462       597 006473
    598 006475       601 006504       603 006506       613 006511       615 006513       617 006520       619 006541
    621 006547       622 006552       624 006556       625 006565       627 006574       628 006601       629 006605
    630 006622       631 006632       634 006667       635 006670       636 006677       637 006701       638 006703
    639 006705       640 006714       642 006716       651 006721       653 006723       655 006730       657 006751
    659 006770       660 006773       662 006777       663 007007       664 007016       665 007025       667 007027
    669 007036       671 007040       681 007043       683 007045       685 007052       687 007073       689 007112
    690 007115       692 007121       693 007131       694 007140       695 007147       697 007151       699 007160
    701 007162       711 007165       713 007167       715 007174       717 007212       719 007225       720 007230
    722 007234       723 007243       724 007252       725 007261       727 007263       728 007266       731 007272
    733 007274       743 007277       745 007301       747 007306       749 007327       751 007342       752 007345
    754 007351       755 007361       756 007370       757 007377       759 007401       762 007410       764 007412
    777 007415       779 007417       781 007424       783 007445       785 007460       786 007463       788 007467
    789 007477       790 007504       792 007506       794 007515       796 007517       805 007522       807 007524
    809 007531       811 007552       813 007565       814 007570       816 007574       817 007603       818 007612
    819 007621       821 007623       823 007632       825 007634       834 007637       836 007641       838 007646
    840 007664       843 007677       844 007702       846 007706       847 007715       848 007724       849 007733
    851 007735       853 007744       855 007746       864 007751       866 007753       868 007760       870 010001
    872 010014       873 010017       876 010023       877 010033       878 010040       880 010042       883 010051
    885 010053       894 010056       896 010060       898 010065       900 010103       902 010116       903 010121
    905 010125       906 010135       907 010142       909 010144       911 010153       913 010155       922 010160
    924 010162       926 010167       928 010210       935 010227       936 010232       937 010241       938 010245
    939 010264       940 010273       941 010302       943 010304       945 010306       954 010311       956 010313
    958 010320       960 010336       963 010351       964 010354       965 010363       966 010367       967 010406
    968 010417       969 010426       971 010430       973 010432       982 010435       984 010437       986 010444
    988 010465       989 010500       990 010503       992 010507       993 010517       994 010524       996 010526
    998 010535      1000 010537      1009 010542      1011 010544      1013 010551      1015 010572      1016 010611
   1017 010614      1020 010620      1021 010627      1022 010636      1023 010647      1025 010651      1027 010660
   1029 010662      1039 010665      1041 010667      1043 010674      1045 010712      1047 010725      1048 010730
   1050 010734      1051 010743      1052 010750      1054 010752      1057 010761      1059 010763      1068 010766
   1070 010770      1072 010775      1074 011016      1076 011035      1077 011040      1079 011044      1080 011053
   1081 011060      1083 011062      1086 011071      1088 011073      1096 011076      1098 011100      1100 011105
   1102 011126      1104 011141      1105 011144      1107 011150      1108 011157      1109 011166      1111 011170
   1114 011177      1116 011201      1125 011204      1127 011206      1129 011213      1131 011234      1133 011253
   1134 011256      1137 011262      1138 011271      1139 011300      1140 011307      1142 011311      1145 011320
   1147 011322      1155 011325      1157 011327      1159 011334      1161 011352      1163 011365      1164 011370
   1166 011374      1167 011403      1168 011410      1170 011412      1173 011421      1175 011423      1184 011426
   1186 011430      1188 011435      1190 011456      1191 011461      1193 011465      1195 011501      1196 011505
   1197 011526      1199 011536      1200 011537      1202 011542      1203 011565      1204 011601      1205 011610
   1206 011652      1207 011654      1209 011655      1210 011665      1211 011666      1212 011675      1213 011704
   1215 011706      1217 011715      1219 011716      1220 011720      1232 011723      1234 011725      1236 011732
   1238 011750      1240 011767      1241 011772      1243 011776      1244 012005      1245 012006      1246 012015
   1247 012023      1248 012032      1249 012041      1250 012043      1252 012045      1254 012054      1256 012056
   1269 012061      1271 012063      1272 012066      1274 012073      1276 012110      1277 012116      1278 012121
   1280 012125      1281 012135      1282 012142      1284 012144      1286 012153      1288 012155      1301 012160
   1303 012163      1304 012165      1306 012172      1308 012207      1309 012215      1310 012220      1312 012224
   1313 012233      1314 012240      1316 012242      1319 012251      1321 012253      1335 012256      1337 012260
   1338 012263      1340 012270      1342 012305      1343 012313      1344 012316      1346 012322      1347 012331
   1348 012336      1349 012340      1351 012347      1353 012351      1366 012354      1368 012356      1369 012361
   1371 012366      1373 012403      1374 012411      1375 012414      1377 012420      1378 012427      1379 012434
   1380 012436      1382 012445      1384 012447      1397 012452      1399 012454      1400 012457      1402 012464
   1404 012501      1405 012507      1406 012512      1408 012516      1409 012525      1410 012532      1411 012534
   1413 012543      1415 012545      1428 012550      1430 012552      1431 012555      1433 012562      1435 012577
   1436 012605      1437 012610      1439 012614      1440 012623      1441 012630      1442 012632      1444 012641
   1446 012643      1458 012646      1460 012650      1462 012655      1464 012676      1465 012711      1466 012714
   1468 012720      1469 012727      1470 012736      1471 012745      1472 012747      1474 012756      1476 012760
   1485 012763      1487 012765      1489 012772      1491 013010      1492 013016      1493 013021      1495 013025
   1497 013041      1498 013045      1499 013060      1501 013070      1502 013071      1504 013074      1505 013117
   1506 013133      1507 013142      1508 013204      1509 013206      1511 013207      1512 013217      1513 013220
   1514 013227      1515 013236      1516 013240      1519 013247      1521 013250      1522 013252      1530 013255
   1532 013257      1534 013264      1536 013305      1537 013320      1538 013323      1540 013327      1541 013337
   1542 013346      1543 013355      1544 013357      1546 013366      1548 013370      1557 013373      1559 013375
   1561 013402      1563 013420      1564 013433      1565 013436      1567 013442      1568 013451      1569 013456
   1570 013460      1572 013467      1574 013471      1579 013474      1581 013476      1583 013503      1585 013524
   1586 013543      1587 013546      1589 013552      1590 013561      1591 013570      1592 013577      1593 013601
   1595 013610      1597 013612      1601 013615      1603 013617      1605 013624      1607 013642      1608 013650
   1609 013653      1611 013657      1612 013667      1613 013676      1614 013705      1615 013707      1617 013716
   1619 013720      1623 013723      1625 013725      1627 013732      1629 013750      1630 013756      1631 013761
   1633 013765      1634 013775      1635 014004      1636 014013      1637 014015      1639 014024      1641 014026
   1650 014031      1652 014033      1654 014040      1656 014061      1657 014074      1658 014077      1660 014103
   1661 014113      1662 014122      1663 014131      1664 014133      1666 014142      1668 014144      1675 014147
   1677 014151      1679 014156      1681 014174      1682 014207      1683 014212      1685 014216      1686 014225
   1687 014234      1688 014243      1689 014245      1691 014254      1693 014256      1705 014261      1706 014263
   1708 014270      1710 014311      1711 014324      1712 014327      1714 014333      1715 014343      1716 014351
   1719 014354      1720 014361      1721 014370      1722 014377      1723 014401      1724 014403      1726 014412
   1728 014414      1735 014417      1737 014421      1739 014426      1741 014447      1742 014462      1743 014465
   1745 014471      1746 014501      1747 014506      1748 014510      1750 014517      1752 014521      1758 014524
   1760 014526      1762 014533      1764 014551      1765 014570      1766 014573      1768 014577      1769 014607
   1770 014616      1771 014625      1772 014627      1774 014636      1776 014640      1783 014643      1785 014645
   1787 014652      1789 014670      1790 014707      1791 014712      1793 014716      1794 014725      1795 014734
   1796 014743      1797 014745      1799 014754      1801 014756      1809 014761      1811 014763      1813 014770
   1815 015011      1816 015024      1817 015027      1819 015033      1820 015043      1821 015052      1822 015061
   1823 015063      1825 015072      1827 015074      1834 015077      1836 015101      1838 015106      1840 015127
   1841 015146      1842 015151      1844 015155      1845 015165      1846 015174      1847 015203      1848 015205
   1850 015214      1852 015216      1862 015221      1864 015223      1866 015230      1868 015246      1869 015261
   1870 015264      1871 015270      1873 015277      1874 015301      1875 015306      1876 015315      1877 015324
   1878 015333      1879 015335      1881 015344      1883 015346      1891 015351      1893 015353      1895 015360
   1897 015401      1898 015414      1899 015417      1901 015423      1902 015433      1903 015442      1904 015451
   1905 015453      1908 015462      1910 015464      1918 015467      1920 015471      1922 015476      1924 015517
   1925 015532      1926 015535      1928 015541      1929 015551      1930 015560      1931 015567      1932 015571
   1935 015600      1937 015602      1950 015605      1952 015607      1954 015614      1956 015635      1958 015654
   1959 015657      1961 015663      1963 015700      1965 015707      1966 015717      1967 015726      1968 015750
   1969 015761      1970 015763      1972 015772      1974 015774      1983 015777      1985 016001      1987 016006
   1989 016027      1991 016051      1993 016054      1994 016060      1998 016067      1999 016073      2000 016075
   2001 016103      2002 016110      2005 016112      2006 016121      2007 016130      2008 016137      2009 016141
   2011 016150      2013 016152      2023 016155      2025 016157      2027 016164      2029 016202      2031 016221
   2033 016224      2034 016230      2037 016237      2038 016241      2039 016245      2041 016250      2042 016252
   2043 016256      2046 016262      2047 016271      2048 016300      2049 016307      2050 016311      2052 016320
   2054 016322      2064 016325      2066 016327      2068 016334      2070 016355      2072 016374      2074 016377
   2075 016403      2078 016412      2079 016414      2080 016420      2082 016423      2083 016425      2084 016431
   2087 016435      2088 016445      2089 016454      2090 016463      2091 016465      2093 016474      2095 016476
   2106 016501      2108 016503      2110 016510      2112 016531      2114 016550      2115 016557      2116 016564
   2118 016566      2120 016570      2129 016573      2131 016575      2133 016602      2135 016623      2137 016642
   2139 016645      2140 016651      2142 016660      2143 016667      2144 016676      2145 016705      2146 016707
   2148 016716      2150 016720      2297 016723      2303 016733      2304 016743      2306 016755      2307 016757
   2308 017003      2310 017004      2312 017006      2315 017007      2318 017013      2195 017014      2201 017022
   2202 017031      2203 017071      2206 017145      2208 017155      2210 017203      2213 017204      2214 017210
   2216 017214      2218 017230      2220 017256      2223 017261      2226 017305      2228 017306      2230 017322
   2231 017325      2232 017351      2235 017352      2236 017354      2241 017355      2247 017357      2249 017361
   2251 017371      2252 017407      2253 017411      2254 017440      2257 017441      2259 017453      2260 017455
   2261 017501      2263 017502      2265 017504      2267 017505      2269 017515      2270 017550      2271 017552
   2273 017553      2275 017563      2276 017600      2277 017602      2279 017603      2281 017613      2283 017625
   2284 017627      2285 017653      2287 017654      2288 017656      2320 017657      2324 017665      2326 017673
   2327 017701      2328 017742      2330 017744      2331 017761      2335 017762      2338 017770      2339 017777
   2340 020011      2341 020016      2342 020036      2345 020037      2346 020054      2348 020061      2349 020063
   2350 020103      2353 020131      2355 020134      2356 020143      2357 020147      2358 020163      2361 020164
   2362 020200      2365 020216      2373 020217      2379 020221      2380 020224      2381 020226      2382 020235
   2384 020256      2386 020272      2387 020305      2388 020307      2390 020311      2391 020323      2393 020364
   2394 020366


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
