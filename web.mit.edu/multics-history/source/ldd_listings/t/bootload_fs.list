	COMPILATION LISTING OF SEGMENT bootload_fs
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1022.9 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 bootload_fs:
        7      procedure options (variable);
        8 						/* format: style4,indattr,insnl,delnl */
        9 
       10 /* command interface to bootload_fs_ for service use.
       11*   Benson I. Margulies November 1980
       12*   Miscelaneous fixes and renaming, Keith Loepere, May 1984.	*/
       13 
       14 dcl  bootload_fs_$init      entry (bit (1) aligned, fixed bin (19), fixed bin (35));
       15 dcl  bootload_fs_$get       entry (char (*), ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       16 dcl  bootload_fs_$put       entry (char (*), ptr, fixed bin (21), bit (1) aligned, fixed bin (35));
       17 dcl  bootload_fs_$list      entry (area (*), ptr, fixed bin (35));
       18 dcl  bootload_fs_$delete    entry (char (*), fixed bin (35));
       19 dcl  bootload_fs_$rename    entry (char (*), char (*), fixed bin (35));
       20 
       21 dcl  hcs_$fs_get_seg_ptr    entry (char (*), ptr, fixed bin (35));
       22 dcl  hcs_$make_seg	        entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
       23 dcl  initiate_file_	        entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
       24 dcl  initiate_file_$create  entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
       25 dcl  terminate_file_        entry (ptr, fixed bin (24), bit (*), fixed bin (35));
       26 dcl  cu_$af_arg_count       entry (fixed bin, fixed bin (35));
       27 dcl  cu_$arg_ptr	        entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       28 dcl  expand_pathname_       entry (char (*), char (*), char (*), fixed bin (35));
       29 dcl  expand_pathname_$add_suffix
       30 		        entry (char (*), char (*), char (*), char (*), fixed bin (35));
       31 dcl  get_pdir_	        entry () returns (char (168));
       32 dcl  get_system_free_area_  entry () returns (ptr);
       33 dcl  command_query_	        entry () options (variable);
       34 dcl  com_err_	        entry () options (variable);
       35 dcl  com_err_$suppress_name entry () options (variable);
       36 dcl  mdc_$pvname_info       entry (char (*), bit (36) aligned, char (*), bit (36) aligned, fixed bin, fixed bin (35));
       37 dcl  hphcs_$read_partition  entry (bit (36) aligned, char (*), fixed bin (35), pointer, fixed bin (18), fixed bin (35));
       38 dcl  hphcs_$write_partition entry (bit (36) aligned, char (*), fixed bin (35), pointer, fixed bin (18), fixed bin (35));
       39 dcl  adjust_bit_count_      entry (char (168) aligned, char (32) aligned, bit (1) aligned, fixed bin (35), fixed bin (35))
       40 		        ;
       41 dcl  ioa_		        entry () options (variable);
       42 dcl  cv_dec_check_	        entry (char (*), fixed bin (35)) returns (fixed bin (35));
       43 
       44 dcl  char_count	        fixed bin (21);
       45 dcl  seg_bits	        bit (bit_count) unal based;
       46 dcl  bit_count_for_abc      fixed bin (35);
       47 dcl  new_part_length        fixed bin (19);
       48 dcl  bit_count	        fixed bin (24);
       49 dcl  part_name	        char (4) unal;
       50 dcl  answer	        char (32) varying;
       51 dcl  pv_name	        char (32);
       52 dcl  lvname	        char (32);
       53 dcl  (t_pvid, lvid)	        bit (36) aligned;
       54 dcl  device_type	        fixed bin;
       55 dcl  code		        fixed bin (35);
       56 dcl  file_name	        char (32);
       57 dcl  dir_name	        char (168);
       58 dcl  entryname	        char (32);
       59 dcl  which_key	        fixed bin;
       60 dcl  ap		        pointer;
       61 dcl  al		        fixed bin (21);
       62 dcl  argument	        char (al) based (ap);
       63 dcl  areap	        pointer;
       64 dcl  force	        bit (1);
       65 dcl  must_be_new	        bit (1) aligned;
       66 dcl  part_length	        fixed bin (18);
       67 dcl  current_argument       fixed bin;
       68 dcl  an_area	        based (areap) area (1024);
       69 dcl  seg_ptr	        pointer;
       70 dcl  n_arguments	        fixed bin;
       71 dcl  n_key_arguments        fixed bin;
       72 dcl  i		        fixed bin;
       73 
       74 
  1     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  1     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  1     3 /*	version number changed to 4, 08/10/78 WOS */
  1     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  1     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  1     6 
  1     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  1     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  1     9     2 switches aligned,                                     /* various bit switch values */
  1    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  1    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  1    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  1    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  1    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  1    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  1    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  1    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  1    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  1    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  1    20 
  1    21 /*  Limit of data defined for version 2 */
  1    22 
  1    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  1    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  1    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  1    26 						/* minimum of 30 seconds required for repeat */
  1    27 						/* otherwise, no repeat will occur */
  1    28 /* Limit of data defined for version 4 */
  1    29 
  1    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  1    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  1    32 
  1    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  1    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  1    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  1    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  1    37 
  1    38 /*	END INCLUDE FILE query_info.incl.pl1 */
       75 
  2     1 /*  START OF:	bootload_fs_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 /*  BIM  Nobember 80 */
  2     3 
  2     4 declare bootload_fs_list_ptr pointer;
  2     5 
  2     6 declare 1 bootload_fs_list aligned based (bootload_fs_list_ptr),
  2     7         2 n_files fixed bin,
  2     8         2 files (bootload_fs_list_n_files refer (n_files)) aligned,
  2     9 	3 name char (32) unal,
  2    10 	3 length fixed bin (21);
  2    11 
  2    12 declare bootload_fs_list_n_files fixed bin;
  2    13 
  2    14 /*  END OF:	bootload_fs_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
       77 
  4     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  4     2 /* format: style2,^inddcls,idind32 */
  4     3 
  4     4 declare 1 terminate_file_switches	based,
  4     5 	2 truncate		bit (1) unaligned,
  4     6 	2 set_bc			bit (1) unaligned,
  4     7 	2 terminate		bit (1) unaligned,
  4     8 	2 force_write		bit (1) unaligned,
  4     9 	2 delete			bit (1) unaligned;
  4    10 
  4    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  4    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  4    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  4    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  4    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  4    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  4    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  4    18 
  4    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
       78 
       79 
       80 
       81 
       82 dcl  sys_info$max_seg_size  fixed bin (35) ext static;
       83 dcl  (cleanup, bootload_fs_bad_arg_parse)
       84 		        condition;
       85 dcl  (
       86      error_table_$action_not_performed,
       87      error_table_$active_function,
       88      error_table_$bad_arg,
       89      error_table_$bad_conversion,
       90      error_table_$inconsistent,
       91      error_table_$item_too_big,
       92      error_table_$noentry,
       93      error_table_$not_act_fnc,
       94      error_table_$too_many_args
       95      )		        fixed bin (35) ext static;
       96 
       97 dcl  Me		        char (11) init ("bootload_fs") int static options (constant);
       98 dcl  Suffix	        char (7) init ("boot_fs") int static options (constant);
       99 
      100 dcl  Write_partition        init (2) fixed bin int static options (constant);
      101 
      102 dcl  1 Operations	        (11) int static aligned options (constant),
      103        2 long_name	        char (32) unal
      104 		        init ("read_partition", "write_partition", "use_partition", "save_partition",
      105 		        "discard_partition", "init_partition", "read_file", "write_file", "list_files", "delete_file",
      106 		        "rename_file"),
      107        2 medium_name        char (32) unal
      108 		        init ("", "", "", "svpart", "", "", "read", "write", "list", "delete", "rename"),
      109        2 short_name	        char (32) unal
      110 		        init ("rpart", "wpart", "upart", "spart", "dpart", "ipart", "r", "w", "ls", "dl", "rn"),
      111        2 min_arguments      init (2, 2, 1, 1, 0, 0, 2, 2, 0, 1, 2) fixed bin,
      112        2 max_arguments      init (2, 3, 1, 1, 1, 2, 2, 3, 0, 1, 2) fixed bin,
      113        2 usage	        char (132) unal init ("pv_name part_name",
      114 						/* read_partition */
      115 		        "pv_name part_name",		/* write_partition */
      116 		        "path",			/* use_partition */
      117 		        "path",			/* save_partition */
      118 		        "{-control_arg}",		/* discard_partition */
      119 		        "{-control_arg}",		/* init_partition */
      120 		        "file_name path",		/* read_file */
      121 		        "path file_name",		/* write_file */
      122 		        "",			/* list_files */
      123 		        "file_name",		/* delete_file */
      124 		        "old_file_name new_file_name"); /* rename_file */
      125 
      126 dcl  1 static_info	        internal static aligned,
      127        2 flags	        aligned,
      128        ( 3 partition_valid,
      129          3 temp_valid,
      130          3 pv_info_valid
      131          )	        bit (1) unal init (""b),
      132        2 temp	        aligned,
      133          3 tsp	        pointer,
      134          3 dir_name	        char (168) unaligned,
      135          3 entryname        char (32) unal,
      136        2 pv_info	        aligned,
      137          3 name	        char (32) unal,
      138          3 pvid	        bit (36) aligned,
      139          3 part	        char (4) unal,
      140          3 length	        fixed bin (35);
      141 
      142 dcl  (addr, divide, hbound, index, length, min, null)
      143 		        builtin;
      144 
      145 
      146 	call cu_$af_arg_count (n_arguments, code);
      147 	if code = error_table_$not_act_fnc
      148 	then code = 0;
      149 	else if code = 0
      150 	then code = error_table_$active_function;
      151 	if code ^= 0 then do;
      152 	     call com_err_ (code, Me);
      153 	     return;
      154 	end;
      155 
      156 	if n_arguments = 0 then do;
      157 	     call com_err_$suppress_name (0, Me, "Usage: bootload_fs Key {arguments}");
      158 	     return;
      159 	end;
      160 	call init_arguments;
      161 
      162 	call get_next_argument;
      163 	do which_key = 1 to hbound (Operations, 1)
      164 	     while (argument ^= Operations (which_key).long_name & argument ^= Operations (which_key).medium_name
      165 	     & argument ^= Operations (which_key).short_name);
      166 	end;
      167 	if which_key > hbound (Operations, 1) then do;
      168 	     call com_err_ (error_table_$bad_arg, Me, "The ^a keyword does not exist.", argument);
      169 	     return;
      170 	end;
      171 	n_key_arguments = n_arguments - 1;
      172 	if n_key_arguments < Operations (which_key).min_arguments
      173 	     | n_key_arguments > Operations (which_key).max_arguments then do;
      174 	     call com_err_$suppress_name (0, Me, "Usage: bootload_fs ^a ^a", Operations (which_key).long_name,
      175 		Operations (which_key).usage);
      176 	     return;
      177 	end;
      178 
      179 	goto Keywords (which_key);			/* frazzle the rope -- from now on its command by command */
      180 
      181 
      182 
      183 
      184 Keywords (2 /* write_partition */):			/* These two parse the arguments identically */
      185 	force = ""b;
      186 	if n_key_arguments = 1 then do;		/* check for -force */
      187 	     call get_this_argument (1);
      188 	     if argument = "-force" | argument = "-fc"
      189 	     then force = "1"b;
      190 	     else do;
      191 		if index (argument, "-") = 1
      192 		then call com_err_ (error_table_$bad_arg, Me, "Invalid control argument ^a.", argument);
      193 		else call com_err_ (error_table_$inconsistent, Me,
      194 			"Both a Pvname and a Partition name must be given.");
      195 	     end;
      196 	end;
      197 	if static_info.pv_info_valid & n_key_arguments = 0
      198 	then goto PART_INFO_KNOWN;			/* saving back where we had it */
      199 						/* else fall through into get code to find out about partition from arguments */
      200 
      201 Keywords (1 /* read_partition */):
      202 	call get_next_argument;			/* unspecific, and we know its there */
      203 	pv_name = argument;
      204 	call get_next_argument;
      205 	if length (argument) > 4 then do;
      206 	     call com_err_ (error_table_$bad_arg, Me, "Partition names may be only 4 characters. ^a.", argument);
      207 	     return;
      208 	end;
      209 	part_name = argument;
      210 	call mdc_$pvname_info (pv_name, t_pvid, lvname, lvid, device_type, code);
      211 	if code ^= 0 then do;
      212 	     call com_err_ (code, Me, "Pv ^a.", pv_name);
      213 	     return;
      214 	end;
      215 	call get_part_info (t_pvid, part_name, part_length, code);
      216 	if code ^= 0 then do;
      217 	     call com_err_ (code, Me, "Partition ^a on Pv ^a.", part_name, pv_name);
      218 	     return;
      219 	end;
      220 
      221 	if part_length > sys_info$max_seg_size then do;
      222 	     call com_err_ (0, Me,
      223 		"Warning: Partition ^a on Pv ^a, length ^d, is longer than a segment. Only ^d words will be used.",
      224 		part_name, pv_name, part_length, sys_info$max_seg_size);
      225 	end;
      226 	static_info.pv_info.name = pv_name;
      227 	static_info.pv_info.part = part_name;
      228 	static_info.pv_info.length = part_length;
      229 	static_info.pv_info.pvid = t_pvid;
      230 	static_info.pv_info_valid = "1"b;
      231 
      232 PART_INFO_KNOWN:
      233 	if ^static_info.partition_valid then do;
      234 	     if which_key = Write_partition then do;
      235 		call com_err_ (error_table_$action_not_performed, Me, "There is no partition to write.");
      236 		return;
      237 	     end;
      238 	     call get_temp;
      239 	end;
      240 
      241 /* split functions again */
      242 
      243 	goto READ_WRITE (which_key);
      244 
      245 READ_WRITE (1):					/* read partition */
      246 	call ioa_ ("Starting read of Partition ^a of Pv ^a.", static_info.pv_info.part, static_info.pv_info.name);
      247 	call hphcs_$read_partition (static_info.pv_info.pvid, static_info.pv_info.part, (0) /* beginning */,
      248 	     static_info.tsp, min (sys_info$max_seg_size, static_info.pv_info.length), code);
      249 						/* read the data to temp seg */
      250 	if code ^= 0 then do;
      251 	     call com_err_ (code, Me, "Could not read partition.");
      252 	     return;
      253 	end;
      254 	call ioa_ ("Read completed.");
      255 	static_info.partition_valid = "1"b;		/* the temp segment now constains a partition */
      256 	return;					/* End of Read_partition */
      257 
      258 READ_WRITE (2):					/* write partition */
      259 						/* at this point we supposedly know that there is a partition image in the temp segment. Query and write */
      260 	if ^force then do;
      261 	     query_info.version = query_info_version_4;
      262 	     query_info.yes_or_no_sw = "1"b;
      263 	     call command_query_ (addr (query_info), answer, Me,
      264 		"Writing current partition into the ^a partition of volume ^a. ^/This operation will destroy the current contents of the partition. ^/Do you wish to proceed?"
      265 		, static_info.pv_info.part, static_info.pv_info.name);
      266 	     if answer ^= "yes"
      267 	     then return;
      268 	end;
      269 	call ioa_ ("Starting write to Partition ^a of Pv ^a.", static_info.pv_info.part, static_info.pv_info.name);
      270 	call hphcs_$write_partition (static_info.pv_info.pvid, static_info.pv_info.part, (0) /* beginning */,
      271 	     static_info.tsp, min (static_info.pv_info.length, sys_info$max_seg_size), code);
      272 	if code ^= 0 then do;
      273 	     call com_err_ (code, Me, "Could not write partition.");
      274 	     return;
      275 	end;
      276 	call ioa_ ("Write completed.");
      277 	return;					/* end of write partition */
      278 
      279 
      280 
      281 Keywords (3 /* use partition */):
      282 	call get_next_argument;			/* its there */
      283 	seg_ptr = null ();
      284 	on cleanup call clean_seg;
      285 	call expand_pathname_$add_suffix (argument, Suffix, dir_name, entryname, code);
      286 	if code ^= 0
      287 	then go to use_part_error;
      288 	seg_ptr = null ();
      289 	call initiate_file_ (dir_name, entryname, RW_ACCESS, seg_ptr, bit_count, code);
      290 	if seg_ptr = null () then do;
      291 use_part_error:
      292 	     call com_err_ (code, Me, "^a", argument);
      293 	     return;
      294 	end;
      295 
      296 	if static_info.partition_valid then do;
      297 	     query_info.yes_or_no_sw = "1"b;
      298 	     query_info.version = query_info_version_4;
      299 	     call command_query_ (addr (query_info), answer, Me,
      300 		"Information in working partition will be lost. ^[^/(copy of Partition ^a of Pv ^a)^;^]^/Do you wish to proceed?"
      301 		, static_info.pv_info_valid, static_info.pv_info.part, static_info.pv_info.name);
      302 	     if answer ^= "yes"
      303 	     then return;
      304 	end;
      305 	static_info.tsp -> seg_bits = seg_ptr -> seg_bits;/* copy to temp segment */
      306 	static_info.partition_valid = "1"b;
      307 	call bootload_fs_$init ("0"b, (0), code);	/* inquire as to whether it is valid to warn early */
      308 	if code ^= 0
      309 	then call com_err_ (code, Me);
      310 	return;					/* end of use partition */
      311 
      312 
      313 
      314 Keywords (4 /* save partition */):
      315 	if ^static_info.partition_valid then do;
      316 	     call com_err_ (error_table_$action_not_performed, Me, "No working partition to save.");
      317 	     return;
      318 	end;
      319 	call get_next_argument;
      320 	on cleanup call clean_seg;
      321 	call expand_pathname_$add_suffix (argument, Suffix, dir_name, entryname, code);
      322 	if code ^= 0
      323 	then go to save_part_error;
      324 	seg_ptr = null ();
      325 	call initiate_file_$create (dir_name, entryname, RW_ACCESS, seg_ptr, ("0"b), (0), code);
      326 	if seg_ptr = null () then do;
      327 save_part_error:
      328 	     call com_err_ (code, Me, "^a", argument);
      329 	     return;
      330 	end;
      331 	call adjust_bit_count_ ((static_info.temp.dir_name), (static_info.temp.entryname), ""b, bit_count_for_abc, code)
      332 	     ;
      333 	bit_count = bit_count_for_abc;
      334 	if bit_count < 0 then do;
      335 	     call com_err_ (code, Me, "Adjusting bc on temp seg.");
      336 	     call clean_seg;
      337 	end;
      338 	seg_ptr -> seg_bits = static_info.tsp -> seg_bits;/* home */
      339 	call terminate_file_ (seg_ptr, bit_count, TERM_FILE_BC | TERM_FILE_TERM, code);
      340 	if code ^= 0
      341 	then call com_err_ (code, Me, "^a", argument);
      342 	return;					/* end of save partition */
      343 
      344 
      345 
      346 Keywords (5 /* discard */):				/* throw out all static information, to avoid gratuitous queries and the like */
      347 	force = ""b;
      348 	if n_key_arguments = 1 then do;		/* perhaps -fc */
      349 	     call get_next_argument;
      350 	     if argument = "-fc" | argument = "-force"
      351 	     then force = "1"b;
      352 	     else if index (argument, "-") = 1
      353 	     then call com_err_ (error_table_$bad_arg, Me, "^a.", argument);
      354 	     else call com_err_ (error_table_$inconsistent, Me, "Spurious argument ^a.", argument);
      355 	end;
      356 
      357 	if static_info.partition_valid & ^force then do;
      358 	     query_info.version = query_info_version_4;
      359 	     query_info.yes_or_no_sw = "1"b;
      360 	     call command_query_ (addr (query_info), answer, Me, "Do you really want to discard the working partition?")
      361 		;
      362 	     if answer ^= "yes"
      363 	     then return;
      364 	end;
      365 	static_info.partition_valid = ""b;
      366 	static_info.temp_valid = ""b;
      367 	call terminate_file_ (static_info.tsp, 0, TERM_FILE_TRUNC, code);
      368 	static_info.pv_info_valid = ""b;
      369 	return;					/* end of discard-partition */
      370 
      371 
      372 
      373 Keywords (6 /* init partition */):			/* the two both look for -force */
      374 	new_part_length = -1;
      375 	force = ""b;
      376 	do i = 1 to n_key_arguments;
      377 	     call get_next_argument;
      378 	     if index (argument, "-") = 1 then do;
      379 		if argument = "-force" | argument = "-fc"
      380 		then force = "1"b;
      381 		else do;
      382 		     call com_err_ (error_table_$bad_arg, Me, "^a.", argument);
      383 		     return;
      384 		end;
      385 	     end;
      386 	     else do;				/* has to be a length */
      387 		if new_part_length > -1 then do;
      388 		     call com_err_ (error_table_$too_many_args, Me, "Only one length may be supplied.");
      389 		     return;
      390 		end;
      391 		new_part_length = cv_dec_check_ (argument, code);
      392 		if code ^= 0 then do;
      393 		     call com_err_ (error_table_$bad_conversion, Me, "Unable to convert ^a to an integer.", argument);
      394 		     return;
      395 		end;
      396 	     end;
      397 	     if new_part_length > sys_info$max_seg_size then do;
      398 		call com_err_ (error_table_$item_too_big, Me,
      399 		     "Bootload file partition may not be bigger than a segment.");
      400 		return;
      401 	     end;
      402 	end;					/* have the info */
      403 	if new_part_length = -1
      404 	then new_part_length = sys_info$max_seg_size;
      405 	if static_info.partition_valid & ^force then do;
      406 	     query_info.version = query_info_version_4;
      407 	     query_info.yes_or_no_sw = "1"b;
      408 	     call command_query_ (addr (query_info), answer, Me,
      409 		"Do you really want to reinitialize the working partition?");
      410 	     if answer ^= "yes"
      411 	     then return;
      412 	end;
      413 	call get_temp;
      414 	static_info.partition_valid = "1"b;
      415 	call bootload_fs_$init ("1"b, new_part_length, code);
      416 						/* reinitialize */
      417 	if code ^= 0
      418 	then call com_err_ (code, Me);
      419 	return;					/* end of init partition */
      420 
      421 
      422 
      423 Keywords (7 /* read file */):
      424 	if ^static_info.partition_valid then do;
      425 	     call com_err_ (error_table_$action_not_performed, Me,
      426 		"No working partition exists. Use init_partition or read_partition.");
      427 	     return;
      428 	end;
      429 	call get_next_argument;			/* file_name */
      430 	file_name = argument;
      431 	call get_next_argument;			/* get the pathname */
      432 	call expand_pathname_ (argument, dir_name, entryname, code);
      433 	if code ^= 0 then do;
      434 	     call com_err_ (code, Me, "^a.", argument);
      435 	     return;
      436 	end;
      437 	seg_ptr = null ();
      438 	call initiate_file_$create (dir_name, entryname, RW_ACCESS, seg_ptr, ("0"b), (0), code);
      439 	if seg_ptr = null () then do;
      440 	     call com_err_ (code, Me, "^a>^a.", dir_name, entryname);
      441 	     return;
      442 	end;
      443 	call bootload_fs_$get (file_name, seg_ptr, sys_info$max_seg_size * 4, char_count, code);
      444 	if code ^= 0 then do;
      445 	     call com_err_ (code, Me, "^a", file_name);
      446 	     call clean_seg;
      447 	     return;
      448 	end;
      449 	call terminate_file_ (seg_ptr, char_count * 9, TERM_FILE_BC | TERM_FILE_TERM, code);
      450 	if code ^= 0
      451 	then call com_err_ (code, Me, "^a", argument);
      452 	return;					/* ent of get file */
      453 
      454 
      455 Keywords (8 /* write file */):
      456 	if ^static_info.partition_valid then do;
      457 	     call com_err_ (error_table_$action_not_performed, Me,
      458 		"No working partition exists. Use init_partition or read_partition.");
      459 	     return;
      460 	end;
      461 	call get_next_argument;			/* get the pathname */
      462 	call expand_pathname_ (argument, dir_name, entryname, code);
      463 	if code ^= 0 then do;
      464 	     call com_err_ (code, Me, "^a.", argument);
      465 	     return;
      466 	end;
      467 	seg_ptr = null ();
      468 	call initiate_file_ (dir_name, entryname, R_ACCESS, seg_ptr, bit_count, code);
      469 	if seg_ptr = null () then do;
      470 	     call com_err_ (code, Me, "^a>^a.", dir_name, entryname);
      471 	     return;
      472 	end;
      473 	call get_next_argument;			/* file_name */
      474 	file_name = argument;
      475 	must_be_new = ""b;
      476 	if n_key_arguments = 3 then do;		/* positional, but its only a (capitalist) tool */
      477 	     call get_next_argument;
      478 	     if argument = "-new"
      479 	     then must_be_new = "1"b;
      480 	     else do;
      481 		if index (argument, "-") = 1
      482 		then call com_err_ (error_table_$bad_arg, Me, "^a.", argument);
      483 		else call com_err_ (error_table_$too_many_args, Me, "^a is extraneous.", argument);
      484 		call clean_seg;
      485 		return;
      486 	     end;
      487 	end;
      488 	call bootload_fs_$put (file_name, seg_ptr, divide (bit_count, 9, 21, 0), must_be_new, code);
      489 	if code ^= 0
      490 	then call com_err_ (code, Me, "^a.", file_name);
      491 	call clean_seg;
      492 	return;					/* end of put file */
      493 
      494 
      495 
      496 Keywords (9 /* list files */):
      497 	if ^static_info.partition_valid then do;
      498 	     call com_err_ (error_table_$action_not_performed, Me, "No working partition exists.");
      499 	     return;
      500 	end;
      501 	areap = get_system_free_area_ ();
      502 	call bootload_fs_$list (an_area, bootload_fs_list_ptr, code);
      503 	if code ^= 0 then do;
      504 	     if code = error_table_$noentry
      505 	     then call ioa_ ("No files.");
      506 	     else call com_err_ (code, Me);
      507 	     return;
      508 	end;
      509 	call ioa_ ("Length^-File Name^/");
      510 	do i = 1 to bootload_fs_list.n_files;
      511 	     call ioa_ ("^d^-^a", bootload_fs_list.files (i).length, bootload_fs_list.files (i).name);
      512 	end;
      513 	free bootload_fs_list;
      514 	return;					/* end of list files */
      515 
      516 
      517 Keywords (10 /* delete */):
      518 	if ^static_info.partition_valid then do;
      519 	     call com_err_ (error_table_$action_not_performed, Me, "No working partition exists.");
      520 	     return;
      521 	end;
      522 	call get_next_argument;
      523 	call bootload_fs_$delete (argument, code);
      524 	if code ^= 0
      525 	then call com_err_ (code, Me, "^a", argument);
      526 	return;					/* end of delete */
      527 
      528 
      529 Keywords (11 /* rename */):
      530 	if ^static_info.partition_valid then do;
      531 	     call com_err_ (error_table_$action_not_performed, Me, "No working partition exists.");
      532 	     return;
      533 	end;
      534 	call get_next_argument;
      535 	file_name = argument;
      536 	call get_next_argument;
      537 	call bootload_fs_$rename (file_name, argument, code);
      538 	if code ^= 0
      539 	then call com_err_ (code, Me, "^a", file_name);
      540 	return;					/* end of rename */
      541 
      542 
      543 clean_seg:
      544      procedure;
      545 
      546 	if seg_ptr ^= null ()
      547 	then call terminate_file_ (seg_ptr, (0), TERM_FILE_TERM, code);
      548 	return;
      549      end clean_seg;
      550 
      551 init_arguments:
      552      procedure;
      553 
      554 dcl  code		        fixed bin (35);
      555 
      556 	current_argument = 1;
      557 	return;
      558 
      559 get_next_argument:
      560      entry;
      561 
      562 	call cu_$arg_ptr (current_argument, ap, al, code);
      563 	if code ^= 0
      564 	then signal condition (bootload_fs_bad_arg_parse);
      565 	current_argument = current_argument + 1;
      566 	return;
      567 
      568 get_this_argument:
      569      entry (n);
      570 
      571 dcl  n		        fixed bin;
      572 	call cu_$arg_ptr (n, ap, al, code);
      573 	if code ^= 0
      574 	then signal condition (bootload_fs_bad_arg_parse);
      575 	return;
      576      end init_arguments;
      577 
      578 
      579 get_temp:
      580      procedure;
      581 
      582 dcl  Partition_name	        char (32) static options (constant) init ("bootload_file_partition");
      583 dcl  refname_ptr	        ptr;
      584 
      585 	if ^static_info.temp_valid then do;
      586 	     static_info.tsp = null ();
      587 	     static_info.temp.dir_name = get_pdir_ ();
      588 	     static_info.temp.entryname = Partition_name;
      589 	     call hcs_$make_seg (static_info.temp.dir_name, static_info.temp.entryname, Partition_name, RW_ACCESS_BIN,
      590 		static_info.tsp, code);		/* initiate with refname so bootload_fs_ can find */
      591 	     if static_info.tsp = null () then do;
      592 		call com_err_ (code, Me, "Can't initiate working file system.");
      593 		go to RETURN;
      594 	     end;
      595 	     call hcs_$fs_get_seg_ptr (Partition_name, refname_ptr, code);
      596 	     if code ^= 0 | refname_ptr ^= static_info.tsp then do;
      597 		call com_err_ (code, Me, "Refname ^a does not refer to temp file system in [pd].", Partition_name);
      598 		call terminate_file_ (static_info.tsp, 0, TERM_FILE_TRUNC, code);
      599 		go to RETURN;
      600 	     end;
      601 	     static_info.temp_valid = "1"b;
      602 	end;
      603      end get_temp;
      604 
      605 
      606 get_part_info:
      607      procedure (id, name, n_words, code);
      608 
      609 dcl  id		        bit (36) aligned;
      610 dcl  name		        char (4) unal;
      611 dcl  n_words	        fixed bin (18);
      612 dcl  code		        fixed bin (35);
      613 
      614 dcl  phcs_$read_disk_label  entry (bit (36) aligned, pointer, fixed bin (35));
      615 
      616 	labelp = null ();
      617 	on cleanup
      618 	     begin;
      619 		if labelp ^= null ()
      620 		then free label;
      621 	     end;
      622 	allocate label;
      623 	call phcs_$read_disk_label (id, labelp, code);
      624 	if code ^= 0
      625 	then goto RETURN;
      626 	code = error_table_$noentry;
      627 	do i = 1 to label.nparts;
      628 	     if parts (i).part = name then do;
      629 		n_words = parts (i).nrec * 1024;
      630 		code = 0;
      631 	     end;
      632 	end;
      633 RETURN:
      634 	free label;
      635 	return;
      636 
  5     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  5     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     6*     Add the subvolume info.
  5     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  5     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  5     9*     Added inconsistent_dbm bit used to determine consistency of volume
  5    10*     dumper bit maps.
  5    11*                                                   END HISTORY COMMENTS */
  5    12 
  5    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  5    14 /* Note: fsout_vol clears pad fields before writing the label */
  5    15 
  5    16 dcl  labelp ptr;
  5    17 
  5    18 dcl 1 label based (labelp) aligned,
  5    19 
  5    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  5    21 
  5    22     2 gcos (5*64) fixed bin,
  5    23 
  5    24 /* Now we have the Multics label */
  5    25 
  5    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  5    27     2 version fixed bin,				/* Version 1 */
  5    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  5    29     2 pv_name char (32),				/* Physical volume name. */
  5    30     2 lv_name char (32),				/* Name of logical volume for pack */
  5    31     2 pvid bit (36),				/* Unique ID of this pack */
  5    32     2 lvid bit (36),				/* unique ID of its logical vol */
  5    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  5    34     2 time_registered fixed bin (71),			/* time imported to system */
  5    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  5    36     2 vol_size fixed bin,				/* total size of volume, in records */
  5    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  5    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  5    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  5    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  5    41     2 flagpad bit (33) unal,
  5    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  5    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  5    44     2 password bit (72),				/* not yet used */
  5    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  5    46     2 this_sv fixed bin,				/* what subvolume number it is */
  5    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  5    48     2 pad1 (13) fixed bin,
  5    49     2 time_mounted fixed bin (71),			/* time mounted */
  5    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  5    51 
  5    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  5    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  5    54* */
  5    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  5    56     2 pad6 fixed bin,				
  5    57 
  5    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  5    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  5    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  5    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  5    62     2 pad1a (2) fixed bin,
  5    63     2 err_hist_size fixed bin,			/* size of pack error history */
  5    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  5    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  5    66     2 pad2 (40) fixed bin,
  5    67     2 root,
  5    68       3 here bit (1),				/* TRUE if the root is on this pack */
  5    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  5    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  5    71       3 pad7 bit (1) aligned,				
  5    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  5    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  5    74       3 esd_state fixed bin,				/* State of esd */
  5    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  5    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  5    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  5    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  5    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  5    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  5    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  5    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  5    83     2 pad3 (52) fixed bin,
  5    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  5    85     2 parts (47),
  5    86       3 part char (4),				/* Name of partition */
  5    87       3 frec fixed bin,				/* First record */
  5    88       3 nrec fixed bin,				/* Number of records */
  5    89       3 pad5 fixed bin,
  5    90     2 pad4 (5*64) fixed bin;
  5    91 
  5    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  5    93 
  5    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      637 
      638      end get_part_info;
      639 RETURN:
      640 	return;
      641      end bootload_fs;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1535.0  bootload_fs.pl1                   >special_ldd>install>MR12.2-1061>bootload_fs.pl1
75           1    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
76           2    07/11/84  0937.3  bootload_fs_list.incl.pl1         >ldd>include>bootload_fs_list.incl.pl1
77           3    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
78           4    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
637          5    07/19/88  1523.2  fs_vol_label.incl.pl1             >special_ldd>install>MR12.2-1061>fs_vol_label.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Me                              001240 constant        char(11)                 initial packed unaligned dcl 97 set ref 152* 157*
                                                                                  168* 174* 191* 193* 206* 212* 217* 222* 235* 251*
                                                                                  263* 273* 291* 299* 308* 316* 327* 335* 340* 352*
                                                                                  354* 360* 382* 388* 393* 398* 408* 417* 425* 434*
                                                                                  440* 445* 450* 457* 464* 470* 481* 483* 489* 498*
                                                                                  506* 519* 524* 531* 538* 592* 597*
Multics                 500            based           char(32)                 initial level 2 dcl 5-18 set ref 622*
Operations                      000000 constant        structure                array level 1 dcl 102 set ref 163 167
Partition_name                  001226 constant        char(32)                 initial packed unaligned dcl 582 set ref 588 589*
                                                                                  595* 597*
RW_ACCESS                       001245 constant        bit(3)                   initial packed unaligned dcl 3-11 set ref 289* 325*
                                                                                  438*
RW_ACCESS_BIN                   001244 constant        fixed bin(5,0)           initial dcl 3-36 set ref 589*
R_ACCESS                        001322 constant        bit(3)                   initial packed unaligned dcl 3-11 set ref 468*
Suffix                          001236 constant        char(7)                  initial packed unaligned dcl 98 set ref 285* 321*
TERM_FILE_BC                           constant        bit(2)                   initial packed unaligned dcl 4-12 ref 339 449
TERM_FILE_TERM                  001243 constant        bit(3)                   initial packed unaligned dcl 4-14 set ref 339 449
                                                                                  546*
TERM_FILE_TRUNC                 001322 constant        bit(1)                   initial packed unaligned dcl 4-11 set ref 367* 598*
Write_partition                        constant        fixed bin(17,0)          initial dcl 100 ref 234
addr                                                   builtin function         dcl 142 ref 263 263 299 299 360 360 408 408
adjust_bit_count_               000170 constant        entry                    external dcl 39 ref 331
al                              000240 automatic       fixed bin(21,0)          dcl 61 set ref 163 163 163 168 168 188 188 191 191
                                                                                  191 203 205 206 206 209 285 285 291 291 321 321
                                                                                  327 327 340 340 350 350 352 352 352 354 354 378
                                                                                  379 379 382 382 391 391 393 393 430 432 432 434
                                                                                  434 450 450 462 462 464 464 474 478 481 481 481
                                                                                  483 483 523 523 524 524 535 537 537 562* 572*
an_area                                based           area(1024)               dcl 68 set ref 502*
answer                          000105 automatic       varying char(32)         dcl 50 set ref 263* 266 299* 302 360* 362 408* 410
answer_iocbp              6     000256 automatic       pointer                  initial level 2 dcl 1-7 set ref 1-7*
ap                              000236 automatic       pointer                  dcl 60 set ref 163 163 163 168 188 188 191 191 203
                                                                                  205 206 209 285 291 321 327 340 350 350 352 352
                                                                                  354 378 379 379 382 391 393 430 432 434 450 462
                                                                                  464 474 478 481 481 483 523 524 535 537 562* 572*
areap                           000242 automatic       pointer                  dcl 63 set ref 501* 502
argument                               based           char                     packed unaligned dcl 62 set ref 163 163 163 168* 188
                                                                                  188 191 191* 203 205 206* 209 285* 291* 321* 327*
                                                                                  340* 350 350 352 352* 354* 378 379 379 382* 391*
                                                                                  393* 430 432* 434* 450* 462* 464* 474 478 481 481*
                                                                                  483* 523* 524* 535 537*
bit_count                       000103 automatic       fixed bin(24,0)          dcl 48 set ref 289* 305 305 333* 334 338 338 339*
                                                                                  468* 488 488
bit_count_for_abc               000101 automatic       fixed bin(35,0)          dcl 46 set ref 331* 333
bootload_fs_$delete             000122 constant        entry                    external dcl 18 ref 523
bootload_fs_$get                000114 constant        entry                    external dcl 15 ref 443
bootload_fs_$init               000112 constant        entry                    external dcl 14 ref 307 415
bootload_fs_$list               000120 constant        entry                    external dcl 17 ref 502
bootload_fs_$put                000116 constant        entry                    external dcl 16 ref 488
bootload_fs_$rename             000124 constant        entry                    external dcl 19 ref 537
bootload_fs_bad_arg_parse       000000 stack reference condition                dcl 83 ref 563 573
bootload_fs_list                       based           structure                level 1 dcl 2-6 set ref 513
bootload_fs_list_ptr            000274 automatic       pointer                  dcl 2-4 set ref 502* 510 511 511 513
char_count                      000100 automatic       fixed bin(21,0)          dcl 44 set ref 443* 449
cleanup                         000276 stack reference condition                dcl 83 ref 284 320 617
code                                   parameter       fixed bin(35,0)          dcl 612 in procedure "get_part_info" set ref 606
                                                                                  623* 624 626* 630*
code                            000314 automatic       fixed bin(35,0)          dcl 554 in procedure "init_arguments" set ref 562*
                                                                                  563 572* 573
code                            000141 automatic       fixed bin(35,0)          dcl 55 in procedure "bootload_fs" set ref 146* 147
                                                                                  147* 149 149* 151 152* 210* 211 212* 215* 216 217*
                                                                                  247* 250 251* 270* 272 273* 285* 286 289* 291*
                                                                                  307* 308 308* 321* 322 325* 327* 331* 335* 339*
                                                                                  340 340* 367* 391* 392 415* 417 417* 432* 433 434*
                                                                                  438* 440* 443* 444 445* 449* 450 450* 462* 463
                                                                                  464* 468* 470* 488* 489 489* 502* 503 504 506*
                                                                                  523* 524 524* 537* 538 538* 546* 589* 592* 595*
                                                                                  596 597* 598*
com_err_                        000156 constant        entry                    external dcl 34 ref 152 168 191 193 206 212 217 222
                                                                                  235 251 273 291 308 316 327 335 340 352 354 382
                                                                                  388 393 398 417 425 434 440 445 450 457 464 470
                                                                                  481 483 489 498 506 519 524 531 538 592 597
com_err_$suppress_name          000160 constant        entry                    external dcl 35 ref 157 174
command_query_                  000154 constant        entry                    external dcl 33 ref 263 299 360 408
cp_escape_control         1(02) 000256 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 1-7*
cu_$af_arg_count                000140 constant        entry                    external dcl 26 ref 146
cu_$arg_ptr                     000142 constant        entry                    external dcl 27 ref 562 572
current_argument                000247 automatic       fixed bin(17,0)          dcl 67 set ref 556* 562* 565* 565
cv_dec_check_                   000174 constant        entry                    external dcl 42 ref 391
device_type                     000140 automatic       fixed bin(17,0)          dcl 54 set ref 210*
dir_name                  4     000010 internal static char(168)                level 3 in structure "static_info" packed packed
                                                                                  unaligned dcl 126 in procedure "bootload_fs" set
                                                                                  ref 331 587* 589*
dir_name                        000152 automatic       char(168)                packed unaligned dcl 57 in procedure "bootload_fs"
                                                                                  set ref 285* 289* 321* 325* 432* 438* 440* 462*
                                                                                  468* 470*
divide                                                 builtin function         dcl 142 ref 488 488
entryname                       000224 automatic       char(32)                 packed unaligned dcl 58 in procedure "bootload_fs"
                                                                                  set ref 285* 289* 321* 325* 432* 438* 440* 462*
                                                                                  468* 470*
entryname                56     000010 internal static char(32)                 level 3 in structure "static_info" packed packed
                                                                                  unaligned dcl 126 in procedure "bootload_fs" set
                                                                                  ref 331 588* 589*
error_table_$action_not_performed
                                000200 external static fixed bin(35,0)          dcl 85 set ref 235* 316* 425* 457* 498* 519* 531*
error_table_$active_function    000202 external static fixed bin(35,0)          dcl 85 ref 149
error_table_$bad_arg            000204 external static fixed bin(35,0)          dcl 85 set ref 168* 191* 206* 352* 382* 481*
error_table_$bad_conversion     000206 external static fixed bin(35,0)          dcl 85 set ref 393*
error_table_$inconsistent       000210 external static fixed bin(35,0)          dcl 85 set ref 193* 354*
error_table_$item_too_big       000212 external static fixed bin(35,0)          dcl 85 set ref 398*
error_table_$noentry            000214 external static fixed bin(35,0)          dcl 85 ref 504 626
error_table_$not_act_fnc        000216 external static fixed bin(35,0)          dcl 85 ref 147
error_table_$too_many_args      000220 external static fixed bin(35,0)          dcl 85 set ref 388* 483*
expand_pathname_                000144 constant        entry                    external dcl 28 ref 432 462
expand_pathname_$add_suffix     000146 constant        entry                    external dcl 29 ref 285 321
explanation_len          14     000256 automatic       fixed bin(21,0)          initial level 2 dcl 1-7 set ref 1-7*
explanation_ptr          12     000256 automatic       pointer                  initial level 2 dcl 1-7 set ref 1-7*
file_name                       000142 automatic       char(32)                 packed unaligned dcl 56 set ref 430* 443* 445* 474*
                                                                                  488* 489* 535* 537* 538*
files                     1            based           structure                array level 2 dcl 2-6
flags                           000010 internal static structure                level 2 dcl 126
force                           000244 automatic       bit(1)                   packed unaligned dcl 64 set ref 184* 188* 258 346*
                                                                                  350* 357 375* 379* 405
get_pdir_                       000150 constant        entry                    external dcl 31 ref 587
get_system_free_area_           000152 constant        entry                    external dcl 32 ref 501
hbound                                                 builtin function         dcl 142 ref 163 167
hcs_$fs_get_seg_ptr             000126 constant        entry                    external dcl 21 ref 595
hcs_$make_seg                   000130 constant        entry                    external dcl 22 ref 589
hphcs_$read_partition           000164 constant        entry                    external dcl 37 ref 247
hphcs_$write_partition          000166 constant        entry                    external dcl 38 ref 270
i                               000254 automatic       fixed bin(17,0)          dcl 72 set ref 376* 510* 511 511* 627* 628 629*
id                                     parameter       bit(36)                  dcl 609 set ref 606 623*
index                                                  builtin function         dcl 142 ref 191 352 378 481
initiate_file_                  000132 constant        entry                    external dcl 23 ref 289 468
initiate_file_$create           000134 constant        entry                    external dcl 24 ref 325 438
ioa_                            000172 constant        entry                    external dcl 41 ref 245 254 269 276 504 509 511
label                                  based           structure                level 1 dcl 5-18 set ref 619 622 633
labelp                          000100 automatic       pointer                  dcl 5-16 set ref 616* 619 619 622* 623* 627 628 629
                                                                                  633
length                   11            based           fixed bin(21,0)          array level 3 in structure "bootload_fs_list"
                                                                                  dcl 2-6 in procedure "bootload_fs" set ref 511*
length                  100     000010 internal static fixed bin(35,0)          level 3 in structure "static_info" dcl 126
                                                                                  in procedure "bootload_fs" set ref 228* 247 247
                                                                                  270 270
length                                                 builtin function         dcl 142 in procedure "bootload_fs" ref 205
literal_sw                1(05) 000256 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 1-7*
long_name                       000000 constant        char(32)                 initial array level 2 packed packed unaligned
                                                                                  dcl 102 set ref 163 174*
lvid                            000137 automatic       bit(36)                  dcl 53 set ref 210*
lvname                          000126 automatic       char(32)                 packed unaligned dcl 52 set ref 210*
max_arguments            31     000000 constant        fixed bin(17,0)          initial array level 2 dcl 102 ref 172
mdc_$pvname_info                000162 constant        entry                    external dcl 36 ref 210
medium_name              10     000000 constant        char(32)                 initial array level 2 packed packed unaligned
                                                                                  dcl 102 ref 163
min                                                    builtin function         dcl 142 ref 247 247 270 270
min_arguments            30     000000 constant        fixed bin(17,0)          initial array level 2 dcl 102 ref 172
must_be_new                     000245 automatic       bit(1)                   dcl 65 set ref 475* 478* 488*
n                                      parameter       fixed bin(17,0)          dcl 571 set ref 568 572*
n_arguments                     000252 automatic       fixed bin(17,0)          dcl 70 set ref 146* 156 171
n_files                                based           fixed bin(17,0)          level 2 dcl 2-6 ref 510 513
n_key_arguments                 000253 automatic       fixed bin(17,0)          dcl 71 set ref 171* 172 172 186 197 348 376 476
n_words                                parameter       fixed bin(18,0)          dcl 611 set ref 606 629*
name                      1            based           char(32)                 array level 3 in structure "bootload_fs_list" packed
                                                                                  packed unaligned dcl 2-6 in procedure
                                                                                  "bootload_fs" set ref 511*
name                                   parameter       char(4)                  packed unaligned dcl 610 in procedure
                                                                                  "get_part_info" ref 606 628
name                     66     000010 internal static char(32)                 level 3 in structure "static_info" packed packed
                                                                                  unaligned dcl 126 in procedure "bootload_fs" set
                                                                                  ref 226* 245* 263* 269* 299*
new_part_length                 000102 automatic       fixed bin(19,0)          dcl 47 set ref 373* 387 391* 397 403 403* 415*
nparts                 1003            based           fixed bin(17,0)          level 2 dcl 5-18 ref 627
nrec                   1006            based           fixed bin(17,0)          array level 3 dcl 5-18 ref 629
null                                                   builtin function         dcl 142 ref 283 288 290 324 326 437 439 467 469 1-7
                                                                                  1-7 1-7 546 586 591 616 619
padding                   1(07) 000256 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 1-7*
part                     77     000010 internal static char(4)                  level 3 in structure "static_info" packed packed
                                                                                  unaligned dcl 126 in procedure "bootload_fs" set
                                                                                  ref 227* 245* 247* 263* 269* 270* 299*
part                   1004            based           char(4)                  array level 3 in structure "label" dcl 5-18
                                                                                  in procedure "get_part_info" ref 628
part_length                     000246 automatic       fixed bin(18,0)          dcl 66 set ref 215* 221 222* 228
part_name                       000104 automatic       char(4)                  packed unaligned dcl 49 set ref 209* 215* 217* 222*
                                                                                  227
partition_valid                 000010 internal static bit(1)                   initial level 3 packed packed unaligned dcl 126 set
                                                                                  ref 232 255* 296 306* 314 357 365* 405 414* 423
                                                                                  455 496 517 529
parts                  1004            based           structure                array level 2 dcl 5-18
phcs_$read_disk_label           000222 constant        entry                    external dcl 614 ref 623
prompt_after_explanation
                          1(06) 000256 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 1-7*
pv_info                  66     000010 internal static structure                level 2 dcl 126
pv_info_valid             0(02) 000010 internal static bit(1)                   initial level 3 packed packed unaligned dcl 126 set
                                                                                  ref 197 230* 299* 368*
pv_name                         000116 automatic       char(32)                 packed unaligned dcl 51 set ref 203* 210* 212* 217*
                                                                                  222* 226
pvid                     76     000010 internal static bit(36)                  level 3 dcl 126 set ref 229* 247* 270*
query_code                3     000256 automatic       fixed bin(35,0)          initial level 2 dcl 1-7 set ref 1-7*
query_info                      000256 automatic       structure                level 1 dcl 1-7 set ref 263 263 299 299 360 360 408
                                                                                  408
query_info_version_4                   constant        fixed bin(17,0)          initial dcl 1-34 ref 261 298 358 406
question_iocbp            4     000256 automatic       pointer                  initial level 2 dcl 1-7 set ref 1-7*
refname_ptr                     000332 automatic       pointer                  dcl 583 set ref 595* 596
repeat_time              10     000256 automatic       fixed bin(71,0)          initial level 2 dcl 1-7 set ref 1-7*
seg_bits                               based           bit                      packed unaligned dcl 45 set ref 305* 305 338* 338
seg_ptr                         000250 automatic       pointer                  dcl 69 set ref 283* 288* 289* 290 305 324* 325* 326
                                                                                  338 339* 437* 438* 439 443* 449* 467* 468* 469
                                                                                  488* 546 546*
short_name               20     000000 constant        char(32)                 initial array level 2 packed packed unaligned
                                                                                  dcl 102 ref 163
static_info                     000010 internal static structure                level 1 dcl 126
status_code               2     000256 automatic       fixed bin(35,0)          initial level 2 dcl 1-7 set ref 1-7*
suppress_name_sw          1(01) 000256 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 1-7*
suppress_spacing          1(04) 000256 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 1-7*
switches                  1     000256 automatic       structure                level 2 dcl 1-7
sys_info$max_seg_size           000176 external static fixed bin(35,0)          dcl 82 set ref 221 222* 247 247 270 270 397 403 443
t_pvid                          000136 automatic       bit(36)                  dcl 53 set ref 210* 215* 229
temp                      2     000010 internal static structure                level 2 dcl 126
temp_valid                0(01) 000010 internal static bit(1)                   initial level 3 packed packed unaligned dcl 126 set
                                                                                  ref 366* 585 601*
terminate_file_                 000136 constant        entry                    external dcl 25 ref 339 367 449 546 598
tsp                       2     000010 internal static pointer                  level 3 dcl 126 set ref 247* 270* 305 338 367* 586*
                                                                                  589* 591 596 598*
usage                    32     000000 constant        char(132)                initial array level 2 packed packed unaligned
                                                                                  dcl 102 set ref 174*
version                         000256 automatic       fixed bin(17,0)          level 2 dcl 1-7 set ref 261* 298* 358* 406*
which_key                       000234 automatic       fixed bin(17,0)          dcl 59 set ref 163* 163 163 163* 167 172 172 174 174
                                                                                  179 234 243
yes_or_no_sw              1     000256 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 1-7 set
                                                                                  ref 262* 297* 359* 407* 1-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 5-92
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 4-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 4-16
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 4-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 4-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
bootload_fs_list_n_files               automatic       fixed bin(17,0)          dcl 2-12
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 1-33
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 1-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 1-36
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 4-4

NAMES DECLARED BY EXPLICIT CONTEXT.
Keywords                        001211 constant        label                    array(11) dcl 184 ref 179
PART_INFO_KNOWN                 003033 constant        label                    dcl 232 ref 197
READ_WRITE                      001224 constant        label                    array(2) dcl 245 ref 243
RETURN                          007343 constant        label                    dcl 633 in procedure "get_part_info" set ref 624
RETURN                          006664 constant        label                    dcl 639 in procedure "bootload_fs" ref 593 599
bootload_fs                     002116 constant        entry                    external dcl 6
clean_seg                       006666 constant        entry                    internal dcl 543 ref 284 320 336 446 484 491
get_next_argument               006732 constant        entry                    internal dcl 559 ref 162 201 204 281 319 349 377 429
                                                                                  431 461 473 477 522 534 536
get_part_info                   007224 constant        entry                    internal dcl 606 ref 215
get_temp                        007005 constant        entry                    internal dcl 579 ref 238 413
get_this_argument               006757 constant        entry                    internal dcl 568 ref 187
init_arguments                  006726 constant        entry                    internal dcl 551 ref 160
save_part_error                 004140 constant        label                    dcl 327 ref 322
use_part_error                  003570 constant        label                    dcl 291 ref 286

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10046       10272    7363       10056
Length     10746    7363       224         440     462         102

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bootload_fs                         487 external procedure  is an external procedure.  
on unit on line 284                  64 on unit               
on unit on line 320                  64 on unit               
clean_seg                            84 internal procedure  is called by several nonquick procedures.  
init_arguments                          internal procedure  shares stack frame of external procedure bootload_fs.  
get_temp                                internal procedure  shares stack frame of external procedure bootload_fs.  
get_part_info                        82 internal procedure  enables or reverts conditions.  
on unit on line 617                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_info                 bootload_fs

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bootload_fs              000100 char_count                  bootload_fs
                         000101 bit_count_for_abc           bootload_fs
                         000102 new_part_length             bootload_fs
                         000103 bit_count                   bootload_fs
                         000104 part_name                   bootload_fs
                         000105 answer                      bootload_fs
                         000116 pv_name                     bootload_fs
                         000126 lvname                      bootload_fs
                         000136 t_pvid                      bootload_fs
                         000137 lvid                        bootload_fs
                         000140 device_type                 bootload_fs
                         000141 code                        bootload_fs
                         000142 file_name                   bootload_fs
                         000152 dir_name                    bootload_fs
                         000224 entryname                   bootload_fs
                         000234 which_key                   bootload_fs
                         000236 ap                          bootload_fs
                         000240 al                          bootload_fs
                         000242 areap                       bootload_fs
                         000244 force                       bootload_fs
                         000245 must_be_new                 bootload_fs
                         000246 part_length                 bootload_fs
                         000247 current_argument            bootload_fs
                         000250 seg_ptr                     bootload_fs
                         000252 n_arguments                 bootload_fs
                         000253 n_key_arguments             bootload_fs
                         000254 i                           bootload_fs
                         000256 query_info                  bootload_fs
                         000274 bootload_fs_list_ptr        bootload_fs
                         000314 code                        init_arguments
                         000332 refname_ptr                 get_temp
get_part_info            000100 labelp                      get_part_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          signal_op
enable_op           ext_entry           int_entry           alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             bootload_fs_$delete           bootload_fs_$get              bootload_fs_$init
bootload_fs_$list             bootload_fs_$put              bootload_fs_$rename           com_err_
com_err_$suppress_name        command_query_                cu_$af_arg_count              cu_$arg_ptr
cv_dec_check_                 expand_pathname_              expand_pathname_$add_suffix   get_pdir_
get_system_free_area_         hcs_$fs_get_seg_ptr           hcs_$make_seg                 hphcs_$read_partition
hphcs_$write_partition        initiate_file_                initiate_file_$create         ioa_
mdc_$pvname_info              phcs_$read_disk_label         terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$active_function  error_table_$bad_arg
error_table_$bad_conversion   error_table_$inconsistent     error_table_$item_too_big     error_table_$noentry
error_table_$not_act_fnc      error_table_$too_many_args    sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 002115    1    7 002123       146 002153       147 002163       149 002171       151 002175       152 002177
    153 002213       156 002214       157 002216       158 002242       160 002243       162 002244       163 002245
    166 002275       167 002277       168 002302       169 002335       171 002336       172 002341       174 002352
    176 002407       179 002410       184 002412       186 002413       187 002415       188 002421       191 002436
    193 002504       197 002530       201 002536       203 002537       204 002544       205 002545       206 002550
    207 002602       209 002603       210 002607       211 002642       212 002644       213 002673       215 002674
    216 002710       217 002712       218 002746       221 002747       222 002753       226 003017       227 003023
    228 003025       229 003027       230 003031       232 003033       234 003036       235 003041       236 003064
    238 003065       243 003066       245 003070       247 003114       250 003156       251 003160       252 003204
    254 003205       255 003224       256 003227       258 003230       261 003232       262 003234       263 003236
    266 003300       269 003305       270 003331       272 003373       273 003375       274 003421       276 003422
    277 003441       281 003442       283 003443       284 003445       285 003467       286 003523       288 003525
    289 003527       290 003564       291 003570       293 003622       296 003623       297 003627       298 003631
    299 003633       302 003702       305 003707       306 003716       307 003720       308 003735       310 003754
    314 003755       316 003761       317 004004       319 004005       320 004006       321 004030       322 004064
    324 004066       325 004070       326 004134       327 004140       329 004172       331 004173       333 004222
    334 004224       335 004225       336 004251       338 004255       339 004264       340 004313       342 004347
    346 004350       348 004351       349 004353       350 004354       352 004371       354 004436       357 004471
    358 004477       359 004501       360 004503       362 004534       365 004541       366 004544       367 004546
    368 004573       369 004576       373 004577       375 004601       376 004602       377 004611       378 004612
    379 004626       382 004641       383 004673       385 004674       387 004675       388 004700       389 004724
    391 004725       392 004752       393 004754       394 005007       397 005010       398 005014       400 005037
    402 005040       403 005042       405 005050       406 005056       407 005060       408 005062       410 005113
    413 005120       414 005121       415 005124       417 005140       419 005157       423 005160       425 005164
    427 005207       429 005210       430 005211       431 005216       432 005217       433 005247       434 005251
    435 005303       437 005304       438 005306       439 005352       440 005356       441 005411       443 005412
    444 005445       445 005447       446 005476       447 005502       449 005503       450 005536       452 005572
    455 005573       457 005577       459 005622       461 005623       462 005624       463 005654       464 005656
    465 005710       467 005711       468 005713       469 005750       470 005754       471 006007       473 006010
    474 006011       475 006016       476 006017       477 006022       478 006023       481 006034       483 006101
    484 006137       485 006143       488 006144       489 006200       491 006231       492 006235       496 006236
    498 006242       499 006265       501 006266       502 006274       503 006315       504 006317       506 006337
    507 006353       509 006354       510 006370       511 006377       512 006431       513 006433       514 006440
    517 006441       519 006445       520 006470       522 006471       523 006472       524 006512       526 006546
    529 006547       531 006553       532 006576       534 006577       535 006600       536 006605       537 006606
    538 006632       540 006663       639 006664       543 006665       546 006673       548 006725       551 006726
    556 006727       557 006731       559 006732       562 006733       563 006750       565 006755       566 006756
    568 006757       572 006761       573 006777       575 007004       579 007005       585 007006       586 007012
    587 007014       588 007022       589 007026       591 007061       592 007066       593 007111       595 007112
    596 007132       597 007141       598 007171       599 007217       601 007220       603 007222       606 007223
    616 007231       617 007233       619 007247       621 007256       622 007257       623 007266       624 007302
    626 007305       627 007310       628 007322       629 007334       630 007340       632 007341       633 007343
    635 007345


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
