	COMPILATION LISTING OF SEGMENT trace_mcs
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/02/85  1547.3 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 trace_mcs:
        7 mcm_trace:
        8      procedure () options (variable);
        9 
       10 /* MCS Tracing command procedure: */
       11 /* This procedure is used to control MCS tracing, and print the results */
       12 
       13 /* Derived from an earlier version by C. Hornig */
       14 /* Completely rewritten 10 March 82, W. Olin Sibert 
       15*   Modified: 1984-09-19 to stop using decimal_date_time...JAFalksen
       16*   Modified: October 1984 by Greg Texada to change the calling sequence for copy_erf_seg_.		*/
       17 
       18 	declare arg_count		 fixed bin;
       19 	declare arg_index		 fixed bin;
       20 	declare arg_lth		 fixed bin (21);
       21 	declare arg_ptr		 pointer;
       22 	declare arg		 char (arg_lth) based (arg_ptr);
       23 	declare code		 fixed bin (35);
       24 	declare operation		 char (32) varying;
       25 
       26 	declare brief_sw		 bit (1) aligned;
       27 	declare reset_sw		 bit (1) aligned;
       28 	declare all_sw		 bit (1) aligned;
       29 	declare reverse_sw		 bit (1) aligned;
       30 	declare on_sw		 bit (1) aligned;
       31 	declare off_sw		 bit (1) aligned;
       32 	declare force_sw		 bit (1) aligned;
       33 	declare print_sw		 bit (1) aligned;
       34 
       35 	declare last_count		 fixed bin;
       36 	declare table_size		 fixed bin;
       37 	declare new_modes		 char (120);
       38 	declare erf_name		 char (32);
       39 
       40 	declare n_excludes		 fixed bin;
       41 	declare exclude		 (20) char (40) varying;
       42 	declare n_matches		 fixed bin;
       43 	declare match		 (20) char (40) varying;
       44 	declare n_channels		 fixed bin;
       45 	declare channel		 (20) char (32) varying;
       46 	declare temp_segs		 (2) pointer;
       47 	declare areap		 pointer;
       48 
       49 	declare trace_mode_bits	 bit (18) unaligned;
       50 	declare trace_mode_string	 char (120) varying;
       51 
       52 	declare trace_idx		 fixed bin;
       53 
       54 	declare last_trace_time	 fixed binary (71) internal static initial (0);
       55 	declare last_trace_idx	 fixed binary internal static initial (0);
       56 
       57 	declare error_table_$noarg	 fixed bin (35) external static;
       58 	declare error_table_$badopt	 fixed bin (35) external static;
       59 	declare error_table_$too_many_args fixed bin (35) external static;
       60 	declare error_table_$bad_conversion fixed bin (35) external static;
       61 	declare error_table_$bad_mode	 fixed bin (35) external static;
       62 	declare error_table_$inconsistent fixed bin (35) external static;
       63 	declare error_table_$bigarg	 fixed bin (35) external static;
       64 
       65 	declare check_star_name_$entry entry (char (*), fixed bin (35));
       66 	declare command_query_$yes_no	 entry options (variable);
       67 	declare com_err_		 entry options (variable);
       68 	declare copy_erf_seg_$name	 entry (char (*), char (*), pointer, fixed bin (19), fixed bin (35));
       69 	declare cu_$arg_count	 entry (fixed bin, fixed bin (35));
       70 	declare cu_$arg_ptr		 entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
       71 	declare cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
       72 	declare date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
       73 	declare get_temp_segments_	 entry (char (*), (*) pointer, fixed bin (35));
       74 	declare ioa_		 entry options (variable);
       75 	declare ioa_$rsnnl		 entry options (variable);
       76 	declare match_star_name_	 entry (char (*), char (*), fixed bin (35));
       77 	declare mode_string_$parse	 entry (char (*), pointer, pointer, fixed bin (35));
       78 	declare release_temp_segments_ entry (char (*), (*) pointer, fixed bin (35));
       79 
       80 	declare hphcs_$set_mcm_trace_table_size entry (fixed bin, fixed bin (35));
       81 	declare hphcs_$set_mcm_global_trace entry (bit (*), fixed bin (35));
       82 	declare hphcs_$set_mcm_channel_trace entry (fixed bin, bit (2) aligned, fixed bin (35));
       83 
       84 	declare WHOAMI		 char (32) internal static options (constant) init ("trace_mcs");
       85 
       86 	declare (linkage_error, cleanup) condition;
       87 
       88 	declare (addr, binary, empty, float, hbound, index, length) builtin;
       89 	declare (maxlength, mod, null, pointer, rel, rtrim, size) builtin;
       90 	declare (string, substr, unspec) builtin;
       91 
       92 /*  */
       93 
       94 	temp_segs (*) = null ();
       95 	brief_sw = "0"b;
       96 	reset_sw = "0"b;
       97 	all_sw = "0"b;
       98 	reverse_sw = "0"b;
       99 	on_sw = "0"b;
      100 	off_sw = "0"b;
      101 	print_sw = "0"b;
      102 	force_sw = "0"b;
      103 
      104 	erf_name = "";
      105 	table_size = -1;
      106 	new_modes = "";
      107 	n_channels = 0;
      108 	n_excludes = 0;
      109 	n_matches = 0;
      110 	last_count = -1;
      111 
      112 	on condition (cleanup)
      113 	     call cleanup_procedure ();
      114 
      115 	call cu_$arg_count (arg_count, code);
      116 	if (code ^= 0) then do;
      117 		call com_err_ (code, WHOAMI);
      118 		goto MAIN_RETURN;
      119 	     end;
      120 
      121 	if (arg_count < 1) then do;
      122 		call com_err_ (error_table_$noarg, WHOAMI,
      123 		     "^/Usage:^-^a modes|chn|table_size|print {-control_args}", WHOAMI);
      124 		goto MAIN_RETURN;
      125 	     end;
      126 
      127 	arg_index = 1;
      128 	call cu_$arg_ptr (arg_index, arg_ptr, arg_lth, (0));
      129 
      130 	if (arg = "table_size") | (arg = "ts") then goto PROCESS_TABLE_SIZE;
      131 	else if (arg = "channel") | (arg = "chan") | (arg = "chn") then goto PROCESS_CHANNEL;
      132 	else if (arg = "modes") then goto PROCESS_MODES;
      133 	else if (arg = "print") | (arg = "pr") | (arg = "p") then goto PROCESS_PRINT;
      134 	else if (arg = "reset") | (arg = "rs") then goto PROCESS_RESET;
      135 	else do;
      136 		call com_err_ (0, WHOAMI, "Unknown function: ^a", arg);
      137 		goto MAIN_RETURN;
      138 	     end;
      139 
      140 
      141 BADOPT_ERROR:
      142 	call com_err_ (error_table_$badopt, WHOAMI, "^a", arg);
      143 	goto MAIN_RETURN;
      144 
      145 
      146 inconsistent:
      147      procedure (P_error);
      148 
      149 	declare P_error		 char (*) parameter;
      150 
      151 	call com_err_ (error_table_$inconsistent, WHOAMI, P_error);
      152 	goto MAIN_RETURN;
      153      end inconsistent;
      154 
      155 
      156 MAIN_RETURN:
      157 	call cleanup_procedure ();
      158 
      159 	return;
      160 
      161 /*  */
      162 
      163 PROCESS_TABLE_SIZE:
      164 	operation = "set trace table size";
      165 
      166 	do arg_index = 2 to arg_count;
      167 	     call cu_$arg_ptr (arg_index, arg_ptr, arg_lth, (0));
      168 
      169 	     if (arg = "-erf") then call get_erf_argument;
      170 
      171 	     else if (index (arg, "-") = 1) then goto BADOPT_ERROR;
      172 
      173 	     else do;				/* Anything else is supposed to be a table size */
      174 		     if (table_size >= 0) then do;
      175 			     call com_err_ (error_table_$too_many_args, WHOAMI, "Extra table size ^a", arg);
      176 			     goto MAIN_RETURN;
      177 			end;
      178 
      179 		     table_size = cv_dec_check_ (arg, code);
      180 		     if (code ^= 0) | (table_size < 0) then do;
      181 			     call com_err_ (error_table_$bad_conversion, WHOAMI,
      182 				"Table size must be a positive decimal integer, (0 for off), not ""^a"".", arg);
      183 			     goto MAIN_RETURN;
      184 			end;
      185 		end;
      186 	end;
      187 
      188 	if (table_size < 0) then do;			/* Print the current value */
      189 		call get_tty_segs ();
      190 
      191 		if (trace_array_ptr = null ()) then
      192 		     call ioa_ ("MCS Tracing is not enabled^[ in ERF ^a^;^s^].",
      193 			(erf_name ^= ""), erf_name);
      194 
      195 		else call ioa_ ("MCS Trace table size is ^d^[ in ERF ^a^;^s^].",
      196 			trace_array.num_entries, (erf_name ^= ""), erf_name);
      197 	     end;
      198 
      199 	else call set_table_size ();
      200 
      201 	goto MAIN_RETURN;				/* All done for table_size */
      202 
      203 /*  */
      204 
      205 PROCESS_MODES:
      206 	operation = "set trace modes";
      207 
      208 	do arg_index = 2 to arg_count;
      209 	     call cu_$arg_ptr (arg_index, arg_ptr, arg_lth, (0));
      210 
      211 	     if (arg = "-erf") then call get_erf_argument;
      212 	     else if (arg = "-brief") | (arg = "-bf") then brief_sw = "1"b;
      213 	     else if (arg = "-long") | (arg = "-lg") then brief_sw = "1"b;
      214 
      215 	     else if (index (arg, "-") = 1) then goto BADOPT_ERROR;
      216 
      217 	     else do;				/* Anything else is supposed to be a mode string */
      218 		     if (new_modes ^= "") then do;
      219 			     call com_err_ (error_table_$too_many_args, WHOAMI, "Extra mode string ^a", arg);
      220 			     goto MAIN_RETURN;
      221 			end;
      222 
      223 		     new_modes = arg;
      224 		end;
      225 	end;
      226 
      227 	call get_tty_segs ();
      228 	trace_mode_bits = string (tty_buf.trace.flags);	/* Get the current bit string value */
      229 
      230 	if (new_modes = "") then do;			/* Print the current value */
      231 		call get_trace_modes ();
      232 
      233 		call ioa_ ("MCS Trace modes^[ in ERF ^a^;^s^]: ^a",
      234 		     (erf_name ^= ""), erf_name, trace_mode_string);
      235 	     end;
      236 
      237 	else do;
      238 		call check_if_update_allowed ();
      239 
      240 		call set_trace_modes (new_modes);
      241 
      242 		call hphcs_$set_mcm_global_trace (trace_mode_bits, code);
      243 		if code ^= 0 then call com_err_ (code, WHOAMI,
      244 			"Cannot change trace modes to ^a", new_modes);
      245 		else if ^brief_sw then do;
      246 			call get_trace_modes ();
      247 			call ioa_ ("New MCS trace modes: ^a", trace_mode_string);
      248 		     end;
      249 	     end;
      250 
      251 	goto MAIN_RETURN;				/* All done for mode setting */
      252 
      253 /*  */
      254 
      255 PROCESS_CHANNEL:
      256 	operation = "set channel tracing";
      257 
      258 	do arg_index = 2 to arg_count;
      259 	     call cu_$arg_ptr (arg_index, arg_ptr, arg_lth, (0));
      260 
      261 	     if (arg = "-erf") then call get_erf_argument;
      262 	     else if (arg = "-print") | (arg = "-pr") then print_sw = "1"b;
      263 	     else if (arg = "-force") | (arg = "-fc") then force_sw = "1"b;
      264 	     else if (arg = "-on") then on_sw = "1"b;
      265 	     else if (arg = "-off") then off_sw = "1"b;
      266 
      267 	     else if (index (arg, "-") = 1) then goto BADOPT_ERROR;
      268 
      269 	     else call add_to_array /* Anything else is supposed to be a channel name */
      270 		     (arg, channel, n_channels, "channel name", "1"b);
      271 	end;					/* Of argument loop */
      272 
      273 	if (on_sw & off_sw) then call inconsistent ("-on and -off");
      274 	if (force_sw & ^(on_sw | off_sw)) then call inconsistent ("-force and not -on");
      275 
      276 	if ^(on_sw | off_sw | print_sw) then do;
      277 		call com_err_ (error_table_$noarg, WHOAMI,
      278 		     "At least one of -on, -off, or -print must be specified to ^a", operation);
      279 		goto MAIN_RETURN;
      280 	     end;
      281 
      282 	if (n_channels = 0) then do;
      283 		call com_err_ (error_table_$noarg, WHOAMI,
      284 		     "At least one channel name must be specified to ^a", operation);
      285 		goto MAIN_RETURN;
      286 	     end;
      287 
      288 	if (on_sw | off_sw) then
      289 	     call check_if_update_allowed ();
      290 
      291 	call get_tty_segs ();
      292 
      293 	call set_channel_tracing ();
      294 
      295 	goto MAIN_RETURN;				/* All done for setting per- channel tracing */
      296 
      297 /*  */
      298 
      299 PROCESS_RESET:
      300 	operation = "reset MCS tracing";
      301 
      302 	if (arg_count > 2) then do;
      303 		call com_err_ (error_table_$too_many_args, WHOAMI, "No additional arguments are permitted.");
      304 		goto MAIN_RETURN;
      305 	     end;
      306 
      307 	call check_if_update_allowed ();
      308 
      309 	call get_tty_segs ();
      310 
      311 	call set_trace_modes ("off,^default,none");	/* Everything off */
      312 
      313 	call hphcs_$set_mcm_global_trace (trace_mode_bits, code);
      314 	if code ^= 0 then do;
      315 		call com_err_ (code, WHOAMI, "Cannot set tracing modes to reset state.");
      316 		goto MAIN_RETURN;
      317 	     end;
      318 
      319 	call hphcs_$set_mcm_trace_table_size (0, code);
      320 	if code ^= 0 then do;
      321 		call com_err_ (code, WHOAMI, "Cannot set trace table size to zero.");
      322 		goto MAIN_RETURN;
      323 	     end;
      324 
      325 	begin;
      326 
      327 	     declare chan_idx	      fixed bin;
      328 	     declare chan_name	      char (32);
      329 
      330 	     do chan_idx = 1 to lct.max_no_lctes;
      331 		lctep = addr (lct.lcte_array (chan_idx));
      332 
      333 		if (lcte.trace | lcte.trace_force) then do;
      334 			chan_name = lcnt.names (chan_idx);
      335 			if (unspec (chan_name) = ""b) then chan_name = "";
      336 
      337 			call hphcs_$set_mcm_channel_trace (chan_idx, "00"b, code);
      338 			if code ^= 0 then call com_err_ (code, WHOAMI,
      339 				"Cannot reset channel tracing for devx ^d.^[ (^a)^]",
      340 				chan_idx, (chan_name ^= ""), chan_name);
      341 		     end;
      342 	     end;					/* Of loop through LCTEs */
      343 	end;					/* Begin block */
      344 
      345 	goto MAIN_RETURN;
      346 
      347 /*  */
      348 
      349 PROCESS_PRINT:
      350 	operation = "print trace entries";
      351 
      352 	do arg_index = 2 to arg_count;
      353 	     call cu_$arg_ptr (arg_index, arg_ptr, arg_lth, (0));
      354 
      355 	     if (arg = "-erf") then call get_erf_argument;
      356 	     else if (arg = "-reset") | (arg = "-rs") then reset_sw = "1"b;
      357 	     else if (arg = "-all") | (arg = "-a") then all_sw = "1"b;
      358 	     else if (arg = "-reverse") | (arg = "-rev") | (arg = "-rv") then reverse_sw = "1"b;
      359 
      360 	     else if (arg = "-last") | (arg = "-lt") then do;
      361 		     if (last_count > 0) then do;
      362 			     call com_err_ (error_table_$too_many_args, WHOAMI, "Extra -last count ^a", arg);
      363 			     goto MAIN_RETURN;
      364 			end;
      365 
      366 		     call get_next_argument ("Count for -last");
      367 		     last_count = cv_dec_check_ (arg, code);
      368 		     if (code ^= 0) | (last_count <= 0) then do;
      369 			     call com_err_ (error_table_$bad_conversion, WHOAMI,
      370 				"Count for -last must be a number greater than zero, not ""^a"".", arg);
      371 			     goto MAIN_RETURN;
      372 			end;
      373 		end;
      374 
      375 	     else if (arg = "-channel") | (arg = "-chan") | (arg = "-chn") then do;
      376 		     call get_next_argument ("Channel name");
      377 		     call add_to_array (arg, channel, n_channels, "channel name", "1"b);
      378 		end;
      379 
      380 	     else if (arg = "-match") | (arg = "-mh") then do;
      381 		     call get_next_argument ("Match string");
      382 		     call add_to_array (arg, match, n_matches, "match string", "0"b);
      383 		end;
      384 
      385 	     else if (arg = "-exclude") | (arg = "-ex") then do;
      386 		     call get_next_argument ("Exclude string");
      387 		     call add_to_array (arg, exclude, n_excludes, "exclude string", "0"b);
      388 		end;
      389 
      390 	     else if (index (arg, "-") = 1) then goto BADOPT_ERROR;
      391 
      392 	     else call add_to_array /* Anything else is supposed to be a channel name */
      393 		     (arg, channel, n_channels, "channel name", "1"b);
      394 
      395 	end;					/* Of argument loop */
      396 
      397 	if reverse_sw & ^(all_sw | (last_count > 0)) then
      398 	     call inconsistent ("-reverse without -last or -all");
      399 
      400 	call get_tty_segs ();
      401 
      402 	if (trace_array_ptr = null ()) then
      403 	     call ioa_ ("^a: There is no MCS trace array defined^[ in ERF ^a^;^s^].",
      404 		WHOAMI, (erf_name ^= ""), erf_name);
      405 
      406 	else if (binary (trace_array.idx, 36) <= 1) then
      407 	     call ioa_ ("^a: The MCS trace array is empty^[ in ERF ^a^;^s^]",
      408 		WHOAMI, (erf_name ^= ""), erf_name);
      409 
      410 	else call print_trace_entries ();
      411 
      412 	goto MAIN_RETURN;				/* All done for printing trace entries */
      413 
      414 /*  */
      415 
      416 get_tty_segs:
      417      procedure ();
      418 
      419 	declare erf_number		 char (32);
      420 
      421 	call get_temp_segments_ (WHOAMI, temp_segs, code);
      422 	if code ^= 0 then do;
      423 		call com_err_ (code, WHOAMI, "Getting termporary segments.");
      424 		goto MAIN_RETURN;
      425 	     end;
      426 
      427 	ttybp = temp_segs (1);
      428 	areap = temp_segs (2);
      429 
      430 	if (erf_name = "") then erf_number = "-1";
      431 	else do;
      432 		erf_number = erf_name;
      433 		last_trace_time, last_trace_idx = 0;
      434 	     end;
      435 	call copy_erf_seg_$name (erf_number, "tty_buf", ttybp, (0), code);
      436 	if code ^= 0 then do;
      437 		call com_err_ (code, WHOAMI, "Cannot copy tty_buf.");
      438 		goto MAIN_RETURN;
      439 	     end;
      440 
      441 	call copy_erf_seg_$name (erf_number, "tty_area", areap, (0), code);
      442 	if code ^= 0 then do;
      443 		call com_err_ (code, WHOAMI, "Cannot copy tty_area.");
      444 		goto MAIN_RETURN;
      445 	     end;
      446 
      447 	lctp = pointer (ttybp, rel (tty_buf.lct_ptr));
      448 	lcntp = pointer (areap, rel (lct.lcnt_ptr));
      449 
      450 	if (tty_buf.trace.data_offset = ""b) then
      451 	     trace_array_ptr = null ();
      452 	else do;
      453 		trace_array_ptr = pointer (ttybp, tty_buf.trace.data_offset);
      454 		if last_trace_idx = 0 then last_trace_idx = trace_array.num_entries;
      455 		if trace_array.entry (last_trace_idx).time = last_trace_time then
      456 		     trace_idx = mod (last_trace_idx, trace_array.num_entries) + 1;
      457 		else trace_idx = mod (binary (trace_array.idx, 18), trace_array.num_entries) + 1;
      458 	     end;
      459 
      460 	return;
      461      end get_tty_segs;
      462 
      463 /*  */
      464 
      465 check_if_update_allowed:
      466      procedure ();
      467 
      468 	declare temp_entry		 entry variable;
      469 
      470 
      471 	if (erf_name ^= "") then do;
      472 		call com_err_ (0, WHOAMI,
      473 		     "MCS Tracing parameters may not be altered in an FDUMP. Cannot ^a.", operation);
      474 		goto MAIN_RETURN;
      475 	     end;
      476 
      477 	on condition (linkage_error) begin;
      478 		call com_err_ (0, WHOAMI, "This operation requires access to hphcs_. Cannot ^a.", operation);
      479 		goto MAIN_RETURN;
      480 	     end;
      481 
      482 	temp_entry = hphcs_$set_mcm_trace_table_size;
      483 
      484 	revert condition (linkage_error);
      485 
      486 	return;
      487      end check_if_update_allowed;
      488 
      489 /*  */
      490 
      491 set_table_size:
      492      procedure ();
      493 
      494 	declare yes_sw		 bit (1) aligned;
      495 	declare new_size		 fixed bin (18);
      496 	declare new_free		 fixed bin (18);
      497 	declare percent_used	 float bin;
      498 
      499 
      500 	call check_if_update_allowed ();
      501 
      502 	call get_tty_segs ();
      503 
      504 	new_size = size (trace_entry) * table_size;
      505 
      506 	if (trace_array_ptr ^= null ()) then
      507 	     new_free = tty_buf.bleft + (size (trace_entry) * trace_array.num_entries);
      508 	else new_free = tty_buf.bleft;
      509 
      510 	percent_used = 100.0e0 * (float (new_size) / float (new_free));
      511 
      512 	if (percent_used > 50.0e0) then do;
      513 		call command_query_$yes_no (yes_sw, 0, WHOAMI, "",
      514 		     "The new table will use ^.1f percent of the free space in tty_buf.^/Do you still wish to set table size to ^d?",
      515 		     percent_used, table_size);
      516 
      517 		if ^yes_sw then goto MAIN_RETURN;
      518 	     end;
      519 
      520 	if (trace_array_ptr ^= null ()) then do;	/* Just clear out the old one first */
      521 		call hphcs_$set_mcm_trace_table_size (0, code);
      522 		if code ^= 0 then do;
      523 			call com_err_ (code, WHOAMI, "Cannot remove old trace table.");
      524 			goto MAIN_RETURN;
      525 		     end;
      526 	     end;
      527 
      528 	call hphcs_$set_mcm_trace_table_size (table_size, code);
      529 	if code ^= 0 then
      530 	     call com_err_ (code, WHOAMI, "Setting trace table size to ^d", table_size);
      531 
      532 	return;
      533      end set_table_size;
      534 
      535 /*  */
      536 
      537 set_trace_modes:
      538      procedure (P_new_modes);
      539 
      540 	declare P_new_modes		 char (*) parameter;
      541 	declare modes_area		 area (1000);
      542 	declare idx		 fixed bin;
      543 
      544 
      545 	call mode_string_$parse (P_new_modes, addr (modes_area), mode_string_info_ptr, code);
      546 	if (code ^= 0) then do;
      547 		call com_err_ (code, WHOAMI, "Mode string ^a", P_new_modes);
      548 		goto MAIN_RETURN;
      549 	     end;
      550 
      551 	do idx = 1 to mode_string_info.number;
      552 	     mode_value_ptr = addr (mode_string_info.modes (idx));
      553 	     if (^mode_value.boolean_valuep) then do;
      554 		     call com_err_ (error_table_$bad_mode, WHOAMI,
      555 			"The value for the ^a mode must be boolean^[, not character^]^[, not numeric^].",
      556 			mode_value.mode_name, mode_value.char_valuep, mode_value.numeric_valuep);
      557 		     goto MAIN_RETURN;
      558 		end;
      559 
      560 	     call set_single_mode (mode_value.mode_name, mode_value.boolean_value);
      561 	end;
      562 
      563 	return;
      564      end set_trace_modes;
      565 
      566 /*  */
      567 
      568 /* This procedure is used both for setting modes and building the mode string.
      569*   The reason for its hirsute flow of control is to allow all the correspondence
      570*   between mode names and mode bit names to be centralized in a single place:
      571*   the list of calls to process_mode. To add new modes, just put in a new call
      572*   to process_mode in the right place in the list (either before or after the
      573*   assignment to set_all_modes, depending on whether the mode should be affected
      574*   by use of the "all" or "none" mode names. */
      575 
      576 process_modes:
      577      procedure ();
      578 
      579 	declare P_new_mode_value	 bit (1) unaligned parameter;
      580 	declare P_set_mode_name	 char (*) parameter;
      581 
      582 	declare 1 trace_modes	 unaligned like tty_buf.trace.flags;
      583 
      584 	declare function		 char (16) varying;
      585 	declare all_mode_sw		 bit (1) aligned;	/* Means we are processing "all" or "none" */
      586 	declare all_mode_value	 bit (1) aligned;	/* Value for above */
      587 	declare set_all_modes	 bit (1) aligned;	/* Set to indicate start of modes in "all" set */
      588 
      589 
      590 get_trace_modes:
      591      entry ();
      592 
      593 	function = "add";
      594 
      595 	trace_mode_string = "";
      596 
      597 	goto PROCESS_MODES_COMMON;
      598 
      599 
      600 set_single_mode:
      601      entry (P_set_mode_name, P_new_mode_value);
      602 
      603 	function = "set";
      604 	set_all_modes = "0"b;
      605 
      606 	if (P_set_mode_name = "all") then do;
      607 		if P_new_mode_value = "0"b then goto BAD_MODE_VALUE;
      608 		all_mode_sw = "1"b;
      609 		all_mode_value = "1"b;
      610 	     end;
      611 
      612 	else if (P_set_mode_name = "none") then do;
      613 		if P_new_mode_value = "0"b then goto BAD_MODE_VALUE;
      614 		all_mode_sw = "1"b;
      615 		all_mode_value = "0"b;
      616 	     end;
      617 
      618 	else all_mode_sw = "0"b;
      619 
      620 	if (P_set_mode_name = "off") then do;
      621 		P_set_mode_name = "on";
      622 		P_new_mode_value = ^P_new_mode_value;
      623 	     end;
      624 
      625 PROCESS_MODES_COMMON:
      626 	string (trace_modes) = trace_mode_bits;		/* Get the current values */
      627 
      628 	call process_mode (trace_modes.enable, "on");
      629 	call process_mode (trace_modes.default_mode, "default");
      630 
      631 	set_all_modes = all_mode_sw;
      632 
      633 	call process_mode (trace_modes.read, "read");
      634 	call process_mode (trace_modes.write, "write");
      635 	call process_mode (trace_modes.data, "data");
      636 	call process_mode (trace_modes.control, "control");
      637 	call process_mode (trace_modes.modes, "modes");
      638 	call process_mode (trace_modes.interrupt, "interrupt");
      639 	call process_mode (trace_modes.init, "init_mpx");
      640 	call process_mode (trace_modes.start, "start_mpx");
      641 	call process_mode (trace_modes.shutdown, "stop_mpx");
      642 	call process_mode (trace_modes.space_man, "space_man");
      643 
      644 	if (function = "set") & (^all_mode_sw) then do;	/* We fell through to here without finding the mode */
      645 BAD_MODE_VALUE:
      646 		call com_err_ (error_table_$bad_mode, WHOAMI,
      647 		     "^[^^^]^a", P_new_mode_value, P_set_mode_name);
      648 		goto MAIN_RETURN;
      649 	     end;
      650 
      651 FINISHED_SETTING_MODE:
      652 	if (function = "set") then /* Update the bit string */
      653 	     string (trace_mode_bits) = string (trace_modes);
      654 
      655 	return;
      656 
      657 /*  */
      658 
      659 /* Procedure to either add a single mode to the string, or, if the mode
      660*   name matches, set the mode value for a single mode. */
      661 
      662 process_mode:
      663      procedure (P_mode_bit, P_mode_name);
      664 
      665 	declare P_mode_bit		 bit (1) unaligned parameter;
      666 	declare P_mode_name		 char (16) varying;
      667 
      668 	if function = "add" then do;
      669 		if (length (trace_mode_string) > 0) then
      670 		     trace_mode_string = trace_mode_string || ",";
      671 
      672 		if P_mode_bit then
      673 		     trace_mode_string = trace_mode_string || P_mode_name;
      674 		else trace_mode_string = trace_mode_string || "^" || P_mode_name;
      675 	     end;
      676 
      677 	else if function = "set" then do;
      678 		if set_all_modes then do;
      679 			P_mode_bit = all_mode_value;
      680 			return;
      681 		     end;
      682 
      683 		if P_set_mode_name ^= P_mode_name then return; /* Not the right one */
      684 		P_mode_bit = P_new_mode_value;
      685 		goto FINISHED_SETTING_MODE;
      686 	     end;
      687 
      688      end process_mode;
      689 
      690      end process_modes;
      691 
      692 /*  */
      693 
      694 /* This procedure sets tracing for specified channels, and/or prints the state o tracing */
      695 
      696 set_channel_tracing:
      697      procedure ();
      698 
      699 	declare chan_idx		 fixed bin;
      700 	declare name_idx		 fixed bin;
      701 	declare channel_name	 char (32);
      702 	declare trace_flags		 bit (2) aligned;
      703 	declare matching_channels	 fixed bin;
      704 	declare old_state		 char (16) varying;
      705 	declare new_state		 char (16) varying;
      706 
      707 
      708 	trace_flags = ""b;
      709 	substr (trace_flags, 1, 1) = on_sw;
      710 	substr (trace_flags, 2, 1) = force_sw;
      711 	call ioa_$rsnnl ("^[on^;off^]^[, default^]", new_state, (0), on_sw, force_sw);
      712 
      713 	matching_channels = 0;
      714 
      715 	do chan_idx = 1 to lct.max_no_lctes;
      716 	     lctep = addr (lct.lcte_array (chan_idx));
      717 	     channel_name = lcnt.names (chan_idx);
      718 
      719 	     if unspec (channel_name) = ""b then goto NEXT_CHANNEL;
      720 	     if channel_name = "" then goto NEXT_CHANNEL;
      721 
      722 	     do name_idx = 1 to n_channels;
      723 		call match_star_name_ (channel_name, (channel (name_idx)), code);
      724 		if code = 0 then goto THIS_CHANNEL;
      725 	     end;
      726 
      727 	     goto NEXT_CHANNEL;			/* Matched none of the possibilities */
      728 
      729 THIS_CHANNEL:
      730 	     matching_channels = matching_channels + 1;
      731 	     if (matching_channels = 1) & print_sw then /* Print header */
      732 		call ioa_ ("Devx^2xName^36tState (default is ^[on^;off^])",
      733 		     tty_buf.trace.flags.default_mode);
      734 
      735 	     call ioa_$rsnnl ("^[on^;off^]^[, force^]",
      736 		old_state, (0), lcte.trace, lcte.trace_force);
      737 
      738 	     if (on_sw | off_sw) then do;
      739 		     call hphcs_$set_mcm_channel_trace (chan_idx, trace_flags, code);
      740 		     if code ^= 0 then call com_err_ (code, WHOAMI,
      741 			     "Cannot set tracing on ^a to ^a.", channel_name, new_state);
      742 		     if print_sw then call ioa_ ("^4d^2x^a^36t^a (was ^a)",
      743 			     chan_idx, channel_name, new_state, old_state);
      744 		end;
      745 
      746 	     else if print_sw then
      747 		call ioa_ ("^4d^2x^a^36t^a",
      748 		     chan_idx, channel_name, old_state);
      749 
      750 NEXT_CHANNEL:
      751 	end;
      752 
      753 	if (matching_channels = 0) then
      754 	     call ioa_ ("^a: No channels matched supplied names.", WHOAMI);
      755 
      756 	else if print_sw then call ioa_ ("");
      757 
      758 	return;
      759      end set_channel_tracing;
      760 
      761 /*  */
      762 
      763 print_trace_entries:
      764      procedure ();
      765 
      766 	declare channel_name	 char (32);
      767 	declare first_idx		 fixed bin;
      768 	declare last_idx		 fixed bin;
      769 	declare increment		 fixed bin;
      770 	declare entry_idx		 fixed bin;
      771 	declare real_entry_idx	 fixed bin;
      772 
      773 
      774 	if all_sw then last_count = trace_array.num_entries; /* Fake up printin them all */
      775 
      776 	if (last_count > 0) then do;
      777 		if (last_count > trace_array.num_entries) then do;
      778 			call ioa_ ("Cannot print last ^d entries; maximum will be ^d",
      779 			     last_count, trace_array.num_entries);
      780 			last_count = trace_array.num_entries;
      781 		     end;
      782 
      783 		if reverse_sw then do;
      784 			increment = -1;
      785 			first_idx = binary (trace_array.idx) - 1;
      786 			last_idx = (first_idx - last_count) + 1;
      787 		     end;
      788 		else do;
      789 			increment = 1;
      790 			last_idx = binary (trace_array.idx) - 1;
      791 			first_idx = (last_idx - last_count) + 1;
      792 		     end;
      793 
      794 		do entry_idx = first_idx to last_idx by increment;
      795 
      796 		     real_entry_idx = 1 + mod ((entry_idx - 1), trace_array.num_entries);
      797 		     trace_entry_ptr = addr (trace_array.entry (real_entry_idx));
      798 		     channel_name = lcnt.names (trace_entry.devx);
      799 
      800 		     if (trace_entry.time > 0) then
      801 			if entry_matches () then
      802 			     call print_single_entry ();
      803 		end;				/* Of loop through trace entries */
      804 
      805 		return;				/* All done here */
      806 	     end;					/* Of case for -last */
      807 
      808 	do while ((trace_array.entry (trace_idx).time + 10000 > last_trace_time)
      809 	     & (trace_array.entry (trace_idx).time > 0));
      810 
      811 	     trace_entry_ptr = addr (trace_array.entry (trace_idx));
      812 	     channel_name = lcnt.names (trace_entry.devx);
      813 
      814 	     if entry_matches () then call print_single_entry ();
      815 
      816 NEXT_TRACE_ENTRY:
      817 	     last_trace_idx = trace_idx;
      818 	     last_trace_time = trace_entry.time;
      819 	     trace_idx = mod (trace_idx, trace_array.num_entries) + 1;
      820 	end;
      821 
      822 	return;
      823 
      824 /*  */
      825 
      826 
      827 entry_matches:
      828      procedure () returns (bit (1) aligned);
      829 
      830 	declare name_idx		 fixed bin;
      831 
      832 
      833 	do name_idx = 1 to n_channels;
      834 	     call match_star_name_ (channel_name, (channel (name_idx)), code);
      835 	     if code = 0 then goto CHECK_FOR_STRINGS;
      836 	end;
      837 
      838 	if (n_channels > 0) then return ("0"b);		/* No channels matched */
      839 
      840 CHECK_FOR_STRINGS:
      841 	do name_idx = 1 to n_excludes;
      842 	     if index (rtrim (trace_entry.message), exclude (name_idx)) ^= 0 then
      843 		return ("0"b);			/* Exclude strig matches */
      844 	end;
      845 
      846 	do name_idx = 1 to n_matches;
      847 	     if index (rtrim (trace_entry.message), match (name_idx)) ^= 0 then
      848 		return ("1"b);			/* Match string matches */
      849 	end;
      850 
      851 	if (n_matches > 0) then return ("0"b);		/* If none matched, and there were some, just go on */
      852 
      853 	return ("1"b);
      854      end entry_matches;
      855 
      856 /*  */
      857 
      858 print_single_entry:
      859      procedure ();
      860 
      861 	declare time_form		 char (22) int static options (constant) init ("^Hd:^MH:^99v.999999SM");
      862 	if (channel_name = "") | (unspec (channel_name) = ""b) then
      863 	     call ioa_$rsnnl ("^o", channel_name, (0), trace_entry.devx);
      864 
      865 	call ioa_ ("^16a ^a: ^a",
      866 	     date_time_$format (time_form, trace_entry.time, "", ""),
      867 	     channel_name, trace_entry.message);
      868 
      869 	return;
      870      end print_single_entry;
      871 
      872      end print_trace_entries;
      873 
      874 /*  */
      875 
      876 get_erf_argument:
      877      procedure ();
      878 
      879 	call get_next_argument ("ERF name");
      880 
      881 	if (erf_name ^= "") then do;
      882 		call com_err_ (error_table_$too_many_args, WHOAMI, "Extra ERF name ^a", arg);
      883 		goto MAIN_RETURN;
      884 	     end;
      885 
      886 	erf_name = arg;
      887 
      888 	return;
      889      end;
      890 
      891 
      892 
      893 get_next_argument:
      894      procedure (P_name);
      895 
      896 	declare P_name		 char (*) parameter;
      897 
      898 
      899 	if (arg_index >= arg_count) then do;
      900 		call com_err_ (error_table_$noarg, WHOAMI, "^a after ^a", P_name, arg);
      901 		goto MAIN_RETURN;
      902 	     end;
      903 
      904 	arg_index = arg_index + 1;
      905 	call cu_$arg_ptr (arg_index, arg_ptr, arg_lth, (0));
      906 
      907 	return;
      908      end get_next_argument;
      909 
      910 /*  */
      911 
      912 add_to_array:
      913      procedure (P_name, P_array, P_array_size, P_description, P_check_starname);
      914 
      915 	declare P_name		 char (*) parameter;
      916 	declare P_array		 (*) char (*) varying parameter;
      917 	declare P_array_size	 fixed bin;
      918 	declare P_description	 char (*);
      919 	declare P_check_starname	 bit (1) aligned;
      920 
      921 
      922 	if P_check_starname then do;
      923 		call check_star_name_$entry (P_name, code);
      924 		if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
      925 			call com_err_ (code, WHOAMI, "Invalid ^a: ^a",
      926 			     P_description, P_name);
      927 			goto MAIN_RETURN;
      928 		     end;
      929 	     end;
      930 
      931 	if (P_array_size >= hbound (P_array, 1)) then do;
      932 		call com_err_ (error_table_$too_many_args, WHOAMI,
      933 		     "Too many ^as. Max is ^d.", P_description, hbound (P_array, 1));
      934 		goto MAIN_RETURN;
      935 	     end;
      936 
      937 	if (length (P_name) > maxlength (P_array (1))) then do;
      938 		call com_err_ (error_table_$bigarg, WHOAMI,
      939 		     "The ^a may only be ^d characters long. ^a",
      940 		     P_description, maxlength (P_array (1)), P_name);
      941 		goto MAIN_RETURN;
      942 	     end;
      943 
      944 	P_array_size = P_array_size + 1;
      945 	P_array (P_array_size) = P_name;
      946 
      947 	return;
      948      end add_to_array;
      949 
      950 /*  */
      951 
      952 cleanup_procedure:
      953      procedure ();
      954 
      955 	if (temp_segs (1) ^= null ()) then
      956 	     call release_temp_segments_ (WHOAMI, temp_segs, (0));
      957 
      958 	return;
      959      end cleanup_procedure;
      960 
      961  /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  1     2 
  1     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  1     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  1     5 
  1     6 declare	mode_value_ptr		ptr,
  1     7 	number_of_modes		fixed bin;
  1     8 
  1     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  1    10 	  2 version		fixed bin,
  1    11 	  2 number		fixed bin,
  1    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  1    13 
  1    14 declare	mode_string_info_ptr	ptr;
  1    15 
  1    16 declare	1 mode_value		aligned based (mode_value_ptr),
  1    17 	  2 version		fixed bin,
  1    18 	  2 mode_name		char (32) unaligned,
  1    19 	  2 flags,
  1    20 	    3 boolean_valuep	bit (1) unaligned,
  1    21 	    3 numeric_valuep	bit (1) unaligned,
  1    22 	    3 char_valuep		bit (1) unaligned,
  1    23 	    3 boolean_value		bit (1) unaligned,
  1    24 	    3 pad1		bit (32) unaligned,
  1    25 	  2 numeric_value		fixed bin (35),
  1    26 	  2 char_value		char (32) varying,
  1    27 	  2 code			fixed bin (35),
  1    28 	  2 pad2			bit (36);
  1    29 
  1    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  1    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  1    32 
  1    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
      961 
      962  /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  2     2 
  2     3 /* Date Last Modified and Reason
  2     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  2     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  2     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  2     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  2     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  2     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  2    10*   Modified November 1979 by C. Hornig for MCS tracing.
  2    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  2    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  2    13*   Modified March 1980 by Robert Coren to reorganize metering information
  2    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  2    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  2    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  2    17**/
  2    18 
  2    19 dcl  ttybp ptr,
  2    20      tty_buf$ ext static,				/* tty buffer segment */
  2    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  2    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  2    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  2    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  2    25 
  2    26 
  2    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  2    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  2    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  2    30 
  2    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  2    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  2    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  2    34 
  2    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  2    36     2 slock bit (36),				/* per system lock */
  2    37     2 absorig fixed bin (24),				/* abs address of this seg */
  2    38     2 borig bit (18),				/* index of start of buffer area */
  2    39     2 bleft fixed bin (18),				/* words left in pool */
  2    40     2 free bit (18),				/* pointer to start of free pool */
  2    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  2    42     2 padb1 bit (28) unaligned,
  2    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  2    44 
  2    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  2    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  2    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  2    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  2    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  2    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  2    51     2 minbuf fixed bin (18),				/* min output buffer size */
  2    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  2    53 
  2    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  2    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  2    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  2    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  2    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  2    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  2    60 
  2    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  2    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  2    63     2 bfx fixed bin,				/* used in calls to iobm */
  2    64     2 nquits fixed bin (35),				/* number of quits */
  2    65     2 space_needed_data,
  2    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  2    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  2    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  2    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  2    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  2    71 
  2    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  2    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  2    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  2    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  2    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  2    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  2    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  2    79 
  2    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  2    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  2    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  2    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  2    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  2    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  2    86 
  2    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  2    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  2    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  2    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  2    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  2    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  2    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  2    94 
  2    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  2    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  2    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  2    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  2    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  2   100     2 echo_neg_mux_nonecho fixed bin (35),
  2   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  2   102 
  2   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  2   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  2   105     2 trace unaligned,				/* tracing information */
  2   106       3 flags,
  2   107       4 enable bit,					/* global tracing control */
  2   108       4 default_mode bit,				/* whether to trace channels by default */
  2   109       4 read bit,					/* read */
  2   110       4 write bit,					/* write */
  2   111       4 data bit,					/* buffers on reads and writes */
  2   112       4 control bit,				/* control, priv_control, and hpriv_control */
  2   113       4 modes bit,					/* (get set check)_modes */
  2   114       4 interrupt bit,				/* interrupt, interrupt_later */
  2   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  2   116       4 start bit,					/* start, stop */
  2   117       4 shutdown bit,				/* shutdown */
  2   118       4 space_man bit,				/* tty_space_man$* */
  2   119       4 pad_flags bit (6),
  2   120       3 data_offset bit (18),				/* offset of tracing data */
  2   121 
  2   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  2   123 
  2   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  2   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  2   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  2   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  2   128 
  2   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  2   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  2   131 
  2   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  2   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  2   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  2   135 
  2   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  2   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  2   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  2   139 
  2   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  2   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  2   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  2   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  2   144 
  2   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  2   146 
  2   147     2 pad2 (13) fixed bin (35),
  2   148 
  2   149     2 free_space fixed bin;				/* start of free space region */
  2   150 
  2   151 
  3     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  3     2 
  3     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  3     4 
  3     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     6 
  3     7 /* format: style3 */
  3     8 
  3     9 declare	lock_ptr		pointer;
  3    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  3    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    13 	  2 flags		aligned,
  3    14 	    3 notify_sw	bit (1) unaligned,
  3    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    16 
  3    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2   152 
  2   153 
  2   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      962 
      963  /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      963 
      964  /* Begin include file mcs_trace_data.incl.pl1 */
  5     2 
  5     3 dcl (trace_array_ptr, trace_entry_ptr) pointer;
  5     4 dcl  trace_array_size uns fixed bin (18);
  5     5 
  5     6 dcl 1 trace_array aligned based (trace_array_ptr),	/* trace control information */
  5     7     2 num_entries uns fixed bin (18),			/* number of entries in trace table */
  5     8     2 idx bit (36) aligned,				/* index of next entry to use */
  5     9     2 entry (trace_array_size refer (trace_array.num_entries)) aligned like trace_entry;
  5    10 
  5    11 dcl 1 trace_entry aligned based (trace_entry_ptr),
  5    12     2 time fixed bin (71),				/* time sample taken */
  5    13     2 devx unsigned fixed bin (18) unaligned,		/* channel traced */
  5    14     2 message char (54) unaligned;
  5    15 
  5    16 /* End include file mcs_trace_data.incl.pl1 */
      964 
      965 
      966      end trace_mcs;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/02/85  1519.1  trace_mcs.pl1                     >spec>online>41-2>trace_mcs.pl1
961          1    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
962          2    01/02/85  1316.8  tty_buf.incl.pl1                  >spec>online>41-2>tty_buf.incl.pl1
2-152        3    01/02/85  1316.9  hc_fast_lock.incl.pl1             >spec>online>41-2>hc_fast_lock.incl.pl1
963          4    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
964          5    06/30/80  1400.3  mcs_trace_data.incl.pl1           >ldd>include>mcs_trace_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_array                                parameter       varying char             array dcl 916 set ref 912 931 932 932 937 938 938
                                                                                  945*
P_array_size                           parameter       fixed bin(17,0)          dcl 917 set ref 912 931 944* 944 945
P_check_starname                       parameter       bit(1)                   dcl 919 ref 912 922
P_description                          parameter       char                     unaligned dcl 918 set ref 912 925* 932* 938*
P_error                                parameter       char                     unaligned dcl 149 set ref 146 151*
P_mode_bit                             parameter       bit(1)                   unaligned dcl 665 set ref 662 672 679* 684*
P_mode_name                            parameter       varying char(16)         dcl 666 ref 662 672 674 683
P_name                                 parameter       char                     unaligned dcl 915 in procedure "add_to_array" set
                                                                                  ref 912 923* 925* 937 938* 945
P_name                                 parameter       char                     unaligned dcl 896 in procedure "get_next_argument"
                                                                                  set ref 893 900*
P_new_mode_value                       parameter       bit(1)                   unaligned dcl 579 set ref 600 607 613 622* 622 645*
                                                                                  684
P_new_modes                            parameter       char                     unaligned dcl 540 set ref 537 545* 547*
P_set_mode_name                        parameter       char                     unaligned dcl 580 set ref 600 606 612 620 621* 645*
                                                                                  683
WHOAMI                          000006 constant        char(32)                 initial unaligned dcl 84 set ref 117* 122* 122* 136*
                                                                                  141* 151* 175* 181* 219* 243* 277* 283* 303* 315*
                                                                                  321* 338* 362* 369* 402* 406* 421* 423* 437* 443*
                                                                                  472* 478* 513* 523* 529* 547* 554* 645* 740* 753*
                                                                                  882* 900* 925* 932* 938* 955*
addr                                                   builtin function         dcl 88 ref 331 545 545 552 716 797 811
all_mode_sw                     003530 automatic       bit(1)                   dcl 585 set ref 608* 614* 618* 631 644
all_mode_value                  003531 automatic       bit(1)                   dcl 586 set ref 609* 615* 679
all_sw                          000122 automatic       bit(1)                   dcl 28 set ref 97* 357* 397 774
areap                           001364 automatic       pointer                  dcl 47 set ref 428* 441* 448
arg                                    based           char                     unaligned dcl 22 set ref 130 130 131 131 131 132 133
                                                                                  133 133 134 134 136* 141* 169 171 175* 179* 181*
                                                                                  211 212 212 213 213 215 219* 223 261 262 262 263
                                                                                  263 264 265 267 269* 355 356 356 357 357 358 358
                                                                                  358 360 360 362* 367* 369* 375 375 375 377* 380
                                                                                  380 382* 385 385 387* 390 392* 882* 886 900*
arg_count                       000100 automatic       fixed bin(17,0)          dcl 18 set ref 115* 121 166 208 258 302 352 899
arg_index                       000101 automatic       fixed bin(17,0)          dcl 19 set ref 127* 128* 166* 167* 208* 209* 258*
                                                                                  259* 352* 353* 899 904* 904 905*
arg_lth                         000102 automatic       fixed bin(21,0)          dcl 20 set ref 128* 130 130 131 131 131 132 133 133
                                                                                  133 134 134 136 136 141 141 167* 169 171 175 175
                                                                                  179 179 181 181 209* 211 212 212 213 213 215 219
                                                                                  219 223 259* 261 262 262 263 263 264 265 267 269
                                                                                  269 353* 355 356 356 357 357 358 358 358 360 360
                                                                                  362 362 367 367 369 369 375 375 375 377 377 380
                                                                                  380 382 382 385 385 387 387 390 392 392 882 882
                                                                                  886 900 900 905*
arg_ptr                         000104 automatic       pointer                  dcl 21 set ref 128* 130 130 131 131 131 132 133 133
                                                                                  133 134 134 136 141 167* 169 171 175 179 181 209*
                                                                                  211 212 212 213 213 215 219 223 259* 261 262 262
                                                                                  263 263 264 265 267 269 353* 355 356 356 357 357
                                                                                  358 358 358 360 360 362 367 369 375 375 375 377
                                                                                  380 380 382 385 385 387 390 392 882 886 900 905*
binary                                                 builtin function         dcl 88 ref 406 457 785 790
bleft                     3            based           fixed bin(18,0)          level 2 dcl 2-35 ref 506 508
boolean_value            11(03)        based           bit(1)                   level 3 packed unaligned dcl 1-16 set ref 560*
boolean_valuep           11            based           bit(1)                   level 3 packed unaligned dcl 1-16 ref 553
brief_sw                        000120 automatic       bit(1)                   dcl 26 set ref 95* 212* 213* 245
chan_idx                        001472 automatic       fixed bin(17,0)          dcl 327 in begin block on line 325 set ref 330* 331
                                                                                  334 337* 338*
chan_idx                        003550 automatic       fixed bin(17,0)          dcl 699 in procedure "set_channel_tracing" set ref
                                                                                  715* 716 717 739* 742* 746*
chan_name                       001473 automatic       char(32)                 unaligned dcl 328 set ref 334* 335 335* 338 338*
channel                         001073 automatic       varying char(32)         array dcl 45 set ref 269* 377* 392* 723 834
channel_name                    003606 automatic       char(32)                 unaligned dcl 766 in procedure "print_trace_entries"
                                                                                  set ref 798* 812* 834* 862 862 862* 865*
channel_name                    003552 automatic       char(32)                 unaligned dcl 701 in procedure "set_channel_tracing"
                                                                                  set ref 717* 719 720 723* 740* 742* 746*
char_valuep              11(02)        based           bit(1)                   level 3 packed unaligned dcl 1-16 set ref 554*
check_star_name_$entry          000032 constant        entry                    external dcl 65 ref 923
cleanup                         001430 stack reference condition                dcl 86 ref 112
code                            000106 automatic       fixed bin(35,0)          dcl 23 set ref 115* 116 117* 179* 180 242* 243 243*
                                                                                  313* 314 315* 319* 320 321* 337* 338 338* 367* 368
                                                                                  421* 422 423* 435* 436 437* 441* 442 443* 521* 522
                                                                                  523* 528* 529 529* 545* 546 547* 723* 724 739* 740
                                                                                  740* 834* 835 923* 924 924 924 925*
com_err_                        000036 constant        entry                    external dcl 67 ref 117 122 136 141 151 175 181 219
                                                                                  243 277 283 303 315 321 338 362 369 423 437 443
                                                                                  472 478 523 529 547 554 645 740 882 900 925 932
                                                                                  938
command_query_$yes_no           000034 constant        entry                    external dcl 66 ref 513
control                   0(05) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 636*
copy_erf_seg_$name              000040 constant        entry                    external dcl 68 ref 435 441
cu_$arg_count                   000042 constant        entry                    external dcl 69 ref 115
cu_$arg_ptr                     000044 constant        entry                    external dcl 70 ref 128 167 209 259 353 905
cv_dec_check_                   000046 constant        entry                    external dcl 71 ref 179 367
data                      0(04) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 635*
data_offset             102(18)        based           bit(18)                  level 3 packed unaligned dcl 2-35 ref 450 453
date_time_$format               000050 constant        entry                    external dcl 72 ref 865
default_mode            102(01)        based           bit(1)                   level 4 in structure "tty_buf" packed unaligned
                                                                                  dcl 2-35 in procedure "mcm_trace" set ref 731*
default_mode              0(01) 003522 automatic       bit(1)                   level 2 in structure "trace_modes" packed unaligned
                                                                                  dcl 582 in procedure "process_modes" set ref 629*
devx                      2            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 5-11 set ref
                                                                                  798 812 862*
empty                                                  builtin function         dcl 88 ref 541
enable                          003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 628*
entry                     2            based           structure                array level 2 dcl 5-6 set ref 797 811
entry_idx                       003621 automatic       fixed bin(17,0)          dcl 770 set ref 794* 796*
erf_name                        000170 automatic       char(32)                 unaligned dcl 38 set ref 104* 191 191* 195 195* 233
                                                                                  233* 402 402* 406 406* 430 432 471 881 886*
erf_number                      001512 automatic       char(32)                 unaligned dcl 419 set ref 430* 432* 435* 441*
error_table_$bad_conversion     000022 external static fixed bin(35,0)          dcl 60 set ref 181* 369*
error_table_$bad_mode           000024 external static fixed bin(35,0)          dcl 61 set ref 554* 645*
error_table_$badopt             000016 external static fixed bin(35,0)          dcl 58 set ref 141*
error_table_$bigarg             000030 external static fixed bin(35,0)          dcl 63 set ref 938*
error_table_$inconsistent       000026 external static fixed bin(35,0)          dcl 62 set ref 151*
error_table_$noarg              000014 external static fixed bin(35,0)          dcl 57 set ref 122* 277* 283* 900*
error_table_$too_many_args      000020 external static fixed bin(35,0)          dcl 59 set ref 175* 219* 303* 362* 882* 932*
exclude                         000201 automatic       varying char(40)         array dcl 41 set ref 387* 842
first_idx                       003616 automatic       fixed bin(17,0)          dcl 767 set ref 785* 786 791* 794
flags                   102            based           structure                level 3 in structure "tty_buf" packed unaligned
                                                                                  dcl 2-35 in procedure "mcm_trace" set ref 228
flags                    11            based           structure                level 2 in structure "mode_value" dcl 1-16
                                                                                  in procedure "mcm_trace"
flags                     2(09)        based           structure                level 2 in structure "lcte" packed unaligned
                                                                                  dcl 4-20 in procedure "mcm_trace"
float                                                  builtin function         dcl 88 ref 510 510
force_sw                        000126 automatic       bit(1)                   dcl 32 set ref 102* 263* 274 710 711*
function                        003523 automatic       varying char(16)         dcl 584 set ref 593* 603* 644 651 668 677
get_temp_segments_              000052 constant        entry                    external dcl 73 ref 421
hbound                                                 builtin function         dcl 88 ref 931 932 932
hc_fast_lock                           based           structure                level 1 dcl 3-10
hphcs_$set_mcm_channel_trace    000072 constant        entry                    external dcl 82 ref 337 739
hphcs_$set_mcm_global_trace     000070 constant        entry                    external dcl 81 ref 242 313
hphcs_$set_mcm_trace_table_size 000066 constant        entry                    external dcl 80 ref 319 482 521 528
idx                             003512 automatic       fixed bin(17,0)          dcl 542 in procedure "set_trace_modes" set ref 551*
                                                                                  552*
idx                       1            based           bit(36)                  level 2 in structure "trace_array" dcl 5-6
                                                                                  in procedure "mcm_trace" ref 406 457 785 790
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "mcm_trace"
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "mcm_trace"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "mcm_trace"
increment                       003620 automatic       fixed bin(17,0)          dcl 769 set ref 784* 789* 794
index                                                  builtin function         dcl 88 ref 171 215 267 390 842 847
init                      0(08) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 639*
interrupt                 0(07) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 638*
ioa_                            000054 constant        entry                    external dcl 74 ref 191 195 233 247 402 406 731 742
                                                                                  746 753 756 778 865
ioa_$rsnnl                      000056 constant        entry                    external dcl 75 ref 711 735 862
last_count                      000130 automatic       fixed bin(17,0)          dcl 35 set ref 110* 361 367* 368 397 774* 776 777
                                                                                  778* 780* 786 791
last_idx                        003617 automatic       fixed bin(17,0)          dcl 768 set ref 786* 790* 791 794
last_trace_idx                  000012 internal static fixed bin(17,0)          initial dcl 55 set ref 433* 454 454* 455 455 816*
last_trace_time                 000010 internal static fixed bin(71,0)          initial dcl 54 set ref 433* 455 808 818*
lcnt                                   based           structure                level 1 dcl 4-65
lcnt_ptr                  2            based           pointer                  level 2 dcl 4-11 ref 448
lcntp                           001450 automatic       pointer                  dcl 4-63 set ref 334 448* 717 798 812
lct                                    based           structure                level 1 dcl 4-11
lct_ptr                   6            based           pointer                  level 2 dcl 2-35 ref 447
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 331 716
lctep                           001446 automatic       pointer                  dcl 4-8 set ref 331* 333 333 716* 735 735
lctp                            001444 automatic       pointer                  dcl 4-7 set ref 330 331 447* 448 715 716
length                                                 builtin function         dcl 88 ref 669 937
linkage_error                   000000 stack reference condition                dcl 86 ref 477 484
match                           000536 automatic       varying char(40)         array dcl 43 set ref 382* 847
match_star_name_                000060 constant        entry                    external dcl 76 ref 723 834
matching_channels               003563 automatic       fixed bin(17,0)          dcl 703 set ref 713* 729* 729 731 753
max_no_lctes                           based           fixed bin(17,0)          level 2 dcl 4-11 ref 330 715
maxlength                                              builtin function         dcl 89 ref 937 938 938
message                   2(18)        based           char(54)                 level 2 packed unaligned dcl 5-11 set ref 842 847
                                                                                  865*
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "mcm_trace"
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "mcm_trace"
mod                                                    builtin function         dcl 89 ref 455 457 796 819
mode_name                 1            based           char(32)                 level 2 packed unaligned dcl 1-16 set ref 554* 560*
mode_string_$parse              000062 constant        entry                    external dcl 77 ref 545
mode_string_info                       based           structure                level 1 dcl 1-9
mode_string_info_ptr            001440 automatic       pointer                  dcl 1-14 set ref 545* 551 552
mode_value                             based           structure                level 1 dcl 1-16
mode_value_ptr                  001436 automatic       pointer                  dcl 1-6 set ref 552* 553 554 554 554 560 560
modes                     0(06) 003522 automatic       bit(1)                   level 2 in structure "trace_modes" packed unaligned
                                                                                  dcl 582 in procedure "process_modes" set ref 637*
modes                     2            based           structure                array level 2 in structure "mode_string_info"
                                                                                  dcl 1-9 in procedure "mcm_trace" set ref 552
modes_area                      001542 automatic       area(1000)               dcl 541 set ref 541* 545 545
n_channels                      001072 automatic       fixed bin(17,0)          dcl 44 set ref 107* 269* 282 377* 392* 722 833 838
n_excludes                      000200 automatic       fixed bin(17,0)          dcl 40 set ref 108* 387* 840
n_matches                       000535 automatic       fixed bin(17,0)          dcl 42 set ref 109* 382* 846 851
name_idx                        003634 automatic       fixed bin(17,0)          dcl 830 in procedure "entry_matches" set ref 833*
                                                                                  834* 840* 842* 846* 847*
name_idx                        003551 automatic       fixed bin(17,0)          dcl 700 in procedure "set_channel_tracing" set ref
                                                                                  722* 723*
names                                  based           char(32)                 array level 2 packed unaligned dcl 4-65 ref 334 717
                                                                                  798 812
new_free                        001532 automatic       fixed bin(18,0)          dcl 496 set ref 506* 508* 510
new_modes                       000132 automatic       char(120)                unaligned dcl 37 set ref 106* 218 223* 230 240* 243*
new_size                        001531 automatic       fixed bin(18,0)          dcl 495 set ref 504* 510
new_state                       003571 automatic       varying char(16)         dcl 705 set ref 711* 740* 742*
null                                                   builtin function         dcl 89 ref 94 191 402 450 506 520 955
num_entries                            based           fixed bin(18,0)          level 2 unsigned dcl 5-6 set ref 195* 454 455 457
                                                                                  506 774 777 778* 780 796 819
number                    1            based           fixed bin(17,0)          level 2 dcl 1-9 ref 551
numeric_valuep           11(01)        based           bit(1)                   level 3 packed unaligned dcl 1-16 set ref 554*
off_sw                          000125 automatic       bit(1)                   dcl 31 set ref 100* 265* 273 274 276 288 738
old_state                       003564 automatic       varying char(16)         dcl 704 set ref 735* 742* 746*
on_sw                           000124 automatic       bit(1)                   dcl 30 set ref 99* 264* 273 274 276 288 709 711* 738
operation                       000107 automatic       varying char(32)         dcl 24 set ref 163* 205* 255* 277* 283* 299* 349*
                                                                                  472* 478*
percent_used                    001533 automatic       float bin(27)            dcl 497 set ref 510* 512 513*
pointer                                                builtin function         dcl 89 ref 447 448 453
print_sw                        000127 automatic       bit(1)                   dcl 33 set ref 101* 262* 276 731 742 746 756
read                      0(02) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 633*
real_entry_idx                  003622 automatic       fixed bin(17,0)          dcl 771 set ref 796* 797
rel                                                    builtin function         dcl 89 ref 447 448
release_temp_segments_          000064 constant        entry                    external dcl 78 ref 955
reset_sw                        000121 automatic       bit(1)                   dcl 27 set ref 96* 356*
reverse_sw                      000123 automatic       bit(1)                   dcl 29 set ref 98* 358* 397 783
rtrim                                                  builtin function         dcl 89 ref 842 847
set_all_modes                   003532 automatic       bit(1)                   dcl 587 set ref 604* 631* 678
shutdown                  0(10) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 641*
size                                                   builtin function         dcl 89 ref 504 506
space_man                 0(11) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 642*
start                     0(09) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 640*
string                                                 builtin function         dcl 90 set ref 228 625* 651* 651
substr                                                 builtin function         dcl 90 set ref 709* 710*
table_size                      000131 automatic       fixed bin(17,0)          dcl 36 set ref 105* 174 179* 180 188 504 513* 528*
                                                                                  529*
temp_entry                      000100 automatic       entry variable           dcl 468 set ref 482*
temp_segs                       001360 automatic       pointer                  array dcl 46 set ref 94* 421* 427 428 955 955*
time                                   based           fixed bin(71,0)          level 2 in structure "trace_entry" dcl 5-11
                                                                                  in procedure "mcm_trace" set ref 800 818 865*
time                      2            based           fixed bin(71,0)          array level 3 in structure "trace_array" dcl 5-6
                                                                                  in procedure "mcm_trace" set ref 455 808 808
time_form                       000000 constant        char(22)                 initial unaligned dcl 861 set ref 865*
trace                     2(16)        based           bit(1)                   level 3 in structure "lcte" packed unaligned
                                                                                  dcl 4-20 in procedure "mcm_trace" set ref 333 735*
trace                   102            based           structure                level 2 in structure "tty_buf" packed unaligned
                                                                                  dcl 2-35 in procedure "mcm_trace"
trace_array                            based           structure                level 1 dcl 5-6
trace_array_ptr                 001452 automatic       pointer                  dcl 5-3 set ref 191 195 402 406 450* 453* 454 455
                                                                                  455 457 457 506 506 520 774 777 778 780 785 790
                                                                                  796 797 808 808 811 819
trace_entry                            based           structure                level 1 dcl 5-11 set ref 504 506
trace_entry_ptr                 001454 automatic       pointer                  dcl 5-3 set ref 504 506 797* 798 800 811* 812 818
                                                                                  842 847 862 865 865
trace_flags                     003562 automatic       bit(2)                   dcl 702 set ref 708* 709* 710* 739*
trace_force               2(15)        based           bit(1)                   level 3 packed unaligned dcl 4-20 set ref 333 735*
trace_idx                       001426 automatic       fixed bin(17,0)          dcl 52 set ref 455* 457* 808 808 811 816 819* 819
trace_mode_bits                 001366 automatic       bit(18)                  unaligned dcl 49 set ref 228* 242* 313* 625 651*
trace_mode_string               001367 automatic       varying char(120)        dcl 50 set ref 233* 247* 595* 669 669* 669 672* 672
                                                                                  674* 674
trace_modes                     003522 automatic       structure                level 1 packed unaligned dcl 582 set ref 625* 651
tty_buf                                based           structure                level 1 dcl 2-35
ttybp                           001442 automatic       pointer                  dcl 2-19 set ref 228 427* 435* 447 447 450 453 453
                                                                                  506 508 731
unspec                                                 builtin function         dcl 90 ref 335 719 862
write                     0(03) 003522 automatic       bit(1)                   level 2 packed unaligned dcl 582 set ref 634*
yes_sw                          001530 automatic       bit(1)                   dcl 494 set ref 513* 517

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 2-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 2-32
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 2-33
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 2-19
bsizec                                 internal static fixed bin(17,0)          initial dcl 2-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 2-29
input_bpart                            internal static fixed bin(18,0)          initial dcl 2-19
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
lock_ptr                               automatic       pointer                  dcl 3-9
mode_string_info_version_2             internal static fixed bin(17,0)          initial dcl 1-30
mode_value_version_3                   internal static fixed bin(17,0)          initial dcl 1-30
number_of_modes                        automatic       fixed bin(17,0)          dcl 1-6
output_bpart                           internal static fixed bin(18,0)          initial dcl 2-19
qblock_size                            internal static fixed bin(17,0)          initial dcl 2-27
saved_meters                           based           structure                level 1 dcl 4-68
trace_array_size                       automatic       fixed bin(18,0)          unsigned dcl 5-4
tty_buf$                               external static fixed bin(17,0)          dcl 2-19
tty_ev                                 internal static fixed bin(17,0)          initial dcl 2-19

NAMES DECLARED BY EXPLICIT CONTEXT.
BADOPT_ERROR                    001567 constant        label                    dcl 141 ref 171 215 267 390
BAD_MODE_VALUE                  005611 constant        label                    dcl 645 ref 607 613
CHECK_FOR_STRINGS               006773 constant        label                    dcl 840 ref 835
FINISHED_SETTING_MODE           005647 constant        label                    dcl 651 ref 685
MAIN_RETURN                     001622 constant        label                    dcl 156 ref 118 124 137 143 152 176 183 201 220 251
                                                                                  279 285 295 304 316 322 345 363 371 412 424 438
                                                                                  444 474 479 517 524 548 557 648 883 901 927 934
                                                                                  941
NEXT_CHANNEL                    006433 constant        label                    dcl 750 ref 719 720 727
NEXT_TRACE_ENTRY                006700 constant        label                    dcl 816
PROCESS_CHANNEL                 002457 constant        label                    dcl 255 ref 131
PROCESS_MODES                   002134 constant        label                    dcl 205 ref 132
PROCESS_MODES_COMMON            005455 constant        label                    dcl 625 ref 597
PROCESS_PRINT                   003300 constant        label                    dcl 349 ref 133
PROCESS_RESET                   003001 constant        label                    dcl 299 ref 134
PROCESS_TABLE_SIZE              001627 constant        label                    dcl 163 set ref 130
THIS_CHANNEL                    006171 constant        label                    dcl 729 ref 724
add_to_array                    007411 constant        entry                    internal dcl 912 ref 269 377 382 387 392
check_if_update_allowed         004572 constant        entry                    internal dcl 465 ref 238 288 307 500
cleanup_procedure               007662 constant        entry                    internal dcl 952 ref 112 156
entry_matches                   006714 constant        entry                    internal dcl 827 ref 800 814
get_erf_argument                007236 constant        entry                    internal dcl 876 ref 169 211 261 355
get_next_argument               007312 constant        entry                    internal dcl 893 ref 366 376 381 386 879
get_trace_modes                 005350 constant        entry                    internal dcl 590 ref 231 246
get_tty_segs                    004253 constant        entry                    internal dcl 416 ref 189 227 291 309 400 502
inconsistent                    004216 constant        entry                    internal dcl 146 ref 273 274 397
mcm_trace                       001250 constant        entry                    external dcl 6
print_single_entry              007106 constant        entry                    internal dcl 858 ref 800 814
print_trace_entries             006474 constant        entry                    internal dcl 763 ref 410
process_mode                    005657 constant        entry                    internal dcl 662 ref 628 629 633 634 635 636 637 638
                                                                                  639 640 641 642
process_modes                   005346 constant        entry                    internal dcl 576
set_channel_tracing             006015 constant        entry                    internal dcl 696 ref 293
set_single_mode                 005357 constant        entry                    internal dcl 600 ref 560
set_table_size                  004717 constant        entry                    internal dcl 491 ref 199
set_trace_modes                 005137 constant        entry                    internal dcl 537 ref 240 311
trace_mcs                       001257 constant        entry                    external dcl 6

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10502       10576   10125       10512
Length     11172   10125        74         357     355           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mcm_trace                          2682 external procedure  is an external procedure.  
on unit on line 112                  64 on unit               
inconsistent                            internal procedure  shares stack frame of external procedure mcm_trace.  
begin block on line 325                 begin block         shares stack frame of external procedure mcm_trace.  
get_tty_segs                            internal procedure  shares stack frame of external procedure mcm_trace.  
check_if_update_allowed             112 internal procedure  enables or reverts conditions.  
on unit on line 477                  98 on unit               
set_table_size                          internal procedure  shares stack frame of external procedure mcm_trace.  
set_trace_modes                         internal procedure  shares stack frame of external procedure mcm_trace.  
process_modes                           internal procedure  shares stack frame of external procedure mcm_trace.  
process_mode                            internal procedure  shares stack frame of external procedure mcm_trace.  
set_channel_tracing                     internal procedure  shares stack frame of external procedure mcm_trace.  
print_trace_entries                     internal procedure  shares stack frame of external procedure mcm_trace.  
entry_matches                           internal procedure  shares stack frame of external procedure mcm_trace.  
print_single_entry                      internal procedure  shares stack frame of external procedure mcm_trace.  
get_erf_argument                        internal procedure  shares stack frame of external procedure mcm_trace.  
get_next_argument                       internal procedure  shares stack frame of external procedure mcm_trace.  
add_to_array                            internal procedure  shares stack frame of external procedure mcm_trace.  
cleanup_procedure                    80 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 last_trace_time             mcm_trace
000012 last_trace_idx              mcm_trace

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
check_if_update_allowed  000100 temp_entry                  check_if_update_allowed
mcm_trace                000100 arg_count                   mcm_trace
                         000101 arg_index                   mcm_trace
                         000102 arg_lth                     mcm_trace
                         000104 arg_ptr                     mcm_trace
                         000106 code                        mcm_trace
                         000107 operation                   mcm_trace
                         000120 brief_sw                    mcm_trace
                         000121 reset_sw                    mcm_trace
                         000122 all_sw                      mcm_trace
                         000123 reverse_sw                  mcm_trace
                         000124 on_sw                       mcm_trace
                         000125 off_sw                      mcm_trace
                         000126 force_sw                    mcm_trace
                         000127 print_sw                    mcm_trace
                         000130 last_count                  mcm_trace
                         000131 table_size                  mcm_trace
                         000132 new_modes                   mcm_trace
                         000170 erf_name                    mcm_trace
                         000200 n_excludes                  mcm_trace
                         000201 exclude                     mcm_trace
                         000535 n_matches                   mcm_trace
                         000536 match                       mcm_trace
                         001072 n_channels                  mcm_trace
                         001073 channel                     mcm_trace
                         001360 temp_segs                   mcm_trace
                         001364 areap                       mcm_trace
                         001366 trace_mode_bits             mcm_trace
                         001367 trace_mode_string           mcm_trace
                         001426 trace_idx                   mcm_trace
                         001436 mode_value_ptr              mcm_trace
                         001440 mode_string_info_ptr        mcm_trace
                         001442 ttybp                       mcm_trace
                         001444 lctp                        mcm_trace
                         001446 lctep                       mcm_trace
                         001450 lcntp                       mcm_trace
                         001452 trace_array_ptr             mcm_trace
                         001454 trace_entry_ptr             mcm_trace
                         001472 chan_idx                    begin block on line 325
                         001473 chan_name                   begin block on line 325
                         001512 erf_number                  get_tty_segs
                         001530 yes_sw                      set_table_size
                         001531 new_size                    set_table_size
                         001532 new_free                    set_table_size
                         001533 percent_used                set_table_size
                         001542 modes_area                  set_trace_modes
                         003512 idx                         set_trace_modes
                         003522 trace_modes                 process_modes
                         003523 function                    process_modes
                         003530 all_mode_sw                 process_modes
                         003531 all_mode_value              process_modes
                         003532 set_all_modes               process_modes
                         003550 chan_idx                    set_channel_tracing
                         003551 name_idx                    set_channel_tracing
                         003552 channel_name                set_channel_tracing
                         003562 trace_flags                 set_channel_tracing
                         003563 matching_channels           set_channel_tracing
                         003564 old_state                   set_channel_tracing
                         003571 new_state                   set_channel_tracing
                         003606 channel_name                print_trace_entries
                         003616 first_idx                   print_trace_entries
                         003617 last_idx                    print_trace_entries
                         003620 increment                   print_trace_entries
                         003621 entry_idx                   print_trace_entries
                         003622 real_entry_idx              print_trace_entries
                         003634 name_idx                    entry_matches

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_ne_as             alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              tra_ext             mod_fx1             enable
shorten_stack       ext_entry           int_entry           set_cs_eis          index_cs_eis        empty

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      command_query_$yes_no         copy_erf_seg_$name
cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_                 date_time_$format
get_temp_segments_            hphcs_$set_mcm_channel_trace  hphcs_$set_mcm_global_trace
hphcs_$set_mcm_trace_table_size                             ioa_                          ioa_$rsnnl
match_star_name_              mode_string_$parse            release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$bad_mode         error_table_$badopt           error_table_$bigarg
error_table_$inconsistent     error_table_$noarg            error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 001247        94 001264        95 001277        96 001300        97 001301        98 001302        99 001303
    100 001304       101 001305       102 001306       104 001307       105 001312       106 001314       107 001317
    108 001320       109 001321       110 001322       112 001323       115 001345       116 001356       117 001360
    118 001375       121 001376       122 001401       124 001430       127 001431       128 001433       130 001451
    131 001463       132 001477       133 001503       134 001517       136 001527       137 001566       141 001567
    143 001621       156 001622       159 001626       163 001627       166 001634       167 001643       169 001661
    171 001671       174 001703       175 001705       176 001743       179 001744       180 001771       181 001775
    183 002030       186 002031       188 002033       189 002035       191 002036       195 002074       197 002131
    199 002132       201 002133       205 002134       208 002141       209 002151       211 002167       212 002177
    213 002212       215 002225       218 002237       219 002243       220 002276       223 002277       225 002302
    227 002304       228 002305       230 002311       231 002315       233 002316       235 002353       238 002354
    240 002360       242 002363       243 002400       245 002433       246 002435       247 002436       251 002456
    255 002457       258 002464       259 002473       261 002511       262 002521       263 002534       264 002547
    265 002556       267 002565       269 002577       271 002641       273 002643       274 002657       276 002675
    277 002704       279 002734       282 002735       283 002737       285 002767       288 002770       291 002776
    293 002777       295 003000       299 003001       302 003006       303 003011       304 003035       307 003036
    309 003042       311 003043       313 003051       314 003066       315 003070       316 003114       319 003115
    320 003127       321 003131       322 003155       330 003156       331 003165       333 003171       334 003174
    335 003203       337 003212       338 003227       342 003275       345 003277       349 003300       352 003305
    353 003315       355 003333       356 003343       357 003356       358 003371       360 003410       361 003420
    362 003422       363 003455       366 003456       367 003467       368 003514       369 003520       371 003553
    373 003554       375 003555       376 003571       377 003601       378 003643       380 003644       381 003654
    382 003663       383 003725       385 003726       386 003736       387 003747       388 004012       390 004013
    392 004025       395 004067       397 004071       400 004105       402 004106       406 004147       410 004214
    412 004215       146 004216       151 004227       152 004252       416 004253       421 004254       422 004275
    423 004277       424 004323       427 004324       428 004326       430 004330       432 004340       433 004343
    435 004347       436 004403       437 004405       438 004434       441 004435       442 004471       443 004473
    444 004517       447 004520       448 004525       450 004531       453 004540       454 004543       455 004550
    457 004562       460 004570       465 004571       471 004577       472 004604       474 004634       477 004637
    478 004653       479 004705       482 004710       484 004715       486 004716       491 004717       500 004720
    502 004724       504 004725       506 004730       508 004742       510 004745       512 004754       513 004756
    517 005023       520 005026       521 005032       522 005044       523 005046       524 005072       528 005073
    529 005104       532 005136       537 005137       541 005150       545 005153       546 005203       547 005205
    548 005242       551 005243       552 005253       553 005257       554 005262       557 005324       560 005325
    561 005343       563 005345       576 005346       590 005347       593 005351       595 005355       597 005356
    600 005357       603 005370       604 005374       606 005375       607 005404       608 005411       609 005413
    610 005414       612 005415       613 005421       614 005426       615 005430       616 005431       618 005432
    620 005433       621 005440       622 005443       625 005455       628 005457       629 005465       631 005474
    633 005476       634 005504       635 005513       636 005521       637 005530       638 005537       639 005546
    640 005555       641 005564       642 005573       644 005602       645 005611       648 005646       651 005647
    655 005656       662 005657       668 005661       669 005666       672 005677       674 005720       675 005756
    677 005760       678 005765       679 005767       680 005773       683 005774       684 006006       685 006013
    688 006014       696 006015       708 006016       709 006017       710 006023       711 006030       713 006064
    715 006065       716 006075       717 006101       719 006110       720 006114       722 006120       723 006127
    724 006163       725 006166       727 006170       729 006171       731 006172       735 006222       738 006263
    739 006270       740 006303       742 006340       744 006375       746 006376       750 006433       753 006435
    756 006460       758 006473       763 006474       774 006475       776 006501       777 006503       778 006505
    780 006531       783 006533       784 006535       785 006537       786 006546       787 006551       789 006552
    790 006554       791 006563       794 006566       796 006606       797 006614       798 006620       800 006630
    803 006640       805 006643       808 006644       811 006660       812 006662       814 006672       816 006700
    818 006703       819 006705       820 006712       822 006713       827 006714       833 006716       834 006725
    835 006761       836 006764       838 006766       840 006773       842 007003       844 007032       846 007034
    847 007043       849 007073       851 007075       853 007102       858 007106       862 007107       865 007150
    869 007235       876 007236       879 007237       881 007244       882 007250       883 007303       886 007304
    888 007311       893 007312       899 007323       900 007326       901 007370       904 007371       905 007372
    907 007410       912 007411       922 007434       923 007440       924 007456       925 007464       927 007525
    931 007526       932 007534       934 007570       937 007571       938 007574       941 007634       944 007635
    945 007636       947 007660       952 007661       955 007667       958 007715


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
