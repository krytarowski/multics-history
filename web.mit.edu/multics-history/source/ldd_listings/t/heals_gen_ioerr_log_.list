	COMPILATION LISTING OF SEGMENT heals_gen_ioerr_log_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/27/84  0744.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 heals_gen_ioerr_log_: proc (heals_arg_info_p, heals_ior_args_p, r_code);
        7 
        8 /* ******************************************************************************
        9*   *								*
       10*   *  Comments:							*
       11*   *								*
       12*   *	Written by RH Morrison  Nov. 19, 1976	 			*
       13*   *	Last modified by A. Downing 01/14/77
       14*   *								*
       15*   ****************************************************************************** */
       16 /* FF */
       17 /* ********	DECLARATIONS	******** */
       18 
       19 /* ****	PROCEDURE ARGUMENTS   **** */
       20 dcl  heals_arg_info_p ptr;
       21 dcl  heals_ior_args_p ptr;
       22 dcl  r_code fixed bin (35);
       23 
       24 /* ****	EXTERNAL STATIC	**** */
       25 dcl  error_table_$end_of_info ext static fixed bin (35);
       26 
       27 /* ****	ENTRIES		**** */
       28 dcl  ioa_ entry options (variable);
       29 dcl  com_err_ entry options (variable);
       30 dcl  clock_ entry returns (fixed bin (71));
       31 dcl  date_time_ entry (fixed bin (71), char (*));
       32 dcl  cv_oct_ entry (char (*)) returns (fixed bin (35));
       33 dcl  ioa_$rsnnl entry options (variable);
       34 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
       35 dcl  iox_$close entry (ptr, fixed bin (35));
       36 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
       37 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       38 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       39 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
       40 dcl  vfile_$vfile_attach entry (ptr, (*) char (*) varying, bit (1) aligned, fixed bin (35));
       41 
       42 /* ****	POINTERS		**** */
       43 dcl  flags_p ptr init (null);
       44 dcl  work_p1 ptr init (null);
       45 dcl  outsw_p ptr init (null);
       46 dcl  sortsw_p ptr init (null);
       47 dcl  inbuf_p ptr init (null);
       48 dcl  sort_desc_p (3) ptr init (null, null, null);
       49 dcl  tape_nfo_p ptr init (null);
       50 dcl  sort_data_p ptr init (null);
       51 dcl  syserr_nfo_p ptr init (null);
       52 dcl  dev_data_p ptr init (null);
       53 						/*   Arguments  */
       54 dcl  insw_p ptr init (null);
       55 
       56 
       57 /* pointers declared in include files:
       58**/
       59 
       60 /* ****	CHARACTER STRING VARIABLES    **** */
       61 dcl  rprt_from_time char (16);
       62 dcl  rprt_to_time char (16);
       63 dcl  work_time char (16);
       64 dcl  ascii_status char (12);
       65 dcl  record_name char (13);
       66 dcl  work_ch1 char (1);
       67 dcl  inbuf char (inbuf_len) aligned;
       68 dcl  ioi_buf char (outbuf_len) aligned;
       69 dcl  bad_rec_buf char (outbuf_len) aligned;
       70 dcl  disk_buf char (outbuf_len) aligned;
       71 dcl  misc_buf char (outbuf_len) aligned;
       72 dcl  pic_w pic "99";
       73 dcl  bad_name char (7);
       74 dcl  dev_nm_chk char (4);
       75 dcl  dev_data_space char (1540);
       76 dcl  n_a char (3) init ("N/A");
       77 dcl  date_time char (16);
       78 dcl  date char (8);
       79 dcl  time char (6);
       80 
       81 /*   Arguments  */
       82 dcl  whoami char (20) init ("heals_gen_ioerr_log_");
       83 dcl  version_date char (8) init ("12/15/76");
       84 dcl  vfile_info (1) char (168) varying;
       85 
       86 /* ****	ARITHMETIC VARIABLES    **** */
       87 dcl  dev_data_stopper fixed bin based (dev_data_p);
       88 dcl  inbuf_len fixed bin (21) int static init (1024);
       89 dcl  outbuf_len fixed bin (21) int static init (1024);
       90 dcl  stream_in fixed bin init (1);
       91 dcl  stream_out fixed bin init (2);
       92 dcl  seq_in fixed bin init (4);
       93 dcl  seq_out fixed bin init (5);
       94 dcl  status_nb fixed bin (35);
       95 dcl  i_code fixed bin (35);
       96 dcl  nb_ioerr_recs fixed bin;
       97 dcl  ioerr_rec_min_len fixed bin (21);
       98 dcl  dev_data_size fixed bin;
       99 dcl (i, j, k, l) fixed bin;
      100 dcl  ndx fixed bin (24);
      101 dcl  offs_ndx fixed bin;
      102 dcl  ss fixed bin;
      103 dcl  page_nb fixed bin;
      104 dcl  iom_nb_chk fixed bin (3);
      105 dcl  ch_nb_chk fixed bin (6);
      106 dcl  dev_nb_chk fixed bin (6);
      107 dcl  fake_data_size fixed bin;
      108 dcl  save_size fixed bin;
      109 
      110 /*   Arguments  */
      111 dcl  code fixed bin (35);
      112 dcl  inrec_len fixed bin (21);
      113 dcl  outrec_len fixed bin (21);
      114 
      115 dcl  version_nb fixed bin init (1);
      116 dcl  clock_time fixed bin (71);
      117 
      118 /* ****	BIT STRING VARIABLES    **** */
      119 /*   Working  */
      120 dcl  unused bit (1) aligned init ("0"b);
      121 dcl  flags_word bit (36) aligned init ("0"b);
      122 dcl  found bit (1) aligned;
      123 dcl  rec_hdr bit (180) based;
      124 
      125 /* ****	ARRAY VARIABLES		**** */
      126 dcl  ntrpt_nm_list (0:7) char (1) aligned init (
      127      "", "o", "x", "t", "x", "m", "x", "s");
      128 
      129 dcl 1 tape_nfo_ar (1:max_iom_nb_a) aligned,
      130     2 tape_entry (0:max_tape_nb_a) like tape_nfo;
      131 
      132 dcl  fake_data (2) bit (36) aligned init (
      133     (36)"0"b,
      134     (36)"0"b);
      135 
      136 
      137 /* ***	BASED VARIABLES   *** */
      138 dcl 1 flags aligned based (flags_p),
      139     (2 trace bit (1),
      140     2 db bit (1),
      141     2 io_error bit (1),
      142     2 sorted_io_error bit (1),
      143     2 hdrs bit (1),
      144     2 msg bit (1),
      145     2 disk_hold bit (1),
      146     2 disk_addr bit (1)
      147      ) unal;
      148 
      149 dcl 1 tape_nfo aligned based (tape_nfo_p),
      150     (2 rsn char (7),
      151     2 dens char (4),
      152     2 tracks char (2),
      153     2 ring char (2))unal;
      154 
      155 dcl 1 dev_data aligned based (dev_data_p),
      156     2 dev_name char (4) aligned,
      157     2 used bit (1) aligned,
      158     2 ch_nmbr fixed bin (6) aligned,
      159     (2 fill1 bit (11),
      160     2 dev_nmbr fixed bin (6),
      161     2 fill2 bit (14),
      162     2 iom_nmbr fixed bin (3)) unal,
      163     2 saved_data (2) bit (36) aligned;
      164 
      165 dcl 1 ch_nfo_ar (1:max_iom_nb_a) aligned based (ch_nfo_ar_p),
      166     2 ch_entry (0:max_ch_nb_a) like ch_nfo;
      167 
      168 /*   Arguments  */
      169 dcl 1 arg_info like heals_arg_info aligned based (heals_arg_info_p);
      170 
      171 /* ****	MISC. DECLARATIONS		**** */
      172 dcl (addr, addrel, index, null, search, size, substr, unspec, verify) builtin;
      173 dcl  cleanup condition;
      174 dcl  conversion condition;
      175 
      176 /* FF */
      177 /* ****	INCLUDE FILES	**** */
  1     1 /* heals_arg_info.incl.pl1 contains the declaration
  1     2*   of the argument structure passed between heals releated utilities.
  1     3*   Created January 1976 by A. R. Downing */
  1     4 dcl 1 heals_arg_info aligned,
  1     5     2 iocbp ptr,
  1     6     2 report_iocbp ptr,
  1     7     2 err_nb fixed bin (35),
  1     8     2 info_selection bit (72) unal,
  1     9     2 report_name char (64) varying,
  1    10     2 heals_log_path_name char (168),			/* path name of the heals log */
  1    11     2 system_id char (32) varying,
  1    12     2 installation_id char (32) varying,
  1    13     2 from_seq fixed bin (35),			/* beginning seq_num */
  1    14     2 to_seq fixed bin (35),				/* ending seq_num */
  1    15     2 from_time fixed bin (71),			/* beginning of desired time period */
  1    16     2 to_time fixed bin (71);				/* end of desired time period */
  1    17 						/* end heals_arg_info. */
      178 
  2     1 /*  BEGIN INCLUDE FILE  heals_io_report_args.incl.pl1  */
  2     2 /*  Created by RH Morrison Dec. 9,1976  */
  2     3 /*  Last modified by RH Morrison 12/13/76  */
  2     4 
  2     5 dcl 1 ior_ptrs aligned based (heals_ior_args_p),
  2     6     2 ior_flags_p ptr,
  2     7     2 ior_prms_p ptr,
  2     8     2 ch_nfo_ar_p ptr,
  2     9     2 ioerr_log_sw_p ptr,
  2    10     2 ior_avars_p ptr;
  2    11 
  2    12 dcl 1 ior_flags aligned based (ior_ptrs.ior_flags_p),
  2    13     (2 trace bit (1),
  2    14     2 db bit (1),
  2    15     2 no_recs bit (1)
  2    16      ) unal;
  2    17 
  2    18 dcl 1 ior_prms aligned based (ior_ptrs.ior_prms_p),
  2    19     (2 max_iom_nb_a fixed bin,
  2    20     2 max_ch_nb_a fixed bin,
  2    21     2 max_tape_nb_a fixed bin,
  2    22     2 max_line_cnt_a fixed bin) unal;
  2    23 
  2    24 dcl  ch_nfo_p ptr;
  2    25 dcl 1 ch_nfo aligned based (ch_nfo_p),
  2    26     (2 dev_nam char (4),
  2    27     2 model fixed bin,
  2    28     2 lchan fixed bin (6),
  2    29     2 uchan fixed bin (6),
  2    30     2 i_set bit (1)
  2    31      ) unal;
  2    32 
  2    33 dcl 1 ior_avars aligned based (ior_ptrs.ior_avars_p),
  2    34     2 bulk_port fixed bin;
  2    35 
  2    36 /*  END INCLUDE FILE  heals_io_report_args.incl.pl1  */
      179 
  3     1 /*  BEGIN INCLUDE FILE  heals_ioerr_rec.incl.pl1  */
  3     2 /*  Created Dec. 1, 1976 by RH Morrison  */
  3     3 /*  Last modified by RH Morrison  01/03/77  */
  3     4 /*  This include file defines the I/O error record derived from syserr_log records.  */
  3     5 
  3     6 dcl  ioerr_rec_p ptr;
  3     7 dcl 1 ioerr_rec aligned based (ioerr_rec_p),
  3     8     2 sort_rec aligned,
  3     9     (3 sort_date char (8),
  3    10       3 iom_nb fixed bin (3),
  3    11       3 ch_nb fixed bin (6),
  3    12       3 dev_nb fixed bin (6),
  3    13       3 power_off bit (1),
  3    14       3 maj_st bit (6),
  3    15       3 sub_st bit (6),
  3    16       3 ntrpt_no bit (1),
  3    17       3 dev_cmnd bit (6),
  3    18       3 iom_st bit (6),
  3    19       3 rec_cnt_res bit (6)) unal,
  3    20     2 report_nfo aligned,
  3    21     (3 dev_nm pic "xxxx",
  3    22       3 log_time char (6),
  3    23       3 ntrpt_nm char (1),
  3    24       3 rprt_flags,
  3    25         4 ioerr bit (1),
  3    26         4 diskerr bit (1),
  3    27         4 disk_addr bit (1),
  3    28         4 ext_stat bit (1),
  3    29         4 iom_rec bit (1),
  3    30         4 bad_rec bit (1),
  3    31         4 msg bit (1),
  3    32         4 bulk bit (1),
  3    33         4 fill bit (1),
  3    34       3 dev_model fixed bin) unal,
  3    35     2 tape_disk_nfo aligned,
  3    36     (3 tapno_diskad pic "xxxxxxx",
  3    37       3 dens_cyl pic "xxxx",
  3    38       3 ring_head pic "xx",
  3    39       3 tracks_sector pic "xx") unal,
  3    40     2 syserr_nfo aligned,
  3    41     (3 tally_nb fixed bin (35),
  3    42       3 seq_nb fixed bin (35),
  3    43       3 time fixed bin (71),
  3    44       3 code fixed bin (11),
  3    45       3 msg_len fixed bin (11),
  3    46       3 data_size fixed bin (11),
  3    47       3 data (0 refer (ioerr_rec.data_size)) bit (36)) unal,
  3    48     2 msg char (0 refer (ioerr_rec.msg_len)) aligned;
  3    49 						/*  END INCLUDE FILE  heals_ioerr_rec.incl.pl1  */
      180 
  4     1 /* begin heals_message.incl.pl1 */
  4     2 /* Produced March 1976 by A. Downing. */
  4     3 dcl 1 heals_message based (heals_message_p) aligned,
  4     4     2 tally fixed bin (35),
  4     5     2 rest_of_record aligned,
  4     6       3 seq_num fixed bin (35),			/* Sequence number of this message. */
  4     7       3 time fixed bin (71) unal,			/* Time message logged at */
  4     8       3 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  4     9       3 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  4    10       3 data_size fixed bin (11) unal,			/* Size of binary data */
  4    11       3 data_code fixed bin (11) unal,			/* format type code */
  4    12       3 pad bit (60) unal,
  4    13       3 text char (0 refer (heals_message.text_len)),	/* Text of expanded message - kept in ASCII. */
  4    14       3 data (0 refer (heals_message.data_size)) bit (36);	/* Binary data area */
  4    15 dcl  heals_message_p ptr;
  4    16 						/* end heals_message.incl.pl1 */
      181 
  5     1 /* Begin include file ..... io_syserr_msg.incl.pl1 */
  5     2 
  5     3 /* Created October 1975 by Larry Johnson */
  5     4 /* Modified 11/11/76 by Noel I. Morris */
  5     5 /* Modified November 1979 by Larry Johnson for detailed status */
  5     6 /* Modified February 1981 by Chris Jones to use channel names */
  5     7 
  5     8 /* This include file defines the format of the syserr message generated for I/O errors. */
  5     9 /* This message is also defined (size and type) by the "io_msg" and "io_msg_detail"
  5    10*   constants in syserr_binary_def.incl.pl1 */
  5    11 
  5    12 dcl  io_msgp ptr;					/* Pointer to syserr message structure */
  5    13 
  5    14 dcl  1 io_msg aligned based (io_msgp),
  5    15        (
  5    16        2 level bit (3),				/* Level of interrupt being logged */
  5    17        2 fill1 bit (9),
  5    18        2 device bit (6),				/* Device which caused error */
  5    19        2 time_out bit (1),				/* Set if error caused by channel timeout */
  5    20        2 type bit (2),				/* Type of last DCW */
  5    21        2 command bit (6),				/* Command being executed by device */
  5    22        2 fill2 bit (3),
  5    23        2 count bit (6)
  5    24        ) unal,					/* Count of message repetitions */
  5    25        2 channel char (8),				/* Channel over which interrupt came */
  5    26        2 status bit (36),				/* First word of IOM status */
  5    27        2 devname char (4),				/* Device name */
  5    28        2 detailed_status bit (216);			/* Optional detailed device status */
  5    29 
  5    30 /* End include file ..... io_syserr_msg.incl.pl1 */
      182 
  6     1 
  6     2 /* Begin include file ...... iom_stat.incl.pl1 */
  6     3 /* Last modified on 10/31/74 by Noel I. Morris */
  6     4 
  6     5 dcl  statp ptr;					/* pointer to status */
  6     6 
  6     7 dcl 1 status based (statp) aligned,			/* IOM status information */
  6     8      (2 t bit (1),					/* set to "1"b by IOM */
  6     9       2 power bit (1),				/* non-zero if peripheral absent or power off */
  6    10       2 major bit (4),				/* major status */
  6    11       2 sub bit (6),				/* substatus */
  6    12       2 eo bit (1),					/* even/odd bit */
  6    13       2 marker bit (1),				/* non-zero if marker status */
  6    14       2 soft bit (2),				/* software status */
  6    15       2 initiate bit (1),				/* initiate bit */
  6    16       2 abort bit (1),				/* software abort bit */
  6    17       2 channel_stat bit (3),				/* IOM channel status */
  6    18       2 central_stat bit (3),				/* IOM central status */
  6    19       2 mbz bit (6),
  6    20       2 rcount bit (6),				/* record count residue */
  6    21       2 address bit (18),				/* DCW address residue */
  6    22       2 char_pos bit (3),				/* character position residue */
  6    23       2 r bit (1),					/* non-zero if reading */
  6    24       2 type bit (2),				/* type of last DCW */
  6    25       2 tally bit (12)) unal;				/* DCW tally residue */
  6    26 
  6    27 dcl 1 faultword based (statp) aligned,			/* system fault word */
  6    28      (2 mbz1 bit (9),
  6    29       2 channel bit (9),				/* channel number */
  6    30       2 serv_req bit (5),				/* service request */
  6    31       2 mbz2 bit (3),
  6    32       2 controller_fault bit (4),			/* system controller fault code */
  6    33       2 io_fault bit (6)) unal;			/* I/O fault code */
  6    34 
  6    35 dcl 1 special_status based (statp) aligned,		/* special status from PSIA */
  6    36    (2 t bit (1),					/* entry present bit */
  6    37     2 channel bit (8),				/* channel number */
  6    38     2 pad1 bit (3),
  6    39     2 device bit (6),				/* device address */
  6    40     2 pad2 bit (1),
  6    41     2 byte2 bit (8),				/* device dependent information */
  6    42     2 pad3 bit (1),
  6    43     2 byte3 bit (8)) unal;				/* device dependent information */
  6    44 
  6    45 /* End of include file iom_stat.incl.pl1 */
  6    46 
      183 
  7     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  7     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  7     3*      version number to IOX2. */
  7     4 /* format: style2 */
  7     5 
  7     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  7     7 	     2 version	      character (4) aligned,	/* IOX2 */
  7     8 	     2 name	      char (32),		/* I/O name of this block. */
  7     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  7    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  7    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  7    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  7    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  7    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  7    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  7    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  7    17 						/* open(p,mode,not_used,s) */
  7    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  7    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  7    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  7    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    24 						/* put_chars(p,bufptr,buflen,s) */
  7    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  7    26 						/* modes(p,newmode,oldmode,s) */
  7    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  7    28 						/* position(p,u1,u2,s) */
  7    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  7    30 						/* control(p,order,infptr,s) */
  7    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  7    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    34 						/* write_record(p,bufptr,buflen,s) */
  7    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  7    36 						/* rewrite_record(p,bufptr,buflen,s) */
  7    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  7    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    39 						/* seek_key(p,key,len,s) */
  7    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    41 						/* read_key(p,key,len,s) */
  7    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  7    43 						/* read_length(p,len,s) */
  7    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  7    45 						/* open_file(p,mode,desc,not_used,s) */
  7    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  7    47 						/* close_file(p,desc,s) */
  7    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  7    49 						/* detach(p,desc,s) */
  7    50 
  7    51      declare iox_$iocb_version_sentinel
  7    52 			      character (4) aligned external static;
  7    53 
  7    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      184 
      185 /* *******	END OF DECLARATIONS	******* */
      186 /* FF */
      187 /* ********	PROCEDURE		******** */
      188 
      189 /* ****	Procedure Initialization	**** */
      190 
      191 	on cleanup call clean_up;
      192 
      193 /*  Init returns.  */
      194 	r_code = 0;
      195 
      196 /*  Init pointers.  */
      197 	flags_p = addr (flags_word);
      198 	insw_p = arg_info.iocbp;
      199 	inbuf_p = addr (inbuf);
      200 	outsw_p = ioerr_log_sw_p;
      201 	heals_message_p = addr (inbuf);
      202 
      203 /*  Init procedure constants.  */
      204 	ioerr_rec_min_len = size (ioerr_rec) * 4;	/* ioerr_rec is output record */
      205 	dev_data_size = size (dev_data);		/* size of entry for saving binary data */
      206 	fake_data_size = size (fake_data);		/* fake data is used when no real data exists */
      207 
      208 /*  Init all else.  */
      209 	code = 0;
      210 	arg_info.err_nb = 0;
      211 	call date_time_ (arg_info.from_time, rprt_from_time); /* args to heals_report */
      212 	call date_time_ (arg_info.to_time, rprt_to_time);
      213 	nb_ioerr_recs = 0;				/* init output record count */
      214 
      215 	ioerr_rec_p = addr (bad_rec_buf);		/* init ioerr_rec buffers */
      216 	ioerr_rec.data_size = 0;
      217 	rprt_flags = "0"b;
      218 	ioerr_rec_p = addr (disk_buf);
      219 	ioerr_rec.data_size = 0;
      220 	rprt_flags = "0"b;
      221 	ioerr_rec_p = addr (ioi_buf);
      222 	ioerr_rec.data_size = 0;
      223 	rprt_flags = "0"b;
      224 	ioerr_rec_p = addr (misc_buf);
      225 	ioerr_rec.data_size = 0;
      226 	rprt_flags = "0"b;
      227 
      228 	dev_data_p = addr (dev_data_space);		/* init saved data array */
      229 	dev_data_stopper = -1;			/* set stopper in first entry */
      230 	dev_data.used = "0"b;			/* set first entry unused */
      231 	dev_data_p = addrel (dev_data_p, 64*dev_data_size); /* bump pointer to end of dev_data_space */
      232 	dev_data_stopper = -1;			/* set stopper at end of dev_data_space */
      233 
      234 	do i = 1 to max_iom_nb_a;			/* init tape_nfo_ar */
      235 	  do j = 0 to max_tape_nb_a;
      236 	    tape_nfo_p = addr (tape_nfo_ar.tape_entry (i, j));
      237 	    tape_nfo = ".";				/* init data */
      238 	  end;
      239 	end;
      240 
      241 
      242 /* ****	End Procedure Initialization    **** */
      243 
      244 /*  Run information.  */
      245 	clock_time = clock_ ();
      246 	call date_time_ (clock_time, date_time);
      247 	date = substr (date_time, 1, 8);
      248 	time = substr (date_time, 11, 6);
      249 	if flags.trace
      250 	| ior_flags.trace
      251 	then call ioa_ ("^a run info: date ^a, time ^a, version ^d of ^a.",
      252 	  whoami, date, time, version_nb, version_date);
      253 
      254 /* ****	Build ioerr_rec and write it to heals_ioerr_log.  **** */
      255 
      256 /*  Open heals_ioerr_log file (output).  */
      257 	call iox_$open (outsw_p, seq_out, unused, code);
      258 	if code ^= 0 then call proc_err (13);
      259 
      260 	on conversion begin;			/* report error on output report */
      261 	  ioerr_rec_p = addr (bad_rec_buf);		/* assign output buffer */
      262 	  msg_len = 72;
      263 	  call ioa_$rsnnl (
      264 	    "HEALS: conversion condition raised while processing this ^a record.",
      265 	    ioerr_rec.msg, i, record_name);
      266 	  msg_len = i;
      267 	  flags.msg = "1"b;
      268 	  rprt_flags.msg = "1"b;
      269 	  call write_ioerr_rec;
      270 	  go to next_log_rec;			/* keep going */
      271 	end;
      272 
      273 /*  Read first heals_log record.  */
      274 	call iox_$read_record (insw_p, inbuf_p, inbuf_len, inrec_len, code);
      275 	if code ^= 0
      276 	then if code = error_table_$end_of_info
      277 	  then goto ineof_1;
      278 	  else call proc_err (17);
      279 	goto rec_id;
      280 
      281 /* **	Record processing loop.	** */
      282 next_log_rec:
      283 	call iox_$read_record (insw_p, inbuf_p, inbuf_len, inrec_len, code);
      284 	if code ^= 0
      285 	then if code = error_table_$end_of_info		/* normal loop exit, case 1 */
      286 	  then goto ineof_1;
      287 	  else call proc_err (14);
      288 
      289 /*  Identify record type.  */
      290 rec_id:
      291 	record_name = "next";			/* reset record name */
      292 	if heals_message.time > arg_info.to_time then goto ineof_1; /* exit, case 2 */
      293 	if substr (heals_message.text, 1, 4) = "RCP:" then goto rcp_rec;
      294 	if substr (heals_message.text, 1, 8) = "ioi_mask" then goto ioi_rec;
      295 	if substr (heals_message.text, 1, 7) = "ocdcm_:" then goto ioi_rec;
      296 	if substr (heals_message.text, 1, 12) = "disk_control" then goto disk_rec;
      297 	if substr (heals_message.text, 1, 4) = "bulk" then goto bulk_rec;
      298 	if substr (heals_message.text, 1, 6) = "dn355:" then goto dn355_rec;
      299 	goto next_log_rec;				/* no record of interest */
      300 
      301 /* ****	Process "RCP": records.   * *** */
      302 rcp_rec:
      303 	record_name = "RCP:";
      304 	iom_nb_chk = 1;				/* arbitrary since not included in RCP: records */
      305 	if index (heals_message.text, " tap") > 0 then
      306 	  go to tape_recs;
      307 	goto next_log_rec;				/* all other RCP: records */
      308 
      309 tape_recs:
      310 	offs_ndx = index (heals_message.text, " tap") + 6;	/* get  tape number from text */
      311 	dev_nb_chk = bin (substr (heals_message.text, offs_ndx, 2), 6, 0);
      312 	if dev_nb_chk < 0 | dev_nb_chk > max_tape_nb_a	/* within tape_nfo_ar bounds */
      313 	then do; bad_name = "device";			/* nope */
      314 	  goto bad_rcp_rec;
      315 	end;
      316 	tape_nfo_p = addr (tape_nfo_ar.tape_entry (iom_nb_chk, dev_nb_chk)); /* set entry pointer */
      317 
      318 	if index (heals_message.text, "Attached tap") ^= 0 then goto attach_rec;
      319 	if index (heals_message.text, "Note (tap") ^= 0 then goto note_rec;
      320 	if index (heals_message.text, "Mount Reel") ^= 0 then goto mount_rec;
      321 	if index (heals_message.text, "Remount Reel") ^= 0 then goto mount_rec;
      322 	goto next_log_rec;				/* all other tape records */
      323 
      324 attach_rec:
      325 	tape_nfo = "?";				/* overwrite old values */
      326 	goto next_log_rec;
      327 
      328 note_rec:
      329 	ndx = index (heals_message.text, "den=");	/* determine density */
      330 	if ndx ^= 0
      331 	then do; work_ch1 = substr (heals_message.text, ndx + 7, 1);
      332 	  i = verify (work_ch1, "0123456789");
      333 	  if i = 0
      334 	  then tape_nfo.dens = substr (heals_message.text, ndx + 4, 4);
      335 	  else tape_nfo.dens = substr (heals_message.text, ndx + 4, 3);
      336 	end;
      337 	else tape_nfo.dens = "dflt";			/* density not specified */
      338 
      339 	if index (heals_message.text, "7track") ^= 0	/* determine number of tracks */
      340 	then tape_nfo.tracks = " 7";
      341 	else if index (heals_message.text, "9track") ^= 0
      342 	then tape_nfo.tracks = " 9";
      343 	else tape_nfo.tracks = "df";			/* tracks not specified */
      344 	goto next_log_rec;
      345 
      346 mount_rec:
      347 	if index (heals_message.text, "without") ^= 0	/* determine if write ring */
      348 	then tape_nfo.ring = "no";
      349 	else if index (heals_message.text, "with") ^= 0
      350 	then tape_nfo.ring = "ys";
      351 	else tape_nfo.ring = "df";			/* ring not specified */
      352 
      353 	ndx = index (heals_message.text, "Reel") + 5;	/* tape serial number or name */
      354 	offs_ndx = index (substr (heals_message.text, ndx), " ");
      355 	if offs_ndx ^> 1
      356 	then do; bad_name = "text";			/* something is wrong */
      357 	  goto bad_rcp_rec;
      358 	end;
      359 	if offs_ndx > 8
      360 	then tape_nfo.rsn = substr (heals_message.text, ndx, 7);
      361 	else tape_nfo.rsn = substr (heals_message.text, ndx, offs_ndx - 1);
      362 
      363 	if tape_nfo.dens = "?" then tape_nfo.dens = "dflt"; /* if no Note recored */
      364 	if tape_nfo.tracks = "?" then tape_nfo.tracks = "df"; /* ditto */
      365 	goto next_log_rec;
      366 
      367 bad_rcp_rec:
      368 	ioerr_rec_p = addr (bad_rec_buf);
      369 	ioerr_rec.data_size = 0;			/* force use of fake data */
      370 	call load_sort_data;
      371 	dev_nm_chk = dev_nm;
      372 	call get_iom_ch_nb;
      373 	dev_nb = dev_nb_chk;
      374 	goto bad_rec;
      375 
      376 
      377 /* ****	Process "ioi_interrupt" records.	**** */
      378 ioi_rec:
      379 	record_name = "ioi_";
      380 	io_msgp = addr (heals_message.data);		/* records have binary data */
      381 	call convert_channame_kludge (io_msg.channel, iom_nb_chk, ch_nb_chk);
      382 	if iom_nb_chk < 1 | iom_nb_chk > max_iom_nb_a	/* within bounds */
      383 	then do; bad_name = "iom";			/* nope */
      384 	  dev_nm_chk = "????";			/* fake it */
      385 	  goto bad_ioi_rec;
      386 	end;
      387 	if ch_nb_chk < 0 | ch_nb_chk > max_ch_nb_a
      388 	then do; bad_name = "channel";
      389 	  dev_nm_chk = "????";
      390 	  goto bad_ioi_rec;
      391 	end;
      392 	if io_msg.time_out
      393 	then dev_nm_chk = "chnl";
      394 	else do;
      395 	  ch_nfo_p = addr (ch_nfo_ar.ch_entry (iom_nb_chk, ch_nb_chk));
      396 	  if heals_message.data_size = 3
      397 	  then dev_nm_chk = devname;
      398 	  else if ch_nfo.i_set
      399 	  then dev_nm_chk = ch_nfo.dev_nam;
      400 	  else do; bad_name = "ch_unkn";		/* usually if system was reconfigured */
      401 	    dev_nm_chk = "????";			/* ^ between time of error and time of HEALS run */
      402 	    goto bad_ioi_rec;
      403 	  end;
      404 	end;
      405 	if substr (dev_nm_chk, 1, 3) = "tap" then do;
      406 	  dev_nb_chk = bin (io_msg.device, 6, 0);
      407 	  if dev_nb_chk < 0 | dev_nb_chk > max_tape_nb_a
      408 	  then do; bad_name = "device";
      409 	    goto bad_ioi_rec;
      410 	  end;
      411 	end;
      412 	ioerr_rec_p = addr (ioi_buf);			/* looks good - assign output buffer */
      413 	call move_syserr_nfo;			/* move info from heals_log record to ioerr_rec */
      414 	call load_sort_data;			/* fill in ioerr_rec.sort_data from binary data */
      415 
      416 /* Specific device info.  */
      417 
      418 /* Channel timeout. */
      419 	if io_msg.time_out
      420 	then do; dev_nm = "chnl";			/* as good a name as any */
      421 	  dev_model = 9999;				/* dummy model number */
      422 	  ioerr_rec.tape_disk_nfo = "";		/* null tape,disk info fields */
      423 	  tapno_diskad = "timeout";			/* use this column to say what happened */
      424 	  goto write_ioi_rec;
      425 	end;
      426 
      427 /* All other devices. */
      428 	dev_nm = dev_nm_chk;
      429 	if ch_nfo.i_set
      430 	then dev_model = ch_nfo.model;
      431 	else dev_model = 9999;
      432 	if substr (dev_nm, 1, 3) = "tap" then
      433 	  goto tape_err;
      434 	if substr (dev_nm, 1, 3) = "prt" then goto ur_err;
      435 	if substr (dev_nm, 1, 3) = "rdr" then goto ur_err;
      436 	if substr (dev_nm, 1, 3) = "pun" then goto ur_err;
      437 	if substr (dev_nm, 1, 3) = "dsk" then goto disk_err;
      438 	if substr (dev_nm, 1, 3) = "opc" then goto ur_err;
      439 	bad_name = "dv_unkn";			/* just in case */
      440 	dev_nm_chk = dev_nm;			/* report what it was */
      441 	goto bad_ioi_rec;
      442 
      443 tape_err:
      444 	tape_nfo_p = addr (tape_nfo_ar.tape_entry (iom_nb, dev_nb));
      445 	tapno_diskad = tape_nfo.rsn;			/* retrieve data from RCP: records */
      446 	dens_cyl = tape_nfo.dens;
      447 	tracks_sector = tape_nfo.tracks;
      448 	ring_head = tape_nfo.ring;
      449 	goto write_ioi_rec;
      450 
      451 disk_err:
      452 	ioerr_rec.tape_disk_nfo = "";			/* null until more info is logged */
      453 	tapno_diskad = "disk IO";			/* note it is user IO, not disk_control: */
      454 	goto write_ioi_rec;
      455 
      456 ur_err:
      457 	ioerr_rec.tape_disk_nfo = "";
      458 	tapno_diskad = n_a;				/* say it is not applicable */
      459 	goto write_ioi_rec;
      460 
      461 write_ioi_rec:
      462 	rprt_flags.ioerr = "1"b;
      463 	call write_ioerr_rec;
      464 	goto next_log_rec;
      465 
      466 bad_ioi_rec:
      467 	ioerr_rec_p = addr (bad_rec_buf);
      468 	ioerr_rec.data_size = heals_message.data_size;	/* use binary data in ioi_interrupt records */
      469 	call load_sort_data;
      470 	goto bad_rec;
      471 
      472 /* ****	Process "disk_control:" records.   * *** */
      473 disk_rec:
      474 	record_name = "disk_control:";
      475 	ioerr_rec_p = addr (disk_buf);
      476 	if index (heals_message.text, "Lost IOM") ^= 0 then goto iom_rec;
      477 	if index (heals_message.text, "Unex") ^= 0 then goto iom_rec;
      478 	if index (heals_message.text, "(iom") ^= 0 then goto disk_stat_rtrn;
      479 	if index (heals_message.text, "detail") ^= 0 then goto disk_detail;
      480 	if index (heals_message.text, "sect=") ^= 0 then goto disk_addr;
      481 	goto next_log_rec;
      482 
      483 iom_rec:
      484 	ndx = index (heals_message.text, "iom");
      485 	iom_nb_chk = bin (substr (heals_message.text, ndx + 4, 1)); /* get iom number */
      486 	ndx = index (heals_message.text, "dsk");
      487 	dev_nm_chk = substr (heals_message.text, ndx, 4); /* get device name */
      488 	offs_ndx = index (substr (heals_message.text, ndx + 5), " ");
      489 	if offs_ndx > 1
      490 	then dev_nb_chk = bin (substr (heals_message.text, ndx + 5, offs_ndx - 1)); /* device number */
      491 	else do; dev_nb_chk = 0;			/* something is wrong */
      492 	  goto bad_disk_rec;
      493 	end;
      494 	ndx = index (heals_message.text, "chan");
      495 	offs_ndx = index (substr (heals_message.text, ndx +5), ")");
      496 	if offs_ndx = 2
      497 	then ch_nb_chk = bin (substr (heals_message.text, ndx+5, 1)); /* single digit number */
      498 	else if offs_ndx = 3
      499 	then ch_nb_chk = bin (substr (heals_message.text, ndx+6, 1)) +
      500 	  bin (substr (heals_message.text, ndx+5, 1))*8;	/* change from octal to decimal */
      501 	else goto bad_disk_rec;
      502 	if flags.disk_hold				/* if holding data in buffer */
      503 	then do; call save_data;			/* then save it */
      504 	  flags.disk_hold = "0"b;			/* reset flag */
      505 	end;
      506 	call move_syserr_nfo;			/* build ioerr_rec */
      507 	call load_sort_data;
      508 	iom_nb = iom_nb_chk;
      509 	ch_nb = ch_nb_chk;
      510 	dev_nb = dev_nb_chk;
      511 	dev_nm = dev_nm_chk;
      512 	tape_disk_nfo = "";
      513 	msg_len = 38;
      514 	ndx = index (heals_message.text, "Lost");
      515 	if ndx ^= 0 then ioerr_rec.msg = substr (heals_message.text, ndx, 18);
      516 	else do; ndx = index (heals_message.text, "IOM");
      517 	  if ndx ^= 0 then ioerr_rec.msg = substr (heals_message.text, ndx, 35);
      518 	  else ioerr_rec.msg = "";
      519 	end;
      520 	flags.msg = "1"b;
      521 	rprt_flags.iom_rec = "1"b;			/* set format flag */
      522 	goto write_disk_rec;			/* write the ioerr_rec record */
      523 
      524 disk_stat_rtrn:
      525 	if flags.disk_hold
      526 	then call save_data;			/* save the data being held */
      527 	else flags.disk_hold = "1"b;			/* hold the new data */
      528 	call move_syserr_nfo;			/* build ioerr_rec */
      529 	call load_sort_data;
      530 	if heals_message.data_size = 3
      531 	then dev_nm = devname;
      532 	else do; ndx = index (heals_message.text, "dsk");
      533 	  dev_nm = substr (heals_message.text, ndx, 4);
      534 	end;
      535 	if index (heals_message.text, "sect=") = 0
      536 	then tape_disk_nfo = "";
      537 	else do;
      538 	  flags.disk_hold = "0"b;
      539 	  ndx = index (heals_message.text, "sect=");	/* get continuous address */
      540 	  offs_ndx = index (substr (heals_message.text, ndx), ",");
      541 	  if offs_ndx ^> 6 then goto bad_disk_rec;
      542 	  tapno_diskad = substr (heals_message.text, ndx + 5, offs_ndx - 6); /* number in ascii */
      543 	  do while (search (tapno_diskad, " ") > 0);
      544 	    tapno_diskad = "0" || tapno_diskad;		/* Eliminate blanks */
      545 	  end;
      546 	  i = bin (substr (heals_message.text, ndx + 5, offs_ndx - 6)); /* number in binary */
      547 
      548 	  ndx = index (heals_message.text, "cyl=");	/* get cylinder number */
      549 	  offs_ndx = index (substr (heals_message.text, ndx), ",");
      550 	  if offs_ndx ^> 5 then goto bad_disk_rec;
      551 	  dens_cyl = substr (heals_message.text, ndx +4, offs_ndx - 5);
      552 	  j = bin (substr (heals_message.text, ndx + 4, offs_ndx - 5));
      553 
      554 	  ndx = index (heals_message.text, "hd=");	/* get head number */
      555 	  offs_ndx = index (substr (heals_message.text, ndx), ",");
      556 	  if offs_ndx ^> 4 then goto bad_disk_rec;
      557 	  ring_head = substr (heals_message.text, ndx +3, offs_ndx -4);
      558 	  k = bin (substr (heals_message.text, ndx + 3, offs_ndx -4));
      559 
      560 	  l = i - j*760 - k*40;			/* get sector number */
      561 	  pic_w = l;
      562 	  tracks_sector = pic_w;
      563 	end;
      564 
      565 	if index (heals_message.text, "detail") = 0
      566 	then rprt_flags.ioerr = "1"b;			/* set the format flag */
      567 	else do;
      568 	  ndx = index (heals_message.text, "status:") + 8; /* get extended status text */
      569 	  msg_len = text_len - ndx +12;
      570 	  ioerr_rec.msg = "extended: (" || substr (heals_message.text, ndx, text_len-ndx) || ")";
      571 						/* reformat it */
      572 	  flags.msg = "1"b;				/* ioerr_rec contains a message */
      573 	  rprt_flags.diskerr = "1"b;			/* report line format */
      574 	end;
      575 
      576 	goto write_disk_rec;
      577 
      578 disk_detail:
      579 	ndx = index (heals_message.text, "dsk");
      580 	dev_nm_chk = substr (heals_message.text, ndx, 4);
      581 	offs_ndx = index (substr (heals_message.text, ndx + 5), " ");
      582 	if offs_ndx > 1
      583 	then dev_nb_chk = bin (substr (heals_message.text, ndx + 5, offs_ndx - 1));
      584 	else do; dev_nb_chk = 0;			/* something is wrong */
      585 	  goto bad_disk_rec;
      586 	end;
      587 	call move_syserr_nfo;			/* does not change dev_nb, dev_nm, or binary data */
      588 	ioerr_rec.data_size = save_size;		/* restore previous size */
      589 	if dev_nm ^= dev_nm_chk | dev_nb ^= dev_nb_chk | dev_cmnd = "000000"b
      590 	then do;					/* data in buffer not for this device */
      591 	  if flags.disk_hold then call save_data;	/* save the binary data */
      592 	  call retrieve_data;
      593 	  if i_code = 0 then dev_data.used = "0"b;	/* reset so that space can be re-used */
      594 	  call load_sort_data;
      595 	  if i_code ^= 0				/* fake data was used */
      596 	  then do; call get_iom_ch_nb;
      597 	    dev_nb = dev_nb_chk;			/* overwrite fake_data */
      598 	  end;
      599 	  dev_nm = dev_nm_chk;
      600 	end;
      601 	flags.disk_hold = "0"b;			/* reset flag */
      602 	ndx = index (heals_message.text, "status:") + 8;	/* get extended status text */
      603 	msg_len = text_len - ndx +12;
      604 	ioerr_rec.msg = "extended: (" || substr (heals_message.text, ndx, text_len-ndx) || ")";
      605 						/* reformat it */
      606 	flags.msg = "1"b;				/* ioerr_rec contains a message */
      607 	rprt_flags.ext_stat = "1"b;			/* report line format */
      608 	goto write_disk_rec;
      609 
      610 disk_addr:
      611 	ndx = index (heals_message.text, "dsk");
      612 	dev_nm_chk = substr (heals_message.text, ndx, 4);
      613 	offs_ndx = index (substr (heals_message.text, ndx + 5), " ");
      614 	if offs_ndx > 1
      615 	then dev_nb_chk = bin (substr (heals_message.text, ndx + 5, offs_ndx - 1));
      616 	else do; dev_nb_chk = 0;			/* something is wrong */
      617 	  goto bad_disk_rec;
      618 	end;
      619 	call move_syserr_nfo;			/* does not change dev_nb, dev_nm, or binary data */
      620 	ioerr_rec.data_size = save_size;		/* restore previous size */
      621 	if dev_nm ^= dev_nm_chk | dev_nb ^= dev_nb_chk | dev_cmnd = "000000"b
      622 	then do;					/* data in buffer not for this device */
      623 	  if flags.disk_hold
      624 	  then do; flags.disk_hold = "0"b;
      625 	    call save_data;
      626 	  end;
      627 	  call retrieve_data;
      628 	  call load_sort_data;
      629 	  if i_code ^= 0				/* fake data was used */
      630 	  then do; call get_iom_ch_nb;
      631 	    dev_nb = dev_nb_chk;			/* overwrite fake_data */
      632 	  end;
      633 	  dev_nm = dev_nm_chk;
      634 	end;
      635 	ndx = index (heals_message.text, "sect=");	/* get continuous address */
      636 	offs_ndx = index (substr (heals_message.text, ndx), ",");
      637 	if offs_ndx ^> 6 then goto bad_disk_rec;
      638 	tapno_diskad = substr (heals_message.text, ndx + 5, offs_ndx - 6);
      639 	do while (search (tapno_diskad, " ") > 0);
      640 	  tapno_diskad = "0" || tapno_diskad;		/* Eliminate blanks */
      641 	end;
      642 	i = bin (substr (heals_message.text, ndx + 5, offs_ndx - 6));
      643 
      644 	ndx = index (heals_message.text, "cyl=");	/* get cylinder number */
      645 	offs_ndx = index (substr (heals_message.text, ndx), ",");
      646 	if offs_ndx ^> 5 then goto bad_disk_rec;
      647 	dens_cyl = substr (heals_message.text, ndx +4, offs_ndx - 5);
      648 	j = bin (substr (heals_message.text, ndx + 4, offs_ndx - 5));
      649 
      650 	ndx = index (heals_message.text, "hd=");	/* get head number */
      651 	offs_ndx = index (substr (heals_message.text, ndx), ",");
      652 	if offs_ndx ^> 4 then goto bad_disk_rec;
      653 	ring_head = substr (heals_message.text, ndx +3, offs_ndx -4);
      654 	k = bin (substr (heals_message.text, ndx + 3, offs_ndx -4));
      655 
      656 	l = i - j*760 - k*40;			/* get sector number */
      657 	pic_w = l;
      658 	tracks_sector = pic_w;
      659 	rprt_flags.disk_addr = "1"b;			/* report line format */
      660 	goto write_disk_rec;
      661 
      662 write_disk_rec:
      663 	call write_ioerr_rec;
      664 	goto next_log_rec;
      665 
      666 bad_disk_rec:
      667 	ioerr_rec_p = addr (bad_rec_buf);
      668 	bad_name = "text";
      669 	ioerr_rec.data_size = 0;			/* force fake data */
      670 	call load_sort_data;
      671 	call get_iom_ch_nb;
      672 	goto bad_rec;
      673 
      674 /* ****	Process miscellaneous record types.	* *** */
      675 
      676 bulk_rec:						/* not an IO error, but nowhere else to put it */
      677 	record_name = "bulk";
      678 	ioerr_rec_p = addr (misc_buf);		/* assign output buffer */
      679 	call move_syserr_nfo;
      680 	call load_sort_data;
      681 	dev_nb = bulk_port;				/* port number is  used for device number */
      682 	dev_nm = "bulk";
      683 	ioerr_rec.msg_len = heals_message.text_len;
      684 	ioerr_rec.msg = heals_message.text;		/* print the syserr_log text */
      685 	flags.msg = "1"b;
      686 	rprt_flags.bulk = "1"b;
      687 	call write_ioerr_rec;
      688 	goto next_log_rec;
      689 
      690 dn355_rec:
      691 	if index (heals_message.text, "status") = 0 then goto next_log_rec;
      692 	record_name = "dn355";
      693 	ioerr_rec_p = addr (misc_buf);
      694 	call move_syserr_nfo;
      695 	ndx = index (heals_message.text, ":");
      696 	dev_nm = "355" || substr (heals_message.text, ndx +6, 1);
      697 	ioerr_rec.data_size = 2;
      698 	ioerr_rec.data = fake_data;
      699 	ndx = index (heals_message.text, "status");
      700 	ascii_status = substr (heals_message.text, ndx +7, 6)
      701 	  || substr (heals_message.text, ndx +14, 6);
      702 	status_nb = cv_oct_ (ascii_status);
      703 	ioerr_rec.data (2) = unspec (status_nb);
      704 	call load_sort_data;
      705 	dev_nm_chk = dev_nm;
      706 	call get_iom_ch_nb;
      707 	dev_nb = 1;
      708 	ioerr_rec.tape_disk_nfo = "";
      709 	tapno_diskad = n_a;
      710 	rprt_flags.ioerr = "1"b;
      711 	call write_ioerr_rec;
      712 	goto next_log_rec;
      713 
      714 bad_rec:
      715 	call move_syserr_nfo;			/* build ioerr_rec */
      716 	if ioerr_rec.data_size = 0
      717 	then ioerr_rec.data_size = save_size;		/* restore previous size */
      718 	dev_nm = dev_nm_chk;
      719 	msg_len = 38;
      720 	if bad_name = "text"			/* something wrong in extracting from text */
      721 	then call ioa_$rsnnl (
      722 	  "HEALS: error in extracting from text",
      723 	  ioerr_rec.msg, i);
      724 	else if bad_name = "ch_unkn" | bad_name = "dv_unkn" /* probably config change */
      725 	then do; if bad_name = "ch_unkn"
      726 	  then bad_name = "channel";
      727 	  else bad_name = "device";
      728 	  call ioa_$rsnnl (
      729 	    "HEALS: ^a not in config_table.",
      730 	    ioerr_rec.msg, i, bad_name);
      731 	end;
      732 	else call ioa_$rsnnl (
      733 	  "HEALS: ^a number is out of range.",
      734 	  ioerr_rec.msg, i, bad_name);		/* out of array bounds */
      735 	msg_len = i;
      736 	flags.msg = "1"b;
      737 	rprt_flags.bad_rec = "1"b;
      738 	call write_ioerr_rec;
      739 	goto next_log_rec;
      740 
      741 ineof_1:						/* end of file on heals_log */
      742 	revert conversion;
      743 	if nb_ioerr_recs = 0 then do; ior_flags.no_recs = "1"b; /* possibly there are no error recs */
      744 	end;
      745 	call iox_$close (ioerr_log_sw_p, code);
      746 	if code ^= 0 then call proc_err (7);
      747 
      748 /*  Writing of heals_ioerr_log file completed.  */
      749 
      750 /* FF  */
      751 
      752 
      753 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      754 	/*									*/
      755 	/* The following procedure is a no-no.  Ideally, there would be a system procedure to do	*/
      756 	/* what it does, or heals should just use the string provided in io_msg.  What it does	*/
      757 	/* is take a string and convert it to iom number and channel number.  If the string is	*/
      758 	/* unconvertible, it sets these values to -1.  It is up to the caller to detect this	*/
      759 	/* problem.								*/
      760 	/*									*/
      761 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      762 
      763 convert_channame_kludge: proc (chanid, iom, chan);
      764 
      765    dcl chanid char (8) aligned;
      766    dcl iom fixed bin (3);
      767    dcl chan fixed bin (6);
      768 
      769      iom = index ("ABCD", substr (chanid, 1, 1));
      770      if iom < 1 then goto bad_name;
      771      if verify (rtrim (substr (chanid, 2)), "0123456789") ^= 0 then goto bad_name;
      772      chan = binary (substr (chanid, 2), 7);
      773      return;
      774 
      775 bad_name:
      776      iom, chan = -1;				/* assume failure */
      777      return;
      778 
      779      end convert_channame_kludge;
      780 
      781 write_ioerr_rec: proc;
      782 	  if initiate				/* initiate interrupt */
      783 	  then do;				/* get rid of flags */
      784 	    if tapno_diskad = "?" then tapno_diskad = "";
      785 	    if ring_head = "?" then ring_head = "";
      786 	    if dens_cyl = "?" then dens_cyl = "";
      787 	    if tracks_sector = "?" then tracks_sector = "";
      788 	  end;
      789 
      790 	  nb_ioerr_recs = nb_ioerr_recs + 1;		/* keep count of records written */
      791 	  outrec_len = ioerr_rec_min_len + ioerr_rec.data_size * 4; /* account for data size */
      792 	  if flags.msg then outrec_len = outrec_len + msg_len; /* account for message length */
      793 	  call iox_$write_record (outsw_p, ioerr_rec_p, outrec_len, code);
      794 	  if code ^= 0 then call proc_err (15);
      795 	  flags.msg = "0"b;				/* reset flags */
      796 	  rprt_flags = "0"b;
      797 	  return;
      798 	end write_ioerr_rec;
      799 
      800 
      801 	return;
      802 
      803 move_syserr_nfo: proc;
      804 	  syserr_nfo_p = addr (ioerr_rec.syserr_nfo);	/* set pointer into current buffer */
      805 	  save_size = ioerr_rec.data_size;		/* save the data size in order to reload it */
      806 	  syserr_nfo_p -> rec_hdr = heals_message_p -> rec_hdr; /* move data from heals_log record */
      807 	  ioerr_rec.msg_len = 0;			/* usually no message in ioerr_rec */
      808 	  if ioerr_rec.data_size ^= 0			/* now equal to heals_message.data_size */
      809 	  then ioerr_rec.data = heals_message.data;	/* move the new data */
      810 
      811 	  call date_time_ ((heals_message.time), work_time); /* convert syserr_log time */
      812 	  sort_date = substr (work_time, 1, 8);		/* fill in ioerr_rec.sort_rec */
      813 	  log_time = substr (work_time, 11, 6);
      814 	  return;
      815 	end move_syserr_nfo;
      816 
      817 load_sort_data: proc;
      818 	  i_code = 0;
      819 	  if ioerr_rec.data_size = 0			/* if no data */
      820 	  then do; ioerr_rec.data_size = fake_data_size;	/* then fake it */
      821 	    ioerr_rec.data = fake_data;
      822 	    i_code = 1;				/* fake data used  */
      823 	  end;
      824 
      825 	  io_msgp = addr (ioerr_rec.data);		/* fill in ioerr_rec.sort_rec */
      826 	  statp = addr (io_msg.status);
      827 	  call convert_channame_kludge (io_msg.channel, iom_nb_chk, ch_nb_chk);
      828 	  iom_nb = iom_nb_chk;
      829 	  ch_nb = ch_nb_chk;
      830 	  dev_nb = bin (io_msg.device);
      831 	  dev_cmnd = io_msg.command;
      832 	  ss = bin (io_msg.level);
      833 	  ntrpt_nm = ntrpt_nm_list (ss);
      834 
      835 	  power_off = power;
      836 	  maj_st = "00"b || major;
      837 	  sub_st = sub;
      838 	  ntrpt_no = initiate;			/* initiate interrupt */
      839 	  if initiate then ntrpt_nm = "i";
      840 	  iom_st = channel_stat || central_stat;
      841 	  rec_cnt_res = rcount;
      842 	  return;
      843 	end load_sort_data;
      844 
      845 get_iom_ch_nb: proc;				/* get iom and channel number for device name */
      846 	  i_code = 0;
      847 	  found = "0"b;
      848 	  do i = 1 to max_iom_nb_a while (^found);
      849 	    do j = 0 to max_ch_nb_a while (^found);
      850 	      if ch_nfo_ar.ch_entry.dev_nam (i, j) = dev_nm_chk
      851 	      then do;
      852 	        iom_nb = i;
      853 	        ch_nb = j;
      854 	        found = "1"b;
      855 	      end;
      856 	    end;
      857 	  end;
      858 
      859 	  if ^found then i_code = 1;			/* did not find entry for device name */
      860 	  return;
      861 	end get_iom_ch_nb;
      862 
      863 save_data: proc;					/* save ioerr_rec data for future use */
      864 	  i_code = 0;
      865 	  found = "0"b;
      866 	  if ioerr_rec.data_size = 0			/* should not happen */
      867 	  then do; i_code = 1;
      868 	    return;
      869 	  end;
      870 	  if ioerr_rec.data_size ^= 2 then ioerr_rec.data_size = 2;
      871 
      872 /* Search for entry by device address to overwrite unused old data. */
      873 	  dev_data_p = addr (dev_data_space);
      874 	  do while (dev_data_stopper ^= -1 & ^found);
      875 	    if ch_nb = ch_nmbr
      876 	    then if dev_nb = dev_nmbr
      877 	      then if iom_nb = iom_nmbr
      878 	        then do;				/* matched with old entry */
      879 		saved_data = ioerr_rec.data;
      880 		dev_name = dev_nm;
      881 		dev_data.used = "1"b;
      882 		found = "1"b;
      883 	        end;
      884 	    if ^found then dev_data_p = addrel (dev_data_p, dev_data_size); /* to next entry */
      885 	  end;
      886 
      887 /* Search for unused entry. */
      888 	  if ^found then do;
      889 	    dev_data_p = addr (dev_data_space);
      890 	    i = 0;				/* initialize count */
      891 	    do while (dev_data_stopper ^= -1 & ^found);
      892 	      i = i +1;				/* count number of entries */
      893 	      if ^dev_data.used then found = "1"b;;	/* found one */
      894 	      if ^found then dev_data_p = addrel (dev_data_p, dev_data_size); /* to next entry */
      895 	    end;					/* didn't find one */
      896 	  end;
      897 
      898 	  if ^found then if i <= 64			/* do not go beyond assigned space */
      899 	    then do;
      900 	      work_p1 = addrel (dev_data_p, dev_data_size); /* set stopper in next entry */
      901 	      work_p1 -> dev_data_stopper = -1;
      902 	      found = "1"b;
      903 	    end;
      904 	    else i_code = 1;			/* data not saved  */
      905 
      906 	  if found then do;				/* unused or new entry */
      907 	    ch_nmbr = ch_nb;
      908 	    dev_nmbr = dev_nb;
      909 	    iom_nmbr = iom_nb;
      910 	    dev_name = dev_nm;
      911 	    saved_data = ioerr_rec.data;
      912 	    dev_data.used = "1"b;
      913 	  end;
      914 	  return;
      915 	end save_data;
      916 
      917 retrieve_data: proc;				/* retrive previously saved data */
      918 	  i_code = 0;
      919 	  dev_data_p = addr (dev_data_space);		/* initialize pointer */
      920 	  found = "0"b;
      921 	  do while (dev_data_stopper ^= -1 & ^found);
      922 	    if dev_nm_chk = dev_name			/* search by device name and number */
      923 	    then if dev_nb_chk = dev_nmbr
      924 	      then do;
      925 	        iom_nb = iom_nmbr;			/* move info to ioerr_rec */
      926 	        ch_nb = ch_nmbr;
      927 	        ioerr_rec.data_size = 2;
      928 	        ioerr_rec.data = saved_data;
      929 	        found = "1"b;
      930 	      end;
      931 	    if ^found then dev_data_p = addrel (dev_data_p, dev_data_size); /* to next entry */
      932 	  end;
      933 	  if ^found then do; i_code = 1;		/* no entry found */
      934 	    ioerr_rec.data_size = 0;			/* set data size to 0 as a flag */
      935 	  end;
      936 	  return;
      937 	end retrieve_data;
      938 
      939 /* FF */
      940 proc_err:	proc (proc_err_nb);
      941 dcl  proc_err_nb fixed bin;
      942 	  r_code = code;
      943 	  call com_err_ (code, whoami, "Procedure error number = ^d.", proc_err_nb);
      944 	  call clean_up;
      945 	  goto err_return;
      946 	end proc_err;
      947 
      948 clean_up:	proc;
      949 	  if sortsw_p ^= null ()
      950 	  then do; if sortsw_p -> iocb.open_descrip_ptr ^= null ()
      951 	    then call sortsw_p -> iocb.close (sortsw_p, code);
      952 	    if sortsw_p -> iocb.attach_descrip_ptr ^= null ()
      953 	    then call sortsw_p -> iocb.detach_iocb (sortsw_p, code);
      954 	  end;
      955 	  return;
      956 	end clean_up;
      957 
      958 err_return: return;
      959 
      960 
      961         end heals_gen_ioerr_log_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/27/84  0744.1  heals_gen_ioerr_log_.pl1          >spec>on>heals>heals_gen_ioerr_log_.pl1
178          1    11/02/76  1752.0  heals_arg_info.incl.pl1           >ldd>include>heals_arg_info.incl.pl1
179          2    10/25/77  1258.3  heals_io_report_args.incl.pl1     >ldd>include>heals_io_report_args.incl.pl1
180          3    10/25/77  1258.3  heals_ioerr_rec.incl.pl1          >ldd>include>heals_ioerr_rec.incl.pl1
181          4    10/25/77  1258.3  heals_message.incl.pl1            >ldd>include>heals_message.incl.pl1
182          5    08/10/81  1843.6  io_syserr_msg.incl.pl1            >ldd>include>io_syserr_msg.incl.pl1
183          6    01/10/75  1343.6  iom_stat.incl.pl1                 >ldd>include>iom_stat.incl.pl1
184          7    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 172 ref 197 199 201 215 218 221 224 228 236 261
                                                                                  316 367 380 395 412 443 466 475 666 678 693 804
                                                                                  825 826 873 889 919
addrel                                                 builtin function         dcl 172 ref 231 884 894 900 931
arg_info                               based           structure                level 1 dcl 169
ascii_status                    000146 automatic       char(12)                 unaligned dcl 64 set ref 700* 702*
attach_descrip_ptr       14            based           pointer                  level 2 dcl 7-6 ref 952
bad_name                        000160 automatic       char(7)                  unaligned dcl 73 set ref 313* 356* 383* 388* 400*
                                                                                  408* 439* 668* 720 724 724 725 725* 727* 728* 732*
bad_rec                   6(32)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 737*
bad_rec_buf                     000156 automatic       char                     dcl 69 set ref 215 261 367 466 666
bulk                      6(34)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 686*
bulk_port                              based           fixed bin(17,0)          level 2 dcl 2-33 ref 681
central_stat              0(21)        based           bit(3)                   level 2 packed unaligned dcl 6-7 ref 840
ch_entry                               based           structure                array level 2 dcl 165 set ref 395
ch_nb                     2(04)        based           fixed bin(6,0)           level 3 packed unaligned dcl 3-7 set ref 509* 829*
                                                                                  853* 875 907 926*
ch_nb_chk                       001027 automatic       fixed bin(6,0)           dcl 105 set ref 381* 387 387 395 496* 498* 509 827*
                                                                                  829
ch_nfo                                 based           structure                level 1 dcl 2-25
ch_nfo_ar                              based           structure                array level 1 dcl 165
ch_nfo_ar_p               4            based           pointer                  level 2 dcl 2-5 ref 395 850
ch_nfo_p                        001226 automatic       pointer                  dcl 2-24 set ref 395* 398 398 429 429
ch_nmbr                   2            based           fixed bin(6,0)           level 2 dcl 155 set ref 875 907* 926
chan                                   parameter       fixed bin(6,0)           dcl 767 set ref 763 772* 775*
chanid                                 parameter       char(8)                  dcl 765 ref 763 769 771 772
channel                   1            based           char(8)                  level 2 dcl 5-14 set ref 381* 827*
channel_stat              0(18)        based           bit(3)                   level 2 packed unaligned dcl 6-7 ref 840
cleanup                         001060 stack reference condition                dcl 173 ref 191
clock_                          000020 constant        entry                    external dcl 30 ref 245
clock_time                      001040 automatic       fixed bin(71,0)          dcl 116 set ref 245* 246*
close                    36            based           entry variable           level 2 dcl 7-6 ref 950
code                            001033 automatic       fixed bin(35,0)          dcl 111 set ref 209* 257* 258 274* 275 275 282* 284
                                                                                  284 745* 746 793* 794 942 943* 950* 952*
com_err_                        000016 constant        entry                    external dcl 29 ref 943
command                   0(21)        based           bit(6)                   level 2 packed unaligned dcl 5-14 ref 831
conversion                      001066 stack reference condition                dcl 174 ref 260 741
cv_oct_                         000024 constant        entry                    external dcl 32 ref 702
data                     21            based           bit(36)                  array level 3 in structure "ioerr_rec" packed
                                                                                  unaligned dcl 3-7 in procedure
                                                                                  "heals_gen_ioerr_log_" set ref 698* 703* 808* 821*
                                                                                  825 879 911 928*
data                                   based           bit(36)                  array level 3 in structure "heals_message" dcl 4-3
                                                                                  in procedure "heals_gen_ioerr_log_" set ref 380
                                                                                  808
data_size                 4(24)        based           fixed bin(11,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "heals_gen_ioerr_log_" ref 396 468 530 808
data_size                20(24)        based           fixed bin(11,0)          level 3 in structure "ioerr_rec" packed unaligned
                                                                                  dcl 3-7 in procedure "heals_gen_ioerr_log_" set
                                                                                  ref 216* 219* 222* 225* 263 369* 468* 515 517 518
                                                                                  570 588* 604 620* 669* 684 697* 698 716 716* 720
                                                                                  728 732 791 805 808 808 819 820* 821 866 870 870*
                                                                                  879 911 927* 928 934*
date                            000772 automatic       char(8)                  unaligned dcl 78 set ref 247* 249*
date_time                       000765 automatic       char(16)                 unaligned dcl 77 set ref 246* 247 248
date_time_                      000022 constant        entry                    external dcl 31 ref 211 212 246 811
dens                      1(27)        based           char(4)                  level 2 packed unaligned dcl 149 set ref 333* 335*
                                                                                  337* 363 363* 446
dens_cyl                 11(27)        based           picture(4)               level 3 packed unaligned dcl 3-7 set ref 446* 551*
                                                                                  647* 786 786*
detach_iocb              26            based           entry variable           level 2 dcl 7-6 ref 952
dev_cmnd                  2(32)        based           bit(6)                   level 3 packed unaligned dcl 3-7 set ref 589 621
                                                                                  831*
dev_data                               based           structure                level 1 dcl 155 set ref 205
dev_data_p                      000126 automatic       pointer                  initial dcl 52 set ref 52* 205 228* 229 230 231* 231
                                                                                  232 593 873* 874 875 875 875 879 880 881 884* 884
                                                                                  889* 891 893 894* 894 900 907 908 909 910 911 912
                                                                                  919* 921 922 922 925 926 928 931* 931
dev_data_size                   001016 automatic       fixed bin(17,0)          dcl 98 set ref 205* 231 884 894 900 931
dev_data_space                  000163 automatic       char(1540)               unaligned dcl 75 set ref 228 873 889 919
dev_data_stopper                       based           fixed bin(17,0)          dcl 87 set ref 229* 232* 874 891 901* 921
dev_model                 7            based           fixed bin(17,0)          level 3 packed unaligned dcl 3-7 set ref 421* 429*
                                                                                  431*
dev_nam                                based           char(4)                  array level 3 in structure "ch_nfo_ar" packed
                                                                                  unaligned dcl 165 in procedure
                                                                                  "heals_gen_ioerr_log_" set ref 850
dev_nam                                based           char(4)                  level 2 in structure "ch_nfo" packed unaligned
                                                                                  dcl 2-25 in procedure "heals_gen_ioerr_log_" ref
                                                                                  398
dev_name                               based           char(4)                  level 2 dcl 155 set ref 880* 910* 922
dev_nb                    2(11)        based           fixed bin(6,0)           level 3 packed unaligned dcl 3-7 set ref 373* 443
                                                                                  510* 589 597* 621 631* 681* 707* 830* 875 908
dev_nb_chk                      001030 automatic       fixed bin(6,0)           dcl 106 set ref 311* 312 312 316 373 406* 407 407
                                                                                  489* 491* 510 582* 584* 589 597 614* 616* 621 631
                                                                                  922
dev_nm                    4            based           picture(4)               level 3 packed unaligned dcl 3-7 set ref 371 420*
                                                                                  428* 432 434 435 436 437 438 440 511* 530* 533*
                                                                                  589 599* 621 633* 682* 696* 705 718* 880 910
dev_nm_chk                      000162 automatic       char(4)                  unaligned dcl 74 set ref 371* 384* 389* 392* 396*
                                                                                  398* 401* 405 428 440* 487* 511 580* 589 599 612*
                                                                                  621 633 705* 718 850 922
dev_nmbr                  3(11)        based           fixed bin(6,0)           level 2 packed unaligned dcl 155 set ref 875 908*
                                                                                  922
device                    0(12)        based           bit(6)                   level 2 packed unaligned dcl 5-14 ref 406 830
devname                   4            based           char(4)                  level 2 dcl 5-14 ref 396 530
disk_addr                 6(29)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 659*
disk_buf                        000156 automatic       char                     dcl 70 set ref 218 475
disk_hold                 0(06)        based           bit(1)                   level 2 packed unaligned dcl 138 set ref 502 504*
                                                                                  524 527* 538* 591 601* 623 624*
diskerr                   6(28)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 573*
err_nb                    4            based           fixed bin(35,0)          level 2 dcl 169 set ref 210*
error_table_$end_of_info        000012 external static fixed bin(35,0)          dcl 25 ref 275 284
ext_stat                  6(30)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 607*
fake_data                       001056 automatic       bit(36)                  initial array dcl 132 set ref 132* 132* 206 698 821
fake_data_size                  001031 automatic       fixed bin(17,0)          dcl 107 set ref 206* 820
flags                                  based           structure                level 1 dcl 138
flags_p                         000100 automatic       pointer                  initial dcl 43 set ref 43* 197* 249 267 502 504 520
                                                                                  524 527 538 572 591 601 606 623 624 685 736 792
                                                                                  795
flags_word                      001043 automatic       bit(36)                  initial dcl 121 set ref 121* 197
found                           001044 automatic       bit(1)                   dcl 122 set ref 847* 848 849 854* 859 865* 874 882*
                                                                                  884 888 891 893* 894 898 902* 906 920* 921 929*
                                                                                  931 933
from_time               126            based           fixed bin(71,0)          level 2 dcl 169 set ref 211*
heals_arg_info                  001074 automatic       structure                level 1 dcl 1-4
heals_arg_info_p                       parameter       pointer                  dcl 20 ref 6 198 210 211 212 292
heals_ior_args_p                       parameter       pointer                  dcl 21 ref 6 129 129 200 234 235 249 312 382 387 395
                                                                                  395 395 407 681 743 745 848 849 850 850 850
heals_message                          based           structure                level 1 dcl 4-3
heals_message_p                 001232 automatic       pointer                  dcl 4-15 set ref 201* 292 293 294 295 296 297 298
                                                                                  305 309 311 318 319 320 321 328 331 333 335 339
                                                                                  341 346 349 353 354 359 361 380 396 468 476 477
                                                                                  478 479 480 483 485 486 487 488 489 494 495 496
                                                                                  498 498 514 515 516 517 530 532 533 535 539 540
                                                                                  542 546 548 549 551 552 554 555 557 558 565 568
                                                                                  569 570 570 578 580 581 582 602 603 604 604 610
                                                                                  612 613 614 635 636 638 642 644 645 647 648 650
                                                                                  651 653 654 683 684 690 695 696 699 700 700 806
                                                                                  808 811
i                               001017 automatic       fixed bin(17,0)          dcl 99 set ref 234* 236* 263* 266 332* 333 546* 560
                                                                                  642* 656 720* 728* 732* 735 848* 850 852* 890*
                                                                                  892* 892 898
i_code                          001013 automatic       fixed bin(35,0)          dcl 95 set ref 593 595 629 818* 822* 846* 859* 864*
                                                                                  867* 904* 918* 933*
i_set                     1(32)        based           bit(1)                   level 2 packed unaligned dcl 2-25 ref 398 429
inbuf                           000156 automatic       char                     dcl 67 set ref 199 201
inbuf_len                       000010 internal static fixed bin(21,0)          initial dcl 88 set ref 67 274* 282*
inbuf_p                         000110 automatic       pointer                  initial dcl 47 set ref 47* 199* 274* 282*
index                                                  builtin function         dcl 172 ref 305 309 318 319 320 321 328 339 341 346
                                                                                  349 353 354 476 477 478 479 480 483 486 488 494
                                                                                  495 514 516 532 535 539 540 548 549 554 555 565
                                                                                  568 578 581 602 610 613 635 636 644 645 650 651
                                                                                  690 695 699 769
initiate                  0(16)        based           bit(1)                   level 2 packed unaligned dcl 6-7 ref 782 838 839
inrec_len                       001034 automatic       fixed bin(21,0)          dcl 112 set ref 274* 282*
insw_p                          000130 automatic       pointer                  initial dcl 54 set ref 54* 198* 274* 282*
io_msg                                 based           structure                level 1 dcl 5-14
io_msgp                         001234 automatic       pointer                  dcl 5-12 set ref 380* 381 392 396 406 419 530 825*
                                                                                  826 827 830 831 832
ioa_                            000014 constant        entry                    external dcl 28 ref 249
ioa_$rsnnl                      000026 constant        entry                    external dcl 33 ref 263 720 728 732
iocb                                   based           structure                level 1 dcl 7-6
iocbp                                  based           pointer                  level 2 dcl 169 ref 198
ioerr                     6(27)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 461* 565*
                                                                                  710*
ioerr_log_sw_p            6            based           pointer                  level 2 dcl 2-5 set ref 200 745*
ioerr_rec                              based           structure                level 1 dcl 3-7 set ref 204
ioerr_rec_min_len               001015 automatic       fixed bin(21,0)          dcl 97 set ref 204* 791
ioerr_rec_p                     001230 automatic       pointer                  dcl 3-6 set ref 204 215* 216 217 218* 219 220 221*
                                                                                  222 223 224* 225 226 261* 262 263 266 268 367* 369
                                                                                  371 373 412* 420 421 422 423 428 429 431 432 434
                                                                                  435 436 437 438 440 443 443 445 446 447 448 451
                                                                                  453 456 458 461 466* 468 475* 508 509 510 511 512
                                                                                  513 515 517 518 521 530 533 535 542 543 544 544
                                                                                  551 557 562 565 569 570 573 588 589 589 589 597
                                                                                  599 603 604 607 620 621 621 621 631 633 638 639
                                                                                  640 640 647 653 658 659 666* 669 678* 681 682 683
                                                                                  684 686 693* 696 697 698 703 705 707 708 709 710
                                                                                  716 716 718 719 720 728 732 735 737 784 784 785
                                                                                  785 786 786 787 787 791 792 793* 796 804 805 807
                                                                                  808 808 812 813 819 820 821 825 828 829 830 831
                                                                                  833 835 836 837 838 839 840 841 852 853 866 870
                                                                                  870 875 875 875 879 880 907 908 909 910 911 925
                                                                                  926 927 928 934
ioi_buf                         000156 automatic       char                     dcl 68 set ref 221 412
iom                                    parameter       fixed bin(3,0)           dcl 766 set ref 763 769* 770 775*
iom_nb                    2            based           fixed bin(3,0)           level 3 packed unaligned dcl 3-7 set ref 443 508*
                                                                                  828* 852* 875 909 925*
iom_nb_chk                      001026 automatic       fixed bin(3,0)           dcl 104 set ref 304* 316 381* 382 382 395 485* 508
                                                                                  827* 828
iom_nmbr                  3(32)        based           fixed bin(3,0)           level 2 packed unaligned dcl 155 set ref 875 909*
                                                                                  925
iom_rec                   6(31)        based           bit(1)                   level 4 packed unaligned dcl 3-7 set ref 521*
iom_st                    3(02)        based           bit(6)                   level 3 packed unaligned dcl 3-7 set ref 840*
ior_avars                              based           structure                level 1 dcl 2-33
ior_avars_p              10            based           pointer                  level 2 dcl 2-5 ref 681
ior_flags                              based           structure                level 1 dcl 2-12
ior_flags_p                            based           pointer                  level 2 dcl 2-5 ref 249 743
ior_prms                               based           structure                level 1 dcl 2-18
ior_prms_p                2            based           pointer                  level 2 dcl 2-5 ref 129 129 234 235 312 382 387 395
                                                                                  395 407 848 849 850 850
ior_ptrs                               based           structure                level 1 dcl 2-5
iox_$close                      000030 constant        entry                    external dcl 35 ref 745
iox_$open                       000032 constant        entry                    external dcl 37 ref 257
iox_$read_record                000034 constant        entry                    external dcl 38 ref 274 282
iox_$write_record               000036 constant        entry                    external dcl 39 ref 793
j                               001020 automatic       fixed bin(17,0)          dcl 99 set ref 235* 236* 552* 560 648* 656 849* 850
                                                                                  853*
k                               001021 automatic       fixed bin(17,0)          dcl 99 set ref 558* 560 654* 656
l                               001022 automatic       fixed bin(17,0)          dcl 99 set ref 560* 561 656* 657
level                                  based           bit(3)                   level 2 packed unaligned dcl 5-14 ref 832
log_time                  5            based           char(6)                  level 3 packed unaligned dcl 3-7 set ref 813*
maj_st                    2(19)        based           bit(6)                   level 3 packed unaligned dcl 3-7 set ref 836*
major                     0(02)        based           bit(4)                   level 2 packed unaligned dcl 6-7 ref 836
max_ch_nb_a               0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-18 ref 387 395 395
                                                                                  849 850 850
max_iom_nb_a                           based           fixed bin(17,0)          level 2 packed unaligned dcl 2-18 ref 129 234 382
                                                                                  848
max_tape_nb_a             1            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-18 ref 129 235 312
                                                                                  407
misc_buf                        000156 automatic       char                     dcl 71 set ref 224 678 693
model                     1            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-25 ref 429
msg                       6(33)        based           bit(1)                   level 4 in structure "ioerr_rec" packed unaligned
                                                                                  dcl 3-7 in procedure "heals_gen_ioerr_log_" set
                                                                                  ref 268*
msg                       0(05)        based           bit(1)                   level 2 in structure "flags" packed unaligned
                                                                                  dcl 138 in procedure "heals_gen_ioerr_log_" set
                                                                                  ref 267* 520* 572* 606* 685* 736* 792 795*
msg                                    based           char                     level 2 in structure "ioerr_rec" dcl 3-7
                                                                                  in procedure "heals_gen_ioerr_log_" set ref 263*
                                                                                  515* 517* 518* 570* 604* 684* 720* 728* 732*
msg_len                  20(12)        based           fixed bin(11,0)          level 3 packed unaligned dcl 3-7 set ref 262* 263
                                                                                  263 266* 513* 515 517 518 569* 570 603* 604 683*
                                                                                  684 719* 720 720 728 728 732 732 735* 792 807*
n_a                             000764 automatic       char(3)                  initial unaligned dcl 76 set ref 76* 458 709
nb_ioerr_recs                   001014 automatic       fixed bin(17,0)          dcl 96 set ref 213* 743 790* 790
ndx                             001023 automatic       fixed bin(24,0)          dcl 100 set ref 328* 330 331 333 335 353* 354 359
                                                                                  361 483* 485 486* 487 488 489 494* 495 496 498 498
                                                                                  514* 515 515 516* 517 517 532* 533 539* 540 542
                                                                                  546 548* 549 551 552 554* 555 557 558 568* 569 570
                                                                                  570 578* 580 581 582 602* 603 604 604 610* 612 613
                                                                                  614 635* 636 638 642 644* 645 647 648 650* 651 653
                                                                                  654 695* 696 699* 700 700
no_recs                   0(02)        based           bit(1)                   level 2 packed unaligned dcl 2-12 set ref 743*
ntrpt_nm                  6(18)        based           char(1)                  level 3 packed unaligned dcl 3-7 set ref 833* 839*
ntrpt_nm_list                   001045 automatic       char(1)                  initial array dcl 126 set ref 126* 126* 126* 126*
                                                                                  126* 126* 126* 126* 833
ntrpt_no                  2(31)        based           bit(1)                   level 3 packed unaligned dcl 3-7 set ref 838*
null                                                   builtin function         dcl 172 ref 43 44 45 46 47 48 48 48 49 50 51 52 54
                                                                                  949 950 952
offs_ndx                        001024 automatic       fixed bin(17,0)          dcl 101 set ref 309* 311 354* 355 359 361 488* 489
                                                                                  489 495* 496 498 540* 541 542 546 549* 550 551 552
                                                                                  555* 556 557 558 581* 582 582 613* 614 614 636*
                                                                                  637 638 642 645* 646 647 648 651* 652 653 654
open_descrip_ptr         20            based           pointer                  level 2 dcl 7-6 ref 950
outbuf_len                             constant        fixed bin(21,0)          initial dcl 89 ref 68 69 70 71
outrec_len                      001035 automatic       fixed bin(21,0)          dcl 113 set ref 791* 792* 792 793*
outsw_p                         000104 automatic       pointer                  initial dcl 45 set ref 45* 200* 257* 793*
pic_w                           000156 automatic       picture(2)               unaligned dcl 72 set ref 561* 562 657* 658
power                     0(01)        based           bit(1)                   level 2 packed unaligned dcl 6-7 ref 835
power_off                 2(18)        based           bit(1)                   level 3 packed unaligned dcl 3-7 set ref 835*
proc_err_nb                            parameter       fixed bin(17,0)          dcl 941 set ref 940 943*
r_code                                 parameter       fixed bin(35,0)          dcl 22 set ref 6 194* 942*
rcount                    0(30)        based           bit(6)                   level 2 packed unaligned dcl 6-7 ref 841
rec_cnt_res               3(08)        based           bit(6)                   level 3 packed unaligned dcl 3-7 set ref 841*
rec_hdr                                based           bit(180)                 unaligned dcl 123 set ref 806* 806
record_name                     000151 automatic       char(13)                 unaligned dcl 65 set ref 263* 290* 302* 378* 473*
                                                                                  676* 692*
report_nfo                4            based           structure                level 2 dcl 3-7
rest_of_record            1            based           structure                level 2 dcl 4-3
ring                      3(09)        based           char(2)                  level 2 packed unaligned dcl 149 set ref 346* 349*
                                                                                  351* 448
ring_head                12(27)        based           picture(2)               level 3 packed unaligned dcl 3-7 set ref 448* 557*
                                                                                  653* 785 785*
rprt_flags                6(27)        based           structure                level 3 packed unaligned dcl 3-7 set ref 217* 220*
                                                                                  223* 226* 796*
rprt_from_time                  000132 automatic       char(16)                 unaligned dcl 61 set ref 211*
rprt_to_time                    000136 automatic       char(16)                 unaligned dcl 62 set ref 212*
rsn                                    based           char(7)                  level 2 packed unaligned dcl 149 set ref 359* 361*
                                                                                  445
save_size                       001032 automatic       fixed bin(17,0)          dcl 108 set ref 588 620 716 805*
saved_data                4            based           bit(36)                  array level 2 dcl 155 set ref 879* 911* 928
search                                                 builtin function         dcl 172 ref 543 639
seq_in                          001010 automatic       fixed bin(17,0)          initial dcl 92 set ref 92*
seq_out                         001011 automatic       fixed bin(17,0)          initial dcl 93 set ref 93* 257*
size                                                   builtin function         dcl 172 ref 204 205 206
sort_data_p                     000122 automatic       pointer                  initial dcl 50 set ref 50*
sort_date                              based           char(8)                  level 3 packed unaligned dcl 3-7 set ref 812*
sort_desc_p                     000112 automatic       pointer                  initial array dcl 48 set ref 48* 48* 48*
sort_rec                               based           structure                level 2 dcl 3-7
sortsw_p                        000106 automatic       pointer                  initial dcl 46 set ref 46* 949 950 950 950* 952 952
                                                                                  952*
ss                              001025 automatic       fixed bin(17,0)          dcl 102 set ref 832* 833
statp                           001236 automatic       pointer                  dcl 6-5 set ref 782 826* 835 836 837 838 839 840 840
                                                                                  841
status                                 based           structure                level 1 dcl 6-7 in procedure "heals_gen_ioerr_log_"
status                    3            based           bit(36)                  level 2 in structure "io_msg" dcl 5-14 in procedure
                                                                                  "heals_gen_ioerr_log_" set ref 826
status_nb                       001012 automatic       fixed bin(35,0)          dcl 94 set ref 702* 703
stream_in                       001006 automatic       fixed bin(17,0)          initial dcl 90 set ref 90*
stream_out                      001007 automatic       fixed bin(17,0)          initial dcl 91 set ref 91*
sub                       0(06)        based           bit(6)                   level 2 packed unaligned dcl 6-7 ref 837
sub_st                    2(25)        based           bit(6)                   level 3 packed unaligned dcl 3-7 set ref 837*
substr                                                 builtin function         dcl 172 ref 247 248 293 294 295 296 297 298 311 331
                                                                                  333 335 354 359 361 405 432 434 435 436 437 438
                                                                                  485 487 488 489 495 496 498 498 515 517 533 540
                                                                                  542 546 549 551 552 555 557 558 570 580 581 582
                                                                                  604 612 613 614 636 638 642 645 647 648 651 653
                                                                                  654 696 700 700 769 771 772 812 813
syserr_nfo               14            based           structure                level 2 dcl 3-7 set ref 804
syserr_nfo_p                    000124 automatic       pointer                  initial dcl 51 set ref 51* 804* 806
tape_disk_nfo            10            based           structure                level 2 dcl 3-7 set ref 422* 451* 456* 512* 535*
                                                                                  708*
tape_entry                      001055 automatic       structure                array level 2 dcl 129 set ref 236 316 443
tape_nfo                               based           structure                level 1 dcl 149 set ref 237* 324*
tape_nfo_ar                     001055 automatic       structure                array level 1 dcl 129
tape_nfo_p                      000120 automatic       pointer                  initial dcl 49 set ref 49* 236* 237 316* 324 333 335
                                                                                  337 339 341 343 346 349 351 359 361 363 363 364
                                                                                  364 443* 445 446 447 448
tapno_diskad             10            based           picture(7)               level 3 packed unaligned dcl 3-7 set ref 423* 445*
                                                                                  453* 458* 542* 543 544* 544 638* 639 640* 640 709*
                                                                                  784 784*
text                      7            based           char                     level 3 dcl 4-3 ref 293 294 295 296 297 298 305 309
                                                                                  311 318 319 320 321 328 331 333 335 339 341 346
                                                                                  349 353 354 359 361 476 477 478 479 480 483 485
                                                                                  486 487 488 489 494 495 496 498 498 514 515 516
                                                                                  517 532 533 535 539 540 542 546 548 549 551 552
                                                                                  554 555 557 558 565 568 570 578 580 581 582 602
                                                                                  604 610 612 613 614 635 636 638 642 644 645 647
                                                                                  648 650 651 653 654 684 690 695 696 699 700 700
text_len                  4(12)        based           fixed bin(11,0)          level 3 packed unaligned dcl 4-3 ref 293 294 295 296
                                                                                  297 298 305 309 311 318 319 320 321 328 331 333
                                                                                  335 339 341 346 349 353 354 359 361 380 476 477
                                                                                  478 479 480 483 485 486 487 488 489 494 495 496
                                                                                  498 498 514 515 516 517 532 533 535 539 540 542
                                                                                  546 548 549 551 552 554 555 557 558 565 568 569
                                                                                  570 570 578 580 581 582 602 603 604 604 610 612
                                                                                  613 614 635 636 638 642 644 645 647 648 650 651
                                                                                  653 654 683 684 690 695 696 699 700 700 808 808
time                      2            based           fixed bin(71,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "heals_gen_ioerr_log_" ref 292 811
time                            000774 automatic       char(6)                  unaligned dcl 79 in procedure "heals_gen_ioerr_log_"
                                                                                  set ref 248* 249*
time_out                  0(18)        based           bit(1)                   level 2 packed unaligned dcl 5-14 ref 392 419
to_time                 130            based           fixed bin(71,0)          level 2 dcl 169 set ref 212* 292
trace                                  based           bit(1)                   level 2 in structure "flags" packed unaligned
                                                                                  dcl 138 in procedure "heals_gen_ioerr_log_" ref
                                                                                  249
trace                                  based           bit(1)                   level 2 in structure "ior_flags" packed unaligned
                                                                                  dcl 2-12 in procedure "heals_gen_ioerr_log_" ref
                                                                                  249
tracks                    2(27)        based           char(2)                  level 2 packed unaligned dcl 149 set ref 339* 341*
                                                                                  343* 364 364* 447
tracks_sector            13(09)        based           picture(2)               level 3 packed unaligned dcl 3-7 set ref 447* 562*
                                                                                  658* 787 787*
unspec                                                 builtin function         dcl 172 ref 703
unused                          001042 automatic       bit(1)                   initial dcl 120 set ref 120* 257*
used                      1            based           bit(1)                   level 2 dcl 155 set ref 230* 593* 881* 893 912*
verify                                                 builtin function         dcl 172 ref 332 771
version_date                    001004 automatic       char(8)                  initial unaligned dcl 83 set ref 83* 249*
version_nb                      001036 automatic       fixed bin(17,0)          initial dcl 115 set ref 115* 249*
whoami                          000776 automatic       char(20)                 initial unaligned dcl 82 set ref 82* 249* 943*
work_ch1                        000155 automatic       char(1)                  unaligned dcl 66 set ref 331* 332
work_p1                         000102 automatic       pointer                  initial dcl 44 set ref 44* 900* 901
work_time                       000142 automatic       char(16)                 unaligned dcl 63 set ref 811* 812 813

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
faultword                              based           structure                level 1 dcl 6-27
iox_$attach_ioname              000000 constant        entry                    external dcl 34
iox_$detach_iocb                000000 constant        entry                    external dcl 36
iox_$iocb_version_sentinel             external static char(4)                  dcl 7-51
page_nb                                automatic       fixed bin(17,0)          dcl 103
special_status                         based           structure                level 1 dcl 6-35
vfile_$vfile_attach             000000 constant        entry                    external dcl 40
vfile_info                             automatic       varying char(168)        array dcl 84

NAMES DECLARED BY EXPLICIT CONTEXT.
attach_rec                      001612 constant        label                    dcl 324 ref 318
bad_disk_rec                    004431 constant        label                    dcl 666 ref 492 498 541 550 556 585 617 637 646 652
bad_ioi_rec                     002463 constant        label                    dcl 466 ref 385 390 402 409 441
bad_name                        005265 constant        label                    dcl 775 ref 770 771
bad_rcp_rec                     002050 constant        label                    dcl 367 ref 314 357
bad_rec                         004725 constant        label                    dcl 714 ref 374 470 672
bulk_rec                        004443 constant        label                    dcl 676 ref 297
clean_up                        006541 constant        entry                    internal dcl 948 ref 191 944
convert_channame_kludge         005206 constant        entry                    internal dcl 763 ref 381 827
disk_addr                       004013 constant        label                    dcl 610 ref 480
disk_detail                     003576 constant        label                    dcl 578 ref 479
disk_err                        002407 constant        label                    dcl 451 ref 437
disk_rec                        002472 constant        label                    dcl 473 ref 296
disk_stat_rtrn                  003107 constant        label                    dcl 524 ref 478
dn355_rec                       004521 constant        label                    dcl 690 ref 298
err_return                      005205 constant        label                    dcl 958 ref 945
get_iom_ch_nb                   006000 constant        entry                    internal dcl 845 ref 372 596 630 671 706
heals_gen_ioerr_log_            000305 constant        entry                    external dcl 6
ineof_1                         005146 constant        label                    dcl 741 ref 275 284 292
ioi_rec                         002070 constant        label                    dcl 378 ref 294 295
iom_rec                         002546 constant        label                    dcl 483 ref 476 477
load_sort_data                  005603 constant        entry                    internal dcl 817 ref 370 414 469 507 529 594 628 670
                                                                                  680 704
mount_rec                       001722 constant        label                    dcl 346 ref 320 321
move_syserr_nfo                 005465 constant        entry                    internal dcl 803 ref 413 506 528 587 619 679 694 714
next_log_rec                    001370 constant        label                    dcl 282 ref 270 299 307 322 326 344 365 464 481 664
                                                                                  688 690 712 739
note_rec                        001626 constant        label                    dcl 328 ref 319
proc_err                        006467 constant        entry                    internal dcl 940 ref 258 278 287 746 794
rcp_rec                         001471 constant        label                    dcl 302 ref 293
rec_id                          001424 constant        label                    dcl 290 ref 279
retrieve_data                   006354 constant        entry                    internal dcl 917 ref 592 627
save_data                       006107 constant        entry                    internal dcl 863 ref 503 524 591 625
tape_err                        002356 constant        label                    dcl 443 ref 432
tape_recs                       001512 constant        label                    dcl 309 ref 305
ur_err                          002427 constant        label                    dcl 456 ref 434 435 436 438
write_disk_rec                  004424 constant        label                    dcl 662 ref 522 576 608 660
write_ioerr_rec                 005273 constant        entry                    internal dcl 781 ref 269 463 662 687 711 738
write_ioi_rec                   002454 constant        label                    dcl 461 set ref 424 449 454 459

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 311 406 485 489 496 498 498 546 552 558 582 614
                                                                                  642 648 654 830 832
binary                                                 builtin function         ref 772
rtrim                                                  builtin function         ref 771

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7472        7532    7300        7502
Length     10070    7300        40         321     172           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
heals_gen_ioerr_log_               1248 external procedure  is an external procedure.  
on unit on line 191                  64 on unit               
on unit on line 260                 102 on unit               
convert_channame_kludge                 internal procedure  shares stack frame of external procedure heals_gen_ioerr_log_.  
write_ioerr_rec                      78 internal procedure  is called by several nonquick procedures.  
move_syserr_nfo                         internal procedure  shares stack frame of external procedure heals_gen_ioerr_log_.  
load_sort_data                          internal procedure  shares stack frame of external procedure heals_gen_ioerr_log_.  
get_iom_ch_nb                           internal procedure  shares stack frame of external procedure heals_gen_ioerr_log_.  
save_data                               internal procedure  shares stack frame of external procedure heals_gen_ioerr_log_.  
retrieve_data                           internal procedure  shares stack frame of external procedure heals_gen_ioerr_log_.  
proc_err                             90 internal procedure  is called by several nonquick procedures.  
clean_up                             72 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 inbuf_len                   heals_gen_ioerr_log_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
heals_gen_ioerr_log_     000100 flags_p                     heals_gen_ioerr_log_
                         000102 work_p1                     heals_gen_ioerr_log_
                         000104 outsw_p                     heals_gen_ioerr_log_
                         000106 sortsw_p                    heals_gen_ioerr_log_
                         000110 inbuf_p                     heals_gen_ioerr_log_
                         000112 sort_desc_p                 heals_gen_ioerr_log_
                         000120 tape_nfo_p                  heals_gen_ioerr_log_
                         000122 sort_data_p                 heals_gen_ioerr_log_
                         000124 syserr_nfo_p                heals_gen_ioerr_log_
                         000126 dev_data_p                  heals_gen_ioerr_log_
                         000130 insw_p                      heals_gen_ioerr_log_
                         000132 rprt_from_time              heals_gen_ioerr_log_
                         000136 rprt_to_time                heals_gen_ioerr_log_
                         000142 work_time                   heals_gen_ioerr_log_
                         000146 ascii_status                heals_gen_ioerr_log_
                         000151 record_name                 heals_gen_ioerr_log_
                         000155 work_ch1                    heals_gen_ioerr_log_
                         000156 ioi_buf                     heals_gen_ioerr_log_
                         000156 bad_rec_buf                 heals_gen_ioerr_log_
                         000156 inbuf                       heals_gen_ioerr_log_
                         000156 disk_buf                    heals_gen_ioerr_log_
                         000156 pic_w                       heals_gen_ioerr_log_
                         000156 misc_buf                    heals_gen_ioerr_log_
                         000160 bad_name                    heals_gen_ioerr_log_
                         000162 dev_nm_chk                  heals_gen_ioerr_log_
                         000163 dev_data_space              heals_gen_ioerr_log_
                         000764 n_a                         heals_gen_ioerr_log_
                         000765 date_time                   heals_gen_ioerr_log_
                         000772 date                        heals_gen_ioerr_log_
                         000774 time                        heals_gen_ioerr_log_
                         000776 whoami                      heals_gen_ioerr_log_
                         001004 version_date                heals_gen_ioerr_log_
                         001006 stream_in                   heals_gen_ioerr_log_
                         001007 stream_out                  heals_gen_ioerr_log_
                         001010 seq_in                      heals_gen_ioerr_log_
                         001011 seq_out                     heals_gen_ioerr_log_
                         001012 status_nb                   heals_gen_ioerr_log_
                         001013 i_code                      heals_gen_ioerr_log_
                         001014 nb_ioerr_recs               heals_gen_ioerr_log_
                         001015 ioerr_rec_min_len           heals_gen_ioerr_log_
                         001016 dev_data_size               heals_gen_ioerr_log_
                         001017 i                           heals_gen_ioerr_log_
                         001020 j                           heals_gen_ioerr_log_
                         001021 k                           heals_gen_ioerr_log_
                         001022 l                           heals_gen_ioerr_log_
                         001023 ndx                         heals_gen_ioerr_log_
                         001024 offs_ndx                    heals_gen_ioerr_log_
                         001025 ss                          heals_gen_ioerr_log_
                         001026 iom_nb_chk                  heals_gen_ioerr_log_
                         001027 ch_nb_chk                   heals_gen_ioerr_log_
                         001030 dev_nb_chk                  heals_gen_ioerr_log_
                         001031 fake_data_size              heals_gen_ioerr_log_
                         001032 save_size                   heals_gen_ioerr_log_
                         001033 code                        heals_gen_ioerr_log_
                         001034 inrec_len                   heals_gen_ioerr_log_
                         001035 outrec_len                  heals_gen_ioerr_log_
                         001036 version_nb                  heals_gen_ioerr_log_
                         001040 clock_time                  heals_gen_ioerr_log_
                         001042 unused                      heals_gen_ioerr_log_
                         001043 flags_word                  heals_gen_ioerr_log_
                         001044 found                       heals_gen_ioerr_log_
                         001045 ntrpt_nm_list               heals_gen_ioerr_log_
                         001055 tape_nfo_ar                 heals_gen_ioerr_log_
                         001056 fake_data                   heals_gen_ioerr_log_
                         001074 heals_arg_info              heals_gen_ioerr_log_
                         001226 ch_nfo_p                    heals_gen_ioerr_log_
                         001230 ioerr_rec_p                 heals_gen_ioerr_log_
                         001232 heals_message_p             heals_gen_ioerr_log_
                         001234 io_msgp                     heals_gen_ioerr_log_
                         001236 statp                       heals_gen_ioerr_log_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_var            call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              tra_ext             alloc_auto_adj      bound_check_signal  mpfx2
enable              shorten_stack       ext_entry           int_entry           set_cs_eis          index_cs_eis
any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      cv_oct_                       date_time_
ioa_                          ioa_$rsnnl                    iox_$close                    iox_$open
iox_$read_record              iox_$write_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000301        43 000312        44 000314        45 000315        46 000316        47 000317        48 000320
     49 000343        50 000344        51 000345        52 000346        54 000347        67 000350        68 000357
     69 000366        70 000375        71 000404        76 000413        82 000415        83 000423        90 000425
     91 000427        92 000431        93 000433       115 000435       120 000437       121 000440       126 000441
    129 000503       132 000524       191 000533       194 000555       197 000557       198 000561       199 000565
    200 000567       201 000573       204 000575       205 000605       206 000607       209 000611       210 000612
    211 000614       212 000631       213 000651       215 000652       216 000654       217 000656       218 000700
    219 000702       220 000704       221 000726       222 000730       223 000732       224 000754       225 000756
    226 000760       228 001002       229 001004       230 001006       231 001007       232 001013       234 001015
    235 001031       236 001045       237 001056       238 001071       239 001073       245 001075       246 001104
    247 001121       248 001124       249 001130       257 001200       258 001215       260 001227       261 001243
    262 001247       263 001252       266 001312       267 001317       268 001321       269 001323       270 001330
    274 001333       275 001352       278 001357       279 001367       282 001370       284 001407       287 001414
    290 001424       292 001427       293 001440       294 001443       295 001447       296 001454       297 001460
    298 001463       299 001470       302 001471       304 001474       305 001476       307 001511       309 001512
    311 001514       312 001526       313 001540       314 001542       316 001543       318 001554       319 001564
    320 001573       321 001602       322 001611       324 001612       326 001625       328 001626       330 001635
    331 001636       332 001642       333 001652       335 001660       336 001664       337 001665       339 001670
    341 001703       343 001716       344 001721       346 001722       349 001734       351 001746       353 001750
    354 001760       355 001776       356 002000       357 002003       359 002004       361 002012       363 002016
    364 002032       365 002047       367 002050       369 002052       370 002054       371 002055       372 002060
    373 002061       374 002067       378 002070       380 002073       381 002102       382 002114       383 002126
    384 002131       385 002133       387 002134       388 002144       389 002147       390 002151       392 002152
    395 002160       396 002174       398 002206       400 002214       401 002217       402 002221       405 002222
    406 002226       407 002232       408 002241       409 002244       412 002245       413 002247       414 002250
    419 002251       420 002254       421 002260       422 002262       423 002276       424 002301       428 002302
    429 002306       431 002316       432 002320       434 002324       435 002330       436 002334       437 002340
    438 002344       439 002350       440 002353       441 002355       443 002356       445 002372       446 002375
    447 002400       448 002403       449 002406       451 002407       453 002423       454 002426       456 002427
    458 002443       459 002453       461 002454       463 002456       464 002462       466 002463       468 002465
    469 002470       470 002471       473 002472       475 002475       476 002477       477 002511       478 002520
    479 002527       480 002536       481 002545       483 002546       485 002555       486 002571       487 002601
    488 002604       489 002622       491 002640       492 002641       494 002642       495 002652       496 002670
    498 002706       502 002744       503 002747       504 002750       506 002752       507 002753       508 002754
    509 002762       510 002767       511 002774       512 002777       513 003013       514 003015       515 003030
    516 003050       517 003057       518 003072       520 003102       521 003104       522 003106       524 003107
    527 003114       528 003116       529 003117       530 003120       532 003134       533 003145       535 003151
    538 003201       539 003203       540 003204       541 003222       542 003224       543 003234       544 003253
    545 003263       546 003264       548 003302       549 003315       550 003333       551 003335       552 003345
    554 003360       555 003370       556 003406       557 003410       558 003421       560 003434       561 003445
    562 003455       565 003461       568 003504       569 003515       570 003523       572 003570       573 003573
    576 003575       578 003576       580 003605       581 003610       582 003626       584 003644       585 003645
    587 003646       588 003647       589 003652       591 003666       592 003672       593 003673       594 003677
    595 003700       596 003702       597 003703       599 003711       601 003715       602 003717       603 003733
    604 003740       606 004005       607 004010       608 004012       610 004013       612 004022       613 004025
    614 004043       616 004061       617 004062       619 004063       620 004064       621 004067       623 004103
    624 004106       625 004110       627 004111       628 004112       629 004113       630 004115       631 004116
    633 004124       635 004130       636 004143       637 004161       638 004163       639 004173       640 004213
    641 004223       642 004224       644 004242       645 004255       646 004273       647 004275       648 004305
    650 004320       651 004330       652 004346       653 004350       654 004361       656 004374       657 004405
    658 004415       659 004421       660 004423       662 004424       664 004430       666 004431       668 004433
    669 004436       670 004440       671 004441       672 004442       676 004443       678 004446       679 004450
    680 004451       681 004452       682 004463       683 004466       684 004471       685 004510       686 004512
    687 004514       688 004520       690 004521       692 004532       693 004535       694 004537       695 004540
    696 004555       697 004570       698 004572       699 004620       700 004632       702 004640       703 004655
    704 004660       705 004661       706 004664       707 004665       708 004672       709 004706       710 004716
    711 004720       712 004724       714 004725       716 004726       718 004735       719 004740       720 004742
    724 005013       725 005021       727 005027       728 005032       731 005071       732 005072       735 005131
    736 005135       737 005137       738 005141       739 005145       741 005146       743 005147       743 005151
    745 005156       746 005172       801 005204       958 005205       763 005206       769 005210       770 005222
    771 005224       772 005247       773 005264       775 005265       777 005271       781 005272       782 005300
    784 005304       785 005322       786 005337       787 005353       790 005367       791 005370       792 005377
    793 005406       794 005422       795 005436       796 005441       797 005464       803 005465       804 005466
    805 005471       806 005476       807 005502       808 005504       811 005550       812 005572       813 005576
    814 005602       817 005603       818 005604       819 005605       820 005612       821 005614       822 005642
    825 005644       826 005646       827 005650       828 005662       829 005670       830 005675       831 005704
    832 005713       833 005716       835 005721       836 005726       837 005736       838 005743       839 005750
    840 005755       841 005772       842 005777       845 006000       846 006001       847 006002       848 006003
    849 006021       850 006037       852 006061       853 006067       854 006074       856 006076       857 006100
    859 006102       860 006106       863 006107       864 006110       865 006111       866 006112       867 006120
    868 006122       870 006123       873 006127       874 006131       875 006141       879 006171       880 006217
    881 006221       882 006223       884 006224       885 006231       888 006232       889 006234       890 006236
    891 006237       892 006245       893 006246       894 006253       895 006260       898 006261       900 006266
    901 006272       902 006274       903 006276       904 006277       906 006301       907 006303       908 006311
    909 006315       910 006322       911 006324       912 006351       914 006353       917 006354       918 006355
    919 006356       920 006360       921 006361       922 006371       925 006402       926 006410       927 006415
    928 006417       929 006445       931 006447       932 006455       933 006456       933 006460       934 006462
    936 006465       940 006466       942 006474       943 006500       944 006530       945 006535       948 006540
    949 006546       950 006553       952 006570       955 006606


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
