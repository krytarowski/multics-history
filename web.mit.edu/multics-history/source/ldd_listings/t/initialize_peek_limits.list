	COMPILATION LISTING OF SEGMENT initialize_peek_limits
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1542.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 initialize_peek_limits:  proc;
       12 		     
       13 /* Program to define regions of hardcore which can be accessed
       14*   via metering_ring_zero_peek_.  The latter is a ring-1 gate
       15*   which calls a routine to "filter" ring_zero_peek_ requests for
       16*   users who do not have access to phcs_ (of course, such users must
       17*   have access to metering_ring_zero_peek_).  
       18*
       19*   This program builds a table of accessible regions from an ASCII
       20*   segment.  This table resides in >sl1>ring_zero_meter_limits.table.
       21*   This program should be run as part of system_start_up.ec.  Until it
       22*   runs, no hardcore area is available via metering_ring_zero_peek_.
       23*
       24*   Command call sequence:
       25*
       26*          initialize_peek_limits <pathname>
       27*
       28*   where <pathname> is the path name of the ASCII segment.  Normally,
       29*   <pathname> is >system_library_1>ring_zero_meter_limits.ascii, which
       30*   is loaded from Collection 3; however, it can be site-supplied.
       31*
       32*   The format of the ASCII segment is as follows.  There is a statement 
       33*   for each hardcore region, in one of the following forms:
       34*
       35*     <segment> : <begin> <length>;
       36*
       37*     <segment> : <begin> <end>;
       38*
       39*     <segment> : <end>;
       40*     
       41*     <segment> : <length>;
       42*     
       43*     <segment> : ;
       44*
       45*   where
       46*
       47*          <segment> is either the name of a hardcore segment or a hardcore
       48*                    segment number
       49*          <begin>   is either an offset into the segment (decimal) which is
       50*                    the first word of an accessible region, or the name of
       51*                    an externally accessible symbol in the segment which 
       52*                    represents the first word of an accessible region
       53*          <length>  is the length of the accessible region in words
       54*          <end>     is the name of an externally accessible symbol in the segment which
       55*                    represents the first word beyond the end of the accessible
       56*                    region.
       57*          
       58*   If <begin> is not supplied, the accessible region is assumed to begin at offset
       59*   0 within the segment.  If only <segment> is supplied, the accessible region is
       60*   the entire segment.
       61*
       62*   Written December 80 by J. Bongiovanni
       63*
       64**/
       65 
       66 /**/   	
       67 
       68 /* Automatic */
       69 
       70 dcl abs_filename char (168);
       71 dcl any_parse bit (1);
       72 dcl bc fixed bin (24);
       73 dcl begin_offset fixed bin (18);
       74 dcl code fixed bin (35);
       75 dcl delim_type fixed bin;
       76 dcl dirname char (168);
       77 dcl end_offset fixed bin (18);
       78 dcl entryname char (32);
       79 dcl field_ptr ptr;
       80 dcl field_l fixed bin (21);
       81 dcl field_type fixed bin;
       82 dcl filename_l fixed bin (21);
       83 dcl filename_p ptr;
       84 dcl file_l fixed bin (21);
       85 dcl file_ptr ptr;
       86 dcl high_seg fixed bin;
       87 dcl ignore bit (1);
       88 dcl low_seg fixed bin;
       89 dcl marrayp ptr;
       90 dcl nargs fixed bin;
       91 dcl one_begin bit (1);
       92 dcl one_seg bit (1);
       93 dcl rcode fixed bin (35);
       94 dcl seg_no fixed bin;
       95 dcl seg_ptr ptr;
       96 dcl type fixed bin;
       97 	
       98 /* Static */
       99 
      100 dcl LIMITSEG_DIR char (17) init (">system_library_1") int static options (constant);
      101 dcl LIMITSEG_NAME char (28) init ("ring_zero_meter_limits.table");
      102 dcl MAX_OFFSET fixed bin (19) init (262143) int static options (constant);
      103 dcl my_name char (22) init ("initialize_peek_limits") int static options (constant);
      104 dcl (NUMERIC init (0), NON_NUMERIC init (1)) fixed bin int static options (constant);
      105 dcl (SEMI init (1), COLON init (2), WHITE_SPACE init (3),
      106 	END_OF_SCAN init (4)) fixed bin int static options (constant);
      107 
      108 /* Based */
      109 
      110 dcl field char (field_l) based (field_ptr);
      111 dcl filename char (filename_l) based (filename_p);
      112 
  1     1 /*  START OF:	meter_limits.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Table of metering limits for filtering metering_ring_zero_peek_
  1     4*   requests.										
  1     5*
  1     6*   Written December 1980 by J. Bongiovanni							*/
  1     7 	
  1     8 	
  1     9 dcl mtablep ptr;
  1    10 dcl mentryp ptr;
  1    11 	
  1    12 dcl 1 meter_limits_table aligned based (mtablep),		/* table header				*/
  1    13     2 initialized bit (1),				/* on=>table is valid			*/
  1    14     2 high_seg_no fixed bin,				/* highest segment number in table		*/
  1    15     2 thread_head (0:0 refer (high_seg_no)) fixed bin (18); /* begin thread of entries this segment		*/
  1    16 	
  1    17 dcl 1 meter_limits_entry aligned based (mentryp),		/* defines a region which can be accessed	*/
  1    18     2 thread fixed bin (18),				/* next entry this segment (0=>none)		*/
  1    19     2 begin_offset fixed bin (18) unsigned unal,		/* begin word of accessible region		*/
  1    20     2 end_offset fixed bin (18) unsigned unal;		/* last word of accessible region		*/
  1    21 	
  1    22 
  1    23 
  1    24 /*  END OF:	meter_limits.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      114 
      115 dcl 1 meter_limits_array (0:1) aligned based (marrayp) like meter_limits_entry;
      116 
      117 /* Entry */
      118 
      119 dcl com_err_ entry options (variable);
      120 dcl cu_$arg_count entry (fixed bin);
      121 dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
      122 dcl expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
      123 dcl get_temp_segment_ entry (char(*), ptr, fixed bin(35));
      124 dcl hcs_$high_low_seg_count entry (fixed bin, fixed bin);
      125 dcl hcs_$initiate_count entry (char(*), char(*), char(*), fixed bin(24), fixed bin(2), ptr, fixed bin(35));
      126 dcl hcs_$terminate_noname entry (ptr, fixed bin(35));
      127 dcl installation_tools_$patch_path entry (char(*), char(*), fixed bin (18),
      128      ptr, fixed bin (18), fixed bin (35));
      129 dcl release_temp_segment_ entry (char(*), ptr, fixed bin(35));
      130 dcl ring0_get_$definition entry (ptr, char(*), char(*), fixed bin(18), fixed bin, fixed bin (35));
      131 dcl ring0_get_$segptr entry (char(*), char(*), ptr, fixed bin (35));
      132 
      133 
      134 /* External */
      135 
      136 dcl error_table_$badsyntax fixed bin (35) external;
      137 dcl error_table_$segknown fixed bin (35) external;
      138 dcl error_table_$zero_length_seg fixed bin (35) external;
      139 
      140 /* Condition */
      141 
      142 dcl cleanup condition;
      143 dcl size condition;
      144 
      145 /* Builtin */
      146 
      147 dcl addr builtin;
      148 dcl baseno builtin;
      149 dcl baseptr builtin;
      150 dcl bin builtin;
      151 dcl currentsize builtin;
      152 dcl divide builtin;
      153 dcl fixed builtin;
      154 dcl index builtin;
      155 dcl null builtin;
      156 dcl ptr builtin;
      157 dcl rel builtin;
      158 dcl rtrim builtin;
      159 dcl search builtin;
      160 dcl verify builtin;
      161 
      162 
      163 /**/
      164 code = 0;
      165 file_ptr, mtablep = null();
      166 
      167 on cleanup call Mr_Clean;
      168 
      169 call get_temp_segment_ (my_name, mtablep, code);
      170 if code^=0 then call Complain ("Cannot get temp segment");
      171 meter_limits_table.initialized = "1"b;
      172 
      173 call hcs_$high_low_seg_count (high_seg, low_seg);
      174 meter_limits_table.high_seg_no = low_seg - 1;		/* highest supervisor seg number		*/
      175 marrayp = ptr (mtablep, currentsize (meter_limits_table));	/* first allocatable entry			*/
      176 
      177 
      178 call cu_$arg_count (nargs);
      179 if nargs^=1 then
      180      call Complain ("Usage is:   initialize_peek_limits <pathname of source>");
      181 call cu_$arg_ptr (1, filename_p, filename_l, code);
      182 
      183 call expand_pathname_ (filename, dirname, entryname, code);
      184 if code^=0 then call Complain (filename);
      185 abs_filename = rtrim (dirname) || ">" || rtrim (entryname);
      186 
      187 call hcs_$initiate_count (dirname, entryname, "", bc, 0, file_ptr, code);
      188 if code^=0&code^=error_table_$segknown
      189      then call Complain (abs_filename);
      190 if bc=0 then do;
      191      code = error_table_$zero_length_seg;
      192      call Complain (abs_filename);
      193 end;
      194 
      195 file_l = divide (bc, 9, 21);
      196 
      197 /*  */
      198 /* romp through input file and build table of allowable peek regions					*/
      199 
      200 delim_type = 0;
      201 seg_no = -1;
      202 begin_offset = 0;
      203 end_offset = MAX_OFFSET;
      204 any_parse, one_seg, one_begin, ignore = "0"b;
      205 on size goto syntax_error;
      206 
      207 do while (delim_type^=END_OF_SCAN);
      208      call next_field (file_ptr, file_l, field_ptr, field_l, delim_type, field_type);
      209      if delim_type = COLON then do;			/* field is segment name or number		*/
      210 	if^ignore then do;
      211 	     any_parse = "1"b;
      212 	     if one_seg then do;			/* already have segment name or number		*/
      213 syntax_error:	code = error_table_$badsyntax;
      214 		call Complain (abs_filename);
      215 	     end;
      216 	     if field_type = NUMERIC
      217 		then seg_no = fixed (field, 17);
      218 	     else do;
      219 		call ring0_get_$segptr ("", field, seg_ptr, rcode);
      220 		if rcode^=0 then do;
      221 		     call com_err_ (0, my_name, "Segment ^a not found.", field);
      222 		     ignore = "1"b;
      223 		end;
      224 		seg_no = bin (baseno (seg_ptr), 17);
      225 	     end;
      226 	     one_seg = "1"b;
      227 	end;
      228      end;
      229      else if delim_type = WHITE_SPACE then do;	/* begin offset or symbol			*/
      230 	if ^ignore then do;
      231 	     any_parse = "1"b;
      232 	     if one_begin then goto syntax_error;
      233 	     if seg_no = -1 then goto syntax_error;
      234 	     if field_type = NUMERIC then begin_offset = fixed (field, 18);
      235 	     else do;
      236 		call ring0_get_$definition (baseptr (seg_no), "", 
      237 		     field, begin_offset, type, rcode);
      238 		if rcode^=0 then do;
      239 		     call com_err_ (0, my_name, "Symbol ^a not found.",
      240 			field);
      241 		     ignore = "1"b;
      242 	          end;
      243 	     end;
      244 	     one_begin = "1"b;
      245 	end;
      246      end;
      247      else if delim_type = SEMI then do;		/* end symbol or length			*/
      248 	if ^ignore then do;
      249 	     if seg_no = -1 then goto syntax_error;
      250 	     if field^="" then do;		/* no end or length => whole segment accessible	*/
      251 		if field_type=NUMERIC then do;
      252 		     if fixed (field, 18)>= MAX_OFFSET+1 then goto syntax_error;
      253 		     end_offset = begin_offset + fixed (field) -1;
      254 		end;
      255 		else do;
      256 		     call ring0_get_$definition (baseptr (seg_no),
      257 			"", field, end_offset, type, rcode);
      258 		     if rcode^=0 then do;
      259 			call com_err_ (0, my_name, "Symbol ^a not found.",
      260 			     field);
      261 			ignore = "1"b;
      262 		     end;
      263 		     end_offset = end_offset - 1;
      264 		end;
      265 	     end;
      266 	end;
      267 	if ^ignore then do;
      268 	     if seg_no<0 | seg_no>meter_limits_table.high_seg_no
      269 		then goto syntax_error;
      270 	     if begin_offset>end_offset then goto syntax_error;
      271 	     mentryp = marrayp;
      272 	     meter_limits_entry.thread = meter_limits_table.thread_head (seg_no);
      273 	     meter_limits_entry.begin_offset = begin_offset;
      274 	     meter_limits_entry.end_offset = end_offset;
      275 	     meter_limits_table.thread_head (seg_no) = fixed (rel (mentryp));
      276 	     marrayp = addr (meter_limits_array (1));/* point to next free			*/
      277 	end;
      278 	
      279 	ignore, any_parse, one_seg, one_begin = "0"b;
      280 	begin_offset = 0;
      281 	end_offset = MAX_OFFSET;
      282      end;
      283      else if any_parse then goto syntax_error;	/* end of text in middle of statement		*/
      284 end;
      285 
      286 revert size;
      287 
      288 call installation_tools_$patch_path (LIMITSEG_DIR, LIMITSEG_NAME, 0,
      289      mtablep, bin (rel (marrayp), 18), code);
      290 if code^=0 then call Complain ("Cannot copy into " || rtrim (LIMITSEG_DIR)
      291      || ">" || rtrim (LIMITSEG_NAME));
      292 
      293 call Mr_Clean;
      294 
      295 
      296 EXIT:
      297 return;
      298 
      299 /**/
      300 /* Internal procedure to print an error message and terminate */
      301 
      302 Complain:
      303      proc (why);
      304      
      305 
      306 dcl why char (*);
      307      
      308 call com_err_ (code, my_name, why);
      309 goto EXIT;
      310 
      311 end Complain;
      312 
      313 
      314 /* Internal procedure to clean up before quitting (normal or otherwise */
      315 
      316 Mr_Clean:
      317      proc;
      318      
      319 dcl acode fixed bin (35);
      320      
      321 if file_ptr^=null() 
      322      then call hcs_$terminate_noname (file_ptr, acode);
      323 if mtablep^=null() 
      324      then call release_temp_segment_ (my_name, mtablep, acode);
      325 
      326 
      327 end Mr_Clean;
      328 
      329 
      330 /* */
      331 /* Internal procedure to scan a text for the next field, return
      332*   that field, and an indication of the delimeter following
      333*   the field.  Additionally, the text pointers are updated
      334*   for the next call.  In this scan, PL1-type comments
      335*   are bypassed										*/
      336 
      337 next_field:
      338           proc (scan_ptr, scan_len, field_ptr, field_len, del_type, field_type);
      339 		
      340 dcl scan_ptr ptr;					/* pointer to start of text			*/
      341 dcl scan_len fixed bin (21);				/* length of text				*/
      342 dcl field_ptr ptr;					/* pointer to start of field			*/
      343 dcl field_len fixed bin (21);				/* length of field				*/
      344 dcl del_type fixed bin;				/* indicates delimeter following field		*/
      345 dcl field_type fixed bin;				/* indicates numeric or non-numeric		*/
      346 	
      347 	
      348 
      349 dcl l fixed bin;
      350 	
      351 dcl DELIM char (5) init (" 
      352 	:;") int static options (constant);		/* space, NL, TAB, :, ;			*/
      353 dcl WS_DELIM char (3) init (" 
      354 	") int static options (constant);		/* space, NL, TAB				*/
      355 
      356 dcl field char (field_len) based (field_ptr);
      357 dcl next_1 char (1) based (scan_ptr);
      358 dcl next_2 char (2) based (scan_ptr);
      359 dcl scan char (scan_len) based (scan_ptr);
      360 dcl scan_array (scan_len) char (1) based (scan_ptr);
      361 	
      362 
      363 if scan_len<=0 then do;
      364 zero_length:
      365      delim_type = END_OF_SCAN;
      366      return;
      367 end;
      368 if ^remove_white_space() then goto zero_length;		/* ran out of text				*/
      369 
      370 field_ptr = scan_ptr;
      371 l = search (scan, DELIM);				/* look for delimeter after field		*/
      372 if l=0 then field_len = scan_len;			/* text ends with this field			*/
      373 else field_len = l-1;
      374 scan_ptr = addr (scan_array (field_len+1));		/* next place to look for field		*/
      375 scan_len = scan_len - field_len;			/* remaining chars in text			*/
      376 
      377 if ^remove_white_space()				/* only white space remaining in text		*/
      378      then del_type = WHITE_SPACE;
      379 else if next_1=";" then del_type = SEMI;
      380 else if next_1=":" then del_type = COLON;
      381 else del_type = WHITE_SPACE;
      382 
      383 if del_type^=WHITE_SPACE then do;				/* bump pointer past delimeter		*/
      384      scan_ptr = addr (scan_array (2));
      385      scan_len = scan_len - 1;
      386 end;
      387 
      388 if verify (field, "0123456789") = 0
      389      then field_type = NUMERIC;
      390 else field_type = NON_NUMERIC;
      391 
      392 
      393 return;
      394 
      395 
      396 
      397 /* Internal procedure to next_field which removes white space
      398*   by adjusting scan_ptr and scan_len to skip over such.
      399*   PL1-type comments are also bypassed here.  A bit(1) value
      400*   is returned to indicate end of text - "0"b for end-of-text,
      401*   "1"b otherwise										*/
      402 
      403 remove_white_space:
      404           proc returns (bit (1));
      405 	
      406 dcl l fixed bin (21);
      407 	
      408 
      409 
      410 do while ("1"b);
      411      if scan_len<=0 then do;				/* no text left--easy case			*/
      412 return_empty:
      413 	scan_ptr = addr (scan_array (scan_len + 1));
      414 	scan_len = 0;				/* set end of text				*/
      415 	return ("0"b);
      416      end;
      417 
      418      l = verify (scan, WS_DELIM);
      419      if l=0 then goto return_empty;			/* ran out of text				*/
      420      scan_ptr = addr (scan_array (l));			/* point to first non-delimeter		*/
      421      scan_len = scan_len-l+1;
      422      if next_2="/*" then do;                               /* PL1-type comment				*/
      423 	l = index (scan, "*/");			/* end of comment				*/
      424 	if l=0 then return ("0"b);			/* no end of comment			*/
      425 	scan_ptr = addr (scan_array (l+2));		/* point to 1st character past end of comment	*/
      426 	scan_len = scan_len-l-1;
      427      end;
      428      else return ("1"b);
      429 end;
      430 
      431 end remove_white_space;
      432 
      433 
      434 end next_field;
      435 
      436 end initialize_peek_limits;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1455.8  initialize_peek_limits.pl1        >dumps>old>recomp>initialize_peek_limits.pl1
113          1    03/18/81  2207.1  meter_limits.incl.pl1             >ldd>include>meter_limits.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COLON                                  constant        fixed bin(17,0)          initial dcl 105 ref 209 380
DELIM                           000002 constant        char(5)                  initial unaligned dcl 351 ref 371
END_OF_SCAN                            constant        fixed bin(17,0)          initial dcl 105 ref 207 364
LIMITSEG_DIR                    000012 constant        char(17)                 initial unaligned dcl 100 set ref 288* 290
LIMITSEG_NAME                   000275 automatic       char(28)                 initial unaligned dcl 101 set ref 101* 288* 290
MAX_OFFSET                             constant        fixed bin(19,0)          initial dcl 102 ref 203 252 281
NON_NUMERIC                            constant        fixed bin(17,0)          initial dcl 104 ref 390
NUMERIC                                constant        fixed bin(17,0)          initial dcl 104 ref 216 234 251 388
SEMI                                   constant        fixed bin(17,0)          initial dcl 105 ref 247 379
WHITE_SPACE                            constant        fixed bin(17,0)          initial dcl 105 ref 229 377 381 383
WS_DELIM                        000000 constant        char(3)                  initial unaligned dcl 353 ref 418
abs_filename                    000100 automatic       char(168)                unaligned dcl 70 set ref 185* 188* 192* 214*
acode                           000100 automatic       fixed bin(35,0)          dcl 319 set ref 321* 323*
addr                                                   builtin function         dcl 147 ref 276 374 384 412 420 425
any_parse                       000152 automatic       bit(1)                   unaligned dcl 71 set ref 204* 211* 231* 279* 283
baseno                                                 builtin function         dcl 148 ref 224
baseptr                                                builtin function         dcl 149 ref 236 236 256 256
bc                              000153 automatic       fixed bin(24,0)          dcl 72 set ref 187* 190 195
begin_offset                    000154 automatic       fixed bin(18,0)          dcl 73 in procedure "initialize_peek_limits" set ref
                                                                                  202* 234* 236* 253 270 273 280*
begin_offset              1            based           fixed bin(18,0)          level 2 in structure "meter_limits_entry" packed
                                                                                  unsigned unaligned dcl 1-17 in procedure
                                                                                  "initialize_peek_limits" set ref 273*
bin                                                    builtin function         dcl 150 ref 224 288 288
cleanup                         000310 stack reference condition                dcl 142 ref 167
code                            000155 automatic       fixed bin(35,0)          dcl 74 set ref 164* 169* 170 181* 183* 184 187* 188
                                                                                  188 191* 213* 288* 290 308*
com_err_                        000010 constant        entry                    external dcl 119 ref 221 239 259 308
cu_$arg_count                   000012 constant        entry                    external dcl 120 ref 178
cu_$arg_ptr                     000014 constant        entry                    external dcl 121 ref 181
currentsize                                            builtin function         dcl 151 ref 175
del_type                               parameter       fixed bin(17,0)          dcl 344 set ref 337 377* 379* 380* 381* 383
delim_type                      000156 automatic       fixed bin(17,0)          dcl 75 set ref 200* 207 208* 209 229 247 364*
dirname                         000157 automatic       char(168)                unaligned dcl 76 set ref 183* 185 187*
divide                                                 builtin function         dcl 152 ref 195
end_offset                      000231 automatic       fixed bin(18,0)          dcl 77 in procedure "initialize_peek_limits" set ref
                                                                                  203* 253* 256* 263* 263 270 274 281*
end_offset                1(18)        based           fixed bin(18,0)          level 2 in structure "meter_limits_entry" packed
                                                                                  unsigned unaligned dcl 1-17 in procedure
                                                                                  "initialize_peek_limits" set ref 274*
entryname                       000232 automatic       char(32)                 unaligned dcl 78 set ref 183* 185 187*
error_table_$badsyntax          000040 external static fixed bin(35,0)          dcl 136 ref 213
error_table_$segknown           000042 external static fixed bin(35,0)          dcl 137 ref 188
error_table_$zero_length_seg    000044 external static fixed bin(35,0)          dcl 138 ref 191
expand_pathname_                000016 constant        entry                    external dcl 122 ref 183
field                                  based           char                     unaligned dcl 356 in procedure "next_field" ref 388
field                                  based           char                     unaligned dcl 110 in procedure
                                                                                  "initialize_peek_limits" set ref 216 219* 221* 234
                                                                                  236* 239* 250 252 253 256* 259*
field_l                         000244 automatic       fixed bin(21,0)          dcl 80 set ref 208* 216 219 219 221 221 234 236 236
                                                                                  239 239 250 252 253 256 256 259 259
field_len                              parameter       fixed bin(21,0)          dcl 343 set ref 337 372* 373* 374 375 388
field_ptr                       000242 automatic       pointer                  dcl 79 in procedure "initialize_peek_limits" set ref
                                                                                  208* 216 219 221 234 236 239 250 252 253 256 259
field_ptr                              parameter       pointer                  dcl 342 in procedure "next_field" set ref 337 370*
                                                                                  388
field_type                      000245 automatic       fixed bin(17,0)          dcl 81 in procedure "initialize_peek_limits" set ref
                                                                                  208* 216 234 251
field_type                             parameter       fixed bin(17,0)          dcl 345 in procedure "next_field" set ref 337 388*
                                                                                  390*
file_l                          000252 automatic       fixed bin(21,0)          dcl 84 set ref 195* 208*
file_ptr                        000254 automatic       pointer                  dcl 85 set ref 165* 187* 208* 321 321*
filename                               based           char                     unaligned dcl 111 set ref 183* 184*
filename_l                      000246 automatic       fixed bin(21,0)          dcl 82 set ref 181* 183 183 184 184
filename_p                      000250 automatic       pointer                  dcl 83 set ref 181* 183 184
fixed                                                  builtin function         dcl 153 ref 216 234 252 253 275
get_temp_segment_               000020 constant        entry                    external dcl 123 ref 169
hcs_$high_low_seg_count         000022 constant        entry                    external dcl 124 ref 173
hcs_$initiate_count             000024 constant        entry                    external dcl 125 ref 187
hcs_$terminate_noname           000026 constant        entry                    external dcl 126 ref 321
high_seg                        000256 automatic       fixed bin(17,0)          dcl 86 set ref 173*
high_seg_no               1            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 174* 175 268
ignore                          000257 automatic       bit(1)                   unaligned dcl 87 set ref 204* 210 222* 230 241* 248
                                                                                  261* 267 279*
index                                                  builtin function         dcl 154 ref 423
initialized                            based           bit(1)                   level 2 dcl 1-12 set ref 171*
installation_tools_$patch_path  000030 constant        entry                    external dcl 127 ref 288
l                               000342 automatic       fixed bin(21,0)          dcl 406 in procedure "remove_white_space" set ref
                                                                                  418* 419 420 421 423* 424 425 426
l                               000332 automatic       fixed bin(17,0)          dcl 349 in procedure "next_field" set ref 371* 372
                                                                                  373
low_seg                         000260 automatic       fixed bin(17,0)          dcl 88 set ref 173* 174
marrayp                         000262 automatic       pointer                  dcl 89 set ref 175* 271 276* 276 288 288
mentryp                         000306 automatic       pointer                  dcl 1-10 set ref 271* 272 273 274 275
meter_limits_array                     based           structure                array level 1 dcl 115 set ref 276
meter_limits_entry                     based           structure                level 1 dcl 1-17
meter_limits_table                     based           structure                level 1 dcl 1-12 set ref 175
mtablep                         000304 automatic       pointer                  dcl 1-9 set ref 165* 169* 171 174 175 175 268 272
                                                                                  275 288* 323 323*
my_name                         000004 constant        char(22)                 initial unaligned dcl 103 set ref 169* 221* 239*
                                                                                  259* 308* 323*
nargs                           000264 automatic       fixed bin(17,0)          dcl 90 set ref 178* 179
next_1                                 based           char(1)                  unaligned dcl 357 ref 379 380
next_2                                 based           char(2)                  unaligned dcl 358 ref 422
null                                                   builtin function         dcl 155 ref 165 321 323
one_begin                       000265 automatic       bit(1)                   unaligned dcl 91 set ref 204* 232 244* 279*
one_seg                         000266 automatic       bit(1)                   unaligned dcl 92 set ref 204* 212 226* 279*
ptr                                                    builtin function         dcl 156 ref 175
rcode                           000267 automatic       fixed bin(35,0)          dcl 93 set ref 219* 220 236* 238 256* 258
rel                                                    builtin function         dcl 157 ref 275 288 288
release_temp_segment_           000032 constant        entry                    external dcl 129 ref 323
ring0_get_$definition           000034 constant        entry                    external dcl 130 ref 236 256
ring0_get_$segptr               000036 constant        entry                    external dcl 131 ref 219
rtrim                                                  builtin function         dcl 158 ref 185 185 290 290
scan                                   based           char                     unaligned dcl 359 ref 371 418 423
scan_array                             based           char(1)                  array unaligned dcl 360 set ref 374 384 412 420 425
scan_len                               parameter       fixed bin(21,0)          dcl 341 set ref 337 363 371 372 375* 375 385* 385
                                                                                  411 412 414* 418 421* 421 423 426* 426
scan_ptr                               parameter       pointer                  dcl 340 set ref 337 370 371 374* 374 379 380 384*
                                                                                  384 412* 412 418 420* 420 422 423 425* 425
search                                                 builtin function         dcl 159 ref 371
seg_no                          000270 automatic       fixed bin(17,0)          dcl 94 set ref 201* 216* 224* 233 236 236 249 256
                                                                                  256 268 268 272 275
seg_ptr                         000272 automatic       pointer                  dcl 95 set ref 219* 224
size                            000316 stack reference condition                dcl 143 ref 205 286
thread                                 based           fixed bin(18,0)          level 2 dcl 1-17 set ref 272*
thread_head               2            based           fixed bin(18,0)          array level 2 dcl 1-12 set ref 272 275*
type                            000274 automatic       fixed bin(17,0)          dcl 96 set ref 236* 256*
verify                                                 builtin function         dcl 160 ref 388 418
why                                    parameter       char                     unaligned dcl 306 set ref 302 308*

NAMES DECLARED BY EXPLICIT CONTEXT.
Complain                        001507 constant        entry                    internal dcl 302 ref 170 179 184 188 192 214 290
EXIT                            001505 constant        label                    dcl 296 ref 309
Mr_Clean                        001550 constant        entry                    internal dcl 316 ref 167 293
initialize_peek_limits          000137 constant        entry                    external dcl 11
next_field                      001621 constant        entry                    internal dcl 337 ref 208
remove_white_space              001763 constant        entry                    internal dcl 403 ref 368 377
return_empty                    001770 constant        label                    dcl 412 ref 419
syntax_error                    000610 constant        label                    dcl 213 ref 205 232 233 249 252 268 270 283
zero_length                     001625 constant        label                    dcl 364 ref 368

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3172        3240    2727        3202
Length      3462    2727        46         205     242           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
initialize_peek_limits              466 external procedure  is an external procedure.  
on unit on line 167                  64 on unit               
on unit on line 205                  64 on unit               
Complain                             80 internal procedure  is called during a stack extension.  
Mr_Clean                             86 internal procedure  is called by several nonquick procedures.  
next_field                              internal procedure  shares stack frame of external procedure initialize_peek_limits.  
remove_white_space                      internal procedure  shares stack frame of external procedure initialize_peek_limits.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
Mr_Clean                 000100 acode                       Mr_Clean
initialize_peek_limits   000100 abs_filename                initialize_peek_limits
                         000152 any_parse                   initialize_peek_limits
                         000153 bc                          initialize_peek_limits
                         000154 begin_offset                initialize_peek_limits
                         000155 code                        initialize_peek_limits
                         000156 delim_type                  initialize_peek_limits
                         000157 dirname                     initialize_peek_limits
                         000231 end_offset                  initialize_peek_limits
                         000232 entryname                   initialize_peek_limits
                         000242 field_ptr                   initialize_peek_limits
                         000244 field_l                     initialize_peek_limits
                         000245 field_type                  initialize_peek_limits
                         000246 filename_l                  initialize_peek_limits
                         000250 filename_p                  initialize_peek_limits
                         000252 file_l                      initialize_peek_limits
                         000254 file_ptr                    initialize_peek_limits
                         000256 high_seg                    initialize_peek_limits
                         000257 ignore                      initialize_peek_limits
                         000260 low_seg                     initialize_peek_limits
                         000262 marrayp                     initialize_peek_limits
                         000264 nargs                       initialize_peek_limits
                         000265 one_begin                   initialize_peek_limits
                         000266 one_seg                     initialize_peek_limits
                         000267 rcode                       initialize_peek_limits
                         000270 seg_no                      initialize_peek_limits
                         000272 seg_ptr                     initialize_peek_limits
                         000274 type                        initialize_peek_limits
                         000275 LIMITSEG_NAME               initialize_peek_limits
                         000304 mtablep                     initialize_peek_limits
                         000306 mentryp                     initialize_peek_limits
                         000332 l                           next_field
                         000342 l                           remove_white_space

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return              tra_ext             signal              enable              shorten_stack
ext_entry           int_entry           int_entry_desc      any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   expand_pathname_
get_temp_segment_             hcs_$high_low_seg_count       hcs_$initiate_count           hcs_$terminate_noname
installation_tools_$patch_path                              release_temp_segment_         ring0_get_$definition
ring0_get_$segptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badsyntax        error_table_$segknown         error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000136       101 000144       164 000147       165 000150       167 000153       169 000175       170 000216
    171 000233       173 000235       174 000246       175 000252       178 000256       179 000265       181 000303
    183 000322       184 000352       185 000367       187 000441       188 000504       190 000521       191 000523
    192 000526       195 000536       200 000541       201 000542       202 000544       203 000545       204 000547
    205 000553       207 000572       208 000575       209 000577       210 000602       211 000604       212 000606
    213 000610       214 000613       216 000623       219 000641       220 000671       221 000673       222 000727
    224 000731       226 000735       228 000737       229 000740       230 000742       231 000744       232 000746
    233 000750       234 000753       236 000771       238 001035       239 001037       241 001076       244 001100
    246 001102       247 001103       248 001105       249 001107       250 001112       251 001120       252 001122
    253 001143       254 001164       256 001165       258 001231       259 001233       261 001272       263 001274
    267 001276       268 001300       270 001305       271 001310       272 001312       273 001315       274 001321
    275 001323       276 001326       279 001330       280 001334       281 001335       282 001337       283 001340
    284 001342       286 001343       288 001344       290 001405       293 001500       296 001505       302 001506
    308 001522       309 001544       316 001547       321 001555       323 001572       327 001620       337 001621
    363 001623       364 001625       366 001627       368 001630       370 001635       371 001641       372 001656
    373 001662       374 001664       375 001670       377 001672       379 001703       380 001717       381 001724
    383 001726       384 001731       385 001736       388 001740       390 001760       393 001762       403 001763
    411 001765       412 001770       414 001776       415 001777       418 002005       419 002021       420 002022
    421 002026       422 002032       423 002036       424 002047       425 002056       426 002061       427 002065
    428 002066       429 002074       431 002075


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
