	COMPILATION LISTING OF SEGMENT carry_load
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/09/85  1404.0 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 carry_load: proc;
       12 
       13 /* This module implements the carry_load, carry_map and carry_retrieve commands,
       14*   which operate on tapes created by the carry_dump command.
       15*
       16*   Usage:
       17*   carry_load tape_number {-control_args}
       18*
       19*   where:
       20*
       21*   1. tape_number	is the ASCII identifier of a tape.
       22*
       23*   2. control_args can be:
       24*
       25*-comment STR, -com STR
       26*   specifies a comment name for the previously specified tape.
       27*-copy_dir PATH, -cpd PATH
       28*   specifies a different directory in which to place retrieved copies.
       29*-force, -fc
       30*   loads tape even if it is more than 5 days old.
       31*-next_vol STR, -nxv STR
       32*   specifies a continuation tape.
       33*-queue_dir PATH, -qd PATH
       34*   specifies a different directory containing the carry queue.
       35*-test
       36*   does not load a tape; used for testing.
       37*
       38*   One of the entries on a carry tape is a directory containing segments to be mailed
       39*   to requestors when the requests are successfully loaded. This directory is named
       40*   mail_to_carry and resides in the specified queue directory. After the load has been
       41*   performed, error messages are inserted in these mail segments and copies of entries
       42*   that cannot be loaded are retrieved under the directory >daemon_dir_dir>carry_dir>copies.
       43*
       44*   Note: This command reloads an entire carry tape. To load particular entries from a tape,
       45*   use the carry_retrieve command.
       46*
       47*   Active function usage:
       48*
       49*   [carry_load tape_number {-control_args}]
       50*
       51*   returns true if the tape could be read, false otherwise.
       52*
       53*   Other commands:
       54*
       55*   carry_map tape_number
       56*
       57*   to list the contents of a carry tape, and:
       58*
       59*   carry_retrieve tape_number {-select} path1 {-new_dir path2} etc.
       60*
       61*   to retrieve a specified entry from a carry tape, possibly into someplace new.
       62*   With -select, prints list of tape contents and accepts line nuumbers of requests.
       63*
       64*   Steve Herbst 1/16/77 */
       65 /* -trim and bug fixes 08/03/79 S. Herbst */
       66 /* carry_retrieve -select 09/05/79 S. Herbst */
       67 /* Add -user & -next_vol 01/08/80 S. Herbst */
       68 /* Add -comment & -copy_dir 07/30/80 S. Herbst */
       69 
       70 
  1     1 /* BEGIN INCLUDE FILE ... backup_control.incl.pl1 */
  1     2 /* Modified: July 1982 by G. Palter to add features for proper support of AIM in IMFT (version 4) */
  1     3 /* Modified: August 1983 by Robert Coren to add minimum access class enforcement */
  1     4 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  1     5 
  1     6 /* Hierarchy dumper/reloader subroutine control structure */
  1     7 
  1     8 dcl 1 backup_control aligned based (backup_control_ptr),
  1     9     2 header,					/* allows people to use like (!) */
  1    10       3 version character (8) unaligned,
  1    11       3 tape_entry entry (character (*)) variable,	/* returns next tape label */
  1    12       3 data_iocb pointer,				/* -> I/O switch to use for dumping/loading if preattached */
  1    13       3 maximum_access_class bit (72) aligned,		/* maximum access class for anything to be dumped */
  1    14       3 minimum_access_class bit (72) aligned,		/* minimum access class for anything to be dumped */
  1    15       3 maximum_dir_access_class bit (72) aligned,	/* no directory above this access class is dumped */
  1    16       3 user_for_access_check,			/* data required to validate user's access */
  1    17         4 id character (32) unaligned,			/* Person.Project.tag */
  1    18         4 authorization bit (72),			/* the user's process authorization */
  1    19         4 ring fixed binary,				/* the user's ring o execution */
  1    20       3 minimum_ring fixed binary,			/* no ring bracket is set below this value */
  1    21       3 aim_translations,				/* data required to translate AIM attributes on the tape */
  1    22         4 source_attributes_ptr pointer,
  1    23         4 target_attributes_ptr pointer,
  1    24       3 options aligned,
  1    25         4 map_sw  bit(1) unaligned,			/* ON to write map segment */
  1    26         4 debug_sw bit (1) unaligned,			/* ON to check quotas and not trim subtrees */
  1    27         4 no_reload_sw bit (1) unaligned,		/* ON to not load for backup_load_ */
  1    28         4 hold_sw bit (1) unaligned,			/* ON to not demount tape afterwards */
  1    29         4 preattached bit (1) unaligned,		/* ON => perform loading/dumping to supplied I/O switch */
  1    30         4 error_file bit (1) unaligned,			/* ON => generate an error file anyway */
  1    31         4 first bit (1) unaligned,			/* ON => for reload, stop after all requests satisfied */
  1    32         4 caller_handles_conditions bit (1) unaligned,	/* ON => caller of backup_dump_ handles faults */
  1    33         4 allow_dir_overwrite bit (1) unaligned,		/* ON => allow reloaded seg to overwrite a dir */
  1    34         4 enforce_max_access_class bit (1) unaligned,	/* ON => do not dump anything above given access class */
  1    35         4 dont_dump_upgraded_dirs bit (1) unaligned,	/* ON => do not dump directories above given access class */
  1    36         4 check_effective_access bit (1) unaligned,	/* ON => do not dump branches specified user can't touch */
  1    37         4 restore_access_class bit (1) unaligned,		/* ON => restore AIM attributes even in debug mode */
  1    38         4 enforce_minimum_ring bit (1) unaligned,		/* ON => do not give anything ring bracket below minimum */
  1    39         4 translate_access_class bit (1) unaligned,	/* ON => translate access classes read from tape */
  1    40         4 enforce_min_access_class bit (1) unaligned,	/* ON => do not dump anything below given access class */
  1    41         4 upgrade_to_user_auth bit (1) unaligned,		/* ON => set access class of branch being dumped to user's authorization */
  1    42         4 pad bit (19) unaligned,
  1    43       3 request_count fixed binary,			/* # of entries to load or dump */
  1    44     2 requests (backup_control_request_count refer (backup_control.request_count)),
  1    45       3 path character (168) unaligned,			/* pathname of object to be dumped/loaded */
  1    46       3 new_path character (168) unaligned,		/* pathname for object when reloading if not same as above */
  1    47       3 switches aligned,
  1    48         4 no_primary_sw bit (1) unaligned,		/* do not use primary pathname */
  1    49         4 trim_sw bit (1) unaligned,			/* trim target directories */
  1    50         4 pad bit (34) unaligned,
  1    51       3 found bit(1) aligned,				/* ON => found on tape by backup_load_ (output) */
  1    52       3 loaded bit (1) aligned,			/* ON => loaded by backup_load_ (output) */
  1    53       3 status_code fixed binary (35),			/* ON => per-entry status code (output) */
  1    54       3 error_name character (65) unaligned;		/* ON => some information about what happened (output) */
  1    55 
  1    56 dcl  backup_control_ptr pointer;
  1    57 
  1    58 dcl backup_control_request_count fixed binary;		/* for allocations */
  1    59 
  1    60 dcl BACKUP_CONTROL_VERSION_5 character (8) static options (constant) initial ("hbc_0005");
  1    61 
  1    62 /* END INCLUDE FILE ... backup_control.incl.pl1 */
       71 
       72 dcl 1 request_info (request_count) aligned based,
       73     2 sender char (32) unaligned,			/* Person.Project */
       74     2 new_user char (32) unaligned,			/* access name for copy if different */
       75     2 type_string char (32) unaligned,			/* "Segment" or "Subtree" */
       76     2 path char (168) unaligned,			/* pathname on tape */
       77     2 incacc_sw bit (1) aligned,			/* ON if requestor lacks sma on parent */
       78     2 incacc_code fixed bin (35),			/* code from hcs_$get_user_effmode */
       79     2 copy_sw bit (1) aligned,			/* ON to retrieve copy */
       80     2 copy_path char (168) unaligned,			/* >ddd>carry_dir>copies>... */
       81     2 user_dir char (168) unaligned;			/* >ddd>ccarry_dir>copies>next_dir */
       82 
       83 dcl  queue_dir char (168) init (">ddd>carry_dir");
       84 dcl  copy_dir char (168) init (">daemon_dir_dir>carry_dir>copies");
       85 
       86 dcl  WHITE_SPACE char (2) int static options (constant) init ("	 ");  /* HT SP */
       87 dcl  DIGITS char (10) int static options (constant) init ("1234567890");
       88 
       89 dcl copy_path_array (50) char (168);
       90 dcl copy_sender_array (50) char (168);
       91 
       92 dcl query_explanation char (168) int static options (constant) init
       93 	("Type the numbers of the requests you want retrieved, with optional ""-new_dir PATH"", as in ""2 4 -nd >foo 6""");
       94 dcl (dn, error_path, mail_dir_path, new_dn, process_dir, request_path, tape_log_path) char (168);
       95 dcl (command, en, temp_en) char (32);
       96 dcl  arg char (arg_len) based (arg_ptr);
       97 dcl  return_string char (return_len) varying based (return_ptr);
       98 dcl  mail_seg char (mail_seg_len) based (mail_seg_ptr);
       99 dcl (buffer, error_line) char (500);
      100 dcl  answer char (300) varying;
      101 dcl (err_string, sender_string) char (100);
      102 dcl  name_string char (65);
      103 dcl (new_user_id, sender_id) char (32);
      104 dcl (destination, ds_arg) char (23);
      105 dcl  (comment, tape_number) char (32) int static;
      106 dcl  newline char (1) int static options (constant) init ("
      107 ");
      108 dcl 1 next_array (20) int static,
      109      2 next_vol char (32),
      110      2 next_comment char (32);
      111 
      112 dcl retrieve_array (500) bit (1) unaligned;
      113 
      114 dcl  dtm72 bit (72);
      115 dcl (active_function, ds_sw, found_sw, force_sw, got_path, got_tape) bit (1) aligned;
      116 dcl (mail_sw, new_dir_sw, print_log_sw, select_sw, test_sw) bit (1) aligned;
      117 dcl  use_first_tape bit (1) aligned int static;
      118 dcl  tape_attached bit (1) aligned init ("0"b);
      119 
      120 dcl (bk_iocb, new_mail_iocb, old_mail_iocb, tape_log_iocb) ptr init (null);
      121 dcl (eptr, nptr) ptr init (null);
      122 dcl (area_ptr, arg_ptr, mail_seg_ptr, return_ptr, tape_log_ptr) ptr;
      123 dcl  ptrs (2) ptr;
      124 dcl (control_ptr, info_ptr) ptr init (null);
      125 
      126 dcl mode fixed bin (5);
      127 dcl (arg_count, arg_len, buffer_len, copies_omitted, days, ecount, error_line_len) fixed bin;
      128 dcl (i, j, k, level, number_omitted, request_count, request_index, return_len, saved_request_count) fixed bin;
      129 dcl (next_vol_count, next_vol_index) fixed bin int static;
      130 dcl  mail_seg_len fixed bin;
      131 dcl (mail_seg_bc, tape_log_bc) fixed bin (24);
      132 dcl  code fixed bin (35);
      133 dcl (now, time_written, four_days) fixed bin (71);
      134 dcl  ONE_DAY fixed bin (71) int static options (constant) init (86400000000);
      135 dcl  ONE_HOUR fixed bin (71) int static options (constant) init (3600000000);
      136 
      137 dcl  area area based (area_ptr);
      138 
      139 dcl 1 segment_acl (1) aligned,
      140     2 access_name char (32) unaligned,
      141     2 modes bit (36),
      142     2 zero_pad bit (36),
      143     2 status_code fixed bin (35);
      144 
      145 dcl 1 entries (ecount) aligned based (eptr),
      146     2 type bit (2) unaligned,
      147     2 nnames fixed bin (15) unaligned,
      148     2 nindex fixed bin (17) unaligned;
      149 
      150 dcl  star_names (99) char (32) aligned based (nptr);
  2     1      declare		/* Structure returned by hcs_$status_long */
  2     2 
  2     3 	1 branch_status aligned,				/* automatic: hcs_$status uses a pointer */
  2     4 
  2     5 	  2 type bit(2) unaligned,				/* type of entry: link, segment, dir */
  2     6 	  2 number_names bit(16) unaligned,			/* unused by directory_status_ */
  2     7 	  2 names_rel_pointer bit(18) unaligned,		/* unused by directory_status_ */
  2     8 	  2 date_time_modified bit(36) unaligned,		/* date time modified */
  2     9 	  2 date_time_used bit(36) unaligned,			/* date time entry used */
  2    10 	  2 mode bit(5) unaligned,				/* effective access of caller */
  2    11 	  2 raw_mode bit(5) unaligned,
  2    12 	  2 pad1 bit(8) unaligned,
  2    13 	  2 records bit(18) unaligned,			/* number of records in use */
  2    14 	  2 date_time_dumped bit(36) unaligned,			/* date time last dumped */
  2    15 	  2 date_time_entry_modified bit(36) unaligned,		/* date time entry modified */
  2    16 	  2 lvid bit(36) unaligned,				/* logical volume id */
  2    17 	  2 current_length bit(12) unaligned,			/* number of blocks currently allocated */
  2    18 	  2 bit_count bit(24) unaligned,			/* bit count of entry */
  2    19 	  2 pad3 bit(8) unaligned,
  2    20 	  2 copy_switch bit(1) unaligned,			/* the copy switch */
  2    21 	  2 tpd bit(1) unaligned,				/* transparent to paging device */
  2    22 	  2 mdir bit(1) unaligned,				/* master directory switch */
  2    23 	  2 damaged_switch bit (1) unaligned,			/* true if contents damaged */
  2    24 	  2 synchronized_switch bit (1) unaligned,		/* true if a DM synchronized file */
  2    25 	  2 pad4 bit(5) unaligned,
  2    26 	  2 ring_brackets (0:2) bit(6) unaligned,		/* branch ring brackets */
  2    27 	  2 unique_id bit(36) unaligned,			/* entry unique id */
  2    28 
  2    29 
  2    30 	     /* The types of each class of branch */
  2    31 	segment_type bit(2) aligned internal static initial ("01"b),
  2    32 	directory_type bit(2) aligned internal static initial ("10"b),
  2    33 	msf_type bit(2) aligned internal static initial ("10"b),	/* will eventually be different */
  2    34 	link_type bit(2) aligned internal static initial ("00"b);
  2    35 
  2    36 
      151 
  3     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  3     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  3     3 /*	version number changed to 4, 08/10/78 WOS */
  3     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  3     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  3     6 
  3     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  3     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  3     9     2 switches aligned,                                     /* various bit switch values */
  3    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  3    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  3    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  3    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  3    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  3    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  3    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  3    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  3    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  3    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  3    20 
  3    21 /*  Limit of data defined for version 2 */
  3    22 
  3    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  3    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  3    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  3    26 						/* minimum of 30 seconds required for repeat */
  3    27 						/* otherwise, no repeat will occur */
  3    28 /* Limit of data defined for version 4 */
  3    29 
  3    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  3    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  3    32 
  3    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  3    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  3    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  3    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  3    37 
  3    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      152 
  4     1 /*  BEGIN  send_mail_info include file */
  4     2 
  4     3 dcl send_mail_info_version_2 fixed bin init(2);
  4     4 
  4     5 dcl 1 send_mail_info aligned,
  4     6      2 version fixed bin,  /* = 2 */
  4     7      2 sent_from char(32) aligned,
  4     8      2 switches,
  4     9       3 wakeup bit(1) unal,
  4    10       3 mbz1 bit(1) unal,
  4    11       3 always_add bit(1) unal,
  4    12       3 never_add bit(1) unal,
  4    13       3 notify bit(1) unal,
  4    14       3 acknowledge bit(1) unal,
  4    15       3 mbz bit(30) unal;
  4    16 
  4    17 /*  END  send_mail_info include file */
      153 
  5     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  5     2*
  5     3*   Values for the "access mode" argument so often used in hardcore
  5     4*   James R. Davis 26 Jan 81  MCR 4844
  5     5*   Added constants for SM access 4/28/82 Jay Pattin
  5     6*   Added text strings 03/19/85 Chris Jones
  5     7**/
  5     8 
  5     9 
  5    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5    11 dcl	(
  5    12 	N_ACCESS		   init ("000"b),
  5    13 	R_ACCESS		   init ("100"b),
  5    14 	E_ACCESS		   init ("010"b),
  5    15 	W_ACCESS		   init ("001"b),
  5    16 	RE_ACCESS		   init ("110"b),
  5    17 	REW_ACCESS	   init ("111"b),
  5    18 	RW_ACCESS		   init ("101"b),
  5    19 	S_ACCESS		   init ("100"b),
  5    20 	M_ACCESS		   init ("010"b),
  5    21 	A_ACCESS		   init ("001"b),
  5    22 	SA_ACCESS		   init ("101"b),
  5    23 	SM_ACCESS		   init ("110"b),
  5    24 	SMA_ACCESS	   init ("111"b)
  5    25 	)		   bit (3) internal static options (constant);
  5    26 
  5    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  5    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  5    29 
  5    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  5    31 			   static options (constant);
  5    32 
  5    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  5    34 			   static options (constant);
  5    35 
  5    36 dcl	(
  5    37 	N_ACCESS_BIN	   init (00000b),
  5    38 	R_ACCESS_BIN	   init (01000b),
  5    39 	E_ACCESS_BIN	   init (00100b),
  5    40 	W_ACCESS_BIN	   init (00010b),
  5    41 	RW_ACCESS_BIN	   init (01010b),
  5    42 	RE_ACCESS_BIN	   init (01100b),
  5    43 	REW_ACCESS_BIN	   init (01110b),
  5    44 	S_ACCESS_BIN	   init (01000b),
  5    45 	M_ACCESS_BIN	   init (00010b),
  5    46 	A_ACCESS_BIN	   init (00001b),
  5    47 	SA_ACCESS_BIN	   init (01001b),
  5    48 	SM_ACCESS_BIN	   init (01010b),
  5    49 	SMA_ACCESS_BIN	   init (01011b)
  5    50 	)		   fixed bin (5) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      154 
      155 dcl  error_table_$badopt fixed bin (35) ext;
      156 dcl  error_table_$end_of_info fixed bin (35) ext;
      157 dcl  error_table_$incorrect_access fixed bin (35) ext;
      158 dcl  error_table_$noentry fixed bin (35) ext;
      159 dcl  error_table_$nomatch fixed bin (35) ext;
      160 dcl  error_table_$no_dir fixed bin (35) ext;
      161 dcl  error_table_$not_act_fnc fixed bin (35) ext;
      162 dcl  error_table_$not_attached fixed bin (35) ext;
      163 dcl  error_table_$request_pending fixed bin (35) ext;
      164 dcl  error_table_$rqover fixed bin (35) ext;
      165 
      166 dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
      167 dcl (active_fnc_err_, active_fnc_err_$suppress_name) entry options (variable);
      168 dcl  adjust_bit_count_ entry (char (168) aligned, char (32) aligned, bit (1) aligned, fixed bin (24), fixed bin (35));
      169 dcl  backup_load_ entry (ptr, fixed bin (35));
      170 dcl  bk_input$input_finish entry;
      171 dcl  bk_ss_$holdsw bit (1) aligned ext;
      172 dcl (com_err_, com_err_$suppress_name) entry options (variable);
      173 dcl  command_query_ entry options (variable);
      174 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
      175 dcl  convert_status_code_ entry (fixed bin (35), char (*), char (*));
      176 dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
      177 dcl  cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35));
      178 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      179 dcl  cu_$level_get entry (fixed bin);
      180 dcl  cv_dec_ entry (char (*)) returns (fixed bin);
      181 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      182 dcl  get_group_id_ entry returns (char (32));
      183 dcl  get_pdir_ entry returns (char (168));
      184 dcl  get_system_free_area_ entry returns (ptr);
      185 dcl  get_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
      186 dcl  hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      187 dcl  hcs_$add_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      188 dcl  hcs_$chname_file entry (char (*), char (*), char (*), char (*), fixed bin (35));
      189 dcl  hcs_$del_dir_tree entry (char (*), char (*), fixed bin (35));
      190 dcl  hcs_$delentry_file entry (char (*), char (*), fixed bin (35));
      191 dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
      192 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (1), ptr, fixed bin (35));
      193 dcl  hcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
      194 dcl  hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      195 dcl  hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
      196 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      197 dcl (ioa_, ioa_$ioa_switch, ioa_$nnl, ioa_$rs, ioa_$rsnnl) entry options (variable);
      198 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      199 dcl  iox_$close entry (ptr, fixed bin (35));
      200 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      201 dcl  iox_$error_output ptr ext;
      202 dcl  iox_$find_iocb entry (char (*), ptr, fixed bin (35));
      203 dcl  iox_$get_line entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
      204 dcl  iox_$open entry (ptr, fixed bin, bit (1), fixed bin (35));
      205 dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
      206 dcl  iox_$user_output ptr ext;
      207 dcl  release_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
      208 dcl  send_mail_ entry (char (*), char (*), ptr, fixed bin (35));
      209 dcl  send_message_$notify_mail entry options (variable);
      210 dcl  unique_chars_ entry (bit (1) aligned) returns (char (32));
      211 
      212 dcl (addr, clock, divide, fixed, index, length, ltrim) builtin;
      213 dcl (min, null, rtrim, search, substr, translate, unspec, verify) builtin;
      214 
      215 dcl (cleanup, program_interrupt) condition;
      216 						/*  */
      217 	command = "carry_load";
      218 	print_log_sw, select_sw = "0"b;
      219 
      220 	call cu_$af_return_arg (arg_count, return_ptr, return_len, code);
      221 	if code = error_table_$not_act_fnc then active_function = "0"b;
      222 	else do;
      223 	     active_function = "1"b;
      224 	     return_string = "false";
      225 	end;
      226 
      227 	if arg_count = 0 then do;
      228 USAGE:	     if active_function then call active_fnc_err_$suppress_name
      229 		(0, "carry_load", "Usage:  [carry_load tape_number {-control_args}]");
      230 	     else call com_err_$suppress_name
      231 		(0, "carry_load", "Usage:  carry_load tape_number {-control_args}");
      232 	     return;
      233 	end;
      234 
      235 	comment = "";
      236 	ds_sw, force_sw, got_tape, test_sw = "0"b;
      237 	next_vol_count = 0;
      238 	next_vol_index = 1;
      239 
      240 	do i = 1 to arg_count;
      241 
      242 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      243 
      244 	     if substr (arg, 1, 1) = "-" then
      245 		if arg = "-force" | arg = "-fc" then force_sw = "1"b;
      246 		else if arg = "-test" then test_sw = "1"b;
      247 		else if arg = "-destination" | arg = "-ds" then do;
      248 		     i = i + 1;
      249 		     if i > arg_count then do;
      250 			call warn (0, "carry_load", "No value specified for -destination.");
      251 			return;
      252 		     end;
      253 		     ds_sw = "1"b;
      254 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      255 		     ds_arg = arg;
      256 		end;
      257 		else if arg = "-queue_dir" | arg = "-qd" then do;
      258 		     i = i + 1;
      259 		     if i > arg_count then do;
      260 			call warn (0, "carry_load", "No value specified for -queue_dir");
      261 			return;
      262 		     end;
      263 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      264 		     call absolute_pathname_ (arg, queue_dir, code);
      265 		     if code ^= 0 then do;
      266 			call warn (code, "carry_load", arg);
      267 			return;
      268 		     end;
      269 		end;
      270 		else if arg = "-comment" | arg = "-com" then do;
      271 		     i = i + 1;
      272 		     if i > arg_count then do;
      273 			call warn (0, "carry_load", "No value specified for -comment.");
      274 			return;
      275 		     end;
      276 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      277 		     if next_vol_count = 0 then comment = arg;
      278 		     else next_array.next_comment (next_vol_count) = arg;
      279 		end;
      280 		else if arg = "-copy_dir" | arg = "-cpd" then do;
      281 		     i = i + 1;
      282 		     if i > arg_count then do;
      283 			call warn (0, "carry_load", "No value specified for -copy_dir");
      284 			return;
      285 		     end;
      286 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      287 		     call absolute_pathname_ (arg, copy_dir, code);
      288 		     if code ^= 0 then do;
      289 			call warn (code, "carry_load", arg);
      290 			return;
      291 		     end;
      292 		end;
      293 		else if arg = "-next_vol" | arg = "-nxv" then do;
      294 		     i = i + 1;
      295 		     if i > arg_count then do;
      296 			call warn (0, "carry_load", "No value specified for -next_vol.");
      297 			return;
      298 		     end;
      299 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      300 		     next_vol_count = next_vol_count + 1;
      301 		     next_array.next_vol (next_vol_count) = arg;
      302 		     next_array.next_comment (next_vol_count) = "";
      303 		end;
      304 		else do;
      305 		     code = error_table_$badopt;
      306 		     if active_function then call active_fnc_err_ (code, "carry_load", "^a", arg);
      307 		     else call com_err_ (code, "carry_load", "^a", arg);
      308 		     return;
      309 		end;
      310 
      311 	     else if got_tape then go to USAGE;
      312 	     else do;
      313 		got_tape = "1"b;
      314 		tape_number = arg;
      315 	     end;
      316 	end;
      317 	if ^got_tape then go to USAGE;
      318 	go to COMMON;
      319 						/*  */
      320 carry_map: entry;
      321 
      322 	command = "carry_map";
      323 	active_function = "0"b;
      324 	print_log_sw = "1"b;
      325 
      326 	call cu_$arg_count (arg_count, code);
      327 	if arg_count = 0 then do;
      328 USAGE2:	     call com_err_$suppress_name (0, "carry_map", "Usage:  carry_map tape_number {-next_vol ...}");
      329 	     return;
      330 	end;
      331 
      332 	go to GET_ARGS;
      333 
      334 
      335 
      336 
      337 carry_retrieve: entry;
      338 
      339 	command = "carry_retrieve";
      340 	active_function = "0"b;
      341 	force_sw = "1"b;				/* read tape no matter how old */
      342 
      343 	call cu_$arg_count (arg_count, code);
      344 	if arg_count < 2 then do;
      345 USAGE3:	     call com_err_$suppress_name (0, "carry_retrieve",
      346 		"Usage: carry_retrieve tape_number {-control_args} {path1} {-new_dir path2} etc.");
      347 	     return;
      348 	end;
      349 
      350 GET_ARGS:	ds_sw, got_tape, got_path, select_sw, test_sw = "0"b;
      351 	comment = "";
      352 	next_vol_count = 0;
      353 	next_vol_index = 1;
      354 
      355 	do i = 1 to arg_count;
      356 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      357 	     if substr (arg, 1, 1) ^= "-" then
      358 		if ^got_tape then do;
      359 		     got_tape = "1"b;
      360 		     tape_number = arg;
      361 		end;
      362 		else got_path = "1"b;
      363 	     else if arg = "-next_vol" | arg = "-nxv" then do;
      364 		i = i + 1;
      365 		if i > arg_count then do;
      366 		     call com_err_ (0, command, "No value specified for -next_vol");
      367 		     return;
      368 		end;
      369 		call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      370 		next_vol_count = next_vol_count + 1;
      371 		next_array.next_vol (next_vol_count) = arg;
      372 	     end;
      373 	     else if command = "carry_map" then do;
      374 		call com_err_ (error_table_$badopt, "carry_map", "^a", arg);
      375 		return;
      376 	     end;
      377 	     else if arg = "-test" then test_sw = "1"b;
      378 	     else if arg = "-select" then select_sw = "1"b;
      379 	     else if arg = "-no_select" then select_sw = "0"b;
      380 	end;
      381 
      382 	if command = "carry_map" then do;
      383 	     if ^got_tape then go to USAGE2;
      384 	end;
      385 	else do;
      386 	     if ^got_path & ^select_sw then go to USAGE3;
      387 	     print_log_sw = select_sw;
      388 	end;
      389 						/*  */
      390 COMMON:	on condition (cleanup) call clean_up;
      391 
      392 /* Allocate and initialize a control structure to drive backup_load_ */
      393 
      394 	call get_temp_segments_ (command, ptrs, code);
      395 	if code ^= 0 then do;
      396 	     call warn (code, command,
      397 		"^/Unable to allocate temp segs in process directory.^/Cannot load tape.");
      398 	     return;
      399 	end;
      400 	control_ptr = ptrs (1);
      401 	info_ptr = ptrs (2);
      402 
      403 	use_first_tape = "1"b;
      404 	control_ptr -> backup_control.version = BACKUP_CONTROL_VERSION_5;
      405 	control_ptr -> backup_control.tape_entry = load_tape_entry;
      406 	unspec (control_ptr -> backup_control.options) = "0"b;
      407 	control_ptr -> backup_control.debug_sw = "1"b;
      408 	control_ptr -> backup_control.first = "1"b;
      409 
      410 	if command = "carry_load" | select_sw then control_ptr -> backup_control.hold_sw = "1"b;
      411 	else control_ptr -> backup_control.hold_sw = "0"b;
      412 
      413 	if command = "carry_retrieve" & ^select_sw then go to RETRIEVE;
      414 
      415 /* Load <tape_number>.tape_log segment */
      416 
      417 	control_ptr -> backup_control.no_primary_sw = "0"b;  /* try by both given and primary path */
      418 
      419 	call ioa_$rsnnl ("^a>^a.tape_log", tape_log_path, 168, queue_dir, tape_number);
      420 	control_ptr -> backup_control.request_count = 1;
      421 	control_ptr -> backup_control.path (1) = tape_log_path;
      422 
      423 	if print_log_sw then do;
      424 	     process_dir = get_pdir_ ();
      425 	     call ioa_$rsnnl ("^a>^a.tape_log", tape_log_path, 168, process_dir, tape_number);
      426 	     control_ptr -> backup_control.new_path (1) = tape_log_path;
      427 	end;
      428 	else control_ptr -> backup_control.new_path (1) = "";
      429 
      430 	tape_attached = "1"b;
      431 
      432 	call backup_load_ (control_ptr, code);
      433 
      434 	if code = error_table_$not_attached then do;
      435 NO_TAPE:	     call warn (0, command, "Tape " || rtrim (tape_number) || " is not available.");
      436 	     go to RETURN;
      437 	end;
      438 
      439 	if print_log_sw then do;			/* print tape log segment */
      440 	     if code ^= 0 then do;
      441 		call com_err_ (code, command, "Unable to load ^a", tape_log_path);
      442 		go to RETURN;
      443 	     end;
      444 	     else if ^control_ptr -> backup_control.loaded (1) then do;
      445 		call com_err_ (control_ptr -> backup_control.status_code (1), command,
      446 		     "Unable to load ^a", tape_log_path);
      447 		go to RETURN;
      448 	     end;
      449 
      450 	     call adjust_bit_count_ ((process_dir), rtrim (tape_number) || ".tape_log", "1"b, tape_log_bc, code);
      451 	     call hcs_$initiate_count (tape_log_path, "", "", tape_log_bc, 0, tape_log_ptr, code);
      452 	     if select_sw then go to READ;
      453 	     call ioa_ ("^/");
      454 	     call iox_$put_chars (iox_$user_output, tape_log_ptr, divide (tape_log_bc, 9, 17, 0), code);
      455 	     call ioa_ ("");
      456 	     call hcs_$delentry_file (tape_log_path, "", code);
      457 	     go to RETURN;
      458 	end;
      459 
      460 	if code ^= 0 then do;
      461 	     call warn (code, command,
      462 		"^/Segment " || rtrim (tape_log_path) || " not loaded.^/Cannot load tape.");
      463 	     go to RETURN;
      464 	end;
      465 	else if ^control_ptr -> backup_control.loaded (1) then do;
      466 	     if control_ptr -> backup_control.status_code (1) = 0 then
      467 		call warn (0, command, "Segment " || rtrim (tape_log_path) || " not found on tape.
      468 Cannot load tape.");
      469 	     else call warn (control_ptr -> backup_control.status_code (1), command,
      470 		"^/Segment " || rtrim (tape_log_path) || " not found.^/Cannot load tape.");
      471 	     go to RETURN;
      472 	end;
      473 
      474 /* Read <tape_number>.tape_log */
      475 
      476 READ:	segment_acl (1).access_name = "*.*.*";
      477 	segment_acl (1).modes = "100"b;
      478 	segment_acl (1).zero_pad = "0"b;
      479 	call hcs_$add_acl_entries (tape_log_path, "", addr (segment_acl), 1, code);
      480 	call adjust_bit_count_ ((queue_dir), (rtrim (tape_number) || ".tape_log"), "1"b, (0), code);
      481 
      482 	call iox_$attach_name ("carry_tape_log", tape_log_iocb, "vfile_ " || tape_log_path, null, code);
      483 	if code ^= 0 then do;
      484 	     call warn (code, command, "^/Unable to attach ""carry_tape_log"" to " || tape_log_path);
      485 	     go to RETURN;
      486 	end;
      487 	call iox_$open (tape_log_iocb, 1, "0"b, code);
      488 	if code ^= 0 then do;
      489 READ_ERROR:    call warn (code, command,
      490 		"^/Unable to read " || rtrim (tape_log_path) || "^/Cannot load tape.");
      491 	     go to RETURN;
      492 	end;
      493 
      494 	call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
      495 	if code ^= 0 then go to READ_ERROR;
      496 	j = index (buffer, " to ");
      497 	i = index (buffer, " written ");
      498 	if i = 0 then do;
      499 PARSE_ERROR:   call warn (0, command, "Syntax error in tape log " || tape_log_path);
      500 	     call ioa_$ioa_switch (iox_$error_output, substr (buffer, 1, min (100, buffer_len)));
      501 	     call ioa_$ioa_switch (iox_$error_output, "Cannot load tape.");
      502 	     go to RETURN;
      503 	end;
      504 	destination = substr (buffer, j + 4, i - j - 4);
      505 	if ds_sw then
      506 	     if destination ^= ds_arg then do;
      507 		call warn (0, command, "Tape destination " || rtrim (destination) ||
      508 		     " does not match destination arg " || rtrim (ds_arg) || "^/Cannot load tape.");
      509 		go to RETURN;
      510 	     end;
      511 	i = i + 9;
      512 	call convert_date_to_binary_ (substr (buffer, i, buffer_len - i), time_written, code);
      513 	if code ^= 0 then go to PARSE_ERROR;
      514 	days = divide (clock () - time_written, ONE_DAY, 71, 0);
      515 	if days > 5 & ^force_sw then do;
      516 	     call ioa_$rsnnl ("Tape is ^d days old and may contain old data.^/Not loaded.",
      517 		buffer, buffer_len, days);
      518 	     call warn (0, command, substr (buffer, 1, buffer_len));
      519 	     go to RETURN;
      520 	end;
      521 
      522 	if select_sw then call ioa_ ("^/^a", substr (buffer, 1, buffer_len));  /* print header */
      523 						/*  */
      524 /* Test that requestors have sma access to parent directories */
      525 
      526 	call cu_$level_get (level);
      527 
      528 	call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
      529 
      530 	request_count, control_ptr -> backup_control.request_count = 0;
      531 	number_omitted = 0;
      532 
      533 	if select_sw then
      534 	     on program_interrupt go to QUERY_INIT;
      535 
      536 	do while (code ^= error_table_$end_of_info);
      537 
      538 	     if buffer_len >= 22
      539 		     & substr (buffer, 1, 22) = "No requests submitted."
      540 		     & control_ptr -> backup_control.request_count < 2 then do;
      541 
      542 		call ioa_ ("Tape contains no requests.");
      543 		if active_function then return_string = "true";
      544 		go to RETURN;
      545 	     end;
      546 
      547 	     request_count, control_ptr -> backup_control.request_count = request_count + 1;
      548 	     if select_sw then call ioa_$nnl ("^3d^2x^a", request_count, substr (buffer, 1, buffer_len));
      549 	     i = index (buffer, "  ");
      550 	     if i = 0 then go to PARSE_ERROR;
      551 	     info_ptr -> request_info (request_count).type_string = substr (buffer, 1, 7);
      552 	     control_ptr -> backup_control.no_primary_sw (request_count) = "1"b;
      553 	     if substr (buffer, buffer_len, 1) = newline then buffer_len = buffer_len - 1;
      554 	     if substr (buffer, buffer_len - 8, 9) = " -new_dir" then do;
      555 		new_dir_sw = "1"b;
      556 		buffer_len = buffer_len - 9;
      557 	     end;
      558 	     else new_dir_sw = "0"b;
      559 	     if substr (buffer, buffer_len - 5, 6) = " -trim" then do;
      560 		control_ptr -> backup_control.trim_sw (request_count) = "1"b;
      561 		buffer_len = buffer_len - 6;
      562 	     end;
      563 	     else control_ptr -> backup_control.trim_sw (request_count) = "0"b;
      564 	     sender_string = substr (buffer, i + 2, buffer_len - i - 1);
      565 	     j = index (sender_string, " -user ");
      566 	     if j = 0 then do;
      567 		sender_id = sender_string;
      568 		new_user_id = "";
      569 	     end;
      570 	     else do;
      571 		sender_id = substr (sender_string, 1, j - 1);
      572 		new_user_id = substr (sender_string, j + 7);
      573 	     end;
      574 	     info_ptr -> request_info (request_count).sender = sender_id;
      575 	     info_ptr -> request_info (request_count).new_user = new_user_id;
      576 	     request_path, control_ptr -> backup_control.path (request_count) = substr (buffer, 9, i - 9);
      577 	     control_ptr -> backup_control.new_path (request_count) = "";
      578 	     call expand_pathname_ (request_path, dn, en, code);
      579 	     if code ^= 0 then go to NEXT_LINE;
      580 	     if new_dir_sw then do;
      581 		call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
      582 		if code = 0 then do;
      583 		     request_path, control_ptr -> backup_control.new_path (request_count) =
      584 			substr (buffer, 29, buffer_len - 29) || ">" || en;
      585 		     if select_sw then call ioa_$nnl ("^5x^a", substr (buffer, 1, buffer_len));
      586 		end;
      587 	     end;
      588 	     if select_sw then go to NEXT_LINE;		/* don't test access for carry_retrieve */
      589 	     temp_en = "";				/* get access on parent */
      590 
      591 GET_MODE:	     if substr (sender_id, length (rtrim (sender_id)) - 1, 1) = "." then
      592 		call hcs_$get_user_effmode (dn, temp_en, sender_id, level, mode, code);
      593 	     else call hcs_$get_user_effmode (dn, temp_en, rtrim (sender_id) || ".*", level, mode, code);
      594 
      595 	     if (mode ^= SMA_ACCESS_BIN & code = 0) |
      596 	     (code ^= 0 &
      597 	     (code ^= error_table_$noentry | temp_en ^= "") &
      598 	     code ^= error_table_$no_dir) then
      599 		if temp_en = "" & info_ptr -> request_info (request_count).type_string = "Subtree" then do;
      600 		     temp_en = en;			/* settle for sma on existing directory itself */
      601 		     go to GET_MODE;
      602 		end;
      603 		else do;
      604 		     info_ptr -> request_info (request_count).incacc_sw = "1"b;
      605 		     info_ptr -> request_info (request_count).incacc_code = code;
      606 		     info_ptr -> request_info (request_count).path =
      607 			control_ptr -> backup_control.path (request_count);
      608 		     control_ptr -> backup_control.path (request_count) = ">foo>foo"; /* not findable */
      609 		end;
      610 
      611 NEXT_LINE:     call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
      612 	end;
      613 
      614 	if select_sw then do;			/* carry_retrieve -select */
      615 
      616 QUERY_INIT:    unspec (query_info) = "0"b;
      617 	     query_info.version = query_info_version_5;
      618 	     query_info.suppress_name_sw = "1"b;
      619 	     query_info.explanation_ptr = addr (query_explanation);
      620 	     query_info.explanation_len = length (rtrim (query_explanation));
      621 
      622 QUERY:	     call command_query_ (addr (query_info), answer, "carry_retrieve", "Request numbers:  ");
      623 
      624 	     unspec (retrieve_array) = "0"b;
      625 	     request_index = 0;			/* initialize */
      626 	     answer = ltrim (answer, WHITE_SPACE);
      627 	     do while (answer ^= "");
      628 
      629 		dn = get_token ();
      630 
      631 		if verify (rtrim (dn), DIGITS) = 0 then do;
      632 		     request_index = cv_dec_ (dn);
      633 		     if request_index < 1 | request_index > request_count then do;
      634 			call com_err_ (0, "carry_retrieve", "No request number ^d", request_index);
      635 			go to QUERY;
      636 		     end;
      637 		     retrieve_array (request_index) = "1"b;  /* to be retrieved */
      638 		end;
      639 		else if dn = "-new_dir" | dn = "-nd" then do;
      640 		     if request_index = 0 then do;
      641 			call com_err_ (0, "carry_retrieve", "-new_dir must follow a request number.");
      642 			go to QUERY;
      643 		     end;
      644 
      645 		     dn = get_token ();
      646 
      647 		     if dn = "" then do;
      648 			call com_err_ (0, "carry_retrieve", "No value specified for -new_dir");
      649 			go to QUERY;
      650 		     end;
      651 		     call absolute_pathname_ (dn, dn, code);
      652 		     if code ^= 0 then do;
      653 			call com_err_ (code, "carry_retrieve", "^a", dn);
      654 			go to QUERY;
      655 		     end;
      656 		     call expand_pathname_ (control_ptr -> backup_control.path (request_index), "", en, code);
      657 		     control_ptr -> backup_control.new_path (request_index) = rtrim (dn) || ">" || en;
      658 		end;
      659 		else do;
      660 		     call com_err_ (0, "carry_retrieve",
      661 			"Can only select request #'s, optionally followed by -nd PATH.");
      662 		     go to QUERY;
      663 		end;
      664 	     end;
      665 	     if substr (unspec (retrieve_array), 1, request_count) = "0"b then do;
      666 		call com_err_ (0, "carry_retrieve", "No retrievals requested.");
      667 		go to RETURN;
      668 	     end;
      669 	     do i = 1 to request_count;
      670 		if ^retrieve_array (i) then
      671 		     control_ptr -> backup_control.path (i) = ">foo>foo";  /* not findable dummy */
      672 	     end;
      673 
      674 	     tape_attached = "1"b;
      675 
      676 	     go to RELOAD;
      677 	end;
      678 						/*  */
      679 						/* Add mail_to_carry directory to the control structure */
      680 
      681 	call ioa_$rsnnl ("^a>mail_to_carry", buffer, buffer_len, queue_dir);
      682 	control_ptr -> backup_control.path (request_count + 1) = buffer;
      683 	control_ptr -> backup_control.new_path (request_count + 1) = "";
      684 
      685 	request_count, control_ptr -> backup_control.request_count = request_count + 1;
      686 
      687 /* Delete old mail_to_carry directory */
      688 
      689 	call hcs_$status_minf (queue_dir, "mail_to_carry", 1, 0, 0, code);
      690 	if code ^= error_table_$noentry then do;
      691 	     segment_acl (1).access_name = get_group_id_ ();
      692 	     segment_acl (1).modes = "111"b;
      693 	     call hcs_$add_dir_acl_entries (queue_dir, "mail_to_carry", addr (segment_acl), 1, code);
      694 	     call hcs_$del_dir_tree (queue_dir, "mail_to_carry", code);
      695 	     call hcs_$delentry_file (queue_dir, "mail_to_carry", code);
      696 	end;
      697 
      698 /* Pick up args to carry_retrieve */
      699 
      700 RETRIEVE:	if command = "carry_retrieve" then do;
      701 
      702 	     request_count, control_ptr -> backup_control.request_count = 0;
      703 
      704 	     do i = 2 to arg_count;
      705 		call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      706 		if substr (arg, 1, 1) = "-" then
      707 		     if arg = "-new_dir" | arg = "-nd" | arg = "-move" | arg = "-mv" then
      708 			if request_count = 0 then go to USAGE3;
      709 			else do;
      710 			     i = i + 1;
      711 			     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      712 			     if code ^= 0 then go to USAGE3;
      713 			     call absolute_pathname_ (arg, new_dn, code);
      714 			     if code ^= 0 then do;
      715 BADPATH:				call com_err_ (code, "carry_retrieve", "^a", arg);
      716 				go to RETURN;
      717 			     end;
      718 			     control_ptr -> backup_control.new_path (request_count) =
      719 				rtrim (new_dn) || ">" || en;
      720 			end;
      721 		     else do;
      722 			call com_err_ (error_table_$badopt, "carry_retrieve", "^a", arg);
      723 			go to RETURN;
      724 		     end;
      725 		else do;
      726 		     request_count, control_ptr -> backup_control.request_count = request_count + 1;
      727 		     call expand_pathname_ (arg, dn, en, code);
      728 		     if code ^= 0 then go to BADPATH;
      729 		     control_ptr -> backup_control.path (request_count) = rtrim (dn) || ">" || en;
      730 		     control_ptr -> backup_control.new_path (request_count) = "";
      731 		     control_ptr -> backup_control.no_primary_sw (request_count) = "1"b;
      732 		end;
      733 	     end;
      734 	     tape_attached = "1"b;
      735 	end;
      736 
      737 	control_ptr -> backup_control.no_reload_sw = test_sw;
      738 
      739 RELOAD:
      740 
      741 /* Try loading each thing by primary path as well, just in case */
      742 
      743 	do i = 1 to request_count;
      744 	     control_ptr -> backup_control.requests (i + request_count) = control_ptr -> requests (i);
      745 	     control_ptr -> backup_control.no_primary_sw (i + request_count) = "0"b;
      746 	end;
      747 	control_ptr -> backup_control.request_count = request_count * 2;
      748 
      749 /* Perform the reload */
      750 
      751 	call backup_load_ (control_ptr, code);
      752 
      753 	if code = error_table_$not_attached then go to NO_TAPE;
      754 
      755 	if code ^= 0 then do;
      756 	     call warn (code, command, "^/Tape " || rtrim (tape_number) || " not loaded.");
      757 	     go to RETURN;
      758 	end;
      759 
      760 /* See if any were loaded by primary path instead of the expected path */
      761 
      762 	do i = 1 to request_count;
      763 	     if ^control_ptr -> backup_control.found (i) &
      764 		control_ptr -> backup_control.found (i + request_count) then
      765 		     control_ptr -> backup_control.requests (i) =  /* copy the primary path's info */
      766 			control_ptr -> backup_control.requests (i + request_count);
      767 	end;
      768 	control_ptr -> backup_control.request_count = request_count;
      769 
      770 	if command = "carry_retrieve" then do;
      771 
      772 	     do i = 1 to control_ptr -> backup_control.request_count;
      773 
      774 		if control_ptr -> backup_control.path (i) ^= ">foo>foo" then do;	/* selected */
      775 		     if ^control_ptr -> backup_control.loaded (i) then
      776 			call ioa_$ioa_switch (iox_$error_output, "^a not ^[loaded^;found on tape^].",
      777 			control_ptr -> backup_control.path (i),
      778 			control_ptr -> backup_control.found (i));
      779 		     if control_ptr -> backup_control.status_code (i) ^= 0 then do;
      780 			dn = control_ptr -> backup_control.new_path (i);
      781 			if dn = "" then dn = control_ptr -> backup_control.path (i);
      782 			call com_err_ (control_ptr -> backup_control.status_code (i),
      783 			     control_ptr -> backup_control.error_name (i), dn);
      784 		     end;
      785 		end;
      786 	     end;
      787 	     go to RETURN;
      788 	end;
      789 
      790 	if active_function then return_string = "true";
      791 
      792 	if control_ptr -> backup_control.loaded (request_count) then mail_sw = "1"b; /* mail dir loaded */
      793 	else mail_sw = "0"b;
      794 
      795 /* Look for error codes */
      796 
      797 	do i = 1 to control_ptr -> backup_control.request_count - 1;
      798 
      799 	     if control_ptr -> backup_control.loaded (i) then call really_look (i);
      800 
      801 	     if ^control_ptr -> backup_control.loaded (i) &
      802 	       control_ptr -> backup_control.status_code (i) ^= error_table_$noentry then do;
      803 
      804 		number_omitted = number_omitted + 1;
      805 
      806 		if info_ptr -> request_info (i).incacc_sw then
      807 		     control_ptr -> backup_control.path (i) = info_ptr -> request_info (i).path;
      808 		else info_ptr -> request_info (i).path = control_ptr -> backup_control.path (i);
      809 
      810 		if control_ptr -> backup_control.status_code (i) = 0 then do;
      811 		     control_ptr -> backup_control.status_code (i) = error_table_$noentry;
      812 		     control_ptr -> backup_control.error_name (i) = "";
      813 		end;
      814 
      815 /* Prepare to retrieve a copy */
      816 
      817 		if control_ptr -> backup_control.found (i) then do;  /* only if found at all */
      818 		     info_ptr -> request_info (i).copy_sw = "1"b;
      819 		     dn = control_ptr -> backup_control.new_path (i);
      820 		     if dn = "" then dn = control_ptr -> backup_control.path (i);
      821 		     j = index (substr (dn, 2), ">");
      822 		     if j ^= 0 then do;
      823 			k = index (substr (dn, j + 2), ">");
      824 			if k ^= 0 then
      825 			     if index (substr (dn, j + k + 2), ">") ^= 0 then
      826 				dn = substr (dn, j + k + 1);
      827 		     end;
      828 		     dn = rtrim (copy_dir) || dn;
      829 		     info_ptr -> request_info (i).copy_path = dn;
      830 		     j = index (substr (dn, length (rtrim (copy_dir)) + 2), ">");
      831 		     if j = 0 then info_ptr -> request_info.user_dir (i) = "";
      832 		     else info_ptr -> request_info.user_dir (i) = substr (dn, 1, j + length (rtrim (copy_dir)) + 1);
      833 		end;
      834 	     end;
      835 
      836 	     code = control_ptr -> backup_control.status_code (i);
      837 	     name_string = control_ptr -> backup_control.error_name (i);
      838 
      839 	     if code ^= 0
      840 	     & name_string ^= "hcs_$set_safety_sw"
      841 	     & name_string ^= "hcs_$replace_dir_acl"
      842 	     & name_string ^= "set_ring_brackets" then do;
      843 
      844 /* Print error message */
      845 
      846 		if info_ptr -> request_info (i).incacc_sw then do; /* Lack sma to requestor */
      847 		     code = info_ptr -> request_info (i).incacc_code;
      848 		     error_path = info_ptr -> request_info (i).path;
      849 
      850 		     if code = 0 then buffer = "Requestor lacks sma access to parent directory.";
      851 		     else buffer = "^/Cannot check requestor's access to parent directory.";
      852 
      853 		     call warn (code, "carry_load", rtrim (buffer) || "  " || error_path);
      854 		end;
      855 		else if name_string = "ACL, ring brackets, safety switch" then do;
      856 		     if control_ptr -> backup_control.new_path (i) ^= "" then
      857 			error_path = control_ptr -> backup_control.new_path (i);
      858 		     else error_path = control_ptr -> backup_control.path (i);
      859 		     call ioa_$ioa_switch (iox_$error_output,
      860 			"Warning: No access to set ACL, ring brackets, safety switch.  ^a", error_path);
      861 		end;
      862 		else do;
      863 		     if control_ptr -> backup_control.found (i)
      864 		     & control_ptr -> backup_control.new_path (i) ^= "" then
      865 			error_path = control_ptr -> backup_control.new_path (i);
      866 		     else error_path = control_ptr -> backup_control.path (i);
      867 
      868 		     if code = error_table_$noentry then
      869 			call warn (0, name_string, "Entry not found on tape: " || rtrim (error_path)
      870 			     || " Entry not loaded.");
      871 		     else call warn (code, name_string, error_path);
      872 		end;
      873 
      874 		if mail_sw then do;
      875 
      876 /* Put error message in mail seg */
      877 
      878 		     if code = error_table_$incorrect_access then
      879 			err_string = "Incorrect access to some containing directory.";
      880 		     else call convert_status_code_ (code, "", err_string);
      881 		     if info_ptr -> request_info (i).incacc_sw then
      882 			if code = 0 then
      883 				call ioa_$rs ("carry_load: " || buffer || " ^a",
      884 				     error_line, error_line_len, error_path);
      885 			else call ioa_$rs ("carry_load: ^a ^a " || buffer,
      886 			     error_line, error_line_len, err_string, error_path);
      887 		     else if name_string = "ACL, ring brackets, safety switch" then
      888 			call ioa_$rs ("Warning: No access to set ACL, ring brackets, safety switch.   ^a",
      889 			     error_line, error_line_len, error_path);
      890 		     else call ioa_$rs ("^a: ^a ^a", error_line, error_line_len,
      891 			name_string, err_string, error_path);
      892 
      893 		     sender_id = info_ptr -> request_info.new_user (i);
      894 		     if sender_id = "" then sender_id = info_ptr -> request_info.sender (i);
      895 		     call ioa_$rsnnl ("^a>mail_to_carry", dn, 168, queue_dir);
      896 		     temp_en = unique_chars_ ("0"b);	/* prepare to copy mail seg */
      897 		     call hcs_$chname_file (dn, sender_id, sender_id, temp_en, code);
      898 		     if code ^= 0 then go to MAIL_END;
      899 
      900 		     found_sw = "0"b;
      901 
      902 		     call iox_$attach_name ("old_carry_mail", old_mail_iocb,
      903 			"vfile_ " || rtrim (dn) || ">" || temp_en, null, code);
      904 		     if code ^= 0 then go to MAIL_END;
      905 		     call iox_$open (old_mail_iocb, 1, "0"b, code);
      906 		     if code ^= 0 then go to DETACH_OLD;
      907 		     call iox_$attach_name ("new_carry_mail", new_mail_iocb,
      908 			"vfile_ " || rtrim (dn) || ">" || sender_id, null, code);
      909 		     if code ^= 0 then go to CLOSE_OLD;
      910 		     call iox_$open (new_mail_iocb, 2, "0"b, code);
      911 		     if code ^= 0 then go to DETACH_NEW;
      912 
      913 		     call iox_$get_line (old_mail_iocb, addr (buffer), length (buffer), buffer_len, code);
      914 
      915 		     do while (code ^= error_table_$end_of_info);
      916 
      917 			if ^found_sw then do;	/* still looking */
      918 
      919 /* See if this is the right line */
      920 
      921 			     request_path = substr (buffer, 9, index (buffer, " loaded ") - 9);
      922 			     if request_path = error_path then do;
      923 
      924 				found_sw = "1"b;
      925 				if control_ptr -> backup_control.loaded (i) then do;
      926 				     call iox_$put_chars (new_mail_iocb, addr (buffer), buffer_len, code);
      927 				     call iox_$put_chars (new_mail_iocb, addr (error_line),
      928 					error_line_len, code);
      929 				end;
      930 				else do;
      931 				     call ioa_$ioa_switch (new_mail_iocb,
      932 					"Unable to load ^a from tape ^a", error_path, tape_number);
      933 				     error_line_len = length (rtrim (error_line));
      934 				     call iox_$put_chars (new_mail_iocb, addr (error_line),
      935 					error_line_len, code);
      936 				     if unspec (info_ptr -> request_info (i).copy_path) = "0"b then
      937 					call ioa_$ioa_switch (new_mail_iocb, "Check for copy in ^a", copy_dir);
      938 				     else call ioa_$ioa_switch (new_mail_iocb, "Check for copy ^a",
      939 					info_ptr -> request_info (i).copy_path);
      940 				end;
      941 			     end;
      942 			     else call iox_$put_chars (new_mail_iocb, addr (buffer), buffer_len, code);
      943 			end;
      944 			else call iox_$put_chars (new_mail_iocb, addr (buffer), buffer_len, code);
      945 
      946 			call iox_$get_line (old_mail_iocb, addr (buffer), length (buffer), buffer_len, code);
      947 		     end;
      948 
      949 		     call iox_$close (new_mail_iocb, code);
      950 DETACH_NEW:	     call iox_$detach_iocb (new_mail_iocb, code);
      951 CLOSE_OLD:	     call iox_$close (old_mail_iocb, code);
      952 DETACH_OLD:	     call iox_$detach_iocb (old_mail_iocb, code);
      953 
      954 		     call hcs_$delentry_file (dn, temp_en, code);
      955 MAIL_END:		end;
      956 	     end;
      957 	end;
      958 
      959 /* Print "not loaded" messages */
      960 
      961 	do i = 1 to control_ptr -> backup_control.request_count - 1;
      962 
      963 	     if ^control_ptr -> backup_control.loaded (i) then
      964 		call ioa_$ioa_switch (iox_$error_output, "^a ^a not loaded.",
      965 		info_ptr -> request_info (i).type_string,
      966 		control_ptr -> backup_control.path (i));
      967 	end;
      968 
      969 	if command = "carry_retrieve" then go to RETURN;
      970 
      971 /* Clean up old copies */
      972 
      973 	call delete_old_copies;
      974 
      975 /* Retrieve copies */
      976 
      977 	saved_request_count = control_ptr -> backup_control.request_count - 1;
      978 	request_count, control_ptr -> backup_control.request_count = 0;
      979 
      980 	do i = 1 to saved_request_count;
      981 
      982 	     if info_ptr -> request_info (i).copy_sw then do;
      983 
      984 		request_count, control_ptr -> backup_control.request_count = request_count + 1;
      985 		control_ptr -> backup_control.path (request_count) =
      986 		     info_ptr -> request_info (i).path;
      987 		control_ptr -> backup_control.new_path (request_count) =
      988 		     info_ptr -> request_info (i).copy_path;
      989 		control_ptr -> backup_control.status_code (request_count) = 0;
      990 
      991 		info_ptr -> request_info (request_count).sender =
      992 		     info_ptr -> request_info (i).sender;
      993 		info_ptr -> request_info (request_count).new_user =
      994 		     info_ptr -> request_info (i).new_user;
      995 		info_ptr -> request_info (request_count).type_string =
      996 		     info_ptr -> request_info (i).type_string;
      997 	     end;
      998 	end;
      999 
     1000 	if request_count = 0 then do;
     1001 	     bk_ss_$holdsw = "0"b;			/* demount tape */
     1002 	     call bk_input$input_finish;
     1003 	end;
     1004 	else do;
     1005 	     control_ptr -> backup_control.hold_sw = "0"b;
     1006 
     1007 	     call backup_load_ (control_ptr, code);
     1008 	end;
     1009 
     1010 	tape_attached = "0"b;
     1011 
     1012 /* Set access on copies */
     1013 
     1014 	segment_acl (1).modes = "111"b;
     1015 	copies_omitted = 0;
     1016 
     1017 	do i = 1 to request_count;
     1018 
     1019 	     if control_ptr -> backup_control.loaded (i) then call really_look (i);
     1020 
     1021 	     if ^control_ptr -> backup_control.loaded (i) then do;
     1022 		if control_ptr -> backup_control.status_code (i) = error_table_$rqover then
     1023 		     call hcs_$delentry_file (control_ptr -> backup_control.new_path (i), "", code);
     1024 		if control_ptr -> backup_control.status_code (i) = error_table_$incorrect_access then
     1025 		     call com_err_ (0, "carry_load", "Incorrect access to some containing directory.  ^a",
     1026 			control_ptr -> backup_control.new_path (i));
     1027 		else if control_ptr -> backup_control.status_code (i) ^= 0 then
     1028 		     call com_err_ (control_ptr -> backup_control.status_code (i), "carry_load",
     1029 		     "^[Copy not loaded.  ^]^a", control_ptr -> backup_control.status_code (i) - 0,
     1030 		     control_ptr -> backup_control.new_path (i));
     1031 		copies_omitted = copies_omitted + 1;
     1032 		copy_path_array (copies_omitted) = control_ptr -> backup_control.new_path (i);
     1033 		copy_sender_array (copies_omitted) = info_ptr -> request_info (i).sender;
     1034 		if active_function then return_string = "false";
     1035 	     end;
     1036 	     sender_id = info_ptr -> request_info (i).new_user;
     1037 	     if sender_id = "" then sender_id = info_ptr -> request_info (i).sender;
     1038 	     segment_acl (1).access_name = substr (sender_id, 1, index (sender_id, ".") - 1) || ".*.*";
     1039 	     call expand_pathname_ (control_ptr -> backup_control.path (i), dn, en, code);
     1040 	     call hcs_$add_dir_acl_entries (dn, "", addr (segment_acl), 1, code);  /* parent */
     1041 	     if code ^= 0 & control_ptr -> backup_control.loaded (i) then call warn (code, "carry_load", dn);
     1042 	     if info_ptr -> request_info (i).user_dir ^= "" then
     1043 		call hcs_$add_dir_acl_entries (info_ptr -> request_info (i).user_dir, "",
     1044 		     addr (segment_acl), 1, code);
     1045 	     if info_ptr -> request_info (i).type_string = "Subtree" then
     1046 		call hcs_$add_dir_acl_entries (dn, en, addr (segment_acl), 1, code);
     1047 	     else call hcs_$add_acl_entries (dn, en, addr (segment_acl), 1, code);
     1048 	end;
     1049 
     1050 /* Send mail to requestors */
     1051 
     1052 	area_ptr = get_system_free_area_ ();
     1053 	send_mail_info.version = 2;
     1054 	send_mail_info.sent_from = "";
     1055 	unspec (send_mail_info.switches) = "0"b;
     1056 	send_mail_info.always_add = "1"b;
     1057 
     1058 	call ioa_$rsnnl ("^a>mail_to_carry", mail_dir_path, 168, queue_dir);
     1059 
     1060 	ecount = 0;
     1061 
     1062 	call hcs_$star_ (mail_dir_path, "**", 3 /* all */, area_ptr, ecount, eptr, nptr, code);
     1063 
     1064 	do i = 1 to ecount;
     1065 
     1066 	     sender_id = star_names (entries (i).nindex);
     1067 	     call hcs_$initiate_count (mail_dir_path, sender_id, "", mail_seg_bc, 0, mail_seg_ptr, code);
     1068 	     if mail_seg_ptr ^= null then do;
     1069 		mail_seg_len = divide (mail_seg_bc, 9, 17, 0);
     1070 
     1071 		call send_mail_ (sender_id, mail_seg, addr (send_mail_info), code);
     1072 		j = index (sender_id, ".");
     1073 		call send_message_$notify_mail (substr (sender_id, 1, j - 1), substr (sender_id, j + 1), code);
     1074 						/* send mail notification */
     1075 		call hcs_$terminate_noname (mail_seg_ptr, code);
     1076 	     end;
     1077 	end;
     1078 
     1079 	call ioa_ ("carry_load: Normal termination.");
     1080 	if number_omitted ^= 0 then
     1081 	     call ioa_ ("^d request^[s^] not loaded in place.", number_omitted, number_omitted > 1);
     1082 	if copies_omitted ^= 0 then do;
     1083 	     call ioa_ ("OF THESE, ^d COPIES NOT LOADED:", copies_omitted);
     1084 	     do i = 1 to copies_omitted;
     1085 		call ioa_ ("^3x^a^3x^a", copy_path_array (i), copy_sender_array (i));
     1086 	     end;
     1087 	end;
     1088 
     1089 RETURN:	call clean_up;
     1090 
     1091 	return;
     1092 						/*  */
     1093 get_token: proc returns (char (168));
     1094 
     1095 /* This internal procedure, used by carry_retrieve -select, returns the next
     1096*   space-separated token from the user's answer to "Request numbers:" query. */
     1097 
     1098 dcl token char (168);
     1099 
     1100 	if answer = "" then return ("");
     1101 	i = search (answer, WHITE_SPACE);
     1102 	if i = 0 then do;
     1103 	     token = answer;
     1104 	     answer = "";
     1105 	end;
     1106 	else do;
     1107 	     token = substr (answer, 1, i - 1);
     1108 	     answer = ltrim (substr (answer, i), WHITE_SPACE);
     1109 	end;
     1110 	return (token);
     1111 
     1112 end get_token;
     1113 /**/
     1114 really_look: proc (i);
     1115 
     1116 /* Checks that an entry has really been loaded with nonzero contents. */
     1117 
     1118 dcl i fixed bin;
     1119 dcl path char (168);
     1120 
     1121 	path = control_ptr -> backup_control.new_path (i);
     1122 	if path = "" then path = control_ptr -> backup_control.path (i);
     1123 
     1124 	call hcs_$status_ (path, "", 1, addr (branch_status), null, code);
     1125 
     1126 	if code = error_table_$noentry | code = error_table_$no_dir then do;
     1127 NOT_THERE:     control_ptr -> backup_control.loaded (i) = "0"b;
     1128 	     control_ptr -> backup_control.status_code (i) = error_table_$request_pending;
     1129 						/* "Request has not been completed" */
     1130 	end;
     1131 	else if code = 0 then do;
     1132 	     dtm72 = "0"b;
     1133 	     substr (dtm72, 21, 36) = branch_status.date_time_modified;  /* convert dtcm to clock time */
     1134 	     unspec (time_written) = unspec (dtm72);
     1135 	     if clock () - time_written > ONE_HOUR then go to NOT_THERE;
     1136 	     if branch_status.records = "0"b then go to NOT_THERE;
     1137 	end;
     1138 
     1139 end really_look;
     1140 						/*  */
     1141 delete_old_copies: proc;
     1142 
     1143 /* This internal procedure deletes all directories under >ddd>carry_dir>copies
     1144*   all of whose segments are more than 4 days old. */
     1145 
     1146 	     call convert_date_to_binary_ ("4 days", four_days, code);
     1147 	     now = clock ();
     1148 
     1149 	     segment_acl (1).access_name = get_group_id_ ();
     1150 	     segment_acl (1).modes = "111"b;
     1151 
     1152 	     area_ptr = get_system_free_area_ ();
     1153 	     eptr, nptr = null;
     1154 	     on condition (cleanup) begin;
     1155 		if eptr ^= null then free eptr -> entries in (area);
     1156 		if nptr ^= null then free nptr -> star_names in (area);
     1157 	     end;
     1158 
     1159 	     call hcs_$star_ (copy_dir, "**", 3 /* all */, area_ptr, ecount, eptr, nptr, code);
     1160 	     if code ^= 0 then return;
     1161 
     1162 	     do i = 1 to ecount;
     1163 		en = star_names (entries (i).nindex);
     1164 		if ALL_OLD (copy_dir, en) then do;
     1165 		     call hcs_$del_dir_tree (copy_dir, en, code);
     1166 		     call hcs_$delentry_file (copy_dir, en, code);
     1167 		end;
     1168 	     end;
     1169 
     1170 	     if eptr ^= null then free eptr -> entries in (area);
     1171 	     if nptr ^= null then free nptr -> star_names in (area);
     1172 
     1173 	end delete_old_copies;
     1174 						/*  */
     1175 ALL_OLD:	proc (DN, EN) returns (bit (1) aligned);
     1176 
     1177 /* This internal procedure, which calls itself recursively, returns ("1"b) if
     1178*   all segments below it are more than 2 weeks old. */
     1179 
     1180 dcl (DN, EN) char (*);
     1181 dcl  DIR_NAME char (168);
     1182 dcl  ENAME char (32);
     1183 dcl (EPTR, NPTR) ptr;
     1184 dcl (ECOUNT, I) fixed bin;
     1185 
     1186 	     call hcs_$status_ (DN, EN, 0, addr (branch_status), area_ptr, code);
     1187 	     if code ^= 0 then return ("0"b);
     1188 
     1189 	     if branch_status.type = segment_type | branch_status.type = link_type then
     1190 		if now - fixed (branch_status.date_time_modified || (16)"0"b, 52) > four_days then return ("1"b);
     1191 		else return ("0"b);
     1192 
     1193 	     else do;
     1194 		call hcs_$add_dir_acl_entries (DN, EN, addr (segment_acl), 1, code);
     1195 		EPTR, NPTR = null;
     1196 		on condition (cleanup) call free_names;
     1197 		DIR_NAME = rtrim (DN) || ">" || EN;
     1198 		call hcs_$star_ (DIR_NAME, "**", 3 /* all */, area_ptr, ECOUNT, EPTR, NPTR, code);
     1199 		if code ^= 0 then
     1200 		     if code = error_table_$nomatch then return ("1"b);
     1201 		     else return ("0"b);
     1202 		do I = 1 to ECOUNT;
     1203 		     ENAME = NPTR -> star_names (EPTR -> entries (I).nindex);
     1204 
     1205 		     if ^ALL_OLD (DIR_NAME, ENAME) then do;
     1206 			call free_names;
     1207 			return ("0"b);
     1208 		     end;
     1209 		end;
     1210 		call free_names;
     1211 		return ("1"b);
     1212 	     end;
     1213 
     1214 free_names:    proc;
     1215 
     1216 		if EPTR ^= null then free EPTR -> entries in (area);
     1217 		if NPTR ^= null then free NPTR -> star_names in (area);
     1218 
     1219 	     end free_names;
     1220 
     1221 	end ALL_OLD;
     1222 						/*  */
     1223 load_tape_entry: entry (tape_label);
     1224 
     1225 /* This entry point, called by backup_load_, returns carry_load's tape_number
     1226*   argument the first time it is called, -next_vol arguments succeeding times,
     1227*   and finally "" */
     1228 
     1229 dcl  tape_label char (32);
     1230 
     1231 	if use_first_tape then
     1232 	     if comment ^= "" then tape_label = rtrim (tape_number) || ",*" || translate (comment, ";", ",");
     1233 	     else tape_label = tape_number;
     1234 	else if next_vol_index <= next_vol_count then do;
     1235 	     tape_label = next_array.next_vol (next_vol_index);
     1236 	     if next_array.next_comment (next_vol_index) ^= "" then
     1237 		tape_label = rtrim (tape_label) || ",*" || translate (next_array.next_comment (next_vol_index), ";", ",");
     1238 	     next_vol_index = next_vol_index + 1;
     1239 	end;
     1240 	else tape_label = "";
     1241 	use_first_tape = "0"b;
     1242 	return;
     1243 						/*  */
     1244 warn:	proc (a_code, a_name, a_string);
     1245 
     1246 /* This internal procedure prints an error message on error_output without signalling
     1247*   in the case of an active function. In the case of a command, it calls com_err_.
     1248*   We don't want active function error messages to abort exec_com's. */
     1249 
     1250 dcl  a_code fixed bin (35);
     1251 dcl (a_name, a_string) char (*);
     1252 
     1253 	     if active_function then do;
     1254 		if a_name = "" then a_name = "carry_load";
     1255 		if a_code = 0 then call ioa_$ioa_switch (iox_$error_output, "^a: " || a_string, a_name);
     1256 		else do;
     1257 		     call convert_status_code_ (a_code, "", err_string);
     1258 		     call ioa_$ioa_switch (iox_$error_output, "^a: ^a  " || a_string, a_name, err_string);
     1259 		end;
     1260 	     end;
     1261 
     1262 	     else if a_name = "" then call com_err_$suppress_name (a_code, "carry_load", a_string);
     1263 	     else call com_err_ (a_code, a_name, a_string);
     1264 
     1265 	end warn;
     1266 
     1267 
     1268 clean_up:	proc;
     1269 
     1270 	     if tape_attached then do;
     1271 		call bk_input$input_finish;
     1272 		call iox_$find_iocb ("bk_input_1", bk_iocb, code);
     1273 		call iox_$close (bk_iocb, code);
     1274 		call iox_$detach_iocb (bk_iocb, code);
     1275 	     end;
     1276 	     if old_mail_iocb ^= null then call iox_$close (old_mail_iocb, code);
     1277 	     if old_mail_iocb ^= null then call iox_$detach_iocb (old_mail_iocb, code);
     1278 	     if new_mail_iocb ^= null then call iox_$close (new_mail_iocb, code);
     1279 	     if new_mail_iocb ^= null then call iox_$detach_iocb (new_mail_iocb, code);
     1280 	     if tape_log_iocb ^= null then call iox_$close (tape_log_iocb, code);
     1281 	     if tape_log_iocb ^= null then call iox_$detach_iocb (tape_log_iocb, code);
     1282 
     1283 	     call release_temp_segments_ ("carry_load", ptrs, code);
     1284 
     1285 	end clean_up;
     1286 
     1287 
     1288      end carry_load;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/09/85  1404.1  carry_load.pl1                    >spec>on>41-15>carry_load.pl1
71           1    11/21/83  1219.2  backup_control.incl.pl1           >ldd>include>backup_control.incl.pl1
151          2    11/22/82  0955.6  branch_status.incl.pl1            >ldd>include>branch_status.incl.pl1
152          3    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
153          4    04/27/78  1504.4  send_mail_info.incl.pl1           >ldd>include>send_mail_info.incl.pl1
154          5    04/09/85  1109.7  access_mode_values.incl.pl1       >spec>on>41-15>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BACKUP_CONTROL_VERSION_5        000062 constant        char(8)                  initial unaligned dcl 1-60 ref 404
DIGITS                          000056 constant        char(10)                 initial unaligned dcl 87 ref 631
DIR_NAME                        000100 automatic       char(168)                unaligned dcl 1181 set ref 1197* 1198* 1205*
DN                                     parameter       char                     unaligned dcl 1180 set ref 1175 1186* 1194* 1197
ECOUNT                          000166 automatic       fixed bin(17,0)          dcl 1184 set ref 1198* 1202
EN                                     parameter       char                     unaligned dcl 1180 set ref 1175 1186* 1194* 1197
ENAME                           000152 automatic       char(32)                 unaligned dcl 1182 set ref 1203* 1205*
EPTR                            000162 automatic       pointer                  dcl 1183 set ref 1195* 1198* 1203 1216 1216
I                               000167 automatic       fixed bin(17,0)          dcl 1184 set ref 1202* 1203*
NPTR                            000164 automatic       pointer                  dcl 1183 set ref 1195* 1198* 1203 1217 1217
ONE_DAY                         000002 constant        fixed bin(71,0)          initial dcl 134 ref 514
ONE_HOUR                        000000 constant        fixed bin(71,0)          initial dcl 135 ref 1135
SMA_ACCESS_BIN                         constant        fixed bin(5,0)           initial dcl 5-36 ref 595
WHITE_SPACE                            constant        char(2)                  initial unaligned dcl 86 ref 626 1101 1108
a_code                                 parameter       fixed bin(35,0)          dcl 1250 set ref 1244 1255 1257* 1262* 1263*
a_name                                 parameter       char                     unaligned dcl 1251 set ref 1244 1254 1254* 1255*
                                                                                  1258* 1262 1263*
a_string                               parameter       char                     unaligned dcl 1251 set ref 1244 1255 1258 1262*
                                                                                  1263*
absolute_pathname_              000560 constant        entry                    external dcl 166 ref 264 287 651 713
access_name                     012066 automatic       char(32)                 array level 2 packed unaligned dcl 139 set ref 476*
                                                                                  691* 1038* 1149*
active_fnc_err_                 000562 constant        entry                    external dcl 167 ref 306
active_fnc_err_$suppress_name   000564 constant        entry                    external dcl 167 ref 228
active_function                 011760 automatic       bit(1)                   dcl 115 set ref 221* 223* 228 306 323* 340* 543 790
                                                                                  1034 1253
addr                                                   builtin function         dcl 212 ref 479 479 494 494 528 528 581 581 611 611
                                                                                  619 622 622 693 693 913 913 926 926 927 927 934
                                                                                  934 942 942 944 944 946 946 1040 1040 1042 1042
                                                                                  1045 1045 1047 1047 1071 1071 1124 1124 1186 1186
                                                                                  1194 1194
adjust_bit_count_               000566 constant        entry                    external dcl 168 ref 450 480
always_add               11(02) 012132 automatic       bit(1)                   level 3 packed unaligned dcl 4-5 set ref 1056*
answer                          011464 automatic       varying char(300)        dcl 100 set ref 622* 626* 626 627 1100 1101 1103
                                                                                  1104* 1107 1108* 1108
answer_iocbp              6     012114 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
area                                   based           area(1024)               dcl 137 ref 1155 1156 1170 1171 1216 1217
area_ptr                        012010 automatic       pointer                  dcl 122 set ref 1052* 1062* 1152* 1155 1156 1159*
                                                                                  1170 1171 1186* 1198* 1216 1217
arg                                    based           char                     unaligned dcl 96 set ref 244 244 244 246 247 247 255
                                                                                  257 257 264* 266* 270 270 277 278 280 280 287*
                                                                                  289* 293 293 301 306* 307* 314 357 360 363 363 371
                                                                                  374* 377 378 379 706 706 706 706 706 713* 715*
                                                                                  722* 727*
arg_count                       012033 automatic       fixed bin(17,0)          dcl 127 set ref 220* 227 240 249 259 272 282 295
                                                                                  326* 327 343* 344 355 365 704
arg_len                         012034 automatic       fixed bin(17,0)          dcl 127 set ref 242* 244 244 244 246 247 247 254*
                                                                                  255 257 257 263* 264 264 266 266 270 270 276* 277
                                                                                  278 280 280 286* 287 287 289 289 293 293 299* 301
                                                                                  306 306 307 307 314 356* 357 360 363 363 369* 371
                                                                                  374 374 377 378 379 705* 706 706 706 706 706 711*
                                                                                  713 713 715 715 722 722 727 727
arg_ptr                         012012 automatic       pointer                  dcl 122 set ref 242* 244 244 244 246 247 247 254*
                                                                                  255 257 257 263* 264 266 270 270 276* 277 278 280
                                                                                  280 286* 287 289 293 293 299* 301 306 307 314 356*
                                                                                  357 360 363 363 369* 371 374 377 378 379 705* 706
                                                                                  706 706 706 706 711* 713 715 722 727
backup_control                         based           structure                level 1 dcl 1-8
backup_load_                    000570 constant        entry                    external dcl 169 ref 432 751 1007
bk_input$input_finish           000572 constant        entry                    external dcl 170 ref 1002 1271
bk_iocb                         011774 automatic       pointer                  initial dcl 120 set ref 120* 1272* 1273* 1274*
bk_ss_$holdsw                   000574 external static bit(1)                   dcl 171 set ref 1001*
branch_status                   012101 automatic       structure                level 1 dcl 2-1 set ref 1124 1124 1186 1186
buffer                          011072 automatic       char(500)                unaligned dcl 99 set ref 494 494 494 494 496 497 500
                                                                                  500 504 512 512 516* 518 518 522 522 528 528 528
                                                                                  528 538 548 548 549 551 553 554 559 564 576 581
                                                                                  581 581 581 583 585 585 611 611 611 611 681* 682
                                                                                  850* 851* 853 881 885 913 913 913 913 921 921 926
                                                                                  926 942 942 944 944 946 946 946 946
buffer_len                      012035 automatic       fixed bin(17,0)          dcl 127 set ref 494* 500 500 512 512 516* 518 518
                                                                                  522 522 528* 538 548 548 553 553* 553 554 556* 556
                                                                                  559 561* 561 564 581* 583 585 585 611* 681* 913*
                                                                                  926* 942* 944* 946*
cleanup                         012144 stack reference condition                dcl 215 ref 390 1154 1196
clock                                                  builtin function         dcl 212 ref 514 1135 1147
code                            012056 automatic       fixed bin(35,0)          dcl 132 set ref 220* 221 242* 254* 263* 264* 265
                                                                                  266* 276* 286* 287* 288 289* 299* 305* 306* 307*
                                                                                  326* 343* 356* 369* 394* 395 396* 432* 434 440
                                                                                  441* 450* 451* 454* 456* 460 461* 479* 480* 482*
                                                                                  483 484* 487* 488 489* 494* 495 512* 513 528* 536
                                                                                  578* 579 581* 582 591* 593* 595 595 595 595 605
                                                                                  611* 651* 652 653* 656* 689* 690 693* 694* 695*
                                                                                  705* 711* 712 713* 714 715* 727* 728 751* 753 755
                                                                                  756* 836* 839 847* 850 853* 868 871* 878 880* 881
                                                                                  897* 898 902* 904 905* 906 907* 909 910* 911 913*
                                                                                  915 926* 927* 934* 942* 944* 946* 949* 950* 951*
                                                                                  952* 954* 1007* 1022* 1039* 1040* 1041 1041* 1042*
                                                                                  1045* 1047* 1062* 1067* 1071* 1073* 1075* 1124*
                                                                                  1126 1126 1131 1146* 1159* 1160 1165* 1166* 1186*
                                                                                  1187 1194* 1198* 1199 1199 1272* 1273* 1274* 1276*
                                                                                  1277* 1278* 1279* 1280* 1281* 1283*
com_err_                        000576 constant        entry                    external dcl 172 ref 307 366 374 441 445 634 641 648
                                                                                  653 660 666 715 722 782 1024 1027 1263
com_err_$suppress_name          000600 constant        entry                    external dcl 172 ref 230 328 345 1262
command                         011042 automatic       char(32)                 unaligned dcl 95 set ref 217* 322* 339* 366* 373 382
                                                                                  394* 396* 410 413 435* 441* 445* 461* 466* 469*
                                                                                  484* 489* 499* 507* 518* 700 756* 770 969
command_query_                  000602 constant        entry                    external dcl 173 ref 622
comment                         000010 internal static char(32)                 unaligned dcl 105 set ref 235* 277* 351* 1231 1231
control_ptr                     012026 automatic       pointer                  initial dcl 124 set ref 124* 400* 404 405 406 407
                                                                                  408 410 411 417 420 421 426 428 432* 444 445 465
                                                                                  466 469 530 538 547 552 560 563 576 577 583 606
                                                                                  608 656 657 670 682 683 685 702 718 726 729 730
                                                                                  731 737 744 744 745 747 751* 763 763 763 763 768
                                                                                  772 774 775 775 775 779 780 781 782 782 792 797
                                                                                  799 801 801 806 808 810 811 812 817 819 820 836
                                                                                  837 856 856 858 863 863 863 866 925 961 963 963
                                                                                  977 978 984 985 987 989 1005 1007* 1019 1021 1022
                                                                                  1022 1024 1024 1027 1027 1027 1027 1032 1039 1041
                                                                                  1121 1122 1127 1128
convert_date_to_binary_         000604 constant        entry                    external dcl 174 ref 512 1146
convert_status_code_            000606 constant        entry                    external dcl 175 ref 880 1257
copies_omitted                  012036 automatic       fixed bin(17,0)          dcl 127 set ref 1015* 1031* 1031 1032 1033 1082
                                                                                  1083* 1084
copy_dir                        000152 automatic       char(168)                initial unaligned dcl 84 set ref 84* 287* 828 830
                                                                                  832 936* 1159* 1164* 1165* 1166*
copy_path               105            based           char(168)                array level 2 packed unaligned dcl 72 set ref 829*
                                                                                  936 938* 987
copy_path_array                 000224 automatic       char(168)                array unaligned dcl 89 set ref 1032* 1085*
copy_sender_array               004310 automatic       char(168)                array unaligned dcl 90 set ref 1033* 1085*
copy_sw                 104            based           bit(1)                   array level 2 dcl 72 set ref 818* 982
cp_escape_control         1(02) 012114 automatic       bit(2)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
cu_$af_return_arg               000612 constant        entry                    external dcl 177 ref 220
cu_$arg_count                   000610 constant        entry                    external dcl 176 ref 326 343
cu_$arg_ptr                     000614 constant        entry                    external dcl 178 ref 242 254 263 276 286 299 356 369
                                                                                  705 711
cu_$level_get                   000616 constant        entry                    external dcl 179 ref 526
cv_dec_                         000620 constant        entry                    external dcl 180 ref 632
date_time_modified        1     012101 automatic       bit(36)                  level 2 packed unaligned dcl 2-1 set ref 1133 1189
days                            012037 automatic       fixed bin(17,0)          dcl 127 set ref 514* 515 516*
debug_sw                 36(01)        based           bit(1)                   level 4 packed unaligned dcl 1-8 set ref 407*
destination                     011723 automatic       char(23)                 unaligned dcl 104 set ref 504* 505 507
divide                                                 builtin function         dcl 212 ref 454 454 514 1069
dn                              010374 automatic       char(168)                unaligned dcl 94 set ref 578* 591* 593* 629* 631
                                                                                  632* 639 639 645* 647 651* 651* 653* 657 727* 729
                                                                                  780* 781 781* 782* 819* 820 820* 821 823 824 824*
                                                                                  824 828* 828 829 830 832 895* 897* 902 907 954*
                                                                                  1039* 1040* 1041* 1045* 1047*
ds_arg                          011731 automatic       char(23)                 unaligned dcl 104 set ref 255* 505 507
ds_sw                           011761 automatic       bit(1)                   dcl 115 set ref 236* 253* 350* 505
dtm72                           011756 automatic       bit(72)                  unaligned dcl 114 set ref 1132* 1133* 1134
ecount                          012040 automatic       fixed bin(17,0)          dcl 127 set ref 1060* 1062* 1064 1155 1159* 1162
                                                                                  1170 1216
en                              011052 automatic       char(32)                 unaligned dcl 95 set ref 578* 583 600 656* 657 718
                                                                                  727* 729 1039* 1045* 1047* 1163* 1164* 1165* 1166*
entries                                based           structure                array level 1 dcl 145 ref 1155 1170 1216
eptr                            012004 automatic       pointer                  initial dcl 121 set ref 121* 1062* 1066 1153* 1155
                                                                                  1155 1159* 1163 1170 1170
err_string                      011600 automatic       char(100)                unaligned dcl 101 set ref 878* 880* 885* 890* 1257*
                                                                                  1258*
error_line                      011267 automatic       char(500)                unaligned dcl 99 set ref 881* 885* 887* 890* 927 927
                                                                                  933 934 934
error_line_len                  012041 automatic       fixed bin(17,0)          dcl 127 set ref 881* 885* 887* 890* 927* 933* 934*
error_name              170            based           char(65)                 array level 3 packed unaligned dcl 1-8 set ref 782*
                                                                                  812* 837
error_path                      010446 automatic       char(168)                unaligned dcl 94 set ref 848* 853 856* 858* 859*
                                                                                  863* 866* 868 871* 881* 885* 887* 890* 922 931*
error_table_$badopt             000534 external static fixed bin(35,0)          dcl 155 set ref 305 374* 722*
error_table_$end_of_info        000536 external static fixed bin(35,0)          dcl 156 ref 536 915
error_table_$incorrect_access   000540 external static fixed bin(35,0)          dcl 157 ref 878 1024
error_table_$no_dir             000546 external static fixed bin(35,0)          dcl 160 ref 595 1126
error_table_$noentry            000542 external static fixed bin(35,0)          dcl 158 ref 595 690 801 811 868 1126
error_table_$nomatch            000544 external static fixed bin(35,0)          dcl 159 ref 1199
error_table_$not_act_fnc        000550 external static fixed bin(35,0)          dcl 161 ref 221
error_table_$not_attached       000552 external static fixed bin(35,0)          dcl 162 ref 434 753
error_table_$request_pending    000554 external static fixed bin(35,0)          dcl 163 ref 1128
error_table_$rqover             000556 external static fixed bin(35,0)          dcl 164 ref 1022
expand_pathname_                000622 constant        entry                    external dcl 181 ref 578 656 727 1039
explanation_len          14     012114 automatic       fixed bin(21,0)          initial level 2 dcl 3-7 set ref 620* 3-7*
explanation_ptr          12     012114 automatic       pointer                  initial level 2 dcl 3-7 set ref 619* 3-7*
first                    36(06)        based           bit(1)                   level 4 packed unaligned dcl 1-8 set ref 408*
fixed                                                  builtin function         dcl 212 ref 1189
force_sw                        011763 automatic       bit(1)                   dcl 115 set ref 236* 244* 341* 515
found                   165            based           bit(1)                   array level 3 dcl 1-8 set ref 763 763 775* 817 863
found_sw                        011762 automatic       bit(1)                   dcl 115 set ref 900* 917 924*
four_days                       012064 automatic       fixed bin(71,0)          dcl 133 set ref 1146* 1189
get_group_id_                   000624 constant        entry                    external dcl 182 ref 691 1149
get_pdir_                       000626 constant        entry                    external dcl 183 ref 424
get_system_free_area_           000630 constant        entry                    external dcl 184 ref 1052 1152
get_temp_segments_              000632 constant        entry                    external dcl 185 ref 394
got_path                        011764 automatic       bit(1)                   dcl 115 set ref 350* 362* 386
got_tape                        011765 automatic       bit(1)                   dcl 115 set ref 236* 311 313* 317 350* 357 359* 383
hcs_$add_acl_entries            000634 constant        entry                    external dcl 186 ref 479 1047
hcs_$add_dir_acl_entries        000636 constant        entry                    external dcl 187 ref 693 1040 1042 1045 1194
hcs_$chname_file                000640 constant        entry                    external dcl 188 ref 897
hcs_$del_dir_tree               000642 constant        entry                    external dcl 189 ref 694 1165
hcs_$delentry_file              000644 constant        entry                    external dcl 190 ref 456 695 954 1022 1166
hcs_$get_user_effmode           000646 constant        entry                    external dcl 191 ref 591 593
hcs_$initiate_count             000650 constant        entry                    external dcl 192 ref 451 1067
hcs_$star_                      000652 constant        entry                    external dcl 193 ref 1062 1159 1198
hcs_$status_                    000654 constant        entry                    external dcl 194 ref 1124 1186
hcs_$status_minf                000656 constant        entry                    external dcl 195 ref 689
hcs_$terminate_noname           000660 constant        entry                    external dcl 196 ref 1075
header                                 based           structure                level 2 dcl 1-8
hold_sw                  36(03)        based           bit(1)                   level 4 packed unaligned dcl 1-8 set ref 410* 411*
                                                                                  1005*
i                                      parameter       fixed bin(17,0)          dcl 1118 in procedure "really_look" ref 1114 1121
                                                                                  1122 1127 1128
i                               012042 automatic       fixed bin(17,0)          dcl 128 in procedure "carry_load" set ref 240* 242*
                                                                                  248* 248 249 254* 258* 258 259 263* 271* 271 272
                                                                                  276* 281* 281 282 286* 294* 294 295 299* 355* 356*
                                                                                  364* 364 365 369* 497* 498 504 511* 511 512 512
                                                                                  512 512 549* 550 564 564 576 669* 670 670* 704*
                                                                                  705* 710* 710 711* 739* 744 744 745* 762* 763 763
                                                                                  763 763* 772* 774 775 775 775 779 780 781 782 782*
                                                                                  797* 799 799* 801 801 806 806 806 808 808 810 811
                                                                                  812 817 818 819 820 829 831 832 836 837 846 847
                                                                                  848 856 856 858 863 863 863 866 881 893 894 925
                                                                                  936 938* 961* 963 963 963* 980* 982 985 987 991
                                                                                  993 995* 1017* 1019 1019* 1021 1022 1022 1024 1024
                                                                                  1027 1027 1027 1027 1032 1033 1036 1037 1039 1041
                                                                                  1042 1042 1045* 1064* 1066* 1084* 1085 1085* 1101*
                                                                                  1102 1107 1108 1162* 1163*
incacc_code             103            based           fixed bin(35,0)          array level 2 dcl 72 set ref 605* 847
incacc_sw               102            based           bit(1)                   array level 2 dcl 72 set ref 604* 806 846 881
index                                                  builtin function         dcl 212 ref 496 497 549 565 821 823 824 830 921 1038
                                                                                  1072
info_ptr                        012030 automatic       pointer                  initial dcl 124 set ref 124* 401* 551 574 575 595
                                                                                  604 605 606 806 806 808 818 829 831 832 846 847
                                                                                  848 881 893 894 936 938 963 982 985 987 991 991
                                                                                  993 993 995 995 1033 1036 1037 1042 1042 1045
ioa_                            000662 constant        entry                    external dcl 197 ref 453 455 522 542 1079 1080 1083
                                                                                  1085
ioa_$ioa_switch                 000664 constant        entry                    external dcl 197 ref 500 501 775 859 931 936 938 963
                                                                                  1255 1258
ioa_$nnl                        000666 constant        entry                    external dcl 197 ref 548 585
ioa_$rs                         000670 constant        entry                    external dcl 197 ref 881 885 887 890
ioa_$rsnnl                      000672 constant        entry                    external dcl 197 ref 419 425 516 681 895 1058
iox_$attach_name                000674 constant        entry                    external dcl 198 ref 482 902 907
iox_$close                      000676 constant        entry                    external dcl 199 ref 949 951 1273 1276 1278 1280
iox_$detach_iocb                000700 constant        entry                    external dcl 200 ref 950 952 1274 1277 1279 1281
iox_$error_output               000702 external static pointer                  dcl 201 set ref 500* 501* 775* 859* 963* 1255* 1258*
iox_$find_iocb                  000704 constant        entry                    external dcl 202 ref 1272
iox_$get_line                   000706 constant        entry                    external dcl 203 ref 494 528 581 611 913 946
iox_$open                       000710 constant        entry                    external dcl 204 ref 487 905 910
iox_$put_chars                  000712 constant        entry                    external dcl 205 ref 454 926 927 934 942 944
iox_$user_output                000714 external static pointer                  dcl 206 set ref 454*
j                               012043 automatic       fixed bin(17,0)          dcl 128 set ref 496* 504 504 565* 566 571 572 821*
                                                                                  822 823 824 824 830* 831 832 1072* 1073 1073 1073
                                                                                  1073
k                               012044 automatic       fixed bin(17,0)          dcl 128 set ref 823* 824 824 824
length                                                 builtin function         dcl 212 ref 494 494 528 528 581 581 591 611 611 620
                                                                                  830 832 913 913 933 946 946
level                           012045 automatic       fixed bin(17,0)          dcl 128 set ref 526* 591* 593*
link_type                              constant        bit(2)                   initial dcl 2-1 ref 1189
literal_sw                1(05) 012114 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
loaded                  166            based           bit(1)                   array level 3 dcl 1-8 set ref 444 465 775 792 799
                                                                                  801 925 963 1019 1021 1041 1127*
ltrim                                                  builtin function         dcl 212 ref 626 1108
mail_dir_path                   010520 automatic       char(168)                unaligned dcl 94 set ref 1058* 1062* 1067*
mail_seg                               based           char                     unaligned dcl 98 set ref 1071*
mail_seg_bc                     012054 automatic       fixed bin(24,0)          dcl 131 set ref 1067* 1069
mail_seg_len                    012053 automatic       fixed bin(17,0)          dcl 130 set ref 1069* 1071 1071
mail_seg_ptr                    012014 automatic       pointer                  dcl 122 set ref 1067* 1068 1071 1075*
mail_sw                         011766 automatic       bit(1)                   dcl 116 set ref 792* 793* 874
min                                                    builtin function         dcl 213 ref 500 500
mode                            012032 automatic       fixed bin(5,0)           dcl 126 set ref 591* 593* 595
modes                    10     012066 automatic       bit(36)                  array level 2 dcl 139 set ref 477* 692* 1014* 1150*
name_string                     011662 automatic       char(65)                 unaligned dcl 102 set ref 837* 839 839 839 855 868*
                                                                                  871* 887 890*
new_dir_sw                      011767 automatic       bit(1)                   dcl 116 set ref 555* 558* 580
new_dn                          010572 automatic       char(168)                unaligned dcl 94 set ref 713* 718
new_mail_iocb                   011776 automatic       pointer                  initial dcl 120 set ref 120* 907* 910* 926* 927*
                                                                                  931* 934* 936* 938* 942* 944* 949* 950* 1278 1278*
                                                                                  1279 1279*
new_path                112            based           char(168)                array level 3 packed unaligned dcl 1-8 set ref 426*
                                                                                  428* 577* 583* 657* 683* 718* 730* 780 819 856 856
                                                                                  863 863 987* 1022* 1024* 1027* 1032 1121
new_user                 10            based           char(32)                 array level 2 packed unaligned dcl 72 set ref 575*
                                                                                  893 993* 993 1036
new_user_id                     011703 automatic       char(32)                 unaligned dcl 103 set ref 568* 572* 575
newline                         017502 constant        char(1)                  initial unaligned dcl 106 ref 553
next_array                      000030 internal static structure                array level 1 packed unaligned dcl 108
next_comment             10     000030 internal static char(32)                 array level 2 packed unaligned dcl 108 set ref 278*
                                                                                  302* 1236 1236
next_vol                        000030 internal static char(32)                 array level 2 packed unaligned dcl 108 set ref 301*
                                                                                  371* 1235
next_vol_count                  000531 internal static fixed bin(17,0)          dcl 129 set ref 237* 277 278 300* 300 301 302 352*
                                                                                  370* 370 371 1234
next_vol_index                  000532 internal static fixed bin(17,0)          dcl 129 set ref 238* 353* 1234 1235 1236 1236 1238*
                                                                                  1238
nindex                    0(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 145 ref 1066 1163
                                                                                  1203
no_primary_sw           164            based           bit(1)                   array level 4 packed unaligned dcl 1-8 set ref 417*
                                                                                  552* 731* 745*
no_reload_sw             36(02)        based           bit(1)                   level 4 packed unaligned dcl 1-8 set ref 737*
now                             012060 automatic       fixed bin(71,0)          dcl 133 set ref 1147* 1189
nptr                            012006 automatic       pointer                  initial dcl 121 set ref 121* 1062* 1066 1153* 1156
                                                                                  1156 1159* 1163 1171 1171
null                                                   builtin function         dcl 213 ref 120 120 120 120 121 121 124 124 482 482
                                                                                  902 902 907 907 1068 3-7 3-7 3-7 1124 1124 1153
                                                                                  1155 1156 1170 1171 1195 1216 1217 1276 1277 1278
                                                                                  1279 1280 1281
number_omitted                  012046 automatic       fixed bin(17,0)          dcl 128 set ref 531* 804* 804 1080 1080* 1080
old_mail_iocb                   012000 automatic       pointer                  initial dcl 120 set ref 120* 902* 905* 913* 946*
                                                                                  951* 952* 1276 1276* 1277 1277*
options                  36            based           structure                level 3 dcl 1-8 set ref 406*
padding                   1(07) 012114 automatic       bit(29)                  initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
path                            012264 automatic       char(168)                unaligned dcl 1119 in procedure "really_look" set
                                                                                  ref 1121* 1122 1122* 1124*
path                     40            based           char(168)                array level 3 in structure "backup_control" packed
                                                                                  unaligned dcl 1-8 in procedure "carry_load" set
                                                                                  ref 421* 576* 606 608* 656* 670* 682* 729* 774
                                                                                  775* 781 806* 808 820 858 866 963* 985* 1039* 1122
path                     30            based           char(168)                array level 2 in structure "request_info" packed
                                                                                  unaligned dcl 72 in procedure "carry_load" set ref
                                                                                  606* 806 808* 848 985
print_log_sw                    011770 automatic       bit(1)                   dcl 116 set ref 218* 324* 387* 423 439
process_dir                     010644 automatic       char(168)                unaligned dcl 94 set ref 424* 425* 450
program_interrupt               012152 stack reference condition                dcl 215 ref 533
prompt_after_explanation
                          1(06) 012114 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
ptrs                            012022 automatic       pointer                  array dcl 123 set ref 394* 400 401 1283*
query_code                3     012114 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
query_explanation               000004 constant        char(168)                initial unaligned dcl 92 set ref 619 620
query_info                      012114 automatic       structure                level 1 dcl 3-7 set ref 616* 622 622
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 3-35 ref 617
question_iocbp            4     012114 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
queue_dir                       000100 automatic       char(168)                initial unaligned dcl 83 set ref 83* 264* 419* 480
                                                                                  681* 689* 693* 694* 695* 895* 1058*
records                   3(18) 012101 automatic       bit(18)                  level 2 packed unaligned dcl 2-1 set ref 1136
release_temp_segments_          000716 constant        entry                    external dcl 207 ref 1283
repeat_time              10     012114 automatic       fixed bin(71,0)          initial level 2 dcl 3-7 set ref 3-7*
request_count                   012047 automatic       fixed bin(17,0)          dcl 128 in procedure "carry_load" set ref 530* 547
                                                                                  547* 548* 551 552 560 563 574 575 576 577 583 595
                                                                                  604 605 606 606 608 633 665 669 682 683 685 685*
                                                                                  702* 706 718 726 726* 729 730 731 739 744 745 747
                                                                                  762 763 763 768 792 978* 984 984* 985 987 989 991
                                                                                  993 995 1000 1017
request_count            37            based           fixed bin(17,0)          level 3 in structure "backup_control" dcl 1-8
                                                                                  in procedure "carry_load" set ref 417 420* 530*
                                                                                  538 547* 685* 702* 726* 747* 768* 772 797 961 977
                                                                                  978* 984*
request_index                   012050 automatic       fixed bin(17,0)          dcl 128 set ref 625* 632* 633 633 634* 637 640 656
                                                                                  657
request_info                           based           structure                array level 1 dcl 72
request_path                    010716 automatic       char(168)                unaligned dcl 94 set ref 576* 578* 583* 921* 922
requests                 40            based           structure                array level 2 dcl 1-8 set ref 744* 744 763* 763
retrieve_array                  011737 automatic       bit(1)                   array unaligned dcl 112 set ref 624* 637* 665 670
return_len                      012051 automatic       fixed bin(17,0)          dcl 128 set ref 220* 224 543 790 1034
return_ptr                      012016 automatic       pointer                  dcl 122 set ref 220* 224 543 790 1034
return_string                          based           varying char             dcl 97 set ref 224* 543* 790* 1034*
rtrim                                                  builtin function         dcl 213 ref 435 450 461 466 469 480 489 507 507 591
                                                                                  593 620 631 657 718 729 756 828 830 832 853 868
                                                                                  902 907 933 1197 1231 1236
saved_request_count             012052 automatic       fixed bin(17,0)          dcl 128 set ref 977* 980
search                                                 builtin function         dcl 213 ref 1101
segment_acl                     012066 automatic       structure                array level 1 dcl 139 set ref 479 479 693 693 1040
                                                                                  1040 1042 1042 1045 1045 1047 1047 1194 1194
segment_type                           constant        bit(2)                   initial dcl 2-1 ref 1189
select_sw                       011771 automatic       bit(1)                   dcl 116 set ref 218* 350* 378* 379* 386 387 410 413
                                                                                  452 522 533 548 585 588 614
send_mail_                      000720 constant        entry                    external dcl 208 ref 1071
send_mail_info                  012132 automatic       structure                level 1 dcl 4-5 set ref 1071 1071
send_mail_info_version_2        012131 automatic       fixed bin(17,0)          initial dcl 4-3 set ref 4-3*
send_message_$notify_mail       000722 constant        entry                    external dcl 209 ref 1073
sender                                 based           char(32)                 array level 2 packed unaligned dcl 72 set ref 574*
                                                                                  894 991* 991 1033 1037
sender_id                       011713 automatic       char(32)                 unaligned dcl 103 set ref 567* 571* 574 591 591 591*
                                                                                  593 893* 894 894* 897* 897* 907 1036* 1037 1037*
                                                                                  1038 1038 1066* 1067* 1071* 1072 1073 1073 1073
                                                                                  1073
sender_string                   011631 automatic       char(100)                unaligned dcl 101 set ref 564* 565 567 571 572
sent_from                 1     012132 automatic       char(32)                 level 2 dcl 4-5 set ref 1054*
star_names                             based           char(32)                 array dcl 150 ref 1066 1156 1163 1171 1203 1217
status_code               2     012114 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 3-7
                                                                                  in procedure "carry_load" set ref 3-7*
status_code             167            based           fixed bin(35,0)          array level 3 in structure "backup_control" dcl 1-8
                                                                                  in procedure "carry_load" set ref 445* 466 469*
                                                                                  779 782* 801 810 811* 836 989* 1022 1024 1027
                                                                                  1027* 1027 1128*
substr                                                 builtin function         dcl 213 set ref 244 357 500 500 504 512 512 518 518
                                                                                  522 522 538 548 548 551 553 554 559 564 571 572
                                                                                  576 583 585 585 591 665 706 821 823 824 824 830
                                                                                  832 921 1038 1073 1073 1073 1073 1107 1108 1133*
suppress_name_sw          1(01) 012114 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  618* 3-7*
suppress_spacing          1(04) 012114 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
switches                  1     012114 automatic       structure                level 2 in structure "query_info" dcl 3-7
                                                                                  in procedure "carry_load"
switches                164            based           structure                array level 3 in structure "backup_control" dcl 1-8
                                                                                  in procedure "carry_load"
switches                 11     012132 automatic       structure                level 2 in structure "send_mail_info" dcl 4-5
                                                                                  in procedure "carry_load" set ref 1055*
tape_attached                   011773 automatic       bit(1)                   initial dcl 118 set ref 118* 430* 674* 734* 1010*
                                                                                  1270
tape_entry                2            based           entry variable           level 3 dcl 1-8 set ref 405*
tape_label                             parameter       char(32)                 unaligned dcl 1229 set ref 1223 1231* 1233* 1235*
                                                                                  1236* 1236 1240*
tape_log_bc                     012055 automatic       fixed bin(24,0)          dcl 131 set ref 450* 451* 454 454
tape_log_iocb                   012002 automatic       pointer                  initial dcl 120 set ref 120* 482* 487* 494* 528*
                                                                                  581* 611* 1280 1280* 1281 1281*
tape_log_path                   010770 automatic       char(168)                unaligned dcl 94 set ref 419* 421 425* 426 441* 445*
                                                                                  451* 456* 461 466 469 479* 482 484 489 499
tape_log_ptr                    012020 automatic       pointer                  dcl 122 set ref 451* 454*
tape_number                     000020 internal static char(32)                 unaligned dcl 105 set ref 314* 360* 419* 425* 435
                                                                                  450 480 756 931* 1231 1233
temp_en                         011062 automatic       char(32)                 unaligned dcl 95 set ref 589* 591* 593* 595 595 600*
                                                                                  896* 897* 902 954*
test_sw                         011772 automatic       bit(1)                   dcl 116 set ref 236* 246* 350* 377* 737
time_written                    012062 automatic       fixed bin(71,0)          dcl 133 set ref 512* 514 1134* 1135
token                           012204 automatic       char(168)                unaligned dcl 1098 set ref 1103* 1107* 1110
translate                                              builtin function         dcl 213 ref 1231 1236
trim_sw                 164(01)        based           bit(1)                   array level 4 packed unaligned dcl 1-8 set ref 560*
                                                                                  563*
type                            012101 automatic       bit(2)                   level 2 packed unaligned dcl 2-1 set ref 1189 1189
type_string              20            based           char(32)                 array level 2 packed unaligned dcl 72 set ref 551*
                                                                                  595 963* 995* 995 1045
unique_chars_                   000724 constant        entry                    external dcl 210 ref 896
unspec                                                 builtin function         dcl 213 set ref 406* 616* 624* 665 936 1055* 1134*
                                                                                  1134
use_first_tape                  000530 internal static bit(1)                   dcl 117 set ref 403* 1231 1241*
user_dir                157            based           char(168)                array level 2 packed unaligned dcl 72 set ref 831*
                                                                                  832* 1042 1042*
verify                                                 builtin function         dcl 213 ref 631
version                         012132 automatic       fixed bin(17,0)          level 2 in structure "send_mail_info" dcl 4-5
                                                                                  in procedure "carry_load" set ref 1053*
version                         012114 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 3-7
                                                                                  in procedure "carry_load" set ref 617*
version                                based           char(8)                  level 3 in structure "backup_control" packed
                                                                                  unaligned dcl 1-8 in procedure "carry_load" set
                                                                                  ref 404*
yes_or_no_sw              1     012114 automatic       bit(1)                   initial level 3 packed unaligned dcl 3-7 set ref
                                                                                  3-7*
zero_pad                 11     012066 automatic       bit(36)                  array level 2 dcl 139 set ref 478*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 5-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 5-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 5-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 5-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 5-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 5-36
backup_control_ptr                     automatic       pointer                  dcl 1-56
backup_control_request_count           automatic       fixed bin(17,0)          dcl 1-58
directory_type                         internal static bit(2)                   initial dcl 2-1
msf_type                               internal static bit(2)                   initial dcl 2-1
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 3-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 3-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 3-36

NAMES DECLARED BY EXPLICIT CONTEXT.
ALL_OLD                         015300 constant        entry                    internal dcl 1175 ref 1164 1205
BADPATH                         007624 constant        label                    dcl 715 ref 728
CLOSE_OLD                       012547 constant        label                    dcl 951 ref 909
COMMON                          003215 constant        label                    dcl 390 ref 318
DETACH_NEW                      012536 constant        label                    dcl 950 ref 911
DETACH_OLD                      012560 constant        label                    dcl 952 ref 906
GET_ARGS                        002731 constant        label                    dcl 350 ref 332
GET_MODE                        006102 constant        label                    dcl 591 ref 601
MAIL_END                        012612 constant        label                    dcl 955 ref 898 904
NEXT_LINE                       006313 constant        label                    dcl 611 ref 579 588
NOT_THERE                       014714 constant        label                    dcl 1127 ref 1135 1136
NO_TAPE                         003533 constant        label                    dcl 435 ref 753
PARSE_ERROR                     004730 constant        label                    dcl 499 ref 513 550
QUERY                           006364 constant        label                    dcl 622 ref 635 642 649 654 662
QUERY_INIT                      006341 constant        label                    dcl 616 ref 533
READ                            004343 constant        label                    dcl 476 ref 452
READ_ERROR                      004604 constant        label                    dcl 489 ref 495
RELOAD                          010123 constant        label                    dcl 739 ref 676
RETRIEVE                        007473 constant        label                    dcl 700 ref 413
RETURN                          014316 constant        label                    dcl 1089 ref 436 442 447 457 463 471 485 491 502 509
                                                                                  519 544 667 716 723 757 787 969
USAGE                           001464 constant        label                    dcl 228 ref 311 317
USAGE2                          002610 constant        label                    dcl 328 ref 383
USAGE3                          002675 constant        label                    dcl 345 ref 386 706 712
carry_load                      001411 constant        entry                    external dcl 11
carry_map                       002561 constant        entry                    external dcl 320
carry_retrieve                  002645 constant        entry                    external dcl 337
clean_up                        016214 constant        entry                    internal dcl 1268 ref 390 1089
delete_old_copies               014753 constant        entry                    internal dcl 1141 ref 973
free_names                      015721 constant        entry                    internal dcl 1214 ref 1196 1206 1210
get_token                       014515 constant        entry                    internal dcl 1093 ref 629 645
load_tape_entry                 014326 constant        entry                    external dcl 1223 ref 405
really_look                     014621 constant        entry                    internal dcl 1114 ref 799 1019
warn                            015746 constant        entry                    internal dcl 1244 ref 250 260 266 273 283 289 296
                                                                                  396 435 461 466 469 484 489 499 507 518 756 853
                                                                                  868 871 1041

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     20500       21426   17511       20510
Length     22174   17511       726         532     766         524

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
carry_load                         5900 external procedure  is an external procedure.  
on unit on line 390                  64 on unit               
on unit on line 533                  64 on unit               
get_token                               internal procedure  shares stack frame of external procedure carry_load.  
really_look                             internal procedure  shares stack frame of external procedure carry_load.  
delete_old_copies                   124 internal procedure  enables or reverts conditions.  
on unit on line 1154                 64 on unit               
ALL_OLD                             194 internal procedure  enables or reverts conditions.  
on unit on line 1196                 64 on unit               
free_names                           64 internal procedure  is called by several nonquick procedures.  
warn                                102 internal procedure  is called during a stack extension.  
clean_up                             82 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 comment                     carry_load
000020 tape_number                 carry_load
000030 next_array                  carry_load
000530 use_first_tape              carry_load
000531 next_vol_count              carry_load
000532 next_vol_index              carry_load

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ALL_OLD                  000100 DIR_NAME                    ALL_OLD
                         000152 ENAME                       ALL_OLD
                         000162 EPTR                        ALL_OLD
                         000164 NPTR                        ALL_OLD
                         000166 ECOUNT                      ALL_OLD
                         000167 I                           ALL_OLD
carry_load               000100 queue_dir                   carry_load
                         000152 copy_dir                    carry_load
                         000224 copy_path_array             carry_load
                         004310 copy_sender_array           carry_load
                         010374 dn                          carry_load
                         010446 error_path                  carry_load
                         010520 mail_dir_path               carry_load
                         010572 new_dn                      carry_load
                         010644 process_dir                 carry_load
                         010716 request_path                carry_load
                         010770 tape_log_path               carry_load
                         011042 command                     carry_load
                         011052 en                          carry_load
                         011062 temp_en                     carry_load
                         011072 buffer                      carry_load
                         011267 error_line                  carry_load
                         011464 answer                      carry_load
                         011600 err_string                  carry_load
                         011631 sender_string               carry_load
                         011662 name_string                 carry_load
                         011703 new_user_id                 carry_load
                         011713 sender_id                   carry_load
                         011723 destination                 carry_load
                         011731 ds_arg                      carry_load
                         011737 retrieve_array              carry_load
                         011756 dtm72                       carry_load
                         011760 active_function             carry_load
                         011761 ds_sw                       carry_load
                         011762 found_sw                    carry_load
                         011763 force_sw                    carry_load
                         011764 got_path                    carry_load
                         011765 got_tape                    carry_load
                         011766 mail_sw                     carry_load
                         011767 new_dir_sw                  carry_load
                         011770 print_log_sw                carry_load
                         011771 select_sw                   carry_load
                         011772 test_sw                     carry_load
                         011773 tape_attached               carry_load
                         011774 bk_iocb                     carry_load
                         011776 new_mail_iocb               carry_load
                         012000 old_mail_iocb               carry_load
                         012002 tape_log_iocb               carry_load
                         012004 eptr                        carry_load
                         012006 nptr                        carry_load
                         012010 area_ptr                    carry_load
                         012012 arg_ptr                     carry_load
                         012014 mail_seg_ptr                carry_load
                         012016 return_ptr                  carry_load
                         012020 tape_log_ptr                carry_load
                         012022 ptrs                        carry_load
                         012026 control_ptr                 carry_load
                         012030 info_ptr                    carry_load
                         012032 mode                        carry_load
                         012033 arg_count                   carry_load
                         012034 arg_len                     carry_load
                         012035 buffer_len                  carry_load
                         012036 copies_omitted              carry_load
                         012037 days                        carry_load
                         012040 ecount                      carry_load
                         012041 error_line_len              carry_load
                         012042 i                           carry_load
                         012043 j                           carry_load
                         012044 k                           carry_load
                         012045 level                       carry_load
                         012046 number_omitted              carry_load
                         012047 request_count               carry_load
                         012050 request_index               carry_load
                         012051 return_len                  carry_load
                         012052 saved_request_count         carry_load
                         012053 mail_seg_len                carry_load
                         012054 mail_seg_bc                 carry_load
                         012055 tape_log_bc                 carry_load
                         012056 code                        carry_load
                         012060 now                         carry_load
                         012062 time_written                carry_load
                         012064 four_days                   carry_load
                         012066 segment_acl                 carry_load
                         012101 branch_status               carry_load
                         012114 query_info                  carry_load
                         012131 send_mail_info_version_2    carry_load
                         012132 send_mail_info              carry_load
                         012204 token                       get_token
                         012264 path                        really_look

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return              tra_ext             enable
shorten_stack       ext_entry           int_entry           int_entry_desc      set_cs_eis          index_cs_eis
divide_fx4          free_based          clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            active_fnc_err_               active_fnc_err_$suppress_name adjust_bit_count_
backup_load_                  bk_input$input_finish         com_err_                      com_err_$suppress_name
command_query_                convert_date_to_binary_       convert_status_code_          cu_$af_return_arg
cu_$arg_count                 cu_$arg_ptr                   cu_$level_get                 cv_dec_
expand_pathname_              get_group_id_                 get_pdir_                     get_system_free_area_
get_temp_segments_            hcs_$add_acl_entries          hcs_$add_dir_acl_entries      hcs_$chname_file
hcs_$del_dir_tree             hcs_$delentry_file            hcs_$get_user_effmode         hcs_$initiate_count
hcs_$star_                    hcs_$status_                  hcs_$status_minf              hcs_$terminate_noname
ioa_                          ioa_$ioa_switch               ioa_$nnl                      ioa_$rs
ioa_$rsnnl                    iox_$attach_name              iox_$close                    iox_$detach_iocb
iox_$find_iocb                iox_$get_line                 iox_$open                     iox_$put_chars
release_temp_segments_        send_mail_                    send_message_$notify_mail     unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$holdsw                 error_table_$badopt           error_table_$end_of_info      error_table_$incorrect_access
error_table_$no_dir           error_table_$noentry          error_table_$nomatch          error_table_$not_act_fnc
error_table_$not_attached     error_table_$request_pending  error_table_$rqover           iox_$error_output
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     83 001335        84 001340       118 001343       120 001344       121 001351       124 001353    3    7 001355
 4    3 001404        11 001410       217 001417       218 001422       220 001424       221 001441       223 001447
    224 001451       227 001462       228 001464       230 001520       232 001551       235 001552       236 001555
    237 001561       238 001562       240 001564       242 001573       244 001610       246 001631       247 001640
    248 001650       249 001651       250 001654       251 001704       253 001705       254 001707       255 001724
    256 001731       257 001732       258 001742       259 001743       260 001746       261 001776       263 001777
    264 002014       265 002040       266 002042       267 002071       269 002072       270 002073       271 002103
    272 002104       273 002107       274 002137       276 002140       277 002155       278 002166       279 002175
    280 002176       281 002206       282 002207       283 002212       284 002242       286 002243       287 002260
    288 002304       289 002306       290 002335       292 002336       293 002337       294 002347       295 002350
    296 002353       297 002403       299 002404       300 002421       301 002423       302 002433       303 002437
    305 002440       306 002443       307 002503       308 002540       309 002541       311 002542       313 002544
    314 002546       316 002553       317 002555       318 002557       320 002560       322 002567       323 002572
    324 002573       326 002575       327 002606       328 002610       329 002642       332 002643       337 002644
    339 002653       340 002656       341 002657       343 002661       344 002672       345 002675       347 002730
    350 002731       351 002736       352 002742       353 002743       355 002745       356 002755       357 002772
    359 003001       360 003003       361 003010       362 003011       363 003014       364 003025       365 003026
    366 003031       367 003056       369 003057       370 003074       371 003076       372 003106       373 003107
    374 003113       375 003152       377 003153       378 003162       379 003171       380 003176       382 003200
    383 003204       384 003206       386 003207       387 003213       390 003215       394 003237       395 003260
    396 003262       398 003305       400 003306       401 003310       403 003312       404 003315       405 003320
    406 003324       407 003325       408 003327       410 003331       411 003342       413 003344       417 003352
    419 003365       420 003425       421 003430       423 003433       424 003435       425 003444       426 003504
    427 003510       428 003511       430 003514       432 003516       434 003527       435 003533       436 003613
    439 003615       440 003617       441 003621       442 003650       444 003651       445 003654       447 003705
    450 003706       451 003757       452 004021       453 004023       454 004036       455 004056       456 004067
    457 004110       460 004111       461 004113       463 004171       465 004173       466 004176       469 004260
    471 004341       476 004343       477 004346       478 004350       479 004351       480 004406       482 004461
    483 004530       484 004532       485 004560       487 004561       488 004602       489 004604       491 004662
    494 004664       495 004707       496 004711       497 004720       498 004727       499 004730       500 004757
    501 005007       502 005033       504 005034       505 005042       507 005050       509 005162       511 005164
    512 005166       513 005221       514 005224       515 005232       516 005236       518 005265       519 005315
    522 005317       526 005347       528 005357       530 005402       531 005405       533 005406       536 005427
    538 005434       542 005447       543 005462       544 005475       547 005476       548 005503       549 005536
    550 005550       551 005551       552 005560       553 005566       554 005576       555 005603       556 005605
    557 005607       558 005610       559 005611       560 005616       561 005621       562 005623       563 005624
    564 005627       565 005636       566 005645       567 005646       568 005651       569 005654       571 005655
    572 005661       574 005672       575 005700       576 005705       577 005722       578 005727       579 005753
    580 005755       581 005757       582 006002       583 006004       585 006043       586 006074       588 006075
    589 006077       591 006102       593 006155       595 006226       600 006264       601 006267       604 006270
    605 006273       606 006276       608 006306       611 006313       612 006336       614 006337       616 006341
    617 006344       618 006346       619 006350       620 006352       622 006364       624 006427       625 006432
    626 006433       627 006455       629 006463       631 006465       632 006510       633 006525       634 006532
    635 006571       637 006572       638 006575       639 006576       640 006606       641 006610       642 006643
    645 006644       647 006646       648 006652       649 006705       651 006706       652 006725       653 006727
    654 006764       656 006765       657 007017       658 007063       660 007065       662 007120       664 007121
    665 007122       666 007127       667 007165       669 007166       670 007175       672 007207       674 007211
    676 007213       681 007214       682 007246       683 007255       685 007262       689 007267       690 007336
    691 007342       692 007350       693 007352       694 007415       695 007444       700 007473       702 007477
    704 007502       705 007511       706 007526       710 007556       711 007557       712 007574       713 007576
    714 007622       715 007624       716 007664       718 007665       720 007731       722 007733       723 007773
    724 007774       726 007775       727 010002       728 010032       729 010034       730 010100       731 010106
    733 010111       734 010113       737 010115       739 010123       744 010133       745 010147       746 010152
    747 010154       751 010160       753 010171       755 010175       756 010177       757 010255       762 010257
    763 010267       767 010312       768 010314       770 010317       772 010323       774 010331       775 010340
    779 010400       780 010406       781 010413       782 010423       786 010450       787 010452       790 010453
    792 010466       793 010475       797 010476       799 010507       801 010515       804 010527       806 010530
    808 010545       810 010553       811 010555       812 010557       817 010563       818 010566       819 010571
    820 010575       821 010605       822 010616       823 010617       824 010635       828 010663       829 010711
    830 010716       831 010734       832 010742       836 010750       837 010753       839 010757       846 010774
    847 011002       848 011004       850 011011       851 011017       853 011022       854 011104       855 011106
    856 011112       858 011123       859 011127       861 011153       863 011154       866 011170       868 011174
    871 011260       874 011301       878 011303       880 011313       881 011333       885 011406       887 011447
    890 011504       893 011545       894 011554       895 011566       896 011622       897 011635       898 011663
    900 011665       902 011666       904 011774       905 011777       906 012020       907 012022       909 012130
    910 012133       911 012154       913 012156       915 012201       917 012206       921 012210       922 012222
    924 012226       925 012230       926 012235       927 012253       929 012272       931 012273       933 012322
    934 012334       936 012353       938 012411       941 012444       942 012445       943 012463       944 012464
    946 012502       947 012525       949 012526       950 012536       951 012547       952 012560       954 012571
    957 012612       961 012614       963 012625       967 012671       969 012673       973 012677       977 012703
    978 012707       980 012711       982 012717       984 012724       985 012731       987 012740       989 012745
    991 012746       993 012755       995 012762       998 012767      1000 012771      1001 012773      1002 012775
   1003 013001      1005 013002      1007 013005      1010 013016      1014 013017      1015 013021      1017 013022
   1019 013031      1021 013037      1022 013044      1024 013074      1027 013144      1031 013223      1032 013224
   1033 013237      1034 013247      1036 013262      1037 013271      1038 013303      1039 013327      1040 013362
   1041 013417      1042 013452      1045 013523      1047 013571      1048 013626      1052 013630      1053 013637
   1054 013641      1055 013644      1056 013645      1058 013647      1060 013703      1062 013704      1064 013753
   1066 013763      1067 013775      1068 014037      1069 014043      1071 014046      1072 014077      1073 014110
   1075 014153      1077 014165      1079 014167      1080 014203      1082 014234      1083 014236      1084 014256
   1085 014265      1086 014314      1089 014316      1091 014322      1223 014323      1231 014334      1233 014411
   1234 014420      1235 014423      1236 014432      1238 014503      1239 014505      1240 014506      1241 014513
   1242 014514      1093 014515      1100 014517      1101 014531      1102 014544      1103 014545      1104 014551
   1105 014552      1107 014553      1108 014557      1110 014614      1114 014621      1121 014623      1122 014632
   1124 014644      1126 014706      1127 014714      1128 014721      1130 014725      1131 014726      1132 014730
   1133 014732      1134 014740      1135 014742      1136 014746      1139 014751      1141 014752      1146 014760
   1147 015003      1149 015006      1150 015015      1152 015020      1153 015027      1154 015033      1155 015047
   1156 015057      1157 015067      1159 015070      1160 015140      1162 015143      1163 015154      1164 015166
   1165 015212      1166 015234      1168 015256      1170 015261      1171 015267      1173 015276      1175 015277
   1186 015320      1187 015361      1189 015367      1191 015411      1194 015414      1195 015453      1196 015456
   1197 015500      1198 015544      1199 015615      1201 015627      1202 015632      1203 015641      1205 015653
   1206 015677      1207 015703      1209 015706      1210 015710      1211 015714      1214 015720      1216 015726
   1217 015735      1219 015744      1244 015745      1253 015766      1254 015771      1255 016003      1256 016045
   1257 016046      1258 016066      1259 016134      1260 016135      1262 016136      1263 016172      1265 016212
   1268 016213      1270 016221      1271 016224      1272 016230      1273 016256      1274 016270      1276 016302
   1277 016320      1278 016336      1279 016354      1280 016372      1281 016410      1283 016426      1285 016454


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
