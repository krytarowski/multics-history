	COMPILATION LISTING OF SEGMENT upd_doc_task_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/11/87  0926.5 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 upd_doc_task_:	procedure
       13 		options ( rename (( alloc_, smart_alloc_ )) );
       14 
       15 /*	April 1973,  P. B. Kelley								*/
       16 /*	October 1981, E. N. Kittlitz  multiply sys_info_$max_seg_size by 4, not 9			  */
       17 
       18 /****^  HISTORY COMMENTS:
       19*  1) change(86-06-25,GDixon), approve(86-08-18,MCR7494),
       20*     audit(86-08-18,Martinson), install(86-08-19,MR12.0-1129):
       21*     Changed to use more flexible mechanism to change Installations.info.
       22*  2) change(87-01-13,GDixon), approve(87-04-16,MCR7609),
       23*     audit(87-08-10,GJohnson), install(87-08-11,MR12.1-1080):
       24*     Fix bug which prevents adding installation documentation in a totally
       25*     empty Installations.info segment.
       26*                                                   END HISTORY COMMENTS */
       27 dcl
       28      control_word		bit (36) aligned,		/* control word */
       29      areap		ptr,			/* ptr to segment Area */
       30      parentp		ptr,			/* ptr to parent */
       31      acode		fixed bin (35),		/* error code */
       32      asev			fixed bin,		/* error severity */
       33      taskp		ptr,			/* task ptr */
       34      seqno		fixed bin,		/* sequence no. */
       35      treep		ptr,			/* ptr to modification description */
       36      log_name		char (168),		/* pathname of documentation segment */
       37      info_name		char (168),		/* pathname of documentation info segment */
       38      ename (3)		char(32) aligned,		/* entry name array */
       39      dname (3)		char(168) aligned,		/* directory name array */
       40      Uid (3)		bit (36) aligned,		/* unique id array */
       41      Sfwd_done		bit(1),			/* ON if already done */
       42      install_date		fixed bin (35),		/* installation date */
       43      de_install_date	fixed bin(35),		/* de-installation date */
       44      log_directory		char (168) aligned,		/* pathname of documentation directory */
       45      max_line_size		fixed bin,		/* maximum line size */
       46      prosep		ptr;			/* ptr to documentation description structure */
       47 
       48 dcl  LOG_NAME		char(32) int static options(constant) init("Installations.log" ),
       49 						/* MUST end with suffix ".log" */
       50      INFO_NAME		char(32) int static options(constant) init("Installations.info" ),
       51 						/* MUST end with suffix ".info" */
       52      INFO_NAME_WHEN_FULL	char(32) int static options(constant) init("Installations.new.info"),
       53      INFO_HEADER		char(56) int static options(constant) init("Reverse chronological list of system software changes.
       54 
       55 " );						/* Standard header for Installations.info. 	*/
       56 						/* MUST be changed in this program.     	*/
       57 
       58 dcl  1  c  aligned based (addr ( control_word)),
       59        (2  reverse_sw	bit (1),
       60         2  task_sw		bit (1),
       61         2  compile_sw	bit (1),
       62         2  run_sw		bit (1),
       63         2  task_run_sw	bit (1),
       64         2  log_sw		bit (1),
       65         2  error_sw		bit (1),
       66         2  brief_sw		bit (1),
       67         2  detail_sw	bit (1) ) unaligned;
       68 
       69 dcl  A  area based (areap);				/* outside segment area where everything happens */
       70 
       71 
       72 dcl  1  limb  aligned based (blkp),			/* block to be allocated by $get_tree */
       73         2  Nsegname	char (32),			/* primary name of Nsegment */
       74         2  Osegname	char (32),			/* former name of seg       */
       75         2  Nlib	char (168) aligned,			/* "target" seg library     */
       76         2  Olib	char (168) aligned,			/* "old" seg library */
       77         2  date	char (16),			/* install date */
       78         2  actxn	fixed bin,			/* action code of segment  */
       79         2  nc	fixed bin (17),			/* number components if bound */
       80         2  el 	(nn refer (limb.nc)),		/* array of components   */
       81 	 3  cname		char (32),		/* component name */
       82 	 3  cactxn	fixed bin;		/* action code of component */
       83 
       84 dcl  1  prose based (prosep),					/* place where prose is stored */
       85         2  editsw		bit(1),				/* "on" if editted */
       86         2  no_char		fixed bin,			/* no. of characters */
       87         2  prose_string	char (0 refer (prose.no_char));	/* the string */
       88 
       89 						/* structures for moving info seg around */
       90 dcl  Inon_nl		fixed bin(21),
       91      created_sw		bit(1) aligned,
       92      full_bc		fixed bin(24),
       93      full_info_p		ptr,
       94      header_l		fixed bin(21),
       95      header_p		ptr,
       96      header		char(header_l) based(header_p),
       97      info_bc		fixed bin(24),
       98      info_l		fixed bin(21),
       99      info_p		ptr,
      100      info			char(info_l) based(info_p);
      101 
      102 dcl  BITS_PER_CHAR		fixed bin int static options(constant) init(9);
      103 dcl  CHARS_PER_WORD		fixed bin int static options(constant) init(4);
      104 dcl  NL			char(1) int static options(constant) init ("
      105 ");
      106 dcl  NL_NL		char(2) int static options(constant) init("
      107 
      108 ");
      109 
      110 dcl  1  control_base aligned based (addr(control)),
      111        (2  path_given (3)	bit(1),
      112         2  pad 		bit(33) ) unal;
      113 
      114 dcl  1  status based (addr(scode)),
      115         2  code	fixed bin(35);
      116 
      117 dcl  mask (4) bit (36) aligned init
      118 	("101"b,		/* ADD     action */
      119 	 "111"b,		/* REPLACE action */
      120 	 "010"b,		/* DELETE  action */
      121 	 "011"b );	/* MOVE - NO REPL action */
      122 
      123 dcl					/* codes for possible actions */
      124      added       fixed bin init	(1),
      125      replaced    fixed bin init	(2),
      126      deleted     fixed bin init	(3),
      127      moved       fixed bin init	(4),
      128      del_com     fixed bin init	(3);
      129 
      130 dcl   com (1:8)  char (17)  init		/* printable comments for action codes */
      131     ("added to",
      132      "replaced in",
      133      "deleted from",
      134      "moved to",
      135      "de-installed from",
      136      "de-installed from",
      137      "re-installed to",
      138      "moved back"  );
      139 
      140 dcl  comp_array (4) char (16) init
      141 	("          added:",
      142 	 "       replaced:",
      143 	 "        deleted:",
      144 	 "          moved:");
      145 
      146 dcl
      147      cu_$arg_list_ptr 	entry (ptr),
      148      upd_add_task_ 		entry (char (*), ptr),
      149      upd_log_task_$lock	entry (char(*) aligned, fixed bin(35)),
      150      upd_log_task_$unlock	entry (char(*) aligned, fixed bin(35)),
      151      upd_print_err_		entry options ( variable ),
      152      upd_status_$long	entry ( char (*) aligned, char (*) aligned, fixed bin, ptr, ptr, fixed bin (35)),
      153      upd_task_err_ 		entry  options (variable),
      154      ioa_$ioa_stream 	entry options (variable),
      155      ios_$attach		entry  (char(*) aligned, char(*) aligned, char(*), char(32) aligned,
      156 			       bit(72) aligned),
      157      ios_$detach		entry (char(*) aligned, char(*) aligned, char(*) aligned, bit(72) aligned),
      158      ios_$write		entry (char(*) aligned, ptr, fixed bin, fixed bin, fixed bin, bit(72) aligned),
      159      date_time_$fstime 	entry (fixed bin(35), char(*) aligned),
      160      get_wdir_		entry returns (char(168) aligned),
      161      get_temp_segments_	entry (char(*), (*) ptr, fixed bin(35)),
      162      hcs_$delentry_seg	entry (ptr, fixed bin(35)),
      163      hcs_$initiate_count	entry (char(*), char(*), char(*), fixed bin(24), fixed bin(2), ptr,
      164 			     fixed bin(35)),
      165      hcs_$terminate_noname 	entry (ptr, fixed bin(35)),
      166      initiate_file_$create	entry (char(*), char(*), bit(*), ptr, bit(1) aligned, fixed bin(24),
      167 			     fixed bin(35)),
      168      pathname_		entry (char(*), char(*)) returns(char(168)),
      169      release_temp_segments_	entry (char(*), (*) ptr, fixed bin(35)),
      170      terminate_file_	entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      171 
      172 dcl
      173     (error_table_$bad_segment,
      174      error_table_$moderr,
      175      error_table_$namedup,
      176      error_table_$noarg,
      177      error_table_$non_matching_uid,
      178      error_table_$oldobj,
      179      error_table_$rqover,
      180      error_table_$segknown)		fixed bin(35) ext static,
      181      sys_info$max_seg_size		ext fixed bin (35);
      182 
      183 dcl  1  s1  (1000)  aligned,				/* structure containing info on segment */
      184         2   segname 	char (32) aligned,
      185         2   dtc      	fixed bin (71);
      186 dcl  1  s2  (1000)  aligned,
      187         2   segname 	char(32) aligned,
      188         2   dtc     	fixed bin(71);
      189 
      190 dcl  1  Stat aligned,				/* structure for upd_status_$long   */
      191       (2  type	bit (2),
      192        2  nnames	bit (16),
      193        2  nrp	bit (18),
      194        2  dtm	bit (36),
      195        2  dtu	bit (36),
      196        2  mode	bit (5),
      197        2  pad	bit (13),
      198        2  rec	bit (18),
      199        2  dtd	bit (36),
      200        2  dtem	bit (36),
      201        2  acct	bit (36),
      202        2  curlen	bit (12),
      203        2  bitcnt	bit (24),
      204        2  did	bit (4),
      205        2  mdid	bit (4),
      206        2  copysw	bit (1),
      207        2  pad2	bit (9),
      208        2  rbs (3)	bit (6),
      209        2  uid	bit (36)  )  unaligned;
      210 
      211 dcl						/* misc variables */
      212      actions (1001)		fixed bin,
      213      axn 			fixed bin,		
      214      b1_date		char(24) aligned init (" "),
      215      b2_date		char(24) aligned init (" "),
      216      b1_name		char(32) aligned init (" "),
      217      b2_name		char(32) aligned init (" "),
      218      bitc 		fixed bin (24),
      219      buffer		char(132) aligned,
      220      code			fixed bin (35),
      221      control		bit(36) aligned init ("0"b),
      222      Date			char(16) aligned,
      223      de_installation_sw	bit (1),
      224      entry		char (32),
      225      errname		char(32),
      226      errpath		char (168),
      227      gate_sw		bit (1) init ("0"b),
      228      ignore		fixed bin(35),
      229      log_dir		char(168),
      230      logsw		bit (1),
      231      names (1001) 		char (32),
      232      new_lib		char (168) aligned,
      233      no_more		bit(1) init ("0"b),
      234      old_lib		char (168) aligned,
      235      record_quota_overflow	condition,
      236      rev			fixed bin,
      237      runsw		bit (1),
      238      scode		bit (72) aligned,
      239      sev			fixed bin,
      240      unb_sw 		bit (1) init ("1"b);
      241 
      242 dcl (e, i, ii, nn, line_size, point) fixed bin (17);
      243 dcl (j, k) fixed bin(17) init (1);		/* needed for do loops */
      244 dcl (argp, q, p1, p2, Pseg, blkp) ptr init (null);
      245 dcl  p(2) ptr init((2) null);
      246 dcl (addr, dimension, divide, fixed, index, length, min, null, reverse,
      247      rtrim, setcharno, substr, verify) builtin;
      248 
      249 
      250 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
      251 /**/
      252 get_tree:		entry (control_word, areap, parentp, acode, asev, taskp, seqno,
      253 		     dname, ename, Uid, treep );
      254 
      255 	e = 1;
      256 	entry = "upd_doc_task_$get_tree";
      257 	go to common;
      258 
      259 write_tree:	entry (control_word, areap, parentp, acode, asev, taskp, seqno,
      260 		     treep, install_date, de_install_date, log_directory, Sfwd_done);
      261 
      262 	e = 2;
      263 	entry = "upd_doc_task_$write_tree";
      264 	go to common;
      265 
      266 write_prose:	entry (control_word, areap, parentp, acode, asev, taskp, seqno,
      267 		     log_directory, prosep, install_date, Sfwd_done, max_line_size);
      268 
      269 	e = 3;
      270 	entry = "upd_doc_task_$write_prose";
      271 
      272 common:
      273 	call cu_$arg_list_ptr (argp);			/* get arglist ptr       */
      274 	logsw = c.log_sw;				/* set internal log switch */
      275 	runsw = c.run_sw | c.task_run_sw;		/* and internal process switch */
      276 	if c.error_sw then if asev = 0 then		/* print errors only */
      277 	     logsw = "0"b;
      278 	if c.task_sw then				/* add a task to list */
      279 	     call upd_add_task_ ( entry, argp );		
      280 	if e ^= 1 then do;				/* get_tree entry doesn't pass log_directory */
      281 	     if substr(log_directory, 1, 1) = " " then do;
      282 		log_dir = get_wdir_();
      283 		log_name = LOG_NAME;		/* set the value of log_name */
      284 		info_name = INFO_NAME;		/* and info name */
      285 		end;
      286 	     else do;
      287 		log_dir = log_directory;
      288 		log_name =  rtrim(log_directory)||">"||LOG_NAME;
      289 		info_name = rtrim(log_directory)||">"||INFO_NAME;
      290 		end;
      291 	     end;
      292 
      293 	go to start(e);
      294 
      295 /**/
      296 start(1):						/* get_tree entry */
      297 	if logsw then do; 				/* user wants something printed, so... */
      298 	     call ioa_$ioa_stream ( "installation_list_",
      299 		"^5x^RGather documentation info^B");
      300 	     if asev ^= 0 then
      301 	 	call upd_print_err_ ( acode, asev );
      302 	     return;				/* that's all we do when logging */
      303 	     end;
      304 	if c.reverse_sw then			/* do not run in reverse mode */
      305 	     return;
      306 	if ^runsw then return;			/* if not processing now, quit  */
      307 	if treep ^= null then return;			/* if info already gathered, then quit */
      308 
      309 	nn = 0;
      310 	do i = 1 to 3;				/* which paths were received?  */
      311 	     if substr (dname(i), 1, 1) ^= " "
      312 		then path_given (i) = "1"b;
      313 	     end;
      314 	if control = "0"b then do;			/* means no paths received */
      315 	     code = error_table_$noarg;		/* can't do something with nothing */
      316 	     sev = 3;				/* bad error */
      317 	     errpath = "<no paths received>";
      318 	     errname = "";
      319 	     go to err;				/* leave thru error exit */
      320 	     end;
      321 
      322 	do i = 1 to 2;				/* let's get some info on existing paths */
      323 	     if path_given(i) then do;
      324 		call upd_status_$long ( dname(i), ename(i), 1, addr(Stat), null, code);    
      325 		   if code = 0 then do;				/* it better be */
      326 		     if fixed(Stat.rbs(2),6) ^= fixed(Stat.rbs(3),6)     	/* If gate seg... */
      327 			then gate_sw = "1"b;			/* then don't worry 'bout it */
      328 		     if fixed(Uid(i)) ^= 0 then if Uid(i) ^= Stat.uid then do;/* check uid           */
      329 			sev = 3;					/* whoops, got one */
      330 			code = error_table_$non_matching_uid;
      331 			errpath = dname(i);
      332 			errname = ename(i);
      333 			go to err;				/* let's get out now  */
      334 			end;
      335 		     end;
      336 		end;
      337 	     end;
      338 
      339 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      340 /*			Find action being performed		 				*/
      341 
      342 	if (control & "010"b)			/* get standardized form of "old" lib */
      343 	     then call valid_lib_ (dname(2), old_lib);
      344 	     else old_lib = "";
      345 	if (control & "001"b)			/* and standardized form of "target" lib */
      346 	     then call valid_lib_ (dname(3), new_lib);	/* (may be different) */
      347 	     else new_lib = old_lib;			/* only poss. is DEL; print routine expects "new_lib" */
      348 
      349 	if control = mask(1) then do;			/* ADD action			*/
      350 	     axn = added;
      351 	     ename(2) = ename(3);				/* used later		 */
      352 	     end;
      353 	else if control = mask(2) then do;		/* REPLACE action			*/
      354 	     if new_lib = old_lib then         			/* simple REPLACE		*/
      355 		axn = replaced;
      356 	     else    					/* REPLACE with MOVE	*/
      357 		axn = moved;
      358 	     end;
      359 	else if control = mask(3) then do;		/* DELETE action			*/
      360 	     axn = deleted;
      361 	     ename(3) = ename(2);				/* used later		*/
      362 	     end;
      363 	else if control = mask(4) then do;		/* MOVE with no replace		*/
      364 	     axn, del_com = moved;
      365 	     end;
      366 	go to init_entry;
      367 
      368 err:						/* common out for severe errors	 */
      369 	call upd_task_err_ ( code, sev, argp, entry, "^a>^a", errpath, errname );/* call error handler */
      370 	return;							/* scram    */
      371 /**/
      372 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      373 /*			gather info for segs given						*/
      374 init_entry:
      375 	if gate_sw then go to record_seg;			/* special case gates, might not have access  	*/
      376 	errpath = dname(1);
      377 	errname = ename(1);
      378 	sev = 3;
      379 	p1 = addr(s1);
      380 	p2 = addr(s2);
      381 	s1(1).segname, s2(1).segname = "";
      382 
      383 	if (control & "100"b) then do;			/* let's find out about the "new" seg */
      384 	     call hcs_$initiate_count ((dname(1)), (ename(1)), "", bitc, 0, Pseg, code); 
      385 		 if code ^= 0 then if code ^= error_table_$segknown then do; /* sounds like it's not there */
      386 		     if code = error_table_$moderr then go to no_rec;	/* nope, just no access */
      387 		     go to err;					/* bad error */
      388 		     end;
      389 	     call doc_util_ (Pseg, bitc, p1, ename(1), unb_sw, k, b1_date, b1_name, code);
      390 	 	if code ^= 0 then if code ^= error_table_$bad_segment then	/* might not be an object segment */
      391 		     go to err;				/* segment probably clobbered */
      392 	     call hcs_$terminate_noname ( Pseg, code);
      393 	     end;
      394 
      395 	errpath = dname(2);
      396 	errname = ename(2);
      397 
      398 	if (control & "010"b) then do;				/* let's find out about the "old" seg */
      399 	     call hcs_$initiate_count ((dname(2)), (ename(2)), "", bitc, 0, Pseg, code); 
      400 		if code ^= 0 then if code ^= error_table_$segknown then do; /* might not be there */
      401 		     if code = error_table_$moderr then go to no_rec;	/* rings are probably 1,1,1 */
      402 		     go to err;					/* bad error */
      403 		     end;
      404 	     call doc_util_ ( Pseg, bitc, p2, ename(2), unb_sw, j, b2_date, b2_name, code);
      405 		if code ^= 0 then do;				/* couldn't get it    */
      406 		     if code = error_table_$bad_segment then go to record_seg; /* could be non-object segment  */
      407 		     if code = error_table_$oldobj then do;		/* wrong incls for older than '72 stuff */
      408 			if unb_sw  then go to record_seg;		/* if unbound then don't worry  */
      409 no_rec:			sev = 0;					/* inform user if it */
      410 			if substr(ename(2),1,6) = "bound_" then		/* starts with "bound_"*/
      411 			     call upd_task_err_ ( code, sev, argp, entry,
      412 				"Not recording component changes.  ^a>^a" , errpath, errname);
      413 			go to record_seg;				/* non-fatal, so continue... */
      414 			end;
      415 		     go to err;
      416 		     end;
      417 	     call hcs_$terminate_noname ( Pseg, code);
      418 	     end;
      419 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      420 /*  */
      421 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      422 /*			what kind of info have we found ?					*/
      423 	if unb_sw then
      424 	     go to record_seg;				/* neither seg is bound */
      425 
      426 	if (control & "010"b) then do ii = 1 to j;		/*  dig out the deleted ones first  */
      427 	     do i = 1 to k;
      428 		if s1(i).segname = s2(ii).segname then go to next1; /* this one's still there  */
      429 		end;
      430 	     nn = nn + 1;					/* this name didn't match up, so add it to list */
      431 	     names(nn) = s2(ii).segname;
      432 	     actions(nn) = del_com;
      433 next1:	     end;
      434 
      435 	if control = mask(4) then go to changed;		/* if moving w/ no repl. then xfer */
      436 
      437 	if (control & "001"b) then do i = 1 to k;		/* now for the replaced and added ones */
      438 	     do ii = 1 to j;
      439 		if s1(i).segname = s2(ii).segname then do;	/* found a name-match */
      440 		     if s1(i).dtc ^= s2(ii).dtc then do;	/* this one's being replaced */
      441 			nn = nn + 1;			/* add it to our collection */
      442 			names(nn) = s1(i).segname;
      443 			actions(nn) = replaced;
      444 			go to next2;
      445 			end;
      446 		     if axn = moved then do;			/* if moving, then record all components */
      447 			nn = nn + 1;			/* add it to collection */
      448 			names(nn) = s1(i).segname;
      449 			actions(nn) = moved;
      450 			end;
      451 		     go to next2;
      452 		     end;
      453 		end;
      454 	     nn = nn + 1;					/* no name-match, must be an added one */
      455 	     names(nn) = s1(i).segname;			/* so we'll add it   */
      456 	     actions(nn) = added;
      457 next2:	     end;
      458 
      459 	if b1_date ^= " " then				/* check for bindfile change */
      460 	     if b2_date ^= " " then				/* both have been bound with v2 */
      461 		if b1_date ^= b2_date then go to changed;  	/* and not with same bindfile */
      462 		else go to record_seg;
      463 							/* one (or both) was bound with v1 */
      464 	do i = 1 to nn;					/* if any components were added, deleted, */
      465 	     if actions(i) ^= replaced then go to changed;	/* or moved, then report bindfile change */
      466 	     end;
      467 	go to record_seg;
      468 changed:  nn = nn + 1;					/* add it to our list */
      469 	if (control & "100"b) then
      470 	     names(nn) = b1_name;
      471 	else
      472 	     names(nn) = b2_name;
      473 	actions(nn) = axn;				/* assume the action of the bound seg */
      474 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      475 /**/
      476 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      477 /*			transfer info into external area					*/
      478 
      479 record_seg:
      480 	allocate limb in (A) set (q);			/* allocate storage for limb */
      481 	q->limb.Nsegname = ename(3);			/* new name of seg   */
      482 	q->limb.Osegname = ename(2);			/* former name of seg	   */
      483 	q->limb.Nlib = new_lib;			/* "target" seg lib */
      484 	q->limb.Olib = old_lib;			/* "old" seg library */
      485 	q->limb.date = "  (date)";			/* future date */
      486 	q->limb.actxn = axn;			/* action code reflecting segment */
      487 	if nn = 1 then if ename(3) = names(1) then 	/* means unbound seg being added|replaced|deleted */
      488 	     nn = 0;				/* pretend no components */
      489 	q->limb.nc = nn;				/* number of components (if bound seg) */
      490 	if nn > 0 then do i = 1 to nn;		/* if bound, then copy all components changed */
      491 	     q->limb.el(i).cname = names(i);		/* component name 		*/
      492 	     q->limb.el(i).cactxn = actions(i);		/* action code reflecting component */
      493 	     end;	
      494 	treep = q;				/* set treep to limb   */
      495 	return;					/* finis */
      496 
      497 /*			end of upd_doc_task_$get_tree					*/
      498 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
      499 /**/
      500 start(2):							/* write_tree entry */
      501 	if ^logsw then if ^runsw then
      502 	     return;
      503 	if logsw then do;					/* if we're in "print" mode, then do it. */
      504 	     if c.detail_sw then 				/* if detail, then print what's happening */ 
      505 		call ioa_$ioa_stream ("installation_list_", "^5x^RLog into^B^-^a", log_name);
      506 	     if treep = null then do;				/* we haven't gotten info yet */
      507 		call ioa_$ioa_stream ("installation_list_", "^-Log Information list is empty.^/");
      508 		return;
      509 		end;
      510 	     call ios_$attach ( "installation_log_", "syn", "installation_list_", "w", scode);
      511 	     if status.code ^= 0 then do;			/* attach unsuccessful */
      512 		call upd_task_err_ (status.code, 0, argp, entry, "Attempting to attach I/O stream.");
      513 		go to skip_comps;
      514 		end;
      515 	     go to print_it;		     		/* zip thru the printing routine */
      516 	     end;
      517 
      518 	if Sfwd_done ^= c.reverse_sw then
      519 	     return;					/* already finished in this direction*/
      520 	if treep = null then 				/* can't get info from null ptr   */
      521 	     return;
      522 
      523 	call upd_log_task_$lock ((log_name), code);		/* lock the installation log file */
      524 	if code ^= 0 then do;				/* whoops, something's not there */
      525 	     call upd_task_err_ (code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
      526 	     return;					/* only issue warning if processing */
      527 	     end;
      528 	call ios_$attach ("installation_log_", "file_", log_name, "w", scode);
      529 	if status.code ^= 0 then do;				/* attach unsuccessful? */
      530 	     call upd_task_err_ (status.code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
      531 	     go to skip_comps;
      532 	     end;
      533 
      534 print_it:	de_installation_sw = c.reverse_sw;
      535 
      536 	if ^de_installation_sw then do;			/* if going forward... */
      537 	     rev = 0;
      538 	     if install_date ^=  0 then			/* and if we have a date */
      539 		call date_time_$fstime (install_date, Date);	/* then decode it */
      540 	     else
      541 		Date = "  (date)";				/*  or, for printing...	*/
      542 	     if runsw then					/* unless we're listing */
      543 		treep->limb.date = Date;			/* set Date fwd only 	*/
      544 	     end;
      545 	else do;						/* if going in reverse... */
      546 	     rev = 4;
      547 	     call date_time_$fstime (de_install_date, Date);
      548 	     call ioa_$ioa_stream ( "installation_log_", "^/+++++"); /* a "reverse" separator? */
      549 	     end;
      550 
      551 	if treep->limb.actxn ^= moved then do;			/* Major line, fwd or rev, not moving	*/
      552 	     call ioa_$ioa_stream ("installation_log_", "^/^16a^4x^a ^a ^a",
      553 		Date, treep->limb.Nsegname, com(treep->limb.actxn+rev),treep->limb.Nlib);
      554 	     if de_installation_sw then do;			/* reverse		*/
      555 		call ioa_$ioa_stream ("installation_log_", "^/^-^5x(previously installed ^16a)",
      556 		     treep->limb.date);			/* use block date */
      557 		go to skip_comps;				/* skip component printing */
      558 		end;
      559 	     if treep->limb.Nsegname ^= treep->limb.Osegname then
      560 		call ioa_$ioa_stream ("installation_log_", "^/^-^5x(renamed from ^a)",
      561 			treep->limb.Osegname);
      562 	     go to print_comps;
      563 	     end;
      564 							/* Major line for moving */
      565 	if ^de_installation_sw then do;			/* fwd...		*/
      566 	     call ioa_$ioa_stream ("installation_log_", "^/^16a^4x^a moved from ^a to ^a",
      567 		Date, treep->limb.Nsegname, treep->limb.Olib,treep->limb.Nlib);
      568 	     if treep->limb.Nsegname ^= treep->limb.Osegname then
      569 		call ioa_$ioa_stream ("installation_log_", "^/^-^5x(renamed from ^a)",
      570 		     treep->limb.Osegname);
      571 	     end;
      572 	else do;						/* reverse	*/
      573 	     call ioa_$ioa_stream ("installation_log_", "^/^16a^4x^a moved back from ^a to ^a",
      574 		Date, treep->limb.Osegname, treep->limb.Nlib, treep->limb.Olib);
      575 	     call ioa_$ioa_stream ("installation_log_", "^/^-^5x(previously installed ^16a)",
      576 		treep->limb.date);
      577 	     go to skip_comps;
      578 	     end;
      579 
      580 print_comps:						/* now for the components */
      581 	if treep->limb.nc = 0 then				/* if zero comps, then can't print them */
      582 	     go to skip_comps;
      583 	do i = 1 to 4;					/* 4 possible actions */
      584 	     k = i;
      585 	     do j = 1 to treep->limb.nc;			/* random arrangement, so simplest is..*/
      586 		if treep->limb.el(j).cactxn = i then do;
      587 		     if k ^= 0 then
      588 			call ioa_$ioa_stream ("installation_log_",
      589 			     "^/^16a^4x^a", comp_array(k), treep->limb.el(j).cname);
      590 		     else
      591 			call ioa_$ioa_stream ("installation_log_", "^2-^a", treep->limb.el(j).cname);
      592 		     k = 0;
      593 		     end;
      594 		end;
      595 	     end;
      596 
      597 skip_comps:
      598 	call ios_$detach ("installation_log_", "", "", scode);	/* remember to always detach this stream here */
      599 	if runsw then do;
      600 	     call upd_log_task_$unlock ((log_name), code);	/* unlocks log file */
      601 	     Sfwd_done = ^Sfwd_done;
      602 	     if substr(log_directory, 1, 1) = " " then
      603 		log_directory = get_wdir_();
      604 	     end;
      605 
      606 	return;
      607 
      608 /*			end of upd_doc_task_$write_tree				*/
      609 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
      610 /**/
      611 start(3):							/* write_prose entry */
      612 	if ^runsw then if ^logsw then
      613 	     return;
      614 	if c.reverse_sw then
      615 	     return;					/* do nothing in reverse */
      616 	if logsw then do;					/* user wants to check */
      617 	     call ioa_$ioa_stream ("installation_list_",		/* already attached at this point */
      618 		"^2/^RDocument modification description into:^B^/^5x^a.", log_name);
      619 	     if asev ^= 0 then
      620 		call upd_print_err_ ( acode, asev );		/* print any errors */
      621 	     if prosep = null then do;			/* but description is empty */
      622 		call ioa_$ioa_stream ("installation_list_",	/* already attached */
      623 		     "^/^5x(modification description is empty)^/");
      624 		return;
      625 		end;
      626 	     if (c.detail_sw | ^c.brief_sw) then do;		/* print what's there */
      627 		call ios_$attach ( "installation_log_", "syn", "installation_list_", "w", scode);
      628 		if status.code ^= 0 then do;
      629 		     call upd_task_err_ ( status.code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
      630 		     return;
      631 		     end;
      632 		end;
      633 	     else
      634 		return;
      635 	     end;
      636 
      637 	if runsw then
      638 	     if Sfwd_done ^= c.reverse_sw then			/* we've already done this */
      639 		return;
      640 	if runsw then
      641 	     if prosep = null then do;			/* at least print separator */
      642 	     no_more = "1"b;
      643 	     go to skipedit;
      644 	     end;
      645 	if prose.editsw then				/* if we've already gone thru this... */
      646 	     go to skipedit;				/* then let's save some time */
      647 							/* *************************** */
      648 							/* EDIT the best we can        */
      649 							/* *************************** */
      650 	point = 1;
      651 	line_size = max_line_size;
      652 look:	i = min ( line_size, ( (no_char - point) + 1 ) );		/* make sure we don't grab too much */
      653 	buffer = substr ( prose_string, point, i );		/* let's look at the string */
      654 	if i < line_size then
      655 	     go to process;					/* we've got all we need */
      656 	i = index ( buffer, NL );				/* look for a new_line */
      657 	if i = 0 then do;					/* let's try something else */
      658 	     if line_size > max_line_size then			/* if we had to grap extra chars */
      659 		i = index ( substr ( buffer, 1, line_size ) , " "); /* look for first occurance of a blank */
      660 	     else do;					/* non-expanded buffer, so... */
      661 		k = index ( reverse ( substr ( buffer, 1, line_size ) ), " "); /* look for last occurance of a blank */
      662 		if k ^= 0 then
      663 		     i = line_size - ( k - 1 );		/* set i to blank char */
      664 		end;
      665 	     if i ^= 0 then do;				/* if we found one */
      666 		substr ( buffer, i, 1 ) = NL;			/* make it a new_line */
      667 		go to process;
      668 		end;
      669 	     if line_size ^> (max_line_size + 10) then do;	/* increase size of line ( max. 10) */
      670 		line_size = line_size + 5;
      671 		go to look;
      672 		end;
      673 	     i = max_line_size;				/* have to cut off line */
      674 	     end;
      675 
      676 process:	substr ( prose_string, point, i) = substr ( buffer, 1, i);
      677 	point = point + i;					/* adjust out pointer */
      678 	if point < no_char then				/* check for end of the line */
      679 	     go to look;
      680 
      681 skipedit:	if logsw then do;					/* write description on already attached stream */
      682 	     call ioa_$ioa_stream ("installation_log_", "");	/* NL */
      683 	     call ios_$write ("installation_log_", addr(prose.prose_string), 0, prose.no_char, i, scode);
      684 	     call ioa_$ioa_stream ("installation_log_", "");	/* NL (really CR here) */
      685 	     go to return;					/* nothing more to do here */
      686 	     end;
      687 							/* *************************** */
      688 							/* first, the LOG file         */
      689 							/* *************************** */
      690 	call upd_log_task_$lock ((log_name), code );		/* set the lock */
      691 	if code ^= 0 then 
      692 	     go to lock_err;
      693 	call ios_$attach ( "installation_log_", "file_", log_name, "w", scode);
      694 	if status.code ^= 0 then do;
      695 	     call upd_task_err_ ( status.code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
      696 	     go to un_log;
      697 	     end;
      698 	call ioa_$ioa_stream ( "installation_log_", "^/*****");	/* start with a separator */
      699 	if ^no_more then do;				/* continue only if there's more */
      700 	     call ios_$write ("installation_log_", addr(prose.prose_string), 0, prose.no_char, i, scode);
      701 	     call ioa_$ioa_stream ("installation_log_", "");     	/* NL */
      702 	     end;
      703 un_log:	call ios_$detach ("installation_log_", "", "", scode);	/* detach the print stream */
      704 	call upd_log_task_$unlock ((log_name), code);		/* unlock the log */
      705 	if code ^= 0 then
      706 	     call upd_task_err_ ( code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
      707 	if no_more then					/* nothing more to do */
      708 	     go to return;
      709 							/* *************************** */
      710 							/* and now the INFO file       */
      711 							/* *************************** */
      712 	call date_time_$fstime ( install_date, Date);
      713 	call upd_log_task_$lock ((info_name), code);		/* lock the info file */
      714 	if code ^= 0 then do;
      715 	     log_name = info_name;
      716 	     go to lock_err;
      717 	     end;
      718 							/* get temp space */
      719 	call get_temp_segments_ ("upd_doc_task_", p, code);
      720 	if code ^= 0 then do;
      721 	     call upd_task_err_ ( code, 0, argp, entry, "Getting temp segment.");
      722 	     go to un_info;
      723 	     end;
      724 							/* now the REAL seg */
      725 	call hcs_$initiate_count ( log_dir, INFO_NAME, "", info_bc, 1, info_p, code);
      726 	if (code ^= 0 & code ^= error_table_$segknown) then do;
      727 	     call upd_task_err_ ( code, 0, argp, entry, "^2xInitiating info segment^/^2x(^a).",
      728 		info_name);
      729 	     go to un_info;
      730 	     end;
      731 	info_l = divide (info_bc, BITS_PER_CHAR, 21, 0);
      732 
      733 	call save$init (p(1));				/* save copy of current info seg in case*/
      734 	call save$str (info);				/*   it must be restored (eg on RQO).	*/
      735 
      736 	call out$init (p(2));				/* prepare to build new copy of info seg. */
      737 	if substr(info,1,min(length(info),length(INFO_HEADER))) = INFO_HEADER then do;
      738 							/* if our heading line is present, then */
      739 	     header_p = info_p;				/* insert new data between header and   */
      740 	     header_l = length(INFO_HEADER);			/* existing data.			*/
      741 	     end;
      742 	else do;						/* if our heading line is NOT present,  */
      743 	     header_p = info_p;				/* insert new data after first blank    */
      744 	     header_l = index(info, NL_NL);			/* line in the info segment.		*/
      745 	     if header_l > 0 then
      746 	        header_l = header_l - 1 + length(NL_NL);
      747 	     end;
      748 	info_p = setcharno(info_p, length(header));
      749 	info_l = info_l - length(header);
      750 
      751 	Inon_nl = verify(info, NL);				/* Strip extra NLs from start of data.	*/
      752 	if Inon_nl > 1 then do;
      753 	     info_p = addcharno(info_p, Inon_nl-1);
      754 	     info_l = info_l - (Inon_nl-1);
      755 	     end;
      756 
      757 	call out$str (header);				/* output our header, date line and	*/
      758 	call out$str (substr(Date,1,8));			/* new documentation into temp segment. */
      759 	call out$str (":");
      760 	call out$str (NL);
      761 	call out$str (prose_string);
      762 	call out$str (NL);
      763 	call out$str (NL);
      764 	call out$str (NL);
      765 
      766 	if out$len() + length(info) > sys_info$max_seg_size * CHARS_PER_WORD then do;
      767 							/* handle overflow of info seg by 	*/
      768 							/* writing new data into a new 	*/
      769 							/* permanent segment, leaving the old	*/
      770 							/* segment untouched.		*/
      771 	     call upd_print_err_ ( 0, 0, "Warning", "", entry, "",	/* print a warning to the effect	*/
      772 		"^2xInfo segment is full^/(^a).
      773   New data placed in ^a.
      774   Please rename info segment as appropriate.",
      775 		info_name, pathname_ (log_dir, INFO_NAME_WHEN_FULL));
      776 	     on record_quota_overflow begin;
      777 		call hcs_$delentry_seg (full_info_p, code);
      778 		code = error_table_$rqover;
      779 		go to rqo_full;
      780 		end;
      781 	     call initiate_file_$create (log_dir, INFO_NAME_WHEN_FULL, RW_ACCESS,
      782 		full_info_p, created_sw, full_bc, code);
      783 	     if code = 0 & ^created_sw then do;
      784 		code = error_table_$namedup;
      785 		call terminate_file_ (full_info_p, 0, TERM_FILE_TERM, ignore);
      786 		end;
      787 	     if code ^= 0 then do;
      788 rqo_full:		call upd_task_err_ (code, 0, argp, entry, "Creating ^a.
      789 Documentation for current installation lost.",
      790 		     pathname_ (log_dir, INFO_NAME_WHEN_FULL));
      791 		go to un_info;
      792 		end;
      793 	     call out$copy (full_info_p, full_bc);
      794 	     revert record_quota_overflow;
      795 	     call terminate_file_ (full_info_p, full_bc, TERM_FILE_TRUNC_BC_TERM, code);
      796 	     if code ^= 0 then do;
      797 		call upd_task_err_ (code, 0, argp, entry, "Setting bit count on ^a.
      798 Documentation for current installation lost.",
      799 		     pathname_ (log_dir, INFO_NAME_WHEN_FULL));
      800 		go to un_info;
      801 		end;
      802 	     end;
      803 	else do;
      804 	     call out$str (info);
      805 	     on record_quota_overflow begin;		/* restore info contents to its previous value 	*/
      806 		call save$copy (info_p, info_bc);	/*   abandon built data, report the error.	*/
      807 		call upd_task_err_ (error_table_$rqover, 0, argp, entry,
      808 		   "Updating ^a.
      809 Documentation for current installation lost.",
      810 		     info_name);
      811 		go to term_info;
      812 		end;
      813 	     info_p = header_p;
      814 	     call out$copy (info_p, info_bc);
      815 term_info:     revert record_quota_overflow;
      816 	     call terminate_file_ (info_p, info_bc, TERM_FILE_TRUNC_BC, code);
      817 	     if code ^= 0 then
      818 		call upd_task_err_ (code, 0, argp, entry, "Writing ^a.
      819 Segment may be damaged.",
      820 		     info_name);
      821 	     end;
      822 
      823 un_info:	call terminate_file_ (info_p, 0, TERM_FILE_TERM, code);	/* terminate original and copy */
      824 	call release_temp_segments_ ("upd_doc_task_", p, code);
      825 	call upd_log_task_$unlock ((info_name), code);		/* unlock the lock */
      826 	if code ^= 0 then
      827 	     call upd_task_err_ (code, 0, argp, entry, "While unlocking ^a", info_name);
      828 
      829 
      830 
      831 return:	if runsw then do;
      832 	     Sfwd_done = ^Sfwd_done;				/* reset the forward done sw */
      833 	     if substr(log_directory, 1, 1) = " " then
      834 		log_directory = get_wdir_();
      835 	     end;
      836 	if logsw then					/* remember to detach I/O stream */
      837 	     call ios_$detach ( "installation_log_", "", "", scode);
      838 	return;
      839 
      840 lock_err:	call upd_task_err_ ( code, 0, argp, entry, "Referencing ^R^a^B.", log_name);
      841 	go to return;
      842 
      843 
      844 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      845 /*							       */
      846 /* The following declarations and internal procedures provide a utility for  */
      847 /* building up the new contents of an info segment in a temp segment.	       */
      848 /*							       */
      849 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      850 
      851 	
      852 
      853     dcl   out_len		fixed bin(21),		/* data built so far.			*/
      854 	out_ptr		ptr,
      855 	out_seg		char(out_len) based (out_ptr);
      856 
      857 
      858 out$copy: proc (target_ptr, target_bc);			/* proc to copy built data into info seg.	*/
      859 
      860     dcl	target_ptr	ptr,
      861 	target_bc		fixed bin(24);
      862 
      863 	target_ptr -> out_seg = out_seg;
      864 	target_bc = length(out_seg) * BITS_PER_CHAR;
      865 	return;
      866 
      867 
      868 out$init:	entry (aout_ptr);				/* procedure to initialize temp seg to empty 	*/
      869 						/* state (ie, no built data).			*/
      870 
      871     dcl	aout_ptr		ptr;
      872 
      873 	out_ptr = aout_ptr;
      874 	out_len = 0;
      875 	return;
      876 
      877 
      878 out$len:	entry returns(fixed bin(21));			/* function returning length of data built so far.*/
      879 
      880 	return (out_len);
      881 
      882 
      883 out$str:	entry (str);				/* procedure to add a string to end of built data.*/
      884 
      885     dcl	str		char(*);
      886     dcl	insert_point	fixed bin(21);
      887 
      888 	insert_point = out_len + 1;
      889 	out_len = out_len + length(str);
      890 	substr(out_seg,insert_point) = str;
      891 	return;
      892 
      893 	end out$copy;
      894 
      895 
      896 
      897     dcl	save_len		fixed bin(21),		/* saved copy of previous info seg contents,	*/
      898 	save_ptr		ptr,			/*   stored beyond end of built (new) data.	*/
      899 	save_seg		char(save_len) based(save_ptr);
      900 
      901 save$copy:
      902 	proc (target_ptr, target_bc);			/* proc to copy saved data into info seg.	*/
      903 
      904     dcl	target_ptr	ptr,
      905 	target_bc		fixed bin(24);
      906 
      907 	target_ptr -> save_seg = save_seg;
      908 	target_bc = length(save_seg) * BITS_PER_CHAR;
      909 	return;
      910 
      911 save$init:
      912 	entry (asave_ptr);				/* procedure to initialize temp seg to empty 	*/
      913 						/* state (ie, no built data).			*/
      914 
      915     dcl	asave_ptr		ptr;
      916 
      917 	save_ptr = asave_ptr;
      918 	save_len = 0;
      919 	return;
      920 
      921 
      922 save$str:						/* procedure to add data to saved info seg image. */
      923      	entry (str);
      924 
      925     dcl	str		char(*);
      926     dcl	insert_point	fixed bin(21);
      927 
      928 	insert_point = save_len + 1;
      929 	save_len = save_len + length(str);
      930 	substr(save_seg,insert_point) = str;
      931 	return;
      932 
      933 	end save$copy;
      934 
      935 /*			end of upd_doc_task_$write_prose					 */
      936 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
      937 
      938 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
      939 
      940 doc_util_:   procedure (p, bitc, ptrp, Segname, unb_sw, i, bf_date, bfname, ec);
      941 /* Procedure which returns information about referenced segment. Notably,
      942*   name (or component names) and compile date ( or component compile dates ).	*/
  1     1 /* BEGIN INCLUDE SEGMENT ... symbol_block.incl.pl1
  1     2*coded February 8, 1972 by Michael J. Spier	*/
  1     3 
  1     4 /* last modified may 3, 1972  by M. Weaver */
  1     5 
  1     6 declare	1 sb aligned based(sblkp),		/* structure describing a standard symbol block */
  1     7 	2 decl_vers fixed bin,		/* version number of current structure format */
  1     8 	2 identifier char(8) aligned,		/* symbolic code to define purpose of this symb block */
  1     9 	2 gen_version_number fixed bin,	/* positive integer designating version of object generator */
  1    10 	2 gen_creation_time fixed bin(71),	/* clock reading of date/time generator was created */
  1    11 	2 obj_creation_time fixed bin(71),	/* clock reading of date/time object was generated */
  1    12 	2 generator char(8) aligned,		/* name of processor which generated segment */
  1    13 	2 gen_name_offset bit(18) unaligned,	/* offset of generator name in words rel to base of symbol block */
  1    14 	2 gen_name_length bit(18) unaligned,	/* length of printable generator version name in characters */
  1    15 	2 uid_offset bit(18) unaligned,	/* offset of creator id in words rel to base of symbol block */
  1    16 	2 uid_length bit(18) unaligned,	/* length of standard Multics id of object creator in characters */
  1    17 	2 comment_offset bit(18) unaligned,	/* offset of comment in words relative to base of symbol block */
  1    18 	2 comment_length bit(18) unaligned,	/* length of printable generator comment in characters */
  1    19 	2 tbound bit(18) unaligned,		/* specifies mod of text section base boundary */
  1    20 	2 stat_bound bit(18) unaligned,	/* specifies mod of internal static base boundary */
  1    21 	2 source_map bit(18) unaligned,	/* offset relative to base of symbol block of source map structure */
  1    22 	2 area_ptr bit(18) unaligned,		/* offset of block info in words relative to base of symbol block */
  1    23 	2 symb_base bit(18) unaligned,	/* back pointer (rel to base of symb block) to base of symb section */
  1    24 	2 block_size bit(18) unaligned,	/* size in words of entire symbol block */
  1    25 	2 next_block bit(18) unaligned,	/* if ^= "0"b, is thread (rel to base of symb section) to next symb block */
  1    26 	2 rel_text bit(18) unaligned,		/* offset rel to base of symbol block of text sect relocation info */
  1    27 	2 rel_def bit(18) unaligned,		/* offset rel to base of symb block of def section relocation info */
  1    28 	2 rel_link bit(18) unaligned,		/* offset rel to base of symb block of link sect relocation info */
  1    29 	2 rel_symb bit(18) unaligned,		/* offset rel to base of symb block of symb sect relocation info */
  1    30 	2 default_truncate bit(18) unaligned,	/* offset RTBOSB for binder to automatically trunc. symb sect. */
  1    31 	2 optional_truncate bit(18) unaligned;	/* offset RTBOSB for binder to optionally truncate symb section */
  1    32 
  1    33 /* END INCLUDE SEGMENT ... symbol_block.incl.pl1 */
      943 
  2     1 	/* BEGIN INCLUDE SEGMENT ... bind_map.incl.pl1 Michael J. Spier, 4/29/71  */
  2     2 	/* last modified  April, 1972 by M. Weaver */
  2     3 
  2     4 declare	1 bindmap aligned based(bmp),
  2     5 
  2     6 	2 dcl_version fixed bin,		/* version number of this structure = 1 */
  2     7 	2 n_components fixed bin,		/* number of entries in this array */
  2     8 	2 component(0 refer(bindmap.n_components)) aligned,
  2     9 	  3 name,				/* objectname of component object */
  2    10 	    4 name_ptr bit(18) unaligned,	/* pointer to name string */
  2    11 	    4 name_lng bit(18) unaligned,	/* length of name string */
  2    12 	  3 comp_name char(8) aligned,	/* name of component's compiler */
  2    13 	  3 text_start bit(18) unaligned,	/* text section relocation counter */
  2    14 	  3 text_lng bit(18) unaligned,	/* length of text section */
  2    15 	  3 stat_start bit(18) unaligned,	/* internal static relocation counter */
  2    16 	  3 stat_lng bit(18) unaligned,	/* length of internal static */
  2    17 	  3 symb_start bit(18) unaligned,	/* symbol section relocation counter */
  2    18 	  3 symb_lng bit(18) unaligned,	/* length of symbol section */
  2    19 	  3 defblock_ptr bit(18) unaligned,	/* pointer to components definition block */
  2    20 	  3 n_blocks bit(18) unaligned,	/* number of symbol blocks the component has */
  2    21 	2 bf_name aligned,			/* name of bindfile */
  2    22 	  3 bf_name_ptr bit(18) unaligned,	/* pointer to name string */
  2    23 	  3 bf_name_lng bit(18) unaligned,	/* length of name string */
  2    24 	2 bf_date_up char(24),		/* date updated in archive */
  2    25 	2 bf_date_mod char(24);		/* date last modified */
  2    26 
  2    27 /* END INCLUDE SEGMENT ... bind_map.incl.pl1 */
      944 
  3     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  3     2*coded February 8, 1972 by Michael J. Spier	*/
  3     3 /* modified May 26, 1972 by M. Weaver */
  3     4 /* modified 15 April, 1975 by M. Weaver */
  3     5 
  3     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  3     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  3     8 	2 textp pointer,			/* pointer to beginning of text section */
  3     9 	2 defp pointer,			/* pointer to beginning of definition section */
  3    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  3    11 	2 statp pointer,			/* pointer to beginning of static section */
  3    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  3    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  3    14 	2 tlng fixed bin,			/* length in words of text section */
  3    15 	2 dlng fixed bin,			/* length in words of definition section */
  3    16 	2 llng fixed bin,			/* length in words of linkage section */
  3    17 	2 ilng fixed bin,			/* length in words of static section */
  3    18 	2 slng fixed bin,			/* length in words of symbol section */
  3    19 	2 blng fixed bin,			/* length in words of break map */
  3    20 	2 format,				/* word containing bit flags about object type */
  3    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  3    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  3    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  3    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  3    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  3    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  3    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  3    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  3    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  3    30 	  3 pad bit(27) unaligned,
  3    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  3    32 	2 textlinkp pointer,		/* ptr to first link in text */
  3    33 
  3    34 	/* LIMIT OF BRIEF STRUCTURE */
  3    35 
  3    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  3    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  3    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  3    39 	2 cvers aligned,			/* generator version name in printable char string form */
  3    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  3    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  3    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  3    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  3    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  3    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  3    46 
  3    47 	/* LIMIT OF DISPLAY STRUCTURE */
  3    48 
  3    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  3    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  3    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  3    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  3    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  3    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  3    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  3    56 					/* currently not used by system */
  3    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  3    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  3    59 
  3    60 declare	object_info_version_2 fixed bin int static init(2);
  3    61 
  3    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      945 
      946 
      947 dcl  1  oi  aligned like object_info;
      948 dcl  p 		ptr,				/* ptr to segment                 IN  */
      949      bitc 	fixed bin(24),			/* bitcount of seg                IN  */
      950      ptrp 	ptr,				/* ptr to structure               IN  */
      951      Segname	char (32) aligned,			/* name of seg, we might need it  IN  */
      952      unb_sw 	bit (1),				/* = 0 if bound, = 1 if not bound OUT */
      953      i 		fixed bin,			/* number of components of        OUT */
      954      bf_date	char(24) aligned,			/* bindfile date updated	    OUT */
      955      bfname	char(32) aligned,			/* bindfile name		    OUT */
      956      ec 		fixed bin(35);			/* return error code              OUT */
      957 dcl  1  struc  (1000)  aligned based (ptrp),		/* likeness of ext  structure          */
      958         2  segname  	char (32) aligned,		/* name of component         */
      959         2  dtc      	fixed bin (71);		/* compile time of component */
      960 dcl  ( j, k ) 		fixed bin,
      961      (bmp, sblkp, mapp, q)	ptr,
      962      name			char (k) based (q),
      963      (addr, addrel, index, substr)	builtin;
      964 dcl  object_info_$display 	entry (ptr, fixed bin (24), ptr, fixed bin (35)),
      965      get_bound_seg_info_ 	entry (ptr, fixed bin (24), ptr, ptr, ptr, fixed bin (35));
      966 
      967 	     i = 1;
      968 	     oi.version_number = 2;
      969 	     call object_info_$display (p, bitc, addr (oi), ec);
      970 	          if ec ^= 0 then do;		/* might not be an object segment  */
      971 		     ptrp->struc(1).segname = Segname;
      972 		     ptrp->struc(1).dtc = 0;
      973 		     unb_sw = "1"b;
      974 		     return;
      975 		     end;
      976 	     if oi.format.bound then do;			/* if bound then do this...   */
      977 		unb_sw = "0"b;
      978 		call get_bound_seg_info_ (p, bitc, addr (oi), bmp, sblkp, ec);
      979 		     if ec ^= 0 then return;			/* bad error here  */
      980 		do i = 1 to n_components while ( i < 1001 );	/* put upper limit on this */
      981 		     q = addrel (sblkp, component (i).name.name_ptr);
      982 		     k = fixed (component (i).name_lng, 18);
      983 		     j = fixed (component (i).symb_start, 18);
      984 		     mapp = addrel (oi.symbp, j);
      985 		     ptrp->struc(i).dtc = mapp->sb.obj_creation_time;
      986 		     ptrp->struc(i).segname = substr(name, 1, k);
      987 		     end;
      988 		i = i - 1;				/* do loops count one too many */
      989 		if dcl_version > 1 then do;			/* report bindfile date if possible */
      990 		     bf_date = bindmap.bf_date_up;
      991 		     q = addrel (sblkp, bf_name_ptr);
      992 		     k = fixed ( bf_name_lng, 18 );
      993 		     if k ^= 0 then bfname = substr ( name, 1, k);
      994 		     end;
      995 		else do;
      996 		     bf_date = " ";				/* earlier version */
      997 		     k = index(Segname, " ");
      998 		     bfname = substr(Segname, 1, k)||".bind";
      999 		     end;
     1000 		return;
     1001 	          end;
     1002 	     ptrp->struc(1).segname = Segname;			/* for unbound segments, the following... */
     1003 	     ptrp->struc(1).dtc = oi.compile_time;
     1004           end doc_util_;
     1005 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
     1006 /*  */
     1007 /*  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  ==  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  */
     1008 
     1009 valid_lib_:	 procedure ( dn, lib);
     1010 
     1011 /* Since directories can be referenced by several names, this procedure standardizes
     1012*   the system library names for documentation purposes and sets them to CAPS		     */
     1013 
     1014 dcl
     1015      dn 	char (168) aligned,				/* primary directory name       IN */
     1016      lib 	char (168) aligned,				/* library name (or directory)  OUT */
     1017      lb   char (32) aligned,
     1018      i 	fixed bin;
     1019 
     1020 dcl n_root_libs    fixed bin;
     1021 
     1022 dcl root_libs (27) char (32) aligned init (
     1023 	"standard", "system_library_standard", "sss", "SSS",
     1024 	"system_library_dev",
     1025 	"system_library_tools", "tools", "t",
     1026 	"system_library_languages", "lang",
     1027 	"system_library_auth_maint", "auth_maint", "am", "aml",
     1028 	"installation_maintained_library", "iml", "IML",
     1029 	"system_library_unbundled", "unbundled", "unb",
     1030 	"network", "net", "system_library_network", "NET",
     1031 	 "system_library_obsolete", "obsolete", "obs" );
     1032 
     1033 dcl LIBS (27) char (10) aligned init (
     1034 	"SSS", "SSS", "SSS", "SSS",
     1035 	"DEV",
     1036 	"TOOLS", "TOOLS", "TOOLS",
     1037 	"LANG", "LANG",
     1038 	"AML", "AML", "AML", "AML",
     1039 	"IML", "IML", "IML",
     1040 	"UNB", "UNB", "UNB",
     1041 	"NET", "NET", "NET", "NET",
     1042 	 "OBS", "OBS", "OBS" );
     1043 
     1044 dcl n_odd_libs 	fixed bin;
     1045 
     1046 dcl ODD_LIBS (10) char (10) init (
     1047 	"INCL",
     1048 	"INFO",
     1049 	"IIS",
     1050 	"RDMS",
     1051 	"RDMS_TOOLS",
     1052 	"RDMS_INCL",
     1053 	"RDMS_INFO",
     1054 	"HARD",
     1055 	"BOS",
     1056 	"MCS" );
     1057 
     1058 	n_root_libs = dimension ( LIBS, 1 );
     1059 	n_odd_libs  = dimension ( ODD_LIBS, 1 );
     1060 
     1061 	lb = substr (dn, 2, length(lb));			/* get rid of leading ">" */
     1062 	i = index ( lb , ">");
     1063 	if i ^= 0
     1064 	    then lb = substr ( lb, 1, (i-1));
     1065 
     1066 	do i = 1 to n_root_libs;
     1067 	     if lb = root_libs(i)
     1068 		then go to got_lib;			/* look for system library */
     1069 	     end;
     1070 	i = 1;
     1071 	call MATCH_PATHS ( dn, ">ldd>include", code );		/* INCLUDE SEG? */
     1072 	if code = 0
     1073 	     then go to got_odd_lib;	
     1074 
     1075 	i = 2;	
     1076 	call MATCH_PATHS ( dn, ">doc>info", code );		/* INFO SEG? */
     1077 	if code = 0
     1078 	     then go to got_odd_lib;	
     1079 
     1080 	i = 3;	
     1081 	call MATCH_PATHS ( dn, ">doc>iis", code );		/* IML INFO SEG? */
     1082 	if code = 0
     1083 	     then go to got_odd_lib;	
     1084 
     1085 	i = 4;	
     1086 	call MATCH_PATHS ( dn, ">lib>rdms", code );		/* RDMS SERVICE? */
     1087 	if code = 0
     1088 	     then go to got_odd_lib;	
     1089 
     1090 	i = 5;	
     1091 	call MATCH_PATHS ( dn, ">lib>rdms>tools", code);		/* RDMS TOOLS? */
     1092 	if code = 0
     1093 	     then go to got_odd_lib;	
     1094 
     1095 	i = 6;	
     1096 	call MATCH_PATHS ( dn, ">lib>rdms>include", code );	/* RDMS INCL? */
     1097 	if code = 0
     1098 	     then go to got_odd_lib;	
     1099 
     1100 	i = 7;	
     1101 	call MATCH_PATHS ( dn, ">lib>rdms>info", code );		/* RDMS INFO? */
     1102 	if code = 0
     1103 	     then go to got_odd_lib;	
     1104 
     1105 	i = 8;	
     1106 	call MATCH_PATHS (dn, ">ldd>hard>object", code );		/* HARDCORE */
     1107 	if code = 0					/*  .        */
     1108 	     then go to got_odd_lib;				/*  .        */
     1109 							/*  .        */
     1110 	call MATCH_PATHS (dn, ">ldd>hard>execution", code );	/* HARDCORE */
     1111 	if code = 0
     1112 	     then go to got_odd_lib;	
     1113 
     1114 	i = 9;	
     1115 	call MATCH_PATHS (dn, ">ldd>bos>object", code );		/* BOS */
     1116 	if code = 0					/*  .  */
     1117 	     then go to got_odd_lib;				/*  .  */
     1118 							/*  .  */
     1119 	call MATCH_PATHS (dn, ">ldd>bos>execution", code );	/* BOS */
     1120 	if code = 0
     1121 	     then go to got_odd_lib;	
     1122 
     1123 	i = 10;	
     1124 	call MATCH_PATHS (dn, ">ldd>comm>fnp>o", code );		/* MCS */
     1125 	if code = 0					/*  .  */
     1126 	     then go to got_odd_lib;				/*  .  */
     1127 							/*  .  */
     1128 	call MATCH_PATHS (dn, ">ldd>comm>fnp>execution", code);	/* MCS */
     1129 	if code = 0
     1130 	     then go to got_odd_lib;	
     1131 
     1132 	code = 0;						/* zap error code - not needed */
     1133 no_lib:	lib = dn;						/* can't get a proper name for this one */
     1134 	return;						/* if not system lib, then leave it alone */
     1135 
     1136 got_lib:	lib = LIBS(i);				/* if system lib, then set to CAPS */
     1137 	return;
     1138 
     1139 got_odd_lib:
     1140 	lib = ODD_LIBS(i);				/* if known ODD lib, then set to CAPS */
     1141 	return;
     1142 
     1143      end valid_lib_;
     1144 
     1145 
     1146 MATCH_PATHS:	proc ( path1, path2, code );
     1147 					/* This procedure compares the unique id's of the   */
     1148 					/* two input pathnames to determine if they REALLY  */
     1149 					/* point to the same place.  If so, a 0 is returned */
     1150 					/* in the error code.  If not, a non-zero.          */
     1151 
     1152 dcl
     1153      path1	char(168) aligned,
     1154      path2	char(168) aligned,
     1155      code		fixed bin(35);
     1156 
     1157 dcl
     1158      UID1		bit(36),
     1159      UID2		bit(36),
     1160      dir_name	char(168) aligned,
     1161      entry_name	char(32) aligned;
     1162 
     1163 dcl
     1164      expand_pathname_	entry (char(*) aligned, char(*) aligned, char(*) aligned, fixed bin(35));
     1165 
     1166 
     1167 	call expand_pathname_ (path1, dir_name, entry_name, code );
     1168 	if code ^= 0
     1169 	     then return;
     1170 
     1171 	call upd_status_$long ( dir_name, entry_name, 1, addr(Stat), null, code );
     1172 	if code ^=0
     1173 	     then return;
     1174 
     1175 	UID1 = Stat.uid;
     1176 
     1177 	call expand_pathname_ ( path2, dir_name, entry_name, code );
     1178 	if code ^= 0
     1179 	     then return;
     1180 
     1181 	call upd_status_$long ( dir_name, entry_name, 1, addr(Stat), null, code );
     1182 	if code ^= 0
     1183 	     then return;
     1184 
     1185 	UID2 = Stat.uid;
     1186 
     1187 	if UID1 = UID2
     1188 	     then code = 0;
     1189 	     else code = 1;
     1190 
     1191 	return;
     1192 
     1193 	end MATCH_PATHS;
     1194 
  4     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  4     2*
  4     3*   Values for the "access mode" argument so often used in hardcore
  4     4*   James R. Davis 26 Jan 81  MCR 4844
  4     5*   Added constants for SM access 4/28/82 Jay Pattin
  4     6*   Added text strings 03/19/85 Chris Jones
  4     7**/
  4     8 
  4     9 
  4    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  4    11 dcl	(
  4    12 	N_ACCESS		   init ("000"b),
  4    13 	R_ACCESS		   init ("100"b),
  4    14 	E_ACCESS		   init ("010"b),
  4    15 	W_ACCESS		   init ("001"b),
  4    16 	RE_ACCESS		   init ("110"b),
  4    17 	REW_ACCESS	   init ("111"b),
  4    18 	RW_ACCESS		   init ("101"b),
  4    19 	S_ACCESS		   init ("100"b),
  4    20 	M_ACCESS		   init ("010"b),
  4    21 	A_ACCESS		   init ("001"b),
  4    22 	SA_ACCESS		   init ("101"b),
  4    23 	SM_ACCESS		   init ("110"b),
  4    24 	SMA_ACCESS	   init ("111"b)
  4    25 	)		   bit (3) internal static options (constant);
  4    26 
  4    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  4    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  4    29 
  4    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  4    31 			   static options (constant);
  4    32 
  4    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  4    34 			   static options (constant);
  4    35 
  4    36 dcl	(
  4    37 	N_ACCESS_BIN	   init (00000b),
  4    38 	R_ACCESS_BIN	   init (01000b),
  4    39 	E_ACCESS_BIN	   init (00100b),
  4    40 	W_ACCESS_BIN	   init (00010b),
  4    41 	RW_ACCESS_BIN	   init (01010b),
  4    42 	RE_ACCESS_BIN	   init (01100b),
  4    43 	REW_ACCESS_BIN	   init (01110b),
  4    44 	S_ACCESS_BIN	   init (01000b),
  4    45 	M_ACCESS_BIN	   init (00010b),
  4    46 	A_ACCESS_BIN	   init (00001b),
  4    47 	SA_ACCESS_BIN	   init (01001b),
  4    48 	SM_ACCESS_BIN	   init (01010b),
  4    49 	SMA_ACCESS_BIN	   init (01011b)
  4    50 	)		   fixed bin (5) internal static options (constant);
  4    51 
  4    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1195 
     1196 
  5     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  5     2 /* format: style2,^inddcls,idind32 */
  5     3 
  5     4 declare 1 terminate_file_switches	based,
  5     5 	2 truncate		bit (1) unaligned,
  5     6 	2 set_bc			bit (1) unaligned,
  5     7 	2 terminate		bit (1) unaligned,
  5     8 	2 force_write		bit (1) unaligned,
  5     9 	2 delete			bit (1) unaligned;
  5    10 
  5    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  5    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  5    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  5    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  5    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  5    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  5    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  5    18 
  5    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1197 
     1198 
     1199 end upd_doc_task_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/11/87  0926.5  upd_doc_task_.pl1                 >spec>install>MR12.1-1080>upd_doc_task_.pl1
943          1    05/06/74  1752.6  symbol_block.incl.pl1             >ldd>include>symbol_block.incl.pl1
944          2    09/18/74  1700.9  bind_map.incl.pl1                 >ldd>include>bind_map.incl.pl1
945          3    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
1195         4    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1197         5    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                                      based           area(1024)               dcl 69 ref 479
BITS_PER_CHAR                          constant        fixed bin(17,0)          initial dcl 102 ref 731 864 908
CHARS_PER_WORD                         constant        fixed bin(17,0)          initial dcl 103 ref 766
Date                            051462 automatic       char(16)                 dcl 211 set ref 538* 540* 542 547* 552* 566* 573*
                                                                                  712* 758 758
INFO_HEADER                     000005 constant        char(56)                 initial unaligned dcl 48 ref 737 737 740
INFO_NAME                       000033 constant        char(32)                 initial unaligned dcl 48 set ref 284 289 725*
INFO_NAME_WHEN_FULL             000023 constant        char(32)                 initial unaligned dcl 48 set ref 771* 771* 781* 788*
                                                                                  788* 797* 797*
Inon_nl                         000224 automatic       fixed bin(21,0)          dcl 90 set ref 751* 752 753 754
LIBS                            072264 automatic       char(10)                 initial array dcl 1033 set ref 1033* 1033* 1033*
                                                                                  1033* 1033* 1033* 1033* 1033* 1033* 1033* 1033*
                                                                                  1033* 1033* 1033* 1033* 1033* 1033* 1033* 1033*
                                                                                  1033* 1033* 1033* 1033* 1033* 1033* 1033* 1033*
                                                                                  1058 1136
LOG_NAME                        000043 constant        char(32)                 initial unaligned dcl 48 ref 283 288
NL                              000004 constant        char(1)                  initial unaligned dcl 104 set ref 656 666 751 760*
                                                                                  762* 763* 764*
NL_NL                                  constant        char(2)                  initial unaligned dcl 106 ref 744 745
Nlib                     20            based           char(168)                level 2 dcl 72 set ref 483* 552* 566* 573*
Nsegname                               based           char(32)                 level 2 dcl 72 set ref 481* 552* 559 566* 568
ODD_LIBS                        072406 automatic       char(10)                 initial array unaligned dcl 1046 set ref 1046* 1046*
                                                                                  1046* 1046* 1046* 1046* 1046* 1046* 1046* 1046*
                                                                                  1059 1139
Olib                     72            based           char(168)                level 2 dcl 72 set ref 484* 566* 573*
Osegname                 10            based           char(32)                 level 2 dcl 72 set ref 482* 559 559* 568 568* 573*
Pseg                            071530 automatic       pointer                  initial dcl 244 set ref 244* 384* 389* 392* 399*
                                                                                  404* 417*
RW_ACCESS                       000103 constant        bit(3)                   initial unaligned dcl 4-11 set ref 781*
Segname                                parameter       char(32)                 dcl 948 ref 940 971 997 998 1002
Sfwd_done                              parameter       bit(1)                   unaligned dcl 27 set ref 259 266 518 601* 601 637
                                                                                  832* 832
Stat                            047376 automatic       structure                level 1 dcl 190 set ref 324 324 1171 1171 1181 1181
TERM_FILE_TERM                  000147 constant        bit(3)                   initial unaligned dcl 5-14 set ref 785* 823*
TERM_FILE_TRUNC_BC              000003 constant        bit(2)                   initial unaligned dcl 5-13 set ref 816*
TERM_FILE_TRUNC_BC_TERM         000102 constant        bit(3)                   initial unaligned dcl 5-15 set ref 795*
UID1                            072452 automatic       bit(36)                  unaligned dcl 1157 set ref 1175* 1187
UID2                            072453 automatic       bit(36)                  unaligned dcl 1157 set ref 1185* 1187
Uid                                    parameter       bit(36)                  array dcl 27 ref 252 328 328
acode                                  parameter       fixed bin(35,0)          dcl 27 set ref 252 259 266 300* 619*
actions                         047410 automatic       fixed bin(17,0)          array dcl 211 set ref 432* 443* 449* 456* 465 473*
                                                                                  492
actxn                   150            based           fixed bin(17,0)          level 2 dcl 72 set ref 486* 551 552
added                           000246 automatic       fixed bin(17,0)          initial dcl 123 set ref 123* 350 456
addr                                                   builtin function         dcl 960 in procedure "doc_util_" ref 969 969 978 978
addr                                                   builtin function         dcl 246 in procedure "upd_doc_task_" ref 274 275 275
                                                                                  276 278 304 311 323 324 324 379 380 504 511 512
                                                                                  518 529 530 534 614 626 626 628 629 637 683 683
                                                                                  694 695 700 700 1171 1171 1181 1181
addrel                                                 builtin function         dcl 960 ref 981 984 991
aout_ptr                               parameter       pointer                  dcl 871 ref 868 873
areap                                  parameter       pointer                  dcl 27 ref 252 259 266 479
argp                            071520 automatic       pointer                  initial dcl 244 set ref 244* 272* 278* 368* 410*
                                                                                  512* 525* 530* 629* 695* 705* 721* 727* 788* 797*
                                                                                  807* 817* 826* 840*
asave_ptr                              parameter       pointer                  dcl 915 ref 911 917
asev                                   parameter       fixed bin(17,0)          dcl 27 set ref 252 259 266 276 300 300* 619 619*
axn                             051361 automatic       fixed bin(17,0)          dcl 211 set ref 350* 354* 356* 360* 364* 446 473 486
b1_date                         051362 automatic       char(24)                 initial dcl 211 set ref 211* 389* 459 459
b1_name                         051376 automatic       char(32)                 initial dcl 211 set ref 211* 389* 469
b2_date                         051370 automatic       char(24)                 initial dcl 211 set ref 211* 404* 459 459
b2_name                         051406 automatic       char(32)                 initial dcl 211 set ref 211* 404* 471
bf_date                                parameter       char(24)                 dcl 948 set ref 940 990* 996*
bf_date_up                             based           char(24)                 level 2 dcl 2-4 ref 990
bf_name                                based           structure                level 2 dcl 2-4
bf_name_lng                            based           bit(18)                  level 3 packed unaligned dcl 2-4 ref 992
bf_name_ptr                            based           bit(18)                  level 3 packed unaligned dcl 2-4 ref 991
bfname                                 parameter       char(32)                 dcl 948 set ref 940 993* 998*
bindmap                                based           structure                level 1 dcl 2-4
bitc                                   parameter       fixed bin(24,0)          dcl 948 in procedure "doc_util_" set ref 940 969*
                                                                                  978*
bitc                            051416 automatic       fixed bin(24,0)          dcl 211 in procedure "upd_doc_task_" set ref 384*
                                                                                  389* 399* 404*
blkp                            071532 automatic       pointer                  initial dcl 244 set ref 244*
bmp                             071702 automatic       pointer                  dcl 960 set ref 978* 980 981 982 983 989 990 991 992
bound                    24(01) 071612 automatic       bit(1)                   level 3 packed unaligned dcl 947 set ref 976
brief_sw                  0(07)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 626
buffer                          051417 automatic       char(132)                dcl 211 set ref 653* 656 658 661 666* 676
c                                      based           structure                level 1 dcl 58
cactxn                  162            based           fixed bin(17,0)          array level 3 dcl 72 set ref 492* 586
cname                   152            based           char(32)                 array level 3 dcl 72 set ref 491* 587* 590*
code                                   parameter       fixed bin(35,0)          dcl 1152 in procedure "MATCH_PATHS" set ref 1146
                                                                                  1167* 1168 1171* 1172 1177* 1178 1181* 1182 1187*
                                                                                  1189*
code                            051460 automatic       fixed bin(35,0)          dcl 211 in procedure "upd_doc_task_" set ref 315*
                                                                                  324* 325 330* 368* 384* 385 385 386 389* 390 390
                                                                                  392* 399* 400 400 401 404* 405 406 407 410* 417*
                                                                                  523* 524 525* 600* 690* 691 704* 705 705* 713* 714
                                                                                  719* 720 721* 725* 726 726 727* 777* 778* 781* 783
                                                                                  784* 787 788* 795* 796 797* 816* 817 817* 823*
                                                                                  824* 825* 826 826* 840* 1071* 1072 1076* 1077
                                                                                  1081* 1082 1086* 1087 1091* 1092 1096* 1097 1101*
                                                                                  1102 1106* 1107 1110* 1111 1115* 1116 1119* 1120
                                                                                  1124* 1125 1128* 1129 1132*
code                                   based           fixed bin(35,0)          level 2 in structure "status" dcl 114 in procedure
                                                                                  "upd_doc_task_" set ref 511 512* 529 530* 628 629*
                                                                                  694 695*
com                             000253 automatic       char(17)                 initial array unaligned dcl 130 set ref 130* 130*
                                                                                  130* 130* 130* 130* 130* 130* 552*
comp_array                      000315 automatic       char(16)                 initial array unaligned dcl 140 set ref 140* 140*
                                                                                  140* 140* 587*
compile_time             32     071612 automatic       fixed bin(71,0)          level 2 dcl 947 set ref 1003
component                 2            based           structure                array level 2 dcl 2-4
control                         051461 automatic       bit(36)                  initial dcl 211 set ref 211* 311 314 323 342 345 349
                                                                                  353 359 363 383 398 426 435 437 469
control_base                           based           structure                level 1 dcl 110
control_word                           parameter       bit(36)                  dcl 27 set ref 252 259 266 274 275 275 276 278 304
                                                                                  504 518 534 614 626 626 637
created_sw                      000225 automatic       bit(1)                   dcl 90 set ref 781* 783
cu_$arg_list_ptr                000012 constant        entry                    external dcl 146 ref 272
date                    144            based           char(16)                 level 2 dcl 72 set ref 485* 542* 555* 575*
date_time_$fstime               000040 constant        entry                    external dcl 146 ref 538 547 712
dcl_version                            based           fixed bin(17,0)          level 2 dcl 2-4 ref 989
de_install_date                        parameter       fixed bin(35,0)          dcl 27 set ref 259 547*
de_installation_sw              051466 automatic       bit(1)                   unaligned dcl 211 set ref 534* 536 554 565
del_com                         000252 automatic       fixed bin(17,0)          initial dcl 123 set ref 123* 364* 432
deleted                         000250 automatic       fixed bin(17,0)          initial dcl 123 set ref 123* 360
detail_sw                 0(08)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 504 626
dimension                                              builtin function         dcl 246 ref 1058 1059
dir_name                        072454 automatic       char(168)                dcl 1157 set ref 1167* 1171* 1177* 1181*
divide                                                 builtin function         dcl 246 ref 731
dn                                     parameter       char(168)                dcl 1014 set ref 1009 1061 1071* 1076* 1081* 1086*
                                                                                  1091* 1096* 1101* 1106* 1110* 1115* 1119* 1124*
                                                                                  1128* 1133
dname                                  parameter       char(168)                array dcl 27 set ref 252 311 324* 331 342* 345* 376
                                                                                  384 395 399
dtc                      10     023756 automatic       fixed bin(71,0)          array level 2 in structure "s2" dcl 186 in procedure
                                                                                  "upd_doc_task_" set ref 440
dtc                      10     000336 automatic       fixed bin(71,0)          array level 2 in structure "s1" dcl 183 in procedure
                                                                                  "upd_doc_task_" set ref 440
dtc                      10            based           fixed bin(71,0)          array level 2 in structure "struc" dcl 957
                                                                                  in procedure "doc_util_" set ref 972* 985* 1003*
e                               071510 automatic       fixed bin(17,0)          dcl 242 set ref 255* 262* 269* 280 293
ec                                     parameter       fixed bin(35,0)          dcl 948 set ref 940 969* 970 978* 979
editsw                                 based           bit(1)                   level 2 packed unaligned dcl 84 ref 645
el                      152            based           structure                array level 2 dcl 72
ename                                  parameter       char(32)                 array dcl 27 set ref 252 324* 332 351* 351 361* 361
                                                                                  377 384 389* 396 399 404* 410 481 482 487
entry                           051467 automatic       char(32)                 unaligned dcl 211 set ref 256* 263* 270* 278* 368*
                                                                                  410* 512* 525* 530* 629* 695* 705* 721* 727* 771*
                                                                                  788* 797* 807* 817* 826* 840*
entry_name                      072526 automatic       char(32)                 dcl 1157 set ref 1167* 1171* 1177* 1181*
errname                         051477 automatic       char(32)                 unaligned dcl 211 set ref 318* 332* 368* 377* 396*
                                                                                  410*
error_sw                  0(06)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 276
error_table_$bad_segment        000064 external static fixed bin(35,0)          dcl 172 ref 390 406
error_table_$moderr             000066 external static fixed bin(35,0)          dcl 172 ref 386 401
error_table_$namedup            000070 external static fixed bin(35,0)          dcl 172 ref 784
error_table_$noarg              000072 external static fixed bin(35,0)          dcl 172 ref 315
error_table_$non_matching_uid   000074 external static fixed bin(35,0)          dcl 172 ref 330
error_table_$oldobj             000076 external static fixed bin(35,0)          dcl 172 ref 407
error_table_$rqover             000100 external static fixed bin(35,0)          dcl 172 set ref 778 807*
error_table_$segknown           000102 external static fixed bin(35,0)          dcl 172 ref 385 400 726
errpath                         051507 automatic       char(168)                unaligned dcl 211 set ref 317* 331* 368* 376* 395*
                                                                                  410*
expand_pathname_                000112 constant        entry                    external dcl 1163 ref 1167 1177
fixed                                                  builtin function         dcl 246 ref 326 326 328 982 983 992
format                   24     071612 automatic       structure                level 2 dcl 947
full_bc                         000226 automatic       fixed bin(24,0)          dcl 90 set ref 781* 793* 795*
full_info_p                     000230 automatic       pointer                  dcl 90 set ref 777* 781* 785* 793* 795*
gate_sw                         051561 automatic       bit(1)                   initial unaligned dcl 211 set ref 211* 326* 374
get_bound_seg_info_             000110 constant        entry                    external dcl 964 ref 978
get_temp_segments_              000044 constant        entry                    external dcl 146 ref 719
get_wdir_                       000042 constant        entry                    external dcl 146 ref 282 602 833
hcs_$delentry_seg               000046 constant        entry                    external dcl 146 ref 777
hcs_$initiate_count             000050 constant        entry                    external dcl 146 ref 384 399 725
hcs_$terminate_noname           000052 constant        entry                    external dcl 146 ref 392 417
header                                 based           char                     unaligned dcl 90 set ref 748 749 757*
header_l                        000232 automatic       fixed bin(21,0)          dcl 90 set ref 740* 744* 745 745* 745 748 749 757
                                                                                  757
header_p                        000234 automatic       pointer                  dcl 90 set ref 739* 743* 748 749 757 813
i                               071732 automatic       fixed bin(17,0)          dcl 1014 in procedure "valid_lib_" set ref 1062*
                                                                                  1063 1063 1066* 1067* 1070* 1075* 1080* 1085*
                                                                                  1090* 1095* 1100* 1105* 1114* 1123* 1136 1139
i                               071511 automatic       fixed bin(17,0)          dcl 242 in procedure "upd_doc_task_" set ref 310*
                                                                                  311 311* 322* 323 324 324 328 328 331 332* 427*
                                                                                  428* 437* 439 440 442 448 455* 464* 465* 490* 491
                                                                                  491 492 492* 583* 584 586* 652* 653 654 656* 657
                                                                                  658* 662* 665 666 673* 676 676 677 683* 700*
i                                      parameter       fixed bin(17,0)          dcl 948 in procedure "doc_util_" set ref 940 967*
                                                                                  980* 980* 981 982 983 985 986* 988* 988
ignore                          051562 automatic       fixed bin(35,0)          dcl 211 set ref 785*
ii                              071512 automatic       fixed bin(17,0)          dcl 242 set ref 426* 428 431* 438* 439 440*
index                                                  builtin function         dcl 960 in procedure "doc_util_" ref 997
index                                                  builtin function         dcl 246 in procedure "upd_doc_task_" ref 656 658 661
                                                                                  744 1062
info                                   based           char                     unaligned dcl 90 set ref 734* 737 737 744 751 766
                                                                                  804*
info_bc                         000236 automatic       fixed bin(24,0)          dcl 90 set ref 725* 731 806* 814* 816*
info_l                          000237 automatic       fixed bin(21,0)          dcl 90 set ref 731* 734 734 737 737 744 749* 749 751
                                                                                  754* 754 766 804 804
info_name                       000152 automatic       char(168)                unaligned dcl 27 set ref 284* 289* 713 715 727* 771*
                                                                                  807* 817* 825 826*
info_p                          000240 automatic       pointer                  dcl 90 set ref 725* 734 737 737 739 743 744 748* 748
                                                                                  751 753* 753 766 804 806* 813* 814* 816* 823*
initiate_file_$create           000054 constant        entry                    external dcl 146 ref 781
insert_point                    000100 automatic       fixed bin(21,0)          dcl 926 in procedure "save$copy" set ref 928* 930
insert_point                    071602 automatic       fixed bin(21,0)          dcl 886 in procedure "out$copy" set ref 888* 890
install_date                           parameter       fixed bin(35,0)          dcl 27 set ref 259 266 538 538* 712*
ioa_$ioa_stream                 000030 constant        entry                    external dcl 146 ref 298 504 507 548 552 555 559 566
                                                                                  568 573 575 587 590 617 622 682 684 698 701
ios_$attach                     000032 constant        entry                    external dcl 146 ref 510 528 627 693
ios_$detach                     000034 constant        entry                    external dcl 146 ref 597 703 836
ios_$write                      000036 constant        entry                    external dcl 146 ref 683 700
j                               071516 automatic       fixed bin(17,0)          initial dcl 243 in procedure "upd_doc_task_" set ref
                                                                                  243* 404* 426 438 585* 586 587 590*
j                               071700 automatic       fixed bin(17,0)          dcl 960 in procedure "doc_util_" set ref 983* 984
k                               071517 automatic       fixed bin(17,0)          initial dcl 243 in procedure "upd_doc_task_" set ref
                                                                                  243* 389* 427 437 584* 587 587 592* 661* 662 662
k                               071701 automatic       fixed bin(17,0)          dcl 960 in procedure "doc_util_" set ref 982* 986
                                                                                  986 992* 993 993 993 997* 998
lb                              071722 automatic       char(32)                 dcl 1014 set ref 1061* 1061 1062 1063* 1063 1067
length                                                 builtin function         dcl 246 ref 737 737 740 745 748 749 766 864 889 908
                                                                                  929 1061
lib                                    parameter       char(168)                dcl 1014 set ref 1009 1133* 1136* 1139*
limb                                   based           structure                level 1 dcl 72 set ref 479
line_size                       071514 automatic       fixed bin(17,0)          dcl 242 set ref 651* 652 654 658 658 661 662 669
                                                                                  670* 670
log_dir                         051563 automatic       char(168)                unaligned dcl 211 set ref 282* 287* 725* 771* 771*
                                                                                  781* 788* 788* 797* 797*
log_directory                          parameter       char(168)                dcl 27 set ref 259 266 281 287 288 289 602 602* 833
                                                                                  833*
log_name                        000100 automatic       char(168)                unaligned dcl 27 set ref 283* 288* 504* 523 525*
                                                                                  528* 530* 600 617* 629* 690 693* 695* 704 705*
                                                                                  715* 840*
log_sw                    0(05)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 274
logsw                           051635 automatic       bit(1)                   unaligned dcl 211 set ref 274* 276* 296 500 503 611
                                                                                  616 681 836
mapp                            071706 automatic       pointer                  dcl 960 set ref 984* 985
mask                            000242 automatic       bit(36)                  initial array dcl 117 set ref 117* 117* 117* 117*
                                                                                  349 353 359 363 435
max_line_size                          parameter       fixed bin(17,0)          dcl 27 ref 266 651 658 669 673
min                                                    builtin function         dcl 246 ref 652 737
moved                           000251 automatic       fixed bin(17,0)          initial dcl 123 set ref 123* 356 364 446 449 551
n_components              1            based           fixed bin(17,0)          level 2 dcl 2-4 ref 980 990 991 992
n_odd_libs                      072405 automatic       fixed bin(17,0)          dcl 1044 set ref 1059*
n_root_libs                     071733 automatic       fixed bin(17,0)          dcl 1020 set ref 1058* 1066
name                                   based           char                     unaligned dcl 960 in procedure "doc_util_" ref 986
                                                                                  993
name                      2            based           structure                array level 3 in structure "bindmap" dcl 2-4
                                                                                  in procedure "doc_util_"
name_lng                  2(18)        based           bit(18)                  array level 4 packed unaligned dcl 2-4 ref 982
name_ptr                  2            based           bit(18)                  array level 4 packed unaligned dcl 2-4 ref 981
names                           051636 automatic       char(32)                 array unaligned dcl 211 set ref 431* 442* 448* 455*
                                                                                  469* 471* 487 491
nc                      151            based           fixed bin(17,0)          level 2 dcl 72 set ref 479* 489* 580 585
new_lib                         071346 automatic       char(168)                dcl 211 set ref 345* 347* 354 483
nn                              071513 automatic       fixed bin(17,0)          dcl 242 set ref 309* 430* 430 431 432 441* 441 442
                                                                                  443 447* 447 448 449 454* 454 455 456 464 468* 468
                                                                                  469 471 473 479 479 487 487* 489 490 490
no_char                   1            based           fixed bin(17,0)          level 2 dcl 84 set ref 652 653 676 678 683 683 683*
                                                                                  700 700 700* 761 761
no_more                         071420 automatic       bit(1)                   initial unaligned dcl 211 set ref 211* 642* 699 707
null                                                   builtin function         dcl 246 ref 244 244 244 244 244 244 245 245 307 324
                                                                                  324 506 520 621 640 1171 1171 1181 1181
obj_creation_time         6            based           fixed bin(71,0)          level 2 dcl 1-6 ref 985
object_info                            based           structure                level 1 dcl 3-6
object_info_$display            000106 constant        entry                    external dcl 964 ref 969
oi                              071612 automatic       structure                level 1 dcl 947 set ref 969 969 978 978
old_lib                         071421 automatic       char(168)                dcl 211 set ref 342* 344* 347 354 484
out_len                         071540 automatic       fixed bin(21,0)          dcl 853 set ref 863 863 864 874* 880 888 889* 889
                                                                                  890
out_ptr                         071542 automatic       pointer                  dcl 853 set ref 863 864 873* 890
out_seg                                based           char                     unaligned dcl 853 set ref 863* 863 864 890*
p                                      parameter       pointer                  dcl 948 in procedure "doc_util_" set ref 940 969*
                                                                                  978*
p                               071534 automatic       pointer                  initial array dcl 245 in procedure "upd_doc_task_"
                                                                                  set ref 245* 245* 719* 733* 736* 824*
p1                              071524 automatic       pointer                  initial dcl 244 set ref 244* 379* 389*
p2                              071526 automatic       pointer                  initial dcl 244 set ref 244* 380* 404*
parentp                                parameter       pointer                  dcl 27 ref 252 259 266
path1                                  parameter       char(168)                dcl 1152 set ref 1146 1167*
path2                                  parameter       char(168)                dcl 1152 set ref 1146 1177*
path_given                             based           bit(1)                   array level 2 packed unaligned dcl 110 set ref 311*
                                                                                  323
pathname_                       000056 constant        entry                    external dcl 146 ref 771 771 788 788 797 797
point                           071515 automatic       fixed bin(17,0)          dcl 242 set ref 650* 652 653 676 677* 677 678
prose                                  based           structure                level 1 unaligned dcl 84
prose_string              2            based           char                     level 2 packed unaligned dcl 84 set ref 653 676* 683
                                                                                  683 700 700 761*
prosep                                 parameter       pointer                  dcl 27 ref 266 621 640 645 652 653 676 678 683 683
                                                                                  683 700 700 700 761
ptrp                                   parameter       pointer                  dcl 948 ref 940 971 972 985 986 1002 1003
q                               071710 automatic       pointer                  dcl 960 in procedure "doc_util_" set ref 981* 986
                                                                                  991* 993
q                               071522 automatic       pointer                  initial dcl 244 in procedure "upd_doc_task_" set ref
                                                                                  244* 479* 481 482 483 484 485 486 489 491 492 494
rbs                      10(18) 047376 automatic       bit(6)                   array level 2 packed unaligned dcl 190 set ref 326
                                                                                  326
record_quota_overflow           071474 stack reference condition                dcl 211 ref 776 794 805 815
release_temp_segments_          000060 constant        entry                    external dcl 146 ref 824
replaced                        000247 automatic       fixed bin(17,0)          initial dcl 123 set ref 123* 354 443 465
rev                             071502 automatic       fixed bin(17,0)          dcl 211 set ref 537* 546* 552
reverse                                                builtin function         dcl 246 ref 661
reverse_sw                             based           bit(1)                   level 2 packed unaligned dcl 58 ref 304 518 534 614
                                                                                  637
root_libs                       071734 automatic       char(32)                 initial array dcl 1022 set ref 1022* 1022* 1022*
                                                                                  1022* 1022* 1022* 1022* 1022* 1022* 1022* 1022*
                                                                                  1022* 1022* 1022* 1022* 1022* 1022* 1022* 1022*
                                                                                  1022* 1022* 1022* 1022* 1022* 1022* 1022* 1022*
                                                                                  1067
rtrim                                                  builtin function         dcl 246 ref 288 289
run_sw                    0(03)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 275
runsw                           071503 automatic       bit(1)                   unaligned dcl 211 set ref 275* 306 500 542 599 611
                                                                                  637 640 831
s1                              000336 automatic       structure                array level 1 dcl 183 set ref 379
s2                              023756 automatic       structure                array level 1 dcl 186 set ref 380
save_len                        071544 automatic       fixed bin(21,0)          dcl 897 set ref 907 907 908 918* 928 929* 929 930
save_ptr                        071546 automatic       pointer                  dcl 897 set ref 907 908 917* 930
save_seg                               based           char                     unaligned dcl 897 set ref 907* 907 908 930*
sb                                     based           structure                level 1 dcl 1-6
sblkp                           071704 automatic       pointer                  dcl 960 set ref 978* 981 991
scode                           071504 automatic       bit(72)                  dcl 211 set ref 510* 511 512 528* 529 530 597* 627*
                                                                                  628 629 683* 693* 694 695 700* 703* 836*
segname                         023756 automatic       char(32)                 array level 2 in structure "s2" dcl 186 in procedure
                                                                                  "upd_doc_task_" set ref 381* 428 431 439
segname                         000336 automatic       char(32)                 array level 2 in structure "s1" dcl 183 in procedure
                                                                                  "upd_doc_task_" set ref 381* 428 439 442 448 455
segname                                based           char(32)                 array level 2 in structure "struc" dcl 957
                                                                                  in procedure "doc_util_" set ref 971* 986* 1002*
seqno                                  parameter       fixed bin(17,0)          dcl 27 ref 252 259 266
setcharno                                              builtin function         dcl 246 ref 748
sev                             071506 automatic       fixed bin(17,0)          dcl 211 set ref 316* 329* 368* 378* 409* 410*
status                                 based           structure                level 1 unaligned dcl 114
str                                    parameter       char                     unaligned dcl 885 in procedure "out$copy" ref 883
                                                                                  889 890
str                                    parameter       char                     unaligned dcl 925 in procedure "save$copy" ref 922
                                                                                  929 930
struc                                  based           structure                array level 1 dcl 957
substr                                                 builtin function         dcl 246 in procedure "upd_doc_task_" set ref 281 311
                                                                                  410 602 653 658 661 666* 676* 676 737 758 758 833
                                                                                  890* 930* 1061 1063
substr                                                 builtin function         dcl 960 in procedure "doc_util_" ref 986 993 998
symb_start                7            based           bit(18)                  array level 3 packed unaligned dcl 2-4 ref 983
symbp                    12     071612 automatic       pointer                  level 2 dcl 947 set ref 984
sys_info$max_seg_size           000104 external static fixed bin(35,0)          dcl 172 ref 766
target_bc                              parameter       fixed bin(24,0)          dcl 860 in procedure "out$copy" set ref 858 864*
target_bc                              parameter       fixed bin(24,0)          dcl 904 in procedure "save$copy" set ref 901 908*
target_ptr                             parameter       pointer                  dcl 904 in procedure "save$copy" ref 901 907
target_ptr                             parameter       pointer                  dcl 860 in procedure "out$copy" ref 858 863
task_run_sw               0(04)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 275
task_sw                   0(01)        based           bit(1)                   level 2 packed unaligned dcl 58 ref 278
taskp                                  parameter       pointer                  dcl 27 ref 252 259 266
terminate_file_                 000062 constant        entry                    external dcl 146 ref 785 795 816 823
treep                                  parameter       pointer                  dcl 27 set ref 252 259 307 494* 506 520 542 551 552
                                                                                  552 552 555 559 559 559 566 566 566 568 568 568
                                                                                  573 573 573 575 580 585 586 587 590
uid                      11     047376 automatic       bit(36)                  level 2 packed unaligned dcl 190 set ref 328 1175
                                                                                  1185
unb_sw                          071507 automatic       bit(1)                   initial unaligned dcl 211 in procedure
                                                                                  "upd_doc_task_" set ref 211* 389* 404* 408 423
unb_sw                                 parameter       bit(1)                   unaligned dcl 948 in procedure "doc_util_" set ref
                                                                                  940 973* 977*
upd_add_task_                   000014 constant        entry                    external dcl 146 ref 278
upd_log_task_$lock              000016 constant        entry                    external dcl 146 ref 523 690 713
upd_log_task_$unlock            000020 constant        entry                    external dcl 146 ref 600 704 825
upd_print_err_                  000022 constant        entry                    external dcl 146 ref 300 619 771
upd_status_$long                000024 constant        entry                    external dcl 146 ref 324 1171 1181
upd_task_err_                   000026 constant        entry                    external dcl 146 ref 368 410 512 525 530 629 695 705
                                                                                  721 727 788 797 807 817 826 840
verify                                                 builtin function         dcl 246 ref 751
version_number                  071612 automatic       fixed bin(17,0)          level 2 dcl 947 set ref 968*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 4-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 4-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 4-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 4-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 4-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 4-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 4-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 4-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 4-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 5-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 5-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 5-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 5-11
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 4-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 4-36
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 3-60
terminate_file_switches                based           structure                level 1 packed unaligned dcl 5-4

NAMES DECLARED BY EXPLICIT CONTEXT.
MATCH_PATHS                     012473 constant        entry                    internal dcl 1146 ref 1071 1076 1081 1086 1091 1096
                                                                                  1101 1106 1110 1115 1119 1124 1128
changed                         003323 constant        label                    dcl 468 ref 435 459 465
common                          001524 constant        label                    dcl 272 ref 257 264
doc_util_                       010470 constant        entry                    internal dcl 940 ref 389 404
err                             002353 constant        label                    dcl 368 ref 319 333 387 390 402 415
get_tree                        001403 constant        entry                    external dcl 252
got_lib                         012450 constant        label                    dcl 1136 ref 1067
got_odd_lib                     012462 constant        label                    dcl 1139 ref 1072 1077 1082 1087 1092 1097 1102 1107
                                                                                  1111 1116 1120 1125 1129
init_entry                      002421 constant        label                    dcl 374 ref 366
lock_err                        010153 constant        label                    dcl 840 set ref 691 716
look                            005374 constant        label                    dcl 652 ref 671 678
next1                           003133 constant        label                    dcl 433 ref 428
next2                           003263 constant        label                    dcl 457 ref 444 451
no_lib                          012441 constant        label                    dcl 1133
no_rec                          002760 constant        label                    dcl 409 set ref 386 401
out$copy                        010216 constant        entry                    internal dcl 858 ref 793 814
out$init                        010245 constant        entry                    internal dcl 868 ref 736
out$len                         010270 constant        entry                    internal dcl 878 ref 766
out$str                         010310 constant        entry                    internal dcl 883 ref 757 758 759 760 761 762 763 764
                                                                                  804
print_comps                     004617 constant        label                    dcl 580 ref 562
print_it                        004124 constant        label                    dcl 534 ref 515
process                         005506 constant        label                    dcl 676 ref 654 667
record_seg                      003354 constant        label                    dcl 479 ref 374 406 408 413 423 462 467
return                          010066 constant        label                    dcl 831 ref 685 707 841
rqo_full                        007254 constant        label                    dcl 788 ref 779
save$copy                       010363 constant        entry                    internal dcl 901 ref 806
save$init                       010407 constant        entry                    internal dcl 911 ref 733
save$str                        010425 constant        entry                    internal dcl 922 ref 734
skip_comps                      004765 constant        label                    dcl 597 ref 513 531 557 577 580
skipedit                        005516 constant        label                    dcl 681 ref 643 645
start                           000000 constant        label                    array(3) dcl 296 ref 293
term_info                       007621 constant        label                    dcl 815 ref 811
un_info                         007716 constant        label                    dcl 823 ref 722 729 791 800
un_log                          006107 constant        label                    dcl 703 ref 696
upd_doc_task_                   001364 constant        entry                    external dcl 12
valid_lib_                      010762 constant        entry                    internal dcl 1009 ref 342 345
write_prose                     001477 constant        entry                    external dcl 266
write_tree                      001436 constant        entry                    external dcl 259

NAME DECLARED BY CONTEXT OR IMPLICATION.
addcharno                                              builtin function         ref 753

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13424       13540   12724       13434
Length     14160   12724       114         403     477           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
upd_doc_task_                     30336 external procedure  is an external procedure.  
on unit on line 776                  70 on unit               
on unit on line 805                 116 on unit               
out$copy                                internal procedure  shares stack frame of external procedure upd_doc_task_.  
save$copy                            67 internal procedure  is called by several nonquick procedures.  
doc_util_                               internal procedure  shares stack frame of external procedure upd_doc_task_.  
valid_lib_                              internal procedure  shares stack frame of external procedure upd_doc_task_.  
MATCH_PATHS                             internal procedure  shares stack frame of external procedure upd_doc_task_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
save$copy                000100 insert_point                save$copy
upd_doc_task_            000100 log_name                    upd_doc_task_
                         000152 info_name                   upd_doc_task_
                         000224 Inon_nl                     upd_doc_task_
                         000225 created_sw                  upd_doc_task_
                         000226 full_bc                     upd_doc_task_
                         000230 full_info_p                 upd_doc_task_
                         000232 header_l                    upd_doc_task_
                         000234 header_p                    upd_doc_task_
                         000236 info_bc                     upd_doc_task_
                         000237 info_l                      upd_doc_task_
                         000240 info_p                      upd_doc_task_
                         000242 mask                        upd_doc_task_
                         000246 added                       upd_doc_task_
                         000247 replaced                    upd_doc_task_
                         000250 deleted                     upd_doc_task_
                         000251 moved                       upd_doc_task_
                         000252 del_com                     upd_doc_task_
                         000253 com                         upd_doc_task_
                         000315 comp_array                  upd_doc_task_
                         000336 s1                          upd_doc_task_
                         023756 s2                          upd_doc_task_
                         047376 Stat                        upd_doc_task_
                         047410 actions                     upd_doc_task_
                         051361 axn                         upd_doc_task_
                         051362 b1_date                     upd_doc_task_
                         051370 b2_date                     upd_doc_task_
                         051376 b1_name                     upd_doc_task_
                         051406 b2_name                     upd_doc_task_
                         051416 bitc                        upd_doc_task_
                         051417 buffer                      upd_doc_task_
                         051460 code                        upd_doc_task_
                         051461 control                     upd_doc_task_
                         051462 Date                        upd_doc_task_
                         051466 de_installation_sw          upd_doc_task_
                         051467 entry                       upd_doc_task_
                         051477 errname                     upd_doc_task_
                         051507 errpath                     upd_doc_task_
                         051561 gate_sw                     upd_doc_task_
                         051562 ignore                      upd_doc_task_
                         051563 log_dir                     upd_doc_task_
                         051635 logsw                       upd_doc_task_
                         051636 names                       upd_doc_task_
                         071346 new_lib                     upd_doc_task_
                         071420 no_more                     upd_doc_task_
                         071421 old_lib                     upd_doc_task_
                         071502 rev                         upd_doc_task_
                         071503 runsw                       upd_doc_task_
                         071504 scode                       upd_doc_task_
                         071506 sev                         upd_doc_task_
                         071507 unb_sw                      upd_doc_task_
                         071510 e                           upd_doc_task_
                         071511 i                           upd_doc_task_
                         071512 ii                          upd_doc_task_
                         071513 nn                          upd_doc_task_
                         071514 line_size                   upd_doc_task_
                         071515 point                       upd_doc_task_
                         071516 j                           upd_doc_task_
                         071517 k                           upd_doc_task_
                         071520 argp                        upd_doc_task_
                         071522 q                           upd_doc_task_
                         071524 p1                          upd_doc_task_
                         071526 p2                          upd_doc_task_
                         071530 Pseg                        upd_doc_task_
                         071532 blkp                        upd_doc_task_
                         071534 p                           upd_doc_task_
                         071540 out_len                     upd_doc_task_
                         071542 out_ptr                     upd_doc_task_
                         071544 save_len                    upd_doc_task_
                         071546 save_ptr                    upd_doc_task_
                         071602 insert_point                out$copy
                         071612 oi                          doc_util_
                         071700 j                           doc_util_
                         071701 k                           doc_util_
                         071702 bmp                         doc_util_
                         071704 sblkp                       doc_util_
                         071706 mapp                        doc_util_
                         071710 q                           doc_util_
                         071722 lb                          valid_lib_
                         071732 i                           valid_lib_
                         071733 n_root_libs                 valid_lib_
                         071734 root_libs                   valid_lib_
                         072264 LIBS                        valid_lib_
                         072405 n_odd_libs                  valid_lib_
                         072406 ODD_LIBS                    valid_lib_
                         072452 UID1                        MATCH_PATHS
                         072453 UID2                        MATCH_PATHS
                         072454 dir_name                    MATCH_PATHS
                         072526 entry_name                  MATCH_PATHS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           signal_op           enable_op           shorten_stack
ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              date_time_$fstime             expand_pathname_              get_bound_seg_info_
get_temp_segments_            get_wdir_                     hcs_$delentry_seg             hcs_$initiate_count
hcs_$terminate_noname         initiate_file_$create         ioa_$ioa_stream               ios_$attach
ios_$detach                   ios_$write                    object_info_$display          pathname_
release_temp_segments_        smart_alloc_                  terminate_file_               upd_add_task_
upd_log_task_$lock            upd_log_task_$unlock          upd_print_err_                upd_status_$long
upd_task_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$moderr           error_table_$namedup          error_table_$noarg
error_table_$non_matching_uid error_table_$oldobj           error_table_$rqover           error_table_$segknown
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    117 001114       123 001135       130 001147       140 001230       211 001301       243 001326       244 001331
    245 001340        12 001363       252 001372       255 001415       256 001420       257 001424       259 001425
    262 001456       263 001461       264 001465       266 001466       269 001515       270 001520       272 001524
    274 001534       275 001542       276 001553       278 001563       280 001604       281 001610       282 001614
    283 001632       284 001635       285 001640       287 001641       288 001646       289 001705       290 001731
    293 001732       296 001734       298 001736       300 001762       302 002003       304 002004       306 002010
    307 002012       309 002016       310 002017       311 002026       313 002042       314 002044       315 002046
    316 002051       317 002053       318 002057       319 002063       322 002064       323 002072       324 002077
    325 002153       326 002156       328 002170       329 002201       330 002203       331 002206       332 002216
    333 002226       337 002227       342 002231       344 002250       345 002254       347 002274       349 002301
    350 002305       351 002307       352 002314       353 002315       354 002317       356 002330       358 002332
    359 002333       360 002335       361 002337       362 002344       363 002345       364 002347       366 002352
    368 002353       370 002420       374 002421       376 002423       377 002431       378 002436       379 002440
    380 002442       381 002444       383 002452       384 002455       385 002530       386 002536       387 002540
    389 002541       390 002571       392 002577       395 002611       396 002620       398 002625       399 002630
    400 002703       401 002711       402 002713       404 002714       405 002745       406 002750       407 002753
    408 002755       409 002760       410 002761       413 003033       415 003034       417 003035       423 003047
    426 003053       427 003066       428 003076       429 003110       430 003112       431 003113       432 003127
    433 003133       435 003135       437 003140       438 003152       439 003162       440 003177       441 003203
    442 003204       443 003213       444 003217       446 003220       447 003223       448 003224       449 003233
    451 003237       453 003240       454 003242       455 003243       456 003257       457 003263       459 003265
    462 003303       464 003304       465 003314       466 003320       467 003322       468 003323       469 003324
    471 003340       473 003350       479 003354       481 003405       482 003412       483 003415       484 003421
    485 003425       486 003430       487 003432       489 003444       490 003446       491 003456       492 003471
    493 003476       494 003500       495 003502       500 003503       503 003507       504 003511       506 003545
    507 003552       508 003576       510 003577       511 003644       512 003647       513 003705       515 003706
    518 003707       520 003716       523 003722       524 003743       525 003746       526 004010       528 004011
    529 004054       530 004061       531 004123       534 004124       536 004131       537 004133       538 004134
    540 004155       542 004161       544 004172       546 004173       547 004175       548 004213       551 004240
    552 004246       554 004316       555 004321       557 004353       559 004354       562 004412       565 004413
    566 004415       568 004460       571 004517       573 004520       575 004563       577 004616       580 004617
    583 004624       584 004632       585 004633       586 004646       587 004655       590 004724       592 004757
    594 004761       595 004763       597 004765       599 005016       600 005021       601 005042       602 005055
    606 005071       611 005072       614 005076       616 005102       617 005104       619 005134       621 005155
    622 005162       624 005207       626 005210       627 005221       628 005266       629 005273       630 005335
    632 005336       633 005337       637 005340       640 005352       642 005361       643 005363       645 005364
    650 005370       651 005372       652 005374       653 005407       654 005414       656 005416       657 005427
    658 005430       661 005446       662 005460       665 005466       666 005470       667 005474       669 005475
    670 005501       671 005503       673 005504       676 005506       677 005512       678 005513       681 005516
    682 005520       683 005541       684 005607       685 005631       690 005632       691 005653       693 005656
    694 005721       695 005726       696 005770       698 005771       699 006015       700 006020       701 006065
    703 006107       704 006140       705 006162       707 006227       712 006232       713 006250       714 006272
    715 006275       716 006300       719 006301       720 006331       721 006334       722 006372       725 006373
    726 006437       727 006445       729 006506       731 006507       733 006512       734 006521       736 006536
    737 006546       739 006557       740 006560       741 006562       743 006563       744 006564       745 006576
    748 006601       749 006603       751 006605       752 006620       753 006622       754 006625       757 006630
    758 006645       759 006663       760 006677       761 006710       762 006730       763 006741       764 006752
    766 006763       771 007006       776 007111       777 007125       778 007137       779 007144       781 007147
    783 007212       784 007220       785 007223       787 007251       788 007254       791 007342       793 007343
    794 007354       795 007356       796 007404       797 007407       800 007474       802 007475       804 007476
    805 007512       806 007526       807 007540       811 007603       813 007606       814 007610       815 007621
    816 007623       817 007651       823 007716       824 007746       825 007777       826 010021       831 010066
    832 010071       833 010103       836 010117       838 010152       840 010153       841 010215       858 010216
    863 010223       864 010232       865 010235       868 010245       873 010252       874 010257       875 010260
    878 010270       880 010274       883 010310       888 010324       889 010330       890 010332       891 010352
    901 010362       907 010370       908 010402       909 010405       911 010406       917 010414       918 010422
    919 010423       922 010424       928 010440       929 010445       930 010447       931 010467       940 010470
    967 010473       968 010475       969 010477       970 010520       971 010524       972 010532       973 010534
    974 010540       976 010541       977 010544       978 010550       979 010574       980 010601       981 010615
    982 010625       983 010630       984 010633       985 010636       986 010645       987 010652       988 010654
    989 010656       990 010661       991 010672       992 010677       993 010705       994 010713       996 010714
    997 010720       998 010732       999 010747      1000 010750      1002 010751      1003 010757      1004 010761
   1009 010762      1022 010765      1033 011321      1046 011657      1058 011767      1059 011772      1061 011774
   1062 012001      1063 012012      1066 012020      1067 012030      1069 012040      1070 012042      1071 012044
   1072 012063      1075 012066      1076 012070      1077 012107      1080 012112      1081 012114      1082 012133
   1085 012136      1086 012140      1087 012157      1090 012162      1091 012164      1092 012203      1095 012206
   1096 012210      1097 012227      1100 012232      1101 012234      1102 012253      1105 012256      1106 012260
   1107 012277      1110 012302      1111 012321      1114 012324      1115 012326      1116 012345      1119 012350
   1120 012367      1123 012372      1124 012374      1125 012413      1128 012416      1129 012435      1132 012440
   1133 012441      1134 012447      1136 012450      1137 012461      1139 012462      1141 012472      1146 012473
   1167 012476      1168 012524      1171 012531      1172 012574      1175 012601      1177 012603      1178 012630
   1181 012635      1182 012700      1185 012705      1187 012707      1189 012713      1191 012715


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
