	COMPILATION LISTING OF SEGMENT iodc_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/15/89  0831.6 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style2 */
       14 iodc_:
       15      procedure;
       16 
       17 /* This is the central procedure of the I/O Daemon Coordinator.
       18*   *  It has various entries which are woken up by event calls.
       19**/
       20 
       21 /* Coded by Robert S. Coren  in August 1973 */
       22 /* Modified for the Access Isolation Mechanism by J. Stern, December 1974 */
       23 /* Modified by J. Stern, 11/25/75 */
       24 /* Modified by J. C. Whitmore, 4/78, to support max queues per request type and save more descriptor flags */
       25 /* Modified by J. C. Whitmore, 7/78, for extended driver commands and queue priority functions */
       26 /* Modified by J. C. Whitmore, 11/78, for version 3 iod_tables format and start using coord version numbers */
       27 /* Modified by J. C. Whitmore, 5/80, to mark priority requests in the queue */
       28 /* Modified by Benson I. Margulies 1980*12*29 for unaligned system_dir
       29*   argument and variable iod_table segname. */
       30 /* Modified January 1984 by C. Marker  Added probe as a valid command in test mode. */
       31 /* Modified December 1984 by Keith Loepere to set dir_quota. */
       32 /* Modified January 1985 by Keith Loepere to be smarter about same. */
       33 /* Modified February 23, 1985 by C. Marker to use version 5 message segments */
       34 
       35 
       36 /****^  HISTORY COMMENTS:
       37*  1) change(87-02-04,Gilcrease), approve(87-02-04,MCR7610),
       38*     audit(87-02-18,Farley), install(87-03-25,MR12.1-1013):
       39*               Correct call to internal subroutine for the NEXT command.
       40*  2) change(88-06-03,Brunelle), approve(88-06-03,MCR7911),
       41*     audit(88-10-17,Wallman), install(88-10-28,MR12.2-1199):
       42*     Upgraded to handle version 5 I/O daemon tables.
       43*                                                   END HISTORY COMMENTS */
       44 
       45 	dcl     a_ptr		 ptr;		/* pointer passed as argument to most entries */
       46 
       47 
       48 /* External entries */
       49 
       50 	dcl     aim_check_$equal	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       51 	dcl     aim_check_$greater_or_equal
       52 				 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       53 	dcl     com_err_		 entry options (variable);
       54 	dcl     convert_ipc_code_	 entry (fixed bin (35));
       55 	dcl     debug		 entry;
       56 	dcl     delete_$path	 entry (char (*) aligned, char (*) aligned, bit (6), char (*), fixed bin (35));
       57 	dcl     expand_pathname_	 entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
       58 	dcl     find_next_request_	 entry (fixed bin, ptr) returns (bit (1) aligned);
       59 	dcl     find_next_request_$init
       60 				 entry (ptr);
       61 	dcl     free_oldest_request_$cleanup
       62 				 entry;
       63 	dcl     free_oldest_request_$force
       64 				 entry;
       65 	dcl     free_oldest_request_$init
       66 				 entry (ptr);
       67 	dcl     get_authorization_	 entry returns (bit (72) aligned);
       68 	dcl     get_group_id_$tag_star entry returns (char (32));
       69 	dcl     get_process_id_	 entry returns (bit (36) aligned);
       70 	dcl     get_ring_		 entry returns (fixed bin (6));
       71 	dcl     get_system_free_area_	 entry (ptr);
       72 	dcl     hcs_$chname_seg	 entry (ptr, char (*) aligned, char (*), fixed bin (35));
       73 	dcl     hcs_$create_branch_	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
       74 	dcl     hcs_$delentry_seg	 entry (ptr, fixed bin (35));
       75 	dcl     hcs_$get_access_class	 entry (char (*) aligned, char (*), bit (72) aligned, fixed bin (35));
       76 	dcl     hcs_$initiate_count	 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (24),
       77 				 fixed bin (2), ptr, fixed bin (35));
       78 	dcl     hcs_$make_seg	 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (5), ptr,
       79 				 fixed bin (35));
       80 	dcl     hcs_$set_ring_brackets entry (char (*) aligned, char (*) aligned, (3) fixed bin (3), fixed bin (35));
       81 	dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
       82 	dcl     hcs_$wakeup		 entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
       83 	dcl     ioa_		 entry options (variable);
       84 	dcl     ioa_$ioa_stream	 entry options (variable);
       85 	dcl     ioa_$rsnnl		 entry options (variable);
       86 	dcl     iod_overseer_$coord_ready
       87 				 entry;
       88 	dcl     iodc_$command_level	 entry;
       89 	dcl     iodc_$free_device	 entry (ptr, fixed bin (35));
       90 	dcl     iodc_message_	 entry (bit (3) aligned, fixed bin (35), char (*));
       91 	dcl     iodc_message_$loud	 entry (bit (3) aligned, fixed bin (35), char (*));
       92 	dcl     iodc_message_$init	 entry;
       93 	dcl     iodd_$iodd_init	 entry (char (*) aligned, bit (1) aligned);
       94 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
       95 	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
       96 	dcl     ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
       97 	dcl     ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));
       98 	dcl     ipc_$decl_ev_call_chn	 entry (fixed bin (71), ptr, ptr, fixed bin, fixed bin (35));
       99 	dcl     ipc_$drain_chn	 entry (fixed bin (71), fixed bin (35));
      100 	dcl     ipc_$mask_ev_calls	 entry (fixed bin (35));
      101 	dcl     ipc_$unmask_ev_calls	 entry (fixed bin (35));
      102 	dcl     logout		 entry;
      103 	dcl     match_request_id_	 entry (fixed bin (71), char (*) aligned) returns (bit (1) aligned);
      104 	dcl     message_segment_$create
      105 				 entry (char (*) aligned, char (*) aligned, fixed bin (35));
      106 	dcl     message_segment_$delete
      107 				 entry (char (*) aligned, char (*) aligned, fixed bin (35));
      108 	dcl     message_segment_$delete_index
      109 				 entry (fixed bin, bit (72) aligned, fixed bin (35));
      110 	dcl     message_segment_$ms_acl_add
      111 				 entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin (35));
      112 	dcl     message_segment_$read_message_index
      113 				 entry (fixed bin, pointer, pointer, fixed bin (35));
      114 	dcl     message_segment_$open	 entry (char (*) aligned, char (*) aligned, fixed bin, fixed bin (35));
      115 	dcl     message_segment_$check_salv_bit_index
      116 				 entry (fixed bin, bit (1) aligned, bit (1) aligned, fixed bin (35));
      117 	dcl     message_segment_$update_message_index
      118 				 entry (fixed bin, fixed bin (24), bit (72) aligned, ptr, fixed bin (35));
      119 	dcl     new_proc		 entry;
      120 	dcl     print_devices	 entry options (variable);
      121 	dcl     privileged_make_seg_	 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (5), ptr,
      122 				 fixed bin (35));
      123 	dcl     probe		 entry ();
      124 	dcl     save_request_	 entry (ptr, ptr);
      125 	dcl     save_request_$init	 entry (ptr);
      126 	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
      127 	dcl     signal_		 entry (char (*));
      128 	dcl     system_info_$access_ceiling
      129 				 entry (bit (72) aligned);
      130 	dcl     system_privilege_$initiate_count
      131 				 entry (char (*) aligned, char (*) aligned, char (*), fixed bin (24),
      132 				 fixed bin (2), ptr, fixed bin (35));
      133 	dcl     timer_manager_$reset_alarm_wakeup
      134 				 entry (fixed bin (71));
      135 	dcl     unique_bits_	 entry returns (bit (70));
      136 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
      137 	dcl     unthread_descriptor_	 entry (ptr);
      138 	dcl     unthread_descriptor_$init
      139 				 entry (ptr);
      140 
      141 /* Automatic storage */
      142 
      143 	dcl     ack_chan		 fixed bin (71);
      144 	dcl     area_flag		 fixed bin;
      145 	dcl     auth		 bit (72) aligned;	/* process access authorization */
      146 	dcl     bc		 fixed bin (24);	/* bit count */
      147 	dcl     chan_name		 fixed bin (71);
      148 	dcl     cmd		 char (24) aligned;
      149 	dcl     code		 fixed bin (35);
      150 	dcl     code2		 fixed bin (35);
      151 	dcl     copy_ptr		 ptr;		/* pointer to copy of descriptor */
      152 	dcl     copy_words		 fixed bin;	/* size of copy_template array */
      153 	dcl     cwtp		 ptr;		/* ptr to coord_working_tables */
      154 	dcl     dcx		 fixed bin;	/* index of a device_class entry */
      155 	dcl     desc_off		 fixed bin (18);	/* offset of a request descriptor */
      156 	dcl     desc_ptr		 ptr;		/* pointer to a request descriptor */
      157 	dcl     dev_id		 char (32) aligned;
      158 	dcl     dir_quota		 fixed bin;
      159 	dcl     dr_ptr		 ptr;
      160 	dcl     entry_type		 fixed bin;
      161 	dcl     ev_info_ptr		 ptr;
      162 	dcl     finish		 fixed bin;
      163 	dcl     fwx		 fixed bin;
      164 	dcl     i			 fixed bin;
      165 	dcl     idtx		 fixed bin;	/* iod device table index */
      166 	dcl     iodc_data_ptr	 ptr;
      167 	dcl     iwtp		 ptr;		/* ptr to iod_working_tables */
      168 	dcl     iwtrb		 (3) fixed bin (3); /* ring brackets for iod_working_tables */
      169 	dcl     len		 fixed bin;
      170 	dcl     line		 char (80);
      171 	dcl     lwx		 fixed bin;
      172 	dcl     mask_code		 fixed bin (35);	/* status code from ipc_$unmask_ev_calls */
      173 	dcl     match_dir		 char (168) aligned;
      174 	dcl     match_ent		 char (32) aligned;
      175 	dcl     mdtx		 fixed bin;	/* minor device table index */
      176 	dcl     message_len		 fixed bin;	/* length (in bits) of based_message */
      177 	dcl     ms_id		 bit (72) aligned;	/* message id */
      178 	dcl     nc		 fixed bin;
      179 	dcl     new_driver_id	 char (32) aligned; /* person/project id of new driver */
      180 	dcl     new_idx		 fixed bin;
      181 	dcl     new_iwtp		 ptr;		/* ptr to new copy of iod_working_tables */
      182 	dcl     next_ptr		 ptr;		/* pointer to next request descriptor */
      183 	dcl     nseries		 fixed bin;	/* number of series in series_info */
      184 	dcl     nx		 fixed bin;
      185 	dcl     out_len		 fixed bin;	/* length of error message */
      186 	dcl     out_msg		 char (200);
      187 	dcl     proc_id		 bit (36) aligned;
      188 	dcl     q			 fixed bin;
      189 	dcl     q_idx		 fixed bin;	/* index of queue message seg. */
      190 	dcl     q_name		 char (32) aligned;
      191 	dcl     quota		 fixed bin;
      192 	dcl     retry		 fixed bin;
      193 	dcl     reqp		 ptr;
      194 	dcl     seg_name		 char (32) aligned;
      195 	dcl     sender_class	 char (32) aligned; /* name of device class of sender of driver signal */
      196 	dcl     sender_device	 char (32) aligned; /* name of device run by sender of  a driver signal */
      197 	dcl     sender_id		 char (32) aligned;
      198 	dcl     seq_id		 fixed bin (35);
      199 	dcl     series_id		 fixed bin (35);
      200 	dcl     series_sw		 bit (1) aligned;
      201 	dcl     sig_type		 fixed bin;
      202 	dcl     sip		 ptr;		/* ptr to series_info structure */
      203 	dcl     start		 fixed bin;
      204 	dcl     subdir		 char (168) aligned;/* used to hold pathnames of subdirs of sysdir */
      205 	dcl     system_high		 bit (72) aligned;	/* system high authorization */
      206 	dcl     unbit		 bit (1) aligned;
      207 	dcl     user_id		 char (32) aligned;
      208 	dcl     wlp		 ptr;
      209 	dcl     x			 fixed bin;
      210 
      211 /* Internal static storage */
      212 
      213 	dcl     areap		 ptr int static;	/* ptr to sys_area */
      214 	dcl     driver_sig_chan	 fixed bin (71) int static;
      215 						/* name of channel over which signals from */
      216 						/* driver processes will come */
      217 	dcl     static_idtp		 int static ptr;	/* pointer to io daemon device table */
      218 	dcl     static_mdtp		 int static ptr;	/* pointer to minor device table */
      219 	dcl     driver_cmd_chan	 fixed bin (71) int static;
      220 						/* IPC channel for driver to signal commands which */
      221 						/* are read through the coord_comm.ms seg */
      222 	dcl     recursion_flag	 fixed bin int static;
      223 						/* used to prevent recursive faults */
      224 	dcl     scu_msg		 char (120) int static init ("");
      225 	dcl     sysdir		 char (168) aligned int static;
      226 	dcl     testing		 bit (1) int static;
      227 	dcl     quit_flag		 bit (1) int static;
      228 	dcl     err_label		 label int static;
      229 	dcl     return_label	 label int static;	/* for returning in test environment */
      230 
      231 	dcl     comm_mseg_idx	 fixed bin int static;
      232 						/* message segment index for coord_comm.ms */
      233 	dcl     sysdir_len		 fixed bin int static;
      234 						/* length of pathname in sysdir */
      235 	dcl     sysdir_class	 bit (72) aligned int static;
      236 						/* access class of sysdir */
      237 	dcl     initialized		 bit (1) aligned int static;
      238 						/* turned on when coord initialization is complete */
      239 	dcl     coord_proc_id	 bit (36) int static;
      240 						/* coordinator's process id */
      241 	dcl     new_driver_series	 int static;	/* first sequence number for new driver */
      242 	dcl     com_level		 fixed bin int static;
      243 						/* command level depth */
      244 	dcl     n_acl		 fixed bin int static;
      245 
      246 /* External static */
      247 
      248 	dcl     error_table_$action_not_performed
      249 				 fixed bin (35) ext static;
      250 	dcl     error_table_$bad_segment
      251 				 fixed bin (35) ext static;
      252 	dcl     error_table_$invalid_move_qmax
      253 				 fixed bin (35) ext static;
      254 	dcl     error_table_$noentry	 fixed bin (35) ext static;
      255 	dcl     error_table_$namedup	 fixed bin (35) ext static;
      256 	dcl     error_table_$pathlong	 fixed bin (35) ext static;
      257 	dcl     error_table_$argerr	 fixed bin (35) ext static;
      258 	dcl     error_table_$invalid_lock_reset
      259 				 fixed bin (35) ext static;
      260 	dcl     error_table_$segknown	 fixed bin (35) ext static;
      261 	dcl     error_table_$request_not_recognized
      262 				 fixed bin (35) ext static;
      263 	dcl     error_table_$ai_above_allowed_max
      264 				 fixed bin (35) ext static;
      265 	dcl     error_table_$ai_restricted
      266 				 fixed bin (35) ext static;
      267 
      268 	dcl     iox_$user_input	 ptr ext;
      269 	dcl     iox_$user_io	 ptr ext static;
      270 
      271 
      272 /* Constants */
      273 
      274 	dcl     io_coordinator_version char (8) int static options (constant) init ("3.2");
      275 	dcl     driver_command	 fixed bin int static options (constant) init (100);
      276 	dcl     id		 char (16) int static options (constant) init ("io_coordinator");
      277 	dcl     new_driver		 fixed bin int static options (constant) init (200);
      278 	dcl     priority		 fixed bin int static options (constant) init (2);
      279 	dcl     NL		 char (1) int static options (constant) init ("
      280 ");
      281 
      282 
      283 /* Conditions */
      284 
      285 	dcl     any_other		 condition;
      286 	dcl     quit		 condition;
      287 	dcl     cleanup		 condition;
      288 	dcl     area		 condition;
      289 
      290 /* these guys are just used to pass addresses to ipc_$decl_ev_call_chn */
      291 
      292 	dcl     free_oldest_request_$free_oldest_request_
      293 				 fixed bin ext static;
      294 	dcl     iodc_$new_driver	 fixed bin ext static;
      295 	dcl     iodc_$driver_signal	 fixed bin ext static;
      296 	dcl     iodc_$driver_command	 fixed bin ext static;
      297 
      298 /* Based storage */
      299 
      300 	dcl     based_message	 bit (message_len) aligned based;
      301 	dcl     copy_template	 (copy_words) fixed bin based;
      302 						/* for segment copying */
      303 	dcl     sys_area		 area (65560) based (areap);
      304 						/* system area */
      305 
      306 /* Builtins */
      307 
      308 	dcl     (addr, before, divide, empty, fixed, length, ltrim, max, mod, null, ptr, rel, rtrim, stac, string,
      309 	        substr, unspec)	 builtin;
      310 
      311 
      312 /* Structure declarations */
      313 
      314 	dcl     1 ev_info		 based (ev_info_ptr),
      315 		2 channel		 fixed bin (71),
      316 		2 message		 fixed bin (71),
      317 		2 sending_proc	 bit (36);
      318 
      319 	dcl     1 acl		 (3) aligned int static,
      320 		2 ac_name		 char (32),
      321 		2 modes		 bit (36),
      322 		2 pad		 bit (36) init ((3) (36)"0"b),
      323 		2 code		 fixed bin (35);
      324 
      325 	dcl     1 dir_acl		 (2) aligned int static,
      326 		2 ac_name		 char (32),
      327 		2 modes		 bit (36),
      328 		2 code		 fixed bin (35);
      329 
      330 	dcl     1 driver_mmi	 aligned like mseg_message_info;
      331 
      332 	dcl     1 msg_mmi		 aligned like mseg_message_info;
      333 
      334 	dcl     1 coord_static	 int static aligned like iodc_static;
      335 						/* space for iodc_static */
      336 
      337 	dcl     1 branch_info	 aligned int static like create_branch_info;
      338 
      339 	dcl     1 ms_acl		 aligned,		/* for setting extended acl on message segment */
      340 		2 acc_name	 char (32),
      341 		2 mode		 bit (36),
      342 		2 exmode		 bit (36),
      343 		2 reterr		 fixed bin (35);
      344 
      345 	dcl     1 series_info	 (nseries) aligned based (sip),
      346 						/* for restart_status command */
      347 		2 count		 fixed bin,
      348 		2 first		 fixed bin,
      349 		2 last		 fixed bin,
      350 		2 dcx		 fixed bin;
      351 
      352 	dcl     1 option		 aligned,		/* control options for the next_req driver request */
      353 		2 dev		 bit (1) unal,
      354 		2 q		 bit (1) unal,
      355 		2 user		 bit (1) unal,
      356 		2 id		 bit (1) unal,
      357 		2 et		 bit (1) unal,
      358 		2 pn		 bit (1) unal,
      359 		2 pad		 bit (30) unal;
      360 
      361 
      362 
      363 iodc_init:
      364      entry (dir, test_bit, test_iod_tables);
      365 
      366 /* Main entry point for I/O Coordinator */
      367 /* Initializes I/O Coordinator and waits for drivers.
      368**/
      369 
      370 	dcl     dir		 char (*);
      371 	dcl     test_bit		 bit (1) aligned;
      372 	dcl     test_iod_tables	 char (*);
      373 
      374 	call iodc_message_$init ();			/* set up stream attachments */
      375 
      376 	call ioa_ ("I/O Coordinator Version: ^a", io_coordinator_version);
      377 
      378 	sysdir = dir;
      379 	sysdir_len = length (rtrim (sysdir));
      380 	if sysdir_len > 136
      381 	then do;
      382 		call com_err_ (error_table_$pathlong, "iodc_init", "Cannot append max size device name to ^a.",
      383 		     sysdir);
      384 		go to forget_it;
      385 	     end;
      386 
      387 	subdir = substr (sysdir, 1, sysdir_len) || ">coord_dir";
      388 						/* construct pathname of coord_dir */
      389 
      390 	testing = test_bit;
      391 	return_label = back;
      392 	err_label = forget_it;
      393 	stat_p = addr (coord_static);
      394 
      395 	call get_system_free_area_ (areap);		/* set this once for temp allocations */
      396 
      397 	new_driver_series = 0;
      398 	com_level = -1;
      399 
      400 
      401 
      402 	initialized = "0"b;
      403 	quit_flag = "0"b;
      404 	on quit call quit_handler;
      405 	call iox_$control (iox_$user_io, "quit_enable", null, code);
      406 
      407 	recursion_flag = 0;
      408 	on cleanup call clean_up;			/* unmask, drop timer, etc. */
      409 	on any_other call iodc_handler;
      410 
      411 /* set up acl for data segs and directories */
      412 
      413 	n_acl = 2;
      414 
      415 	dir_acl (1).ac_name, acl (1).ac_name = get_group_id_$tag_star ();
      416 						/* make sure this process always has access */
      417 	dir_acl (1).modes, acl (1).modes = "111"b;
      418 
      419 	dir_acl (2).ac_name, acl (2).ac_name = "*.*.*";
      420 	dir_acl (2).modes, acl (2).modes = "100"b;
      421 
      422 /* First thing to do is check the saved list left by the last
      423*   coordinator for segments to be deleted.  To do this we need
      424*   two data bases:  req_desc_seg, and request_seg.
      425**/
      426 
      427 	call free_oldest_request_$init (stat_p);
      428 	call unthread_descriptor_$init (stat_p);
      429 
      430 	call initiate (subdir, "req_desc_seg", iodc_static.descr_seg_ptr, code);
      431 	if code ^= 0
      432 	then
      433 no_purge:
      434 	     call com_err_ (0, "iodc_init",
      435 		"Warning -- Cannot get old saved list.  Some deletions may not be performed.");
      436 	else do;
      437 		call initiate (subdir, "request_seg", iodc_static.req_seg_ptr, code);
      438 		if code ^= 0
      439 		then go to no_purge;
      440 
      441 		iodc_static.save_first_req_p = addr (req_desc_seg.first_saved);
      442 		iodc_static.first_req_done = req_desc_seg.first_saved;
      443 		do while (iodc_static.first_req_done ^= 0);
      444 		     call free_oldest_request_$cleanup;
      445 		end;
      446 	     end;
      447 
      448 /* delete coord_dir to make sure it gets recreated with proper access class */
      449 
      450 	call delete_$path (sysdir, "coord_dir", "101101"b, "", code);
      451 	if code ^= 0
      452 	then if code ^= error_table_$noentry
      453 	     then do;
      454 		     call com_err_ (code, "iodc_init", "Deleting coord_dir");
      455 		     go to forget_it;
      456 		end;
      457 
      458 
      459 /* get access class of sysdir and process authorization */
      460 
      461 	call hcs_$get_access_class (sysdir, "", sysdir_class, code);
      462 	if code ^= 0
      463 	then do;
      464 		call com_err_ (code, "iodc_init", sysdir);
      465 		go to forget_it;
      466 	     end;
      467 
      468 	auth = get_authorization_ ();
      469 	if ^testing
      470 	then do;
      471 		call system_info_$access_ceiling (system_high);
      472 		if ^aim_check_$equal (system_high, auth)
      473 		then call com_err_ (0, "iodc_init", "Warning -- Coordinator authorization is not ""system_high"".");
      474 	     end;
      475 
      476 /* make a subdirectory to hold the coordinator's writable data segs (i.e. segs modified after initialization) */
      477 /* this subdirectory will be upgraded (if necessary) to the coordinator's authorization */
      478 /* if upgraded, a quota of 250/25 records will be assigned */
      479 
      480 	branch_info.version = create_branch_version_2;	/* initialize branch info structure */
      481 	branch_info.dir_sw = "1"b;
      482 	branch_info.copy_sw = "0"b;
      483 	branch_info.chase_sw = "1"b;
      484 	branch_info.priv_upgrade_sw = "0"b;
      485 	branch_info.mbz1 = ""b;
      486 	branch_info.mode = "101"b;
      487 	branch_info.mbz2 = ""b;
      488 	branch_info.rings (1), branch_info.rings (2), branch_info.rings (3) = get_ring_ ();
      489 	branch_info.userid = acl (1).ac_name;
      490 	branch_info.bitcnt = 0;
      491 
      492 	call make_dir ("coord_dir", auth, 250, 25, code);
      493 	if code ^= 0
      494 	then do;
      495 		call com_err_ (code, "iodc_init", "^a>^a", sysdir, "coord_dir");
      496 		go to forget_it;
      497 	     end;
      498 
      499 /* set up data segments residing in sysdir */
      500 
      501 	seg_name = "iodc_data";
      502 	call make (sysdir, seg_name, iodc_data_ptr, code);
      503 	if code ^= 0
      504 	then do;
      505 no_init:
      506 		call com_err_ (code, "iodc_init", "Could not initiate(create) ^a", seg_name);
      507 forget_it:
      508 		call ioa_$ioa_stream ("error_output", "Process cannot be initialized.");
      509 		return;
      510 	     end;
      511 
      512 	if test_bit & test_iod_tables ^= ""
      513 	then seg_name = test_iod_tables;
      514 	else seg_name = "iod_tables";			/* get ptr to most recently compiled iod tables */
      515 	call initiate (sysdir, seg_name, ithp, code);
      516 	if code ^= 0
      517 	then go to no_init;
      518 	copy_words = divide (bc, 36, 24, 0);		/* remember number of words */
      519 
      520 	if iod_tables_hdr.version ^= IODT_VERSION_5
      521 	then do;
      522 		call com_err_ (0, "iodc_init", "Wrong version number for iod_tables.");
      523 		go to forget_it;
      524 	     end;
      525 
      526 /* now get the last iod_working_tables used to see if anything has changed. */
      527 	iwtp = null;
      528 	seg_name = "iod_working_tables";
      529 	call initiate (sysdir, seg_name, iwtp, code);
      530 	if code ^= 0
      531 	then if code = error_table_$noentry
      532 	     then go to update;
      533 	     else go to no_init;
      534 
      535 /* If version number has changed, iod_working_tables is to be ignored.
      536*   Fake a new table update.
      537*   If the version numbers are the same, then see if iod_tables is newer.
      538*   If so update the working tables with the new tables */
      539 	if iwtp -> iod_tables_hdr.version ^= IODT_VERSION_5
      540 	then go to update;
      541 	if iod_tables_hdr.date_time_compiled > iwtp -> iod_tables_hdr.date_time_compiled
      542 	then do;					/* new tables, must update the working tables */
      543 update:
      544 		seg_name = unique_chars_ (unique_bits_ ());
      545 						/* create unique name segment */
      546 		call make (sysdir, seg_name, new_iwtp, code);
      547 		if code ^= 0
      548 		then go to no_init;
      549 
      550 		iwtrb (1) = branch_info.rings (1);	/* set up ring brackets for working tables */
      551 		iwtrb (2), iwtrb (3) = 5;		/* make available through ring 5 */
      552 		call hcs_$set_ring_brackets (sysdir, seg_name, iwtrb, code);
      553 		if code ^= 0
      554 		then do;
      555 			call com_err_ (code, "iodc_init", "Attempting to set ring brackets of ^a", seg_name);
      556 			go to forget_it;
      557 		     end;
      558 
      559 		new_iwtp -> copy_template = ithp -> copy_template;
      560 						/* copy in iod_tables */
      561 
      562 		if iwtp ^= null
      563 		then do;
      564 			call hcs_$delentry_seg (iwtp, code);
      565 						/* delete old working tables */
      566 			if code ^= 0
      567 			then do;
      568 				call com_err_ (code, "iodc_init", "Attempting to delete iod_working_tables");
      569 				go to forget_it;
      570 			     end;
      571 		     end;
      572 		call hcs_$chname_seg (new_iwtp, seg_name, "iod_working_tables", code);
      573 						/* change name of new working tables */
      574 		if code ^= 0
      575 		then do;
      576 			call com_err_ (code, "iodc_init", "Attempting to change name of iod_working_tables");
      577 			go to forget_it;
      578 		     end;
      579 		iwtp = new_iwtp;
      580 	     end;
      581 
      582 	call hcs_$terminate_noname (ithp, code);
      583 
      584 
      585 /* set up segments in "coord_dir" */
      586 
      587 	seg_name = "coord_working_tables";		/* make coordinator's private copy of iod_tables */
      588 	call make (subdir, seg_name, cwtp, code);
      589 	if code ^= 0
      590 	then go to no_init;
      591 	cwtp -> copy_template = iwtp -> copy_template;
      592 
      593 	call hcs_$terminate_noname (iwtp, code);
      594 
      595 	seg_name = "waiting_list";
      596 	call make (subdir, seg_name, iodc_static.wait_list_ptr, code);
      597 	if code ^= 0
      598 	then go to no_init;
      599 
      600 	seg_name = "req_desc_seg";
      601 	call make (subdir, "req_desc_seg", iodc_static.descr_seg_ptr, code);
      602 	if code ^= 0
      603 	then go to no_init;
      604 	descr_area = empty;
      605 
      606 	seg_name = "request_seg";
      607 	call make (subdir, "request_seg", iodc_static.req_seg_ptr, code);
      608 	if code ^= 0
      609 	then go to no_init;
      610 	req_area = empty;
      611 
      612 
      613 /* initialize table pointers and other static info */
      614 
      615 	static_idtp = ptr (cwtp, cwtp -> iod_tables_hdr.device_tab_offset);
      616 	static_mdtp = ptr (cwtp, cwtp -> iod_tables_hdr.minor_device_tab_offset);
      617 	text_strings_ptr = ptr (cwtp, cwtp -> iod_tables_hdr.text_strings_offset);
      618 	iodc_static.qgtp = ptr (cwtp, cwtp -> iod_tables_hdr.q_group_tab_offset);
      619 	iodc_static.dctp = ptr (cwtp, cwtp -> iod_tables_hdr.dev_class_tab_offset);
      620 	iodc_static.time_interval = cwtp -> iod_tables_hdr.grace_time;
      621 	iodc_static.max_q = cwtp -> iod_tables_hdr.max_queues;
      622 	iodc_static.first_req_done, iodc_static.last_req_done = 0;
      623 	iodc_static.save_first_req_p = addr (req_desc_seg.first_saved);
      624 	req_desc_seg.first_saved = 0;
      625 
      626 /* set up message segment for new driver messages */
      627 
      628 	call message_segment_$delete (sysdir, "coord_comm.ms", code);
      629 						/* delete old message seg, if any */
      630 	if code ^= 0
      631 	then if code ^= error_table_$noentry
      632 	     then do;				/* could not delete it */
      633 		     call com_err_ (code, "iodc_init", "Attempting to delete coord_comm.ms");
      634 		     go to forget_it;
      635 		end;
      636 
      637 	seg_name = "coord_comm.ms";			/* for error message */
      638 	call message_segment_$create (sysdir, "coord_comm.ms", code);
      639 						/* create new message seg */
      640 	if code ^= 0
      641 	then go to no_init;				/* give up */
      642 	call message_segment_$open (sysdir, "coord_comm.ms", comm_mseg_idx, code);
      643 						/* open it */
      644 	if code ^= 0
      645 	then go to no_init;				/* give up */
      646 
      647 /* place the userid for each queue group on the message segment acl */
      648 
      649 	ms_acl.mode = "101"b;			/* want "rw" real access */
      650 	ms_acl.exmode = "1"b;			/* want "a" extended access */
      651 
      652 	do q = 1 to iodc_static.qgtp -> q_group_tab.n_q_groups;
      653 						/* loop through queue groups */
      654 	     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (q));
      655 						/* get ptr to q group entry */
      656 	     if qgte.driver_id ^= acl (1).ac_name
      657 	     then do;				/* don't change coord's access */
      658 		     ms_acl.acc_name = qgte.driver_id;
      659 		     call message_segment_$ms_acl_add (sysdir, "coord_comm.ms", addr (ms_acl), 1, code);
      660 		     if code ^= 0
      661 		     then do;
      662 			     if code = error_table_$argerr
      663 			     then code = ms_acl.reterr;
      664 			     call com_err_ (code, "iodc_init", "Adding to acl of coord_comm.ms");
      665 			     go to forget_it;
      666 			end;
      667 		end;
      668 
      669 	     qgte.open = 0;				/* initialize this while we're here */
      670 	end;
      671 
      672 /* initialize other coordinator procedures */
      673 
      674 	call find_next_request_$init (stat_p);
      675 	call save_request_$init (stat_p);
      676 
      677 /*  free all devices, i.e. delete all device dirs and segs */
      678 
      679 	do idtx = 1 to static_idtp -> iod_device_tab.n_devices;
      680 	     idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
      681 	     idte.process_id = ""b;
      682 	     call iodc_$free_device (idtep, code);
      683 	     if code ^= 0
      684 	     then /* failed to delete device directory */
      685 		go to forget_it;
      686 	end;
      687 
      688 
      689 /* initialize the device class table */
      690 
      691 	do dcx = 1 to iodc_static.dctp -> dev_class_tab.n_classes;
      692 	     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
      693 	     dcte.pending_request, dcte.restart_req = 0;
      694 	end;
      695 
      696 /* change initial acl so it will work for driver segs. */
      697 
      698 	n_acl = 3;
      699 	acl (n_acl).modes = "101"b;
      700 
      701 
      702 /* set up drivers' event channels */
      703 /* new-driver signal will have lower priority so coming-up message */
      704 /* can't beat previous logout message for same device */
      705 
      706 	call ipc_$create_ev_chn (chan_name, code);
      707 	if code ^= 0
      708 	then do;
      709 no_ipc:
      710 		call convert_ipc_code_ (code);
      711 		call com_err_ (code, "iodc_init", "IPC error setting up event channels.");
      712 		go to forget_it;
      713 	     end;
      714 	call ipc_$decl_ev_call_chn (chan_name, addr (iodc_$new_driver), null, 3, code);
      715 	if code ^= 0
      716 	then go to no_ipc;
      717 	iodc_data.init_event_channel = chan_name;
      718 
      719 	call ipc_$create_ev_chn (chan_name, code);
      720 	if code ^= 0
      721 	then go to no_ipc;
      722 	call ipc_$decl_ev_call_chn (chan_name, addr (iodc_$driver_signal), null, 1, code);
      723 	if code ^= 0
      724 	then go to no_ipc;
      725 	driver_sig_chan = chan_name;
      726 
      727 	call ipc_$create_ev_chn (chan_name, code);
      728 	if code ^= 0
      729 	then go to no_ipc;
      730 	call ipc_$decl_ev_call_chn (chan_name, addr (iodc_$driver_command), null, 2, code);
      731 	if code ^= 0
      732 	then go to no_ipc;
      733 	driver_cmd_chan = chan_name;
      734 
      735 /* and timer channel for freeing "saved" requests */
      736 
      737 	call ipc_$create_ev_chn (iodc_static.timer_chan, code);
      738 	if code ^= 0
      739 	then go to no_ipc;
      740 	call ipc_$decl_ev_call_chn (iodc_static.timer_chan, addr (free_oldest_request_$free_oldest_request_), null, 1,
      741 	     code);
      742 	if code ^= 0
      743 	then go to no_ipc;
      744 
      745 
      746 /* OK, let the show begin ... */
      747 
      748 	coord_proc_id, iodc_data.proc_id = get_process_id_ ();
      749 
      750 	initialized = "1"b;
      751 	call iodc_message_ ("010"b, 0, "I/O Coordinator initialized");
      752 	call iod_overseer_$coord_ready;		/* drivers can now get started */
      753 	call iodc_$command_level;
      754 
      755 
      756 back:
      757 	call clean_up;
      758 	return;					/* return to overseer (only in test mode) */
      759 
      760 
      761 clean_up:
      762      proc;
      763 
      764 	call timer_manager_$reset_alarm_wakeup (iodc_static.timer_chan);
      765 						/* through with this */
      766 	call ipc_$drain_chn (iodc_static.timer_chan, code);
      767 	call iox_$control (iox_$user_io, "start", null (), code);
      768 	call ipc_$unmask_ev_calls (code2);
      769 	call ipc_$delete_ev_chn (iodc_static.timer_chan, code2);
      770 	call ipc_$delete_ev_chn (driver_cmd_chan, code2);
      771 	call ipc_$delete_ev_chn (driver_sig_chan, code2);
      772 	call ipc_$delete_ev_chn (iodc_data.init_event_channel, code2);
      773 	return;
      774 
      775      end clean_up;
      776 
      777 
      778 make:
      779      proc (dirname, entname, p, code);
      780 
      781 	dcl     dirname		 char (*) aligned;
      782 	dcl     entname		 char (*) aligned;
      783 	dcl     p			 ptr;
      784 	dcl     code		 fixed bin (35);
      785 	dcl     hcs_$replace_acl	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1) aligned,
      786 				 fixed bin (35));
      787 
      788 	if testing
      789 	then call hcs_$make_seg (dirname, entname, "", 01111b, p, code);
      790 	else call privileged_make_seg_ (dirname, entname, "", 01111b, p, code);
      791 	if code ^= 0
      792 	then if code ^= error_table_$namedup
      793 	     then if code ^= error_table_$segknown
      794 		then return;
      795 	call hcs_$replace_acl (dirname, entname, addr (acl), n_acl, "0"b, code);
      796 
      797 	return;
      798      end;
      799 
      800 /* ********************************************************** */
      801 
      802 make_dir:
      803      proc (ename, aclass, aquota, adir_quota, code);
      804 
      805 	dcl     ename		 char (*) aligned;
      806 	dcl     aclass		 bit (72) aligned;	/* access class of directory */
      807 	dcl     aquota		 fixed bin;	/* quota on directory */
      808 	dcl     adir_quota		 fixed bin;
      809 	dcl     code		 fixed bin (35);
      810 	dcl     hcs_$replace_dir_acl	 entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1),
      811 				 fixed bin (35));
      812 
      813 	branch_info.access_class = aclass;
      814 	if aim_check_$equal (aclass, sysdir_class)
      815 	then branch_info.quota, branch_info.dir_quota = 0;
      816 	else do;
      817 		branch_info.quota = aquota;		/* need quota if dir is upgraded */
      818 		branch_info.dir_quota = adir_quota;
      819 	     end;
      820 
      821 create_branch:
      822 	call hcs_$create_branch_ (sysdir, ename, addr (branch_info), code);
      823 	if code = error_table_$invalid_move_qmax
      824 	then if branch_info.dir_quota = 0
      825 	     then return;
      826 	     else do;				/* try create without dir quota */
      827 		     branch_info.dir_quota = 0;
      828 		     go to create_branch;
      829 		end;
      830 	if code ^= 0
      831 	then return;
      832 
      833 	call hcs_$replace_dir_acl (sysdir, ename, addr (dir_acl), 2, "0"b, code);
      834      end make_dir;
      835 
      836 /* ********************************************************** */
      837 
      838 initiate:
      839      proc (dir, ent, p, code);
      840 
      841 	dcl     dir		 char (*) aligned;
      842 	dcl     ent		 char (*) aligned;
      843 	dcl     p			 ptr;
      844 	dcl     code		 fixed bin (35);
      845 
      846 	if testing
      847 	then /* don't use system_privilege_ in test mode */
      848 	     call hcs_$initiate_count (dir, ent, "", bc, 0, p, code);
      849 	else call system_privilege_$initiate_count (dir, ent, "", bc, 0, p, code);
      850 
      851 	if code = error_table_$segknown
      852 	then code = 0;
      853 
      854      end initiate;
      855 
      856 
      857 driver_signal:
      858      entry (a_ptr);
      859 
      860 /* This entry receives the wakeup from a driver process that has
      861*   *  just finished a request (or otherwise become ready for work),
      862*   *  or has just received a "restart", "save", or "logout" command.
      863*   *  The code in the event message will tell us which.
      864**/
      865 
      866 	mask_code = -1;
      867 	on cleanup
      868 	     begin;
      869 		if mask_code = 0
      870 		then call ipc_$unmask_ev_calls (code2);
      871 	     end;
      872 	call ipc_$mask_ev_calls (mask_code);
      873 
      874 	ev_info_ptr = a_ptr;
      875 	err_label = iodc_return;
      876 	proc_id = ev_info.sending_proc;
      877 
      878 /* find out which driver sent signal and make sure it's legitimate */
      879 
      880 	mdtx = addr (ev_info.message) -> ev_msg.minor_dev_index;
      881 						/* get minor device index */
      882 
      883 	call identify_sender (code);
      884 	if code ^= 0
      885 	then go to bad_signal;			/* reject the signal */
      886 
      887 /* find out what kind of signal it was, and branch accordingly */
      888 
      889 	sig_type = addr (ev_info.message) -> ev_msg.code;
      890 	if sig_type < 0 | sig_type > 5		/* Uh oh */
      891 	then do;
      892 		call ioa_$rsnnl ("Driver signal rejected from device ^a (bad code: ^d)", out_msg, out_len,
      893 		     sender_device, sig_type);
      894 bad_signal:
      895 		call iodc_message_ ("101"b, 0, out_msg);
      896 		go to iodc_return;
      897 	     end;
      898 
      899 	go to sig_label (sig_type);
      900 
      901 
      902 /* **************************************************** */
      903 
      904 identify_sender:
      905      proc (code);
      906 
      907 	dcl     code		 fixed bin (35);
      908 
      909 	if mdtx < 0 | mdtx > static_mdtp -> minor_device_tab.n_minor
      910 						/* a bum index */
      911 	then do;
      912 		out_msg = "Driver signal rejected (bad device index)";
      913 		code = error_table_$request_not_recognized;
      914 		return;
      915 	     end;
      916 
      917 	mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
      918 						/* get ptr to minor device entry */
      919 	idtx = mdte.major_index;			/* get major device index for this minor device */
      920 	idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
      921 						/* get ptr to major device entry */
      922 
      923 	if idte.process_id ^= ev_info.sending_proc	/* whoever sent signal does not own the device */
      924 	then do;
      925 		out_msg = "Driver signal rejected (device not assigned to process)";
      926 		code = error_table_$request_not_recognized;
      927 		return;
      928 	     end;
      929 
      930 	if mdte.active ^= 1
      931 	then do;					/* device isn't active, cannot accept signal */
      932 		out_msg = "Driver signal rejected (minor device not active)";
      933 		code = error_table_$request_not_recognized;
      934 		return;
      935 	     end;
      936 
      937 	dr_ptr = mdte.driver_ptr;			/* pick up ptr to driver status segment */
      938 	dcx = mdte.dev_class_index;			/* pick up index of device class entry */
      939 	dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
      940 						/* get ptr to device class entry */
      941 	qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
      942 
      943 	sender_device = get_device_name ();		/* keep signal sender's device name handy */
      944 	sender_class = get_class_name ();		/* and device class name too */
      945 
      946 	code = 0;
      947 	return;
      948 
      949      end identify_sender;
      950 
      951 /* ********************************************************** */
      952 
      953 get_device_name:
      954      proc returns (char (32) aligned);
      955 
      956 	dcl     name		 char (32) aligned;
      957 
      958 	if idte.last_minor > idte.first_minor /* if more than one minor */ | idte.dev_id ^= mdte.dev_id
      959 	then /* or if minor name is different, add it on */
      960 	     name = rtrim (idte.dev_id) || "." || mdte.dev_id;
      961 	else name = idte.dev_id;
      962 	return (name);
      963 
      964      end get_device_name;
      965 
      966 
      967 /* ********************************************************** */
      968 
      969 get_class_name:
      970      proc returns (char (32) aligned);
      971 
      972 	dcl     name		 char (32) aligned;
      973 
      974 	if qgte.last_dev_class > qgte.first_dev_class /* if more than one device class */ | qgte.name ^= dcte.id
      975 	then /* or if device class name is different, add it on */
      976 	     name = rtrim (qgte.name) || "." || dcte.id;
      977 	else name = qgte.name;
      978 	return (name);
      979 
      980      end get_class_name;
      981 
      982 
      983 sig_label (0):
      984 sig_label (1):					/*
      985* Come here on normal driver signal.
      986* (sig_type = 0) => driver done with request
      987* (sig_type = 1) => driver wants a new request (and is done with any current request) */
      988 						/* find out if driver just finished a request */
      989 	if mdte.current_request ^= 0
      990 	then do;
      991 
      992 /* yes, we've got a descriptor */
      993 /* copy updated portions */
      994 
      995 		desc_ptr = ptr (iodc_static.descr_seg_ptr, mdte.current_request);
      996 		copy_ptr = addr (dr_ptr -> driver_status.descriptor);
      997 		if ^(copy_ptr -> request_descriptor.finished | copy_ptr -> request_descriptor.cancelled)
      998 		then go to iodc_return;		/* don't screw up active request */
      999 		call update_descriptor;
     1000 
     1001 		mdte.current_request = 0;
     1002 
     1003 /* if it hasn't been saved yet, save it */
     1004 
     1005 		call save_request_ (desc_ptr, dctep);
     1006 	     end;
     1007 
     1008 	if sig_type = 0
     1009 	then go to iodc_return;			/* driver doesn't want a new request */
     1010 
     1011 /* is there a request hanging? */
     1012 
     1013 	if dcte.pending_request ^= 0
     1014 	then do;
     1015 		desc_ptr = ptr (iodc_static.descr_seg_ptr, dcte.pending_request);
     1016 		dcte.pending_request = desc_ptr -> request_descriptor.next_pending;
     1017 	     end;
     1018 
     1019 
     1020 /* are we in a restart cycle ? */
     1021 
     1022 	else if dcte.restart_req ^= 0
     1023 	then do;					/* in restart cycle */
     1024 		desc_ptr = ptr (iodc_static.descr_seg_ptr, dcte.restart_req);
     1025 		call unthread_descriptor_ (desc_ptr);	/* will be moved to end of saved list */
     1026 		desc_ptr -> request_descriptor.restarted = "1"b;
     1027 		desc_ptr -> request_descriptor.prev_seq_id = desc_ptr -> request_descriptor.seq_id;
     1028 		dcte.restart_req = 0;		/* reset indicator til we find another */
     1029 
     1030 /* 	if restarting a series, find the next request to restart next time around */
     1031 
     1032 		if desc_ptr -> request_descriptor.series_restart
     1033 		then do;
     1034 			series_id = divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0);
     1035 			desc_off = desc_ptr -> request_descriptor.next_done;
     1036 			do while (desc_off ^= 0);	/* look for next request to restart */
     1037 			     next_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
     1038 						/* if this is part of the series */
     1039 			     if divide (next_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
     1040 			     then do;
     1041 				     next_ptr -> request_descriptor.saved = "1"b;
     1042 						/* should be on already, make sure */
     1043 				     next_ptr -> request_descriptor.series_restart = "1"b;
     1044 						/* so should this */
     1045 				     dcte.restart_req = desc_off;
     1046 						/* we'll do this one next time */
     1047 				     desc_off = 0;	/* drop out of loop */
     1048 				end;
     1049 
     1050 			     else desc_off = next_ptr -> request_descriptor.next_done;
     1051 			end;
     1052 		     end;
     1053 	     end;
     1054 
     1055 
     1056 	else do;
     1057 
     1058 /* Now we must get a brand new request from one of the queues */
     1059 
     1060 		area_flag = 0;			/* indicates area condition not raised yet */
     1061 		on area call area_handler;
     1062 		allocate request_descriptor in (descr_area) set (desc_ptr);
     1063 		revert area;
     1064 
     1065 		unspec (desc_ptr -> request_descriptor) = ""b;
     1066 
     1067 		if ^find_next_request_ (dcx, desc_ptr)
     1068 		then do;
     1069 
     1070 /* we didn't get one */
     1071 
     1072 			free desc_ptr -> request_descriptor in (descr_area);
     1073 
     1074 			if dr_ptr -> driver_status.acknowledge
     1075 			then do;			/* must tell driver anyway */
     1076 				call hcs_$wakeup (idte.process_id, dr_ptr -> driver_status.driver_chan, 0, code);
     1077 				if code ^= 0
     1078 				then call check_wakeup_code (code);
     1079 			     end;
     1080 
     1081 			go to iodc_return;
     1082 		     end;
     1083 
     1084 	     end;
     1085 
     1086 
     1087 /* Okay, let's send it! */
     1088 
     1089 	desc_ptr -> request_descriptor.seq_id = mdte.seq_id + 1;
     1090 	desc_ptr -> request_descriptor.finished = "0"b;
     1091 
     1092 	addr (dr_ptr -> driver_status.descriptor) -> request_descriptor = desc_ptr -> request_descriptor;
     1093 	addr (dr_ptr -> driver_status.descriptor) -> request_descriptor.saved = "0"b;
     1094 						/* see if driver wants it saved */
     1095 	message_len = desc_ptr -> mseg_message_info.ms_len;
     1096 	addr (dr_ptr -> driver_status.message) -> based_message = desc_ptr -> mseg_message_info.ms_ptr -> based_message;
     1097 
     1098 	desc_off = fixed (rel (desc_ptr), 18);
     1099 
     1100 	if ^stac (addr (dr_ptr -> driver_status.request_pending), coord_proc_id)
     1101 	then do;					/* driver no longer wants request */
     1102 make_pending:
     1103 		desc_ptr -> request_descriptor.next_pending = dcte.pending_request;
     1104 		dcte.pending_request = desc_off;
     1105 		go to iodc_return;
     1106 	     end;
     1107 
     1108 	call hcs_$wakeup (idte.process_id, dr_ptr -> driver_status.driver_chan, 0, code);
     1109 	if code ^= 0
     1110 	then do;
     1111 		call check_wakeup_code (code);
     1112 		go to make_pending;
     1113 	     end;
     1114 
     1115 	mdte.current_request = desc_off;
     1116 	if mod (desc_ptr -> request_descriptor.seq_id, 10000) = 9999
     1117 	then do;
     1118 new_series:
     1119 		new_driver_series = new_driver_series + 10000;
     1120 		mdte.seq_id = new_driver_series;
     1121 		call ioa_$rsnnl ("Device ^a switched to series ^d.", out_msg, out_len, sender_device,
     1122 		     new_driver_series);
     1123 		call iodc_message_ ("100"b, 0, out_msg);
     1124 	     end;
     1125 	else mdte.seq_id = desc_ptr -> request_descriptor.seq_id;
     1126 
     1127 /* all done, go home */
     1128 
     1129 iodc_return:
     1130 	call ipc_$unmask_ev_calls (code);
     1131 	recursion_flag = 0;
     1132 	return;
     1133 
     1134 
     1135 /* ***************************************************** */
     1136 
     1137 
     1138 /* This procedure updates a few items in the coord's
     1139*   copy of a descriptor from the driver's copy. */
     1140 
     1141 update_descriptor:
     1142      proc;
     1143 
     1144 	desc_ptr -> request_descriptor.driver_data = copy_ptr -> request_descriptor.driver_data;
     1145 	desc_ptr -> request_descriptor.cancelled = copy_ptr -> request_descriptor.cancelled;
     1146 	desc_ptr -> request_descriptor.dont_delete = copy_ptr -> request_descriptor.dont_delete;
     1147 	if ^desc_ptr -> request_descriptor.saved
     1148 	then /* if still in queue we may keep it there */
     1149 	     desc_ptr -> request_descriptor.keep_in_queue = copy_ptr -> request_descriptor.keep_in_queue;
     1150 	desc_ptr -> request_descriptor.saved =
     1151 	     /* hold request if saved or deferred by driver command */ copy_ptr -> request_descriptor.saved
     1152 	     | copy_ptr -> request_descriptor.keep_in_queue;
     1153 
     1154      end update_descriptor;
     1155 
     1156 
     1157 sig_label (2):
     1158 	series_sw = "1"b;
     1159 	ack_chan = 0;
     1160 	seq_id = addr (ev_info.message) -> ev_msg.seq_id;
     1161 	go to restart_or_save;
     1162 
     1163 sig_label (3):
     1164 	series_sw = "1"b;
     1165 	ack_chan = 0;
     1166 	seq_id = addr (ev_info.message) -> ev_msg.seq_id;
     1167 
     1168 
     1169 restart_or_save:					/*
     1170*   Here for "restart _n"(2) or "save _n"(3) command given to driver. For
     1171*   "restart" we will record that requests for the device class have been
     1172*   restarted, and look for the request from which to restart. For "save" we
     1173*   will simply scan through setting "saved" bit in all requests done of 
     1174*   specified series. */
     1175 
     1176 	if sig_type = save
     1177 	then cmd = "Save";				/* set up for messages */
     1178 	else cmd = "Restart";
     1179 
     1180 	call ioa_$rsnnl ("^a command received from device ^a", out_msg, out_len, cmd, idte.dev_id);
     1181 	call iodc_message_ ("110"b, 0, out_msg);
     1182 
     1183 	series_id = divide (seq_id, 10000, 35, 0);
     1184 
     1185 	do desc_off = iodc_static.first_req_done repeat desc_ptr -> request_descriptor.next_done while (desc_off ^= 0);
     1186 	     desc_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
     1187 
     1188 	     if divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
     1189 	     then /* right series? */
     1190 		if desc_ptr -> request_descriptor.seq_id >= seq_id
     1191 		then /* right request or next one in series? */
     1192 		     if desc_ptr -> request_descriptor.dev_class_index = dcx
     1193 		     then /* is it ours? */
     1194 			go to found_desc;		/* WHEW!  Now make decisions for this one */
     1195 
     1196 		     else do;
     1197 
     1198 /* A restart or save of a given series is logically only allowed
     1199*   to be performed by a driver of the same device class that the
     1200*   series was originally done under.  However, a driver with multiple
     1201*   minor devices has one device class for each minor device.
     1202*   Therefore, even if the minor device that actually sent the
     1203*   wakeup does not have the matching device class, we will allow
     1204*   it so long as one of the other minor devices of the same
     1205*   driver process does have the matching device class.
     1206**/
     1207 
     1208 			     if idte.last_minor > idte.first_minor
     1209 			     then /* more than one minor device */
     1210 				do mdtx = idte.first_minor to idte.last_minor;
     1211 						/* look for one with right device class */
     1212 				     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
     1213 				     if mdte.active = 1
     1214 				     then if mdte.dev_class_index = desc_ptr -> request_descriptor.dev_class_index
     1215 					then do;
     1216 						sender_device = get_device_name ();
     1217 						dctep =
     1218 						     addr (iodc_static.dctp
     1219 						     -> dev_class_tab.entries (mdte.dev_class_index));
     1220 						qgtep =
     1221 						     addr (iodc_static.qgtp
     1222 						     -> q_group_tab.entries (dcte.qgte_index));
     1223 						sender_class = get_class_name ();
     1224 						go to found_desc;
     1225 					     end;
     1226 				end;
     1227 
     1228 			     call ioa_$rsnnl (
     1229 				"^a rejected.  Sender device class does not match that of specified request.",
     1230 				out_msg, out_len, cmd);
     1231 			     call iodc_message_ ("110"b, 0, out_msg);
     1232 			     code = error_table_$action_not_performed;
     1233 			     call driver_ack (code, 0);
     1234 						/* tell driver */
     1235 			     go to iodc_return;
     1236 			end;
     1237 
     1238 	end;
     1239 
     1240 /* come here if the specified sequence id was not found and
     1241*   neither were any higher sequence ids in the same series.
     1242**/
     1243 
     1244 	call ioa_$rsnnl ("No saved requests from number ^d", out_msg, out_len, seq_id);
     1245 	call iodc_message_ ("101"b, 0, out_msg);
     1246 	code = error_table_$noentry;
     1247 	go to tell_driver;
     1248 
     1249 
     1250 found_desc:
     1251 	if sig_type = restart
     1252 	then /* restart only */
     1253 	     if dcte.restart_req ^= 0
     1254 	     then do;
     1255 		     call ioa_$rsnnl ("Restart already in progress for request type ^a", out_msg, out_len,
     1256 			sender_class);
     1257 		     call iodc_message_ ("101"b, 0, out_msg);
     1258 		     code = error_table_$namedup;	/* duplicate request for restart */
     1259 		     go to tell_driver;
     1260 		end;
     1261 
     1262 	if desc_ptr -> request_descriptor.seq_id > seq_id
     1263 	then do;
     1264 		call ioa_$rsnnl ("Request ^d is gone.", out_msg, out_len, seq_id);
     1265 		call iodc_message_ ("001"b, 0, out_msg);
     1266 		code = error_table_$noentry;		/* for single restart error message */
     1267 		if ^series_sw
     1268 		then go to tell_driver;		/* stop now if no series */
     1269 	     end;
     1270 
     1271 	code = 0;					/* we will do a restart now, tell driver OK */
     1272 	seq_id = desc_ptr -> request_descriptor.seq_id;	/* say we started at this request */
     1273 
     1274 	call ioa_$rsnnl ("^a ^[from^;of^] request ^d initiated for request type ^a", out_msg, out_len, cmd, series_sw,
     1275 	     seq_id, sender_class);
     1276 	call iodc_message_ ("110"b, 0, out_msg);
     1277 
     1278 	if sig_type = restart
     1279 	then /* establish restart cycle */
     1280 	     dcte.restart_req = desc_off;
     1281 
     1282 /* for both restart and save, turn on "saved" indicators */
     1283 
     1284 	desc_ptr -> request_descriptor.saved = "1"b;
     1285 	if series_sw
     1286 	then do;
     1287 		if sig_type = restart
     1288 		then desc_ptr -> request_descriptor.series_restart = "1"b;
     1289 						/* this triggers the sequence for next req cmd */
     1290 		do desc_off = desc_ptr -> request_descriptor.next_done
     1291 		     repeat desc_ptr -> request_descriptor.next_done while (desc_off ^= 0);
     1292 		     desc_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
     1293 		     if divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
     1294 		     then do;
     1295 			     desc_ptr -> request_descriptor.saved = "1"b;
     1296 			     if sig_type = restart
     1297 			     then desc_ptr -> request_descriptor.series_restart = "1"b;
     1298 			end;
     1299 		end;
     1300 	     end;
     1301 
     1302 /* if the series restarted or saved is in use, give driver a new series */
     1303 
     1304 	do mdtx = 1 to static_mdtp -> minor_device_tab.n_minor;
     1305 						/* see if series is in use */
     1306 	     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
     1307 	     if mdte.active = 1
     1308 	     then if divide (mdte.seq_id, 10000, 35, 0) = series_id
     1309 		then do;
     1310 			idtep = addr (static_idtp -> iod_device_tab.entries (mdte.major_index));
     1311 			sender_device = get_device_name ();
     1312 			call driver_ack (0, seq_id);	/* be sure driver gets OK */
     1313 			go to new_series;
     1314 		     end;
     1315 	end;
     1316 
     1317 tell_driver:
     1318 	call driver_ack (code, seq_id);		/* tell what happened and which request number */
     1319 	go to iodc_return;				/* ============= */
     1320 
     1321 /* ********************************************************** */
     1322 
     1323 driver_ack:
     1324      proc (code, num);
     1325 
     1326 	dcl     code		 fixed bin (35);
     1327 	dcl     num		 fixed bin (35);
     1328 	dcl     ec		 fixed bin (35);
     1329 
     1330 	if ack_chan = 0
     1331 	then return;				/* if nothing defined, quit */
     1332 
     1333 	addr (event_message) -> ack_msg.code = code;
     1334 	addr (event_message) -> ack_msg.num = num;
     1335 
     1336 	call hcs_$wakeup (proc_id, ack_chan, event_message, ec);
     1337 
     1338 	if ec ^= 0
     1339 	then call iodc_message_ ("101"b, code, "Unable to acknowledge driver command.");
     1340 
     1341 	return;
     1342 
     1343      end driver_ack;
     1344 
     1345 
     1346 
     1347 sig_label (4):					/* 
     1348*   This branch is taken when a driver process has received a "logout" command.
     1349*   It frees the major device assigned to the driver process. */
     1350 
     1351 	call iodc_$free_device (idtep, code);
     1352 	if code = 0
     1353 	then do;
     1354 		call ioa_$rsnnl ("Driver logout for device ^a", out_msg, out_len, idte.dev_id);
     1355 		call iodc_message_ ("100"b, 0, out_msg);
     1356 	     end;
     1357 	go to iodc_return;
     1358 
     1359 
     1360 /* ********************************************************** */
     1361 
     1362 
     1363 sig_label (5):					/* 
     1364*This branch is taken when the driver wants to get the event channel needed to
     1365*send commands through coord_comm.ms, which is only given to live drivers */
     1366 
     1367 	event_message = driver_cmd_chan;
     1368 
     1369 	call hcs_$wakeup (proc_id, dr_ptr -> driver_status.driver_chan, event_message, code);
     1370 
     1371 	if code ^= 0
     1372 	then call check_wakeup_code (code);
     1373 
     1374 	go to iodc_return;
     1375 
     1376 
     1377 free_device:
     1378      entry (a_idtep, a_code);
     1379 
     1380 /* This entry frees a major device for subsequent use by  another driver. */
     1381 /* The process id assigned to the device is zeroed, and each minor device is marked inactive */
     1382 /* The major device directory and all contained driver status segments are deleted. */
     1383 /* If an unfinished request is found for a minor device, that request is
     1384*   made pending for the associated device class and marked as "continued". */
     1385 
     1386 	dcl     a_idtep		 ptr;		/* device table entry ptr */
     1387 	dcl     a_code		 fixed bin (35);
     1388 
     1389 
     1390 	idtep = a_idtep;
     1391 
     1392 /* loop thru minor devices making each inactive */
     1393 
     1394 	do mdtx = idte.first_minor to idte.last_minor;
     1395 	     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
     1396 	     if idte.process_id ^= ""b
     1397 	     then if mdte.active = 1
     1398 		then if mdte.current_request ^= 0
     1399 		     then do;			/* could be an unfinished request */
     1400 			     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (mdte.dev_class_index));
     1401 			     desc_ptr = ptr (iodc_static.descr_seg_ptr, mdte.current_request);
     1402 			     copy_ptr = addr (mdte.driver_ptr -> driver_status.descriptor);
     1403 			     call update_descriptor;
     1404 			     if copy_ptr -> request_descriptor.finished | copy_ptr -> request_descriptor.cancelled
     1405 			     then /* consider it done */
     1406 				call save_request_ (desc_ptr, dctep);
     1407 
     1408 			     else do;		/* not finished, make request pending */
     1409 				     desc_ptr -> request_descriptor.next_pending = dcte.pending_request;
     1410 				     dcte.pending_request = fixed (rel (desc_ptr), 18);
     1411 				     desc_ptr -> request_descriptor.continued = "1"b;
     1412 						/* this request is not brand new */
     1413 				     desc_ptr -> request_descriptor.contd_seq_id =
     1414 					desc_ptr -> request_descriptor.seq_id;
     1415 				end;
     1416 
     1417 			     mdte.current_request = 0;
     1418 			end;
     1419 
     1420 	     mdte.active = 0;
     1421 	end;
     1422 
     1423 	idte.lock, idte.process_id = ""b;
     1424 
     1425 	call delete_$path (sysdir, idte.dev_id, "101101"b, "", code);
     1426 						/* delete major device dir */
     1427 	if code ^= 0
     1428 	then if code ^= error_table_$noentry
     1429 	     then do;
     1430 		     call ioa_$rsnnl ("Deleting ^a>^a.  Cannot free device.", out_msg, out_len, sysdir, idte.dev_id);
     1431 		     call iodc_message_ ("101"b, code, out_msg);
     1432 		end;
     1433 	     else code = 0;
     1434 
     1435 	a_code = code;
     1436 
     1437 	return;
     1438 
     1439 
     1440 new_driver:
     1441      entry (a_ptr);
     1442 
     1443 /* This entry gets a wakeup from a driver that's just come up. We
     1444*   *  must allocate a structure for it and alert it that we're ready for it
     1445*   *  to operate.
     1446**/
     1447 
     1448 	entry_type = new_driver;
     1449 	go to read_comm_msg;
     1450 
     1451 
     1452 driver_command:
     1453      entry (a_ptr);
     1454 
     1455 /* this entry uses some similar code to the new driver entry, but is used by a driver to signal commands
     1456*   which need more space than an event message can provide */
     1457 
     1458 	entry_type = driver_command;
     1459 
     1460 read_comm_msg:
     1461 	ack_chan = 0;				/* define this as not known for now */
     1462 	mask_code = -1;
     1463 	on cleanup
     1464 	     begin;
     1465 		call driver_ack (error_table_$action_not_performed, 0);
     1466 						/* break driver loose */
     1467 		if mask_code = 0
     1468 		then call ipc_$unmask_ev_calls (code2);
     1469 	     end;
     1470 	call ipc_$mask_ev_calls (mask_code);
     1471 	err_label = iodc_return;
     1472 	ev_info_ptr = a_ptr;
     1473 	proc_id = ev_info.sending_proc;
     1474 
     1475 /* The event message for the new driver wakeup should contain a message id. */
     1476 /* The message id  identifies a message placed in coord_comm.ms by the driver */
     1477 
     1478 	ms_id = unspec (ev_info.message);
     1479 	unspec (driver_mmi) = ""b;
     1480 	driver_mmi.version = MSEG_MESSAGE_INFO_V1;
     1481 	driver_mmi.ms_id = ms_id;
     1482 	driver_mmi.message_code = MSEG_READ_SPECIFIED;
     1483 	call message_segment_$read_message_index (comm_mseg_idx, areap, addr (driver_mmi), code);
     1484 	if code ^= 0
     1485 	then do;
     1486 		call iodc_message_ ("101"b, code, "Attempting to read driver message from coord_comm.ms");
     1487 		go to iodc_return;
     1488 	     end;
     1489 	call message_segment_$delete_index (comm_mseg_idx, ms_id, code);
     1490 						/* delete the message */
     1491 	if code ^= 0
     1492 	then call iodc_message_ ("101"b, code, "Deleting coord_comm.ms driver message");
     1493 
     1494 	if entry_type = new_driver
     1495 	then go to make_new_driver;
     1496 
     1497 /* otherwise, this is a driver command .. so get set up for it */
     1498 
     1499 
     1500 	comm_ptr = driver_mmi.ms_ptr;			/* set pointer to message for easy reference */
     1501 	ack_chan = iodd_comm.ack_chan;		/* this is how we tell what happened */
     1502 	err_label = abort_driver_cmd;			/* be sure we jolt driver on errors */
     1503 	mdtx = iodd_comm.minor_idx;			/* see who the driver says he is */
     1504 
     1505 	call identify_sender (code);
     1506 	if code ^= 0
     1507 	then do;
     1508 bad_req:
     1509 		call driver_ack (code, 0);		/* don't let the driver hang */
     1510 		go to iodc_return;
     1511 	     end;
     1512 
     1513 	sig_type = iodd_comm.type;			/* this is the command code */
     1514 
     1515 	if sig_type = save | sig_type = restart
     1516 	then do;					/* for save and restart commands */
     1517 		seq_id = iodd_comm.request_no;
     1518 		if iodd_comm.type_ext = ""b
     1519 		then series_sw = ""b;
     1520 		else series_sw = "1"b;
     1521 		go to restart_or_save;		/* join the main part */
     1522 	     end;
     1523 
     1524 	if sig_type = restart_q
     1525 	then go to restart_queue;			/* for restart_q command */
     1526 
     1527 	if sig_type = next_req
     1528 	then go to next_request;
     1529 
     1530 	code = error_table_$request_not_recognized;
     1531 	go to bad_req;
     1532 
     1533 
     1534 abort_driver_cmd:
     1535 	call driver_ack (error_table_$action_not_performed, 0);
     1536 	go to iodc_return;
     1537 
     1538 
     1539 make_new_driver:
     1540 	new_driver_id = driver_mmi.sender_id;		/* get person/project name of new driver */
     1541 	i = length (rtrim (new_driver_id));		/* locate tag portion of group id */
     1542 	substr (new_driver_id, i) = "*";		/* any tag is ok */
     1543 	auth = driver_mmi.sender_authorization;		/* get authorization of new driver */
     1544 	new_driver_msg_p = driver_mmi.ms_ptr;
     1545 	chan_name = new_driver_msg.wakeup_chan;		/* pick up channel on which to wakeup driver */
     1546 
     1547 /* find out what device class the new driver wants */
     1548 /* make sure the driver's authorization is right for the device class */
     1549 
     1550 	dcx = new_driver_msg.dev_class_index;		/* get index of desired device class */
     1551 	if dcx < 1 | dcx > iodc_static.dctp -> dev_class_tab.n_classes
     1552 						/* bad index */
     1553 	then do;
     1554 		code = 1;
     1555 		call ioa_$rsnnl ("New driver rejected: ^a (bad device class index)", out_msg, out_len, new_driver_id);
     1556 
     1557 bad_new_driver:
     1558 		call iodc_message_ ("100"b, 0, out_msg);
     1559 		go to wake_driver;
     1560 	     end;
     1561 
     1562 	dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
     1563 						/* get dev class table entry ptr */
     1564 
     1565 	qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
     1566 						/* get q group tab entry ptr */
     1567 
     1568 	sender_class = get_class_name ();		/* get device class name */
     1569 
     1570 	if ^aim_check_$greater_or_equal (auth, dcte.max_access)
     1571 	then do;					/* insufficient authorization */
     1572 		code = 2;
     1573 		call ioa_$rsnnl ("New driver rejected: ^a (wrong authorization for device class ^a)", out_msg,
     1574 		     out_len, new_driver_id, sender_class);
     1575 		go to bad_new_driver;
     1576 	     end;
     1577 
     1578 /* make sure driver's userid is right for queue group */
     1579 
     1580 	if qgte.driver_id ^= new_driver_id
     1581 	then do;					/* wrong userid */
     1582 		code = 3;
     1583 		call ioa_$rsnnl ("New driver rejected: ^a (invalid userid for ^a queue group)", out_msg, out_len,
     1584 		     new_driver_id, qgte.name);
     1585 		go to bad_new_driver;
     1586 	     end;
     1587 
     1588 /* now find out which device the new driver wants */
     1589 /* make sure that its valid for the device class and that its not already in use */
     1590 
     1591 	mdtx = new_driver_msg.device_index;
     1592 	if mdtx < 1 | mdtx > static_mdtp -> minor_device_tab.n_minor
     1593 						/* bad index */
     1594 	then do;
     1595 		code = 4;
     1596 		call ioa_$rsnnl ("New driver rejected: ^a (bad minor device index)", out_msg, out_len, new_driver_id);
     1597 		go to bad_new_driver;
     1598 	     end;
     1599 
     1600 	mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
     1601 	idtx = mdte.major_index;			/* get major device index */
     1602 	idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
     1603 	sender_device = get_device_name ();		/* pick up major device name */
     1604 
     1605 	if ^substr (dcte.device_list, mdtx, 1)
     1606 	then do;					/* device not valid for this class */
     1607 		code = 5;
     1608 		call ioa_$rsnnl ("New driver rejected: ^a (device ^a invalid for device class ^a)", out_msg, out_len,
     1609 		     new_driver_id, sender_device, sender_class);
     1610 		go to bad_new_driver;
     1611 	     end;
     1612 
     1613 	if idte.process_id ^= ""b
     1614 	then /* major device is already assigned */
     1615 	     if idte.process_id ^= proc_id
     1616 	     then do;				/* but not to this process */
     1617 		     call set_lock_$lock (idte.lock, 0, code);
     1618 						/* see if lock is still valid */
     1619 		     if code = 0 | code = error_table_$invalid_lock_reset
     1620 		     then do;			/* bad lock so free the device */
     1621 			     call iodc_$free_device (idtep, code);
     1622 			     if code ^= 0
     1623 			     then do;
     1624 				     code = 10;
     1625 				     go to wake_driver;
     1626 				end;
     1627 			end;
     1628 		     else do;			/* lock was good, can't give new driver this device */
     1629 			     code = 6;
     1630 			     call ioa_$rsnnl ("New driver rejected: ^a (device ^a assigned to other process)",
     1631 				out_msg, out_len, new_driver_id, idte.dev_id);
     1632 			     go to bad_new_driver;
     1633 			end;
     1634 		end;
     1635 	     else if mdte.active ^= 0
     1636 	     then do;				/* we already gave him this one */
     1637 		     code = 7;
     1638 		     call ioa_$rsnnl ("New driver rejected: ^a (device ^a already active)", out_msg, out_len,
     1639 			new_driver_id, sender_device);
     1640 		     go to bad_new_driver;
     1641 		end;
     1642 
     1643 /* if the message segment queues have not yet been opened for this group, then open them */
     1644 
     1645 	if qgte.open = 0
     1646 	then /* queues have not been opened */
     1647 	     do q = 1 to qgte.max_queues;		/* open them */
     1648 		qgte.last_read (q) = "0"b;
     1649 		call ioa_$rsnnl ("^a_^d.ms", q_name, out_len, qgte.name, q);
     1650 		call message_segment_$open (sysdir, q_name, q_idx, code);
     1651 
     1652 		if code ^= 0
     1653 		then do;
     1654 			if code = error_table_$noentry
     1655 			then call ioa_$rsnnl ("Queue ^d for request type ^a missing.", out_msg, out_len, q, dcte.id)
     1656 				;
     1657 			else call ioa_$rsnnl ("Could not open ^a>^a", out_msg, out_len, sysdir, q_name);
     1658 			call iodc_message_ ("101"b, code, out_msg);
     1659 			code = 8;
     1660 			go to wake_driver;
     1661 		     end;
     1662 
     1663 		call message_segment_$check_salv_bit_index (q_idx, "1"b, unbit, code);
     1664 		if unbit
     1665 		then do;
     1666 			call ioa_$rsnnl ("Message segment ^a was salvaged. Some requests may have been lost.",
     1667 			     out_msg, out_len, q_name);
     1668 			call iodc_message_ ("110"b, 0, out_msg);
     1669 		     end;
     1670 
     1671 		qgte.mseg_index (q) = q_idx;		/* save the message segment index */
     1672 	     end;
     1673 
     1674 /* If the major device was not previously assigned, we must  create */
     1675 /* a directory to hold all driver status segments for the major device. */
     1676 /* This directory will be upgraded (if necessary) to the authorization of the new driver. */
     1677 /* If upgraded, a quota of 2 records per minor device will be assigned. 
     1678*The dir_quota will be a min of 5, or 1/6 page per segment. */
     1679 
     1680 	if idte.process_id = ""b
     1681 	then do;					/* device not previously assigned */
     1682 		quota = 2 * (idte.last_minor - idte.first_minor + 1);
     1683 						/* 2 records per minor device */
     1684 		dir_quota = max (5, divide (idte.last_minor - idte.first_minor + 1, 6, 17));
     1685 		call make_dir (idte.dev_id, auth, quota, dir_quota, code);
     1686 		if code ^= 0
     1687 		then do;				/* failed to create dir */
     1688 			call ioa_$rsnnl ("Cannot create directory for device ^a", out_msg, out_len, idte.dev_id);
     1689 			call iodc_message_ ("101"b, code, out_msg);
     1690 						/* tell the operator */
     1691 			code = 9;
     1692 			go to wake_driver;
     1693 		     end;
     1694 	     end;
     1695 
     1696 /* now we're ready to set up driver status segment */
     1697 
     1698 	subdir = sysdir;
     1699 	substr (subdir, sysdir_len + 1, 1) = ">";
     1700 	substr (subdir, sysdir_len + 2) = idte.dev_id;	/* construct dir name */
     1701 	acl (n_acl).ac_name = new_driver_id;		/* put driver on the acl of driver status seg */
     1702 	call make (subdir, mdte.dev_id, dr_ptr, code);
     1703 
     1704 	if code ^= 0
     1705 	then do;
     1706 		call ioa_$rsnnl ("Cannot create driver status segment for device ^a", out_msg, out_len, sender_device)
     1707 		     ;
     1708 		call iodc_message_ ("101"b, code, out_msg);
     1709 		code = 10;
     1710 		go to wake_driver;
     1711 	     end;
     1712 
     1713 /* set up driver status segment contents */
     1714 
     1715 	unspec (dr_ptr -> driver_status) = "0"b;
     1716 	dr_ptr -> driver_status.req_type_label = sender_class;
     1717 	dr_ptr -> driver_status.dev_name_label = sender_device;
     1718 	dr_ptr -> driver_status.device_id = mdte.dev_id;
     1719 	dr_ptr -> driver_status.device_class_id = dcte.id;
     1720 	dr_ptr -> driver_status.coord_chan = driver_sig_chan;
     1721 	dr_ptr -> driver_status.request_pending = "0"b;
     1722 	dr_ptr -> driver_status.dev_index = mdtx;
     1723 	dr_ptr -> driver_status.maj_index = idtx;
     1724 	dr_ptr -> driver_status.dev_class_index = dcx;
     1725 	dr_ptr -> driver_status.minor_args = mdte.args;
     1726 	dr_ptr -> driver_status.min_banner = dcte.min_banner;
     1727 
     1728 	dr_ptr -> driver_status.rqti_ptr = null;
     1729 	dr_ptr -> driver_status.dev_out_iocbp = null;
     1730 	dr_ptr -> driver_status.dev_in_iocbp = null;
     1731 	dr_ptr -> driver_status.dev_out_stream = "";
     1732 	dr_ptr -> driver_status.dev_in_stream = "";
     1733 	dr_ptr -> driver_status.forms_validation_ptr = null;
     1734 	dr_ptr -> driver_status.dev_ptr1 = null;
     1735 	dr_ptr -> driver_status.dev_ctl_ptr = null;
     1736 
     1737 /* modify coordinator data bases to reflect new driver */
     1738 
     1739 	qgte.open = 1;
     1740 	idte.lock = new_driver_msg.lock_id;
     1741 	idte.process_id = proc_id;
     1742 	mdte.dev_class_index = dcx;
     1743 	mdte.active = 1;
     1744 	mdte.driver_ptr = dr_ptr;
     1745 	mdte.current_request = 0;
     1746 	new_driver_series = new_driver_series + 10000;
     1747 	mdte.seq_id = new_driver_series;
     1748 
     1749 	call ioa_$rsnnl ("New driver for device ^a, request type ^a (series = ^d)", out_msg, out_len, sender_device,
     1750 	     sender_class, new_driver_series);
     1751 	;
     1752 	call iodc_message_ ("100"b, 0, out_msg);
     1753 
     1754 
     1755 wake_driver:					/* tell the guy all about it */
     1756 	event_message = 0;
     1757 	addr (event_message) -> ev_msg.code = code;
     1758 
     1759 	call hcs_$wakeup (proc_id, chan_name, event_message, code);
     1760 	if code ^= 0
     1761 	then call check_wakeup_code (code);
     1762 	go to iodc_return;
     1763 
     1764 
     1765 restart_queue:					/* 
     1766*go back to the head of the queues for this driver, flush any normal waiting
     1767*requests from the wait list, but leave all priority requests */
     1768 
     1769 	wlp = iodc_static.wait_list_ptr;
     1770 	qgte.last_read (*) = ""b;			/* next time read the first message */
     1771 
     1772 	do dcx = qgte.first_dev_class to qgte.last_dev_class;
     1773 	     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
     1774 	     do q = 1 to 4;				/* look at all possible queues */
     1775 		nx = dcte.first_waiting (q);		/* get first waiting list index for this queue */
     1776 		if nx ^= 0
     1777 		then do;				/* do we need to check? */
     1778 			lwx, fwx = 0;		/* get ready to re-thread the list */
     1779 			do x = nx repeat nx while (nx ^= 0);
     1780 			     nx = wlp -> waiting_list.next (x);
     1781 						/* advance the forward thread */
     1782 			     if wlp -> waiting_list.state (x) = priority
     1783 			     then do;
     1784 				     if fwx = 0
     1785 				     then fwx = x;
     1786 				     else wlp -> waiting_list.next (lwx) = x;
     1787 						/* add to tail of list */
     1788 				     lwx = x;	/* advance the tail marker */
     1789 				     wlp -> waiting_list.next (x) = 0;
     1790 						/* mark this as the end */
     1791 				end;
     1792 			     else do;		/* this is a normal entry, drop it */
     1793 				     if x = wlp -> waiting_list.last_used
     1794 				     then do;	/* drop the high water mark */
     1795 					     wlp -> waiting_list.next (x) = 0;
     1796 					     wlp -> waiting_list.last_used = wlp -> waiting_list.last_used - 1;
     1797 					end;
     1798 				     else do;	/* add to the free list */
     1799 					     wlp -> waiting_list.next (x) = wlp -> waiting_list.first_free;
     1800 					     wlp -> waiting_list.first_free = x;
     1801 					end;
     1802 				     wlp -> waiting_list.state (x) = 0;
     1803 						/* clear any garbage */
     1804 				     wlp -> waiting_list.ms_id (x) = ""b;
     1805 				     wlp -> waiting_list.orig_q (x) = 0;
     1806 				     dcte.n_waiting = dcte.n_waiting - 1;
     1807 						/* reduce the count */
     1808 				end;
     1809 			end;
     1810 			dcte.first_waiting (q) = fwx;
     1811 			dcte.last_waiting (q) = lwx;
     1812 		     end;
     1813 	     end;
     1814 	end;
     1815 
     1816 	call driver_ack (0, 0);
     1817 	go to iodc_return;
     1818 
     1819 
     1820 next_request:					/* 
     1821*   Here a driver has requested the coord to make a certain request high priority.
     1822*   This is done by searching the driver's queues for a request which matches given parameters.
     1823*   Then the message_id and queue number data are threaded into the drivers queue 1 waiting
     1824*   list, behind any other priority requests */
     1825 
     1826 	if iodd_comm.queue_no = 0
     1827 	then do;					/* do we look in each possible queue? */
     1828 		start = 1;
     1829 		finish = qgte.max_queues;
     1830 	     end;
     1831 	else start, finish = iodd_comm.queue_no;	/* just look in the given queue */
     1832 
     1833 	if start < 1 | finish > qgte.max_queues
     1834 	then do;					/* bad to start with */
     1835 		code = error_table_$action_not_performed;
     1836 		go to bad_req;
     1837 	     end;
     1838 
     1839 	user_id = iodd_comm.user_id;
     1840 	string (option) = iodd_comm.type_ext;
     1841 
     1842 	if option.et
     1843 	then do;					/* use this as precedence */
     1844 		option.pn = ""b;			/* in case both were set */
     1845 		match_dir = "";
     1846 		match_ent = iodd_comm.data;		/* get the entry name we will look for */
     1847 	     end;
     1848 	else if option.pn
     1849 	then do;
     1850 		call expand_pathname_ (iodd_comm.data, match_dir, match_ent, code);
     1851 		if code ^= 0
     1852 		then go to bad_req;
     1853 	     end;
     1854 	else do;
     1855 		match_dir, match_ent = "";		/* clear the names */
     1856 		if ^option.id
     1857 		then do;
     1858 			code = error_table_$action_not_performed;
     1859 			go to bad_req;
     1860 		     end;
     1861 	     end;
     1862 
     1863 /*	now look for a request matching user, segment and/or request_id */
     1864 
     1865 	code = 0;					/* clear, then watch for aim errors */
     1866 
     1867 	do q = start to finish;
     1868 	     q_idx = qgte.mseg_index (q);		/* get the message segment index for reading */
     1869 	     ms_id = ""b;				/* start at the begining of the queue */
     1870 
     1871 	     retry = 0;
     1872 retry1:
     1873 	     unspec (msg_mmi) = ""b;
     1874 	     msg_mmi.version = MSEG_MESSAGE_INFO_V1;
     1875 	     msg_mmi.message_code = MSEG_READ_FIRST;
     1876 	     call message_segment_$read_message_index (q_idx, areap, addr (msg_mmi), code2);
     1877 	     if code2 ^= 0
     1878 	     then /* normal test should be cheap */
     1879 		if code2 = error_table_$bad_segment	/* message seg was salvaged */
     1880 		then if retry = 0
     1881 		     then do;			/* try once more */
     1882 			     retry = 1;
     1883 			     go to retry1;
     1884 			end;
     1885 
     1886 	     do while (code2 = 0);
     1887 		ms_id = msg_mmi.ms_id;		/* record the last message read */
     1888 		reqp = msg_mmi.ms_ptr;		/* get pointer to request */
     1889 
     1890 		sender_id = msg_mmi.sender_id;	/* see who put it there */
     1891 		len = length (rtrim (sender_id));	/* get its size */
     1892 		sender_id = substr (sender_id, 1, len - 2);
     1893 						/* strip off the tag */
     1894 
     1895 		if sender_id ^= user_id
     1896 		then go to next_msg;		/* user didn't match, skip the request */
     1897 
     1898 
     1899 		if option.et
     1900 		then if match_ent ^= reqp -> queue_msg_hdr.ename
     1901 		     then go to next_msg;
     1902 
     1903 		if option.pn
     1904 		then do;
     1905 			if match_ent ^= reqp -> queue_msg_hdr.ename
     1906 			then go to next_msg;
     1907 			if match_dir ^= reqp -> queue_msg_hdr.dirname
     1908 			then go to next_msg;
     1909 		     end;
     1910 
     1911 		if option.id
     1912 		then if ^match_request_id_ (reqp -> queue_msg_hdr.msg_time, iodd_comm.req_id)
     1913 		     then go to next_msg;
     1914 
     1915 /*	We have a matching request, see if the driver can run it */
     1916 
     1917 		auth = msg_mmi.sender_authorization;
     1918 
     1919 		if ^aim_check_$greater_or_equal (auth, dcte.min_access)
     1920 		then /* below minimum? */
     1921 		     code = error_table_$ai_restricted;
     1922 		else if aim_check_$greater_or_equal (dcte.max_access, auth)
     1923 		then do;				/* not above max */
     1924 			reqp -> queue_msg_hdr.state = STATE_ELIGIBLE;
     1925 			retry = 0;
     1926 retry3:
     1927 			call message_segment_$update_message_index (q_idx, msg_mmi.ms_len, ms_id, reqp, code2);
     1928 			if code2 ^= 0
     1929 			then do;			/* normal test should be cheap */
     1930 				if code2 = error_table_$bad_segment
     1931 						/* message seg was salvaged */
     1932 				then if retry = 0
     1933 				     then do;	/* try once more */
     1934 					     retry = 1;
     1935 					     go to retry3;
     1936 					end;
     1937 
     1938 				go to next_msg;
     1939 			     end;
     1940 			go to found_next_request;	/* OK, put it into the waiting list */
     1941 		     end;
     1942 		else code = error_table_$ai_above_allowed_max;
     1943 
     1944 /*		if driver can't see the request, pretend we didn't see it either */
     1945 
     1946 next_msg:
     1947 		free reqp -> queue_msg_hdr in (sys_area);
     1948 						/* free the old request */
     1949 		retry = 0;
     1950 retry2:
     1951 		unspec (msg_mmi) = ""b;
     1952 		msg_mmi.version = MSEG_MESSAGE_INFO_V1;
     1953 		msg_mmi.ms_id = ms_id;
     1954 		msg_mmi.message_code = MSEG_READ_AFTER_SPECIFIED;
     1955 		call message_segment_$read_message_index (q_idx, areap, addr (msg_mmi), code2);
     1956 		if code2 ^= 0
     1957 		then /* normal test should be cheap */
     1958 		     if code2 = error_table_$bad_segment/* message seg was salvaged */
     1959 		     then if retry = 0
     1960 			then do;			/* try once more */
     1961 				retry = 1;
     1962 				go to retry2;
     1963 			     end;
     1964 	     end;
     1965 	end;
     1966 
     1967 /* No matching request was found or it was out of aim range */
     1968 
     1969 	if code = 0
     1970 	then code = error_table_$noentry;
     1971 	go to bad_req;
     1972 
     1973 found_next_request:
     1974 	free reqp -> queue_msg_hdr in (sys_area);	/* we are done with the text for now */
     1975 
     1976 /* 	thread the request info into the waiting list */
     1977 
     1978 	wlp = iodc_static.wait_list_ptr;
     1979 
     1980 	if wlp -> waiting_list.first_free > 0
     1981 	then do;
     1982 		new_idx = wlp -> waiting_list.first_free;
     1983 						/* pick off a free entry */
     1984 		wlp -> waiting_list.first_free = wlp -> waiting_list.next (new_idx);
     1985 						/* move the list back */
     1986 	     end;
     1987 	else do;					/* list is full, extend it */
     1988 		if wlp -> waiting_list.last_used = max_wl_size
     1989 		then do;
     1990 			call iodc_message_ ("101"b, 0, "Waiting_list full.");
     1991 			code = error_table_$action_not_performed;
     1992 			go to bad_req;
     1993 		     end;
     1994 		new_idx = wlp -> waiting_list.last_used + 1;
     1995 						/* allocate the next entry */
     1996 		wlp -> waiting_list.last_used = new_idx;/* record the usage */
     1997 	     end;
     1998 
     1999 	wlp -> waiting_list.next (new_idx) = 0;		/* fill in the new entry */
     2000 	wlp -> waiting_list.state (new_idx) = priority;
     2001 	wlp -> waiting_list.ms_id (new_idx) = ms_id;
     2002 	wlp -> waiting_list.orig_q (new_idx) = q;
     2003 
     2004 	nx = dcte.first_waiting (1);			/* find queue 1 waiting list */
     2005 	if nx > 0
     2006 	then do;					/* is there a real list? */
     2007 		lwx = 0;				/* last good entry not found yet */
     2008 		do x = nx repeat nx while (nx ^= 0);
     2009 		     nx = wlp -> waiting_list.next (x); /* offset of next in the chain */
     2010 		     if wlp -> waiting_list.state (x) ^= priority
     2011 		     then do;			/* found last of the priority entries */
     2012 			     nx = 0;		/* stop the loop */
     2013 			     wlp -> waiting_list.next (new_idx) = x;
     2014 						/* put new one in front */
     2015 			     if lwx = 0
     2016 			     then dcte.first_waiting (1) = new_idx;
     2017 						/* if this was the first one */
     2018 			     else wlp -> waiting_list.next (lwx) = new_idx;
     2019 						/* link the last one to the new one */
     2020 			end;
     2021 		     else if nx = 0
     2022 		     then do;			/* last entry was also priority */
     2023 			     wlp -> waiting_list.next (x) = new_idx;
     2024 						/* put this on the end */
     2025 			     dcte.last_waiting (1) = new_idx;
     2026 						/* update the last pointer for chaining to end */
     2027 			end;
     2028 		     lwx = x;			/* save the last index of skipped request */
     2029 		end;
     2030 	     end;
     2031 	else dcte.first_waiting (1), dcte.last_waiting (1) = new_idx;
     2032 						/* no list, so start one */
     2033 
     2034 	dcte.n_waiting = dcte.n_waiting + 1;
     2035 
     2036 	call driver_ack (0, 0);			/* tell driver we found it */
     2037 	go to iodc_return;
     2038 
     2039 
     2040 proc_dies:					/* Come here for new process after disaster */
     2041 	call ioa_$rsnnl ("^a^/New coordinator process will be created. All device drivers will be reinitialized.",
     2042 	     out_msg, out_len, out_msg);
     2043 	call iodc_message_$loud ("001"b, code, out_msg);
     2044 
     2045 /* put machine conditions if any in log */
     2046 
     2047 	if scu_msg ^= ""
     2048 	then call iodc_message_ ("100"b, code, scu_msg);
     2049 	call new_proc;
     2050 
     2051 
     2052 quit_handler:
     2053      proc;
     2054 
     2055 /* Entered when coordinator receives QUIT.
     2056**/
     2057 
     2058 	dcl     mask_code		 fixed bin (35);
     2059 
     2060 	if quit_flag
     2061 	then if ^testing
     2062 	     then do;				/* don't stack quits */
     2063 		     call com_err_ (0, "io_coordinator", "QUIT already pending.");
     2064 		     return;
     2065 		end;
     2066 
     2067 	mask_code = -1;
     2068 	on cleanup
     2069 	     begin;
     2070 		if mask_code = 0
     2071 		then call ipc_$unmask_ev_calls (code2);
     2072 	     end;
     2073 	call ipc_$mask_ev_calls (mask_code);
     2074 
     2075 	quit_flag = "1"b;
     2076 	call ioa_ ("QUIT received.");
     2077 	call iox_$control (iox_$user_input, "resetread", null (), code);
     2078 
     2079 	call iodc_$command_level;
     2080 
     2081 	quit_flag = "0"b;
     2082 	call ipc_$unmask_ev_calls (code2);
     2083 	call iox_$control (iox_$user_io, "start", null, code);
     2084 	return;
     2085 
     2086      end quit_handler;
     2087 
     2088 
     2089 command_level:
     2090      entry;
     2091 
     2092 /* This is the IO Coordinator command processor.  It is
     2093*   called by the quit handler and also by the unclaimed
     2094*   signal handler when in test mode.
     2095**/
     2096 
     2097 	com_level = com_level + 1;
     2098 	mask_code = -1;
     2099 
     2100 	on cleanup
     2101 	     begin;
     2102 		com_level = com_level - 1;
     2103 		if mask_code = 0
     2104 		then call ipc_$unmask_ev_calls (code2);
     2105 	     end;
     2106 
     2107 	if com_level > 0
     2108 	then /* don't ask for a command just after initialization */
     2109 ask:
     2110 	     call ioa_ ("Enter command.^[ (level ^d)^;^s^]", (com_level > 1), com_level);
     2111 
     2112 	if mask_code = 0
     2113 	then do;
     2114 		call ipc_$unmask_ev_calls (code2);
     2115 		mask_code = -1;
     2116 	     end;
     2117 
     2118 	line = "";
     2119 	call iox_$get_line (iox_$user_input, addr (line), length (line), nc, code);
     2120 	line = ltrim (rtrim (line, NL || " "));		/* trim spaces and NL chars */
     2121 	cmd = before (line, " ");			/* command is the first part */
     2122 	if cmd = "" | cmd = "."
     2123 	then go to ask;
     2124 
     2125 	call ipc_$mask_ev_calls (mask_code);
     2126 
     2127 	if cmd = "help"
     2128 	then do;					/* HELP COMMAND */
     2129 		call ioa_ ("list, logout, print_devices, restart_status, start, term, wait_status");
     2130 		if testing
     2131 		then call ioa_ ("**Test: debug, probe, driver, pi, return");
     2132 		go to ask;
     2133 	     end;
     2134 
     2135 	if cmd = "start"				/* START COMMAND */
     2136 	then if com_level > 0
     2137 	     then do;
     2138 		     com_level = com_level - 1;
     2139 		     if mask_code = 0
     2140 		     then call ipc_$unmask_ev_calls (code2);
     2141 		     return;
     2142 		end;
     2143 	     else do;
     2144 		     call com_err_ (0, "io_coordinator", "Coordinator already started.");
     2145 		     go to ask;
     2146 		end;
     2147 
     2148 	if cmd = "return"
     2149 	then /* RETURN COMMAND */
     2150 	     if testing
     2151 	     then go to return_label;
     2152 	     else go to bad_cmd;
     2153 
     2154 	if cmd = "debug"				/* DEBUG COMMAND */
     2155 	then if testing
     2156 	     then do;
     2157 		     call debug;
     2158 		     go to ask;
     2159 		end;
     2160 
     2161 	if cmd = "probe" | cmd = "pb"			/* PROBE COMMAND */
     2162 	then if testing
     2163 	     then do;
     2164 		     call probe;
     2165 		     go to ask;
     2166 		end;
     2167 
     2168 	if cmd = "pi"				/* PI COMMAND */
     2169 	then if testing
     2170 	     then do;
     2171 		     call signal_ ("program_interrupt");
     2172 		     go to ask;
     2173 		end;
     2174 
     2175 	if cmd = "logout"				/* LOGOUT COMMAND */
     2176 	then if testing
     2177 	     then go to return_label;
     2178 	     else call logout;
     2179 
     2180 	if ^initialized
     2181 	then go to bad_cmd;				/* other commands only valid after initialization */
     2182 
     2183 	if cmd = "print_devices"
     2184 	then do;					/* PRINT_DEVICES COMMAND */
     2185 		call print_devices ("-dir", sysdir);
     2186 		go to ask;
     2187 	     end;
     2188 
     2189 	if cmd = "list"
     2190 	then do;					/* LIST COMMAND */
     2191 		i = 0;
     2192 		do idtx = 1 to static_idtp -> iod_device_tab.n_devices;
     2193 		     idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
     2194 		     if idte.process_id ^= ""b
     2195 		     then do mdtx = idte.first_minor to idte.last_minor;
     2196 			     mdtep = addr (static_mdtp -> minor_device_tab.entries (mdtx));
     2197 			     if mdte.active = 1
     2198 			     then do;
     2199 				     dctep =
     2200 					addr (iodc_static.dctp -> dev_class_tab.entries (mdte.dev_class_index));
     2201 				     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
     2202 				     sender_device = get_device_name ();
     2203 				     sender_class = get_class_name ();
     2204 				     call ioa_ ("device ^a is active, request type ^a, request ^d", sender_device,
     2205 					sender_class, mdte.seq_id);
     2206 				     i = i + 1;
     2207 				end;
     2208 			end;
     2209 		end;
     2210 		if i = 0
     2211 		then call ioa_ ("No active devices");
     2212 		go to ask;
     2213 	     end;
     2214 
     2215 	if cmd = "restart_status"			/* RESTART_STATUS COMMAND */
     2216 	then do;
     2217 		nseries = divide (new_driver_series, 10000, 35, 0);
     2218 		if nseries = 0
     2219 		then go to no_restartable;
     2220 
     2221 		allocate series_info in (sys_area);
     2222 		series_info (*).count = 0;
     2223 
     2224 		desc_off = iodc_static.first_req_done;
     2225 		do while (desc_off ^= 0);		/* scan the saved list */
     2226 		     desc_ptr = ptr (iodc_static.descr_seg_ptr, desc_off);
     2227 		     series_id = divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0);
     2228 
     2229 		     if series_info (series_id).count = 0
     2230 		     then do;			/* first request of this series */
     2231 			     series_info (series_id).first = desc_ptr -> request_descriptor.seq_id;
     2232 			     series_info (series_id).dcx = desc_ptr -> request_descriptor.dev_class_index;
     2233 			end;
     2234 		     series_info (series_id).last = desc_ptr -> request_descriptor.seq_id;
     2235 		     series_info (series_id).count = series_info (series_id).count + 1;
     2236 
     2237 		     desc_off = desc_ptr -> request_descriptor.next_done;
     2238 		end;
     2239 
     2240 		i = 0;
     2241 		do series_id = 1 to nseries;		/* now let's see what we found */
     2242 		     if series_info (series_id).count > 0
     2243 		     then do;
     2244 			     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (series_info (series_id).dcx));
     2245 			     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
     2246 			     sender_class = get_class_name ();
     2247 						/* get type/class name for series */
     2248 
     2249 			     call ioa_ ("^d restartable request(s) from ^d to ^d (^a)",
     2250 				series_info (series_id).count, series_info (series_id).first,
     2251 				series_info (series_id).last, sender_class);
     2252 
     2253 			     if dcte.restart_req ^= 0
     2254 			     then do;		/* restart in progress for device class */
     2255 				     desc_ptr = ptr (iodc_static.descr_seg_ptr, dcte.restart_req);
     2256 				     if divide (desc_ptr -> request_descriptor.seq_id, 10000, 35, 0) = series_id
     2257 				     then call ioa_ ("   restart in progress at request ^d",
     2258 					     desc_ptr -> request_descriptor.seq_id);
     2259 				end;
     2260 
     2261 			     i = i + 1;		/* count number of series */
     2262 			end;
     2263 		end;
     2264 
     2265 		free series_info in (sys_area);
     2266 
     2267 		if i = 0
     2268 		then
     2269 no_restartable:
     2270 		     call ioa_ ("No restartable requests.");
     2271 
     2272 		go to ask;
     2273 	     end;
     2274 
     2275 	if cmd = "wait_status" | /* WAIT_STATUS COMMAND */ cmd = "defer_status"
     2276 	then do;					/* old command name */
     2277 		i = 0;
     2278 		do q = 1 to iodc_static.qgtp -> q_group_tab.n_q_groups;
     2279 		     qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (q));
     2280 		     if qgte.open = 1
     2281 		     then do dcx = qgte.first_dev_class to qgte.last_dev_class;
     2282 			     dctep = addr (iodc_static.dctp -> dev_class_tab.entries (dcx));
     2283 			     if dcte.n_waiting ^= 0
     2284 			     then do;
     2285 				     sender_class = get_class_name ();
     2286 				     call ioa_ ("^d request(s) waiting for device class ^a", dcte.n_waiting,
     2287 					sender_class);
     2288 				     i = i + 1;
     2289 				end;
     2290 			end;
     2291 		end;
     2292 		if i = 0
     2293 		then call ioa_ ("No waiting requests");
     2294 		go to ask;
     2295 	     end;
     2296 
     2297 	if cmd = "term"				/* TERM COMMAND */
     2298 	then if com_level > 0
     2299 	     then go to not_after_quit;
     2300 	     else do;
     2301 
     2302 /* operator asked to terminate driver */
     2303 
     2304 		     dev_id = ltrim (substr (line, 5));
     2305 		     if dev_id = ""
     2306 		     then do;
     2307 			     call ioa_ ("Name of major device missing: term <devid>");
     2308 			     go to ask;
     2309 			end;
     2310 
     2311 		     do idtx = 1 to static_idtp -> iod_device_tab.n_devices;
     2312 			idtep = addr (static_idtp -> iod_device_tab.entries (idtx));
     2313 			if idte.dev_id = dev_id
     2314 			then do;
     2315 				call iodc_$free_device (idtep, code);
     2316 				go to ask;
     2317 			     end;
     2318 		     end;
     2319 		     call com_err_ (0, "io_coordinator", "Unrecognized device name: ^a", dev_id);
     2320 
     2321 		     go to ask;
     2322 		end;
     2323 
     2324 	if cmd = "driver"
     2325 	then /* DRIVER COMMAND */
     2326 	     if testing
     2327 	     then if com_level > 0
     2328 		then go to not_after_quit;
     2329 		else do;
     2330 			if mask_code = 0
     2331 			then do;
     2332 				call ipc_$unmask_ev_calls (code2);
     2333 				mask_code = -1;
     2334 			     end;
     2335 			call iodd_$iodd_init (sysdir, "1"b);
     2336 			go to ask;
     2337 		     end;
     2338 
     2339 bad_cmd:
     2340 	call com_err_ (0, "io_coordinator", "Invalid response -- ^a", line);
     2341 	go to ask;
     2342 
     2343 
     2344 not_after_quit:
     2345 	if testing
     2346 	then call com_err_ (0, id, "Specified command can only be used at command level 0:  ^a", cmd);
     2347 	else call com_err_ (0, id, "Specified command cannot be used after a QUIT:  ^a", cmd);
     2348 
     2349 	go to ask;
     2350 
     2351 
     2352 area_handler:
     2353      proc;
     2354 
     2355 /* Handler for area condition when allocating a descriptor.
     2356*   *  If it happens once, free a descriptor and try again. If
     2357*   *  it still fails, area is screwed up, and we're in trouble.
     2358**/
     2359 
     2360 	if area_flag ^= 0
     2361 	then do;
     2362 		out_msg = "Multiple area condition in request descriptor segment.";
     2363 		go to proc_dies;			/* blow */
     2364 	     end;
     2365 
     2366 	area_flag = 1;				/* watch for recursion */
     2367 	call free_oldest_request_$force;		/* do our best to get some space */
     2368 	return;
     2369 
     2370      end;
     2371 
     2372 
     2373 check_wakeup_code:
     2374      proc (wcode);
     2375 
     2376 /* Another little internal procedure, this one to check the return code from hcs_$wakeup */
     2377 
     2378 	dcl     wcode		 fixed bin (35);
     2379 	dcl     wp		 ptr;
     2380 	dcl     code		 fixed bin (35);
     2381 
     2382 	dcl     1 two		 based aligned,
     2383 		2 word1		 fixed bin,
     2384 		2 word2		 fixed bin;
     2385 
     2386 
     2387 	if wcode = 2
     2388 	then call ioa_$rsnnl ("Invalid arguments to hcs_$wakeup.", out_msg, out_len);
     2389 
     2390 	else if wcode = 1 | wcode = 3
     2391 	then do;
     2392 		call ioa_$rsnnl ("Driver for device ^a is gone.", out_msg, out_len, idte.dev_id);
     2393 		call iodc_$free_device (idtep, code);	/* driver is gone, free device */
     2394 	     end;
     2395 
     2396 	else do;
     2397 		wp = addr (dr_ptr -> driver_status.driver_chan);
     2398 		call ioa_$rsnnl ("^w ^w", out_msg, out_len, wp -> two.word1, wp -> two.word2);
     2399 	     end;
     2400 
     2401 	if wcode < 4
     2402 	then wcode = 0;
     2403 	call iodc_message_$loud ("101"b, wcode, out_msg);
     2404 
     2405 	return;
     2406 
     2407      end;
     2408 
     2409 
     2410 iodc_handler:
     2411      proc;
     2412 
     2413 /* Unclaimed signal handler for I/O Coordinator */
     2414 
     2415 	dcl     conname		 char (32);
     2416 	dcl     ec		 fixed bin (35);
     2417 
     2418 	dcl     ap		 ptr;
     2419 	dcl     mp		 ptr;
     2420 
     2421 	dcl     m_len		 fixed bin;
     2422 
     2423 	dcl     cond_mess		 char (m_len) based (mp);
     2424 
     2425 	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
     2426 	dcl     continue_to_signal_	 entry (fixed bin (35));
     2427 	dcl     condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char (*), ptr, ptr);
     2428 	dcl     ioa_$ioa_stream_nnl	 entry options (variable);
     2429 
     2430 	dcl     w			 (8) fixed bin based (scup);
     2431 						/* for storing scu data on recursion */
     2432 
     2433 	dcl     1 local_condition_info aligned like condition_info;
     2434 
     2435 	local_condition_info.version = condition_info_version_1;
     2436 						/* version of condition_info structure */
     2437 	call find_condition_info_ (null, addr (local_condition_info), ec);
     2438 	conname = local_condition_info.condition_name;
     2439 
     2440 	if conname = "command_question"
     2441 	then return;
     2442 	if conname = "command_error"
     2443 	then return;
     2444 
     2445 	if conname = "cput"
     2446 	then do;
     2447 pass_on:
     2448 		call continue_to_signal_ (ec);
     2449 		return;
     2450 	     end;
     2451 	if conname = "alrm"
     2452 	then go to pass_on;
     2453 	if conname = "finish"
     2454 	then go to pass_on;
     2455 	if testing
     2456 	then if conname = "program_interrupt"
     2457 	     then go to pass_on;
     2458 	     else if conname = "mme2"
     2459 	     then go to pass_on;
     2460 
     2461 	call get_system_free_area_ (ap);
     2462 	call condition_interpreter_ (ap, mp, m_len, 3, local_condition_info.mc_ptr, conname,
     2463 	     local_condition_info.wc_ptr, local_condition_info.info_ptr);
     2464 
     2465 /* now we've got message to send to err_output and log */
     2466 
     2467 	if m_len > 0
     2468 	then do;
     2469 		call ioa_$ioa_stream_nnl ("error_output", "io_coordinator: ");
     2470 		call iodc_message_ ("101"b, 0, cond_mess);
     2471 	     end;
     2472 
     2473 	if testing
     2474 	then do;
     2475 		call iodc_$command_level;		/* give tester a chance to do something */
     2476 		return;
     2477 	     end;
     2478 
     2479 
     2480 	if recursion_flag ^= 0
     2481 	then do;					/* Bad news indeed */
     2482 		call ioa_$rsnnl ("Condition ^a signalled while handling unclaimed signal.", out_msg, out_len, conname)
     2483 		     ;
     2484 
     2485 /* try to save scu data so we can check what happened some day */
     2486 
     2487 		if local_condition_info.mc_ptr ^= null
     2488 		then do;
     2489 			scup = addr (local_condition_info.mc_ptr -> mc.scu);
     2490 			code = local_condition_info.mc_ptr -> mc.errcode;
     2491 			call ioa_$rsnnl ("^/scu: ^w ^w ^w ^w^/^5x^w ^w ^w ^w", scu_msg, out_len, w (1), w (2),
     2492 			     w (3), w (4), w (5), w (6), w (7), w (8));
     2493 		     end;
     2494 
     2495 		else do;
     2496 			code = 0;
     2497 			scu_msg = "";
     2498 		     end;
     2499 
     2500 		go to proc_dies;
     2501 	     end;
     2502 
     2503 	recursion_flag = 1;
     2504 	go to err_label;
     2505 
     2506      end;
     2507 
  1     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  1     2 
  1     3 /* Structure for find_condition_info_.
  1     4*
  1     5*   Written 1-Mar-79 by M. N. Davidoff.
  1     6**/
  1     7 
  1     8 /* automatic */
  1     9 
  1    10      declare condition_info_ptr     pointer;
  1    11 
  1    12 /* based */
  1    13 
  1    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  1    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 condition_name     char (32) varying,	/* name of condition */
  1    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  1    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  1    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  1    21 	     2 flags	      unaligned,
  1    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  1    23 	       3 pad1	      bit (35),
  1    24 	     2 pad2	      bit (36),
  1    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  1    26 	     2 pad3	      (4) bit (36);
  1    27 
  1    28 /* internal static */
  1    29 
  1    30      declare condition_info_version_1
  1    31 			      fixed binary internal static options (constant) initial (1);
  1    32 
  1    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
     2508 
     2509 
  2     1 /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  2     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  2     7*       1. Declare version constant properly.
  2     8*       2. Remove version 1 since it was never referenced and to force
  2     9*          callers to upgrade their programs.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  2    14 
  2    15 /* this include files gives the argument structure for create_branch_ */
  2    16 
  2    17 dcl 1 create_branch_info aligned based,
  2    18     2 version fixed bin,				/* set this to the largest value given below */
  2    19     2 switches unaligned,
  2    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  2    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  2    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  2    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  2    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  2    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  2    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  2    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  2    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  2    29     2 userid char (32),				/* user's access control name */
  2    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  2    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  2    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  2    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  2    34 
  2    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  2    36 
  2    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  2    38 
     2510 
     2511 
  3     1 /* BEGIN INCLUDE FILE...device_class.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  3     7*     Ancient History
  3     8*     Coded by R.S.Coren August 1973
  3     9*     Modified by J. Stern, 1/8/75
  3    10*     Modified by J. C. Whitmore, 5/78, to extent the size of the device list
  3    11*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  3    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  3    13*     Added comment field in dcte.
  3    14*                                                   END HISTORY COMMENTS */
  3    15 
  3    16 
  3    17 /* format: style4 */
  3    18 
  3    19 dcl  dctp ptr;					/* ptr to device class table */
  3    20 dcl  1 dev_class_tab aligned based (dctp),		/* the device class table */
  3    21        2 n_classes fixed bin,				/* number of device classes */
  3    22        2 pad fixed bin,
  3    23        2 entries (1 refer (dev_class_tab.n_classes)) like dcte;
  3    24 
  3    25 dcl  dctep ptr;					/* device class table entry ptr */
  3    26 
  3    27 dcl  1 dcte aligned based (dctep),			/* device class table entry */
  3    28 
  3    29 /* following items are initialized before daemon is run */
  3    30 
  3    31        2 id char (32),				/* device class name for this entry */
  3    32        2 comment unaligned like text_offset,		/* comment to apply to the device class */
  3    33        2 qgte_index fixed bin,			/* index of queue group table entry */
  3    34        2 pad1 fixed bin,
  3    35        2 max_access bit (72),				/* max request access class */
  3    36        2 min_access bit (72),				/* min request access class */
  3    37        2 min_banner bit (72),				/* min access class to be placed on output banner */
  3    38        2 device_list bit (360),			/* bit _i ON => minor device _i is valid for device class */
  3    39 
  3    40 /* remaining info is dynamic */
  3    41 
  3    42        2 pending_request fixed bin (18),		/* descriptor offset for allocated but unassigned request */
  3    43        2 restart_req fixed bin (18),			/* offset of next (or last) descriptor to be restarted */
  3    44        2 pad2 (3) fixed bin,
  3    45        2 n_waiting fixed bin,				/* number of waiting requests for device class */
  3    46        2 per_queue_info (4),				/* one copy of this for each queue */
  3    47          3 first_waiting fixed bin,			/* index of first waiting list entry */
  3    48          3 last_waiting fixed bin;			/* index of last waiting list entry */
  3    49 
  3    50 
  3    51 /* END INCLUDE FILE...device_class.incl.pl1 */
     2512 
     2513 
  4     1 /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  4     7*     Ancient History
  4     8*     Coded by Robert S. Coren August 1973
  4     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  4    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  4    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  4    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  4    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  4    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  4    16*     to denote accounting ^= nothing.
  4    17*                                                   END HISTORY COMMENTS */
  4    18 
  4    19 
  4    20 /* status data for a logical device driver */
  4    21 
  4    22 /* format: style4 */
  4    23 
  4    24 dcl  driver_status_ptr ptr;
  4    25 dcl  1 driver_status aligned based (driver_status_ptr),
  4    26        2 req_type_label char (32),			/* string to describe the request type */
  4    27        2 dev_name_label char (32),			/* string to describe the device */
  4    28        2 device_id char (32),				/* minor device name used by this logical driver */
  4    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  4    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  4    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  4    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  4    33        2 request_pending bit (36),			/* locking word for communication with coord */
  4    34 						/* 0 = ready for a request  */
  4    35 						/* driver pid = don't bug me */
  4    36 						/* coord  pid = got a request */
  4    37        2 status_flags,
  4    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  4    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  4    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  4    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  4    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  4    43          3 pad bit (31) unal,
  4    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  4    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  4    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  4    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  4    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  4    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  4    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  4    51 						/* for this logical driver */
  4    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  4    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  4    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  4    55        2 dev_out_stream char (32),			/* output stream for minor device */
  4    56        2 dev_in_stream char (32),			/* input stream for minor device */
  4    57        2 elem_size fixed bin,				/* element size for the stream */
  4    58        2 message_type fixed bin,			/* expected format of user request */
  4    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  4    60        2 forms_validation_ptr ptr,			/* forms validation data */
  4    61        2 dev_ptr1 ptr,				/* another one */
  4    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  4    63        2 dev_fb2 fixed bin,				/* and another */
  4    64        2 dev_fb3 fixed bin,				/* and another */
  4    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  4    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  4    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  4    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  4    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  4    70        2 generic_type char (32),			/* generic type of this minor device */
  4    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  4    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  4    73        2 desc_pad (13) fixed bin,
  4    74        2 message fixed bin;				/* place-holder for copy of request message */
  4    75 
  4    76 
  4    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
     2514 
     2515 
  5     1 /* BEGIN INCLUDE FILE...iod_device_tab.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Created by J. Stern, January 1975
  5     9*     Modified by J. C. Whitmore April 1978
  5    10*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  5    11*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    12*     Added comment, head_sheet, tail_sheet, paper_type, forms_table,
  5    13*     forms_validation, font_dir variables to device entries in support of laser
  5    14*     printers.  Changed driver_module, args to text_offset instead of strings.
  5    15*     Added comment, default_form  to minor device entries.  Changed args in
  5    16*     minor device entry to text_offset instead of string.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 /* format: style4 */
  5    21 
  5    22 dcl  idtp ptr;					/* ptr to device table */
  5    23 dcl  1 iod_device_tab aligned based (idtp),		/* IO daemon device table */
  5    24        2 n_devices fixed bin,				/* number of major devices */
  5    25        2 pad fixed bin,
  5    26        2 entries (1 refer (iod_device_tab.n_devices)) like idte; /* entries for major devices */
  5    27 
  5    28 dcl  idtep ptr;					/* major device entry pointer */
  5    29 dcl  1 idte aligned based (idtep),			/* major device entry */
  5    30 
  5    31 /* static info associated with device from the parms file */
  5    32 
  5    33        2 dev_id char (24),				/* major device name */
  5    34        2 comment unaligned like text_offset,		/* comment to apply to the major device */
  5    35        2 attach_name char (32),			/* channel name or dial id for device attachment */
  5    36        2 attach_type fixed bin,			/* indicates meaning of attach_name */
  5    37 						/* see ATTACH_TYPE_XX in iod_constants.incl.pl1 */
  5    38        2 ctl_attach_name char (32),			/* channel, dial id, or source for control terminal attachment */
  5    39        2 ctl_attach_type fixed bin,			/* indicates meaning of ctl_attach_name */
  5    40 						/* see CTL_ATTACH_TYPE_XX in iod_constants.incl.pl1 */
  5    41        2 driver_module unaligned like text_offset,	/* offset to pathname of program to drive device */
  5    42        2 head_sheet unaligned like text_offset,		/* offset to name of head_sheet program to use */
  5    43        2 tail_sheet unaligned like text_offset,		/* offset to name of tail_sheet program to use */
  5    44        2 paper_type fixed bin,			/* -1=default , 1=continuous form, 2=single sheet */
  5    45        2 forms_table unaligned like text_offset,		/* offset to forms table to apply to this queue group */
  5    46        2 forms_validation unaligned like text_offset,	/* offset to name of routine for forms validation */
  5    47        2 font_dir unaligned like text_offset,		/* offset to location of downloadable fonts */
  5    48        2 args unaligned like text_offset,		/* offset to arguments to driver program */
  5    49        2 first_minor fixed bin,			/* index of first minor device for this major device */
  5    50        2 last_minor fixed bin,			/* index of last minor device for this major device */
  5    51 
  5    52 /* dynamic info associated with driver of this device */
  5    53 
  5    54        2 lock bit (36),				/* lock id of current driver */
  5    55        2 process_id bit (36);				/* process id of current driver */
  5    56 
  5    57 dcl  mdtp ptr;
  5    58 dcl  1 minor_device_tab aligned based (mdtp),
  5    59        2 n_minor fixed bin,				/* number of minor devices */
  5    60        2 pad fixed bin,
  5    61        2 entries (1 refer (minor_device_tab.n_minor)) like mdte;
  5    62 
  5    63 dcl  mdtep ptr;					/* minor device entry pointer */
  5    64 dcl  1 mdte aligned based (mdtep),			/* minor device entry */
  5    65 
  5    66 /* static info associated with device from the parms file */
  5    67 
  5    68        2 dev_id char (24),				/* minor device name */
  5    69        2 comment unaligned like text_offset,		/* comment to apply to the minor device */
  5    70        2 default_form unaligned like text_offset,		/* offset to default -form string for minor device */
  5    71        2 default_dev_class fixed bin,			/* default device class index */
  5    72        2 major_index fixed bin,			/* subscript of corresponding major device entry */
  5    73        2 args unaligned like text_offset,		/* offset to arguments to driver program */
  5    74 
  5    75 /* dynamic info associated with driver of this device */
  5    76 
  5    77        2 dev_class_index fixed bin,			/* index of device class table entry */
  5    78        2 current_request fixed bin (18),		/* offset of current request descriptor */
  5    79        2 driver_ptr ptr,				/* ptr to driver status segment */
  5    80        2 active fixed bin,				/* 1 if active, 0 if not active */
  5    81        2 seq_id fixed bin (35);			/* sequence number of last request */
  5    82 
  5    83 /* named constants for attach_type, ctl_attach_type and paper_type are found
  5    84*   in iod_constants.incl.pl1 */
  5    85 
  5    86 /* END INCLUDE FILE...iod_device_tab.incl.pl1 */
     2516 
     2517 
  6     1 /* BEGIN INCLUDE FILE. . . iod_event_message.incl.pl1 */
  6     2 
  6     3 /* Format of event message used to signal io_daemon coordinator */
  6     4 /* and the acknowledge message for signalling the driver */
  6     5 
  6     6 dcl event_message fixed bin(71);
  6     7 
  6     8 dcl 1 ev_msg based aligned,
  6     9 	2 code fixed bin(17) unal,		/* Purpose of wakeup: */
  6    10 					/* 0 = request completed */
  6    11 					/* 1 = request completed, new request wanted */
  6    12 					/* 2 = restart */
  6    13 					/* 3 = save  */
  6    14 					/* 4 = logout */
  6    15 	2 minor_dev_index fixed bin(17) unal,	/* minor device index for driver sending this message */
  6    16 	2 seq_id fixed bin(35);		/* id of request to be restarted/saved */
  6    17 
  6    18 dcl 1 ack_msg aligned based,			/* driver command acknowledgement message */
  6    19 	2 code fixed bin (35),		/* error_table_ code */
  6    20 	2 num fixed bin (35);		/* number for further info */
  6    21 
  6    22 /* END INCLUDE FILE. . . iod_event_message.incl.pl1 */
     2518 
     2519 
  7     1 /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  7     7*     Ancient History
  7     8*     Created by J. Stern, 1/20/75
  7     9*     Modified by J. C. Whitmore April 1978 for enhancements
  7    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  7    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  7    12*     q_group_tab
  7    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  7    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  7    15*     Change version number to reflect changes in q_group_tab and
  7    16*     iod_device_tab for laser printer support.  Added font tables.
  7    17*                                                   END HISTORY COMMENTS */
  7    18 
  7    19 
  7    20 /* format: style4 */
  7    21 
  7    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  7    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  7    24        2 version char (8),				/* version of this structure */
  7    25        2 date_time_compiled fixed bin (71),
  7    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  7    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  7    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  7    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  7    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  7    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  7    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  7    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  7    34        2 text_strings_offset fixed bin (18),
  7    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  7    36 
  7    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  7    38 dcl  text_strings_ptr ptr;
  7    39 dcl  1 text_strings aligned based (text_strings_ptr),
  7    40        2 length fixed bin,
  7    41        2 chars char (1 refer (text_strings.length)) unaligned;
  7    42 
  7    43 /* this defines text offsets used to locate i/o daemon tables strings in
  7    44*   the text_strings structure */
  7    45 dcl  1 text_offset based,
  7    46        2 first_char fixed bin (18) unsigned unaligned,
  7    47        2 total_chars fixed bin (18) unsigned unaligned;
  7    48 
  7    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  7    50 
  7    51 
  7    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
     2520 
     2521 
  8     1 /* BEGIN INCLUDE FILE ... iodc_data.incl.pl1 */
  8     2 
  8     3 dcl 1 iodc_data based(iodc_data_ptr) aligned,
  8     4 	2 init_event_channel fixed bin(71),	/* channel over which first driver wakeup is expected */
  8     5 	2 proc_id bit(36);			/* coordinator's process id */
  8     6 
  8     7 
  8     8 /* END INCLUDE FILE ... iodc_data.incl.pl1 */
     2522 
     2523 
  9     1 /* BEGIN INCLUDE FILE...iodc_static.incl.pl1 */
  9     2 
  9     3 dcl stat_p ptr int static init(null);
  9     4 
  9     5 dcl 1 iodc_static aligned based(stat_p),
  9     6 	2 dctp ptr,		/* pointer to device class table */
  9     7 	2 qgtp ptr,		/* pointer to queue group table */
  9     8 	2 wait_list_ptr ptr,	/* pointer to waiting list segment */
  9     9 	2 req_seg_ptr ptr,		/* pointer to base of request segment */
  9    10 	2 descr_seg_ptr ptr,	/* pointer to base of request descriptor segment */
  9    11 	2 save_first_req_p ptr,	/* pointer to req_desc_seg.first_saved */
  9    12 	2 first_req_done fixed bin(18),	/* offset of first descriptor on "saved" list */
  9    13 	2 last_req_done fixed bin(18),	/* offset of last  descriptor on "saved" list */
  9    14 	2 time_interval fixed bin(71),	/* time interval to elapse between completion */
  9    15 					/* and deletion of request */
  9    16 	2 max_q fixed bin,			/* maximum number of priority queues */
  9    17 	2 timer_chan fixed bin(71);		/* event channel for timer wakeups */
  9    18 
  9    19 dcl req_area area(131096) based(iodc_static.req_seg_ptr);
  9    20 
  9    21 dcl 1 req_desc_seg aligned based (iodc_static.descr_seg_ptr),
  9    22 	2 first_saved fixed bin(18),		/* offset of head of saved list */
  9    23 	2 pad fixed bin,
  9    24 	2 descr_area area (65560);		/* area where request descriptors are allocated */
  9    25 
  9    26 /* END INCLUDE FILE...iodc_static.incl.pl1 */
     2524 
     2525 
 10     1 /* .....  BEGIN INCLUDE FILE  ...  iodc_wait_list.incl.pl1  ..... */
 10     2 
 10     3 dcl 1 waiting_list aligned based,			/* list of waiting requests already read from queues */
 10     4     2 first_free fixed bin,				/* index of first entry of free list */
 10     5     2 last_used fixed bin,				/* high-water mark, i.e. largest index of all used entries */
 10     6     2 pad (2) fixed bin,				/* pad to 4-word boundary */
 10     7     2 entries (max_wl_size),
 10     8       3 ms_id bit (72),				/* message id of waiting request */
 10     9       3 next fixed bin,				/* next free entry or next waiting entry */
 10    10       3 state fixed bin,				/* 0 = free, 1 = normal, 2 = priority */
 10    11       3 orig_q fixed bin,				/* queue a priority request is in */
 10    12       3 pad fixed bin;				/* pad to even-word boundary */
 10    13 
 10    14 dcl  max_wl_size fixed bin int static init (10000);	/* at most 10000 waiting list entries */
 10    15 
 10    16 
 10    17 /* .....  END INCLUDE FILE  ...  iodc_wait_list.incl.pl1  ... */
     2526 
     2527 
 11     1 /* ..... BEGIN INCLUDE FILE  ...  iodd_comm.incl.pl1  ..... */
 11     2 
 11     3 /* structure used by a driver to send a command/request to the coordinator */
 11     4 
 11     5 dcl  comm_ptr ptr;
 11     6 
 11     7 dcl 1 iodd_comm aligned based (comm_ptr),
 11     8      2 ack_chan fixed bin (71),			/* IPC event channel for coord to return status code */
 11     9      2 type fixed bin,				/* command/request type code
 11    10*						   0 = reserved [done & wait (direct - special ev chan)]
 11    11*						   1 = reserved [done & next   (also direct)]
 11    12*						   2 = restart - single or series
 11    13*						   3 = save - single or series
 11    14*						   4 = reserved [driver logout (direct)]
 11    15*						   5 = reserved [get cmd ev chan (direct)]
 11    16*						   6 = next_req - run a given request next
 11    17*						   7 = restart_q - back to first messages in my queues
 11    18*						*/
 11    19      2 type_ext bit (36),				/* defined by each command type */
 11    20      2 minor_idx fixed bin,				/* index of minor device sending this request */
 11    21      2 dvc_idx fixed bin,				/* index of associated device class */
 11    22      2 request_no fixed bin,				/* request number for save/restart */
 11    23      2 queue_no fixed bin,				/* specified queue for next_req */
 11    24      2 user_id char (32),				/* sender id for next_req */
 11    25      2 req_id char (24),				/* request id from -id arg */
 11    26      2 pad_space (3) fixed bin,
 11    27      2 data_len fixed bin,				/* length of following string */
 11    28      2 data char (256 refer (iodd_comm.data_len));		/* data for command type if needed */
 11    29 
 11    30 dcl restart fixed bin int static options (constant) init (2);
 11    31 dcl save fixed bin int static options (constant) init (3);
 11    32 dcl next_req fixed bin int static options (constant) init (6);
 11    33 dcl restart_q fixed bin int static options (constant) init (7);
 11    34 
 11    35 
 11    36 /* ..... END INCLUDE FILE  ...  iodd_comm.incl.pl1  ..... */
     2528 
     2529 
 12     1 /*  */
 12     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 12     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 12     4 /* Modified 07/07/76 by Morris for fault register data */
 12     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 12     6 /* Modified '82 to make values constant */
 12     7 
 12     8 /* words 0-15 pointer registers */
 12     9 
 12    10 dcl  mcp ptr;
 12    11 
 12    12 dcl 1 mc based (mcp) aligned,
 12    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 12    14    (2 regs,					/* registers */
 12    15       3 x (0:7) bit (18),				/* index registers */
 12    16       3 a bit (36),					/* accumulator */
 12    17       3 q bit (36),					/* q-register */
 12    18       3 e bit (8),					/* exponent */
 12    19       3 pad1 bit (28),
 12    20       3 t bit (27),					/* timer register */
 12    21       3 pad2 bit (6),
 12    22       3 ralr bit (3),				/* ring alarm register */
 12    23 
 12    24     2 scu (0:7) bit (36),
 12    25 
 12    26     2 mask bit (72),				/* mem controller mask at time of fault */
 12    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 12    28     2 errcode fixed bin (35),				/* fault handler's error code */
 12    29     2 fim_temp,
 12    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 12    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 12    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 12    33     2 fault_reg bit (36),				/* fault register */
 12    34     2 pad2 bit (1),
 12    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 12    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 12    37     2 fault_time bit (54),				/* time of fault */
 12    38 
 12    39     2 eis_info (0:7) bit (36)) unaligned;
 12    40 
 12    41 
 12    42 dcl (apx fixed bin init (0),
 12    43      abx fixed bin init (1),
 12    44      bpx fixed bin init (2),
 12    45      bbx fixed bin init (3),
 12    46      lpx fixed bin init (4),
 12    47      lbx fixed bin init (5),
 12    48      spx fixed bin init (6),
 12    49      sbx fixed bin init (7)) internal static options (constant);
 12    50 
 12    51 
 12    52 
 12    53 
 12    54 dcl  scup ptr;
 12    55 
 12    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 12    57 
 12    58 
 12    59 /*	WORD (0)		*/
 12    60 
 12    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 12    62       3 prr bit (3),				/* procedure ring register */
 12    63       3 psr bit (15),				/* procedure segment register */
 12    64       3 p bit (1),					/* procedure privileged bit */
 12    65 
 12    66     2 apu,					/* APPENDING UNIT STATUS */
 12    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 12    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 12    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 12    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 12    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 12    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 12    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 12    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 12    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 12    76       3 ptw bit (1),				/* Fetch of PTW */
 12    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 12    78       3 fap bit (1),				/* Fetch of final address paged */
 12    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 12    80       3 fabs bit (1),				/* Fetch of final address absolute */
 12    81 
 12    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 12    83 
 12    84 
 12    85 /*	WORD (1)		*/
 12    86 
 12    87     2 fd,						/* FAULT  DATA */
 12    88       3 iro bit (1),				/* illegal ring order */
 12    89       3 oeb bit (1),				/* out of execute bracket */
 12    90       3 e_off bit (1),				/* no execute */
 12    91       3 orb bit (1),				/* out of read bracket */
 12    92       3 r_off bit (1),				/* no read */
 12    93       3 owb bit (1),				/* out of write bracket */
 12    94       3 w_off bit (1),				/* no write */
 12    95       3 no_ga bit (1),				/* not a gate */
 12    96       3 ocb bit (1),				/* out of call bracket */
 12    97       3 ocall bit (1),				/* outward call */
 12    98       3 boc bit (1),				/* bad outward call */
 12    99       3 inret bit (1),				/* inward return */
 12   100       3 crt bit (1),				/* cross ring transfer */
 12   101       3 ralr bit (1),				/* ring alarm register */
 12   102       3 am_er bit (1),				/* associative memory fault */
 12   103       3 oosb bit (1),				/* out of segment bounds */
 12   104       3 paru bit (1),				/* processor parity upper */
 12   105       3 parl bit (1),				/* processor parity lower */
 12   106       3 onc_1 bit (1),				/* op not complete type 1 */
 12   107       3 onc_2 bit (1),				/* op not complete type 2 */
 12   108 
 12   109     2 port_stat,					/* PORT  STATUS */
 12   110       3 ial bit (4),				/* illegal action lines */
 12   111       3 iac bit (3),				/* illegal action channel */
 12   112       3 con_chan bit (3),				/* connect channel */
 12   113 
 12   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 12   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 12   116 
 12   117 
 12   118 /*	WORD (2)		*/
 12   119 
 12   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 12   121       3 trr bit (3),				/* temporary ring register */
 12   122       3 tsr bit (15),				/* temporary segment register */
 12   123 
 12   124     2 pad2 bit (9),
 12   125 
 12   126     2 cpu_no bit (3),				/* CPU number */
 12   127 
 12   128     2 delta bit (6),				/* tally modification DELTA */
 12   129 
 12   130 
 12   131 /*	WORD (3)		*/
 12   132 
 12   133     2 word3 bit (18),
 12   134 
 12   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 12   136       3 tsna,					/* Word 1 status */
 12   137         4 prn bit (3),				/* Word 1  PR  number */
 12   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 12   139       3 tsnb,					/* Word 2  status */
 12   140         4 prn bit (3),				/* Word 2  PR  number */
 12   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 12   142       3 tsnc,					/* Word 3  status */
 12   143         4 prn bit (3),				/* Word 3  PR  number */
 12   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 12   145 
 12   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 12   147 
 12   148 
 12   149 /* 	WORD (4)		*/
 12   150 
 12   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 12   152 
 12   153     2 ir,						/* INDICATOR  REGISTERS */
 12   154       3 zero bit (1),				/* zero indicator */
 12   155       3 neg bit (1),				/* negative indicator */
 12   156       3 carry bit (1),				/* carryry indicator */
 12   157       3 ovfl bit (1),				/* overflow indicator */
 12   158       3 eovf bit (1),				/* eponent overflow */
 12   159       3 eufl bit (1),				/* exponent underflow */
 12   160       3 oflm bit (1),				/* overflow mask */
 12   161       3 tro bit (1),				/* tally runout */
 12   162       3 par bit (1),				/* parity error */
 12   163       3 parm bit (1),				/* parity mask */
 12   164       3 bm bit (1),					/* ^bar mode */
 12   165       3 tru bit (1),				/* truncation mode */
 12   166       3 mif bit (1),				/* multi-word instruction mode */
 12   167       3 abs bit (1),				/* absolute mode */
 12   168       3 hex bit (1),				/* hexadecimal exponent mode */
 12   169       3 pad bit (3),
 12   170 
 12   171 
 12   172 /*	WORD (5)		*/
 12   173 
 12   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 12   175 
 12   176     2 cu,						/* CONTROL UNIT STATUS */
 12   177       3 rf bit (1),					/* on first cycle of repeat instr */
 12   178       3 rpt bit (1),				/* repeat instruction */
 12   179       3 rd bit (1),					/* repeat double instruction */
 12   180       3 rl bit (1),					/* repeat link instruciton */
 12   181       3 pot bit (1),				/* IT  modification */
 12   182       3 pon bit (1),				/* return type instruction */
 12   183       3 xde bit (1),				/* XDE from Even location */
 12   184       3 xdo bit (1),				/* XDE from Odd  location */
 12   185       3 poa bit (1),				/* operation preparation */
 12   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 12   187       3 its bit (1),				/* ITS modification */
 12   188       3 if bit (1),					/* fault occured during instruction fetch */
 12   189 
 12   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 12   191 
 12   192 
 12   193 /*	WORDS (6,7)	*/
 12   194 
 12   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 12   196 
 12   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 12   198 
 12   199 
 12   200 
 12   201 
 12   202 
 12   203 
 12   204 /*	ALTERNATE   SCU  DECLARATION		*/
 12   205 
 12   206 
 12   207 dcl 1 scux based (scup) aligned,
 12   208 
 12   209    (2 pad0 bit (36),
 12   210 
 12   211     2 fd,						/* GROUP II  FAULT DATA */
 12   212       3 isn bit (1),				/* illegal segment number */
 12   213       3 ioc bit (1),				/* illegal op  code  */
 12   214       3 ia_am bit (1),				/* illegal address - modifier */
 12   215       3 isp bit (1),				/* illegal slave  procedure */
 12   216       3 ipr bit (1),				/* illegal procedure */
 12   217       3 nea bit (1),				/* non existent address */
 12   218       3 oobb bit (1),				/* out of bounds */
 12   219       3 pad bit (29),
 12   220 
 12   221     2 pad2 bit (36),
 12   222 
 12   223     2 pad3a bit (18),
 12   224 
 12   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 12   226       3 prn bit (3),				/* PR  number */
 12   227       3 prv bit (1),				/* PR  valid bit */
 12   228 
 12   229     2 pad3b bit (6)) unaligned,
 12   230 
 12   231     2 pad45 (0:1) bit (36),
 12   232 
 12   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 12   234 
 12   235 
 12   236 
 12   237 /*  END INCLUDE FILE   mc.incl.pl1 */
     2530 
     2531 
 13     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
 13     2 /* format: style3,idind30 */
 13     3 
 13     4 /* structure returned when message is read from a message segment */
 13     5 
 13     6 
 13     7 dcl	mseg_message_info_ptr	pointer;
 13     8 
 13     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
 13    10 	  2 version		char (8) aligned,
 13    11 	  2 message_code		fixed bin,
 13    12 	  2 control_flags		unaligned,
 13    13 	    3 own			bit (1),
 13    14 	    3 delete		bit (1),
 13    15 	    3 pad			bit (34),
 13    16 	  2 ms_ptr		ptr,		/* pointer to message */
 13    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
 13    18 	  2 ms_id			bit (72),		/* unique ID of message */
 13    19 						/* input in some cases */
 13    20 	  2 ms_access_class		bit (72),		/* message access class */
 13    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
 13    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
 13    23 	  2 sender_level		fixed bin,	/* validation level of sender */
 13    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
 13    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
 13    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
 13    27 
 13    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
 13    29 
 13    30 declare	(
 13    31 	MSEG_READ_FIRST		init (1),
 13    32 	MSEG_READ_LAST		init (2),
 13    33 	MSEG_READ_SPECIFIED		init (3),
 13    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
 13    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
 13    36 	fixed bin int static options (constant);
 13    37 
 13    38 declare  (MSEG_READ_OWN		init ("1"b),
 13    39 	MSEG_READ_DELETE		init ("01"b)
 13    40 	)			bit (36) aligned internal static options (constant);
 13    41 
 13    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     2532 
     2533 
 14     1 /* BEGIN INCLUDE FILE ... new_driver_msg.incl */
 14     2 
 14     3 dcl new_driver_msg_p ptr;
 14     4 
 14     5 dcl 1 new_driver_msg aligned based (new_driver_msg_p),
 14     6       2 wakeup_chan fixed bin (71),		/* event channel for waking driver */
 14     7       2 lock_id bit (36),			/* driver's lock id */
 14     8       2 device_index fixed bin,		/* index of minor device wanted by driver */
 14     9       2 dev_class_index fixed bin;		/* index of device class entry wanted by driver */
 14    10 
 14    11 /* END INCLUDE FILE ... new_driver_msg.incl.pl1 */
     2534 
     2535 
 15     1 /* BEGIN INCLUDE FILE...q_group_tab.incl.pl1 */
 15     2 
 15     3 
 15     4 
 15     5 /****^  HISTORY COMMENTS:
 15     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
 15     7*     Ancient History
 15     8*     Created by J. Stern, December 1974
 15     9*     Modified by J. Whitmore April 1978
 15    10*     Modified by R. McDonald May 1980 to include page charges (UNCA)
 15    11*     Modified by E. N. Kittlitz June 1981 for UNCA changes
 15    12*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
 15    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 15    14*     Add forms_validation, default_form and font_dir variables for laser
 15    15*     printer support.
 15    16*                                                   END HISTORY COMMENTS */
 15    17 
 15    18 
 15    19 /* format: style4 */
 15    20 
 15    21 dcl  qgtp ptr;					/* ptr to queue group table */
 15    22 dcl  1 q_group_tab aligned based (qgtp),
 15    23        2 n_q_groups fixed bin,			/* number of queue groups */
 15    24        2 pad fixed bin,
 15    25        2 entries (1 refer (q_group_tab.n_q_groups)) like qgte; /* entries of queue group table */
 15    26 
 15    27 dcl  qgtep ptr;					/* queue group table entry pointer */
 15    28 dcl  1 qgte aligned based (qgtep),			/* queue group table entry */
 15    29 
 15    30 /* static info from the parms file */
 15    31 
 15    32        2 name char (24),				/* queue group name */
 15    33        2 comment unaligned like text_offset,		/* comment to apply to the request_type */
 15    34        2 driver_id char (32),				/* person.project name of drivers for this q group */
 15    35        2 accounting unaligned like text_offset,		/* offset to accounting routine pathname, "system" => charge_user_ */
 15    36        2 generic_type char (32),			/* generic type of requests in this queue */
 15    37        2 default_generic_queue fixed bin (1),		/* 1 if this is default queue for above generic type, else 0 */
 15    38        2 rqti_seg_name char (32),			/* name of rqti seg, if required, else blank */
 15    39        2 max_queues fixed bin,			/* number of queues for this request type */
 15    40        2 default_queue fixed bin,			/* number of the default queue */
 15    41        2 line_charge,				/* price names for line charges */
 15    42          3 queue (4) char (32),			/* one name for each queue */
 15    43        2 page_charge,				/* price names for page charges */
 15    44          3 queue (4) char (32),			/* one name for each queue */
 15    45        2 forms_table unaligned like text_offset,		/* offset to forms table to apply to this queue group */
 15    46        2 forms_validation unaligned like text_offset,	/* offset to name of routine for forms validation */
 15    47        2 default_form unaligned like text_offset,		/* offset to default -form string if none given */
 15    48        2 font_dir unaligned like text_offset,		/* offset to location of downloadable fonts */
 15    49        2 first_dev_class fixed bin,			/* index of first device class entry of queue group */
 15    50        2 last_dev_class fixed bin,			/* index of last device class entry of queue group */
 15    51 
 15    52 /* dynamic info reflecting current status of queues */
 15    53 
 15    54        2 open fixed bin,				/* 1 if queues have been opened, else 0 */
 15    55        2 per_queue_info (4),
 15    56          3 last_read bit (72),			/* ID of last message read */
 15    57          3 mseg_index fixed bin,			/* message segment index */
 15    58          3 pad fixed bin;				/* pad to even word boundary */
 15    59 
 15    60 /* END INCLUDE FILE...q_group_tab.incl.pl1 */
     2536 
     2537 
 16     1 /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
 16     2 
 16     3 /* This is the message header used for standard system queue messages, namely:
 16     4*   IO daemon requests, absentee requests, retrieval requests.
 16     5**/
 16     6 
 16     7 /* Written by Jerry Whitmore, Spring 1978.
 16     8*   Modified by T. Casey, November 1978, to add values for state.
 16     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
 16    10**/
 16    11 
 16    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
 16    13     2 msg_time fixed bin (71),			/* date and time of request */
 16    14     2 hdr_version fixed bin,				/* version of this declaration */
 16    15     2 dirname char (168),				/* directory name */
 16    16     2 ename char (32),				/* entry name of file requested */
 16    17     2 message_type fixed bin,				/* message format descriptor   */
 16    18 						/* 0 = absentee request        */
 16    19 						/* 1 = print request           */
 16    20 						/* 2 = punch request           */
 16    21 						/* 3 = tape request            */
 16    22 						/* 4 = retrieval request       */
 16    23     2 bit_flags,
 16    24       3 delete_sw bit (1) unal,			/* delete file when done */
 16    25       3 notify bit (1) unal,				/* user wants to be notified */
 16    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
 16    27       3 padding bit (33) unal,
 16    28     2 state fixed bin,				/* stage of processing after being queued:
 16    29*						   0 = initial unprocessed state, 1 = deferred,
 16    30*						   2 = in state transition, 3 = eligible, 4 = running,
 16    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
 16    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
 16    33     2 std_length fixed bin,				/* length of std msg for this type */
 16    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
 16    35     2 hdr_pad (3) fixed bin;
 16    36 
 16    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
 16    38 
 16    39 /* Values for queue_msg_hdr.state */
 16    40 
 16    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
 16    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
 16    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
 16    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
 16    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
 16    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
 16    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
 16    48 
 16    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
     2538 
     2539 
 17     1 /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 17     2 
 17     3 /* Descriptor associated with an I/O daemon request */
 17     4 /* Coded August 1973 by Robert S. Coren */
 17     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 17     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 17     7 
 17     8 dcl  1 request_descriptor based aligned,
 17     9 	2 mseg_message_info_copy like mseg_message_info,
 17    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 17    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 17    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 17    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 17    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 17    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 17    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 17    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 17    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 17    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 17    20 	2 driver_data bit(252),	/* driver maintained data */
 17    21 	2 flags,
 17    22 	   (3 continued,		/* unfinished by one driver and given to another */
 17    23 	    3 finished,
 17    24 	    3 restarted,
 17    25 	    3 cancelled,
 17    26 	    3 dont_delete,
 17    27 	    3 saved,		/* not to be freed */
 17    28 	    3 keep_in_queue,	/* keep request in queue */
 17    29 	    3 series_restart,	/* this request is part of restarted series */
 17    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 17    31 	    3 pad bit(27) unal,
 17    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 17    33 
 17    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
     2540 
     2541 
     2542      end iodc_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/89  0800.1  iodc_.pl1                         >special_ldd>install>MR12.3-1025>iodc_.pl1
2508         1    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
2510         2    03/15/89  0759.4  create_branch_info.incl.pl1       >special_ldd>install>MR12.3-1025>create_branch_info.incl.pl1
2512         3    11/09/88  0759.7  device_class.incl.pl1             >ldd>include>device_class.incl.pl1
2514         4    11/09/88  0759.7  driver_status.incl.pl1            >ldd>include>driver_status.incl.pl1
2516         5    11/09/88  0759.7  iod_device_tab.incl.pl1           >ldd>include>iod_device_tab.incl.pl1
2518         6    09/28/78  1359.8  iod_event_message.incl.pl1        >ldd>include>iod_event_message.incl.pl1
2520         7    11/09/88  0759.7  iod_tables_hdr.incl.pl1           >ldd>include>iod_tables_hdr.incl.pl1
2522         8    08/29/75  1310.5  iodc_data.incl.pl1                >ldd>include>iodc_data.incl.pl1
2524         9    09/28/78  1359.8  iodc_static.incl.pl1              >ldd>include>iodc_static.incl.pl1
2526        10    09/28/78  1359.8  iodc_wait_list.incl.pl1           >ldd>include>iodc_wait_list.incl.pl1
2528        11    09/28/78  1359.8  iodd_comm.incl.pl1                >ldd>include>iodd_comm.incl.pl1
2530        12    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
2532        13    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
2534        14    08/29/75  1310.5  new_driver_msg.incl.pl1           >ldd>include>new_driver_msg.incl.pl1
2536        15    11/09/88  0759.7  q_group_tab.incl.pl1              >ldd>include>q_group_tab.incl.pl1
2538        16    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
2540        17    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
IODT_VERSION_5                  000010 constant        char(8)                  initial packed unaligned dcl 7-49 ref 520 539
MSEG_MESSAGE_INFO_V1            000006 constant        char(8)                  initial dcl 13-28 ref 1480 1874 1952
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 13-30 ref 1954
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 13-30 ref 1875
MSEG_READ_SPECIFIED                    constant        fixed bin(17,0)          initial dcl 13-30 ref 1482
NL                                     constant        char(1)                  initial packed unaligned dcl 279 ref 2120
STATE_ELIGIBLE                         constant        fixed bin(17,0)          initial dcl 16-44 ref 1924
a_code                                 parameter       fixed bin(35,0)          dcl 1387 set ref 1377 1435*
a_idtep                                parameter       pointer                  dcl 1386 ref 1377 1390
a_ptr                                  parameter       pointer                  dcl 45 ref 857 874 1440 1452 1472
ac_name                         000157 internal static char(32)                 array level 2 in structure "acl" dcl 319
                                                                                  in procedure "iodc_" set ref 415* 419* 489 656
                                                                                  1701*
ac_name                         000220 internal static char(32)                 array level 2 in structure "dir_acl" dcl 325
                                                                                  in procedure "iodc_" set ref 415* 419*
acc_name                        000704 automatic       char(32)                 level 2 dcl 339 set ref 658*
access_class             20     000270 internal static bit(72)                  level 2 dcl 337 set ref 813*
ack_chan                        000100 automatic       fixed bin(71,0)          dcl 143 in procedure "iodc_" set ref 1159* 1165*
                                                                                  1330 1336* 1460* 1501*
ack_chan                               based           fixed bin(71,0)          level 2 in structure "iodd_comm" dcl 11-7
                                                                                  in procedure "iodc_" ref 1501
ack_msg                                based           structure                level 1 dcl 6-18
acknowledge              47(03)        based           bit(1)                   level 3 packed packed unaligned dcl 4-25 set ref
                                                                                  1074
acl                             000157 internal static structure                array level 1 dcl 319 set ref 795 795
aclass                                 parameter       bit(72)                  dcl 806 set ref 802 813 814*
active                   20            based           fixed bin(17,0)          level 2 dcl 5-64 set ref 930 1213 1307 1396 1420*
                                                                                  1635 1743* 2197
addr                                                   builtin function         dcl 308 ref 393 441 623 654 659 659 680 692 714 714
                                                                                  722 722 730 730 740 740 795 795 821 821 833 833
                                                                                  880 889 917 920 939 941 996 1092 1093 1096 1100
                                                                                  1160 1166 1212 1217 1220 1306 1310 1333 1334 1395
                                                                                  1400 1402 1483 1483 1562 1565 1600 1602 1757 1773
                                                                                  1876 1876 1955 1955 2119 2119 2193 2196 2199 2201
                                                                                  2244 2245 2279 2282 2312 2397 2437 2437 2489
adir_quota                             parameter       fixed bin(17,0)          dcl 808 ref 802 818
aim_check_$equal                000316 constant        entry                    external dcl 50 ref 472 814
aim_check_$greater_or_equal     000320 constant        entry                    external dcl 51 ref 1570 1919 1922
any_other                       000570 stack reference condition                dcl 285 ref 409
ap                              000120 automatic       pointer                  dcl 2418 set ref 2461* 2462*
aquota                                 parameter       fixed bin(17,0)          dcl 807 ref 802 817
area                            000612 stack reference condition                dcl 288 ref 1061 1063
area_flag                       000102 automatic       fixed bin(17,0)          dcl 144 set ref 1060* 2360 2366*
areap                           000010 internal static pointer                  dcl 213 set ref 395* 1483* 1876* 1946 1955* 1973
                                                                                  2221 2265
args                     12            based           structure                level 2 packed packed unaligned dcl 5-64 ref 1725
auth                            000104 automatic       bit(72)                  dcl 145 set ref 468* 472* 492* 1543* 1570* 1685*
                                                                                  1917* 1919* 1922*
based_message                          based           bit                      dcl 300 set ref 1096* 1096
bc                              000106 automatic       fixed bin(24,0)          dcl 146 set ref 518 846* 849*
before                                                 builtin function         dcl 308 ref 2121
bitcnt                   16     000270 internal static fixed bin(24,0)          level 2 dcl 337 set ref 490*
branch_info                     000270 internal static structure                level 1 dcl 337 set ref 821 821
cancelled                53(03)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref 997
                                                                                  1145* 1145 1404
chan_name                       000110 automatic       fixed bin(71,0)          dcl 147 set ref 706* 714* 717 719* 722* 725 727*
                                                                                  730* 733 1545* 1759*
chase_sw                  1(02) 000270 internal static bit(1)                   level 3 packed packed unaligned dcl 337 set ref 483*
cleanup                         000604 stack reference condition                dcl 287 ref 408 867 1463 2068 2100
cmd                             000112 automatic       char(24)                 dcl 148 set ref 1169* 1178* 1180* 1228* 1274* 2121*
                                                                                  2122 2122 2127 2135 2148 2154 2161 2161 2168 2175
                                                                                  2183 2189 2215 2275 2275 2297 2324 2344* 2347*
code                                   parameter       fixed bin(35,0)          dcl 844 in procedure "initiate" set ref 838 846*
                                                                                  849* 851 851*
code                                   parameter       fixed bin(35,0)          dcl 1326 in procedure "driver_ack" set ref 1323 1333
                                                                                  1338*
code                            000120 automatic       fixed bin(35,0)          dcl 149 in procedure "iodc_" set ref 405* 430* 431
                                                                                  437* 438 450* 451 451 454* 461* 462 464* 492* 493
                                                                                  495* 502* 503 505* 515* 516 529* 530 530 546* 547
                                                                                  552* 553 555* 564* 566 568* 572* 574 576* 582*
                                                                                  588* 589 593* 596* 597 601* 602 607* 608 628* 630
                                                                                  630 633* 638* 640 642* 644 659* 660 662 662* 664*
                                                                                  682* 683 706* 707 709* 711* 714* 715 719* 720 722*
                                                                                  723 727* 728 730* 731 737* 738 740* 742 766* 767*
                                                                                  883* 884 1076* 1077 1077* 1108* 1109 1111* 1129*
                                                                                  1232* 1233* 1246* 1258* 1266* 1271* 1317* 1347*
                                                                                  1352 1369* 1371 1371* 1425* 1427 1427 1431* 1433*
                                                                                  1435 1483* 1484 1486* 1489* 1491 1491* 1505* 1506
                                                                                  1508* 1530* 1554* 1572* 1582* 1595* 1607* 1617*
                                                                                  1619 1619 1621* 1622 1624* 1629* 1637* 1650* 1652
                                                                                  1654 1658* 1659* 1663* 1685* 1686 1689* 1691*
                                                                                  1702* 1704 1708* 1709* 1757 1759* 1760 1760* 1835*
                                                                                  1850* 1851 1858* 1865* 1919* 1942* 1969 1969*
                                                                                  1991* 2043* 2047* 2077* 2083* 2119* 2315* 2490*
                                                                                  2496*
code                                   parameter       fixed bin(35,0)          dcl 907 in procedure "identify_sender" set ref 904
                                                                                  913* 926* 933* 946*
code                                   parameter       fixed bin(35,0)          dcl 809 in procedure "make_dir" set ref 802 821* 823
                                                                                  830 833*
code                            001066 automatic       fixed bin(35,0)          dcl 2380 in procedure "check_wakeup_code" set ref
                                                                                  2393*
code                                   parameter       fixed bin(35,0)          dcl 784 in procedure "make" set ref 778 788* 790*
                                                                                  791 791 791 795*
code                                   based           fixed bin(17,0)          level 2 in structure "ev_msg" packed packed
                                                                                  unaligned dcl 6-8 in procedure "iodc_" set ref 889
                                                                                  1757*
code                                   based           fixed bin(35,0)          level 2 in structure "ack_msg" dcl 6-18 in procedure
                                                                                  "iodc_" set ref 1333*
code2                           000121 automatic       fixed bin(35,0)          dcl 150 set ref 768* 769* 770* 771* 772* 869* 1467*
                                                                                  1876* 1877 1877 1886 1926* 1928 1930 1955* 1956
                                                                                  1956 2070* 2082* 2103* 2114* 2139* 2332*
com_err_                        000322 constant        entry                    external dcl 53 ref 382 431 454 464 472 495 505 522
                                                                                  555 568 576 633 664 711 2063 2144 2319 2339 2344
                                                                                  2347
com_level                       000155 internal static fixed bin(17,0)          dcl 242 set ref 398* 2097* 2097 2102* 2102 2107 2107
                                                                                  2107* 2135 2138* 2138 2297 2324
comm_mseg_idx                   000146 internal static fixed bin(17,0)          dcl 231 set ref 642* 1483* 1489*
comm_ptr                        000734 automatic       pointer                  dcl 11-5 set ref 1500* 1501 1503 1513 1517 1518 1820
                                                                                  1831 1839 1840 1846 1850 1911
cond_mess                              based           char                     packed unaligned dcl 2423 set ref 2470*
condition_info                         based           structure                level 1 dcl 1-14
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 1-30 ref 2435
condition_interpreter_          000604 constant        entry                    external dcl 2427 ref 2462
condition_name            3     000126 automatic       varying char(32)         level 2 dcl 2433 set ref 2438
conname                         000106 automatic       char(32)                 packed unaligned dcl 2415 set ref 2438* 2440 2442
                                                                                  2445 2451 2453 2455 2458 2462* 2482*
contd_seq_id             34            based           fixed bin(35,0)          level 2 dcl 17-8 set ref 1413*
continue_to_signal_             000602 constant        entry                    external dcl 2426 ref 2447
continued                53            based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref
                                                                                  1411*
convert_ipc_code_               000324 constant        entry                    external dcl 54 ref 709
coord_chan               40            based           fixed bin(71,0)          level 2 dcl 4-25 set ref 1720*
coord_proc_id                   000153 internal static bit(36)                  packed unaligned dcl 239 set ref 748* 1100
coord_static                    000244 internal static structure                level 1 dcl 334 set ref 393
copy_ptr                        000122 automatic       pointer                  dcl 151 set ref 996* 997 997 1144 1145 1146 1147
                                                                                  1150 1150 1402* 1404 1404
copy_sw                   1(01) 000270 internal static bit(1)                   level 3 packed packed unaligned dcl 337 set ref 482*
copy_template                          based           fixed bin(17,0)          array dcl 301 set ref 559* 559 591* 591
copy_words                      000124 automatic       fixed bin(17,0)          dcl 152 set ref 518* 559 591
count                                  based           fixed bin(17,0)          array level 2 dcl 345 set ref 2222* 2229 2235* 2235
                                                                                  2242 2249*
create_branch_info                     based           structure                level 1 dcl 2-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 2-35 ref 480
current_request          14            based           fixed bin(18,0)          level 2 dcl 5-64 set ref 983 995 1001* 1115* 1396
                                                                                  1401 1417* 1745*
cwtp                            000126 automatic       pointer                  dcl 153 set ref 588* 591 615 615 616 616 617 617 618
                                                                                  618 619 619 620 621
data                     32            based           char                     level 2 dcl 11-7 set ref 1846 1850*
data_len                 31            based           fixed bin(17,0)          level 2 dcl 11-7 ref 1846 1850 1850
date_time_compiled        2            based           fixed bin(71,0)          level 2 dcl 7-23 ref 541 541
dcte                                   based           structure                level 1 dcl 3-27
dctep                           000720 automatic       pointer                  dcl 3-25 set ref 692* 693 693 939* 941 974 974 1005*
                                                                                  1013 1015 1016 1022 1024 1028 1045 1102 1104 1217*
                                                                                  1220 1250 1278 1400* 1404* 1409 1410 1562* 1565
                                                                                  1570 1605 1654 1719 1726 1773* 1775 1806 1806 1810
                                                                                  1811 1919 1922 2004 2015 2025 2031 2031 2034 2034
                                                                                  2199* 2201 2244* 2245 2253 2255 2282* 2283 2286
dctp                                   based           pointer                  level 2 dcl 9-5 set ref 619* 691 692 939 1217 1400
                                                                                  1551 1562 1773 2199 2244 2282
dcx                       3            based           fixed bin(17,0)          array level 2 in structure "series_info" dcl 345
                                                                                  in procedure "iodc_" set ref 2232* 2244
dcx                             000130 automatic       fixed bin(17,0)          dcl 154 in procedure "iodc_" set ref 691* 692* 938*
                                                                                  939 1067* 1188 1550* 1551 1551 1562 1724 1742
                                                                                  1772* 1773* 2280* 2282*
debug                           000326 constant        entry                    external dcl 55 ref 2157
delete_$path                    000330 constant        entry                    external dcl 56 ref 450 1425
desc_off                        000131 automatic       fixed bin(18,0)          dcl 155 set ref 1035* 1036 1037 1045 1047* 1050*
                                                                                  1098* 1104 1115 1185* 1185* 1186* 1278 1290* 1290*
                                                                                  1292* 2224* 2225 2226 2237*
desc_ptr                        000132 automatic       pointer                  dcl 156 set ref 995* 1005* 1015* 1016 1024* 1025*
                                                                                  1026 1027 1027 1032 1034 1035 1062* 1065 1067*
                                                                                  1072 1089 1090 1092 1095 1096 1098 1102 1116 1125
                                                                                  1144 1145 1146 1147 1147 1150 1186* 1188 1188 1188
                                                                                  1213 1238 1262 1272 1284 1287 1290 1292* 1293 1295
                                                                                  1296 1299 1401* 1404* 1409 1410 1411 1413 1413
                                                                                  2226* 2227 2231 2232 2234 2237 2255* 2256 2256
descr_area                2            based           area(65560)              level 2 dcl 9-21 set ref 604* 1062 1072
descr_seg_ptr            10            based           pointer                  level 2 dcl 9-5 set ref 430* 441 442 601* 604 623
                                                                                  624 995 1015 1024 1037 1062 1072 1186 1292 1401
                                                                                  2226 2255
descriptor              146            based           structure                level 2 dcl 4-25 set ref 996 1092 1093 1402
dev_class_index          13            based           fixed bin(17,0)          level 2 in structure "mdte" dcl 5-64 in procedure
                                                                                  "iodc_" set ref 938 1213 1217 1400 1742* 2199
dev_class_index          36            based           fixed bin(17,0)          level 2 in structure "request_descriptor" dcl 17-8
                                                                                  in procedure "iodc_" set ref 1188 1213 2232
dev_class_index           4            based           fixed bin(17,0)          level 2 in structure "new_driver_msg" dcl 14-5
                                                                                  in procedure "iodc_" ref 1550
dev_class_index          53            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "iodc_" set ref 1724*
dev_class_tab                          based           structure                level 1 dcl 3-20
dev_class_tab_offset     12            based           fixed bin(18,0)          level 2 dcl 7-23 ref 619
dev_ctl_ptr             130            based           pointer                  level 2 dcl 4-25 set ref 1735*
dev_id                                 based           char(24)                 level 2 in structure "idte" dcl 5-29 in procedure
                                                                                  "iodc_" set ref 958 958 961 1180* 1354* 1425*
                                                                                  1430* 1630* 1685* 1688* 1700 2313 2392*
dev_id                          000134 automatic       char(32)                 dcl 157 in procedure "iodc_" set ref 2304* 2305 2313
                                                                                  2319*
dev_id                                 based           char(24)                 level 2 in structure "mdte" dcl 5-64 in procedure
                                                                                  "iodc_" set ref 958 958 1702* 1718
dev_in_iocbp             70            based           pointer                  level 2 dcl 4-25 set ref 1730*
dev_in_stream           102            based           char(32)                 level 2 dcl 4-25 set ref 1732*
dev_index                51            based           fixed bin(17,0)          level 2 dcl 4-25 set ref 1722*
dev_name_label           10            based           char(32)                 level 2 dcl 4-25 set ref 1717*
dev_out_iocbp            66            based           pointer                  level 2 dcl 4-25 set ref 1729*
dev_out_stream           72            based           char(32)                 level 2 dcl 4-25 set ref 1731*
dev_ptr1                120            based           pointer                  level 2 dcl 4-25 set ref 1734*
device_class_id          30            based           char(32)                 level 2 dcl 4-25 set ref 1719*
device_id                20            based           char(32)                 level 2 dcl 4-25 set ref 1718*
device_index              3            based           fixed bin(17,0)          level 2 dcl 14-5 ref 1591
device_list              21            based           bit(360)                 level 2 dcl 3-27 ref 1605
device_tab_offset        10            based           fixed bin(18,0)          level 2 dcl 7-23 ref 615
dir                                    parameter       char                     dcl 841 in procedure "initiate" set ref 838 846*
                                                                                  849*
dir                                    parameter       char                     packed unaligned dcl 370 in procedure "iodc_" ref
                                                                                  363 378
dir_acl                         000220 internal static structure                array level 1 dcl 325 set ref 833 833
dir_quota                22     000270 internal static fixed bin(18,0)          level 2 in structure "branch_info" dcl 337
                                                                                  in procedure "iodc_" set ref 814* 818* 823 827*
dir_quota                       000144 automatic       fixed bin(17,0)          dcl 158 in procedure "iodc_" set ref 1684* 1685*
dir_sw                    1     000270 internal static bit(1)                   level 3 packed packed unaligned dcl 337 set ref 481*
dirname                                parameter       char                     dcl 781 in procedure "make" set ref 778 788* 790*
                                                                                  795*
dirname                   3            based           char(168)                level 2 in structure "queue_msg_hdr" dcl 16-12
                                                                                  in procedure "iodc_" ref 1907
divide                                                 builtin function         dcl 308 ref 518 1034 1039 1183 1188 1293 1307 1684
                                                                                  2217 2227 2256
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref
                                                                                  1146* 1146
dr_ptr                          000146 automatic       pointer                  dcl 159 set ref 937* 996 1074 1076 1092 1093 1096
                                                                                  1100 1108 1369 1702* 1715 1716 1717 1718 1719 1720
                                                                                  1721 1722 1723 1724 1725 1726 1728 1729 1730 1731
                                                                                  1732 1733 1734 1735 1744 2397
driver_chan              42            based           fixed bin(71,0)          level 2 dcl 4-25 set ref 1076* 1108* 1369* 2397
driver_cmd_chan                 000020 internal static fixed bin(71,0)          dcl 219 set ref 733* 770* 1363
driver_command                         constant        fixed bin(17,0)          initial dcl 275 ref 1458
driver_data              44            based           bit(252)                 level 2 dcl 17-8 set ref 1144* 1144
driver_id                 7            based           char(32)                 level 2 dcl 15-28 ref 656 658 1580
driver_mmi                      000620 automatic       structure                level 1 dcl 330 set ref 1479* 1483 1483
driver_ptr               16            based           pointer                  level 2 dcl 5-64 set ref 937 1402 1744*
driver_sig_chan                 000012 internal static fixed bin(71,0)          dcl 214 set ref 725* 771* 1720
driver_status                          based           structure                level 1 dcl 4-25 set ref 1715*
ec                              000116 automatic       fixed bin(35,0)          dcl 2416 in procedure "iodc_handler" set ref 2437*
                                                                                  2447*
ec                              000100 automatic       fixed bin(35,0)          dcl 1328 in procedure "driver_ack" set ref 1336*
                                                                                  1338
empty                                                  builtin function         dcl 308 ref 604 610
ename                                  parameter       char                     dcl 805 in procedure "make_dir" set ref 802 821*
                                                                                  833*
ename                    55            based           char(32)                 level 2 in structure "queue_msg_hdr" dcl 16-12
                                                                                  in procedure "iodc_" ref 1899 1905
ent                                    parameter       char                     dcl 842 set ref 838 846* 849*
entname                                parameter       char                     dcl 782 set ref 778 788* 790* 795*
entries                   2            based           structure                array level 2 in structure "q_group_tab" dcl 15-22
                                                                                  in procedure "iodc_" set ref 654 941 1220 1565
                                                                                  2201 2245 2279
entries                   2            based           structure                array level 2 in structure "iod_device_tab" dcl 5-23
                                                                                  in procedure "iodc_" set ref 680 920 1310 1602
                                                                                  2193 2312
entries                   2            based           structure                array level 2 in structure "dev_class_tab" dcl 3-20
                                                                                  in procedure "iodc_" set ref 692 939 1217 1400
                                                                                  1562 1773 2199 2244 2282
entries                   4            based           structure                array level 2 in structure "waiting_list" dcl 10-3
                                                                                  in procedure "iodc_"
entries                   2            based           structure                array level 2 in structure "minor_device_tab"
                                                                                  dcl 5-58 in procedure "iodc_" set ref 917 1212
                                                                                  1306 1395 1600 2196
entry_type                      000150 automatic       fixed bin(17,0)          dcl 160 set ref 1448* 1458* 1494
err_label                       000136 internal static label variable           dcl 228 set ref 392* 875* 1471* 1502* 2504
errcode                  43            based           fixed bin(35,0)          level 2 packed packed unaligned dcl 12-12 ref 2490
error_table_$action_not_performed
                                000530 external static fixed bin(35,0)          dcl 248 set ref 1232 1465* 1534* 1835 1858 1991
error_table_$ai_above_allowed_max
                                000554 external static fixed bin(35,0)          dcl 263 ref 1942
error_table_$ai_restricted      000556 external static fixed bin(35,0)          dcl 265 ref 1919
error_table_$argerr             000544 external static fixed bin(35,0)          dcl 257 ref 662
error_table_$bad_segment        000532 external static fixed bin(35,0)          dcl 250 ref 1877 1930 1956
error_table_$invalid_lock_reset 000546 external static fixed bin(35,0)          dcl 258 ref 1619
error_table_$invalid_move_qmax  000534 external static fixed bin(35,0)          dcl 252 ref 823
error_table_$namedup            000540 external static fixed bin(35,0)          dcl 255 ref 791 1258
error_table_$noentry            000536 external static fixed bin(35,0)          dcl 254 ref 451 530 630 1246 1266 1427 1654 1969
error_table_$pathlong           000542 external static fixed bin(35,0)          dcl 256 set ref 382*
error_table_$request_not_recognized
                                000552 external static fixed bin(35,0)          dcl 261 ref 913 926 933 1530
error_table_$segknown           000550 external static fixed bin(35,0)          dcl 260 ref 791 851
et                        0(04) 000717 automatic       bit(1)                   level 2 packed packed unaligned dcl 352 set ref 1842
                                                                                  1899
ev_info                                based           structure                level 1 unaligned dcl 314
ev_info_ptr                     000152 automatic       pointer                  dcl 161 set ref 874* 876 880 889 923 1160 1166 1472*
                                                                                  1473 1478
ev_msg                                 based           structure                level 1 dcl 6-8
event_message                   000726 automatic       fixed bin(71,0)          dcl 6-6 set ref 1333 1334 1336* 1363* 1369* 1755*
                                                                                  1757 1759*
exmode                   11     000704 automatic       bit(36)                  level 2 dcl 339 set ref 650*
expand_pathname_                000332 constant        entry                    external dcl 57 ref 1850
find_condition_info_            000600 constant        entry                    external dcl 2425 ref 2437
find_next_request_              000334 constant        entry                    external dcl 58 ref 1067
find_next_request_$init         000336 constant        entry                    external dcl 59 ref 674
finish                          000154 automatic       fixed bin(17,0)          dcl 162 set ref 1829* 1831* 1833 1867
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref 997
                                                                                  1090* 1404
first                     1            based           fixed bin(17,0)          array level 2 dcl 345 set ref 2231* 2249*
first_dev_class         147            based           fixed bin(17,0)          level 2 dcl 15-28 ref 974 1772 2280
first_free                             based           fixed bin(17,0)          level 2 dcl 10-3 set ref 1799 1800* 1980 1982 1984*
first_minor              41            based           fixed bin(17,0)          level 2 dcl 5-29 ref 958 1208 1208 1394 1682 1684
                                                                                  2194
first_req_done           14            based           fixed bin(18,0)          level 2 dcl 9-5 set ref 442* 443 622* 1185 2224
first_saved                            based           fixed bin(18,0)          level 2 dcl 9-21 set ref 441 442 623 624*
first_waiting            41            based           fixed bin(17,0)          array level 3 dcl 3-27 set ref 1775 1810* 2004 2015*
                                                                                  2031*
fixed                                                  builtin function         dcl 308 ref 1098 1410
flags                    53            based           structure                level 2 dcl 17-8
forms_validation_ptr    116            based           pointer                  level 2 dcl 4-25 set ref 1733*
free_oldest_request_$cleanup    000340 constant        entry                    external dcl 61 ref 444
free_oldest_request_$force      000342 constant        entry                    external dcl 63 ref 2367
free_oldest_request_$free_oldest_request_
                                000564 external static fixed bin(17,0)          dcl 292 set ref 740 740
free_oldest_request_$init       000344 constant        entry                    external dcl 65 ref 427
fwx                             000155 automatic       fixed bin(17,0)          dcl 163 set ref 1778* 1784 1784* 1810
get_authorization_              000346 constant        entry                    external dcl 67 ref 468
get_group_id_$tag_star          000350 constant        entry                    external dcl 68 ref 415
get_process_id_                 000352 constant        entry                    external dcl 69 ref 748
get_ring_                       000354 constant        entry                    external dcl 70 ref 488
get_system_free_area_           000356 constant        entry                    external dcl 71 ref 395 2461
grace_time                4            based           fixed bin(71,0)          level 2 dcl 7-23 ref 620
hcs_$chname_seg                 000360 constant        entry                    external dcl 72 ref 572
hcs_$create_branch_             000362 constant        entry                    external dcl 73 ref 821
hcs_$delentry_seg               000364 constant        entry                    external dcl 74 ref 564
hcs_$get_access_class           000366 constant        entry                    external dcl 75 ref 461
hcs_$initiate_count             000370 constant        entry                    external dcl 76 ref 846
hcs_$make_seg                   000372 constant        entry                    external dcl 78 ref 788
hcs_$replace_acl                000574 constant        entry                    external dcl 785 ref 795
hcs_$replace_dir_acl            000576 constant        entry                    external dcl 810 ref 833
hcs_$set_ring_brackets          000374 constant        entry                    external dcl 80 ref 552
hcs_$terminate_noname           000376 constant        entry                    external dcl 81 ref 582 593
hcs_$wakeup                     000400 constant        entry                    external dcl 82 ref 1076 1108 1336 1369 1759
i                               000156 automatic       fixed bin(17,0)          dcl 164 set ref 1541* 1542 2191* 2206* 2206 2210
                                                                                  2240* 2261* 2261 2267 2277* 2288* 2288 2292
id                        0(03) 000717 automatic       bit(1)                   level 2 in structure "option" packed packed
                                                                                  unaligned dcl 352 in procedure "iodc_" set ref
                                                                                  1856 1911
id                              000012 constant        char(16)                 initial packed unaligned dcl 276 in procedure
                                                                                  "iodc_" set ref 2344* 2347*
id                                     based           char(32)                 level 2 in structure "dcte" dcl 3-27 in procedure
                                                                                  "iodc_" set ref 974 974 1654* 1719
idte                                   based           structure                level 1 dcl 5-29
idtep                           000722 automatic       pointer                  dcl 5-28 set ref 680* 681 682* 920* 923 958 958 958
                                                                                  958 961 1076 1108 1180 1208 1208 1208 1208 1310*
                                                                                  1347* 1354 1390* 1394 1394 1396 1423 1423 1425
                                                                                  1430 1602* 1613 1613 1617 1621* 1630 1680 1682
                                                                                  1682 1684 1684 1685 1688 1700 1740 1741 2193* 2194
                                                                                  2194 2194 2312* 2313 2315* 2392 2393*
idtx                            000157 automatic       fixed bin(17,0)          dcl 165 set ref 679* 680* 919* 920 1601* 1602 1723
                                                                                  2192* 2193* 2311* 2312*
info_ptr                 14     000126 automatic       pointer                  level 2 dcl 2433 set ref 2462*
init_event_channel                     based           fixed bin(71,0)          level 2 dcl 8-3 set ref 717* 772*
initialized                     000152 internal static bit(1)                   dcl 237 set ref 402* 750* 2180
io_coordinator_version          000016 constant        char(8)                  initial packed unaligned dcl 274 set ref 376*
ioa_                            000402 constant        entry                    external dcl 83 ref 376 2076 2107 2129 2130 2204
                                                                                  2210 2249 2256 2267 2286 2292 2307
ioa_$ioa_stream                 000404 constant        entry                    external dcl 84 ref 507
ioa_$ioa_stream_nnl             000606 constant        entry                    external dcl 2428 ref 2469
ioa_$rsnnl                      000406 constant        entry                    external dcl 85 ref 892 1121 1180 1228 1244 1255
                                                                                  1264 1274 1354 1430 1555 1573 1583 1596 1608 1630
                                                                                  1638 1649 1654 1657 1666 1688 1706 1749 2040 2387
                                                                                  2392 2398 2482 2491
iod_device_tab                         based           structure                level 1 dcl 5-23
iod_overseer_$coord_ready       000410 constant        entry                    external dcl 86 ref 752
iod_tables_hdr                         based           structure                level 1 dcl 7-23
iodc_$command_level             000412 constant        entry                    external dcl 88 ref 753 2079 2475
iodc_$driver_command            000572 external static fixed bin(17,0)          dcl 296 set ref 730 730
iodc_$driver_signal             000570 external static fixed bin(17,0)          dcl 295 set ref 722 722
iodc_$free_device               000414 constant        entry                    external dcl 89 ref 682 1347 1621 2315 2393
iodc_$new_driver                000566 external static fixed bin(17,0)          dcl 294 set ref 714 714
iodc_data                              based           structure                level 1 dcl 8-3
iodc_data_ptr                   000160 automatic       pointer                  dcl 166 set ref 502* 717 748 772
iodc_message_                   000416 constant        entry                    external dcl 90 ref 751 894 1123 1181 1231 1245 1257
                                                                                  1265 1276 1338 1355 1431 1486 1491 1557 1658 1668
                                                                                  1689 1708 1752 1990 2047 2470
iodc_message_$init              000422 constant        entry                    external dcl 92 ref 374
iodc_message_$loud              000420 constant        entry                    external dcl 91 ref 2043 2403
iodc_static                            based           structure                level 1 dcl 9-5
iodd_$iodd_init                 000424 constant        entry                    external dcl 93 ref 2335
iodd_comm                              based           structure                level 1 dcl 11-7
iox_$control                    000426 constant        entry                    external dcl 94 ref 405 767 2077 2083
iox_$get_line                   000430 constant        entry                    external dcl 95 ref 2119
iox_$user_input                 000560 external static pointer                  dcl 268 set ref 2077* 2119*
iox_$user_io                    000562 external static pointer                  dcl 269 set ref 405* 767* 2083*
ipc_$create_ev_chn              000432 constant        entry                    external dcl 96 ref 706 719 727 737
ipc_$decl_ev_call_chn           000436 constant        entry                    external dcl 98 ref 714 722 730 740
ipc_$delete_ev_chn              000434 constant        entry                    external dcl 97 ref 769 770 771 772
ipc_$drain_chn                  000440 constant        entry                    external dcl 99 ref 766
ipc_$mask_ev_calls              000442 constant        entry                    external dcl 100 ref 872 1470 2073 2125
ipc_$unmask_ev_calls            000444 constant        entry                    external dcl 101 ref 768 869 1129 1467 2070 2082
                                                                                  2103 2114 2139 2332
ithp                            000730 automatic       pointer                  dcl 7-22 set ref 515* 520 541 559 582*
iwtp                            000162 automatic       pointer                  dcl 167 set ref 527* 529* 539 541 562 564* 579* 591
                                                                                  593*
iwtrb                           000164 automatic       fixed bin(3,0)           array dcl 168 set ref 550* 551* 551* 552*
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref
                                                                                  1147* 1147 1150
last                      2            based           fixed bin(17,0)          array level 2 dcl 345 set ref 2234* 2249*
last_dev_class          150            based           fixed bin(17,0)          level 2 dcl 15-28 ref 974 1772 2280
last_minor               42            based           fixed bin(17,0)          level 2 dcl 5-29 ref 958 1208 1208 1394 1682 1684
                                                                                  2194
last_read               152            based           bit(72)                  array level 3 dcl 15-28 set ref 1648* 1770*
last_req_done            15            based           fixed bin(18,0)          level 2 dcl 9-5 set ref 622*
last_used                 1            based           fixed bin(17,0)          level 2 dcl 10-3 set ref 1793 1796* 1796 1988 1994
                                                                                  1996*
last_waiting             42            based           fixed bin(17,0)          array level 3 dcl 3-27 set ref 1811* 2025* 2031*
len                             000167 automatic       fixed bin(17,0)          dcl 169 set ref 1891* 1892
length                                                 builtin function         dcl 308 ref 379 1541 1891 2119 2119
line                            000170 automatic       char(80)                 packed unaligned dcl 170 set ref 2118* 2119 2119
                                                                                  2119 2119 2120* 2120 2121 2304 2339*
local_condition_info            000126 automatic       structure                level 1 dcl 2433 set ref 2437 2437
lock                     43            based           bit(36)                  level 2 dcl 5-29 set ref 1423* 1617* 1740*
lock_id                   2            based           bit(36)                  level 2 dcl 14-5 ref 1740
logout                          000446 constant        entry                    external dcl 102 ref 2178
ltrim                                                  builtin function         dcl 308 ref 2120 2304
lwx                             000214 automatic       fixed bin(17,0)          dcl 171 set ref 1778* 1786 1788* 1811 2007* 2015
                                                                                  2018 2028*
m_len                           000124 automatic       fixed bin(17,0)          dcl 2421 set ref 2462* 2467 2470 2470
maj_index                52            based           fixed bin(17,0)          level 2 dcl 4-25 set ref 1723*
major_index              11            based           fixed bin(17,0)          level 2 dcl 5-64 ref 919 1310 1601
mask_code                       000215 automatic       fixed bin(35,0)          dcl 172 in procedure "iodc_" set ref 866* 869 872*
                                                                                  1462* 1467 1470* 2098* 2103 2112 2115* 2125* 2139
                                                                                  2330 2333*
mask_code                       000100 automatic       fixed bin(35,0)          dcl 2058 in procedure "quit_handler" set ref 2067*
                                                                                  2070 2073*
match_dir                       000216 automatic       char(168)                dcl 173 set ref 1845* 1850* 1855* 1907
match_ent                       000270 automatic       char(32)                 dcl 174 set ref 1846* 1850* 1855* 1899 1905
match_request_id_               000450 constant        entry                    external dcl 103 ref 1911
max                                                    builtin function         dcl 308 ref 1684
max_access               13            based           bit(72)                  level 2 dcl 3-27 set ref 1570* 1922*
max_q                    20            based           fixed bin(17,0)          level 2 dcl 9-5 set ref 621*
max_queues                6            based           fixed bin(17,0)          level 2 in structure "iod_tables_hdr" dcl 7-23
                                                                                  in procedure "iodc_" ref 621
max_queues               41            based           fixed bin(17,0)          level 2 in structure "qgte" dcl 15-28 in procedure
                                                                                  "iodc_" ref 1645 1829 1833
max_wl_size                            constant        fixed bin(17,0)          initial dcl 10-14 ref 1988
mbz1                      1(05) 000270 internal static bit(31)                  level 3 packed packed unaligned dcl 337 set ref 485*
mbz2                      2(03) 000270 internal static bit(33)                  level 2 packed packed unaligned dcl 337 set ref 487*
mc                                     based           structure                level 1 dcl 12-12
mc_ptr                          000126 automatic       pointer                  level 2 dcl 2433 set ref 2462* 2487 2489 2490
mdte                                   based           structure                level 1 dcl 5-64
mdtep                           000724 automatic       pointer                  dcl 5-63 set ref 917* 919 930 937 938 958 958 983
                                                                                  995 1001 1089 1115 1120 1125 1212* 1213 1213 1217
                                                                                  1306* 1307 1307 1310 1395* 1396 1396 1400 1401
                                                                                  1402 1417 1420 1600* 1601 1635 1702 1718 1725 1742
                                                                                  1743 1744 1745 1747 2196* 2197 2199 2204
mdtx                            000300 automatic       fixed bin(17,0)          dcl 175 set ref 880* 909 909 917 1208* 1212* 1304*
                                                                                  1306* 1394* 1395* 1503* 1591* 1592 1592 1600 1605
                                                                                  1722 2194* 2196*
message                 240            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "iodc_" set ref 1096
message                   2            based           fixed bin(71,0)          level 2 in structure "ev_info" dcl 314 in procedure
                                                                                  "iodc_" set ref 880 889 1160 1166 1478
message_code              2     000620 automatic       fixed bin(17,0)          level 2 in structure "driver_mmi" dcl 330
                                                                                  in procedure "iodc_" set ref 1482*
message_code              2     000652 automatic       fixed bin(17,0)          level 2 in structure "msg_mmi" dcl 332 in procedure
                                                                                  "iodc_" set ref 1875* 1954*
message_len                     000301 automatic       fixed bin(17,0)          dcl 176 set ref 1095* 1096 1096
message_segment_$check_salv_bit_index
                                000466 constant        entry                    external dcl 115 ref 1663
message_segment_$create         000452 constant        entry                    external dcl 104 ref 638
message_segment_$delete         000454 constant        entry                    external dcl 106 ref 628
message_segment_$delete_index   000456 constant        entry                    external dcl 108 ref 1489
message_segment_$ms_acl_add     000460 constant        entry                    external dcl 110 ref 659
message_segment_$open           000464 constant        entry                    external dcl 114 ref 642 1650
message_segment_$read_message_index
                                000462 constant        entry                    external dcl 112 ref 1483 1876 1955
message_segment_$update_message_index
                                000470 constant        entry                    external dcl 117 ref 1926
min_access               15            based           bit(72)                  level 2 dcl 3-27 set ref 1919*
min_banner               55            based           bit(72)                  level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "iodc_" set ref 1726*
min_banner               17            based           bit(72)                  level 2 in structure "dcte" dcl 3-27 in procedure
                                                                                  "iodc_" ref 1726
minor_args               54            based           structure                level 2 packed packed unaligned dcl 4-25 set ref
                                                                                  1725*
minor_dev_index           0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-8 ref 880
minor_device_tab                       based           structure                level 1 dcl 5-58
minor_device_tab_offset
                         11            based           fixed bin(18,0)          level 2 dcl 7-23 ref 616
minor_idx                 4            based           fixed bin(17,0)          level 2 dcl 11-7 ref 1503
mod                                                    builtin function         dcl 308 ref 1116
mode                      2     000270 internal static bit(3)                   level 2 in structure "branch_info" packed packed
                                                                                  unaligned dcl 337 in procedure "iodc_" set ref
                                                                                  486*
mode                     10     000704 automatic       bit(36)                  level 2 in structure "ms_acl" dcl 339 in procedure
                                                                                  "iodc_" set ref 649*
modes                    10     000220 internal static bit(36)                  array level 2 in structure "dir_acl" dcl 325
                                                                                  in procedure "iodc_" set ref 417* 420*
modes                    10     000157 internal static bit(36)                  array level 2 in structure "acl" dcl 319
                                                                                  in procedure "iodc_" set ref 417* 420* 699*
mp                              000122 automatic       pointer                  dcl 2419 set ref 2462* 2470
ms_acl                          000704 automatic       structure                level 1 dcl 339 set ref 659 659
ms_id                     4            based           bit(72)                  array level 3 in structure "waiting_list" dcl 10-3
                                                                                  in procedure "iodc_" set ref 1804* 2001*
ms_id                     7     000620 automatic       bit(72)                  level 2 in structure "driver_mmi" dcl 330
                                                                                  in procedure "iodc_" set ref 1481*
ms_id                           000302 automatic       bit(72)                  dcl 177 in procedure "iodc_" set ref 1478* 1481
                                                                                  1489* 1869* 1887* 1926* 1953 2001
ms_id                     7     000652 automatic       bit(72)                  level 2 in structure "msg_mmi" dcl 332 in procedure
                                                                                  "iodc_" set ref 1887 1953*
ms_len                    6            based           fixed bin(24,0)          level 2 in structure "mseg_message_info" dcl 13-9
                                                                                  in procedure "iodc_" ref 1095
ms_len                    6     000652 automatic       fixed bin(24,0)          level 2 in structure "msg_mmi" dcl 332 in procedure
                                                                                  "iodc_" set ref 1926*
ms_ptr                    4            based           pointer                  level 2 in structure "mseg_message_info" dcl 13-9
                                                                                  in procedure "iodc_" ref 1096
ms_ptr                    4     000652 automatic       pointer                  level 2 in structure "msg_mmi" dcl 332 in procedure
                                                                                  "iodc_" set ref 1888
ms_ptr                    4     000620 automatic       pointer                  level 2 in structure "driver_mmi" dcl 330
                                                                                  in procedure "iodc_" set ref 1500 1544
mseg_index              154            based           fixed bin(17,0)          array level 3 dcl 15-28 set ref 1671* 1868
mseg_message_info                      based           structure                level 1 dcl 13-9
msg_mmi                         000652 automatic       structure                level 1 dcl 332 set ref 1872* 1876 1876 1950* 1955
                                                                                  1955
msg_time                               based           fixed bin(71,0)          level 2 dcl 16-12 set ref 1911*
n_acl                           000156 internal static fixed bin(17,0)          dcl 244 set ref 413* 698* 699 795* 1701
n_classes                              based           fixed bin(17,0)          level 2 dcl 3-20 ref 691 1551
n_devices                              based           fixed bin(17,0)          level 2 dcl 5-23 ref 679 2192 2311
n_minor                                based           fixed bin(17,0)          level 2 dcl 5-58 ref 909 1304 1592
n_q_groups                             based           fixed bin(17,0)          level 2 dcl 15-22 ref 652 2278
n_waiting                40            based           fixed bin(17,0)          level 2 dcl 3-27 set ref 1806* 1806 2034* 2034 2283
                                                                                  2286*
name                            001022 automatic       char(32)                 dcl 956 in procedure "get_device_name" set ref 958*
                                                                                  961* 962
name                                   based           char(24)                 level 2 in structure "qgte" dcl 15-28 in procedure
                                                                                  "iodc_" set ref 974 974 977 1583* 1649*
name                            001040 automatic       char(32)                 dcl 972 in procedure "get_class_name" set ref 974*
                                                                                  977* 978
nc                              000304 automatic       fixed bin(17,0)          dcl 178 set ref 2119*
new_driver                             constant        fixed bin(17,0)          initial dcl 277 ref 1448 1494
new_driver_id                   000305 automatic       char(32)                 dcl 179 set ref 1539* 1541 1542* 1555* 1573* 1580
                                                                                  1583* 1596* 1608* 1630* 1638* 1701
new_driver_msg                         based           structure                level 1 dcl 14-5
new_driver_msg_p                000740 automatic       pointer                  dcl 14-3 set ref 1544* 1545 1550 1591 1740
new_driver_series               000154 internal static fixed bin(17,0)          dcl 241 set ref 397* 1118* 1118 1120 1121* 1746*
                                                                                  1746 1747 1749* 2217
new_idx                         000315 automatic       fixed bin(17,0)          dcl 180 set ref 1982* 1984 1994* 1996 1999 2000 2001
                                                                                  2002 2013 2015 2018 2023 2025 2031
new_iwtp                        000316 automatic       pointer                  dcl 181 set ref 546* 559 572* 579
new_proc                        000472 constant        entry                    external dcl 119 ref 2049
next                      6            based           fixed bin(17,0)          array level 3 dcl 10-3 set ref 1780 1786* 1789*
                                                                                  1795* 1799* 1984 1999* 2009 2013* 2018* 2023*
next_done                43            based           fixed bin(18,0)          level 2 dcl 17-8 set ref 1035 1050 1238 1290 1299
                                                                                  2237
next_pending             54            based           fixed bin(18,0)          level 2 dcl 17-8 set ref 1016 1102* 1409*
next_ptr                        000320 automatic       pointer                  dcl 182 set ref 1037* 1039 1041 1043 1050
next_req                               constant        fixed bin(17,0)          initial dcl 11-32 ref 1527
nseries                         000322 automatic       fixed bin(17,0)          dcl 183 set ref 2217* 2218 2221 2222 2241 2265
null                                                   builtin function         dcl 308 ref 405 405 527 562 714 714 722 722 730 730
                                                                                  740 740 767 767 1728 1729 1730 1733 1734 1735 2077
                                                                                  2077 2083 2083 2437 2437 2487
num                                    parameter       fixed bin(35,0)          dcl 1327 in procedure "driver_ack" ref 1323 1334
num                       1            based           fixed bin(35,0)          level 2 in structure "ack_msg" dcl 6-18 in procedure
                                                                                  "iodc_" set ref 1334*
nx                              000323 automatic       fixed bin(17,0)          dcl 184 set ref 1775* 1776 1779 1779 1780* 1809
                                                                                  2004* 2005 2008 2008 2009* 2012* 2021 2029
open                    151            based           fixed bin(17,0)          level 2 dcl 15-28 set ref 669* 1645 1739* 2280
option                          000717 automatic       structure                level 1 dcl 352 set ref 1840*
orig_q                   10            based           fixed bin(17,0)          array level 3 dcl 10-3 set ref 1805* 2002*
out_len                         000324 automatic       fixed bin(17,0)          dcl 185 set ref 892* 1121* 1180* 1228* 1244* 1255*
                                                                                  1264* 1274* 1354* 1430* 1555* 1573* 1583* 1596*
                                                                                  1608* 1630* 1638* 1649* 1654* 1657* 1666* 1688*
                                                                                  1706* 1749* 2040* 2387* 2392* 2398* 2482* 2491*
out_msg                         000325 automatic       char(200)                packed unaligned dcl 186 set ref 892* 894* 912* 925*
                                                                                  932* 1121* 1123* 1180* 1181* 1228* 1231* 1244*
                                                                                  1245* 1255* 1257* 1264* 1265* 1274* 1276* 1354*
                                                                                  1355* 1430* 1431* 1555* 1557* 1573* 1583* 1596*
                                                                                  1608* 1630* 1638* 1654* 1657* 1658* 1666* 1668*
                                                                                  1688* 1689* 1706* 1708* 1749* 1752* 2040* 2040*
                                                                                  2043* 2362* 2387* 2392* 2398* 2403* 2482*
p                                      parameter       pointer                  dcl 783 in procedure "make" set ref 778 788* 790*
p                                      parameter       pointer                  dcl 843 in procedure "initiate" set ref 838 846*
                                                                                  849*
pending_request          33            based           fixed bin(18,0)          level 2 dcl 3-27 set ref 693* 1013 1015 1016* 1102
                                                                                  1104* 1409 1410*
per_queue_info          152            based           structure                array level 2 in structure "qgte" dcl 15-28
                                                                                  in procedure "iodc_"
per_queue_info           41            based           structure                array level 2 in structure "dcte" dcl 3-27
                                                                                  in procedure "iodc_"
pn                        0(05) 000717 automatic       bit(1)                   level 2 packed packed unaligned dcl 352 set ref
                                                                                  1844* 1848 1903
prev_seq_id              35            based           fixed bin(35,0)          level 2 dcl 17-8 set ref 1027*
print_devices                   000474 constant        entry                    external dcl 120 ref 2185
priority                               constant        fixed bin(17,0)          initial dcl 278 ref 1782 2000 2010
priv_upgrade_sw           1(03) 000270 internal static bit(1)                   level 3 packed packed unaligned dcl 337 set ref 484*
privileged_make_seg_            000476 constant        entry                    external dcl 121 ref 790
probe                           000500 constant        entry                    external dcl 123 ref 2164
proc_id                   2            based           bit(36)                  level 2 in structure "iodc_data" dcl 8-3
                                                                                  in procedure "iodc_" set ref 748*
proc_id                         000407 automatic       bit(36)                  dcl 187 in procedure "iodc_" set ref 876* 1336*
                                                                                  1369* 1473* 1613 1741 1759*
process_id               44            based           bit(36)                  level 2 dcl 5-29 set ref 681* 923 1076* 1108* 1396
                                                                                  1423* 1613 1613 1680 1741* 2194
ptr                                                    builtin function         dcl 308 ref 615 616 617 618 619 995 1015 1024 1037
                                                                                  1186 1292 1401 2226 2255
q                               000410 automatic       fixed bin(17,0)          dcl 188 set ref 652* 654* 1645* 1648 1649* 1654*
                                                                                  1671* 1774* 1775 1810 1811* 1867* 1868* 2002 2278*
                                                                                  2279*
q_group_tab                            based           structure                level 1 dcl 15-22
q_group_tab_offset       13            based           fixed bin(18,0)          level 2 dcl 7-23 ref 618
q_idx                           000411 automatic       fixed bin(17,0)          dcl 189 set ref 1650* 1663* 1671 1868* 1876* 1926*
                                                                                  1955*
q_name                          000412 automatic       char(32)                 dcl 190 set ref 1649* 1650* 1657* 1666*
qgte                                   based           structure                level 1 dcl 15-28
qgte_index               11            based           fixed bin(17,0)          level 2 dcl 3-27 ref 941 1220 1565 2201 2245
qgtep                           000742 automatic       pointer                  dcl 15-27 set ref 654* 656 658 669 941* 974 974 974
                                                                                  974 977 1220* 1565* 1580 1583 1645 1645 1648 1649
                                                                                  1671 1739 1770 1772 1772 1829 1833 1868 2201*
                                                                                  2245* 2279* 2280 2280 2280
qgtp                      2            based           pointer                  level 2 dcl 9-5 set ref 618* 652 654 941 1220 1565
                                                                                  2201 2245 2278 2279
queue_msg_hdr                          based           structure                level 1 dcl 16-12 set ref 1946 1973
queue_no                  7            based           fixed bin(17,0)          level 2 dcl 11-7 ref 1820 1831
quit                            000576 stack reference condition                dcl 286 ref 404
quit_flag                       000134 internal static bit(1)                   packed unaligned dcl 227 set ref 403* 2060 2075*
                                                                                  2081*
quota                    17     000270 internal static fixed bin(18,0)          level 2 in structure "branch_info" dcl 337
                                                                                  in procedure "iodc_" set ref 814* 817*
quota                           000422 automatic       fixed bin(17,0)          dcl 191 in procedure "iodc_" set ref 1682* 1685*
recursion_flag                  000022 internal static fixed bin(17,0)          dcl 222 set ref 407* 1131* 2480 2503*
rel                                                    builtin function         dcl 308 ref 1098 1410
req_area                               based           area(131096)             dcl 9-19 set ref 610*
req_desc_seg                           based           structure                level 1 dcl 9-21
req_id                   20            based           char(24)                 level 2 dcl 11-7 set ref 1911*
req_seg_ptr               6            based           pointer                  level 2 dcl 9-5 set ref 437* 607* 610
req_type_label                         based           char(32)                 level 2 dcl 4-25 set ref 1716*
reqp                            000424 automatic       pointer                  dcl 193 set ref 1888* 1899 1905 1907 1911 1924 1926*
                                                                                  1946 1973
request_descriptor                     based           structure                level 1 dcl 17-8 set ref 1062 1065* 1072 1092* 1092
request_no                6            based           fixed bin(17,0)          level 2 dcl 11-7 ref 1517
request_pending          46            based           bit(36)                  level 2 dcl 4-25 set ref 1100 1721*
restart                                constant        fixed bin(17,0)          initial dcl 11-30 ref 1250 1278 1287 1296 1515
restart_q                              constant        fixed bin(17,0)          initial dcl 11-33 ref 1524
restart_req              34            based           fixed bin(18,0)          level 2 dcl 3-27 set ref 693* 1022 1024 1028* 1045*
                                                                                  1250 1278* 2253 2255
restarted                53(02)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref
                                                                                  1026*
reterr                   12     000704 automatic       fixed bin(35,0)          level 2 dcl 339 set ref 662
retry                           000423 automatic       fixed bin(17,0)          dcl 192 set ref 1871* 1877 1882* 1925* 1930 1934*
                                                                                  1949* 1956 1961*
return_label                    000142 internal static label variable           dcl 229 set ref 391* 2148 2175
rings                     3     000270 internal static fixed bin(3,0)           array level 2 dcl 337 set ref 488* 488* 488* 550
rqti_ptr                 64            based           pointer                  level 2 dcl 4-25 set ref 1728*
rtrim                                                  builtin function         dcl 308 ref 379 958 974 1541 1891 2120
save                                   constant        fixed bin(17,0)          initial dcl 11-31 ref 1169 1515
save_first_req_p         12            based           pointer                  level 2 dcl 9-5 set ref 441* 623*
save_request_                   000502 constant        entry                    external dcl 124 ref 1005 1404
save_request_$init              000504 constant        entry                    external dcl 125 ref 675
saved                    53(05)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref
                                                                                  1041* 1093* 1147 1150* 1150 1284* 1295*
scu                      30            based           bit(36)                  array level 2 packed packed unaligned dcl 12-12 set
                                                                                  ref 2489
scu_msg                         000023 internal static char(120)                initial packed unaligned dcl 224 set ref 2047 2047*
                                                                                  2491* 2497*
scup                            000736 automatic       pointer                  dcl 12-54 set ref 2489* 2491 2491 2491 2491 2491
                                                                                  2491 2491 2491
seg_name                        000426 automatic       char(32)                 dcl 194 set ref 501* 502* 505* 512* 514* 515* 528*
                                                                                  529* 543* 546* 552* 555* 572* 587* 588* 595* 596*
                                                                                  600* 606* 637*
sender_authorization     25     000652 automatic       bit(72)                  level 2 in structure "msg_mmi" dcl 332 in procedure
                                                                                  "iodc_" set ref 1917
sender_authorization     25     000620 automatic       bit(72)                  level 2 in structure "driver_mmi" dcl 330
                                                                                  in procedure "iodc_" set ref 1543
sender_class                    000436 automatic       char(32)                 dcl 195 set ref 944* 1223* 1255* 1274* 1568* 1573*
                                                                                  1608* 1716 1749* 2203* 2204* 2246* 2249* 2285*
                                                                                  2286*
sender_device                   000446 automatic       char(32)                 dcl 196 set ref 892* 943* 1121* 1216* 1311* 1603*
                                                                                  1608* 1638* 1706* 1717 1749* 2202* 2204*
sender_id                13     000620 automatic       char(32)                 level 2 in structure "driver_mmi" packed packed
                                                                                  unaligned dcl 330 in procedure "iodc_" set ref
                                                                                  1539
sender_id                       000456 automatic       char(32)                 dcl 197 in procedure "iodc_" set ref 1890* 1891
                                                                                  1892* 1892 1895
sender_id                13     000652 automatic       char(32)                 level 2 in structure "msg_mmi" packed packed
                                                                                  unaligned dcl 332 in procedure "iodc_" set ref
                                                                                  1890
sending_proc              4            based           bit(36)                  level 2 packed packed unaligned dcl 314 ref 876 923
                                                                                  1473
seq_id                   21            based           fixed bin(35,0)          level 2 in structure "mdte" dcl 5-64 in procedure
                                                                                  "iodc_" set ref 1089 1120* 1125* 1307 1747* 2204*
seq_id                          000466 automatic       fixed bin(35,0)          dcl 198 in procedure "iodc_" set ref 1160* 1166*
                                                                                  1183 1188 1244* 1262 1264* 1272* 1274* 1312* 1317*
                                                                                  1517*
seq_id                   32            based           fixed bin(35,0)          level 2 in structure "request_descriptor" dcl 17-8
                                                                                  in procedure "iodc_" set ref 1027 1034 1039 1089*
                                                                                  1116 1125 1188 1188 1262 1272 1293 1413 2227 2231
                                                                                  2234 2256 2256*
seq_id                    1            based           fixed bin(35,0)          level 2 in structure "ev_msg" dcl 6-8 in procedure
                                                                                  "iodc_" ref 1160 1166
series_id                       000467 automatic       fixed bin(35,0)          dcl 199 set ref 1034* 1039 1183* 1188 1293 1307
                                                                                  2227* 2229 2231 2232 2234 2235 2235 2241* 2242
                                                                                  2244 2249 2249 2249 2256*
series_info                            based           structure                array level 1 dcl 345 set ref 2221 2265
series_restart           53(07)        based           bit(1)                   level 3 packed packed unaligned dcl 17-8 set ref
                                                                                  1032 1043* 1287* 1296*
series_sw                       000470 automatic       bit(1)                   dcl 200 set ref 1157* 1163* 1267 1274* 1285 1518*
                                                                                  1520*
set_lock_$lock                  000506 constant        entry                    external dcl 126 ref 1617
sig_type                        000471 automatic       fixed bin(17,0)          dcl 201 set ref 889* 890 890 892* 899 1008 1169 1250
                                                                                  1278 1287 1296 1513* 1515 1515 1524 1527
signal_                         000510 constant        entry                    external dcl 127 ref 2171
sip                             000472 automatic       pointer                  dcl 202 set ref 2221* 2222 2229 2231 2232 2234 2235
                                                                                  2235 2242 2244 2249 2249 2249 2265
stac                                                   builtin function         dcl 308 ref 1100
start                           000474 automatic       fixed bin(17,0)          dcl 203 set ref 1828* 1831* 1833 1867
stat_p                          000314 internal static pointer                  initial dcl 9-3 set ref 393* 427* 428* 430 437 441
                                                                                  441 442 442 443 596 601 604 607 610 618 619 620
                                                                                  621 622 622 623 623 624 652 654 674* 675* 691 692
                                                                                  737 740 764 766 769 939 941 995 1015 1024 1037
                                                                                  1062 1072 1185 1186 1217 1220 1292 1400 1401 1551
                                                                                  1562 1565 1765 1773 1978 2199 2201 2224 2226 2244
                                                                                  2245 2255 2278 2279 2282
state                    67            based           fixed bin(17,0)          level 2 in structure "queue_msg_hdr" dcl 16-12
                                                                                  in procedure "iodc_" set ref 1924*
state                     7            based           fixed bin(17,0)          array level 3 in structure "waiting_list" dcl 10-3
                                                                                  in procedure "iodc_" set ref 1782 1802* 2000* 2010
static_idtp                     000014 internal static pointer                  dcl 217 set ref 615* 679 680 920 1310 1602 2192 2193
                                                                                  2311 2312
static_mdtp                     000016 internal static pointer                  dcl 218 set ref 616* 909 917 1212 1304 1306 1395
                                                                                  1592 1600 2196
status_flags             47            based           structure                level 2 dcl 4-25
string                                                 builtin function         dcl 308 set ref 1840*
subdir                          000475 automatic       char(168)                dcl 204 set ref 387* 430* 437* 588* 596* 601* 607*
                                                                                  1698* 1699* 1700* 1702*
substr                                                 builtin function         dcl 308 set ref 387 1542* 1605 1699* 1700* 1892 2304
switches                  1     000270 internal static structure                level 2 packed packed unaligned dcl 337
sys_area                               based           area(65560)              dcl 303 ref 1946 1973 2221 2265
sysdir                          000061 internal static char(168)                dcl 225 set ref 378* 379 382* 387 450* 461* 464*
                                                                                  495* 502* 515* 529* 546* 552* 628* 638* 642* 659*
                                                                                  821* 833* 1425* 1430* 1650* 1657* 1698 2185* 2335*
sysdir_class                    000150 internal static bit(72)                  dcl 235 set ref 461* 814*
sysdir_len                      000147 internal static fixed bin(17,0)          dcl 233 set ref 379* 380 387 1699 1700
system_high                     000550 automatic       bit(72)                  dcl 205 set ref 471* 472*
system_info_$access_ceiling     000512 constant        entry                    external dcl 128 ref 471
system_privilege_$initiate_count
                                000514 constant        entry                    external dcl 130 ref 849
test_bit                               parameter       bit(1)                   dcl 371 ref 363 390 512
test_iod_tables                        parameter       char                     packed unaligned dcl 372 ref 363 512 512
testing                         000133 internal static bit(1)                   packed unaligned dcl 226 set ref 390* 469 788 846
                                                                                  2060 2130 2148 2154 2161 2168 2175 2324 2344 2455
                                                                                  2473
text_offset                            based           structure                level 1 packed packed unaligned dcl 7-45
text_strings_offset      15            based           fixed bin(18,0)          level 2 dcl 7-23 ref 617
text_strings_ptr                000732 automatic       pointer                  dcl 7-38 set ref 617*
time_interval            16            based           fixed bin(71,0)          level 2 dcl 9-5 set ref 620*
timer_chan               22            based           fixed bin(71,0)          level 2 dcl 9-5 set ref 737* 740* 764* 766* 769*
timer_manager_$reset_alarm_wakeup
                                000516 constant        entry                    external dcl 133 ref 764
two                                    based           structure                level 1 dcl 2382
type                      2            based           fixed bin(17,0)          level 2 dcl 11-7 ref 1513
type_ext                  3            based           bit(36)                  level 2 dcl 11-7 ref 1518 1840
unbit                           000552 automatic       bit(1)                   dcl 206 set ref 1663* 1664
unique_bits_                    000520 constant        entry                    external dcl 135 ref 543 543
unique_chars_                   000522 constant        entry                    external dcl 136 ref 543
unspec                                                 builtin function         dcl 308 set ref 1065* 1478 1479* 1715* 1872* 1950*
unthread_descriptor_            000524 constant        entry                    external dcl 137 ref 1025
unthread_descriptor_$init       000526 constant        entry                    external dcl 138 ref 428
user_id                  10            based           char(32)                 level 2 in structure "iodd_comm" dcl 11-7
                                                                                  in procedure "iodc_" ref 1839
user_id                         000553 automatic       char(32)                 dcl 207 in procedure "iodc_" set ref 1839* 1895
userid                    6     000270 internal static char(32)                 level 2 dcl 337 set ref 489*
version                         000652 automatic       char(8)                  level 2 in structure "msg_mmi" dcl 332 in procedure
                                                                                  "iodc_" set ref 1874* 1952*
version                   2     000126 automatic       fixed bin(17,0)          level 2 in structure "local_condition_info" dcl 2433
                                                                                  in procedure "iodc_handler" set ref 2435*
version                         000270 internal static fixed bin(17,0)          level 2 in structure "branch_info" dcl 337
                                                                                  in procedure "iodc_" set ref 480*
version                         000620 automatic       char(8)                  level 2 in structure "driver_mmi" dcl 330
                                                                                  in procedure "iodc_" set ref 1480*
version                                based           char(8)                  level 2 in structure "iod_tables_hdr" dcl 7-23
                                                                                  in procedure "iodc_" ref 520 539
w                                      based           fixed bin(17,0)          array dcl 2430 set ref 2491* 2491* 2491* 2491* 2491*
                                                                                  2491* 2491* 2491*
wait_list_ptr             4            based           pointer                  level 2 dcl 9-5 set ref 596* 1765 1978
waiting_list                           based           structure                level 1 dcl 10-3
wakeup_chan                            based           fixed bin(71,0)          level 2 dcl 14-5 ref 1545
wc_ptr                   16     000126 automatic       pointer                  level 2 dcl 2433 set ref 2462*
wcode                                  parameter       fixed bin(35,0)          dcl 2378 set ref 2373 2387 2390 2390 2401 2401*
                                                                                  2403*
wlp                             000564 automatic       pointer                  dcl 208 set ref 1765* 1780 1782 1786 1789 1793 1795
                                                                                  1796 1796 1799 1799 1800 1802 1804 1805 1978* 1980
                                                                                  1982 1984 1984 1988 1994 1996 1999 2000 2001 2002
                                                                                  2009 2010 2013 2018 2023
word1                                  based           fixed bin(17,0)          level 2 dcl 2382 set ref 2398*
word2                     1            based           fixed bin(17,0)          level 2 dcl 2382 set ref 2398*
wp                              001064 automatic       pointer                  dcl 2379 set ref 2397* 2398 2398
x                               000566 automatic       fixed bin(17,0)          dcl 209 set ref 1779* 1780 1782 1784 1786 1788 1789
                                                                                  1793 1795 1799 1800 1802 1804 1805* 2008* 2009
                                                                                  2010 2013 2023 2028*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 13-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 13-38
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 13-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 13-38
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 16-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 16-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 16-47
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 16-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 16-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 16-41
abx                                    internal static fixed bin(17,0)          initial dcl 12-42
apx                                    internal static fixed bin(17,0)          initial dcl 12-42
bbx                                    internal static fixed bin(17,0)          initial dcl 12-42
bpx                                    internal static fixed bin(17,0)          initial dcl 12-42
condition_info_ptr                     automatic       pointer                  dcl 1-10
dctp                                   automatic       pointer                  dcl 3-19
driver_status_ptr                      automatic       pointer                  dcl 4-24
idtp                                   automatic       pointer                  dcl 5-22
lbx                                    internal static fixed bin(17,0)          initial dcl 12-42
lpx                                    internal static fixed bin(17,0)          initial dcl 12-42
mcp                                    automatic       pointer                  dcl 12-10
mdtp                                   automatic       pointer                  dcl 5-57
mseg_message_info_ptr                  automatic       pointer                  dcl 13-7
qgtp                                   automatic       pointer                  dcl 15-21
queue_msg_hdr_version_1                internal static fixed bin(17,0)          initial dcl 16-37
sbx                                    internal static fixed bin(17,0)          initial dcl 12-42
scu                                    based           structure                level 1 dcl 12-56
scux                                   based           structure                level 1 dcl 12-207
spx                                    internal static fixed bin(17,0)          initial dcl 12-42
text_strings                           based           structure                level 1 dcl 7-39

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_driver_cmd                007574 constant        label                    dcl 1534 ref 1502
area_handler                    016061 constant        entry                    internal dcl 2352 ref 1061
ask                             012641 constant        label                    dcl 2107 ref 2122 2132 2145 2158 2165 2172 2186 2212
                                                                                  2272 2294 2308 2316 2321 2336 2341 2349
back                            005044 constant        label                    dcl 756 ref 391
bad_cmd                         014227 constant        label                    dcl 2339 set ref 2152 2180
bad_new_driver                  007706 constant        label                    dcl 1557 ref 1575 1585 1597 1610 1632 1640
bad_req                         007532 constant        label                    dcl 1508 ref 1531 1836 1851 1859 1971 1992
bad_signal                      005206 constant        label                    dcl 894 ref 884
check_wakeup_code               016103 constant        entry                    internal dcl 2373 ref 1077 1111 1371 1760
clean_up                        014352 constant        entry                    internal dcl 761 ref 408 756
command_level                   012575 constant        entry                    external dcl 2089
create_branch                   014760 constant        label                    dcl 821 ref 828
driver_ack                      015551 constant        entry                    internal dcl 1323 ref 1233 1312 1317 1465 1508 1534
                                                                                  1816 2036
driver_command                  007264 constant        entry                    external dcl 1452
driver_signal                   005054 constant        entry                    external dcl 857
forget_it                       003105 constant        label                    dcl 507 ref 384 392 455 465 496 523 556 569 577 634
                                                                                  665 683 712
found_desc                      006264 constant        label                    dcl 1250 ref 1188 1224
found_next_request              012276 constant        label                    dcl 1973 ref 1940
free_device                     007006 constant        entry                    external dcl 1377
get_class_name                  015420 constant        entry                    internal dcl 969 ref 944 1223 1568 2203 2246 2285
get_device_name                 015332 constant        entry                    internal dcl 953 ref 943 1216 1311 1603 2202
identify_sender                 015231 constant        entry                    internal dcl 904 ref 883 1505
initiate                        015072 constant        entry                    internal dcl 838 ref 430 437 515 529
iodc_                           001673 constant        entry                    external dcl 14
iodc_handler                    016270 constant        entry                    internal dcl 2410 ref 409
iodc_init                       001705 constant        entry                    external dcl 363
iodc_return                     005665 constant        label                    dcl 1129 ref 875 896 997 1008 1081 1105 1235 1319
                                                                                  1357 1374 1471 1487 1510 1536 1762 1817 2037
make                            014514 constant        entry                    internal dcl 778 ref 502 546 588 596 601 607 1702
make_dir                        014712 constant        entry                    internal dcl 802 ref 492 1685
make_new_driver                 007607 constant        label                    dcl 1539 ref 1494
make_pending                    005532 constant        label                    dcl 1102 ref 1112
new_driver                      007252 constant        entry                    external dcl 1440
new_series                      005577 constant        label                    dcl 1118 set ref 1313
next_msg                        012217 constant        label                    dcl 1946 ref 1895 1899 1905 1907 1911 1938
next_request                    011576 constant        label                    dcl 1820 ref 1527
no_init                         003051 constant        label                    dcl 505 set ref 516 533 547 589 597 602 608 640 644
no_ipc                          004521 constant        label                    dcl 709 ref 715 720 723 728 731 738 742
no_purge                        002320 constant        label                    dcl 431 ref 438
no_restartable                  013665 constant        label                    dcl 2267 ref 2218
not_after_quit                  014265 constant        label                    dcl 2344 ref 2297 2324
pass_on                         016334 constant        label                    dcl 2447 ref 2451 2453 2455 2458
proc_dies                       012465 constant        label                    dcl 2040 ref 2363 2500
quit_handler                    015635 constant        entry                    internal dcl 2052 ref 404
read_comm_msg                   007273 constant        label                    dcl 1460 ref 1449
restart_or_save                 005714 constant        label                    dcl 1169 ref 1161 1521
restart_queue                   011412 constant        label                    dcl 1765 ref 1524
retry1                          011740 constant        label                    dcl 1872 ref 1883
retry2                          012222 constant        label                    dcl 1950 set ref 1962
retry3                          012161 constant        label                    dcl 1926 ref 1935
sig_label                       000000 constant        label                    array(0:5) dcl 983 ref 899
tell_driver                     006654 constant        label                    dcl 1317 ref 1247 1259 1267
update                          003316 constant        label                    dcl 543 ref 530 539
update_descriptor               015506 constant        entry                    internal dcl 1141 ref 999 1403
wake_driver                     011363 constant        label                    dcl 1755 ref 1559 1625 1660 1692 1710

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     20350       21160   16763       20360
Length     22410   16763       610        1214    1364         306

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iodc_                               892 external procedure  is an external procedure.  
on unit on line 404                  64 on unit               
on unit on line 408                  64 on unit               
on unit on line 409                 236 on unit               
clean_up                             96 internal procedure  is called by several nonquick procedures.  
make                                    internal procedure  shares stack frame of external procedure iodc_.  
make_dir                                internal procedure  shares stack frame of external procedure iodc_.  
initiate                                internal procedure  shares stack frame of external procedure iodc_.  
on unit on line 867                  68 on unit               
identify_sender                         internal procedure  shares stack frame of external procedure iodc_.  
get_device_name                         internal procedure  shares stack frame of external procedure iodc_.  
get_class_name                          internal procedure  shares stack frame of external procedure iodc_.  
on unit on line 1061                 70 on unit               
update_descriptor                       internal procedure  shares stack frame of external procedure iodc_.  
driver_ack                           90 internal procedure  is called by several nonquick procedures.  
on unit on line 1463                 74 on unit               
quit_handler                        120 internal procedure  enables or reverts conditions.  
on unit on line 2068                 68 on unit               
on unit on line 2100                 68 on unit               
area_handler                            internal procedure  shares stack frame of on unit on line 1061.  
check_wakeup_code                       internal procedure  shares stack frame of external procedure iodc_.  
iodc_handler                            internal procedure  shares stack frame of on unit on line 409.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 areap                       iodc_
000012 driver_sig_chan             iodc_
000014 static_idtp                 iodc_
000016 static_mdtp                 iodc_
000020 driver_cmd_chan             iodc_
000022 recursion_flag              iodc_
000023 scu_msg                     iodc_
000061 sysdir                      iodc_
000133 testing                     iodc_
000134 quit_flag                   iodc_
000136 err_label                   iodc_
000142 return_label                iodc_
000146 comm_mseg_idx               iodc_
000147 sysdir_len                  iodc_
000150 sysdir_class                iodc_
000152 initialized                 iodc_
000153 coord_proc_id               iodc_
000154 new_driver_series           iodc_
000155 com_level                   iodc_
000156 n_acl                       iodc_
000157 acl                         iodc_
000220 dir_acl                     iodc_
000244 coord_static                iodc_
000270 branch_info                 iodc_
000314 stat_p                      iodc_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
driver_ack               000100 ec                          driver_ack
iodc_                    000100 ack_chan                    iodc_
                         000102 area_flag                   iodc_
                         000104 auth                        iodc_
                         000106 bc                          iodc_
                         000110 chan_name                   iodc_
                         000112 cmd                         iodc_
                         000120 code                        iodc_
                         000121 code2                       iodc_
                         000122 copy_ptr                    iodc_
                         000124 copy_words                  iodc_
                         000126 cwtp                        iodc_
                         000130 dcx                         iodc_
                         000131 desc_off                    iodc_
                         000132 desc_ptr                    iodc_
                         000134 dev_id                      iodc_
                         000144 dir_quota                   iodc_
                         000146 dr_ptr                      iodc_
                         000150 entry_type                  iodc_
                         000152 ev_info_ptr                 iodc_
                         000154 finish                      iodc_
                         000155 fwx                         iodc_
                         000156 i                           iodc_
                         000157 idtx                        iodc_
                         000160 iodc_data_ptr               iodc_
                         000162 iwtp                        iodc_
                         000164 iwtrb                       iodc_
                         000167 len                         iodc_
                         000170 line                        iodc_
                         000214 lwx                         iodc_
                         000215 mask_code                   iodc_
                         000216 match_dir                   iodc_
                         000270 match_ent                   iodc_
                         000300 mdtx                        iodc_
                         000301 message_len                 iodc_
                         000302 ms_id                       iodc_
                         000304 nc                          iodc_
                         000305 new_driver_id               iodc_
                         000315 new_idx                     iodc_
                         000316 new_iwtp                    iodc_
                         000320 next_ptr                    iodc_
                         000322 nseries                     iodc_
                         000323 nx                          iodc_
                         000324 out_len                     iodc_
                         000325 out_msg                     iodc_
                         000407 proc_id                     iodc_
                         000410 q                           iodc_
                         000411 q_idx                       iodc_
                         000412 q_name                      iodc_
                         000422 quota                       iodc_
                         000423 retry                       iodc_
                         000424 reqp                        iodc_
                         000426 seg_name                    iodc_
                         000436 sender_class                iodc_
                         000446 sender_device               iodc_
                         000456 sender_id                   iodc_
                         000466 seq_id                      iodc_
                         000467 series_id                   iodc_
                         000470 series_sw                   iodc_
                         000471 sig_type                    iodc_
                         000472 sip                         iodc_
                         000474 start                       iodc_
                         000475 subdir                      iodc_
                         000550 system_high                 iodc_
                         000552 unbit                       iodc_
                         000553 user_id                     iodc_
                         000564 wlp                         iodc_
                         000566 x                           iodc_
                         000620 driver_mmi                  iodc_
                         000652 msg_mmi                     iodc_
                         000704 ms_acl                      iodc_
                         000717 option                      iodc_
                         000720 dctep                       iodc_
                         000722 idtep                       iodc_
                         000724 mdtep                       iodc_
                         000726 event_message               iodc_
                         000730 ithp                        iodc_
                         000732 text_strings_ptr            iodc_
                         000734 comm_ptr                    iodc_
                         000736 scup                        iodc_
                         000740 new_driver_msg_p            iodc_
                         000742 qgtep                       iodc_
                         001022 name                        get_device_name
                         001040 name                        get_class_name
                         001064 wp                          check_wakeup_code
                         001066 code                        check_wakeup_code
on unit on line 409      000106 conname                     iodc_handler
                         000116 ec                          iodc_handler
                         000120 ap                          iodc_handler
                         000122 mp                          iodc_handler
                         000124 m_len                       iodc_handler
                         000126 local_condition_info        iodc_handler
quit_handler             000100 mask_code                   quit_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           tra_ext_2           stac_mac            mdfx1
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           op_alloc_
op_freen_           op_empty_           verify_for_rtrim

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$equal              aim_check_$greater_or_equal   com_err_                      condition_interpreter_
continue_to_signal_           convert_ipc_code_             debug                         delete_$path
expand_pathname_              find_condition_info_          find_next_request_            find_next_request_$init
free_oldest_request_$cleanup  free_oldest_request_$force    free_oldest_request_$init     get_authorization_
get_group_id_$tag_star        get_process_id_               get_ring_                     get_system_free_area_
hcs_$chname_seg               hcs_$create_branch_           hcs_$delentry_seg             hcs_$get_access_class
hcs_$initiate_count           hcs_$make_seg                 hcs_$replace_acl              hcs_$replace_dir_acl
hcs_$set_ring_brackets        hcs_$terminate_noname         hcs_$wakeup                   ioa_
ioa_$ioa_stream               ioa_$ioa_stream_nnl           ioa_$rsnnl                    iod_overseer_$coord_ready
iodc_$command_level           iodc_$free_device             iodc_message_                 iodc_message_$init
iodc_message_$loud            iodd_$iodd_init               iox_$control                  iox_$get_line
ipc_$create_ev_chn            ipc_$decl_ev_call_chn         ipc_$delete_ev_chn            ipc_$drain_chn
ipc_$mask_ev_calls            ipc_$unmask_ev_calls          logout                        match_request_id_
message_segment_$check_salv_bit_index                       message_segment_$create       message_segment_$delete
message_segment_$delete_index message_segment_$ms_acl_add   message_segment_$open
message_segment_$read_message_index                         message_segment_$update_message_index
new_proc                      print_devices                 privileged_make_seg_          probe
save_request_                 save_request_$init            set_lock_$lock                signal_
system_info_$access_ceiling   system_privilege_$initiate_count
timer_manager_$reset_alarm_wakeup                           unique_bits_                  unique_chars_
unthread_descriptor_          unthread_descriptor_$init

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$ai_above_allowed_max
error_table_$ai_restricted    error_table_$argerr           error_table_$bad_segment
error_table_$invalid_lock_reset                             error_table_$invalid_move_qmax
error_table_$namedup          error_table_$noentry          error_table_$pathlong
error_table_$request_not_recognized                         error_table_$segknown
free_oldest_request_$free_oldest_request_                   iodc_$driver_command          iodc_$driver_signal
iodc_$new_driver              iox_$user_input               iox_$user_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 001672       363 001700       374 001725       376 001731       378 001751       379 001760       380 001772
    382 001774       384 002027       387 002030       390 002044       391 002050       392 002053       393 002056
    395 002060       397 002066       398 002070       402 002072       403 002073       404 002074       405 002116
    407 002150       408 002152       409 002174       413 002212       415 002215       417 002232       419 002235
    420 002243       427 002246       428 002254       430 002263       431 002316       437 002352       438 002404
    441 002406       442 002413       443 002416       444 002422       445 002426       450 002427       451 002467
    454 002474       455 002526       461 002527       462 002554       464 002556       465 002603       468 002604
    469 002613       471 002616       472 002624       480 002673       481 002676       482 002700       483 002702
    484 002704       485 002706       486 002710       487 002714       488 002716       489 002731       490 002734
    492 002735       493 002751       495 002753       496 003016       501 003017       502 003022       503 003047
    505 003051       507 003105       509 003132       512 003133       514 003151       515 003154       516 003201
    518 003203       520 003206       522 003213       523 003244       527 003245       528 003247       529 003252
    530 003277       533 003304       539 003305       541 003312       543 003316       546 003345       547 003372
    550 003374       551 003377       552 003402       553 003426       555 003430       556 003464       559 003465
    562 003474       564 003500       566 003511       568 003513       569 003543       572 003544       574 003574
    576 003576       577 003626       579 003627       582 003631       587 003642       588 003645       589 003650
    591 003652       593 003661       595 003672       596 003675       597 003723       600 003725       601 003730
    602 003763       604 003765       606 003773       607 003776       608 004030       610 004032       615 004037
    616 004045       617 004051       618 004055       619 004062       620 004066       621 004071       622 004073
    623 004075       624 004077       628 004101       630 004125       633 004132       634 004161       637 004162
    638 004165       640 004212       642 004214       644 004245       649 004247       650 004251       652 004253
    654 004265       656 004273       658 004277       659 004302       660 004342       662 004344       664 004351
    665 004400       669 004401       670 004403       674 004405       675 004414       679 004423       680 004433
    681 004440       682 004441       683 004451       686 004453       691 004455       692 004467       693 004475
    694 004477       698 004501       699 004504       706 004507       707 004517       709 004521       711 004530
    712 004560       714 004561       715 004606       717 004610       719 004612       720 004623       722 004625
    723 004652       725 004654       727 004657       728 004667       730 004671       731 004716       733 004720
    737 004723       738 004734       740 004736       742 004764       748 004766       750 005002       751 005004
    752 005032       753 005037       756 005044       758 005050       857 005051       866 005061       867 005063
    869 005077       871 005110       872 005111       874 005120       875 005124       876 005130       880 005132
    883 005136       884 005140       889 005142       890 005146       892 005153       894 005206       896 005232
    899 005233       983 005234       995 005237       996 005244       997 005247       999 005252      1001 005253
   1005 005255      1008 005266      1013 005270      1015 005273      1016 005300      1017 005302      1022 005303
   1024 005305      1025 005312      1026 005320      1027 005323      1028 005325      1032 005327      1034 005332
   1035 005335      1036 005337      1037 005342      1039 005347      1041 005353      1043 005355      1045 005357
   1047 005362      1048 005363      1050 005364      1051 005366      1053 005367      1060 005370      1061 005371
   1062 005407      1063 005417      1065 005420      1067 005423      1072 005441      1074 005443      1076 005447
   1077 005467      1081 005473      1089 005474      1090 005502      1092 005504      1093 005510      1095 005512
   1096 005514      1098 005520      1100 005523      1102 005532      1104 005536      1105 005540      1108 005541
   1109 005561      1111 005563      1112 005565      1115 005566      1116 005571      1118 005577      1120 005602
   1121 005605      1123 005636      1124 005662      1125 005663      1129 005665      1131 005674      1132 005676
   1157 005677      1159 005701      1160 005703      1161 005705      1163 005706      1165 005710      1166 005712
   1169 005714      1178 005723      1180 005726      1181 005761      1183 006005      1185 006010      1186 006016
   1188 006023      1208 006035      1212 006047      1213 006054      1216 006063      1217 006065      1220 006075
   1223 006103      1224 006105      1226 006106      1228 006110      1231 006140      1232 006164      1233 006167
   1235 006200      1238 006201      1244 006204      1245 006234      1246 006260      1247 006263      1250 006264
   1255 006272      1257 006322      1258 006346      1259 006351      1262 006352      1264 006356      1265 006406
   1266 006432      1267 006435      1271 006440      1272 006441      1274 006444      1276 006510      1278 006534
   1284 006542      1285 006545      1287 006550      1290 006555      1292 006562      1293 006567      1295 006573
   1296 006575      1299 006602      1304 006605      1306 006615      1307 006622      1310 006631      1311 006636
   1312 006640      1313 006651      1315 006652      1317 006654      1319 006664      1347 006665      1352 006676
   1354 006700      1355 006730      1357 006754      1363 006755      1369 006760      1371 006775      1374 007001
   1377 007002      1390 007013      1394 007017      1395 007027      1396 007034      1400 007044      1401 007052
   1402 007057      1403 007062      1404 007063      1409 007101      1410 007105      1411 007110      1413 007112
   1417 007114      1420 007116      1421 007117      1423 007121      1425 007124      1427 007157      1430 007164
   1431 007217      1432 007242      1433 007243      1435 007244      1437 007247      1440 007250      1448 007257
   1449 007261      1452 007262      1458 007271      1460 007273      1462 007275      1463 007277      1465 007313
   1467 007325      1469 007337      1470 007340      1471 007347      1472 007353      1473 007357      1478 007361
   1479 007364      1480 007367      1481 007371      1482 007374      1483 007376      1484 007414      1486 007416
   1487 007444      1489 007445      1491 007460      1494 007510      1500 007513      1501 007515      1502 007517
   1503 007523      1505 007526      1506 007530      1508 007532      1510 007543      1513 007544      1515 007547
   1517 007553      1518 007555      1520 007561      1521 007563      1524 007564      1527 007566      1530 007570
   1531 007573      1534 007574      1536 007606      1539 007607      1541 007612      1542 007624      1543 007634
   1544 007637      1545 007641      1550 007643      1551 007646      1554 007654      1555 007656      1557 007706
   1559 007732      1562 007733      1565 007737      1568 007745      1570 007747      1572 007766      1573 007770
   1575 010023      1580 010024      1582 010031      1583 010033      1585 010067      1591 010070      1592 010073
   1595 010100      1596 010102      1597 010132      1600 010133      1601 010137      1602 010141      1603 010145
   1605 010147      1607 010155      1608 010157      1610 010215      1613 010216      1617 010223      1619 010237
   1621 010244      1622 010255      1624 010257      1625 010261      1627 010262      1629 010263      1630 010265
   1632 010320      1634 010321      1635 010322      1637 010325      1638 010327      1640 010362      1645 010363
   1648 010375      1649 010403      1650 010435      1652 010462      1654 010464      1657 010522      1658 010560
   1659 010603      1660 010605      1663 010606      1664 010625      1666 010630      1668 010660      1671 010704
   1672 010712      1680 010714      1682 010717      1684 010725      1685 010733      1686 010762      1688 010764
   1689 011014      1691 011037      1692 011041      1698 011042      1699 011046      1700 011052      1701 011064
   1702 011072      1704 011116      1706 011120      1708 011150      1709 011173      1710 011175      1715 011176
   1716 011202      1717 011205      1718 011210      1719 011214      1720 011220      1721 011223      1722 011224
   1723 011226      1724 011230      1725 011232      1726 011234      1728 011240      1729 011242      1730 011243
   1731 011244      1732 011247      1733 011252      1734 011253      1735 011254      1739 011255      1740 011260
   1741 011264      1742 011266      1743 011271      1744 011273      1745 011275      1746 011276      1747 011300
   1749 011302      1752 011337      1755 011363      1757 011365      1759 011370      1760 011405      1762 011411
   1765 011412      1770 011416      1772 011433      1773 011443      1774 011451      1775 011457      1776 011463
   1778 011464      1779 011466      1780 011472      1782 011477      1784 011504      1786 011511      1788 011516
   1789 011517      1791 011520      1793 011521      1795 011524      1796 011525      1797 011527      1799 011530
   1800 011532      1802 011534      1804 011535      1805 011540      1806 011541      1809 011544      1810 011547
   1811 011555      1813 011557      1814 011561      1816 011563      1817 011575      1820 011576      1828 011600
   1829 011602      1830 011605      1831 011606      1833 011610      1835 011617      1836 011622      1839 011623
   1840 011626      1842 011630      1844 011633      1845 011635      1846 011640      1847 011644      1848 011645
   1850 011650      1851 011700      1853 011702      1855 011703      1856 011711      1858 011714      1859 011717
   1865 011720      1867 011721      1868 011731      1869 011735      1871 011737      1872 011740      1874 011743
   1875 011745      1876 011747      1877 011766      1882 011775      1883 011777      1886 012000      1887 012002
   1888 012005      1890 012007      1891 012012      1892 012024      1895 012030      1899 012034      1903 012044
   1905 012047      1907 012054      1911 012060      1917 012110      1919 012113      1922 012136      1924 012155
   1925 012160      1926 012161      1928 012200      1930 012202      1934 012207      1935 012211      1938 012212
   1940 012213      1942 012214      1946 012217      1949 012221      1950 012222      1952 012225      1953 012227
   1954 012232      1955 012234      1956 012253      1961 012262      1962 012264      1964 012265      1965 012266
   1969 012270      1971 012275      1973 012276      1978 012300      1980 012304      1982 012306      1984 012307
   1986 012312      1988 012313      1990 012316      1991 012344      1992 012347      1994 012350      1996 012352
   1999 012353      2000 012356      2001 012361      2002 012364      2004 012366      2005 012371      2007 012372
   2008 012373      2009 012376      2010 012403      2012 012410      2013 012411      2015 012416      2018 012424
   2020 012430      2021 012431      2023 012433      2025 012435      2028 012437      2029 012441      2030 012444
   2031 012445      2034 012450      2036 012452      2037 012464      2040 012465      2043 012514      2047 012537
   2049 012566      2089 012573      2097 012602      2098 012604      2100 012606      2102 012622      2103 012624
   2105 012635      2107 012636      2112 012671      2114 012673      2115 012702      2118 012704      2119 012707
   2120 012732      2121 012763      2122 012773      2125 013003      2127 013012      2129 013016      2130 013032
   2132 013050      2135 013051      2138 013060      2139 013062      2141 013072      2144 013073      2145 013123
   2148 013124      2152 013136      2154 013137      2157 013146      2158 013152      2161 013153      2164 013166
   2165 013172      2168 013173      2171 013202      2172 013220      2175 013221      2178 013233      2180 013240
   2183 013243      2185 013247      2186 013265      2189 013266      2191 013272      2192 013273      2193 013303
   2194 013310      2196 013321      2197 013326      2199 013331      2201 013337      2202 013345      2203 013347
   2204 013351      2206 013401      2208 013402      2209 013404      2210 013406      2212 013424      2215 013425
   2217 013431      2218 013434      2221 013435      2222 013444      2224 013456      2225 013462      2226 013464
   2227 013471      2229 013474      2231 013501      2232 013504      2234 013506      2235 013511      2237 013512
   2238 013514      2240 013515      2241 013516      2242 013525      2244 013532      2245 013542      2246 013550
   2249 013552      2253 013615      2255 013620      2256 013625      2261 013651      2263 013652      2265 013657
   2267 013663      2272 013701      2275 013702      2277 013712      2278 013713      2279 013723      2280 013731
   2282 013743      2283 013751      2285 013753      2286 013755      2288 014002      2290 014003      2291 014005
   2292 014007      2294 014030      2297 014031      2304 014037      2305 014054      2307 014060      2308 014073
   2311 014074      2312 014103      2313 014110      2315 014114      2316 014124      2318 014125      2319 014127
   2321 014164      2324 014165      2330 014175      2332 014177      2333 014205      2335 014207      2336 014226
   2339 014227      2341 014264      2344 014265      2347 014320      2349 014350       761 014351       764 014357
    766 014366       767 014401       768 014432       769 014442       770 014455       771 014467       772 014501
    773 014513       778 014514       788 014532       790 014576       791 014636       795 014647       797 014711
    802 014712       813 014723       814 014731       817 014752       818 014756       821 014760       823 015011
    827 015021       828 015022       830 015023       833 015026       834 015071       838 015072       846 015110
    849 015157       851 015222       854 015230       904 015231       909 015233       912 015240       913 015243
    914 015246       917 015247       919 015253       920 015255       923 015261       925 015265       926 015270
    927 015272       930 015273       932 015276       933 015301       934 015303       937 015304       938 015306
    939 015310       941 015315       943 015323       944 015325       946 015327       947 015331       953 015332
    958 015334       961 015406       962 015412       969 015420       974 015422       977 015474       978 015500
   1141 015506      1144 015507      1145 015514      1146 015520      1147 015524      1150 015533      1154 015547
   1323 015550      1330 015556      1333 015561      1334 015564      1336 015566      1338 015602      1341 015633
   2052 015634      2060 015642      2063 015646      2064 015676      2067 015677      2068 015701      2070 015715
   2072 015727      2073 015730      2075 015737      2076 015742      2077 015756      2079 016011      2081 016016
   2082 016020      2083 016027      2084 016060      2352 016061      2360 016062      2362 016065      2363 016070
   2366 016073      2367 016075      2368 016102      2373 016103      2387 016105      2390 016135      2392 016141
   2393 016171      2394 016202      2397 016203      2398 016206      2401 016237      2403 016244      2405 016267
   2410 016270      2435 016271      2437 016273      2438 016312      2440 016316      2442 016323      2445 016330
   2447 016334      2449 016343      2451 016344      2453 016350      2455 016354      2458 016363      2461 016367
   2462 016375      2467 016437      2469 016441      2470 016467      2473 016516      2475 016521      2476 016525
   2480 016526      2482 016530      2487 016560      2489 016564      2490 016570      2491 016573      2493 016647
   2496 016650      2497 016652      2500 016656      2503 016661      2504 016663


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
