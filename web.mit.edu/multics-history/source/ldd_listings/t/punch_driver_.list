	COMPILATION LISTING OF SEGMENT punch_driver_
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/01/90  1534.3 mdt Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 /* format: style4 */
       15 
       16 punch_driver_: proc;
       17 
       18 	return;					/* this is not a legal entry */
       19 
       20 
       21 /* Standard punch device driver control module for the I/O daemon. */
       22 
       23 /* Originally coded in March 1975 by J. C. Whitmore */
       24 /* Modified November 1975 by M. A. Braida to print flip card header */
       25 /* Modified by J. C. Whitmore, 4/78, for new dprint_msg format and general upgrade */
       26 /* Modified by J. C. Whitmore, 7/78, to initialize for auto deferring of long requests */
       27 /* Modified by J. C. Whitmore, 3/79, to correct string size on two assignments */
       28 /* Modified by C. Marker, 02/23/85, to use version 5 message segments */
       29 
       30 
       31 /****^  HISTORY COMMENTS:
       32*  1) change(87-05-10,Gilcrease), approve(87-08-17,MCR7686),
       33*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
       34*      Update for version 4 dprint_msg, and allow previous version.
       35*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       36*     audit(88-10-20,Wallman), install(88-10-28,MR12.2-1199):
       37*     Upgrade for version 5 iod tables.
       38*  3) change(88-08-29,Farley), approve(88-08-19,MCR7911),
       39*     audit(88-10-20,Wallman), install(88-10-28,MR12.2-1199):
       40*     Updated for version 5 dprint_msg.
       41*  4) change(90-08-30,Vu), approve(90-08-30,MCR8196), audit(90-09-12,Zimmerman),
       42*     install(90-10-01,MR12.4-1034):
       43*     Correct generation of major_args_ptr when using offset into the I/O daemon
       44*     tables string area.
       45*                                                   END HISTORY COMMENTS */
       46 
       47 
       48 /*	AUTOMATIC VARIABLES */
       49 
       50 dcl  date_string char (24);
       51 dcl  ec fixed bin (35);
       52 dcl  i fixed bin;					/* general index variable */
       53 dcl  io_stat bit (72) aligned;			/* ios_ status code */
       54 dcl  major_args char (major_args_length) based (major_args_ptr);
       55 dcl  major_args_ptr ptr;				/* ptr to major_args string */
       56 dcl  major_args_length fixed bin;
       57 dcl  nelm fixed bin;
       58 dcl  nelt fixed bin;
       59 dcl  dest char (24);				/* temp for the destination */
       60 dcl  head char (64) aligned;				/* temp for the heading */
       61 dcl  banner_stream char (32) aligned;
       62 dcl  access_class char (36) aligned;			/* temp for the first access class token */
       63 dcl  p2 ptr;
       64 dcl  retry_sw bit (1);
       65 
       66 dcl  1 st aligned based (addr (io_stat)),		/* breakdown of status code */
       67        2 code fixed bin (35),
       68        2 flags bit (36);
       69 
       70 
       71 /*	EXTERNAL ENTRIES    */
       72 
       73 dcl  add_char_offset_ entry (ptr, fixed bin(21)) returns(ptr) reducible;
       74 dcl  clock_ entry () returns (fixed bin (71));
       75 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
       76 dcl  date_time_ entry (fixed bin (71), char (*));
       77 dcl  ioa_$rsnnl entry options (variable);
       78 dcl  iodd_listen_ entry (ptr);
       79 dcl  iodd_msg_ entry options (variable);
       80 dcl  iodd_parse_$args entry (char(*) var, char(*)) returns(char(256) var);
       81 dcl  ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
       82 dcl  ios_$changemode entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
       83 dcl  ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
       84 dcl  ios_$order entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned);
       85 dcl  ios_$getsize entry (char (*) aligned, fixed bin, bit (72) aligned);
       86 dcl  ios_$write entry (char (*) aligned, ptr, fixed bin, fixed bin, fixed bin, bit (72) aligned);
       87 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
       88 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
       89 dcl  output_request_ entry (char (*) aligned, fixed bin, ptr, entry, fixed bin (35));
       90 dcl  output_request_$error_during_request entry (char (*));
       91 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2) aligned, fixed bin (71));
       92 dcl  timer_manager_$sleep entry (fixed bin (71), bit (2) aligned);
       93 dcl  write_control_form_ entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
       94 dcl  write_sample_form_ entry (char (*) aligned, char (*) aligned, fixed bin (35));
       95 
       96 
       97 /*	INTERNAL STATIC   */
       98 
       99 dcl  card_header char (512) aligned int static;		/* buffer for flip card head/tail */
      100 dcl  xxbar char (22) aligned int static options (constant) init ((11)"
      101 -");						/* string of "NL-"'s for flip cards */
      102 dcl  ctl_msg_sent bit (1) int static init ("0"b);		/* flag set when msg sent ok */
      103 dcl  time fixed bin (71) int static init (1);
      104 dcl  alarm_channel fixed bin (71) int static;		/* channel used for time out checks */
      105 dcl  meter_sw bit (1) int static;			/* TRUE - if we are to keep metering data (future) */
      106 dcl  master fixed bin int static options (constant) init (1);
      107 dcl  both fixed bin int static options (constant) init (0);
      108 dcl  whoami char (24) int static options (constant) init ("punch_driver_");
      109 dcl  initial_bit_rate fixed bin int static options (constant) init (1000); /* starting value for the bit rate estimate */
      110 
      111 dcl  1 ctl_wait_list int static aligned,		/* ipc wait list for the form terminnal */
      112        2 number fixed bin,
      113        2 channel fixed bin (71);
      114 
      115 dcl  1 event_info int static aligned,			/* info returned from ipc_$block */
      116        2 chan fixed bin (71),
      117        2 message fixed bin (71),
      118        2 sender bit (36),
      119        2 origin fixed bin,
      120        2 wait_list_index fixed bin;
      121 
      122 dcl  1 form_info aligned int static,			/* data from the form paging dim */
      123        2 page_length fixed bin,			/* put in static to save stack space */
      124        2 line_length fixed bin,
      125        2 line_no fixed bin,
      126        2 carriage_position fixed bin,
      127        2 aligned bit (1) unal,			/* tells if the dim considers the forms alignedd */
      128        2 pad bit (35) unal;
      129 
      130 dcl  1 sw (5) aligned int static,			/* format stream (switch) data structure */
      131        2 name char (32) init ("Undefined", "viipunch_output", "mcc_output", "raw_output", "flipper_output"),
      132        2 size fixed bin init (9, 1, 9, 960, 9),		/* element size for this format */
      133        2 dim char (32) init ("syn", "viipunch_", "mcc_", "raw_", "flipper_");
      134 
      135 
      136 /*	BUILTINS    */
      137 
      138 dcl  (addr, null, substr, before, after, length, rtrim) builtin;
      139 
      140 
      141 /*	CONDITIONS   */
      142 
      143 dcl  cleanup condition;
      144 
      145 
      146 /*	EXTERNAL STATIC -- ERROR TABLE ENTRIES     */
      147 
      148 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      149 dcl  error_table_$fatal_error fixed bin (35) ext static;
      150 dcl  error_table_$ionmat fixed bin (35) ext static;
      151 
      152 
      153 init: entry (arg_p);
      154 
      155 dcl  arg_p ptr;
      156 
      157 	stat_p = arg_p;				/* put the arg into static for easy reference */
      158 	driver_status_ptr = iodd_static.driver_ptr;	/* get current driver status ptr */
      159 	text_strings_ptr = iodd_static.text_strings_ptr;	/* get ptr to i/o daemon table text area */
      160 	retry_sw = "1"b;				/* retry attachments once on error */
      161 
      162 	if iodd_static.attach_type ^= ATTACH_TYPE_IOM then do;	/* this driver expects an IOM channel */
      163 	     ec = error_table_$fatal_error;
      164 	     call iodd_msg_ (2, master, ec, whoami, "This driver requires a punch attached through the IOM.");
      165 	     return;				/* quit now */
      166 	end;
      167 
      168 	if iodd_static.assigned_devices > 1 then do;	/* be sure all is correct */
      169 	     ec = error_table_$fatal_error;
      170 	     call iodd_msg_ (2, master, ec, whoami, "Multiple minor devices are not supported by the punch driver.");
      171 	     return;
      172 	end;
      173 
      174 /* locate the major args for the device in the iod_tables */
      175 	major_args_ptr = add_char_offset_ (addr (text_strings.chars), (iodd_static.major_args.first_char - 1));
      176 	major_args_length = iodd_static.major_args.total_chars;
      177 
      178 	iodd_static.device_dim = iodd_parse_$args ("dim=", major_args); /* see if a dim was specified */
      179 	if iodd_static.device_dim = "" then iodd_static.device_dim = "cpz"; /* no, use the default */
      180 	iodd_static.dev_out_stream = "punch_output_stream";
      181 	iodd_static.dev_io_stream = iodd_static.dev_out_stream; /* make them the same */
      182 	iodd_static.dev_in_stream = "Undefined_Daemon_Stream"; /* avoid uninitialized variables */
      183 
      184 attach:	call ios_$attach (iodd_static.dev_out_stream, iodd_static.device_dim, iodd_static.attach_name, "", io_stat);
      185 	if st.code ^= 0 then do;
      186 	     if st.code = error_table_$ionmat & retry_sw then do; /* can we try again */
      187 retry:		retry_sw = "0"b;			/* yes, but only once */
      188 		call detach_all;			/* clear the slate */
      189 		go to attach;
      190 	     end;
      191 	     call iodd_msg_ (2, master, st.code, whoami, "Fatal Error: Unable to attach channel ^a",
      192 		iodd_static.attach_name);
      193 	     return;
      194 	end;
      195 
      196 	on cleanup call detach_all;			/* for reinit, no_coord, logout, new_device, etc... */
      197 
      198 /*	set up the punch code formatting dims corresponding to the dprint_msg outer_module variable */
      199 
      200 	do i = 2 to 5;				/* attach the defined format streams */
      201 	     call ios_$attach (sw.name (i), sw.dim (i), iodd_static.dev_out_stream, "", io_stat);
      202 	     if st.code ^= 0 then do;
      203 		if st.code = error_table_$ionmat & retry_sw then go to retry; /* start_over */
      204 		call iodd_msg_ (2, master, st.code, whoami, "Fatal Error: Unable to attach ^a to ^a.",
      205 		     sw.name (i), iodd_static.dev_out_stream);
      206 		go to clean_out;
      207 	     end;
      208 	end;
      209 
      210 	do i = 2 to 4;				/* get the stream element sizes for 7punch, mcc and raw */
      211 	     call ios_$getsize (sw.name (i), sw.size (i), io_stat);
      212 	     if st.code ^= 0 then do;
      213 		call iodd_msg_ (2, master, st.code, whoami, "Fatal Error: Invalid getsize call for dim ^a.", sw.dim (i));
      214 		go to clean_out;
      215 	     end;
      216 	end;
      217 
      218 	driver_status.elem_size = 1;
      219 	driver_status.message_type = 2;		/* expected dprint message type */
      220 	driver_status.attached = "1"b;
      221 	driver_status.ready = "1"b;			/* issue an automatic "ready" command */
      222 	driver_status.form_wait_time = 5;		/* set this as a reasonable default */
      223 	driver_status.dev_out_stream = iodd_static.dev_out_stream; /* record this too */
      224 	driver_status.bit_rate_est = initial_bit_rate;
      225 	driver_status.defer_time_limit = 0;
      226 
      227 	if iodd_static.ctl_term.attached then do;
      228 	     ctl_wait_list.number = 1;
      229 	     ctl_wait_list.channel = iodd_static.ctl_ev_chan;
      230 	     alarm_channel = iodd_static.ctl_ev_chan;
      231 	     call ios_$changemode (iodd_static.ctl_output, "^hndlquit", "", io_stat); /* we reset read on quit */
      232 	end;
      233 	else do;
      234 	     ctl_wait_list.number = 0;		/* otherwise clear to avoid errors */
      235 	     ctl_wait_list.channel = 0;
      236 	     alarm_channel = 0;
      237 	end;
      238 
      239 	if driver_status.rqti_ptr ^= null then do;	/* see if there is any rqti data */
      240 	     p2 = driver_status.rqti_ptr;		/* copy the pointer for easy reference */
      241 	     if p2 -> rqti_header.header_version ^= rqti_header_version_1 then do;
      242 		call iodd_msg_ (2, both, error_table_$fatal_error, whoami,
      243 		     "RQTI header version ^d found (expected ^d).", p2 -> rqti_header.header_version,
      244 		     rqti_header_version_1);
      245 		go to clean_out;
      246 	     end;
      247 	     if ^(p2 -> rqti_header.type_code = 0 | p2 -> rqti_header.type_code = 2) then do;
      248 		ec = error_table_$fatal_error;	/* allow header only or punch RQTI - no others */
      249 		call iodd_msg_ (2, both, ec, whoami, "Incorrect RQTI segment format for punch.");
      250 		go to clean_out;
      251 	     end;
      252 	     iodd_static.slave_hold = ^(p2 -> rqti_header.auto_go); /* get the auto go value */
      253 	     iodd_static.wakeup_time = p2 -> rqti_header.driver_wait_time; /* and wait time */
      254 	     meter_sw = p2 -> rqti_header.meter;	/* meters needed? (for the future) */
      255 	end;
      256 	else do;					/* use default values, no rqti seg */
      257 	     iodd_static.slave_hold = "1"b;		/* ask for a go command */
      258 	     iodd_static.wakeup_time = 120;		/* should wait 2 min before asking for work */
      259 	     meter_sw = "0"b;			/* no metering  (future) */
      260 	end;
      261 
      262 	iodd_static.form_type = iodd_parse_$args ("form_type=", major_args); /* was form type given */
      263 	if iodd_static.form_type = "" then iodd_static.form_type = "std_ctl_msg"; /* no, use standard default */
      264 
      265 	call date_time_ (clock_ (), date_string);	/* get set for ready message */
      266 
      267 	call iodd_msg_ (1, both, 0, "", "^/^a driver ready at ^16a^/", driver_status.dev_name_label, date_string);
      268 
      269 	call iodd_listen_ (stat_p);			/* iodd_listen_ will never return */
      270 
      271 clean_out:					/* this label is for error recovery */
      272 
      273 	call detach_all;
      274 	return;
      275 
      276 
      277 request: entry;
      278 
      279 /* This is the entry which is called by the iodd_listen_ procedure when a request
      280*   for this driver has been received from the coordinator.
      281*
      282*   The purpose of the code for this entry of the punch driver is to validate
      283*   that the request is one that we expect and can correctly interpret.  Then we
      284*   call output_request_ to do all the work of access checking etc.  The stream to
      285*   be used is based on the outer module specified in the request.  */
      286 
      287 	driver_status_ptr = iodd_static.driver_ptr;	/* make it general although it will always be the same */
      288 	p2 = addr (driver_status.descriptor);		/* find the request descriptor */
      289 	dmp = addr (driver_status.message);		/* get ptr to message */
      290 
      291 	if dprint_msg.header.hdr_version ^= queue_msg_hdr_version_1 then do; /* trouble */
      292 	     call iodd_msg_ (0, both, 0, "", "Invalid message header.  Cannot read request ^d.^d.",
      293 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q);
      294 	     p2 -> request_descriptor.keep_in_queue = "1"b; /* save for conversion later */
      295 	     go to be_nice;
      296 	end;
      297 	if dprint_msg.header.message_type ^= driver_status.message_type then do;
      298 	     call iodd_msg_ (0, both, 0, "",		/* log the error */
      299 		"Incorrect message type for punch.^/Request ^d.^d for ^a (segment ^a) not processed.",
      300 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q, 
      301 		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
      302 		dprint_msg.header.ename);
      303 	     p2 -> request_descriptor.cancelled = "1"b;
      304 be_nice:	     p2 -> request_descriptor.dont_delete = "1"b; /* save the user's data */
      305 	     p2 -> request_descriptor.finished = "1"b;	/* mark it done */
      306 	     return;				/* it wasn't for us after all */
      307 	end;
      308 	if dprint_msg.version ^= dprint_msg_version_3 	/* Previous version */
      309 	& dprint_msg.version ^= dprint_msg_version_4	/* Previous version */
      310 	& dprint_msg.version ^= dprint_msg_version_5	/* Current version */
      311 	   then do;				/* other trouble? */
      312 	     call iodd_msg_ (0, both, 0, "",
      313 		"Wrong message version found.^/Request ^d.^d for ^a (segment ^a) not processed",
      314 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q, 
      315 		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
      316 		dprint_msg.header.ename);
      317 	     p2 -> request_descriptor.keep_in_queue = "1"b;
      318 	     go to be_nice;
      319 	end;
      320 	if dprint_msg.version < dprint_msg_version_4 then /* Disallow -line_nbrs before version 4 */
      321 	     dprint_msg.control.line_nbrs = "0"b;
      322 
      323 	i = dprint_msg.output_module;			/* get the user defined format */
      324 
      325 	if i < 2 | i > 4 then do;			/* be sure it is defined */
      326 	     call iodd_msg_ (0, both, 0, "",
      327 		"Undefined punch format in user request.^/Request ^d.^d for ^a (segment ^a) not processed",
      328 		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q, 
      329 		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
      330 		dprint_msg.header.ename);
      331 	     p2 -> request_descriptor.cancelled = "1"b;
      332 	     go to be_nice;
      333 	end;
      334 
      335 	iodd_static.quit_during_request = "0"b;		/* start clean */
      336 	ctl_msg_sent = "0"b;			/* initialize to no msg yet */
      337 
      338 	call output_request_ (sw.name (i), sw.size (i), stat_p, print_banner, ec);
      339 	if ec ^= 0 then
      340 	     iodd_static.slave_hold = "1"b;		/* on errors go to command level */
      341 	return;
      342 
      343 
      344 print_banner: entry (a_stream, type, data_ptr, code);
      345 
      346 dcl  a_stream char (*);				/* this would normally be the banner output stream */
      347 						/* but we can only use the flip card stream */
      348 dcl  type fixed bin;				/* type of banner to be written  */
      349 						/* 1 = heading banner            */
      350 						/* 2 = tail banner               */
      351 						/* 3 = error message             */
      352 dcl  data_ptr ptr;					/* pointer to output request data or  */
      353 						/* to char(256) varying string error msg */
      354 dcl  code fixed bin (35);				/* error code */
      355 
      356 	banner_stream = sw.name (5);			/* we must use the flipper stream */
      357 
      358 	if type = 1 then do;			/* heading banner for punch wanted */
      359 
      360 	     iodd_static.quit_during_request = "0"b;	/* reset for each request */
      361 
      362 	     if iodd_static.ctl_term.attached then do;	/* message to ctl term? */
      363 		call write_control_form_ (iodd_static.form_type, iodd_static.ctl_output, data_ptr, ec);
      364 		if ec ^= 0 then do;
      365 		     if code ^= error_table_$action_not_performed then do; /* this is normal */
      366 			call iodd_msg_ (2, master, ec, whoami, "Writing message on control terminal.");
      367 			iodd_static.slave_hold = "1"b;/* avoid automatic start */
      368 		     end;
      369 		     ctl_msg_sent = "0"b;		/* don't wait for bad message */
      370 		end;
      371 		else ctl_msg_sent = "1"b;		/* say all was well, so we can wait */
      372 		if ctl_wait_list.number = 1 & ctl_msg_sent then do; /* are we going to sync with the term? */
      373 		     call ipc_$drain_chn (ctl_wait_list.channel, ec);
      374 		     if ec ^= 0 then do;		/* avoid futher trouble, but not fatal */
      375 			ctl_wait_list.channel = 0;	/* stop trying */
      376 			ctl_wait_list.number = 0;
      377 			iodd_static.slave_hold = "1"b;
      378 			ctl_msg_sent = "0"b;	/* don't wait , no wakeup will come */
      379 			call iodd_msg_ (2, master, 0, whoami, "print_banner bad call to ipc_drain ^d", ec);
      380 		     end;
      381 		     else call timer_manager_$alarm_wakeup (driver_status.form_wait_time, "11"b, alarm_channel);
      382 		end;
      383 	     end;
      384 	     else ctl_msg_sent = "0"b;		/* don't wait */
      385 
      386 	     dmp = addr (iodd_static.driver_ptr -> driver_status.message); /* get pointer to meessage */
      387 	     ordatap = data_ptr;			/* set default ptr for output_request_data */
      388 
      389 /*	PRINT THE FLIP CARDS HERE */
      390 
      391 	     if dprint_msg.heading = "" then
      392 		head = before (ordata.requestor, ".");	/* default to the person */
      393 	     else head = dprint_msg.heading;
      394 
      395 	     if dprint_msg.destination = "" then
      396 		dest = before (after (ordata.requestor, "."), "."); /* default to project */
      397 	     else dest = dprint_msg.destination;
      398 
      399 	     access_class = before (ordata.access_class_string, ","); /* we want the first token, strip the rest */
      400 
      401 /*	Now, format the flip card header. */
      402 
      403 	     call ioa_$rsnnl ("^a^/^x^7a^x^2/^7d^2x^2/^3xCOPY^2x^2/^x^2d OF^2d^x^2/^x^8a^2/^x^8a^2/^x^7a^x^2/^x^7a^x^/",
      404 		card_header, nelm,
      405 		xxbar, "REQUEST", ordata.request_no, ordata.copy_no, ordata.copies,
      406 		substr (ordata.date_time_start_request, 1, 8),
      407 		substr (ordata.date_time_start_request, 11, 6), substr (dest, 1, 7),
      408 		substr (dest, 8, 7));
      409 
      410 	     call write_msg (card_header);		/* the first few cards */
      411 
      412 	     call write_msg (ordata.requestor);
      413 
      414 	     call write_msg (access_class);
      415 
      416 	     call write_msg (ordata.full_path);
      417 
      418 	     call write_msg (xxbar);			/* this closes out the header cards */
      419 
      420 	     call ios_$order (banner_stream, "reset", null, io_stat); /* clear card count */
      421 	end;
      422 
      423 	else if type = 2 then do;			/* a trailing banner is wanted */
      424 
      425 	     if iodd_static.test_entry then		/* be able to set a reasonable pace */
      426 		if time > 1 then call timer_manager_$sleep (time, "11"b); /* simulate device */
      427 
      428 /*	PUT IN A TAIL SEPARATOR HERE */
      429 
      430 	     call ioa_$rsnnl ("^3xEND OF^6xDECK^3x^a", card_header, nelm, xxbar);
      431 
      432 	     call write_msg (card_header);
      433 
      434 	     if iodd_static.quit_during_request then	/* output was lost */
      435 		ctl_msg_sent = "0"b;		/* cancel the flag */
      436 	     else if ctl_msg_sent then do;		/* avoid premature blocking */
      437 		ctl_msg_sent = "0"b;		/* ready for the next one */
      438 		call ipc_$block (addr (ctl_wait_list), addr (event_info), ec); /* wait for form to finish */
      439 	     end;
      440 	end;
      441 
      442 	else if type = 3 then do;			/* put out an error message */
      443 
      444 	     card_header = xxbar || "ERROR DURING REQUEST  " || xxbar; /* just a general message */
      445 
      446 	     call ios_$write (banner_stream, addr (card_header), 0, 66, nelt, io_stat);
      447 
      448 	     code = 0;				/* don't cause trouble */
      449 	end;
      450 
      451 	else code = error_table_$action_not_performed;	/* all other banner types are undefined */
      452 
      453 	return;
      454 
      455 flip_err: code = st.code;				/* report the error */
      456 	return;					/* and stop writing */
      457 
      458 
      459 command: entry (source, state, arg_list_p, c_code);
      460 
      461 dcl  source fixed bin;				/* 1 = master console, 2 = slave */
      462 dcl  state fixed bin;				/* 0 = not quite ready to handle a request */
      463 						/* 1 = drivers are ready */
      464 						/* 2 = command entered after a quit */
      465 dcl  arg_list_p ptr;				/* ptr to structure returned by parse_command_ */
      466 dcl  c_code fixed bin (35);				/* error code: zero if command handled correctly */
      467 						/* error_table_ code for bad syntax or unknown command */
      468 dcl  1 arg_list aligned based (arg_list_p),		/* parse_command_ structure */
      469        2 max_tokens fixed bin,			/* space allocated, do not change */
      470        2 n_tokens fixed bin,				/* number of tokens from command line (including cmd) */
      471        2 command char (64) var,			/* the first token is the command */
      472        2 arg (n_tokens - 1) char (64) var;		/* the other tokens are args to the command */
      473 
      474 	if command = "help" then do;
      475 	     c_code = 0;
      476 	     call iodd_msg_ (1, source, 0, "", "^/** Commands for the punch driver **^/");
      477 	     call iodd_msg_ (1, source, 0, "", "sample_form");
      478 	     if test_entry then
      479 		call iodd_msg_ (1, source, 0, "", "time [<sleep_time>]");
      480 	end;
      481 	else if command = "ctl_term" then do;		/* this was passed on by iodd_command_processor_ */
      482 	     iodd_static.driver_ptr -> driver_status.form_wait_time = 5; /* to have us set the default form type */
      483 	     iodd_static.form_type = "std_ctl_msg";	/* this is our default */
      484 	end;
      485 	else if command = "time" then do;
      486 	     if iodd_static.test_entry then do;		/* refuse to recognize if not testing */
      487 		c_code = 0;			/* the command was good */
      488 		if n_tokens > 1 then do;
      489 		     time = cv_dec_check_ ((arg (1)), ec);
      490 		     if ec ^= 0 then time = 10;
      491 		end;
      492 		else time = 1;			/* return to the default..full speed */
      493 	     end;
      494 	end;
      495 	else if command = "sample_form" then do;
      496 	     c_code = 0;				/* we'll handle everything here */
      497 	     if iodd_static.ctl_term.attached then do;	/* be sure there is a place to write */
      498 		if iodd_static.forms then do;		/* are we simulating FF? */
      499 		     call ios_$order (iodd_static.ctl_output, "form_status", addr (form_info), io_stat);
      500 		     if st.code ^= 0 then do;		/* OOPS.... */
      501 			c_code = st.code;		/* pass it back */
      502 			iodd_static.master_hold = "1"b; /* this is a problem for master terminal */
      503 			call iodd_msg_ (1, both, st.code, whoami,
      504 			     "^/form_status order call.  Master terminal action required to continue.");
      505 			return;
      506 		     end;
      507 		     if ^form_info.aligned then
      508 			call ios_$order (iodd_static.ctl_output, "form_aligned", null, io_stat); /* this will work */
      509 		end;
      510 		call write_sample_form_ (iodd_static.form_type, iodd_static.ctl_output, c_code);
      511 	     end;
      512 	     else call iodd_msg_ (1, source, 0, "", "Control terminal is not attached.");
      513 	end;
      514 	return;					/* return any undefined commands without changing anything */
      515 
      516 
      517 default_handler: entry (condition_info_ptr);
      518 
      519 dcl  condition char (32);				/* fixed string for the call */
      520 
      521 	condition = condition_info.condition_name;	/* this will indent funny */
      522 
      523 	if iodd_static.request_in_progress then		/* try to avoid mistakes */
      524 
      525 	     call output_request_$error_during_request (condition); /* take it away */
      526 
      527 	return;					/* output_request_ should not return, but.... */
      528 
      529 
      530 detach_all: proc;
      531 
      532 /* cleanup proc to detach all possible streams we could have attached */
      533 
      534 	call ios_$detach (iodd_static.dev_out_stream, "", "", io_stat);
      535 	do i = 2 to 5;
      536 	     call ios_$detach (sw.name (i), "", "", io_stat);
      537 	end;
      538 	return;
      539 
      540      end detach_all;
      541 
      542 
      543 
      544 write_msg: proc (string);
      545 
      546 dcl  string char (*) aligned;
      547 
      548 	nelm = length (rtrim (string));
      549 	if nelm > 0 then do;			/* write flip cards for non blank message */
      550 	     call ios_$write (banner_stream, addr (string), 0, nelm, nelt, io_stat);
      551 	     if st.code ^= 0 then go to flip_err;	/* trouble */
      552 	end;
      553 	return;
      554 
      555      end write_msg;
      556  /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  1     2 
  1     3 /* Structure for find_condition_info_.
  1     4*
  1     5*   Written 1-Mar-79 by M. N. Davidoff.
  1     6**/
  1     7 
  1     8 /* automatic */
  1     9 
  1    10      declare condition_info_ptr     pointer;
  1    11 
  1    12 /* based */
  1    13 
  1    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  1    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 condition_name     char (32) varying,	/* name of condition */
  1    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  1    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  1    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  1    21 	     2 flags	      unaligned,
  1    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  1    23 	       3 pad1	      bit (35),
  1    24 	     2 pad2	      bit (36),
  1    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  1    26 	     2 pad3	      (4) bit (36);
  1    27 
  1    28 /* internal static */
  1    29 
  1    30      declare condition_info_version_1
  1    31 			      fixed binary internal static options (constant) initial (1);
  1    32 
  1    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      556 
      557  /* BEGIN INCLUDE FILE ... dprint_msg.incl.pl1 */
  2     2 /* Modified: November 1983 by C. Marker Added no_separator. */
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  2     6*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  2     7*     Add line_nbrs bit for line-numbered printouts, version 4.
  2     8*  2) change(88-02-05,Farley), approve(88-02-05,PBF7686), audit(88-02-05,GWMay),
  2     9*     install(88-02-05,MR12.2-1022):
  2    10*     Corrected alignment of line_nbrs, was aligned s/b unaligned..
  2    11*  3) change(88-08-23,Farley), approve(88-09-16,MCR7911),
  2    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  2    13*     Increased size of forms field to 64 characters (was only 24), which
  2    14*     updates the version to 5.
  2    15*                                                   END HISTORY COMMENTS */
  2    16 
  2    17 
  2    18 dcl  dmp ptr;					/* ptr to message */
  2    19 
  2    20 dcl 1 dprint_msg based (dmp) aligned,			/* structure of a IO daemon print or punch request */
  2    21     2 header like queue_msg_hdr,			/* header for all standard queue messages */
  2    22     2 version fixed bin,				/* version of the dprint_msg used */
  2    23     2 copies fixed bin,				/* number of copies user requested */
  2    24     2 bit_count fixed bin (35),			/* the bitcount of the segment at request time */
  2    25     2 output_module fixed bin,			/* 1=print, 2=7punch, 3= mcc, 4=raw */
  2    26     2 control,					/* control flags. */
  2    27       3 nep bit (1) unal,				/* TRUE if printing over perforations */
  2    28       3 single bit (1) unal,				/* TRUE if ignore FF and VT */
  2    29       3 non_edited bit (1) unal,			/* TRUE if printing in non-edited mode */
  2    30       3 truncate bit (1) unal,			/* TRUE if truncating lines at line length */
  2    31       3 esc bit (1) unal,				/* TRUE if text escapes are to be processed */
  2    32       3 center_top_label bit (1) unal,			/* TRUE if top label to be centered */
  2    33       3 center_bottom_label bit (1) unal,		/* TRUE if bottom label to be centered */
  2    34       3 no_separator bit(1) unal,                           /* TRUE if the inner head a tail sheets of multiple copies are to be suppressed. */
  2    35       3 line_nbrs bit (1) unal,			/* TRUE if line numbers wanted */
  2    36       3 padding bit (27) unal,
  2    37     2 lmargin fixed bin,				/* indent from the left */
  2    38     2 line_lth fixed bin,				/* logical line length */
  2    39     2 page_lth fixed bin,				/* logical page length */
  2    40     2 heading_lth fixed bin,				/* number of chars in heading */
  2    41     2 top_label_lth fixed bin,			/* number of chars in the top label */
  2    42     2 bottom_label_lth fixed bin,			/* number of chars in bottom label */
  2    43     2 chan_stop_path_lth fixed bin,			/* number of chars in channel stop pathname */
  2    44     2 forms_name_lth fixed bin,			/* number of chars in forms name */
  2    45     2 future_fb_values (7) fixed bin,			/* make future versions possible */
  2    46     2 forms char (24),				/* name of special forms, or blank */
  2    47     2 destination char (24),				/* routing for output */
  2    48     2 heading char (head_max_lth refer (dprint_msg.heading_lth)), /* heading on page 1 */
  2    49     2 top_label char (label_max_lth refer (dprint_msg.top_label_lth)), /* top page heading for each page */
  2    50     2 bottom_label char (label_max_lth refer (dprint_msg.bottom_label_lth)), /* bottom page heading */
  2    51     2 chan_stop_path char (path_max_lth refer (dprint_msg.chan_stop_path_lth)), /* path of rqti seg with channel stops */
  2    52     2 forms_name char (forms_max_lth refer (dprint_msg.forms_name_lth)); /* forms name string */
  2    53 
  2    54 
  2    55 dcl  (
  2    56      head_max_lth init (64),				/* allocation size for heading */
  2    57      label_max_lth init (136),			/* allocation size for label fields */
  2    58      path_max_lth init (168),				/* allocation size for pathname fields */
  2    59      forms_max_lth init (64)				/* allocation size for forms name string */
  2    60      ) fixed bin int static options (constant);
  2    61 
  2    62 dcl  (
  2    63      dprint_msg_version_3 init (3),
  2    64      dprint_msg_version_4 init (4),
  2    65      dprint_msg_version_5 init (5)			/* current version */
  2    66      ) fixed bin int static options (constant);
  2    67 
  2    68 /* END INCLUDE FILE ... dprint_msg.incl.pl1 */
      557 
      558  /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  3     7*     Ancient History
  3     8*     Coded by Robert S. Coren August 1973
  3     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  3    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  3    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  3    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  3    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  3    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  3    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  3    16*     to denote accounting ^= nothing.
  3    17*                                                   END HISTORY COMMENTS */
  3    18 
  3    19 
  3    20 /* status data for a logical device driver */
  3    21 
  3    22 /* format: style4 */
  3    23 
  3    24 dcl  driver_status_ptr ptr;
  3    25 dcl  1 driver_status aligned based (driver_status_ptr),
  3    26        2 req_type_label char (32),			/* string to describe the request type */
  3    27        2 dev_name_label char (32),			/* string to describe the device */
  3    28        2 device_id char (32),				/* minor device name used by this logical driver */
  3    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  3    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  3    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  3    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  3    33        2 request_pending bit (36),			/* locking word for communication with coord */
  3    34 						/* 0 = ready for a request  */
  3    35 						/* driver pid = don't bug me */
  3    36 						/* coord  pid = got a request */
  3    37        2 status_flags,
  3    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  3    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  3    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  3    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  3    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  3    43          3 pad bit (31) unal,
  3    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  3    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  3    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  3    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  3    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  3    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  3    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  3    51 						/* for this logical driver */
  3    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  3    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  3    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  3    55        2 dev_out_stream char (32),			/* output stream for minor device */
  3    56        2 dev_in_stream char (32),			/* input stream for minor device */
  3    57        2 elem_size fixed bin,				/* element size for the stream */
  3    58        2 message_type fixed bin,			/* expected format of user request */
  3    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  3    60        2 forms_validation_ptr ptr,			/* forms validation data */
  3    61        2 dev_ptr1 ptr,				/* another one */
  3    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  3    63        2 dev_fb2 fixed bin,				/* and another */
  3    64        2 dev_fb3 fixed bin,				/* and another */
  3    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  3    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  3    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  3    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  3    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  3    70        2 generic_type char (32),			/* generic type of this minor device */
  3    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  3    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  3    73        2 desc_pad (13) fixed bin,
  3    74        2 message fixed bin;				/* place-holder for copy of request message */
  3    75 
  3    76 
  3    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
      558 
      559  /* BEGIN INCLUDE FILE ... iod_constants.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(88-08-31,Brunelle), approve(88-08-31,MCR7911),
  4     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4     7*     Created.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10 /* This file contains constants used by the I/O Daemon software in various tables */
  4    11 
  4    12 /* format: style4 */
  4    13 
  4    14 /* literals for use with idte.attach_type & iodd_static.attach_type */
  4    15 dcl  (ATTACH_TYPE_IOM init (1),
  4    16      ATTACH_TYPE_TTY init (2),
  4    17      ATTACH_TYPE_DIAL init (3),
  4    18      ATTACH_TYPE_VARIABLE_LINE init (4)) fixed bin int static options (constant);
  4    19 
  4    20 /* literals for use with idte.ctl_attach_type & iodd_static.ctl_attach_type */
  4    21 dcl  (CTL_ATTACH_TYPE_TTY init (1),
  4    22      CTL_ATTACH_TYPE_DIAL init (2),
  4    23      CTL_ATTACH_TYPE_MC init (3)) fixed bin int static options (constant);
  4    24 
  4    25 /* literals for use with idte.paper_type & iodd_static.paper_type */
  4    26 dcl  (PAPER_TYPE_DEFAULT init (-1),
  4    27      PAPER_TYPE_SINGLE init (1),
  4    28      PAPER_TYPE_CONTINUOUS init (2)) fixed bin int static options (constant);
  4    29 
  4    30 /* END INCLUDE FILE ... iod_constants.incl.pl1 */
      559 
      560  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Created by J. Stern, 1/20/75
  5     9*     Modified by J. C. Whitmore April 1978 for enhancements
  5    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  5    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  5    12*     q_group_tab
  5    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  5    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    15*     Change version number to reflect changes in q_group_tab and
  5    16*     iod_device_tab for laser printer support.  Added font tables.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 /* format: style4 */
  5    21 
  5    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  5    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  5    24        2 version char (8),				/* version of this structure */
  5    25        2 date_time_compiled fixed bin (71),
  5    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  5    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  5    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  5    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  5    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  5    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  5    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  5    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  5    34        2 text_strings_offset fixed bin (18),
  5    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  5    36 
  5    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  5    38 dcl  text_strings_ptr ptr;
  5    39 dcl  1 text_strings aligned based (text_strings_ptr),
  5    40        2 length fixed bin,
  5    41        2 chars char (1 refer (text_strings.length)) unaligned;
  5    42 
  5    43 /* this defines text offsets used to locate i/o daemon tables strings in
  5    44*   the text_strings structure */
  5    45 dcl  1 text_offset based,
  5    46        2 first_char fixed bin (18) unsigned unaligned,
  5    47        2 total_chars fixed bin (18) unsigned unaligned;
  5    48 
  5    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  5    50 
  5    51 
  5    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      560 
      561  /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  6     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  6     7*     Add support for logout_on_hangup option.
  6     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    10*     Add head/tail_sheet entry variables and paper_type variable.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 /* format: style4 */
  6    14 
  6    15 dcl  stat_p int static ptr;
  6    16 
  6    17 dcl  1 iodd_static based (stat_p) aligned,
  6    18 
  6    19 /*    The first part is set only once for a device driver */
  6    20 
  6    21        2 ithp ptr,					/* pointer to iod tables header */
  6    22        2 ltp ptr,					/* pointer to line table */
  6    23        2 idtp ptr,					/* pointer to device tab */
  6    24        2 mdtp ptr,					/* pointer to minor device table */
  6    25        2 qgtp ptr,					/* pointer to q_group table */
  6    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  6    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  6    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  6    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  6    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  6    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  6    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  6    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  6    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  6    35        2 log_stream char (32),			/* stream name used for log output */
  6    36        2 master_input char (32),			/* master console input stream for commands */
  6    37        2 master_output char (32),			/* master console output stream for messages */
  6    38        2 master_out ptr,				/* master output iocbp */
  6    39        2 master_in ptr,				/* master input iocbp */
  6    40        2 log_iocbp ptr,				/* log output iocbp */
  6    41        2 error_io ptr,				/* error i/o iocbp */
  6    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  6    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  6    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  6    45        2 device_dim char (32),			/* dim which drives the major device */
  6    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  6    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  6    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  6    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  6    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  6    51        2 major_device char (32),			/* name of the major device */
  6    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  6    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  6    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  6    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  6    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  6    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  6    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  6    59 
  6    60 /*    driver module entrypoints are defined by the following entry variables */
  6    61 
  6    62        2 driver_init entry variable options (variable),
  6    63        2 driver_request entry variable options (variable),
  6    64        2 driver_command entry variable options (variable),
  6    65        2 driver_default_handler entry variable options (variable),
  6    66 
  6    67 /*    entrypoints for head/tail_sheet_ entries */
  6    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  6    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  6    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  6    71 
  6    72        2 paper_type fixed bin,			/* type of paper being used */
  6    73 						/* 1 = single sheet */
  6    74 						/* 2 = continuous forms */
  6    75 
  6    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  6    77 
  6    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  6    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  6    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  6    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  6    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  6    83        2 output_device char (32),			/* name of minor device currently in use */
  6    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  6    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  6    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  6    87        2 segptr ptr,				/* ptr to current user segment being processed */
  6    88        2 flags,					/* control flags */
  6    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  6    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  6    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  6    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  6    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  6    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  6    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  6    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  6    97          3 step bit (1) unal,				/* run in step mode */
  6    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  6    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  6   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  6   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  6   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  6   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  6   104          3 pad bit (21) unal,				/* unused space */
  6   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  6   106          3 slave_input char (32),			/* slave input stream name */
  6   107          3 slave_output char (32),			/* slave output stream name */
  6   108          3 slave_pad fixed bin,			/* allocation breakage */
  6   109          3 slave_in ptr,				/* slave input iocbp */
  6   110          3 slave_out ptr,				/* slave output iocbp */
  6   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  6   112          3 active bit (1) unal,			/* on if there is a slave */
  6   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  6   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  6   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  6   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  6   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  6   118          3 priv2 bit (1) unal,
  6   119          3 priv3 bit (1) unal,
  6   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  6   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  6   122        2 ctl_term,					/* control terminal data */
  6   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  6   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  6   125          3 ctl_pad fixed bin,				/* allocation breakage */
  6   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  6   127          3 ctl_input char (32),			/* ctl input stream name */
  6   128          3 ctl_output char (32),			/* ctl output stream name */
  6   129          3 ctl_io char (32),				/* ctl i/o stream name */
  6   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  6   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  6   132          3 ctl_device char (32),			/* ctl terminal device name */
  6   133          3 form_type char (16),			/* format type if printing forms */
  6   134          3 attached bit (1) unal,			/* ctl term attached to process */
  6   135          3 forms bit (1) unal,			/* on if printing forms */
  6   136          3 pad bit (34) unal,
  6   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  6   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  6   139 
  6   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
      561 
      562  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  7     2 /* format: style3,idind30 */
  7     3 
  7     4 /* structure returned when message is read from a message segment */
  7     5 
  7     6 
  7     7 dcl	mseg_message_info_ptr	pointer;
  7     8 
  7     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  7    10 	  2 version		char (8) aligned,
  7    11 	  2 message_code		fixed bin,
  7    12 	  2 control_flags		unaligned,
  7    13 	    3 own			bit (1),
  7    14 	    3 delete		bit (1),
  7    15 	    3 pad			bit (34),
  7    16 	  2 ms_ptr		ptr,		/* pointer to message */
  7    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  7    18 	  2 ms_id			bit (72),		/* unique ID of message */
  7    19 						/* input in some cases */
  7    20 	  2 ms_access_class		bit (72),		/* message access class */
  7    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  7    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  7    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  7    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  7    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  7    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  7    27 
  7    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  7    29 
  7    30 declare	(
  7    31 	MSEG_READ_FIRST		init (1),
  7    32 	MSEG_READ_LAST		init (2),
  7    33 	MSEG_READ_SPECIFIED		init (3),
  7    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  7    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  7    36 	fixed bin int static options (constant);
  7    37 
  7    38 declare  (MSEG_READ_OWN		init ("1"b),
  7    39 	MSEG_READ_DELETE		init ("01"b)
  7    40 	)			bit (36) aligned internal static options (constant);
  7    41 
  7    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      562 
      563  /* BEGIN INCLUDE FILE ... output_request_data.incl.pl1 */
  8     2 
  8     3 /* Modified by R. McDonald May 1980 to include page charges (UNCA) */
  8     4 /* Modified by C. Marker October 1983 added no_separator */
  8     5 
  8     6 
  8     7 /****^  HISTORY COMMENTS:
  8     8*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  8     9*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  8    10*     Add the line_nbrs bit for line-numbered output.
  8    11*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  8    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  8    13*     Added single_sheet bit to denote if continuous paper.
  8    14*                                                   END HISTORY COMMENTS */
  8    15 
  8    16 
  8    17      dcl	   1 ordata	      based (ordatap) aligned,
  8    18 	     2 dpmp	      ptr,		/* Ptr to dprint_msg */
  8    19 	     2 requestor	      char (32),		/* Person.Proj.tag requesting */
  8    20 	     2 full_path	      char (168),		/* source of the output */
  8    21 	     2 queue	      fixed bin,		/* Queue requested. */
  8    22 	     2 copies	      fixed bin,		/* Copies requested. */
  8    23 	     2 copy_no	      fixed bin,		/* Number this copy */
  8    24 	     2 request_no	      fixed bin (35),	/* Number request assigned by coord */
  8    25 	     2 restart_no	      fixed bin (35),	/* old number of restarted request (0 = not restarted) */
  8    26 	     2 request_type	      char (32),		/* Name of device class wanted. */
  8    27 	     2 access_class_string char (280),		/* Access class - size limit for two printer lines */
  8    28 	     2 punsw	      fixed bin,		/* 0 = print, 1= punch */
  8    29 	     2 delete	      fixed bin,		/* 1= delete, 0= don't */
  8    30 	     2 device_name	      char (32),		/* Name of physical device used */
  8    31 	     2 output_mode	      char (128),		/* user's mode string for ios_$changemode */
  8    32 	     2 time_start_request fixed bin (71),	/* Clock time when picked request */
  8    33 	     2 date_time_start_request char (24),	/* .. in chars too */
  8    34 	     2 line_count	      fixed bin (24),	/* Line count returned by DIM */
  8    35 	     2 page_count	      fixed bin,		/* Page count returned by DIM */
  8    36 	     2 cpu_time	      fixed bin (71),	/* Total CPU usage while printing */
  8    37 	     2 real_time	      fixed bin (71),	/* Total realtime while printing */
  8    38 	     2 page_waits	      fixed bin,		/* Total page-waits while printing */
  8    39 	     2 pre_pages	      fixed bin,		/* Total pre-pages (???) .. */
  8    40 	     2 bit_count	      fixed bin (24),	/* Number of bits transmitted. */
  8    41 	     2 charge	      float bin,		/* What the thing cost. */
  8    42 	     2 control_flags,
  8    43 	       3 continued	      bit (1) unal,		/* request started by one driver and given to another */
  8    44 	       3 restarted	      bit (1) unal,		/* request is restarted */
  8    45 	       3 separator	      bit (1) unal,		/* used to determine necessity of a separator page  */
  8    46 	       3 notify	      bit (1) unal,		/* if should confirm to user */
  8    47 	       3 saved	      bit (1) unal,		/* request was suspended by operator, we'll save it */
  8    48 	       3 priority_request bit (1) unal,		/* operator said run now!! */
  8    49 	       3 no_separator     bit (1) unal,		/* suppress inner head and tail sheets when printing multiple copies */
  8    50 	       3 line_nbrs	      bit (1) unal,		/* if line-numbered output requested */
  8    51 	       3 single_sheet     bit (1) unal,		/* ON if single_sheet output */
  8    52 	       3 padding	      bit (27) unal,	/* not used */
  8    53 	     2 contd_no	      fixed bin (35),	/* old number of continued request (0 = not continued) */
  8    54 	     2 total_charge	      float bin,		/* total charge for all copies */
  8    55 	     2 price_per_n_lines  float bin,		/* line price rate used to compute charge */
  8    56 	     2 n_lines_for_price  fixed bin,		/* number of lines price is based on */
  8    57 	     2 charge_queue	      fixed bin,		/* base charge rate on this queue */
  8    58 	     2 price_per_n_pages  float bin,		/* page charge rate used to compute charge */
  8    59 	     2 n_pages_for_price  fixed bin,		/* number of pages price is based on */
  8    60 	     2 rs_number	      fixed bin (9) unsigned unaligned, /* rate_structure number used */
  8    61 	     2 rs_unavailable     bit (1) unaligned,	/* 1=>couldn't read SAT */
  8    62 	     2 no_accounting      bit (1) unaligned,	/* 1=>accounting:nothing in iod_tables */
  8    63 	     2 pad_bits	      bit (25) unaligned,
  8    64 	     2 line_nbr	      fixed bin (35),	/* current line number */
  8    65 	     2 pad_space	      (6) fixed bin (35);	/* save some room to grow */
  8    66 
  8    67      dcl	   ordatap	      ptr;		/* Ptr to above structure */
  8    68 
  8    69      dcl	   1 REQUEST	      like ordata aligned;	/* If wanted, a place to put the above thing */
  8    70 
  8    71 /* END INCLUDE FILE ... output_request_data.incl.pl1 */
      563 
      564  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
  9     2 
  9     3 /* This is the message header used for standard system queue messages, namely:
  9     4*   IO daemon requests, absentee requests, retrieval requests.
  9     5**/
  9     6 
  9     7 /* Written by Jerry Whitmore, Spring 1978.
  9     8*   Modified by T. Casey, November 1978, to add values for state.
  9     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
  9    10**/
  9    11 
  9    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
  9    13     2 msg_time fixed bin (71),			/* date and time of request */
  9    14     2 hdr_version fixed bin,				/* version of this declaration */
  9    15     2 dirname char (168),				/* directory name */
  9    16     2 ename char (32),				/* entry name of file requested */
  9    17     2 message_type fixed bin,				/* message format descriptor   */
  9    18 						/* 0 = absentee request        */
  9    19 						/* 1 = print request           */
  9    20 						/* 2 = punch request           */
  9    21 						/* 3 = tape request            */
  9    22 						/* 4 = retrieval request       */
  9    23     2 bit_flags,
  9    24       3 delete_sw bit (1) unal,			/* delete file when done */
  9    25       3 notify bit (1) unal,				/* user wants to be notified */
  9    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
  9    27       3 padding bit (33) unal,
  9    28     2 state fixed bin,				/* stage of processing after being queued:
  9    29*						   0 = initial unprocessed state, 1 = deferred,
  9    30*						   2 = in state transition, 3 = eligible, 4 = running,
  9    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
  9    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
  9    33     2 std_length fixed bin,				/* length of std msg for this type */
  9    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
  9    35     2 hdr_pad (3) fixed bin;
  9    36 
  9    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
  9    38 
  9    39 /* Values for queue_msg_hdr.state */
  9    40 
  9    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
  9    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
  9    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
  9    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
  9    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
  9    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
  9    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
  9    48 
  9    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
      564 
      565  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 10     2 
 10     3 /* Descriptor associated with an I/O daemon request */
 10     4 /* Coded August 1973 by Robert S. Coren */
 10     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 10     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 10     7 
 10     8 dcl  1 request_descriptor based aligned,
 10     9 	2 mseg_message_info_copy like mseg_message_info,
 10    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 10    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 10    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 10    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 10    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 10    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 10    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 10    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 10    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 10    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 10    20 	2 driver_data bit(252),	/* driver maintained data */
 10    21 	2 flags,
 10    22 	   (3 continued,		/* unfinished by one driver and given to another */
 10    23 	    3 finished,
 10    24 	    3 restarted,
 10    25 	    3 cancelled,
 10    26 	    3 dont_delete,
 10    27 	    3 saved,		/* not to be freed */
 10    28 	    3 keep_in_queue,	/* keep request in queue */
 10    29 	    3 series_restart,	/* this request is part of restarted series */
 10    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 10    31 	    3 pad bit(27) unal,
 10    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 10    33 
 10    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
      565 
      566  /* BEGIN INCLUDE FILE ..... rqti_header.incl.pl1 .....   */
 11     2 
 11     3 
 11     4 dcl 1 rqti_header aligned based,			/* header for a request type info seg */
 11     5     2 time_created fixed bin (71),			/* clock time when table was translated */
 11     6     2 header_version fixed bin,			/* version number of the header alone */
 11     7     2 type_code fixed bin,				/* 0 = header only */
 11     8 						/* 1 = printer generic type */
 11     9 						/* 2 = punch   generic type */
 11    10 						/* 3 = tape    generic type */
 11    11     2 rqti_switches,
 11    12      (3 meter bit (1),				/* meter this request type */
 11    13       3 auto_go bit (1),				/* driver should not request a go command */
 11    14       3 rqti_sw_pad bit (34)) unal,				/* room to grow */
 11    15     2 driver_wait_time fixed bin,			/* seconds to wait, before asking coord for service */
 11    16     2 header_pad (10) fixed bin;			/* leave 10 words for future generations */
 11    17 
 11    18 dcl  rqti_header_version_1 fixed bin int static options (constant) init (1);
 11    19 
 11    20 
 11    21 /* END INCLUDE FILE ..... rqti_header.incl.pl1 .... */
      566 
      567 
      568      end punch_driver_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/01/90  1530.0  punch_driver_.pl1                 >spec>install>1034>punch_driver_.pl1
556          1    06/28/79  1304.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
557          2    11/09/88  0859.7  dprint_msg.incl.pl1               >ldd>include>dprint_msg.incl.pl1
558          3    11/09/88  0859.7  driver_status.incl.pl1            >ldd>include>driver_status.incl.pl1
559          4    11/09/88  0859.7  iod_constants.incl.pl1            >ldd>include>iod_constants.incl.pl1
560          5    11/09/88  0859.7  iod_tables_hdr.incl.pl1           >ldd>include>iod_tables_hdr.incl.pl1
561          6    11/09/88  0859.7  iodd_static.incl.pl1              >ldd>include>iodd_static.incl.pl1
562          7    01/10/85  2102.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
563          8    11/09/88  0859.7  output_request_data.incl.pl1      >ldd>include>output_request_data.incl.pl1
564          9    08/31/82  1736.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
565         10    03/15/85  1053.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
566         11    02/23/78  1729.0  rqti_header.incl.pl1              >ldd>include>rqti_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTACH_TYPE_IOM                        constant        fixed bin(17,0)          initial dcl 4-15 ref 162
a_stream                               parameter       char                     packed unaligned dcl 346 ref 344
access_class                    000155 automatic       char(36)                 dcl 62 set ref 399* 414*
access_class_string     101            based           char(280)                level 2 dcl 8-17 ref 399
add_char_offset_                000370 constant        entry                    external dcl 73 ref 175
addr                                                   builtin function         dcl 138 ref 175 175 185 186 191 202 203 204 212 213
                                                                                  288 289 386 438 438 438 438 446 446 455 499 499
                                                                                  500 501 503 550 550 551
after                                                  builtin function         dcl 138 ref 395
alarm_channel                   000214 internal static fixed bin(71,0)          dcl 104 set ref 230* 236* 381*
aligned                   4     000233 internal static bit(1)                   level 2 packed packed unaligned dcl 122 set ref 507
arg                      23            based           varying char(64)         array level 2 dcl 468 ref 489
arg_list                               based           structure                level 1 dcl 468
arg_list_p                             parameter       pointer                  dcl 465 ref 459 474 481 485 488 489 495
arg_p                                  parameter       pointer                  dcl 155 ref 153 157
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 6-17 ref 168
attach_name             136            based           char(32)                 level 2 dcl 6-17 set ref 184* 191*
attach_type             146            based           fixed bin(17,0)          level 2 dcl 6-17 ref 162
attached                436            based           bit(1)                   level 3 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 6-17 in procedure "punch_driver_"
                                                                                  ref 227 362 497
attached                 47            based           bit(1)                   level 3 in structure "driver_status" packed packed
                                                                                  unaligned dcl 3-25 in procedure "punch_driver_"
                                                                                  set ref 220*
auto_go                   4(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-4 ref 252
banner_stream                   000145 automatic       char(32)                 dcl 61 set ref 356* 420* 446* 550*
before                                                 builtin function         dcl 138 ref 391 395 399
bit_rate_est            132            based           fixed bin(35,0)          level 2 dcl 3-25 set ref 224*
both                            000054 constant        fixed bin(17,0)          initial dcl 107 set ref 242* 249* 267* 292* 298*
                                                                                  312* 326* 503*
c_code                                 parameter       fixed bin(35,0)          dcl 466 set ref 459 475* 487* 496* 501* 510*
cancelled                53(03)        based           bit(1)                   level 3 packed packed unaligned dcl 10-8 set ref
                                                                                  303* 331*
card_header                     000010 internal static char(512)                dcl 99 set ref 403* 410* 430* 432* 444* 446 446
channel                   2     000220 internal static fixed bin(71,0)          level 2 dcl 111 set ref 229* 235* 373* 375*
chars                     1            based           char                     level 2 packed packed unaligned dcl 5-39 set ref 175
                                                                                  175
cleanup                         000172 stack reference condition                dcl 143 ref 196
clock_                          000372 constant        entry                    external dcl 74 ref 265 265
code                                   based           fixed bin(35,0)          level 2 in structure "st" dcl 66 in procedure
                                                                                  "punch_driver_" set ref 185 186 191* 202 203 204*
                                                                                  212 213* 455 500 501 503* 551
code                                   parameter       fixed bin(35,0)          dcl 354 in procedure "punch_driver_" set ref 344 365
                                                                                  448* 451* 455*
command                   2            based           varying char(64)         level 2 dcl 468 ref 474 481 485 495
condition                       000200 automatic       char(32)                 packed unaligned dcl 519 set ref 521* 523*
condition_info                         based           structure                level 1 dcl 1-14
condition_info_ptr                     parameter       pointer                  dcl 1-10 ref 517 521
condition_name            3            based           varying char(32)         level 2 dcl 1-14 ref 521
control                 102            based           structure                level 2 dcl 2-20
copies                   65            based           fixed bin(17,0)          level 2 dcl 8-17 set ref 403*
copy_no                  66            based           fixed bin(17,0)          level 2 dcl 8-17 set ref 403*
ctl_ev_chan             420            based           fixed bin(71,0)          level 3 dcl 6-17 ref 229 230
ctl_msg_sent                    000210 internal static bit(1)                   initial packed unaligned dcl 102 set ref 336* 369*
                                                                                  371* 372 378* 384* 434* 436 437*
ctl_output              370            based           char(32)                 level 3 dcl 6-17 set ref 231* 363* 499* 507* 510*
ctl_term                344            based           structure                level 2 dcl 6-17
ctl_wait_list                   000220 internal static structure                level 1 dcl 111 set ref 438 438
cv_dec_check_                   000374 constant        entry                    external dcl 75 ref 489
data_ptr                               parameter       pointer                  dcl 352 set ref 344 363* 387
date_string                     000100 automatic       char(24)                 packed unaligned dcl 50 set ref 265* 267*
date_time_                      000376 constant        entry                    external dcl 76 ref 265
date_time_start_request
                        264            based           char(24)                 level 2 dcl 8-17 ref 403 403 403 403
defer_time_limit        133            based           fixed bin(35,0)          level 2 dcl 3-25 set ref 225*
descriptor              146            based           structure                level 2 dcl 3-25 set ref 288
dest                            000117 automatic       char(24)                 packed unaligned dcl 59 set ref 395* 397* 403 403
                                                                                  403 403
destination             130            based           char(24)                 level 2 dcl 2-20 ref 395 397
dev_in_stream           106            based           char(32)                 level 2 dcl 6-17 set ref 182*
dev_io_stream            76            based           char(32)                 level 2 dcl 6-17 set ref 181*
dev_name_label           10            based           char(32)                 level 2 dcl 3-25 set ref 267*
dev_out_stream          116            based           char(32)                 level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "punch_driver_" set ref 180* 181 184*
                                                                                  201* 204* 223 534*
dev_out_stream           72            based           char(32)                 level 2 in structure "driver_status" dcl 3-25
                                                                                  in procedure "punch_driver_" set ref 223*
device_dim              126            based           char(32)                 level 2 dcl 6-17 set ref 178* 179 179* 184*
dim                      11     000240 internal static char(32)                 initial array level 2 dcl 130 set ref 201* 213*
dmp                             000210 automatic       pointer                  dcl 2-18 set ref 289* 291 297 298 308 308 308 312
                                                                                  320 320 323 326 386* 391 393 395 397
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 10-8 set ref
                                                                                  304*
dprint_msg                             based           structure                level 1 dcl 2-20
dprint_msg_version_3                   constant        fixed bin(17,0)          initial dcl 2-62 ref 308
dprint_msg_version_4                   constant        fixed bin(17,0)          initial dcl 2-62 ref 308 320
dprint_msg_version_5                   constant        fixed bin(17,0)          initial dcl 2-62 ref 308
driver_ptr              304            based           pointer                  level 2 dcl 6-17 ref 158 287 386 482
driver_status                          based           structure                level 1 dcl 3-25
driver_status_ptr               000212 automatic       pointer                  dcl 3-24 set ref 158* 218 219 220 221 222 223 224
                                                                                  225 239 240 267 287* 288 289 297 381
driver_wait_time          5            based           fixed bin(17,0)          level 2 dcl 11-4 ref 253
ec                              000106 automatic       fixed bin(35,0)          dcl 51 set ref 163* 164* 169* 170* 248* 249* 338*
                                                                                  339 363* 364 366* 373* 374 379* 438* 489* 490
elem_size               112            based           fixed bin(17,0)          level 2 dcl 3-25 set ref 218*
ename                    55            based           char(32)                 level 3 dcl 2-20 set ref 298* 312* 326*
error_table_$action_not_performed
                                000444 external static fixed bin(35,0)          dcl 148 ref 365 451
error_table_$fatal_error        000446 external static fixed bin(35,0)          dcl 149 set ref 163 169 242* 248
error_table_$ionmat             000450 external static fixed bin(35,0)          dcl 150 ref 186 203
event_info                      000224 internal static structure                level 1 dcl 115 set ref 438 438
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 10-8 set ref
                                                                                  305*
first_char              164            based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 6-17
                                                                                  ref 175
flags                   310            based           structure                level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "punch_driver_"
flags                    53            based           structure                level 2 in structure "request_descriptor" dcl 10-8
                                                                                  in procedure "punch_driver_"
form_info                       000233 internal static structure                level 1 dcl 122 set ref 499 499
form_type               432            based           char(16)                 level 3 dcl 6-17 set ref 262* 263 263* 363* 483*
                                                                                  510*
form_wait_time          114            based           fixed bin(71,0)          level 2 dcl 3-25 set ref 222* 381* 482*
forms                   436(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 498
full_path                12            based           char(168)                level 2 dcl 8-17 set ref 416*
hdr_version               2            based           fixed bin(17,0)          level 3 dcl 2-20 ref 291
head                            000125 automatic       char(64)                 dcl 60 set ref 391* 393*
header                                 based           structure                level 2 dcl 2-20
header_version            2            based           fixed bin(17,0)          level 2 dcl 11-4 set ref 241 242*
heading                 136            based           char                     level 2 dcl 2-20 ref 391 393
heading_lth             106            based           fixed bin(17,0)          level 2 dcl 2-20 ref 391 393
i                               000107 automatic       fixed bin(17,0)          dcl 52 set ref 200* 201 201 204* 210* 211 211 213*
                                                                                  323* 325 325 338 338 535* 536*
initial_bit_rate                       constant        fixed bin(17,0)          initial dcl 109 ref 224
io_stat                         000110 automatic       bit(72)                  dcl 53 set ref 184* 185 186 191 201* 202 203 204
                                                                                  211* 212 213 231* 420* 446* 455 499* 500 501 503
                                                                                  507* 534* 536* 550* 551
ioa_$rsnnl                      000400 constant        entry                    external dcl 77 ref 403 430
iodd_listen_                    000402 constant        entry                    external dcl 78 ref 269
iodd_msg_                       000404 constant        entry                    external dcl 79 ref 164 170 191 204 213 242 249 267
                                                                                  292 298 312 326 366 379 476 477 478 503 512
iodd_parse_$args                000406 constant        entry                    external dcl 80 ref 178 262
iodd_static                            based           structure                level 1 dcl 6-17
ios_$attach                     000410 constant        entry                    external dcl 81 ref 184 201
ios_$changemode                 000412 constant        entry                    external dcl 82 ref 231
ios_$detach                     000414 constant        entry                    external dcl 83 ref 534 536
ios_$getsize                    000420 constant        entry                    external dcl 85 ref 211
ios_$order                      000416 constant        entry                    external dcl 84 ref 420 499 507
ios_$write                      000422 constant        entry                    external dcl 86 ref 446 550
ipc_$block                      000424 constant        entry                    external dcl 87 ref 438
ipc_$drain_chn                  000426 constant        entry                    external dcl 88 ref 373
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 10-8 set ref
                                                                                  294* 317*
length                                                 builtin function         dcl 138 in procedure "punch_driver_" ref 548
length                                 based           fixed bin(17,0)          level 2 in structure "text_strings" dcl 5-39
                                                                                  in procedure "punch_driver_" ref 175 175
line_nbrs               102(08)        based           bit(1)                   level 3 packed packed unaligned dcl 2-20 set ref
                                                                                  320*
major_args                             based           char                     packed unaligned dcl 54 in procedure "punch_driver_"
                                                                                  set ref 178* 262*
major_args              164            based           structure                level 2 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 6-17 in procedure "punch_driver_"
major_args_length               000114 automatic       fixed bin(17,0)          dcl 56 set ref 176* 178 178 262 262
major_args_ptr                  000112 automatic       pointer                  dcl 55 set ref 175* 178 262
master                          000072 constant        fixed bin(17,0)          initial dcl 106 set ref 164* 170* 191* 204* 213*
                                                                                  366* 379*
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 set ref
                                                                                  502*
message                 240            based           fixed bin(17,0)          level 2 dcl 3-25 set ref 289 386
message_type            113            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 3-25
                                                                                  in procedure "punch_driver_" set ref 219* 297
message_type             65            based           fixed bin(17,0)          level 3 in structure "dprint_msg" dcl 2-20
                                                                                  in procedure "punch_driver_" ref 297
meter                     4            based           bit(1)                   level 3 packed packed unaligned dcl 11-4 ref 254
meter_sw                        000216 internal static bit(1)                   packed unaligned dcl 105 set ref 254* 259*
mseg_message_info                      based           structure                level 1 dcl 7-9
mseg_message_info_copy                 based           structure                level 2 dcl 10-8
n_tokens                  1            based           fixed bin(17,0)          level 2 dcl 468 ref 488
name                            000240 internal static char(32)                 initial array level 2 dcl 130 set ref 201* 204* 211*
                                                                                  338* 356 536*
nelm                            000115 automatic       fixed bin(17,0)          dcl 57 set ref 403* 430* 548* 549 550*
nelt                            000116 automatic       fixed bin(17,0)          dcl 58 set ref 446* 550*
null                                                   builtin function         dcl 138 ref 239 420 420 507 507
number                          000220 internal static fixed bin(17,0)          level 2 dcl 111 set ref 228* 234* 372 376*
ordata                                 based           structure                level 1 dcl 8-17
ordatap                         000216 automatic       pointer                  dcl 8-67 set ref 387* 391 395 399 403 403 403 403
                                                                                  403 403 403 412 416
output_module           101            based           fixed bin(17,0)          level 2 dcl 2-20 ref 323
output_request_                 000430 constant        entry                    external dcl 89 ref 338
output_request_$error_during_request
                                000432 constant        entry                    external dcl 90 ref 523
p2                              000166 automatic       pointer                  dcl 63 set ref 240* 241 242 247 247 252 253 254 288*
                                                                                  292 292 294 298 298 298 303 304 305 312 312 312
                                                                                  317 326 326 326 331
q                        33            based           fixed bin(17,0)          level 2 dcl 10-8 set ref 292* 298* 312* 326*
queue_msg_hdr                          based           structure                level 1 dcl 9-12
queue_msg_hdr_version_1                constant        fixed bin(17,0)          initial dcl 9-37 ref 291
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 set ref
                                                                                  335* 360* 434
ready                    47(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-25 set ref
                                                                                  221*
request_descriptor                     based           structure                level 1 dcl 10-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 523
request_no               67            based           fixed bin(35,0)          level 2 dcl 8-17 set ref 403*
requestor                 2            based           char(32)                 level 2 dcl 8-17 set ref 391 395 412*
retry_sw                        000170 automatic       bit(1)                   packed unaligned dcl 64 set ref 160* 186 187* 203
rqti_header                            based           structure                level 1 dcl 11-4
rqti_header_version_1           000072 constant        fixed bin(17,0)          initial dcl 11-18 set ref 241 242*
rqti_ptr                 64            based           pointer                  level 2 dcl 3-25 ref 239 240
rqti_switches             4            based           structure                level 2 dcl 11-4
rtrim                                                  builtin function         dcl 138 ref 548
sender_id                13            based           char(32)                 level 3 packed packed unaligned dcl 10-8 set ref
                                                                                  298* 312* 326*
seq_id                   32            based           fixed bin(35,0)          level 2 dcl 10-8 set ref 292* 298* 312* 326*
size                     10     000240 internal static fixed bin(17,0)          initial array level 2 dcl 130 set ref 211* 338*
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 set ref
                                                                                  252* 257* 339* 367* 377*
source                                 parameter       fixed bin(17,0)          dcl 461 set ref 459 476* 477* 478* 512*
st                                     based           structure                level 1 dcl 66
stat_p                          000366 internal static pointer                  dcl 6-15 set ref 157* 158 159 162 168 175 176 178
                                                                                  179 179 180 181 181 182 184 184 184 191 201 204
                                                                                  223 227 229 230 231 252 253 257 258 262 263 263
                                                                                  269* 287 335 338* 339 360 362 363 363 367 377 386
                                                                                  425 434 478 482 483 486 497 498 499 502 507 510
                                                                                  510 523 534
state                                  parameter       fixed bin(17,0)          dcl 462 ref 459
status_flags             47            based           structure                level 2 dcl 3-25
string                                 parameter       char                     dcl 546 set ref 544 548 550 550
substr                                                 builtin function         dcl 138 ref 403 403 403 403 403 403 403 403
sw                              000240 internal static structure                array level 1 dcl 130
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 425 478
                                                                                  486
text_offset                            based           structure                level 1 packed packed unaligned dcl 5-45
text_strings                           based           structure                level 1 dcl 5-39
text_strings_ptr                000214 automatic       pointer                  dcl 5-38 in procedure "punch_driver_" set ref 159*
                                                                                  175 175
text_strings_ptr         14            based           pointer                  level 2 in structure "iodd_static" dcl 6-17
                                                                                  in procedure "punch_driver_" ref 159
time                            000212 internal static fixed bin(71,0)          initial dcl 103 set ref 425 425* 489* 490* 492*
timer_manager_$alarm_wakeup     000434 constant        entry                    external dcl 91 ref 381
timer_manager_$sleep            000436 constant        entry                    external dcl 92 ref 425
total_chars             164(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 6-17
                                                                                  ref 176
type                                   parameter       fixed bin(17,0)          dcl 348 ref 344 358 423 442
type_code                 3            based           fixed bin(17,0)          level 2 dcl 11-4 ref 247 247
version                  76            based           fixed bin(17,0)          level 2 dcl 2-20 ref 308 308 308 320
wakeup_time             300            based           fixed bin(71,0)          level 2 dcl 6-17 set ref 253* 258*
whoami                          000000 constant        char(24)                 initial packed unaligned dcl 108 set ref 164* 170*
                                                                                  191* 204* 213* 242* 249* 366* 379* 503*
write_control_form_             000440 constant        entry                    external dcl 93 ref 363
write_sample_form_              000442 constant        entry                    external dcl 94 ref 510
xxbar                           000006 constant        char(22)                 initial dcl 100 set ref 403* 418* 430* 444 444

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATTACH_TYPE_DIAL                       internal static fixed bin(17,0)          initial dcl 4-15
ATTACH_TYPE_TTY                        internal static fixed bin(17,0)          initial dcl 4-15
ATTACH_TYPE_VARIABLE_LINE              internal static fixed bin(17,0)          initial dcl 4-15
CTL_ATTACH_TYPE_DIAL                   internal static fixed bin(17,0)          initial dcl 4-21
CTL_ATTACH_TYPE_MC                     internal static fixed bin(17,0)          initial dcl 4-21
CTL_ATTACH_TYPE_TTY                    internal static fixed bin(17,0)          initial dcl 4-21
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 5-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 7-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 7-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 7-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 7-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 7-30
PAPER_TYPE_CONTINUOUS                  internal static fixed bin(17,0)          initial dcl 4-26
PAPER_TYPE_DEFAULT                     internal static fixed bin(17,0)          initial dcl 4-26
PAPER_TYPE_SINGLE                      internal static fixed bin(17,0)          initial dcl 4-26
REQUEST                                automatic       structure                level 1 dcl 8-69
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 9-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 9-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 9-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 9-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 9-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 9-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 9-41
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 1-30
forms_max_lth                          internal static fixed bin(17,0)          initial dcl 2-55
head_max_lth                           internal static fixed bin(17,0)          initial dcl 2-55
iod_tables_hdr                         based           structure                level 1 dcl 5-23
ithp                                   automatic       pointer                  dcl 5-22
label_max_lth                          internal static fixed bin(17,0)          initial dcl 2-55
mseg_message_info_ptr                  automatic       pointer                  dcl 7-7
path_max_lth                           internal static fixed bin(17,0)          initial dcl 2-55

NAMES DECLARED BY EXPLICIT CONTEXT.
attach                          001027 constant        label                    dcl 184 ref 189
be_nice                         002202 constant        label                    dcl 304 ref 295 318 332
clean_out                       002024 constant        label                    dcl 271 ref 206 214 245 250
command                         003426 constant        entry                    external dcl 459
default_handler                 004156 constant        entry                    external dcl 517
detach_all                      004211 constant        entry                    internal dcl 530 ref 188 196 271
flip_err                        003415 constant        label                    dcl 455 set ref 551
init                            000600 constant        entry                    external dcl 153
print_banner                    002445 constant        entry                    external dcl 344 ref 338 338
punch_driver_                   000567 constant        entry                    external dcl 16
request                         002032 constant        entry                    external dcl 277
retry                           001070 constant        label                    dcl 187 ref 203
write_msg                       004303 constant        entry                    internal dcl 544 ref 410 412 414 416 418 432

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4764        5436    4412        4774
Length      6156    4412       452         504     352         360

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
punch_driver_                       318 external procedure  is an external procedure.  
on unit on line 196                  64 on unit               
detach_all                           84 internal procedure  is called by several nonquick procedures.  
write_msg                               internal procedure  shares stack frame of external procedure punch_driver_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 card_header                 punch_driver_
000210 ctl_msg_sent                punch_driver_
000212 time                        punch_driver_
000214 alarm_channel               punch_driver_
000216 meter_sw                    punch_driver_
000220 ctl_wait_list               punch_driver_
000224 event_info                  punch_driver_
000233 form_info                   punch_driver_
000240 sw                          punch_driver_
000366 stat_p                      punch_driver_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
punch_driver_            000100 date_string                 punch_driver_
                         000106 ec                          punch_driver_
                         000107 i                           punch_driver_
                         000110 io_stat                     punch_driver_
                         000112 major_args_ptr              punch_driver_
                         000114 major_args_length           punch_driver_
                         000115 nelm                        punch_driver_
                         000116 nelt                        punch_driver_
                         000117 dest                        punch_driver_
                         000125 head                        punch_driver_
                         000145 banner_stream               punch_driver_
                         000155 access_class                punch_driver_
                         000166 p2                          punch_driver_
                         000170 retry_sw                    punch_driver_
                         000200 condition                   punch_driver_
                         000210 dmp                         punch_driver_
                         000212 driver_status_ptr           punch_driver_
                         000214 text_strings_ptr            punch_driver_
                         000216 ordatap                     punch_driver_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              clock_                        cv_dec_check_                 date_time_
ioa_$rsnnl                    iodd_listen_                  iodd_msg_                     iodd_parse_$args
ios_$attach                   ios_$changemode               ios_$detach                   ios_$getsize
ios_$order                    ios_$write                    ipc_$block                    ipc_$drain_chn
output_request_               output_request_$error_during_request                        timer_manager_$alarm_wakeup
timer_manager_$sleep          write_control_form_           write_sample_form_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$fatal_error      error_table_$ionmat




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000566        18 000574       153 000575       157 000605       158 000612       159 000614       160 000616
    162 000620       163 000623       164 000625       165 000662       168 000663       169 000666       170 000670
    171 000725       175 000726       176 000746       178 000753       179 001007       180 001016       181 001021
    182 001024       184 001027       185 001057       186 001063       187 001070       188 001071       189 001075
    191 001076       193 001140       196 001141       200 001163       201 001171       202 001222       203 001226
    204 001233       206 001303       208 001304       210 001306       211 001313       212 001335       213 001341
    214 001405       216 001406       218 001410       219 001413       220 001415       221 001417       222 001421
    223 001423       224 001430       225 001432       227 001433       228 001436       229 001440       230 001442
    231 001444       232 001475       234 001476       235 001477       236 001501       239 001502       240 001507
    241 001511       242 001514       245 001560       247 001561       248 001565       249 001570       250 001625
    252 001626       253 001640       254 001643       255 001646       257 001647       258 001653       259 001655
    262 001656       263 001714       265 001723       267 001746       269 002015       271 002024       274 002030
    277 002031       287 002037       288 002043       289 002045       291 002047       292 002052       294 002115
    295 002120       297 002121       298 002124       303 002177       304 002202       305 002205       306 002207
    308 002210       312 002217       317 002272       318 002275       320 002276       323 002302       325 002304
    326 002310       331 002363       332 002366       335 002367       336 002372       338 002373       339 002431
    341 002437       344 002440       356 002460       358 002464       360 002470       362 002473       363 002476
    364 002522       365 002524       366 002531       367 002566       369 002572       370 002573       371 002574
    372 002577       373 002604       374 002614       375 002616       376 002621       377 002622       378 002625
    379 002626       380 002667       381 002670       383 002706       384 002707       386 002710       387 002715
    391 002721       393 002737       395 002742       397 002772       399 002775       403 003005       410 003111
    412 003122       414 003133       416 003136       418 003147       420 003152       421 003203       423 003204
    425 003206       430 003230       432 003263       434 003274       436 003303       437 003305       438 003306
    440 003324       442 003325       444 003327       446 003347       448 003407       449 003411       451 003412
    453 003414       455 003415       456 003420       459 003421       474 003433       475 003443       476 003444
    477 003502       478 003542       480 003610       481 003611       482 003616       483 003623       484 003626
    485 003627       486 003634       487 003641       488 003642       489 003645       490 003701       491 003706
    492 003707       494 003711       495 003712       496 003717       497 003720       498 003725       499 003730
    500 003763       501 003767       502 003771       503 003775       505 004032       507 004033       510 004072
    511 004115       512 004116       514 004153       517 004154       521 004163       523 004172       527 004207
    530 004210       534 004216       535 004243       536 004252       537 004277       538 004302       544 004303
    548 004314       549 004330       550 004331       551 004367       553 004371


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
