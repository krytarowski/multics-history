	COMPILATION LISTING OF SEGMENT monitor_quota
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/16/85  1306.0 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 monitor_quota:
       12      proc;
       13 
       14 
       15 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
       16*
       17*   Calculates  remaining  storage  of  a  directory  and  will
       18*   send  a  warning  message at the approach of a record quota
       19*   overflow   condition.
       20*
       21*   Written by R. Holmstedt 07/09/81
       22*
       23*   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       24 
       25 dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
       26 dcl  all_flag init ("0"b) bit (1);
       27 dcl  arg char (argl) based (argp);
       28 dcl  argl fixed bin (21);
       29 dcl  argp ptr;
       30 dcl  argno fixed bin;
       31 dcl  call_flag init ("0"b) bit (1);
       32 dcl  call_limit fixed bin (21) init (0);
       33 dcl  command_line char (command_line_length) based (command_line_ptr); /* argument after -call */
       34 dcl  command_line_length fixed bin;			/* length of command line */
       35 dcl  command_line_ptr ptr;				/* pointer to command line argument */
       36 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
       37 dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71),
       38      fixed bin (71), fixed bin (35));
       39 dcl  code fixed bin (35);
       40 dcl  console_flag init ("0"b) bit (1);
       41 dcl  console_warn_limit fixed bin (21) init (0);
       42 dcl  com_err_ entry () options (variable);
       43 dcl  cu_$arg_count entry (fixed bin);
       44 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       45 dcl  cu_$cp entry (ptr, fixed bin (21), fixed bin (35));
       46 dcl (error_table_$action_not_performed, error_table_$moderr, error_table_$noentry,
       47      error_table_$no_dir, error_table_$no_append, error_table_$messages_off,
       48      error_table_$inconsistent, error_table_$bad_arg) fixed bin (35) ext static;
       49 dcl  false init ("0"b) bit (1) internal static options (constant);
       50 dcl  hcs_$quota_read entry (char (*), fixed bin (18), fixed bin (71),
       51      bit (36) aligned, bit (36), fixed bin (1), fixed bin (18),
       52      fixed bin (35));
       53 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
       54 dcl  i fixed bin;
       55 dcl  ioa_$rsnnl entry () options (variable);
       56 dcl  linkage_error condition;
       57 dcl  print_flag init ("0"b) bit (1);
       58 dcl  message char (256) varying init ("");
       59 dcl  message_id (10) char (50) init ((10) (1) "");
       60 dcl  monitor_quota$main entry;
       61 dcl  monitor_quota_init_switch init ("0"b) bit (1) int static;
       62 dcl  monitor_quota_ptr ptr int static init (null);
       63 dcl 01 monitor_list aligned based (monitor_quota_ptr),
       64     02 monitor_count fixed bin,
       65     02 monitor (0 refer (monitor_list.monitor_count)),
       66       03 time fixed bin (71),
       67       03 record_limit fixed bin (21),
       68       03 path_name char (168) varying,
       69       03 call_flag bit (1),
       70       03 call_limit fixed bin (21),
       71       03 console_flag bit (1),
       72       03 console_warn_limit fixed bin (21),
       73       03 warn_flag bit (1),
       74       03 warn_limit fixed bin (21),
       75       03 rpt_time fixed bin (71),
       76       03 rpt_flag bit (1),
       77       03 message_id (10) char (50),
       78       03 command_line_length fixed bin,
       79       03 command_line char (256);
       80 dcl  nargs fixed bin;
       81 dcl  off_flag init ("0"b) bit (1);
       82 dcl  one_big_number fixed bin (71) init (377777777777777777777) internal static options (constant);
       83 dcl  quota fixed bin (18);
       84 dcl  record_limit fixed bin (21);
       85 dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
       86 dcl  rpt_flag init ("0"b) bit (1);
       87 dcl  rpt_time fixed bin (71);
       88 dcl  path_flag init ("0"b) bit (1);
       89 dcl  path_name char (168);
       90 dcl  pathname char (168);
       91 dcl  percent fixed bin (6, 3);
       92 dcl  phcs_$ring_0_message entry (char (*));
       93 dcl  prog_name char (13) internal static init ("monitor_quota");
       94 dcl  send_mail_ entry (char (*), char (*), ptr, fixed bin (35));
       95 dcl  send_message_ entry (char (*), char (*), char (*), fixed bin (35));
       96 dcl  sons_lvid bit (36);
       97 dcl  test_entry entry variable;
       98 dcl  time_now fixed bin (71);
       99 dcl  timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry);
      100 dcl  timer_manager_$reset_alarm_call entry (entry);
      101 dcl  true init ("1"b) bit (1) internal static options (constant);
      102 dcl  trp fixed bin (71);
      103 dcl  tup bit (36) aligned;
      104 dcl  tacc_sw fixed bin (1);
      105 dcl  used fixed bin (18);
      106 dcl  warn char (256) varying;
      107 dcl  warn_flag init ("0"b) bit (1);
      108 dcl  warn_limit fixed bin (21) init (0);
      109 dcl (after, before, convert, null, index, addr, substr, length, rtrim, clock, divide) builtin;
      110 dcl  conversion condition;
      111 
      112 
      113 /* ***********  S T A R T************* */
      114 
      115 command_args:
      116 
      117 
      118 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      119 /*					       */
      120 /* This procedure will define the arguments used for     */
      121 /* the command to process. Some checking is done on      */
      122 /* arguments passed in as to valid characters	       */
      123 /*					       */
      124 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      125 
      126 	on conversion goto num_error;
      127 
      128 	call cu_$arg_count (nargs);
      129 
      130 	do argno = 1 to nargs;
      131 
      132 
      133 	     call cu_$arg_ptr (argno, argp, argl, code);
      134 	     if code ^= 0 then goto bad_arg;
      135 
      136 arg_scan:	     if substr (arg, 1, 1) = "-" then do;
      137 
      138 		if arg = "-pathname" | arg = "-pn" then do;
      139 						/* directory to monitor	       */
      140 		     if path_flag then goto dup_arg;
      141 		     path_flag = true;
      142 		     argno = argno + 1;
      143 		     call cu_$arg_ptr (argno, argp, argl, code);
      144 		     if code ^= 0 then goto bad_arg;
      145 		     if substr (arg, 1, 1) = "-" then goto bad_arg;
      146 		     pathname = rtrim (arg);
      147 		     call absolute_pathname_ (pathname, path_name, code);
      148 		     if code ^= 0 then goto bad_arg;
      149 		end;
      150 
      151 		else if arg = "-call" then do;
      152 						/* a command line is to be executed if quota used exceeds limit */
      153 		     if call_flag then go to dup_arg;
      154 		     call_flag = true;
      155 		     argno = argno + 1;
      156 
      157 		     call cu_$arg_ptr (argno, argp, argl, code);
      158 		     if code ^= 0 then goto bad_arg;
      159 		     if substr (arg, 1, 1) = "-" then goto bad_arg;
      160 		     command_line_length = length (arg);
      161 		     command_line_ptr = addr (arg);
      162 		     command_line = arg;
      163 		     argno = argno + 1;		/* see if record count given */
      164 		     if argno > nargs then goto EOL;
      165 		     call cu_$arg_ptr (argno, argp, argl, code);
      166 		     if code ^= 0 then goto bad_arg;
      167 		     if substr (arg, 1, 1) = "-" then goto arg_scan;
      168 		     call_limit = convert (call_limit, (arg));
      169 		end;
      170 
      171 		else if arg = "-console" then do;
      172 						/* send warning to system console    */
      173 		     if console_flag then goto dup_arg;
      174 		     console_flag = true;
      175 		     on linkage_error goto test_link_fail;
      176 						/* this is how to test if the user has access or not, before making the call */
      177 		     test_entry = phcs_$ring_0_message;
      178 		     revert linkage_error;
      179 		     argno = argno + 1;		/* see if record count given */
      180 		     if argno > nargs then goto EOL;
      181 		     call cu_$arg_ptr (argno, argp, argl, code);
      182 		     if code ^= 0 then return;
      183 		     if substr (arg, 1, 1) = "-" then goto arg_scan;
      184 		     console_warn_limit = convert (console_warn_limit, (arg));
      185 		end;
      186 
      187 		else if arg = "-warn" then do;
      188 						/* send warning to this person       */
      189 		     if warn_flag then goto dup_arg;
      190 		     warn_flag = true;
      191 		     argno = argno + 1;		/* get the person_id.proj_id */
      192 		     call cu_$arg_ptr (argno, argp, argl, code);
      193 		     if code ^= 0 then goto bad_arg;
      194 		     if index (arg, ".") = 0 then go to bad_arg;
      195 		     send_mail_info.version = send_mail_info_version_2;
      196 		     send_mail_info.mbz1 = false;
      197 		     send_mail_info.mbz = false;
      198 		     send_mail_info.sent_from = "";
      199 		     send_mail_info.wakeup = true;
      200 		     send_mail_info.always_add = false;
      201 		     send_mail_info.never_add = true;
      202 		     send_mail_info.notify = false;
      203 		     send_mail_info.acknowledge = false;
      204 		     do i = 1 to 10 while (index (arg, ".") ^= 0);
      205 			message_id (i) = arg;
      206 			call send_mail_ (arg, "", addr (send_mail_info), code);
      207 			if code ^= 0 then do;
      208 			     if code ^= error_table_$messages_off then do;
      209 				if code = error_table_$noentry | code = error_table_$no_dir then
      210 				     warn = "No mailbox for "||arg;
      211 				else if code = error_table_$no_append then
      212 				     warn = "Insufficient access to add a message to "||arg||" mailbox";
      213 				else warn = "Sending message to  "||arg;
      214 				goto non_fatal_warn;
      215 			     end;
      216 			end;
      217 
      218 			argno = argno + 1;		/* get the person_id.proj_id */
      219 			if argno > nargs then goto EOL;
      220 			call cu_$arg_ptr (argno, argp, argl, code);
      221 			if code ^= 0 then goto bad_arg;
      222 		     end;
      223 		     if substr (arg, 1, 1) = "-" then goto arg_scan;
      224 		     warn_limit = convert (call_limit, (arg));
      225 		end;
      226 
      227 		else if arg = "-off" then do;
      228 		     if nargs ^= 1 then do;
      229 			warn = "-off must not be given with any other arguments.";
      230 			code = error_table_$inconsistent;
      231 			goto non_fatal_warn;
      232 		     end;
      233 
      234 		     off_flag = true;
      235 		end;
      236 
      237 		else if arg = "-print" | arg = "-pr" then do;
      238 		     if nargs ^= 1 then do;
      239 			warn = "-print must not be given with any other arguments.";
      240 			code = error_table_$inconsistent;
      241 			goto non_fatal_warn;
      242 		     end;
      243 
      244 		     print_flag = true;
      245 		end;
      246 
      247 		else if arg = "-repeat" | arg = "-rpt" then do;
      248 		     if rpt_flag then goto dup_arg;
      249 		     rpt_flag = true;
      250 		     argno = argno + 1;		/* get the repeat time */
      251 		     call cu_$arg_ptr (argno, argp, argl, code);
      252 		     if code ^= 0 then goto bad_arg;
      253 		     time_now = clock ();
      254 		     if code ^= 0 then goto bad_arg;
      255 		     call convert_date_to_binary_$relative (arg, rpt_time, time_now, code);
      256 		     if code ^= 0 then goto bad_arg;
      257 						/* now get the difference	       */
      258 		     rpt_time = rpt_time - time_now;
      259 
      260 
      261 		end;
      262 		else goto bad_arg;
      263 	     end;
      264 	     else goto bad_arg;
      265 	end;
      266 EOL:						/* thats end of line	       */
      267 	revert conversion;
      268 
      269 	call set_up ();
      270 	goto fini;
      271 
      272 
      273 /* \014 */
      274 set_up:	proc;
      275 
      276 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
      277*
      278*   This procedure will evaluate the command arguments and provide
      279*   the defaults where needed.
      280*
      281*   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      282 
      283 dcl date_time_ entry (fixed bin(71), char(*));
      284 dcl  get_wdir_ entry () returns (char (168));
      285 dcl  ioa_	entry() options(variable);
      286 dcl  time_to_print char (24);
      287 dcl  user_info_ entry (char (*), char (*), char (*));
      288 dcl  user_name char (22);
      289 dcl  user_proj char (9);
      290 dcl  user_acct char (32);
      291 
      292 	     if print_flag then do;	/* show user information on monitors */
      293 		if monitor_quota_init_switch = false then do;
      294 				/* nothing to monitor	       */
      295 		     call ioa_ ("monitor_quota: There are no requests active.");
      296 		     return;
      297 		end;
      298 		
      299 		do i = 1 to monitor_list.monitor_count;
      300 				/* go thru the list		       */
      301 
      302 		     call date_time_ (monitor_list.monitor (i).time, time_to_print);
      303 		     call ioa_ ("^/^d)  ^a^/next wakeup interval: ^a  ^/^[warn limit: ^d^;^s^]    ^[console warning limit: ^d^;^s^]    ^[call warning limit: ^d^;^s^]",
      304 		     i,
      305 		     monitor_list.monitor (i).path_name,
      306 		     time_to_print,
      307 		     monitor_list.monitor (i).warn_flag,
      308 		     monitor_list.monitor (i).warn_limit,
      309 		     monitor_list.monitor (i).console_flag,
      310 		     monitor_list.monitor (i).console_warn_limit,
      311 		     monitor_list.monitor (i).call_flag,
      312 		     monitor_list.monitor (i).call_limit);
      313 		end;
      314 		return;
      315 	     end;
      316 	     
      317 
      318 	     if off_flag then do;			/* stop all monitoring	       */
      319 		if monitor_quota_init_switch = false then goto fini;
      320 		else call cleanup;
      321 		return;
      322 	     end;
      323 
      324 
      325 	     if ^path_flag then path_name = get_wdir_ ();
      326 						/* if we don't have a directory get one */
      327 
      328 	     call hcs_$quota_read ((path_name), quota, trp, tup, sons_lvid, tacc_sw, used, code);
      329 	     if code ^= 0 then do;
      330 		warn = "Error reading quota for " ||rtrim (path_name)||".";
      331 		goto non_fatal_warn;
      332 	     end;
      333 
      334 /* figure out record limit to monitor       */
      335 	     if warn_limit = 0 & console_warn_limit = 0 & quota = 0 & ^call_flag then do;
      336 
      337 		code = error_table_$action_not_performed;
      338 		warn = "The quota of "||rtrim (path_name)||" is 0, a record limit needs to be specified.";
      339 		goto non_fatal_warn;
      340 	     end;
      341 
      342 	     if call_limit > quota | warn_limit > quota | console_warn_limit > quota then do;
      343 		warn = "Record limit specified is larger than the quota in " ||rtrim (path_name)||".";
      344 		code = error_table_$bad_arg;
      345 		goto non_fatal_warn;
      346 	     end;
      347 
      348 	     if warn_limit = 0 & console_warn_limit = 0 then record_limit = quota * .80;
      349 						/* set it to 80% of the dir. quota  */
      350 	     else do;
      351 		if console_warn_limit ^= 0 & warn_limit = 0 then record_limit = console_warn_limit;
      352 		if warn_limit ^= 0 & console_warn_limit = 0 then record_limit = warn_limit;
      353 		if console_warn_limit ^= 0 & warn_limit ^= 0 then do;
      354 		     record_limit = console_warn_limit;
      355 		     if warn_limit < record_limit then record_limit = warn_limit;
      356 		end;
      357 	     end;
      358 
      359 	     if call_flag then do;
      360 
      361 		if call_limit = 0 & quota = 0 then do;
      362 		     code = error_table_$action_not_performed;
      363 		     warn = "The quota of "||rtrim (path_name)||" is 0, a record limit needs to be specified.";
      364 		     goto non_fatal_warn;
      365 		end;
      366 
      367 		if call_limit = 0 then call_limit = quota * .90;
      368 						/* set it to 90% of the dir. if user didn't set it */
      369 		if call_limit < record_limit then record_limit = call_limit;
      370 
      371 	     end;
      372 
      373 	     if ^rpt_flag then			/* figure out a good repeat time     */
      374 		call repeat_calc (quota, used, rpt_time);
      375 
      376 
      377 	     if ^warn_flag & ^console_flag & ^call_flag then do;
      378 
      379 /* need to find somebody to tell */
      380 		call user_info_ (user_name, user_proj, user_acct);
      381 		message_id (1) = rtrim (user_name)||"."||rtrim (user_proj);
      382 		warn_flag = true;
      383 		warn_limit = record_limit;
      384 	     end;
      385 
      386 
      387 	     if monitor_quota_init_switch = false then do;
      388 						/* set up static area to keep information about quota */
      389 		call get_temp_segment_ (prog_name, monitor_quota_ptr, code);
      390 		if code ^= 0 then do;
      391 		     warn = "Error from get_temp_segments_.";
      392 		     goto bummer;
      393 		end;
      394 
      395 		monitor_list.monitor_count = 0;
      396 		monitor_quota_init_switch = true;
      397 	     end;
      398 
      399 	     monitor_list.monitor_count = monitor_list.monitor_count + 1;
      400 						/* add another directory to be monitored */
      401 	     monitor_list.monitor (monitor_count).record_limit = record_limit;
      402 	     monitor_list.monitor (monitor_count).path_name = rtrim (path_name);
      403 	     monitor_list.monitor (monitor_count).call_flag = call_flag;
      404 	     monitor_list.monitor (monitor_count).call_limit = call_limit;
      405 	     monitor_list.monitor (monitor_count).console_flag = console_flag;
      406 	     monitor_list.monitor (monitor_count).console_warn_limit = console_warn_limit;
      407 	     monitor_list.monitor (monitor_count).rpt_time = rpt_time;
      408 	     monitor_list.monitor (monitor_count).rpt_flag = rpt_flag;
      409 	     monitor_list.monitor (monitor_count).warn_flag = warn_flag;
      410 	     monitor_list.monitor (monitor_count).warn_limit = warn_limit;
      411 	     monitor_list.monitor (monitor_count).time = time_now + monitor_list.monitor (monitor_count).rpt_time;
      412 
      413 	     if call_flag then do;
      414 		monitor_list.monitor (monitor_count).command_line_length = command_line_length;
      415 		monitor_list.monitor (monitor_count).command_line = command_line;
      416 	     end;
      417 	     else do;
      418 		monitor_list.monitor (monitor_count).command_line_length = 0;
      419 		monitor_list.monitor (monitor_count).command_line = "";
      420 	     end;
      421 
      422 	     do i = 1 to 10;
      423 		monitor_list.monitor (monitor_count).message_id (i) = message_id (i);
      424 	     end;
      425 
      426 	     if record_limit < used then		/* quota problem already! */
      427 		call convert_date_to_binary_ ("", monitor_list.monitor (monitor_count).time, code);
      428 						/* will look like it matured	       */
      429 
      430 
      431 	     call main ();
      432 	     return;
      433 	end set_up;
      434 						/* \014 */
      435 repeat_calc: proc (dir_quota, dir_used, repeat);
      436 dcl  dir_quota fixed bin (18);
      437 dcl  dir_used fixed bin (18);
      438 dcl  repeat fixed bin (71);
      439 dcl  percent fixed bin (6, 3);
      440 dcl  time_value char (5) varying;
      441 
      442 	     percent = divide ((dir_used * 100), dir_quota, 5, 0) ;
      443 
      444 	     if percent < 50 then time_value = "30min";
      445 	     else if percent < 60 then time_value = "20min";
      446 	     else if percent < 70 then time_value = "10min";
      447 	     else if percent < 80 then time_value = "5min";
      448 	     else if percent > 90 then time_value = "1min";
      449 	     else time_value = "2min";
      450 
      451 	     time_now = clock ();
      452 	     call convert_date_to_binary_$relative ((time_value), repeat, time_now, code);
      453 	     if code ^= 0 then do;
      454 		warn = "Error on calculation of repeat value "||time_value||".";
      455 		goto bummer;
      456 	     end;
      457 						/* now get the difference	       */
      458 	     repeat = repeat - time_now;
      459 
      460 	     return;
      461 	end repeat_calc;
      462 						/* \014 */
      463 main:	entry;
      464 
      465 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
      466*
      467*   This entry scans the monitor_list when the alarm timer
      468*   calls into this entry. The next alarm time is calculated
      469*   for all entrys and  the smallest time is selected for
      470*   the next alarm.
      471*   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      472 
      473 
      474 dcl  alarm_time fixed bin (71);
      475 dcl  j fixed bin;
      476 
      477 
      478 
      479 	alarm_time = one_big_number;
      480 						/* need a starting point to compair */
      481 	call timer_manager_$reset_alarm_call (monitor_quota$main);
      482 	time_now = clock ();			/* get the time now		       */
      483 
      484 
      485 
      486 	do i = 1 to monitor_list.monitor_count;
      487 	     if monitor_list.monitor (i).time < time_now then do;
      488 						/* time to check		       */
      489 
      490 		call hcs_$quota_read ((monitor_list.monitor (i).path_name),
      491 		     quota, trp, tup, sons_lvid, tacc_sw, used, code);
      492 		if code ^= 0 then do;
      493 		     warn = "Error reading quota for " ||monitor_list.monitor (i).path_name||".";
      494 		     goto bummer;
      495 		end;
      496 
      497 		if quota = 0 then do;    /* this will check if directory quota was changed to 0*/
      498 		     if monitor_list.monitor_count > 1 then monitor_list.monitor (i).time = one_big_number;
      499 						/* this should stop monitoring for this only */
      500 		     code = error_table_$action_not_performed;
      501 		     warn = "The quota for " ||monitor_list.monitor (i).path_name ||" has been changed to zero.";
      502 		     goto non_fatal_warn;
      503 		end;
      504 
      505 		if used < monitor_list.monitor (i).record_limit then do;
      506 						/* nothing to worry about 	       */
      507 
      508 		     if ^monitor_list.monitor (monitor_count).rpt_flag then
      509 			call repeat_calc (quota, used, monitor_list.monitor (i).rpt_time);
      510 
      511 		     monitor_list.monitor (i).time = time_now + monitor_list.monitor (i).rpt_time;
      512 		     if monitor_list.monitor (i).time < alarm_time then
      513 			alarm_time = monitor_list.monitor (i).time;
      514 						/* set wakeup time to lowest time needed */
      515 
      516 		end;
      517 
      518 		else do;				/* we used more then the limit       */
      519 		     if monitor_list.monitor (i).console_flag then do;
      520 			if monitor_list.monitor (i).console_warn_limit <= used then do;
      521 			     percent = divide ((used * 100), quota, 5, 0) ;
      522 			     message = "";
      523 			     call ioa_$rsnnl ("^a: Storage in ^a is ^d% full.",
      524 				message, (0), prog_name, (monitor_list.monitor (i).path_name), percent);
      525 						/* error message		       */
      526 
      527 
      528 			     on linkage_error go to call_1_failed;
      529 
      530 			     call phcs_$ring_0_message ((message));
      531 			     revert linkage_error;	/* It worked */
      532 			end;
      533 		     end;
      534 
      535 		     if monitor_list.monitor (i).warn_flag then do;
      536 			if monitor_list.monitor (i).warn_limit <= used then do;
      537 						/* check to be sure, may only have call limit or console limit */
      538 			     percent = divide ((used * 100), quota, 5, 0) ;
      539 			     message = "";
      540 			     call ioa_$rsnnl ("^a: Storage in ^a is ^d% full.",
      541 				message, (0), prog_name, (monitor_list.monitor (i).path_name), percent);
      542 			     do j = 1 to 10 while (monitor_list.monitor (i).message_id (j) ^= "");
      543 				call send_message_ ((before (monitor_list.monitor (i).message_id (j), ".")),
      544 				     (after (monitor_list.monitor (i).message_id (j), ".")),
      545 				     (message), code);
      546 				if code ^= 0 then
      547 				     call com_err_ (code, prog_name,
      548 				     "Error sending warning to ^a ^/Quota limit reached in ^a. Monitoring will continue.",
      549 				     monitor_list.monitor (i).message_id (j), monitor_list.monitor (i).path_name);
      550 						/* tell someone		       */
      551 			     end;
      552 			end;
      553 
      554 		     end;
      555 
      556 
      557 		     if monitor_list.monitor (i).call_flag then do;
      558 			if monitor_list.monitor (i).call_limit <= used then do;
      559 			     call cu_$cp (addr (monitor_list.monitor (i).command_line),
      560 				length (monitor_list.monitor (i).command_line), code);
      561 			     if code ^= 0 then do;
      562 				warn = "Error calling "||rtrim (monitor_list.monitor (i).command_line)|| ".";
      563 				goto non_fatal_warn;
      564 			     end;
      565 			end;
      566 		     end;
      567 		     if ^monitor_list.monitor (monitor_count).rpt_flag then
      568 			call repeat_calc (quota, used, monitor_list.monitor (i).rpt_time);
      569 
      570 		     monitor_list.monitor (i).time = monitor_list.monitor (i).time + monitor_list.monitor (i).rpt_time;
      571 
      572 		     if monitor_list.monitor (i).time < alarm_time then
      573 			alarm_time = monitor_list.monitor (i).time;
      574 						/* set wakeup time to lowest time needed */
      575 
      576 
      577 		end;				/* end of quota problem	       */
      578 
      579 	     end;
      580 
      581 	     else if monitor_list.monitor (i).time < alarm_time then alarm_time = monitor_list.monitor (i).time;
      582 	end;
      583 						/* set to the next wake up	       */
      584 
      585 	call timer_manager_$alarm_call ((alarm_time), "00"b, monitor_quota$main);
      586 	return;
      587 
      588 
      589 
      590 
      591 
      592 
      593 /* \014 */
      594 test_link_fail:
      595 	revert linkage_error;
      596 	code = error_table_$moderr;
      597 	warn = "Access required to phcs_ to send warning to system console.";
      598 	goto non_fatal_warn;
      599 call_1_failed:
      600 	revert linkage_error;
      601 	if monitor_list.monitor_count > 1 then monitor_list.monitor (i).time = one_big_number;
      602 						/* this should stop monitoring for this only */
      603 	code = error_table_$moderr;
      604 	warn = "Access required to phcs_ to send warning to system console.";
      605 	goto non_fatal_warn;
      606 non_fatal_warn:					/* don't delete the other monitor entries */
      607 	if monitor_quota_ptr ^= null then do;
      608 	     if monitor_list.monitor_count >1 then do;
      609 		call com_err_ (code, prog_name, "^/^a", warn);
      610 		return;
      611 	     end;
      612 	end;
      613 	goto bummer;
      614 						/* cleanup and go away	       */
      615 
      616 num_error:
      617 	revert conversion;
      618 
      619 bad_arg:
      620 	code = error_table_$bad_arg;
      621 	warn = arg;
      622 	call com_err_ (code, prog_name, "^a", warn);
      623 	return;
      624 
      625 
      626 dup_arg:
      627 	code = error_table_$inconsistent;
      628 	warn = arg || " appears twice on the command line.";
      629 	goto non_fatal_warn;
      630 bummer:
      631 	call com_err_ (code, prog_name, "^/^a", warn);
      632 	call cleanup;
      633 	return;
      634 
      635 cleanup:	proc;
      636 	     call timer_manager_$reset_alarm_call (monitor_quota$main);
      637 	     if monitor_quota_init_switch ^= false then do;
      638 		call release_temp_segment_ (prog_name, monitor_quota_ptr, code);
      639 		monitor_quota_init_switch = false;
      640 	     end;
      641 	     return;
      642 	end;
      643 fini:
      644 	return;
  1     1 /*  BEGIN  send_mail_info include file */
  1     2 
  1     3 dcl send_mail_info_version_2 fixed bin init(2);
  1     4 
  1     5 dcl 1 send_mail_info aligned,
  1     6      2 version fixed bin,  /* = 2 */
  1     7      2 sent_from char(32) aligned,
  1     8      2 switches,
  1     9       3 wakeup bit(1) unal,
  1    10       3 mbz1 bit(1) unal,
  1    11       3 always_add bit(1) unal,
  1    12       3 never_add bit(1) unal,
  1    13       3 notify bit(1) unal,
  1    14       3 acknowledge bit(1) unal,
  1    15       3 mbz bit(30) unal;
  1    16 
  1    17 /*  END  send_mail_info include file */
      645 
      646      end monitor_quota;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/16/85  1305.0  monitor_quota.pl1                 >special_ldd>online>41-4>monitor_quota.pl1
645          1    04/27/78  1504.4  send_mail_info.incl.pl1           >ldd>include>send_mail_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
absolute_pathname_              000020 constant        entry                    external dcl 25 ref 147
acknowledge              11(05) 000712 automatic       bit(1)                   level 3 packed unaligned dcl 1-5 set ref 203*
addr                                                   builtin function         dcl 109 ref 161 206 206 559 559
after                                                  builtin function         dcl 109 ref 543
alarm_time                      000706 automatic       fixed bin(71,0)          dcl 474 set ref 479* 512 512* 572 572* 581 581* 585
all_flag                        000100 automatic       bit(1)                   initial unaligned dcl 26 set ref 26*
always_add               11(02) 000712 automatic       bit(1)                   level 3 packed unaligned dcl 1-5 set ref 200*
arg                                    based           char                     unaligned dcl 27 set ref 136 138 138 145 146 151 159
                                                                                  160 161 162 167 168 171 183 184 187 194 204 205
                                                                                  206* 209 211 213 223 224 227 237 237 247 247 255*
                                                                                  621 628
argl                            000101 automatic       fixed bin(21,0)          dcl 28 set ref 133* 136 138 138 143* 145 146 151
                                                                                  157* 159 160 161 162 165* 167 168 171 181* 183 184
                                                                                  187 192* 194 204 205 206 206 209 211 213 220* 223
                                                                                  224 227 237 237 247 247 251* 255 255 621 628
argno                           000104 automatic       fixed bin(17,0)          dcl 30 set ref 130* 133* 142* 142 143* 155* 155 157*
                                                                                  163* 163 164 165* 179* 179 180 181* 191* 191 192*
                                                                                  218* 218 219 220* 250* 250 251*
argp                            000102 automatic       pointer                  dcl 29 set ref 133* 136 138 138 143* 145 146 151
                                                                                  157* 159 160 161 162 165* 167 168 171 181* 183 184
                                                                                  187 192* 194 204 205 206 209 211 213 220* 223 224
                                                                                  227 237 237 247 247 251* 255 621 628
before                                                 builtin function         dcl 109 ref 543
call_flag                       000105 automatic       bit(1)                   initial unaligned dcl 31 in procedure
                                                                                  "monitor_quota" set ref 31* 153 154* 335 359 377
                                                                                  403 413
call_flag                60            based           bit(1)                   array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 403* 557
call_limit                      000106 automatic       fixed bin(21,0)          initial dcl 32 in procedure "monitor_quota" set ref
                                                                                  32* 168* 168 224 342 361 367 367* 369 369 404
call_limit               61            based           fixed bin(21,0)          array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 404* 558
clock                                                  builtin function         dcl 109 ref 253 451 482
code                            000112 automatic       fixed bin(35,0)          dcl 39 set ref 133* 134 143* 144 147* 148 157* 158
                                                                                  165* 166 181* 182 192* 193 206* 207 208 209 209
                                                                                  211 220* 221 230* 240* 251* 252 254 255* 256 328*
                                                                                  329 337* 344* 362* 389* 390 426* 452* 453 490* 492
                                                                                  500* 543* 546 546* 559* 561 596* 603* 609* 619*
                                                                                  622* 626* 630* 638*
com_err_                        000026 constant        entry                    external dcl 42 ref 546 609 622 630
command_line            274            based           char(256)                array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 415* 419* 559
                                                                                  559 559 559 562
command_line                           based           char                     unaligned dcl 33 in procedure "monitor_quota" set
                                                                                  ref 162* 415
command_line_length     273            based           fixed bin(17,0)          array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 414* 418*
command_line_length             000107 automatic       fixed bin(17,0)          dcl 34 in procedure "monitor_quota" set ref 160* 162
                                                                                  414 415
command_line_ptr                000110 automatic       pointer                  dcl 35 set ref 161* 162 415
console_flag                    000113 automatic       bit(1)                   initial unaligned dcl 40 in procedure
                                                                                  "monitor_quota" set ref 40* 173 174* 377 405
console_flag             62            based           bit(1)                   array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 405* 519
console_warn_limit       63            based           fixed bin(21,0)          array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 406* 520
console_warn_limit              000114 automatic       fixed bin(21,0)          initial dcl 41 in procedure "monitor_quota" set ref
                                                                                  41* 184* 184 335 342 348 351 351 352 353 354 406
conversion                      000700 stack reference condition                dcl 110 ref 115 266 616
convert                                                builtin function         dcl 109 ref 168 184 224
convert_date_to_binary_         000022 constant        entry                    external dcl 36 ref 426
convert_date_to_binary_$relative
                                000024 constant        entry                    external dcl 37 ref 255 452
cu_$arg_count                   000030 constant        entry                    external dcl 43 ref 128
cu_$arg_ptr                     000032 constant        entry                    external dcl 44 ref 133 143 157 165 181 192 220 251
cu_$cp                          000034 constant        entry                    external dcl 45 ref 559
date_time_                      000102 constant        entry                    external dcl 283 ref 302
dir_quota                              parameter       fixed bin(18,0)          dcl 436 ref 435 442
dir_used                               parameter       fixed bin(18,0)          dcl 437 ref 435 442
divide                                                 builtin function         dcl 109 ref 442 521 538
error_table_$action_not_performed
                                000036 external static fixed bin(35,0)          dcl 46 ref 337 362 500
error_table_$bad_arg            000054 external static fixed bin(35,0)          dcl 46 ref 344 619
error_table_$inconsistent       000052 external static fixed bin(35,0)          dcl 46 ref 230 240 626
error_table_$messages_off       000050 external static fixed bin(35,0)          dcl 46 ref 208
error_table_$moderr             000040 external static fixed bin(35,0)          dcl 46 ref 596 603
error_table_$no_append          000046 external static fixed bin(35,0)          dcl 46 ref 211
error_table_$no_dir             000044 external static fixed bin(35,0)          dcl 46 ref 209
error_table_$noentry            000042 external static fixed bin(35,0)          dcl 46 ref 209
false                                  constant        bit(1)                   initial unaligned dcl 49 ref 196 197 200 202 203 293
                                                                                  319 387 637 639
get_temp_segment_               000060 constant        entry                    external dcl 53 ref 389
get_wdir_                       000104 constant        entry                    external dcl 284 ref 325
hcs_$quota_read                 000056 constant        entry                    external dcl 50 ref 328 490
i                               000115 automatic       fixed bin(17,0)          dcl 54 set ref 204* 205* 299* 302 303* 303 303 303
                                                                                  303 303 303 303* 422* 423 423* 486* 487 490 493
                                                                                  498 501 505 508 511 511 512 512 519 520 523 535
                                                                                  536 540 542 543 543 546 546 557 558 559 559 559
                                                                                  559 562 567 570 570 570 572 572 581 581* 601
index                                                  builtin function         dcl 109 ref 194 204
ioa_                            000106 constant        entry                    external dcl 285 ref 295 303
ioa_$rsnnl                      000062 constant        entry                    external dcl 55 ref 523 540
j                               000710 automatic       fixed bin(17,0)          dcl 475 set ref 542* 542* 543 543 546*
length                                                 builtin function         dcl 109 ref 160 559 559
linkage_error                   000116 stack reference condition                dcl 56 ref 175 178 528 531 594 599
mbz                      11(06) 000712 automatic       bit(30)                  level 3 packed unaligned dcl 1-5 set ref 197*
mbz1                     11(01) 000712 automatic       bit(1)                   level 3 packed unaligned dcl 1-5 set ref 196*
message                         000125 automatic       varying char(256)        initial dcl 58 set ref 58* 522* 523* 530 539* 540*
                                                                                  543
message_id               71            based           char(50)                 array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 423* 542 543
                                                                                  543 546*
message_id                      000226 automatic       char(50)                 initial array unaligned dcl 59 in procedure
                                                                                  "monitor_quota" set ref 59* 205* 381* 423
monitor                   2            based           structure                array level 2 dcl 63
monitor_count                          based           fixed bin(17,0)          level 2 dcl 63 set ref 299 395* 399* 399 401 402 403
                                                                                  404 405 406 407 408 409 410 411 411 414 415 418
                                                                                  419 423 426 486 498 508 567 601 608
monitor_list                           based           structure                level 1 dcl 63
monitor_quota$main              000064 constant        entry                    external dcl 60 ref 481 481 585 585 636 636
monitor_quota_init_switch       000010 internal static bit(1)                   initial unaligned dcl 61 set ref 293 319 387 396*
                                                                                  637 639*
monitor_quota_ptr               000012 internal static pointer                  initial dcl 62 set ref 299 302 303 303 303 303 303
                                                                                  303 303 389* 395 399 399 401 401 402 402 403 403
                                                                                  404 404 405 405 406 406 407 407 408 408 409 409
                                                                                  410 410 411 411 411 411 414 414 415 415 418 418
                                                                                  419 419 423 423 426 426 486 487 490 493 498 498
                                                                                  501 505 508 508 508 511 511 512 512 519 520 523
                                                                                  535 536 540 542 543 543 546 546 557 558 559 559
                                                                                  559 559 562 567 567 567 570 570 570 572 572 581
                                                                                  581 601 601 606 608 638*
nargs                           000423 automatic       fixed bin(17,0)          dcl 80 set ref 128* 130 164 180 219 228 238
never_add                11(03) 000712 automatic       bit(1)                   level 3 packed unaligned dcl 1-5 set ref 201*
notify                   11(04) 000712 automatic       bit(1)                   level 3 packed unaligned dcl 1-5 set ref 202*
null                                                   builtin function         dcl 109 ref 606
off_flag                        000424 automatic       bit(1)                   initial unaligned dcl 81 set ref 81* 234* 318
one_big_number                  000000 constant        fixed bin(71,0)          initial dcl 82 ref 479 498 601
path_flag                       000432 automatic       bit(1)                   initial unaligned dcl 88 set ref 88* 140 141* 325
path_name                       000433 automatic       char(168)                unaligned dcl 89 in procedure "monitor_quota" set
                                                                                  ref 147* 325* 328 330 338 343 363 402
path_name                 5            based           varying char(168)        array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 402* 490
                                                                                  493 501 523 540 546*
pathname                        000505 automatic       char(168)                unaligned dcl 90 set ref 146* 147*
percent                         000774 automatic       fixed bin(6,3)           dcl 439 in procedure "repeat_calc" set ref 442* 444
                                                                                  445 446 447 448
percent                         000557 automatic       fixed bin(6,3)           dcl 91 in procedure "monitor_quota" set ref 521*
                                                                                  523* 538* 540*
phcs_$ring_0_message            000070 constant        entry                    external dcl 92 ref 177 530
print_flag                      000124 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 244* 292
prog_name                       000014 internal static char(13)                 initial unaligned dcl 93 set ref 389* 523* 540* 546*
                                                                                  609* 622* 630* 638*
quota                           000425 automatic       fixed bin(18,0)          dcl 83 set ref 328* 335 342 342 342 348 361 367 373*
                                                                                  490* 497 508* 521 538 567*
record_limit                    000426 automatic       fixed bin(21,0)          dcl 84 in procedure "monitor_quota" set ref 348*
                                                                                  351* 352* 354* 355 355* 369 369* 383 401 426
record_limit              4            based           fixed bin(21,0)          array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 401* 505
release_temp_segment_           000066 constant        entry                    external dcl 85 ref 638
repeat                                 parameter       fixed bin(71,0)          dcl 438 set ref 435 452* 458* 458
rpt_flag                 70            based           bit(1)                   array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 408* 508 567
rpt_flag                        000427 automatic       bit(1)                   initial unaligned dcl 86 in procedure
                                                                                  "monitor_quota" set ref 86* 248 249* 373 408
rpt_time                        000430 automatic       fixed bin(71,0)          dcl 87 in procedure "monitor_quota" set ref 255*
                                                                                  258* 258 373* 407
rpt_time                 66            based           fixed bin(71,0)          array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 407* 411 508*
                                                                                  511 567* 570
rtrim                                                  builtin function         dcl 109 ref 146 330 338 343 363 381 381 402 562
send_mail_                      000072 constant        entry                    external dcl 94 ref 206
send_mail_info                  000712 automatic       structure                level 1 dcl 1-5 set ref 206 206
send_mail_info_version_2        000711 automatic       fixed bin(17,0)          initial dcl 1-3 set ref 195 1-3*
send_message_                   000074 constant        entry                    external dcl 95 ref 543
sent_from                 1     000712 automatic       char(32)                 level 2 dcl 1-5 set ref 198*
sons_lvid                       000560 automatic       bit(36)                  unaligned dcl 96 set ref 328* 490*
substr                                                 builtin function         dcl 109 ref 136 145 159 167 183 223
switches                 11     000712 automatic       structure                level 2 dcl 1-5
tacc_sw                         000573 automatic       fixed bin(1,0)           dcl 104 set ref 328* 490*
test_entry                      000562 automatic       entry variable           dcl 97 set ref 177*
time                      2            based           fixed bin(71,0)          array level 3 dcl 63 set ref 302* 411* 426* 487 498*
                                                                                  511* 512 512 570* 570 572 572 581 581 601*
time_now                        000566 automatic       fixed bin(71,0)          dcl 98 set ref 253* 255* 258 411 451* 452* 458 482*
                                                                                  487 511
time_to_print                   000736 automatic       char(24)                 unaligned dcl 286 set ref 302* 303*
time_value                      000775 automatic       varying char(5)          dcl 440 set ref 444* 445* 446* 447* 448* 449* 452
                                                                                  454
timer_manager_$alarm_call       000076 constant        entry                    external dcl 99 ref 585
timer_manager_$reset_alarm_call 000100 constant        entry                    external dcl 100 ref 481 636
trp                             000570 automatic       fixed bin(71,0)          dcl 102 set ref 328* 490*
true                                   constant        bit(1)                   initial unaligned dcl 101 ref 141 154 174 190 199
                                                                                  201 234 244 249 382 396
tup                             000572 automatic       bit(36)                  dcl 103 set ref 328* 490*
used                            000574 automatic       fixed bin(18,0)          dcl 105 set ref 328* 373* 426 490* 505 508* 520 521
                                                                                  536 538 558 567*
user_acct                       000755 automatic       char(32)                 unaligned dcl 290 set ref 380*
user_info_                      000110 constant        entry                    external dcl 287 ref 380
user_name                       000744 automatic       char(22)                 unaligned dcl 288 set ref 380* 381
user_proj                       000752 automatic       char(9)                  unaligned dcl 289 set ref 380* 381
version                         000712 automatic       fixed bin(17,0)          level 2 dcl 1-5 set ref 195*
wakeup                   11     000712 automatic       bit(1)                   level 3 packed unaligned dcl 1-5 set ref 199*
warn                            000575 automatic       varying char(256)        dcl 106 set ref 209* 211* 213* 229* 239* 330* 338*
                                                                                  343* 363* 391* 454* 493* 501* 562* 597* 604* 609*
                                                                                  621* 622* 628* 630*
warn_flag                64            based           bit(1)                   array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 409* 535
warn_flag                       000676 automatic       bit(1)                   initial unaligned dcl 107 in procedure
                                                                                  "monitor_quota" set ref 107* 189 190* 377 382* 409
warn_limit                      000677 automatic       fixed bin(21,0)          initial dcl 108 in procedure "monitor_quota" set ref
                                                                                  108* 224* 335 342 348 351 352 352 353 355 355 383*
                                                                                  410
warn_limit               65            based           fixed bin(21,0)          array level 3 in structure "monitor_list" dcl 63
                                                                                  in procedure "monitor_quota" set ref 303* 410* 536

NAMES DECLARED BY EXPLICIT CONTEXT.
EOL                             001607 constant        label                    dcl 266 ref 164 180 219
arg_scan                        000552 constant        label                    dcl 136 ref 167 183 223
bad_arg                         003063 constant        label                    dcl 619 ref 134 136 144 145 148 158 159 166 193 194
                                                                                  221 247 252 254 256
bummer                          003154 constant        label                    dcl 630 ref 392 455 494 613
call_1_failed                   002777 constant        label                    dcl 599 ref 528
cleanup                         004555 constant        entry                    internal dcl 635 ref 320 632
command_args                    000476 constant        label                    dcl 115
dup_arg                         003126 constant        label                    dcl 626 ref 140 153 173 189 248
fini                            003205 constant        label                    dcl 643 ref 270 319
main                            001613 constant        entry                    external dcl 463 ref 431
monitor_quota                   000470 constant        entry                    external dcl 11
non_fatal_warn                  003022 constant        label                    dcl 606 ref 214 231 241 331 339 345 364 502 563 598
                                                                                  605 629
num_error                       003062 constant        label                    dcl 616 ref 115
repeat_calc                     004362 constant        entry                    internal dcl 435 ref 373 508 567
set_up                          003206 constant        entry                    internal dcl 274 ref 269
test_link_fail                  002765 constant        label                    dcl 594 set ref 175

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5222        5334    4640        5232
Length      5642    4640       112         271     361          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
monitor_quota                       920 external procedure  is an external procedure.  
on unit on line 115                  64 on unit               
on unit on line 175                  64 on unit               
set_up                                  internal procedure  shares stack frame of external procedure monitor_quota.  
repeat_calc                             internal procedure  shares stack frame of external procedure monitor_quota.  
on unit on line 528                  64 on unit               
cleanup                                 internal procedure  shares stack frame of external procedure monitor_quota.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 monitor_quota_init_switch   monitor_quota
000012 monitor_quota_ptr           monitor_quota
000014 prog_name                   monitor_quota

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
monitor_quota            000100 all_flag                    monitor_quota
                         000101 argl                        monitor_quota
                         000102 argp                        monitor_quota
                         000104 argno                       monitor_quota
                         000105 call_flag                   monitor_quota
                         000106 call_limit                  monitor_quota
                         000107 command_line_length         monitor_quota
                         000110 command_line_ptr            monitor_quota
                         000112 code                        monitor_quota
                         000113 console_flag                monitor_quota
                         000114 console_warn_limit          monitor_quota
                         000115 i                           monitor_quota
                         000124 print_flag                  monitor_quota
                         000125 message                     monitor_quota
                         000226 message_id                  monitor_quota
                         000423 nargs                       monitor_quota
                         000424 off_flag                    monitor_quota
                         000425 quota                       monitor_quota
                         000426 record_limit                monitor_quota
                         000427 rpt_flag                    monitor_quota
                         000430 rpt_time                    monitor_quota
                         000432 path_flag                   monitor_quota
                         000433 path_name                   monitor_quota
                         000505 pathname                    monitor_quota
                         000557 percent                     monitor_quota
                         000560 sons_lvid                   monitor_quota
                         000562 test_entry                  monitor_quota
                         000566 time_now                    monitor_quota
                         000570 trp                         monitor_quota
                         000572 tup                         monitor_quota
                         000573 tacc_sw                     monitor_quota
                         000574 used                        monitor_quota
                         000575 warn                        monitor_quota
                         000676 warn_flag                   monitor_quota
                         000677 warn_limit                  monitor_quota
                         000706 alarm_time                  monitor_quota
                         000710 j                           monitor_quota
                         000711 send_mail_info_version_2    monitor_quota
                         000712 send_mail_info              monitor_quota
                         000736 time_to_print               set_up
                         000744 user_name                   set_up
                         000752 user_proj                   set_up
                         000755 user_acct                   set_up
                         000774 percent                     repeat_calc
                         000775 time_value                  repeat_calc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_cs            cat_realloc_cs      call_ext_in         call_ext_out_desc
call_ext_out        return              tra_ext             enable              shorten_stack       ext_entry
int_entry           trunc_fx1           any_to_any_tr       clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      convert_date_to_binary_
convert_date_to_binary_$relative                            cu_$arg_count                 cu_$arg_ptr
cu_$cp                        date_time_                    get_temp_segment_             get_wdir_
hcs_$quota_read               ioa_                          ioa_$rsnnl                    monitor_quota$main
phcs_$ring_0_message          release_temp_segment_         send_mail_                    send_message_
timer_manager_$alarm_call     timer_manager_$reset_alarm_call                             user_info_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$inconsistent
error_table_$messages_off     error_table_$moderr           error_table_$no_append        error_table_$no_dir
error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     26 000431        31 000432        32 000433        40 000434        41 000435        57 000436        58 000437
     59 000440        81 000456        86 000457        88 000460       107 000461       108 000462    1    3 000463
     11 000467       115 000476       128 000515       130 000524       133 000533       134 000550       136 000552
    138 000557       140 000570       141 000572       142 000574       143 000575       144 000612       145 000614
    146 000621       147 000636       148 000656       149 000660       151 000661       153 000665       154 000667
    155 000671       157 000672       158 000707       159 000711       160 000716       161 000720       162 000722
    163 000725       164 000726       165 000731       166 000746       167 000750       168 000755       169 000772
    171 000774       173 001000       174 001002       175 001004       177 001023       178 001030       179 001031
    180 001032       181 001035       182 001051       183 001053       184 001060       185 001075       187 001077
    189 001103       190 001105       191 001107       192 001110       193 001125       194 001127       195 001142
    196 001144       197 001146       198 001150       199 001153       200 001155       201 001157       202 001161
    203 001163       204 001165       205 001206       206 001214       207 001246       208 001250       209 001253
    211 001302       213 001341       214 001364       218 001366       219 001367       220 001372       221 001407
    222 001411       223 001413       224 001420       225 001435       227 001437       228 001443       229 001446
    230 001453       231 001456       234 001457       235 001461       237 001462       238 001472       239 001475
    240 001502       241 001505       244 001506       245 001510       247 001511       248 001521       249 001523
    250 001525       251 001526       252 001543       253 001545       254 001547       255 001551       256 001600
    258 001602       265 001605       266 001607       269 001610       270 001611       463 001612       479 001621
    481 001623       482 001636       486 001640       487 001651       490 001660       492 001735       493 001740
    494 002000       497 002002       498 002004       500 002016       501 002020       502 002057       505 002061
    508 002072       511 002110       512 002120       516 002123       519 002124       520 002127       521 002131
    522 002135       523 002136       528 002207       530 002227       531 002250       535 002252       536 002261
    538 002265       539 002272       540 002273       542 002345       543 002370       546 002503       551 002556
    557 002560       558 002567       559 002573       561 002612       562 002614       563 002674       567 002676
    570 002720       572 002730       579 002733       581 002734       582 002737       585 002741       586 002764
    594 002765       596 002766       597 002771       598 002776       599 002777       601 003000       603 003012
    604 003014       605 003021       606 003022       608 003027       609 003032       610 003060       613 003061
    616 003062       619 003063       621 003066       622 003077       623 003125       626 003126       628 003131
    629 003152       630 003154       632 003203       633 003204       643 003205       274 003206       292 003207
    293 003211       295 003214       296 003227       299 003230       302 003237       303 003261       313 003362
    314 003364       318 003365       319 003367       320 003372       321 003373       325 003374       328 003405
    329 003454       330 003456       331 003521       335 003523       337 003543       338 003546       339 003611
    342 003613       343 003624       344 003667       345 003673       348 003674       351 003704       352 003713
    353 003722       354 003726       355 003730       359 003734       361 003736       362 003742       363 003745
    364 004010       367 004012       369 004021       373 004024       377 004030       380 004036       381 004057
    382 004131       383 004134       387 004136       389 004141       390 004161       391 004163       392 004170
    395 004171       396 004173       399 004175       401 004176       402 004204       403 004225       404 004227
    405 004231       406 004233       407 004235       408 004237       409 004241       410 004243       411 004245
    413 004250       414 004253       415 004255       416 004265       418 004266       419 004267       422 004275
    423 004303       424 004322       426 004324       431 004355       432 004361       435 004362       442 004364
    444 004371       445 004402       446 004413       447 004424       448 004435       449 004446       451 004452
    452 004454       453 004511       454 004514       455 004546       458 004550       460 004554       635 004555
    636 004556       637 004571       638 004574       639 004614       641 004616


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
