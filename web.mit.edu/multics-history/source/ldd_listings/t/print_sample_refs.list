	COMPILATION LISTING OF SEGMENT print_sample_refs
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1742.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 print_sample_refs: psrf: procedure;
       12 
       13 /*	print_sample_refs interprets the data segments produced by the sample_refs command, and produces
       14*   a printable output file.  The data segments, _n_a_m_e.srf1, _n_a_m_e.srf2, and _n_a_m_e.srf3 are initiated, and
       15*   the output file _n_a_m_e.list is made.  Each individual sample, as found in the srf1 segment, is examined.  An
       16*   attempt is made to initiate the segment, then to determine if it is an object segment, and then to determine
       17*   if the segment reference can be resolved down to a bound component of an object segment.  During this phase, a
       18*   table of components is generated, and if the -brief option has not been specified, information about each
       19*   individual sample is written into the output file.  In the next phase, information from the srf1, srf2,
       20*   and component tables is used to produce the segment number - pathname dictionary. In the final phase, the PSR
       21*   and TSR reference histograms are produced.
       22*
       23*   0) created by Ross E. Klinger, November 11, 1973
       24*   1) modified by R.E. Klinger, August 15, 1975 to convert
       25*   to new object_info structure
       26*   2) Modified 05/01/81, W. Olin Sibert, to eliminate ERROR 295
       27*
       28*   */
       29 	
       30 declare 1 srf1seg based (srf1P) aligned,		/* srf1 data base */
       31         2 time_on fixed bin (71),			/* on time */
       32         2 time_off fixed bin (71),			/* off time */
       33         2 table_index fixed bin (35),			/* index of where_when table */
       34         2 frequency fixed bin (35),			/* sample rate */
       35         2 high_hc fixed bin (35),			/* high hardcore segment */
       36         2 proc_seg_cnt fixed bin (35),			/* high process segment */
       37         2 where_when (srf1_max_index),			/* interrupt table */
       38 	3 time fixed bin (71),			/* interrupt time */
       39 	3 prcdr pointer,				/* psr pointer */
       40 	3 temporary pointer,			/* tsr pointer */
       41 	3 prul fixed bin (35),			/* psr re-usage level */
       42 	3 trul fixed bin (35);			/* tsr re-usage level */
       43 
       44 declare 1 srf2seg based (srf2P) aligned,		/* srf2 data base */
       45         2 time_on fixed bin (71),			/* on time */
       46         2 high_segno fixed bin (35),			/* highest segment number in table */
       47         2 pad fixed bin (35),				/* pad */
       48         2 segment (srf2_max_index),			/* table indexed by segment number */
       49 	3 pathname character (168),			/* segment pathname */
       50 	3 prc fixed bin (35),			/* psr reference count */
       51 	3 trc fixed bin (35),			/* tsr reference count */
       52 	3 ci fixed bin (35),			/* chain index to extension */
       53 	3 bci fixed bin (35);			/* index to bound components */
       54 
       55 declare 1 srf3seg based (srf3P) aligned,		/* extension data base for re-used segment numbers */
       56         2 time_on fixed bin (71),			/* on time */
       57         2 ni fixed bin (35),				/* index to next available entry */
       58         2 pad fixed bin (35),				/* pad area */
       59         2 extension (srf3_max_index),			/* table of pathnames of re-used segment numbers */
       60 	3 pathname char (168),			/* pathname */
       61 	3 prc fixed bin (35),			/* psr reference count */
       62 	3 trc fixed bin (35),			/* tsr reference count */
       63 	3 ci fixed bin (35),			/* index to further re-usage entries */
       64 	3 bci fixed bin (35);			/* index to bound components */
       65 
       66 
       67 declare 1 temp based (t1P) aligned,			/* segment to hold ordered lines */
       68         2 li fixed bin (35),				/* index to next available entry */
       69         2 pad fixed bin (35),				/* pad area */
       70         2 line (temp_max_index),			/* lines */
       71 	3 rul fixed bin (35),			/* re-usage level */
       72 	3 sgnum fixed bin (35),			/* segment number */
       73 	3 bindl fixed bin (35),			/* bound component level */
       74 	3 name char (168),				/* segment/component name */
       75 	3 prc fixed bin (35),			/* psr reference count */
       76 	3 trc fixed bin (35),			/* tsr reference count */
       77 	3 pad fixed bin (35);			/* pad area */
       78 
       79 declare 1 bindings based (t2P) aligned,			/* segment to hold bound component entries */
       80         2 bcmpi fixed bin (35),			/* index to next available entry */
       81         2 pad fixed bin (35),				/* pad area */
       82         2 bcmp (bindings_max_index),			/* bound components */
       83 	3 name char (32),				/* component name */
       84 	3 prc fixed bin (35),			/* psr reference count */
       85 	3 trc fixed bin (35),			/* tsr reference count */
       86 	3 ci fixed bin (35),			/* chain index to next bound component within a segment */
       87 	3 pad fixed bin (35);			/* pad area */
       88 	
       89 declare (srf1P, srf2P, srf3P, t1P, t2P) ptr,		/* segment pointers */
       90          output_path character (168) varying,		/* output pathname */
       91          iocbP ptr,					/* iocb pointer */
       92          open_sw bit (1),				/* iocb open switch */
       93          switch_name char (20),			/* I/O switch name */
       94          unique_name char (15);			/* shreik name used in this invocation */
       95 
       96 declare (srf1_max_index, srf2_max_index, srf3_max_index) fixed bin internal static; /* array limits */
       97 
       98 declare (aP, bP, cP) pointer,				/* argument pointers */
       99         (arglen, i, j, k, l) fixed bin,			/* temporary storage */
      100          reg character (3),				/* holds "TSR" or "PSR" for print_int */
      101          bl character (3),				/* holds bind component incidence */
      102          usage character (4),				/* holds re-usage level for output line */
      103          re_ul fixed bin (35),			/* holds psr or tsr re-usage level */
      104          pname char (168),				/* holds a pathname for print_int */
      105          wdir char (168) aligned,			/* pathname of working directory */
      106          offset fixed bin (35),			/* holds an offset for print_int */
      107          tbit bit (1),				/* psr(0)/tsr(1) interpet switch */
      108          long bit (1) initial ("1"b),			/* long format print switch - default is on */
      109          bindings_full bit (1) initial ("0"b),		/* bindings table full switch */
      110          code fixed bin (35),				/* error code */
      111          bc fixed binary (24),			/* segment bit count */
      112          temp_max_index fixed bin,			/* temp segment maximum index */
      113          bindings_max_index fixed bin,			/* bindings segment maximum index */
      114          current_ring fixed bin (6),			/* current ring */
      115          ring_brackets (3) fixed bin (3),		/* ring brakets of initiated segments */
      116         (pres, tres) fixed binary (35) initial (1),	/* histogram resolution factors */
      117          arg character (arglen) based (aP),		/* argument */
      118          name character (32) aligned,			/* suffixed entry name  */
      119          dirname character (168) aligned,		/* directory name */
      120          ename character (32) aligned,			/* entry name */
      121          rs character (19) varying,			/* psr pointer string for tab evaluation */
      122          prefix character (22) varying,			/* message prefixed to pathname */
      123         (ontime, offtime) character (24);		/* time character strings */
      124 
      125 declare 1 image based (aP),				/* image of auxilliary or extension entry */
      126         2 pathname char (168),			/* pathname */
      127         2 prc fixed bin (35),				/* psr reference count */
      128         2 trc fixed bin (35),				/* tsr reference count */
      129         2 ci fixed bin (35),				/* chain index to extension */
      130         2 bci fixed bin (35);				/* index to bound components */
      131 
      132 declare  null builtin, (any_other, cleanup) condition;
      133 
      134 declare  sys_info$max_seg_size fixed bin (35) external;	/* maximum segment size */
      135 declare  error_table_$badopt fixed bin (35) external;	/* an error code */
      136 
      137 declare  wbar character (100),
      138          bar (100) character (1) defined (wbar);
      139 	
      140 declare  com_err_ ext entry options (variable),
      141          component_info_$offset ext entry (ptr, fixed bin, ptr, fixed bin (35)),
      142          continue_to_signal_ ext entry (fixed bin (35)),
      143          cu_$arg_count ext entry (fixed bin),
      144          cu_$arg_ptr ext entry (fixed bin, ptr, fixed bin, fixed bin (35)),
      145          date_time_ ext entry (fixed bin (71), char (*)),
      146          expand_path_ ext entry (ptr, fixed bin, ptr, ptr, fixed bin (35)),
      147          get_ring_ ext entry returns (fixed bin (6)),
      148          get_wdir_ ext entry returns (char (168) aligned),
      149          find_condition_info_ ext entry (ptr, ptr, fixed bin (35)),
      150          hcs_$delentry_seg ext entry (ptr, fixed bin (35)),
      151          hcs_$get_ring_brackets ext entry (char (*) aligned, char (*) aligned, (3)fixed bin (3), fixed bin (35)),
      152          hcs_$initiate_count ext entry (char (*) aligned, char (*) aligned, char (*),
      153          fixed bin (24), fixed bin (2), ptr, fixed bin (35)),
      154          hcs_$make_seg ext entry (char (*) aligned, char (*) aligned, char (*), fixed bin (5), ptr, fixed bin (35)),
      155          hcs_$terminate_noname ext entry (ptr, fixed bin (35)),
      156          hcs_$truncate_seg ext entry (ptr, fixed bin (24), fixed bin (35)),
      157          ioa_$ioa_switch ext entry options (variable),
      158          ioa_$rsnnl ext entry options (variable),
      159          iox_$attach_ioname ext entry (char (*), ptr, char (*), fixed bin (35)),
      160          iox_$close ext entry (ptr, fixed bin (35)),
      161          iox_$detach_iocb ext entry (ptr, fixed bin (35)),
      162          iox_$open ext entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
      163          object_info_$brief ext entry (ptr, fixed bin (24), ptr, fixed bin (35)),
      164          suffixed_name_$make ext entry (char (*) aligned, char (*), char (32) aligned, fixed bin (35)),
      165          unique_chars_ ext entry (bit (*)) returns (char (15));
      166 	
      167 dcl 1 oi aligned automatic like object_info;		/* storage for object_info_ structure */
      168 
  1     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  1     2*coded February 8, 1972 by Michael J. Spier	*/
  1     3 /* modified May 26, 1972 by M. Weaver */
  1     4 /* modified 15 April, 1975 by M. Weaver */
  1     5 
  1     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  1     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  1     8 	2 textp pointer,			/* pointer to beginning of text section */
  1     9 	2 defp pointer,			/* pointer to beginning of definition section */
  1    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  1    11 	2 statp pointer,			/* pointer to beginning of static section */
  1    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  1    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  1    14 	2 tlng fixed bin,			/* length in words of text section */
  1    15 	2 dlng fixed bin,			/* length in words of definition section */
  1    16 	2 llng fixed bin,			/* length in words of linkage section */
  1    17 	2 ilng fixed bin,			/* length in words of static section */
  1    18 	2 slng fixed bin,			/* length in words of symbol section */
  1    19 	2 blng fixed bin,			/* length in words of break map */
  1    20 	2 format,				/* word containing bit flags about object type */
  1    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  1    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  1    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  1    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  1    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  1    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  1    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  1    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  1    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  1    30 	  3 pad bit(27) unaligned,
  1    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  1    32 	2 textlinkp pointer,		/* ptr to first link in text */
  1    33 
  1    34 	/* LIMIT OF BRIEF STRUCTURE */
  1    35 
  1    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  1    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  1    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  1    39 	2 cvers aligned,			/* generator version name in printable char string form */
  1    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  1    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  1    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  1    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  1    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  1    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  1    46 
  1    47 	/* LIMIT OF DISPLAY STRUCTURE */
  1    48 
  1    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  1    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  1    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  1    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  1    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  1    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  1    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  1    56 					/* currently not used by system */
  1    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  1    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  1    59 
  1    60 declare	object_info_version_2 fixed bin int static init(2);
  1    61 
  1    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      169 
      170 	
  2     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  2     2 
  2     3 declare	1 ci aligned,
  2     4 	2 dcl_version fixed bin,		/* version number of this structure */
  2     5 	2 name char(32) aligned,		/* objectname of component segment */
  2     6 	2 text_start pointer,		/* ptr to component's section of text */
  2     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  2     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  2     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  2    10 	2 text_lng fixed bin,		/* length of text section */
  2    11 	2 stat_lng fixed bin,		/* length of internal static */
  2    12 	2 symb_lng fixed bin,		/* length of symbol section */
  2    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  2    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  2    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  2    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  2    17 	2 userid char(32) aligned,		/* id of creator of component */
  2    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  2    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  2    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  2    21 	2 comment aligned,			/* component's comment */
  2    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  2    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  2    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  2    25 
  2    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      171 
      172 	
      173 	oi.version_number = object_info_version_2;	/* set object_info_ structure version */
      174 	srf1_max_index = divide (sys_info$max_seg_size - 8, 8, 17, 0); /* get maximum segment indices */
      175 	srf2_max_index = divide (sys_info$max_seg_size - 4, 46, 17, 0);
      176 	srf3_max_index = srf2_max_index;
      177 	temp_max_index = divide (sys_info$max_seg_size - 2, 48, 17, 0); /* get maximum segment indices */
      178 	bindings_max_index = divide (sys_info$max_seg_size - 2, 13, 17, 0);
      179 	current_ring = get_ring_ ();			/* get current ring number */
      180 	call cu_$arg_ptr (1, aP, arglen, code);		/* get pathname */
      181 	if code ^= 0 then do;			/* is the argument missing? */
      182 	     call com_err_ (code, "print_sample_refs");	/* yes -- write an error message */
      183 	     return;				/* exit */
      184 	end;
      185 
      186 	srf1P, srf2P, srf3P, t1P, t2P = null;		/* initialize segment pointers */
      187 	iocbP = null;				/* initialize iocb pointer */
      188 	on cleanup call cleaner;			/* establish cleanup handler to terminate/delete segments */
      189 
      190 	bP = addr (dirname);			/* get pointer to directory portion of pathname */
      191 	cP = addr (ename);				/* get pointer to entry name portion of pathname */
      192 	call expand_path_ (aP, arglen, bP, cP, code);	/* expand to an absolute pathname */
      193 	if code ^= 0 then do;			/* was there an error? */
      194 	     call com_err_ (code, "print_sample_refs", "^a", aP -> arg); /* write an error message */
      195 	     return;
      196 	end;
      197 
      198 	call cu_$arg_count (i);			/* see if there are more arguments */
      199 	if i > 1 then do;				/* yes */
      200 	     call cu_$arg_ptr (2, aP, arglen, code);	/* get the argument */
      201 	     if aP -> arg ^= "-brief" then if aP -> arg ^= "-bf" then do; /* if not brief, wrong */
      202 		     call com_err_ (error_table_$badopt, "print_sample_refs", "^a", aP -> arg); /* write error message */
      203 		     return;
      204 		end;
      205 		else long = "0"b;			/* set long switch off */
      206 	end;
      207 	i = index (ename, ".srf");			/* look for an ".srf" suffix (or ".srf1", ".srf2", etc. ) */
      208 	if i ^= 0 then substr (ename, i, 32 - i + 1) = " "; /* if found, best just to strip it off */
      209 	
      210 	call suffixed_name_$make (ename, "srf1", name, code); /* add suffix */
      211 	if code ^= 0 then go to suffix_error;		/* was there an error? */
      212 	call hcs_$initiate_count (dirname, name, "", (0), 0, srf1P, code); /* initiate the srf1 segment */
      213 	if srf1P = null then go to init_error;		/* was there an error? */
      214 
      215 	call suffixed_name_$make (ename, "srf2", name, code); /* add suffix */
      216 	if code ^= 0 then go to suffix_error;		/* was there an error? */
      217 	call hcs_$initiate_count (dirname, name, "", (0), 0, srf2P, code); /* initiate the srf2 segment */
      218 	if srf2P = null then go to init_error;		/* was there an error? */
      219 
      220 	call suffixed_name_$make (ename, "srf3", name, code); /* add suffix */
      221 	if code ^= 0 then go to suffix_error;		/* was there an error? */
      222 	call hcs_$initiate_count (dirname, name, "", (0), 0, srf3P, code); /* initiate the srf3 segment */
      223 	if srf3P = null then go to init_error;		/* was there an error? */
      224 
      225 	unique_name = unique_chars_ ("0"b);		/* get a shreik name */
      226 	call hcs_$make_seg ("", unique_name || ".temp1.psrf", "", 01011b, t1P, code);
      227 	if t1P = null then go to temp_error;		/* was there an error? */
      228 	call hcs_$make_seg ("", unique_name || ".temp2.psrf", "", 01011b, t2P, code); /* make the bindings segment */
      229 	if t2P = null then go to temp_error;		/* was there an error? */
      230 
      231 	li = 1;					/* initialize the index of temp segment */
      232 	bcmpi = 1;				/* initialize the bindings index */
      233 
      234 	call suffixed_name_$make (ename, "list", name, code); /* add suffix */
      235 	if code ^= 0 then go to suffix_error;
      236 	wdir = get_wdir_ ();			/* get working directory name */
      237 	j = index (wdir, " ");			/* find end of working directory name */
      238 	output_path = substr (wdir, 1, j - 1) || ">" || name; /* form list segment absolute pathname */
      239 
      240 	switch_name = unique_name || ".psrf";		/* make an unique I/O switch name */
      241 	call iox_$attach_ioname (switch_name, iocbP, "vfile_ " || output_path, code); /* attach the switch */
      242 	if code ^= 0 then go to switch_error;
      243 	call iox_$open (iocbP, 2, "0"b, code);		/* open switch for stream_output */
      244 	if code ^= 0 then go to switch_error;
      245 	else open_sw = "1"b;
      246 	
      247 	call ioa_$ioa_switch (iocbP, "^|^5-PRINT_SAMPLE_REFS"); /* write report header */
      248 	call date_time_ (srf1seg.time_on, ontime);	/* convert on time to characters */
      249 	call date_time_ (srf1seg.time_off, offtime);	/* convert off time to characters */
      250 	call ioa_$ioa_switch (iocbP, "^3/ON TIME: ^a^/OFF TIME: ^a^/SAMPLE RATE: ^d msec.^/NUMBER OF SAMPLES: ^d^2/",
      251 	     ontime, offtime, frequency, table_index);	/* write initial data */
      252 
      253 
      254 	do i = 1 to table_index;			/* loop to output each interrupt */
      255 
      256 	     tbit = "0"b;				/* set tbit to psr interpet */
      257 	     bP = where_when (i).prcdr;		/* set pointer to psr */
      258 	     re_ul = where_when (i).prul;		/* set re-usage level to psr */
      259 	     reg = "PSR";				/* set to psr */
      260 start1:	     j = fixed (baseno (bP));			/* get segment number */
      261 
      262 	     if j <= high_hc then do;			/* is the segment in the hardcore? */
      263 		segment (j).bci = -1;		/* don't investigate binding */
      264 set_up1:		pname = segment (j).pathname;		/* yes -- name to be printed is the pathname */
      265 set_up2:		offset = fixed (rel (bP));		/* offset to be printed is the interrupt offset */
      266 		go to print_int;			/* output a line */
      267 	     end;
      268 
      269 	     if re_ul = 0 then do;			/* is this a primary usage of the segment number? */
      270 		if segment (j).bci = -1 then go to set_up1; /* primary -- is the segment bound? */
      271 		aP = addr (segment (j).pathname);	/* might be bound -- investigate */
      272 		call check_binding;			/* determine if bound */
      273 		go to print_int;			/* output a line */
      274 	     end;
      275 
      276 	     k = segment (j).ci;			/* not primary -- set k to first re-usage */
      277 	     do l = 1 to re_ul - 1;			/* locate re-usage level corresponding to interrupt */
      278 		k = extension (k).ci;		/* set k to next re-usage */
      279 	     end;
      280 
      281 	     if extension (k).bci = -1 then do;		/* is the segment not bound? */
      282 		pname = extension (k).pathname;	/* not bound -- set pathname to be printed */
      283 		go to set_up2;			/* go to calculate offset */
      284 	     end;
      285 	     aP = addr (extension (k).pathname);	/* might be bound -- investigate */
      286 	     call check_binding;			/* determine if bound */
      287 print_int:     if re_ul = 0 then usage = "";		/* print only a non-zero usage */
      288 	     else call ioa_$rsnnl ("(^d)", usage, j, re_ul);
      289 	     if long then do;			/* output detailed trace if long switch on */
      290 		call ioa_$ioa_switch (iocbP, "^4d  ^a  ^4a  ^p^-^a|^o", i, reg, usage, bP, pname, offset);
      291 		if tbit then call ioa_$ioa_switch (iocbP, "^/"); /* skip a line after tsr print */
      292 	     end;
      293 	     if tbit then go to end1;			/* have both psr and tsr been interpeted? */
      294 	     tbit = "1"b;				/* no -- set to interpet tsr */
      295 	     bP = where_when (i).temporary;		/* set pointer to tsr */
      296 	     re_ul = where_when (i).trul;		/* set re-usage level to tsr re-usage */
      297 	     reg = "TSR";				/* set to tsr */
      298 	     go to start1;				/* go to interpet */
      299 end1:	end;
      300 	
      301 	do i = 1 to high_segno;			/* loop to order our output lines */
      302 	     if segment (i).pathname < " " then go to end2; /* no entry -- check the next */
      303 
      304 	     j = 0;				/* re-usage level is 0 */
      305 	     l = 0;				/* bind level is zero */
      306 	     aP = addr (segment (i).pathname);		/* set pointer to the auxilliary entry */
      307 cycle:	     line (li).rul = j;			/* store the re-usage level */
      308 	     line (li).sgnum = i;			/* store the segment number */
      309 	     line (li).bindl = 0;			/* this is not a bound component */
      310 	     line (li).name = image.pathname;		/* store the pathname */
      311 	     if image.bci <= 0 then do;		/* is this segment bound? */
      312 		line (li).prc = image.prc;		/* not bound -- store the psr reference count */
      313 		line (li).trc = image.trc;		/* store the tsr reference count */
      314 		line (li).bindl = -1;		/* set field to indicate not bound */
      315 		go to check_ru;			/* find out if the segment number is re-used */
      316 	     end;
      317 
      318 	     k = image.bci;				/* segment is bound -- set index to the first component */
      319 	     do l = 1 by 1;				/* loop to pick up the bound components */
      320 		if li = temp_max_index then do;	/* is the temp segment full? */
      321 temp_full:	     call com_err_ (0, "print_sample_refs", "The segment number to pathname dictionary is full.
      322 Entries following component ^d of segment ^d at re-usage level ^d are missing.", l, i, j);
      323 		     go to output_dictionary;		/* output the partial dictionary */
      324 		end;
      325 		li = li + 1 ;			/* increment index to next line */
      326 		line (li).sgnum = i;		/* store segment number */
      327 		line (li).bindl = l;		/* store bound component incidence */
      328 		line (li).rul = j;			/* store re-usage level */
      329 		line (li).name = bcmp (k).name;	/* store component name */
      330 		line (li).prc = bcmp (k).prc;		/* store psr reference count */
      331 		line (li).trc = bcmp (k).trc;		/* store tsr reference count */
      332 		if bcmp (k).ci = 0 then go to check_ru; /* if no more components, check for re-used segment number */
      333 		k = bcmp (k).ci;			/* more -- set index to the next component */
      334 	     end;
      335 
      336 check_ru:	     if image.ci = 0 then do;			/* is the segment number re-used? */
      337 		if li = temp_max_index then go to temp_full; /* check if temp segment is full */
      338 		li = li + 1;			/* no -- increment the line index */
      339 		go to end2;			/* go to check the next auxilliary entry */
      340 	     end;
      341 	     j = j + 1;				/* the segment is re-used -- increment the re-usage level */
      342 	     k = image.ci;				/* get the index of the extension entry */
      343 	     aP = addr (extension (k).pathname);	/* set the image pointer to the extension entry */
      344 	     if li = temp_max_index then go to temp_full; /* check if temp segment is full */
      345 	     li = li+1;				/* increment the line index */
      346 	     go to cycle;				/* go to set up a line, check binding, etc */
      347 end2:	end;
      348 	
      349 output_dictionary: call ioa_$ioa_switch (iocbP, "^|^5xSEGMENT^-PATHNAME^/");
      350 	do i = 1 to li - 1;				/* loop to output the segment/pathname dictionary */
      351 
      352 	     if line (i).bindl = 0 then go to pre_write;	/* ignore references on a bound segment line */
      353 	     if line (i).prc > pres then pres = line (i).prc; /* get highest number of psr references */
      354 	     if line (i).trc > tres then tres = line (i).trc; /* get highest number of tsr references */
      355 	     if line (i).bindl = -1 then do;		/* is this not a bound component? */
      356 pre_write:	bl = "";				/* not a bound component -- set bind incidence for write */
      357 		if line (i).rul = 0 then usage = "";	/* set re-usage for write -- blank if primary...or... */
      358 		else call ioa_$rsnnl ("(^d)", usage, j, line (i).rul); /* outputted if not */
      359 		go to write;
      360 	     end;
      361 	     call ioa_$rsnnl (".^d", bl, j, line (i).bindl); /* bound component - form the bind suffix */
      362 write:	     call ioa_$ioa_switch (iocbP, "^4a ^4o^3a^-^a", usage, line (i).sgnum, bl, line (i).name);
      363 	end;
      364 
      365 	call ioa_$ioa_switch (iocbP, "^|^5-PSR REFERENCE HISTOGRAM");
      366 	if pres <= 100 then pres = 1;			/* set pres factor */
      367 	else if pres <= 200 then pres = 2;
      368 	else if pres <= 500 then pres = 5;
      369 	else if pres <= 1000 then pres = 10;
      370 	else if pres <= 2000 then pres = 20;
      371 	else if pres <= 5000 then pres = 50;
      372 	else pres = 100;
      373 	call ioa_$ioa_switch (iocbP, "^5-(Resolution factor = ^d)", pres);
      374 	call ioa_$ioa_switch (iocbP, "^2/^-SEGMENT^/");
      375 
      376 	do i = 1 to li - 1;				/* loop to output bars */
      377 	     if line (i).bindl = 0 then go to again;	/* skip a bound segment line */
      378 	     if line (i).prc = 0 then go to again;	/* if no references, check the next entry */
      379 	     if line (i).rul = 0 then usage = "";	/* print only a re-usage > 0 */
      380 	     else call ioa_$rsnnl ("(^d)", usage, j, line (i).rul);
      381 	     if line (i).bindl = -1 then bl = "";	/* print only a bound component or unbound segment bl */
      382 	     else call ioa_$rsnnl (".^d", bl, j, line (i).bindl);
      383 	     bar = " ";				/* set the bar to all blanks */
      384 	     do j = 1 to 100 while (line (i).prc>0);	/* extend the bar as long as references remain */
      385 		bar (j) = "x";
      386 		line (i).prc = line (i).prc - pres;	/* decrement the count by the resolution factor */
      387 	     end;
      388 	     call ioa_$ioa_switch (iocbP, "^4a ^4o^3a^-^a", usage, line (i).sgnum, bl, wbar); /* write a line */
      389 again:	end;
      390 	
      391 	call ioa_$ioa_switch (iocbP, "^|^5-TSR REFERENCE HISTOGRAM");
      392 	if tres <= 100 then tres = 1;			/* set tres factor */
      393 	else if tres <= 200 then tres = 2;
      394 	else if tres <= 500 then tres = 5;
      395 	else if tres <= 1000 then tres = 10;
      396 	else if tres <= 2000 then tres = 20;
      397 	else if tres <= 5000 then tres = 50;
      398 	else tres = 100;
      399 	call ioa_$ioa_switch (iocbP, "^5-(Resolution factor = ^d)", tres);
      400 	call ioa_$ioa_switch (iocbP, "^2/^-SEGMENT^/");
      401 
      402 	do i = 1 to li - 1;				/* loop to output bars */
      403 	     if line (i).bindl = 0 then go to again1;	/* skip a bound segment line */
      404 	     if line (i).trc = 0 then go to again1;	/* if no references, check the next entry */
      405 	     if line (i).rul = 0 then usage = "";	/* print only a re-usage > 0 */
      406 	     else call ioa_$rsnnl ("(^d)", usage, j, line (i).rul);
      407 	     if line (i).bindl = -1 then bl = "";	/* print only a bound component or unbound segment bl */
      408 	     else call ioa_$rsnnl (".^d", bl, j, line (i).bindl);
      409 	     bar = " ";				/* set the bar to all blanks */
      410 	     do j = 1 to 100 while (line (i).trc>0);	/* extend the bar as long as references remain */
      411 		bar (j) = "x";
      412 		line (i).trc = line (i).trc - tres;	/* decrement the count by the resolution factor */
      413 	     end;
      414 	     call ioa_$ioa_switch (iocbP, "^4a ^4o^3a^-^a", usage, line (i).sgnum, bl, wbar); /* write a line */
      415 again1:	end;
      416 
      417 	call cleaner;				/* tidy up segments; detach io stream; restore srf segments */
      418 	revert cleanup;				/* disable condition handler */
      419 	return;					/* exit */
      420 	
      421 cleaner:	procedure;				/* cleanup procedure */
      422 	     if iocbP ^= null then do;		/* I/O switch attached? */
      423 		if open_sw then do;			/* I/O switch open? */
      424 		     call iox_$close (iocbP, 0);	/* close it */
      425 		     open_sw = "0"b;		/* and indicate same */
      426 		end;
      427 		call iox_$detach_iocb (iocbP, 0);	/* detach it */
      428 		iocbP = null;			/* indicate same */
      429 	     end;
      430 	     if srf1P ^= null then do;
      431 		call hcs_$terminate_noname (srf1P, 0);
      432 		srf1P = null;
      433 	     end;
      434 	     if srf2P ^= null then do;
      435 		do i = 1 to high_segno;		/* loop to restore srf2 segment to virgin state */
      436 		     segment (i).bci = 0;		/* zero auxilliary bound component indices */
      437 		end;
      438 		call hcs_$terminate_noname (srf2P, 0);
      439 		srf2P = null;
      440 	     end;
      441 	     if srf3P ^= null then do;
      442 		do i = 1 to ni;			/* loop to restore srf3 segment */
      443 		     extension (i).bci = 0;		/* zero extension bound component indices */
      444 		end;
      445 		call hcs_$terminate_noname (srf3P, 0);
      446 		srf3P = null;
      447 	     end;
      448 	     if t1P ^= null then do;
      449 		call hcs_$delentry_seg (t1P, 0);
      450 		t1P = null;
      451 	     end;
      452 	     if t2P ^= null then do;
      453 		call hcs_$delentry_seg (t2P, 0);
      454 		t2P = null;
      455 	     end;
      456 	     return;
      457 	end cleaner;
      458 	
      459 check_binding: procedure;				/* internal procedure to determine if a segment is bound */
      460 	     if bindings_full then go to no_chance;	/* don't try anything if table is full */
      461 
      462 	     j = index (image.pathname, " ");		/* find the end of the pathname */
      463 	     do k = j by -1 to 1 while (substr (image.pathname, k, 1) ^= ">"); /* find the last ">" */
      464 	     end;
      465 	     if substr (image.pathname, k, 1) ^= ">" then go to no_seg; /* not a valid pathname */
      466 	     if k = 1 then dirname = ">";		/* directory is the root */
      467 	     else dirname = substr (image.pathname, 1, k-1); /* form the directory name */
      468 	     ename = substr (image.pathname, k+1, j-k);	/* form the entry name */
      469 	     call hcs_$get_ring_brackets (dirname, ename, ring_brackets, code); /* get the ring brackets */
      470 	     if code ^= 0 then go to no_status;		/* no status on directory -- give up */
      471 	     if ring_brackets (2)<current_ring then go to no_access; /* no access -- give up */
      472 	     call hcs_$initiate_count (dirname, ename, "", bc, 0, cP, code); /* initiate the segment */
      473 	     if cP = null then go to no_seg;		/* unable to initiate? */
      474 
      475 	     if image.bci = 0 then do;		/* initiated -- is the bound status unknown? */
      476 		on any_other call oi_failure;		/* intercept faults from object_info_ */
      477 		call object_info_$brief (ptr (cP, 0), bc, addr (oi), code); /* unknown -- find out */
      478 		revert any_other;			/* intercept off */
      479 		if code ^= 0 then go to not_bound;	/* is it an object segment? */
      480 		if ^(oi.format.bound) then go to not_bound; /* object segment -- is it bound? */
      481 	     end;
      482 
      483 	     call component_info_$offset (ptr (cP, 0), binary (rel (bP)), addr (ci), code); /* bound -- get the component */
      484 	     if code ^= 0 then go to no_component;	/* was the component found? */
      485 
      486 	     if image.bci = 0 then do;		/* found -- initial bound component entry for the segment? */
      487 		image.bci = bcmpi;			/* initial -- set bound component index to next available entry */
      488 create:		bcmp (bcmpi).name = ci.name;		/* store the component name */
      489 		if tbit then bcmp (bcmpi).trc = 1;	/* set a tsr...or... */
      490 		else bcmp (bcmpi).prc = 1;		/* psr reference */
      491 		if bcmpi = bindings_max_index then do;	/* is the bindings segment full? */
      492 		     call com_err_ (0, "print_sample_refs", "The bound component table is full.
      493 Components of segment references following sample ^d cannot be determined.", i);
      494 		     bindings_full = "1"b;		/* set to process no more compoents */
      495 		end;
      496 		else bcmpi = bcmpi + 1;		/* increment the table index to the next available entry */
      497 exit1:		pname = ci.name;			/* store component name for print_int */
      498 		offset = binary (rel (bP)) - binary (rel (ci.text_start)); /* compute offset for print_int */
      499 		call hcs_$terminate_noname (cP, code);	/* terminate the segment */
      500 		return;				/* exit */
      501 	     end;
      502 	     
      503 	     j = image.bci;				/* not an initial entry -- get index of first bound component */
      504 check:	     if bcmp (j).name = ci.name then do;	/* do the names match? */
      505 		if tbit then bcmp (j).trc = bcmp (j).trc + 1; /* match -- increment tsr...or... */
      506 		else bcmp (j).prc = bcmp (j).prc + 1;	/* psr reference count */
      507 		go to exit1;			/* transfer to set up for print_int */
      508 	     end;
      509 	     if bcmp (j).ci ^= 0 then do;		/* no match -- are there more components */
      510 		j = bcmp (j).ci;			/* set index to next component */
      511 		go to check;			/* look for a match */
      512 	     end;
      513 	     bcmp (j).ci = bcmpi;			/* no more components -- store index to next available entry */
      514 	     go to create;				/* make a new entry */
      515 
      516 no_chance:     prefix = "";
      517 	     go to exit2;
      518 no_status:     prefix = "NO STATUS - ";
      519 	     go to exit2;
      520 no_access:     prefix = "NOT IN READ BRACKET - ";
      521 	     go to exit2;
      522 no_seg:	     prefix = "CANNOT INITIATE - ";
      523 	     go to exit2;
      524 no_component:  prefix = "NO COMPONENT - ";
      525 	     go to exit4;
      526 not_bound:     prefix = "";
      527 	     image.bci = -1;
      528 exit4:	     call hcs_$terminate_noname (cP, code);	/* terminate the segment */
      529 exit3:	     pname = prefix||image.pathname;		/* form pathname with prefix, if any */
      530 	     offset = fixed (rel (bP));		/* store offset from psr or tsr */
      531 	     return;
      532 exit2:	     image.bci = -1;
      533 	     go to exit3;
      534 	     
      535 oi_failure:    procedure;				/* object_info_ fault interceptor */
      536 declare 1 cond_info aligned,				/* filled in by find_condition_info_ */
  3     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  3     2*	   coded by M. Weaver 12 July 1973 */
  3     3 
  3     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  3     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  3     6 	  2 condition_name char(32) var,		/* name of condition */
  3     7 	  2 infoptr ptr,				/* ptr to software info structure */
  3     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  3     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  3    10 	  2 flags aligned,
  3    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  3    12 	    3 pad1 bit(35) unal,
  3    13 	  2 pad_word bit(36) aligned,
  3    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  3    15 	  2 pad (4) bit(36) aligned;
  3    16 
  3    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      537 
      538 
      539          call find_condition_info_ (null, addr (cond_info), code); /* what sort of fault? */
      540 		if cond_info.condition_name = "cput" then go to pass_it_on;
      541 		if cond_info.condition_name = "finish" then go to pass_it_on;
      542 		if cond_info.condition_name = "storage" then go to pass_it_on;
      543 		if cond_info.condition_name = "alrm" then go to pass_it_on;
      544 		if cond_info.condition_name = "quit" then go to pass_it_on;
      545 		if cond_info.condition_name = "program_interrupt" then do;
      546 pass_it_on:	     call continue_to_signal_ (code);
      547 		     return;
      548 		end;
      549 		go to not_bound;
      550 	     end oi_failure;
      551 
      552 	end check_binding;
      553 	
      554 suffix_error: call com_err_ (code, "print_sample_refs", "^a", ename);
      555 	call cleaner;
      556 	return;
      557 
      558 init_error: call com_err_ (code, "print_sample_refs", "^a>^a", dirname, name);
      559 	call cleaner;
      560 	return;
      561 
      562 temp_error: call com_err_ (code, "print_sample_refs", "While making a temporary segment in the process directory.");
      563 	call cleaner;
      564 	return;
      565 
      566 switch_error: call com_err_ (code, "print_sample_refs", "^a", output_path);
      567 	call cleaner;
      568 	return;
      569 
      570 
      571      end print_sample_refs;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1526.1  print_sample_refs.pl1             >dumps>old>recomp>print_sample_refs.pl1
169          1    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
171          2    05/06/74  1741.0  component_info.incl.pl1           >ldd>include>component_info.incl.pl1
537          3    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
aP                              000202 automatic       pointer                  dcl 98 set ref 180* 192* 194 200* 201 201 202 271*
                                                                                  285* 306* 310 311 312 313 318 336 342 343* 462 463
                                                                                  465 467 468 475 486 487 503 527 529 532
any_other                       000000 stack reference condition                dcl 132 ref 476 478
arg                                    based           char                     unaligned dcl 98 set ref 194* 201 201 202*
arglen                          000210 automatic       fixed bin(17,0)          dcl 98 set ref 180* 192* 194 194 200* 201 201 202
                                                                                  202
bP                              000204 automatic       pointer                  dcl 98 set ref 190* 192* 257* 260 265 290* 295* 483
                                                                                  483 498 530
bar                                    defined         char(1)                  array unaligned dcl 137 set ref 383* 385* 409* 411*
bc                              000352 automatic       fixed bin(24,0)          dcl 98 set ref 472* 477*
bci                      61            based           fixed bin(35,0)          array level 3 in structure "srf2seg" dcl 44
                                                                                  in procedure "psrf" set ref 263* 270 436*
bci                      55            based           fixed bin(35,0)          level 2 in structure "image" dcl 125 in procedure
                                                                                  "psrf" set ref 311 318 475 486 487* 503 527* 532*
bci                      61            based           fixed bin(35,0)          array level 3 in structure "srf3seg" dcl 55
                                                                                  in procedure "psrf" set ref 281 443*
bcmp                      2            based           structure                array level 2 dcl 79
bcmpi                                  based           fixed bin(35,0)          level 2 dcl 79 set ref 232* 487 488 489 490 491 496*
                                                                                  496 513
bindings                               based           structure                level 1 dcl 79
bindings_full                   000350 automatic       bit(1)                   initial unaligned dcl 98 set ref 98* 460 494*
bindings_max_index              000354 automatic       fixed bin(17,0)          dcl 98 set ref 178* 491
bindl                     4            based           fixed bin(35,0)          array level 3 dcl 67 set ref 309* 314* 327* 352 355
                                                                                  361* 377 381 382* 403 407 408*
bl                              000216 automatic       char(3)                  unaligned dcl 98 set ref 356* 361* 362* 381* 382*
                                                                                  388* 407* 408* 414*
bound                    24(01) 000540 automatic       bit(1)                   level 3 packed unaligned dcl 167 set ref 480
cP                              000206 automatic       pointer                  dcl 98 set ref 191* 192* 472* 473 477 477 483 483
                                                                                  499* 528*
ci                       54            based           fixed bin(35,0)          level 2 in structure "image" dcl 125 in procedure
                                                                                  "psrf" ref 336 342
ci                       60            based           fixed bin(35,0)          array level 3 in structure "srf2seg" dcl 44
                                                                                  in procedure "psrf" ref 276
ci                       14            based           fixed bin(35,0)          array level 3 in structure "bindings" dcl 79
                                                                                  in procedure "psrf" set ref 332 333 509 510 513*
ci                       60            based           fixed bin(35,0)          array level 3 in structure "srf3seg" dcl 55
                                                                                  in procedure "psrf" ref 278
ci                              000626 automatic       structure                level 1 dcl 2-3 in procedure "psrf" set ref 483 483
cleanup                         000500 stack reference condition                dcl 132 ref 188 418
code                            000351 automatic       fixed bin(35,0)          dcl 98 set ref 180* 181 182* 192* 193 194* 200* 210*
                                                                                  211 212* 215* 216 217* 220* 221 222* 226* 228*
                                                                                  234* 235 241* 242 243* 244 469* 470 472* 477* 479
                                                                                  483* 484 499* 528* 539* 546* 554* 558* 562* 566*
com_err_                        000020 constant        entry                    external dcl 140 ref 182 194 202 321 492 554 558 562
                                                                                  566
component_info_$offset          000022 constant        entry                    external dcl 140 ref 483
cond_info                       000106 automatic       structure                level 1 dcl 536 set ref 539 539
condition_name            3     000106 automatic       varying char(32)         level 2 dcl 536 set ref 540 541 542 543 544 545
continue_to_signal_             000024 constant        entry                    external dcl 140 ref 546
cu_$arg_count                   000026 constant        entry                    external dcl 140 ref 198
cu_$arg_ptr                     000030 constant        entry                    external dcl 140 ref 180 200
current_ring                    000355 automatic       fixed bin(6,0)           dcl 98 set ref 179* 471
date_time_                      000032 constant        entry                    external dcl 140 ref 248 249
dirname                         000373 automatic       char(168)                dcl 98 set ref 190 212* 217* 222* 466* 467* 469*
                                                                                  472* 558*
ename                           000445 automatic       char(32)                 dcl 98 set ref 191 207 208* 210* 215* 220* 234* 468*
                                                                                  469* 472* 554*
error_table_$badopt             000016 external static fixed bin(35,0)          dcl 135 set ref 202*
expand_path_                    000034 constant        entry                    external dcl 140 ref 192
extension                 4            based           structure                array level 2 dcl 55
find_condition_info_            000042 constant        entry                    external dcl 140 ref 539
format                   24     000540 automatic       structure                level 2 dcl 167
frequency                 5            based           fixed bin(35,0)          level 2 dcl 30 set ref 250*
get_ring_                       000036 constant        entry                    external dcl 140 ref 179
get_wdir_                       000040 constant        entry                    external dcl 140 ref 236
hcs_$delentry_seg               000044 constant        entry                    external dcl 140 ref 449 453
hcs_$get_ring_brackets          000046 constant        entry                    external dcl 140 ref 469
hcs_$initiate_count             000050 constant        entry                    external dcl 140 ref 212 217 222 472
hcs_$make_seg                   000052 constant        entry                    external dcl 140 ref 226 228
hcs_$terminate_noname           000054 constant        entry                    external dcl 140 ref 431 438 445 499 528
high_hc                   6            based           fixed bin(35,0)          level 2 dcl 30 ref 262
high_segno                2            based           fixed bin(35,0)          level 2 dcl 44 ref 301 435
i                               000211 automatic       fixed bin(17,0)          dcl 98 set ref 198* 199 207* 208 208 208 254* 257
                                                                                  258 290* 295 296* 301* 302 306 308 321* 326* 350*
                                                                                  352 353 353 354 354 355 357 358 361 362 362* 376*
                                                                                  377 378 379 380 381 382 384 386 386 388* 402* 403
                                                                                  404 405 406 407 408 410 412 412 414* 435* 436*
                                                                                  442* 443* 492*
image                                  based           structure                level 1 unaligned dcl 125
ioa_$ioa_switch                 000056 constant        entry                    external dcl 140 ref 247 250 290 291 349 362 365 373
                                                                                  374 388 391 399 400 414
ioa_$rsnnl                      000060 constant        entry                    external dcl 140 ref 288 358 361 380 382 406 408
iocbP                           000166 automatic       pointer                  dcl 89 set ref 187* 241* 243* 247* 250* 290* 291*
                                                                                  349* 362* 365* 373* 374* 388* 391* 399* 400* 414*
                                                                                  422 424* 427* 428*
iox_$attach_ioname              000062 constant        entry                    external dcl 140 ref 241
iox_$close                      000064 constant        entry                    external dcl 140 ref 424
iox_$detach_iocb                000066 constant        entry                    external dcl 140 ref 427
iox_$open                       000070 constant        entry                    external dcl 140 ref 243
j                               000212 automatic       fixed bin(17,0)          dcl 98 set ref 237* 238 260* 262 263 264 270 271 276
                                                                                  288* 304* 307 321* 328 341* 341 358* 361* 380*
                                                                                  382* 384* 385* 406* 408* 410* 411* 462* 463 468
                                                                                  503* 504 505 505 506 506 509 510* 510 513
k                               000213 automatic       fixed bin(17,0)          dcl 98 set ref 276* 278* 278 281 282 285 318* 329
                                                                                  330 331 332 333* 333 342* 343 463* 463* 465 466
                                                                                  467 468 468
l                               000214 automatic       fixed bin(17,0)          dcl 98 set ref 277* 305* 319* 321* 327*
li                                     based           fixed bin(35,0)          level 2 dcl 67 set ref 231* 307 308 309 310 312 313
                                                                                  314 320 325* 325 326 327 328 329 330 331 337 338*
                                                                                  338 344 345* 345 350 376 402
line                      2            based           structure                array level 2 dcl 67
long                            000347 automatic       bit(1)                   initial unaligned dcl 98 set ref 98* 205* 289
name                      1     000626 automatic       char(32)                 level 2 in structure "ci" dcl 2-3 in procedure
                                                                                  "psrf" set ref 488 497 504
name                            000363 automatic       char(32)                 dcl 98 in procedure "psrf" set ref 210* 212* 215*
                                                                                  217* 220* 222* 234* 238 558*
name                      5            based           char(168)                array level 3 in structure "temp" dcl 67
                                                                                  in procedure "psrf" set ref 310* 329* 362*
name                      2            based           char(32)                 array level 3 in structure "bindings" dcl 79
                                                                                  in procedure "psrf" set ref 329 488* 504
ni                        2            based           fixed bin(35,0)          level 2 dcl 55 ref 442
null                                                   builtin function         dcl 132 ref 186 187 213 218 223 227 229 422 428 430
                                                                                  432 434 439 441 446 448 450 452 454 473 539 539
object_info                            based           structure                level 1 dcl 1-6
object_info_$brief              000072 constant        entry                    external dcl 140 ref 477
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 1-60 ref 173
offset                          000345 automatic       fixed bin(35,0)          dcl 98 set ref 265* 290* 498* 530*
offtime                         000472 automatic       char(24)                 unaligned dcl 98 set ref 249* 250*
oi                              000540 automatic       structure                level 1 dcl 167 set ref 477 477
ontime                          000464 automatic       char(24)                 unaligned dcl 98 set ref 248* 250*
open_sw                         000170 automatic       bit(1)                   unaligned dcl 89 set ref 245* 423 425*
output_path                     000112 automatic       varying char(168)        dcl 89 set ref 238* 241 566*
pathname                  4            based           char(168)                array level 3 in structure "srf2seg" dcl 44
                                                                                  in procedure "psrf" set ref 264 271 302 306
pathname                               based           char(168)                level 2 in structure "image" packed unaligned
                                                                                  dcl 125 in procedure "psrf" ref 310 462 463 465
                                                                                  467 468 529
pathname                  4            based           char(168)                array level 3 in structure "srf3seg" dcl 55
                                                                                  in procedure "psrf" set ref 282 285 343
pname                           000221 automatic       char(168)                unaligned dcl 98 set ref 264* 282* 290* 497* 529*
prc                      12            based           fixed bin(35,0)          array level 3 in structure "bindings" dcl 79
                                                                                  in procedure "psrf" set ref 330 490* 506* 506
prc                      57            based           fixed bin(35,0)          array level 3 in structure "temp" dcl 67
                                                                                  in procedure "psrf" set ref 312* 330* 353 353 378
                                                                                  384 386* 386
prc                      52            based           fixed bin(35,0)          level 2 in structure "image" dcl 125 in procedure
                                                                                  "psrf" ref 312
prcdr                    12            based           pointer                  array level 3 dcl 30 ref 257
prefix                          000455 automatic       varying char(22)         dcl 98 set ref 516* 518* 520* 522* 524* 526* 529
pres                            000361 automatic       fixed bin(35,0)          initial dcl 98 set ref 98* 353 353* 366 366* 367
                                                                                  367* 368 368* 369 369* 370 370* 371 371* 372* 373*
                                                                                  386
prul                     16            based           fixed bin(35,0)          array level 3 dcl 30 ref 258
re_ul                           000220 automatic       fixed bin(35,0)          dcl 98 set ref 258* 269 277 287 288* 296*
reg                             000215 automatic       char(3)                  unaligned dcl 98 set ref 259* 290* 297*
ring_brackets                   000356 automatic       fixed bin(3,0)           array dcl 98 set ref 469* 471
rul                       2            based           fixed bin(35,0)          array level 3 dcl 67 set ref 307* 328* 357 358* 379
                                                                                  380* 405 406*
segment                   4            based           structure                array level 2 dcl 44
sgnum                     3            based           fixed bin(35,0)          array level 3 dcl 67 set ref 308* 326* 362* 388*
                                                                                  414*
srf1P                           000100 automatic       pointer                  dcl 89 set ref 186* 212* 213 248 249 250 250 254 257
                                                                                  258 262 295 296 430 431* 432*
srf1_max_index                  000010 internal static fixed bin(17,0)          dcl 96 set ref 174*
srf1seg                                based           structure                level 1 dcl 30
srf2P                           000102 automatic       pointer                  dcl 89 set ref 186* 217* 218 263 264 270 271 276 301
                                                                                  302 306 434 435 436 438* 439*
srf2_max_index                  000011 internal static fixed bin(17,0)          dcl 96 set ref 175* 176
srf2seg                                based           structure                level 1 dcl 44
srf3P                           000104 automatic       pointer                  dcl 89 set ref 186* 222* 223 278 281 282 285 343 441
                                                                                  442 443 445* 446*
srf3_max_index                  000012 internal static fixed bin(17,0)          dcl 96 set ref 176*
srf3seg                                based           structure                level 1 dcl 55
suffixed_name_$make             000074 constant        entry                    external dcl 140 ref 210 215 220 234
switch_name                     000171 automatic       char(20)                 unaligned dcl 89 set ref 240* 241*
sys_info$max_seg_size           000014 external static fixed bin(35,0)          dcl 134 ref 174 175 177 178
t1P                             000106 automatic       pointer                  dcl 89 set ref 186* 226* 227 231 307 307 308 308 309
                                                                                  309 310 310 312 312 313 313 314 314 320 325 325
                                                                                  326 326 327 327 328 328 329 329 330 330 331 331
                                                                                  337 338 338 344 345 345 350 352 353 353 354 354
                                                                                  355 357 358 361 362 362 376 377 378 379 380 381
                                                                                  382 384 386 386 388 402 403 404 405 406 407 408
                                                                                  410 412 412 414 448 449* 450*
t2P                             000110 automatic       pointer                  dcl 89 set ref 186* 228* 229 232 329 330 331 332 333
                                                                                  452 453* 454* 487 488 488 489 489 490 490 491 496
                                                                                  496 504 505 505 506 506 509 510 513 513
table_index               4            based           fixed bin(35,0)          level 2 dcl 30 set ref 250* 254
tbit                            000346 automatic       bit(1)                   unaligned dcl 98 set ref 256* 291 293 294* 489 505
temp                                   based           structure                level 1 dcl 67
temp_max_index                  000353 automatic       fixed bin(17,0)          dcl 98 set ref 177* 320 337 344
temporary                14            based           pointer                  array level 3 dcl 30 ref 295
text_start               12     000626 automatic       pointer                  level 2 dcl 2-3 set ref 498
time_off                  2            based           fixed bin(71,0)          level 2 dcl 30 set ref 249*
time_on                                based           fixed bin(71,0)          level 2 dcl 30 set ref 248*
trc                      53            based           fixed bin(35,0)          level 2 in structure "image" dcl 125 in procedure
                                                                                  "psrf" ref 313
trc                      60            based           fixed bin(35,0)          array level 3 in structure "temp" dcl 67
                                                                                  in procedure "psrf" set ref 313* 331* 354 354 404
                                                                                  410 412* 412
trc                      13            based           fixed bin(35,0)          array level 3 in structure "bindings" dcl 79
                                                                                  in procedure "psrf" set ref 331 489* 505* 505
tres                            000362 automatic       fixed bin(35,0)          initial dcl 98 set ref 98* 354 354* 392 392* 393
                                                                                  393* 394 394* 395 395* 396 396* 397 397* 398* 399*
                                                                                  412
trul                     17            based           fixed bin(35,0)          array level 3 dcl 30 ref 296
unique_chars_                   000076 constant        entry                    external dcl 140 ref 225
unique_name                     000176 automatic       char(15)                 unaligned dcl 89 set ref 225* 226 228 240
usage                           000217 automatic       char(4)                  unaligned dcl 98 set ref 287* 288* 290* 357* 358*
                                                                                  362* 379* 380* 388* 405* 406* 414*
version_number                  000540 automatic       fixed bin(17,0)          level 2 dcl 167 set ref 173*
wbar                            000506 automatic       char(100)                unaligned dcl 137 set ref 383 383 385* 385 388* 409
                                                                                  409 411* 411 414*
wdir                            000273 automatic       char(168)                dcl 98 set ref 236* 237 238
where_when               10            based           structure                array level 2 dcl 30

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
hcs_$truncate_seg               000000 constant        entry                    external dcl 140
rs                                     automatic       varying char(19)         dcl 98

NAMES DECLARED BY EXPLICIT CONTEXT.
again                           003366 constant        label                    dcl 389 ref 377 378
again1                          003754 constant        label                    dcl 415 ref 403 404
check                           005050 constant        label                    dcl 504 ref 511
check_binding                   004425 constant        entry                    internal dcl 459 ref 272 286
check_ru                        002523 constant        label                    dcl 336 ref 315 332
cleaner                         004176 constant        entry                    internal dcl 421 ref 188 417 555 559 563 567
create                          004722 constant        label                    dcl 488 ref 514
cycle                           002325 constant        label                    dcl 307 ref 346
end1                            002277 constant        label                    dcl 299 ref 293
end2                            002554 constant        label                    dcl 347 ref 302 339
exit1                           005020 constant        label                    dcl 497 ref 507
exit2                           005210 constant        label                    dcl 532 ref 517 519 521 523
exit3                           005162 constant        label                    dcl 529 ref 533
exit4                           005151 constant        label                    dcl 528 ref 525
init_error                      004026 constant        label                    dcl 558 set ref 213 218 223
no_access                       005122 constant        label                    dcl 520 ref 471
no_chance                       005112 constant        label                    dcl 516 ref 460
no_component                    005136 constant        label                    dcl 524 ref 484
no_seg                          005130 constant        label                    dcl 522 ref 465 473
no_status                       005114 constant        label                    dcl 518 ref 470
not_bound                       005144 constant        label                    dcl 526 ref 479 480 549
oi_failure                      005214 constant        entry                    internal dcl 535 ref 476
output_dictionary               002556 constant        label                    dcl 349 ref 323
pass_it_on                      005274 constant        label                    dcl 546 ref 540 541 542 543 544
pre_write                       002634 constant        label                    dcl 356 ref 352
print_int                       002132 constant        label                    dcl 287 ref 266 273
print_sample_refs               000416 constant        entry                    external dcl 11
psrf                            000406 constant        entry                    external dcl 11
set_up1                         002022 constant        label                    dcl 264 ref 270
set_up2                         002031 constant        label                    dcl 265 ref 283
start1                          002006 constant        label                    dcl 260 ref 298
suffix_error                    003764 constant        label                    dcl 554 ref 211 216 221 235
switch_error                    004133 constant        label                    dcl 566 ref 242 244
temp_error                      004074 constant        label                    dcl 562 ref 227 229
temp_full                       002401 constant        label                    dcl 321 ref 337 344
write                           002727 constant        label                    dcl 362 ref 359

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 190 191 271 285 306 343 477 477 483 483 539 539
baseno                                                 builtin function         ref 260
binary                                                 builtin function         ref 483 483 498 498
divide                                                 builtin function         ref 174 175 177 178
fixed                                                  builtin function         ref 260 265 530
index                                                  builtin function         ref 207 237 462
ptr                                                    builtin function         ref 477 477 483 483
rel                                                    builtin function         ref 265 483 483 498 498 530
substr                                                 builtin function         ref 208 238 463 465 467 468

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5702        6002    5322        5712
Length      6324    5322       100         306     360           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
psrf                                608 external procedure  is an external procedure.  
on unit on line 188                  64 on unit               
cleaner                              74 internal procedure  is called by several nonquick procedures.  
check_binding                       142 internal procedure  enables or reverts conditions.  
on unit on line 476                 108 on unit               
oi_failure                              internal procedure  shares stack frame of on unit on line 476.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 srf1_max_index              psrf
000011 srf2_max_index              psrf
000012 srf3_max_index              psrf

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
on unit on line 476      000106 cond_info                   oi_failure
psrf                     000100 srf1P                       psrf
                         000102 srf2P                       psrf
                         000104 srf3P                       psrf
                         000106 t1P                         psrf
                         000110 t2P                         psrf
                         000112 output_path                 psrf
                         000166 iocbP                       psrf
                         000170 open_sw                     psrf
                         000171 switch_name                 psrf
                         000176 unique_name                 psrf
                         000202 aP                          psrf
                         000204 bP                          psrf
                         000206 cP                          psrf
                         000210 arglen                      psrf
                         000211 i                           psrf
                         000212 j                           psrf
                         000213 k                           psrf
                         000214 l                           psrf
                         000215 reg                         psrf
                         000216 bl                          psrf
                         000217 usage                       psrf
                         000220 re_ul                       psrf
                         000221 pname                       psrf
                         000273 wdir                        psrf
                         000345 offset                      psrf
                         000346 tbit                        psrf
                         000347 long                        psrf
                         000350 bindings_full               psrf
                         000351 code                        psrf
                         000352 bc                          psrf
                         000353 temp_max_index              psrf
                         000354 bindings_max_index          psrf
                         000355 current_ring                psrf
                         000356 ring_brackets               psrf
                         000361 pres                        psrf
                         000362 tres                        psrf
                         000363 name                        psrf
                         000373 dirname                     psrf
                         000445 ename                       psrf
                         000455 prefix                      psrf
                         000464 ontime                      psrf
                         000472 offtime                     psrf
                         000506 wbar                        psrf
                         000540 oi                          psrf
                         000626 ci                          psrf

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry
set_cs_eis          index_cs_eis        divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      component_info_$offset        continue_to_signal_           cu_$arg_count
cu_$arg_ptr                   date_time_                    expand_path_                  find_condition_info_
get_ring_                     get_wdir_                     hcs_$delentry_seg             hcs_$get_ring_brackets
hcs_$initiate_count           hcs_$make_seg                 hcs_$terminate_noname         ioa_$ioa_switch
ioa_$rsnnl                    iox_$attach_ioname            iox_$close                    iox_$detach_iocb
iox_$open                     object_info_$brief            suffixed_name_$make           unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     98 000375        11 000405       173 000424       174 000426       175 000440       176 000451       177 000452
    178 000464       179 000471       180 000477       181 000516       182 000520       183 000543       186 000544
    187 000552       188 000554       190 000576       191 000600       192 000602       193 000621       194 000623
    195 000663       198 000664       199 000673       200 000676       201 000715       202 000727       203 000767
    205 000770       207 000771       208 001000       210 001010       211 001036       212 001040       213 001103
    215 001107       216 001135       217 001137       218 001202       220 001206       221 001234       222 001236
    223 001301       225 001305       226 001324       227 001370       228 001374       229 001440       231 001444
    232 001446       234 001447       235 001475       236 001477       237 001506       238 001517       240 001551
    241 001560       242 001622       243 001625       244 001646       245 001650       247 001652       248 001672
    249 001707       250 001725       254 001764       256 001774       257 001775       258 002001       259 002004
    260 002006       262 002012       263 002015       264 002022       265 002031       266 002035       269 002036
    270 002040       271 002047       272 002051       273 002055       276 002056       277 002063       278 002077
    279 002104       281 002106       282 002115       283 002122       285 002123       286 002126       287 002132
    288 002137       289 002166       290 002170       291 002237       293 002260       294 002262       295 002264
    296 002271       297 002274       298 002276       299 002277       301 002301       302 002311       304 002320
    305 002321       306 002322       307 002325       308 002333       309 002340       310 002343       311 002352
    312 002355       313 002360       314 002365       315 002372       318 002373       319 002374       320 002376
    321 002401       323 002446       325 002447       326 002453       327 002460       328 002465       329 002472
    330 002505       331 002511       332 002516       333 002520       334 002521       336 002523       337 002526
    338 002531       339 002535       341 002536       342 002537       343 002540       344 002544       345 002547
    346 002553       347 002554       349 002556       350 002576       352 002612       353 002620       354 002625
    355 002631       356 002634       357 002636       358 002644       359 002675       361 002676       362 002727
    363 002777       365 003001       366 003021       367 003027       368 003034       369 003041       370 003046
    371 003053       372 003060       373 003062       374 003106       376 003127       377 003143       378 003151
    379 003154       380 003161       381 003212       382 003224       383 003256       384 003270       385 003303
    386 003307       387 003316       388 003320       389 003366       391 003370       392 003410       393 003416
    394 003423       395 003430       396 003435       397 003442       398 003447       399 003451       400 003475
    402 003516       403 003532       404 003540       405 003543       406 003550       407 003601       408 003613
    409 003645       410 003657       411 003671       412 003675       413 003704       414 003706       415 003754
    417 003756       418 003762       419 003763       554 003764       555 004021       556 004025       558 004026
    559 004067       560 004073       562 004074       563 004126       564 004132       566 004133       567 004170
    568 004174       421 004175       422 004203       423 004210       424 004212       425 004223       427 004225
    428 004237       430 004242       431 004246       432 004260       434 004263       435 004267       436 004300
    437 004303       438 004305       439 004317       441 004322       442 004326       443 004337       444 004342
    445 004344       446 004356       448 004361       449 004365       450 004377       452 004402       453 004406
    454 004420       456 004423       459 004424       460 004432       462 004435       463 004447       464 004461
    465 004464       466 004471       467 004477       468 004503       469 004511       470 004536       471 004541
    472 004544       473 004606       475 004613       476 004616       477 004634       478 004656       479 004657
    480 004662       483 004665       484 004712       486 004715       487 004720       488 004722       489 004732
    490 004742       491 004746       492 004751       494 005010       495 005013       496 005014       497 005020
    498 005024       499 005035       500 005046       503 005047       504 005050       505 005062       506 005073
    507 005101       509 005102       510 005104       511 005105       513 005106       514 005111       516 005112
    517 005113       518 005114       519 005121       520 005122       521 005127       522 005130       523 005135
    524 005136       525 005143       526 005144       527 005146       528 005151       529 005162       530 005202
    531 005207       532 005210       533 005213       535 005214       539 005215       540 005236       541 005243
    542 005250       543 005255       544 005262       545 005267       546 005274       547 005305       549 005306


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
