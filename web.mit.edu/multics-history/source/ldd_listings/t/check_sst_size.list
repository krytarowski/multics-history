	COMPILATION LISTING OF SEGMENT check_sst_size
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1921.81_Mon_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* format: ^inddcls,ind4,ifthenstmt,ifthendo,thendo,ifthen,tree,^case */
        8 
        9 check_sst_size: proc;
       10 
       11         call cu_$arg_count (n_args, code);
       12         if code ^= 0 then go to REPORT_ERROR;
       13 
       14         do arg_no = 1 to n_args;
       15 
       16 	  call cu_$arg_ptr (arg_no, argp, argl, code);
       17 	  if code ^= 0 then go to REPORT_ERROR;
       18 
       19 	  if expect_4k_value then do;
       20 		expect_4k_value = "0"b;
       21 		ctl_arg = "-4k";
       22 		aste_entries (0) = cv_dec_check_ (arg, code);
       23 		if code ^= 0 then go to REPORT_CV_ERROR;
       24 		if aste_entries (0) < 1 then go to REPORT_VALUE_ERROR;
       25 	      end;
       26 
       27 	  else if expect_16k_value then do;
       28 		     expect_16k_value = "0"b;
       29 		     ctl_arg = "-16k";
       30 		     aste_entries (1) = cv_dec_check_ (arg, code);
       31 		     if code ^= 0 then go to REPORT_CV_ERROR;
       32 		     if aste_entries (1) < 1 then go to REPORT_VALUE_ERROR;
       33 		 end;
       34 
       35 	       else if expect_64k_value then do;
       36 			expect_64k_value = "0"b;
       37 			ctl_arg = "-64k";
       38 			aste_entries (2) = cv_dec_check_ (arg, code);
       39 			if code ^= 0 then go to REPORT_CV_ERROR;
       40 			if aste_entries (2) < 1 then go to REPORT_VALUE_ERROR;
       41 		      end;
       42 
       43 		  else if expect_256k_value then do;
       44 			     expect_256k_value = "0"b;
       45 			     ctl_arg = "-256k";
       46 			     aste_entries (3) = cv_dec_check_ (arg, code);
       47 			     if code ^= 0 then go to REPORT_CV_ERROR;
       48 			     if aste_entries (3) < 1 then go to REPORT_VALUE_ERROR;
       49 			 end;
       50 
       51 		       else if expect_pn_value then do;
       52 				ctl_arg = "-pn";
       53 				if index (arg, "-") = 1 & ^accept_hyphen_path then do;
       54 				        if arg = "-name" | arg = "-nm" then accept_hyphen_path = "1"b;
       55 				        else go to REPORT_VALUE_ERROR;
       56 				    end;
       57 				else do;
       58 				        expect_pn_value = "0"b;
       59 				        accept_hyphen_path = "0"b;
       60 				        call expand_pathname_ (arg, config_dir_name, config_ename, code);
       61 				        if code ^= 0 then do;
       62 					      call com_err_ (code, my_name,
       63 						"^/Pathname expansion for config deck: ^a", arg);
       64 					      return;
       65 					  end;
       66 
       67 				        have_path = "1"b;
       68 				    end;
       69 			      end;
       70 
       71 			  else do;
       72 				if arg = "-4k" then expect_4k_value = "1"b;
       73 				else if arg = "-16k" then expect_16k_value = "1"b;
       74 				     else if arg = "-64k" then expect_64k_value = "1"b;
       75 					else if arg = "-256k" then expect_256k_value = "1"b;
       76 					     else if arg = "-pathname" then expect_pn_value = "1"b;
       77 						else if arg = "-pn" then expect_pn_value = "1"b;
       78 						     else if index (arg, "-") = 1 then do;
       79 							        code = error_table_$badopt;
       80 							        go to REPORT_ARG_ERROR;
       81 							    end;
       82 							else do;
       83 							        code = error_table_$bad_arg;
       84 							        go to REPORT_ARG_ERROR;
       85 							    end;
       86 			      end;		/* ends ctl arg do */
       87 
       88         end;					/* ends arg do loop */
       89 
       90 /* Check for missing arguments. */
       91 
       92         if expect_4k_value | expect_16k_value | expect_64k_value | expect_256k_value | expect_pn_value then do;
       93 	      code = error_table_$noarg;
       94 	      go to REPORT_ARG_ERROR;
       95 	  end;
       96 
       97 /* If any values were not supplied, find a config deck, and get them. */
       98 
       99         configp = null ();
      100         do i = 0 to hbound (aste_entries, 1);
      101 	  if aste_entries (i) = 0 then do;
      102 		if configp = null () then do;
      103 		        on cleanup call clean_up ();
      104 
      105 		        if have_path then do;
      106 			      call initiate_file_ (config_dir_name, config_ename, R_ACCESS, configp, bitcnt, code);
      107 			      if code ^= 0 then do;
      108 				    call com_err_ (code, my_name,
      109 				        "^/Cannot access config deck with pathname, ^a", pathname_ (config_dir_name, config_ename));
      110 				    return;
      111 				end;
      112 			  end;
      113 		        else do;
      114 			      configp = addr (config_deck$);
      115 			      call hcs_$status_mins (configp, stype, bitcnt, code);
      116 			      if code ^= 0 then do;
      117 				    call com_err_ (code, my_name, "^/Cannot get bit count of config deck.");
      118 				    return;
      119 				end;
      120 			  end;
      121 
      122 		        config_n_cards = divide (divide (bitcnt, 36, 17, 0), size (config_card), 17, 0);
      123 		        config_max_cards = 128;	/* a guess */
      124 
      125 		        sst_cardp = null ();
      126 		        do card_no = 1 by 1 while (config_deck.cards (card_no).word ^= FREE_CARD_WORD & sst_cardp = null ());
      127 			  cardp = addr (config_deck.cards (card_no));
      128 			  if config_card.word = SST_CARD_WORD then sst_cardp = cardp;
      129 		        end;
      130 
      131 		        if sst_cardp = null () then do;
      132 			      call com_err_ (0, my_name, "Unable to find SST card in configuration deck.");
      133 			      return;
      134 			  end;
      135 		    end;				/* ends do if configp = null */
      136 
      137 		aste_entries (i) = sst_card.no_aste (i);
      138 	      end;				/* ends do if aste_entries(i) = 0 */
      139         end;					/* ends do loop through aste_entries */
      140         call clean_up ();
      141 
      142 /* Calculate size of hash table. */
      143 
      144         n_astes = sum (aste_entries);
      145         n_buckets = divide (n_astes, AVG_HT_DEPTH, 17);
      146         do i = 1 to hbound (HT_SIZES, 1) while (n_buckets > HT_SIZES (i));
      147         end;
      148         if i > hbound (HT_SIZES, 1) then i = hbound (HT_SIZES, 1);
      149         n_buckets = HT_SIZES (i);
      150 
      151 /* Calculate total size of SST. */
      152 
      153         n_sst_words = size (sst) + n_buckets;
      154         do i = 0 to 3;
      155 	  words_in_aste (i) = size (aste) + PTS (i);
      156 	  n_sst_words = n_sst_words + words_in_aste (i) * aste_entries (i);
      157         end;
      158 
      159         n_pages = divide (n_sst_words, 1024, 35, 0);
      160         words_in_last_page = mod (n_sst_words, 1024);
      161         if words_in_last_page ^= 0 then n_pages = n_pages + 1;
      162 
      163         call ioa_ ("Size of SST header = ^d words^/Size of AST hash table = ^d words", size (sst), n_buckets);
      164         do i = 0 to 3;
      165 	  call ioa_ ("Size of ^a ASTE pool with ^d entries (^d words in each) = ^d words",
      166 	      aste_name (i), aste_entries (i), words_in_aste (i), words_in_aste (i) * aste_entries (i));
      167         end;
      168         call ioa_ ("Total size of SST = ^d words (^d pages^[ with ^d words used in last page^])",
      169 	  n_sst_words,
      170 	  n_pages, (words_in_last_page ^= 0), words_in_last_page
      171 	  );
      172         return;
      173 
      174 REPORT_ERROR:
      175         call com_err_ (code, my_name);
      176         go to DISPLAY_USAGE;
      177 
      178 REPORT_ARG_ERROR:
      179         call com_err_ (code, my_name, arg);
      180 
      181 DISPLAY_USAGE:
      182         call ioa_ ("Usage:  ^a <-4k N_4K_ASTE | -16k N_16K_ASTE | -64k N_64K_ASTE | -256k N_256K_ASTE | -pn PATH>", my_name);
      183         return;
      184 
      185 REPORT_CV_ERROR:
      186         call com_err_ (error_table_$bad_conversion, my_name,
      187 	  "^/Character ^d caused conversion error in arg, ^a, to control argument ""^a"".",
      188 	  code, arg, ctl_arg);
      189         return;
      190 
      191 REPORT_VALUE_ERROR:
      192         call com_err_ (error_table_$bad_arg, my_name, "^a to control argument ^a.", arg, ctl_arg);
      193         return;
      194 
      195 clean_up: proc;
      196 
      197         if have_path then if configp ^= null then do;
      198 		 call terminate_file_ (configp, 0, TERM_FILE_TERM, (0));
      199 		 configp = null;
      200 	       end;
      201     end;
      202 
      203 dcl     AVG_HT_DEPTH	 fixed bin init (5) int static options (constant);
      204 dcl     HT_SIZES		 (6) fixed bin init (64, 128, 256, 512, 1024, 2048) int static options (constant);
      205 dcl     PTS		 (0:3) fixed bin init (4, 16, 64, 256);
      206 dcl     accept_hyphen_path	 bit (1) init ("0"b);
      207 dcl     addr		 builtin;
      208 dcl     arg		 char (argl) based (argp);
      209 dcl     argl		 fixed bin (21);
      210 dcl     argp		 pointer;
      211 dcl     arg_no		 fixed bin;
      212 dcl     aste_entries	 (0:3) fixed bin init (0, 0, 0, 0);
      213 dcl     aste_name		 (0:3) char (4) init ("4K", "16K", "64K", "256K");
      214 dcl     bitcnt		 fixed bin (24);
      215 dcl     card_no		 fixed bin;
      216 dcl     cleanup		 condition;
      217 dcl     code		 fixed bin (35);
      218 dcl     com_err_		 entry () options (variable);
      219 dcl     config_dir_name	 char (168);
      220 dcl     config_ename	 char (32);
      221 dcl     ctl_arg		 char (32);
      222 dcl     cu_$arg_count	 entry (fixed bin, fixed bin (35));
      223 dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      224 dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
      225 dcl     divide		 builtin;
      226 dcl     error_table_$active_function fixed bin (35) ext static;
      227 dcl     error_table_$bad_arg	 fixed bin (35) ext static;
      228 dcl     error_table_$bad_conversion fixed bin (35) ext static;
      229 dcl     error_table_$badopt	 fixed bin (35) ext static;
      230 dcl     error_table_$noarg	 fixed bin (35) ext static;
      231 dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      232 dcl     expect_4k_value	 bit (1) init ("0"b);
      233 dcl     expect_16k_value	 bit (1) init ("0"b);
      234 dcl     expect_64k_value	 bit (1) init ("0"b);
      235 dcl     expect_256k_value	 bit (1) init ("0"b);
      236 dcl     expect_pn_value	 bit (1) init ("0"b);
      237 dcl     hbound		 builtin;
      238 dcl     have_path		 bit (1) init ("0"b);
      239 dcl     hcs_$status_mins	 entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
      240 dcl     i			 fixed bin;
      241 dcl     initiate_file_	 entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      242 dcl     ioa_		 entry () options (variable);
      243 dcl     mod		 builtin;
      244 dcl     my_name		 char (14) init ("check_sst_size") int static options (constant);
      245 dcl     n_args		 fixed bin;
      246 dcl     n_astes		 fixed bin;
      247 dcl     n_buckets		 fixed bin;
      248 dcl     n_pages		 fixed bin;
      249 dcl     n_sst_words		 fixed bin;
      250 dcl     null		 builtin;
      251 dcl     pathname_		 entry (char (*), char (*)) returns (char (168));
      252 dcl     size		 builtin;
      253 dcl     stype		 fixed bin (2);
      254 dcl     sum		 builtin;
      255 dcl     terminate_file_	 entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      256 dcl     words_in_aste	 (0:3) fixed bin;
      257 dcl     words_in_last_page	 fixed bin;
      258 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      259 
      260 
  2     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      261 
      262 
  3     1 /* BEGIN INCLUDE FILE ... config_deck.incl.pl1 ... 11/13/80, W. Olin Sibert */
  3     2 
  3     3 dcl (configp, cardp) pointer;
  3     4 dcl  config_n_cards fixed bin;			/* Number of cards used in config */
  3     5 dcl  config_max_cards fixed bin;			/* Max number of cards in config */
  3     6 
  3     7 dcl  config_deck$ fixed bin external static;
  3     8 
  3     9 dcl 1 config_deck aligned based (configp),
  3    10     2 cards (config_n_cards) aligned like config_card,
  3    11     2 pad_cards (config_max_cards - config_n_cards) aligned like config_card;
  3    12 
  3    13 dcl 1 config_card aligned based (cardp),
  3    14     2 word char (4) aligned,
  3    15     2 data_field (14) bit (36) aligned,
  3    16     2 type_word aligned like config_card_type_word;
  3    17 
  3    18 dcl 1 config_card_type_word aligned based,
  3    19     2 field_type (14) bit (2) unaligned,
  3    20     2 pad1 bit (4) unaligned,
  3    21     2 n_fields fixed bin (4) unsigned unaligned;
  3    22 
  3    23 dcl (CONFIG_DECIMAL_TYPE	init ("11"b),
  3    24      CONFIG_OCTAL_TYPE	init ("00"b),
  3    25      CONFIG_SINGLE_CHAR_TYPE	init ("01"b),
  3    26      CONFIG_STRING_TYPE	init ("10"b)) bit (2) aligned static options (constant);
  3    27 
  3    28 dcl  ZERO_CARD_WORD char (4) aligned internal static options (constant) init ("    ");
  3    29 dcl  FREE_CARD_WORD char (4) aligned internal static options (constant) init ("ÿÿÿÿ");
  3    30 
  3    31 dcl  VALID_CARD_WORD_CHARACTERS char (38) internal static options (constant) init
  3    32     ("abcdefghijklmnopqrstuvwxyz0123456789_.");		/* lowercase letters, digits, period and underscore */
  3    33 
  3    34 dcl  EMPTY_FIELD bit (36) aligned internal static options (constant) init ("777777777777"b3);
  3    35 
  3    36 /* END INCLUDE FILE config_deck.incl.pl1 */
      263 
      264 
  4     1 /* BEGIN INCLUDE FILE ... config_sst_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  4     2 
  4     3 dcl  sst_cardp pointer;				/* pointer to SST card */
  4     4 
  4     5 dcl 1 sst_card aligned based (sst_cardp),		/* SST card declaration */
  4     6     2 word char (4),				/* "sst" */
  4     7     2 no_aste (0:3) fixed bin,			/* Size of the four ASTE pools */
  4     8 
  4     9     2 pad (10) bit (36) aligned,			/* Pad to 15 fields */
  4    10 
  4    11     2 type_word aligned,
  4    12       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  4    13       3 pad1 bit (4) unaligned,
  4    14       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  4    15 
  4    16 dcl  SST_CARD_WORD char (4) aligned internal static options (constant) init ("sst");
  4    17 
  4    18 /* END INCLUDE FILE ... config_sst_card.incl.pl1 */
      265 
      266 
  5     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  5     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  5     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  5     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  5     5 
  5     6 dcl  sst_seg$ external;
  5     7 dcl  sstp ptr;
  5     8 
  5     9 dcl 1 sst based (sstp) aligned,
  5    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  5    11 
  5    12 /* SST HEADER */
  5    13 
  5    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  5    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  5    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  5    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  5    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  5    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  5    20 
  5    21     2 ptl bit (36),					/* global page table loop lock */
  5    22     2 astl bit (36),				/* global ast allocation block lock */
  5    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  5    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  5    25     2 nused fixed bin,				/* number of pages on used list */
  5    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  5    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  5    28 
  5    29     2 astap ptr,					/* aste array pointer */
  5    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  5    31     2 astsize fixed bin,				/* size of an AST entry */
  5    32     2 cmesize fixed bin,				/* size of a CME entry */
  5    33     2 root_astep ptr,				/* pointer to the root AST entry */
  5    34 
  5    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  5    36     2 level (0:3),					/* per-list information about ASTE's */
  5    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  5    38 
  5    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  5    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  5    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  5    42     2 strsize fixed bin,				/* Trailer size in words. */
  5    43 
  5    44 /* CORE MAP HEADER */
  5    45 
  5    46     2 cmp ptr,					/* pointer to start of core map */
  5    47     2 usedp bit (18),				/* pointer to first used core block */
  5    48     2 wtct fixed bin,				/* count of pages being written */
  5    49 
  5    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  5    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  5    52 						/* MISC */
  5    53 
  5    54     2 double_write fixed bin,				/* trigger for store through scheme */
  5    55 						/* 0 = no double writes,
  5    56*						   1 = all non-pd pages get written,
  5    57*						   2 = all directories get written */
  5    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  5    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  5    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  5    61 
  5    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  5    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  5    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  5    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  5    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  5    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  5    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  5    69 
  5    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  5    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  5    72 
  5    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  5    74 
  5    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  5    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  5    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  5    78 
  5    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  5    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  5    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  5    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  5    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  5    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  5    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  5    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  5    87 
  5    88 
  5    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  5    90 
  5    91     2 steps fixed bin,				/* number of steps taken around used list */
  5    92     2 needc fixed bin,				/* number of times core page needed */
  5    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  5    94     2 ctwait fixed bin,				/* number of times write counter was full */
  5    95     2 wired fixed bin,				/* number of pages wired by pc */
  5    96     2 laps fixed bin,				/* number of times around used list */
  5    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  5    98     2 skipu fixed bin,				/* because of being used */
  5    99 
  5   100     2 skipm fixed bin,				/* because of being modified */
  5   101     2 skipos fixed bin,				/* because out of service */
  5   102     2 aused fixed bin,				/* number of AST entries on used list */
  5   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  5   104     2 deact_count fixed bin,				/* count of deactivations */
  5   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  5   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  5   107 
  5   108     2 reads (8) fixed bin,				/* number of reads for each did */
  5   109     2 writes (8) fixed bin,				/* number of writes for each did */
  5   110 
  5   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  5   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  5   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  5   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  5   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  5   116     2 total_sf fixed bin,				/* total number of seg_faults */
  5   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  5   118     2 post_list_size fixed bin,
  5   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  5   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  5   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  5   122     2 pre_page_list_size fixed bin,
  5   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  5   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  5   125 
  5   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  5   127 
  5   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  5   129 
  5   130 /* MAIN MEMORY USAGE INFORMATION */
  5   131 
  5   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  5   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  5   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  5   135     2 recopies fixed bin,				/* number of times recopied because modified */
  5   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  5   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  5   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  5   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  5   140 
  5   141 /*  AST METERS  */
  5   142 
  5   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  5   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  5   145 
  5   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  5   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  5   148     2 asearches fixed bin,				/* count of full searches made */
  5   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  5   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  5   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  5   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  5   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  5   154 
  5   155     2 alaps fixed bin,				/* lap counter for AST list */
  5   156     2 updates fixed bin,				/* calls to updateb */
  5   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  5   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  5   159     2 total_bf fixed bin,				/* count of bound faults */
  5   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  5   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  5   162 
  5   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  5   164 
  5   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  5   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  5   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  5   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  5   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  5   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  5   171 
  5   172 /* PRE-PAGE METERS */
  5   173 
  5   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  5   175 
  5   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  5   177 
  5   178 
  5   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  5   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  5   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  5   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  5   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  5   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  5   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  5   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  5   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  5   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  5   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  5   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  5   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  5   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  5   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  5   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  5   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  5   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  5   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  5   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  5   199     2 activations fixed bin,				/* total count of activations */
  5   200     2 dir_activations fixed bin,			/* count of directory activations */
  5   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  5   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  5   203     2 evict_recover_data,				/* see evict_page.alm */
  5   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  5   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  5   206 
  5   207 /* Data for metering force_write facility 08/19/78 */
  5   208 
  5   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  5   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  5   211     2 fw_none fixed bin,				/* Force write wrote none */
  5   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  5   213 
  5   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  5   215     2 pf_unlock_ptl_meterings fixed bin,
  5   216 
  5   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  5   218     2 backup_activations fixed bin (35),		/* activations for backup */
  5   219     2 metering_flags aligned,				/* small chunks of misc. information */
  5   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  5   221       3 pad bit (35) unal,
  5   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  5   223 
  5   224 /* METERS FOR STACK TRUNCATION */
  5   225 
  5   226     2 (stk_truncate_should_didnt,			/* counts */
  5   227        stk_truncate_should_did,
  5   228        stk_truncate_shouldnt_didnt,
  5   229        stk_truncate_shouldnt_did) fixed bin (35),
  5   230     2 stk_pages_truncated fixed bin (35),
  5   231     2 stk_pages_truncated_in_core fixed bin (35),
  5   232 
  5   233 /* SUPPORT FOR PC SEGMOVES */
  5   234 
  5   235     2 segmove_lock aligned,
  5   236       3 pid bit (36) aligned,
  5   237       3 event bit (36) aligned,
  5   238       3 notify bit (1) aligned,
  5   239     2 segmove_io_limit fixed bin, /* max read aheads */
  5   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  5   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  5   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  5   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  5   244 
  5   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  5   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  5   247     2 segmove_vtocx fixed bin,			/* ditto */
  5   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  5   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  5   250 
  5   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  5   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  5   253     2 trace_sw aligned,				/* tracing control flags */
  5   254       3 pad_trace bit (32) unaligned,
  5   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  5   256       3 tty_trace bit (1) unaligned,
  5   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  5   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  5   259     2 new_pages fixed bin,				/* newly created pages */
  5   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  5   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  5   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  5   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  5   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  5   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  5   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  5   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  5   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  5   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  5   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  5   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  5   272 
  5   273 /* END INCLUDE FILE sst.incl.pl1 */
      267 
      268 
  6     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  6     2 /* format: style2,^inddcls,idind32 */
  6     3 
  6     4 declare 1 terminate_file_switches	based,
  6     5 	2 truncate		bit (1) unaligned,
  6     6 	2 set_bc			bit (1) unaligned,
  6     7 	2 terminate		bit (1) unaligned,
  6     8 	2 force_write		bit (1) unaligned,
  6     9 	2 delete			bit (1) unaligned;
  6    10 
  6    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  6    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  6    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  6    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  6    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  6    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  6    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  6    18 
  6    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      269 
      270     end check_sst_size;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1921.8  check_sst_size.pl1                >udd>sm>ds>w>ml>check_sst_size.pl1
259          1    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
261          2    01/30/85  1623.9  aste.incl.pl1                     >ldd>incl>aste.incl.pl1
263          3    05/08/81  1953.6  config_deck.incl.pl1              >ldd>incl>config_deck.incl.pl1
265          4    05/08/81  1953.7  config_sst_card.incl.pl1          >ldd>incl>config_sst_card.incl.pl1
267          5    01/30/85  1623.9  sst.incl.pl1                      >ldd>incl>sst.incl.pl1
269          6    04/06/83  1339.4  terminate_file.incl.pl1           >ldd>incl>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AVG_HT_DEPTH                           constant        fixed bin(17,0)          initial dcl 203 ref 145
FREE_CARD_WORD                  002134 constant        char(4)                  initial dcl 3-29 ref 126
HT_SIZES                        000006 constant        fixed bin(17,0)          initial array dcl 204 ref 146 146 148 148 149
PTS                             000100 automatic       fixed bin(17,0)          initial array dcl 205 set ref 155 205* 205* 205*
                                                                                  205*
R_ACCESS                        000044 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 106*
SST_CARD_WORD                   000001 constant        char(4)                  initial dcl 4-16 ref 128
TERM_FILE_TERM                  000000 constant        bit(3)                   initial packed unaligned dcl 6-14 set ref 198*
accept_hyphen_path              000104 automatic       bit(1)                   initial packed unaligned dcl 206 set ref 53 54* 59*
                                                                                  206*
addr                                                   builtin function         dcl 207 ref 114 127
arg                                    based           char                     packed unaligned dcl 208 set ref 22* 30* 38* 46* 53
                                                                                  54 54 60* 62* 72 73 74 75 76 77 78 178* 185* 191*
arg_no                          000110 automatic       fixed bin(17,0)          dcl 211 set ref 14* 16*
argl                            000105 automatic       fixed bin(21,0)          dcl 209 set ref 16* 22 22 30 30 38 38 46 46 53 54 54
                                                                                  60 60 62 62 72 73 74 75 76 77 78 178 178 185 185
                                                                                  191 191
argp                            000106 automatic       pointer                  dcl 210 set ref 16* 22 30 38 46 53 54 54 60 62 72 73
                                                                                  74 75 76 77 78 178 185 191
aste                                   based           structure                level 1 dcl 2-11 ref 155
aste_entries                    000111 automatic       fixed bin(17,0)          initial array dcl 212 set ref 22* 24 30* 32 38* 40
                                                                                  46* 48 100 101 137* 144 156 165* 165 212* 212*
                                                                                  212* 212*
aste_name                       000115 automatic       char(4)                  initial array packed unaligned dcl 213 set ref 165*
                                                                                  213* 213* 213* 213*
astep                                  automatic       pointer                  dcl 2-9 ref 155
bitcnt                          000121 automatic       fixed bin(24,0)          dcl 214 set ref 106* 115* 122
card_no                         000122 automatic       fixed bin(17,0)          dcl 215 set ref 126* 126* 127*
cardp                           000252 automatic       pointer                  dcl 3-3 set ref 122 127* 128 128
cards                                  based           structure                array level 2 dcl 3-9 set ref 127
cleanup                         000124 stack reference condition                dcl 216 ref 103
code                            000132 automatic       fixed bin(35,0)          dcl 217 set ref 11* 12 16* 17 22* 23 30* 31 38* 39
                                                                                  46* 47 60* 61 62* 79* 83* 93* 106* 107 108* 115*
                                                                                  116 117* 174* 178* 185*
com_err_                        000010 constant        entry                    external dcl 218 ref 62 108 117 132 174 178 185 191
config_card                            based           structure                level 1 dcl 3-13 ref 122
config_card_type_word                  based           structure                level 1 dcl 3-18
config_deck                            based           structure                level 1 dcl 3-9
config_deck$                    000044 external static fixed bin(17,0)          dcl 3-7 set ref 114
config_dir_name                 000133 automatic       char(168)                packed unaligned dcl 219 set ref 60* 106* 108* 108*
config_ename                    000205 automatic       char(32)                 packed unaligned dcl 220 set ref 60* 106* 108* 108*
config_max_cards                000255 automatic       fixed bin(17,0)          dcl 3-5 set ref 123*
config_n_cards                  000254 automatic       fixed bin(17,0)          dcl 3-4 set ref 122*
configp                         000250 automatic       pointer                  dcl 3-3 set ref 99* 102 106* 114* 115* 126 127 197
                                                                                  198* 199*
ctl_arg                         000215 automatic       char(32)                 packed unaligned dcl 221 set ref 21* 29* 37* 45* 52*
                                                                                  185* 191*
cu_$arg_count                   000012 constant        entry                    external dcl 222 ref 11
cu_$arg_ptr                     000014 constant        entry                    external dcl 223 ref 16
cv_dec_check_                   000016 constant        entry                    external dcl 224 ref 22 30 38 46
divide                                                 builtin function         dcl 225 ref 122 122 145 159
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 227 set ref 83 191*
error_table_$bad_conversion     000022 external static fixed bin(35,0)          dcl 228 set ref 185*
error_table_$badopt             000024 external static fixed bin(35,0)          dcl 229 ref 79
error_table_$noarg              000026 external static fixed bin(35,0)          dcl 230 ref 93
expand_pathname_                000030 constant        entry                    external dcl 231 ref 60
expect_16k_value                000226 automatic       bit(1)                   initial packed unaligned dcl 233 set ref 27 28* 73*
                                                                                  92 233*
expect_256k_value               000230 automatic       bit(1)                   initial packed unaligned dcl 235 set ref 43 44* 75*
                                                                                  92 235*
expect_4k_value                 000225 automatic       bit(1)                   initial packed unaligned dcl 232 set ref 19 20* 72*
                                                                                  92 232*
expect_64k_value                000227 automatic       bit(1)                   initial packed unaligned dcl 234 set ref 35 36* 74*
                                                                                  92 234*
expect_pn_value                 000231 automatic       bit(1)                   initial packed unaligned dcl 236 set ref 51 58* 76*
                                                                                  77* 92 236*
have_path                       000232 automatic       bit(1)                   initial packed unaligned dcl 238 set ref 67* 105 197
                                                                                  238*
hbound                                                 builtin function         dcl 237 ref 100 146 148 148
hcs_$status_mins                000032 constant        entry                    external dcl 239 ref 115
i                               000233 automatic       fixed bin(17,0)          dcl 240 set ref 100* 101 137 137* 146* 146* 148 148*
                                                                                  149 154* 155 155 156 156* 164* 165 165 165 165
                                                                                  165*
initiate_file_                  000034 constant        entry                    external dcl 241 ref 106
ioa_                            000036 constant        entry                    external dcl 242 ref 163 165 168 181
mod                                                    builtin function         dcl 243 ref 160
my_name                         000002 constant        char(14)                 initial packed unaligned dcl 244 set ref 62* 108*
                                                                                  117* 132* 174* 178* 181* 185* 191*
n_args                          000234 automatic       fixed bin(17,0)          dcl 245 set ref 11* 14
n_astes                         000235 automatic       fixed bin(17,0)          dcl 246 set ref 144* 145
n_buckets                       000236 automatic       fixed bin(17,0)          dcl 247 set ref 145* 146 149* 153 163*
n_pages                         000237 automatic       fixed bin(17,0)          dcl 248 set ref 159* 161* 161 168*
n_sst_words                     000240 automatic       fixed bin(17,0)          dcl 249 set ref 153* 156* 156 159 160 168*
no_aste                   1            based           fixed bin(17,0)          array level 2 dcl 4-5 ref 137
null                                                   builtin function         dcl 250 ref 99 102 125 126 131 197 199
pathname_                       000040 constant        entry                    external dcl 251 ref 108 108
size                                                   builtin function         dcl 252 ref 122 153 155 163 163
sst                                    based           structure                level 1 dcl 5-9 ref 153 163 163
sst_card                               based           structure                level 1 dcl 4-5
sst_cardp                       000256 automatic       pointer                  dcl 4-3 set ref 125* 126 128* 131 137
sstp                                   automatic       pointer                  dcl 5-7 ref 153 163 163
stype                           000241 automatic       fixed bin(2,0)           dcl 253 set ref 115*
sum                                                    builtin function         dcl 254 ref 144
terminate_file_                 000042 constant        entry                    external dcl 255 ref 198
word                                   based           char(4)                  level 2 in structure "config_card" dcl 3-13
                                                                                  in procedure "check_sst_size" ref 128
word                                   based           char(4)                  array level 3 in structure "config_deck" dcl 3-9
                                                                                  in procedure "check_sst_size" set ref 126
words_in_aste                   000242 automatic       fixed bin(17,0)          array dcl 256 set ref 155* 156 165* 165
words_in_last_page              000246 automatic       fixed bin(17,0)          dcl 257 set ref 160* 161 168 168*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CONFIG_DECIMAL_TYPE                    internal static bit(2)                   initial dcl 3-23
CONFIG_OCTAL_TYPE                      internal static bit(2)                   initial dcl 3-23
CONFIG_SINGLE_CHAR_TYPE                internal static bit(2)                   initial dcl 3-23
CONFIG_STRING_TYPE                     internal static bit(2)                   initial dcl 3-23
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
EMPTY_FIELD                            internal static bit(36)                  initial dcl 3-34
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 6-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 6-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 6-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 6-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 6-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 6-15
VALID_CARD_WORD_CHARACTERS             internal static char(38)                 initial packed unaligned dcl 3-31
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
ZERO_CARD_WORD                         internal static char(4)                  initial dcl 3-28
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
error_table_$active_function           external static fixed bin(35,0)          dcl 226
seg_aste                               based           structure                level 1 dcl 2-96
sst_seg$                               external static fixed bin(17,0)          dcl 5-6
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 6-4

NAMES DECLARED BY EXPLICIT CONTEXT.
DISPLAY_USAGE                   001741 constant        label                    dcl 181 set ref 176
REPORT_ARG_ERROR                001716 constant        label                    dcl 178 ref 80 84 94
REPORT_CV_ERROR                 001762 constant        label                    dcl 185 ref 23 31 39 47
REPORT_ERROR                    001700 constant        label                    dcl 174 ref 12 17
REPORT_VALUE_ERROR              002025 constant        label                    dcl 191 ref 24 32 40 48 54
check_sst_size                  000316 constant        entry                    external dcl 9
clean_up                        002066 constant        entry                    internal dcl 195 ref 103 140

NAME DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 53 78

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2342        2410    2136        2352
Length      2724    2136        46         277     203           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
check_sst_size                      302 external procedure  is an external procedure.  
on unit on line 103                  64 on unit               
clean_up                             84 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
check_sst_size           000100 PTS                         check_sst_size
                         000104 accept_hyphen_path          check_sst_size
                         000105 argl                        check_sst_size
                         000106 argp                        check_sst_size
                         000110 arg_no                      check_sst_size
                         000111 aste_entries                check_sst_size
                         000115 aste_name                   check_sst_size
                         000121 bitcnt                      check_sst_size
                         000122 card_no                     check_sst_size
                         000132 code                        check_sst_size
                         000133 config_dir_name             check_sst_size
                         000205 config_ename                check_sst_size
                         000215 ctl_arg                     check_sst_size
                         000225 expect_4k_value             check_sst_size
                         000226 expect_16k_value            check_sst_size
                         000227 expect_64k_value            check_sst_size
                         000230 expect_256k_value           check_sst_size
                         000231 expect_pn_value             check_sst_size
                         000232 have_path                   check_sst_size
                         000233 i                           check_sst_size
                         000234 n_args                      check_sst_size
                         000235 n_astes                     check_sst_size
                         000236 n_buckets                   check_sst_size
                         000237 n_pages                     check_sst_size
                         000240 n_sst_words                 check_sst_size
                         000241 stype                       check_sst_size
                         000242 words_in_aste               check_sst_size
                         000246 words_in_last_page          check_sst_size
                         000250 configp                     check_sst_size
                         000252 cardp                       check_sst_size
                         000254 config_n_cards              check_sst_size
                         000255 config_max_cards            check_sst_size
                         000256 sst_cardp                   check_sst_size

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
mdfx1               enable_op           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_
expand_pathname_              hcs_$status_mins              initiate_file_                ioa_
pathname_                     terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
config_deck$                  error_table_$bad_arg          error_table_$bad_conversion   error_table_$badopt
error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000315       205 000323       206 000345       212 000346       213 000364       232 000406       233 000407
    234 000410       235 000411       236 000412       238 000413        11 000414        12 000424        14 000426
     16 000435        17 000452        19 000454        20 000456        21 000457        22 000462        23 000507
     24 000511        25 000514        27 000515        28 000517        29 000520        30 000523        31 000550
     32 000552        33 000555        35 000556        36 000560        37 000561        38 000564        39 000611
     40 000613        41 000616        43 000617        44 000621        45 000622        46 000625        47 000652
     48 000654        49 000657        51 000660        52 000662        53 000665        54 000703        56 000716
     58 000717        59 000720        60 000721        61 000751        62 000753        64 001006        67 001007
     69 001011        72 001012        73 001023        74 001032        75 001041        76 001050        77 001057
     78 001066        79 001100        80 001103        83 001104        84 001107        88 001110        92 001112
     93 001124        94 001127        99 001130       100 001132       101 001137       102 001141       103 001145
    105 001167       106 001171       107 001226       108 001230       110 001300       112 001301       114 001302
    115 001305       116 001321       117 001323       118 001347       122 001350       123 001354       125 001356
    126 001360       127 001375       128 001400       129 001404       131 001406       132 001412       133 001437
    137 001440       139 001444       140 001446       144 001452       145 001470       146 001472       147 001503
    148 001505       149 001512       153 001514       154 001516       155 001523       156 001527       157 001534
    159 001536       160 001541       161 001545       163 001547       164 001575       165 001601       167 001640
    168 001642       172 001677       174 001700       176 001715       178 001716       181 001741       183 001761
    185 001762       189 002024       191 002025       193 002064       195 002065       197 002073       198 002102
    199 002130       201 002133


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
