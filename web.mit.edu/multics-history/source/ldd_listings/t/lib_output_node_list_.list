	COMPILATION LISTING OF SEGMENT lib_output_node_list_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/22/86  1444.5 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(83-11-18,Lippard), approve(), audit(), install():
       13*     Use 60 line page lengths.
       14*  2) change(86-03-24,GDixon), approve(86-03-24,MCR7365),
       15*     audit(86-04-22,Dickson), install(86-04-22,MR12.0-1042):
       16*     Change page number format in footing and index to accomodate 5-digit page
       17*     numbers.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 lib_output_node_list_:	procedure;
       22 
       23      dcl						/*	parameters			*/
       24 	footing			char(45) varying,	/* footing line. (In)			*/
       25 	ASrequirements		bit(72) aligned;	/* bits indicating what information is required	*/
       26 						/*   in the printout of non-archive-comp nodes.	*/
       27 						/*   (In)					*/
       28 
       29      dcl						/*	automatic variables			*/
       30 	Lfirst_name		fixed bin(35),	/* length of the first name in a 2-name footer.	*/
       31 	Llast_name		fixed bin(35),	/* length of the last name in a 2-name footer.	*/
       32 	Lname			fixed bin(35),	/* length of a name in the index.		*/
       33 	Nchars			fixed bin(24),	/* length of chars string.			*/
       34 	Nentries			fixed bin,	/* number of nodes input to print entry point.	*/
       35 	1 POD_storage		aligned like POD,
       36 	Pchars			ptr,		/* ptr to chars string.			*/
       37 	Pindex_entry		ptr,		/* ptr to a name to be put in an index entry.	*/
       38 	Pname			ptr,		/* ptr to name to be put in the footer.		*/
       39 	Ptarget			ptr,		/* ptr to target node we're outputing.		*/
       40 	added_NL			fixed bin(35),	/* number of addition new_line chars which must	*/
       41 						/* be output before appending footing to page.	*/
       42 	cleanup			condition,
       43 	code			fixed bin(35),	/* a status code.				*/
       44 	dir			char(168) varying,	/* a directory path name.			*/
       45 	e			fixed bin,	/* the entry point indicator.			*/
       46 	ent			char(32) varying,	/* an entry name.				*/
       47 	1 eop			aligned,		/* structure containing values used by the	*/
       48 						/*    end-of-page (eop) handler to gen footing.	*/
       49 	  2 Pfirst_name		ptr,		/*    ptr to name of first node listed on this pg.*/
       50 	  2 Plast_name		ptr,		/*    ptr to name of last node listed on this pg.	*/
       51 	  2 multiple_names		bit(1) aligned,	/*    on if footing line can contain 2 names.	*/
       52          (i, j)			fixed bin,	/* a do-group index.			*/
       53 	long			char(100) aligned,	/* a convert error code.			*/
       54 	page			pic "zzzz9",	/* a page number char. string.		*/
       55 	saved_Eend_page		entry variable,	/* previous value of fcb.Eend_page.		*/
       56 	saved_page_text_length	fixed bin,	/* previous value of fcb.page_text_length.	*/
       57 	short			char(8) aligned;	/* a short converted error code.		*/
       58 
       59      dcl						/*	based variables			*/
       60 	chars			char(Nchars) based (Pchars),
       61 						/* character overlay for the outputable part of	*/
       62 	name			char(32) based;	/* the name of a node.			*/
       63 
       64      dcl (addr, divide, hbound, length, lbound, min, mod, null, reverse, string, substr, verify)
       65 				builtin;
       66 
       67      dcl						/*	entries				*/
       68 	convert_status_code_	entry (fixed bin(35), char(8) aligned, char(100) aligned),
       69 	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
       70 	ioa_$ioa_switch_nnl		entry options (variable),
       71 	iox_$put_chars		entry (ptr, ptr, fixed bin(21), fixed bin(35)),
       72 	lib_node_path_		entry (ptr, char(168) varying, char(32) varying),
       73 	lib_output_node_$cross_reference
       74 				entry (ptr, ptr, bit(72) aligned, fixed bin(35), char(32),
       75 				       char(168) varying),
       76          (lib_output_node_$info,
       77 	lib_output_node_$map,
       78 	lib_output_node_$print)	entry (ptr, ptr, bit(72) aligned, fixed bin(35), ptr),
       79 	lib_paged_output_		entry (ptr, fixed bin(21), ptr, fixed bin(35)),
       80 	lib_ptr_and_bc_		entry (ptr, fixed bin(24), ptr, ptr, fixed bin(24), fixed bin(35)),
       81 	sort_items_indirect_$char	entry (ptr, ptr, fixed bin(24));
       82 
       83      dcl						/*	static variables			*/
       84 	DOTS			char(40) aligned int static init ((20)" ."),
       85 	INDEX			char(32) aligned int static init ("INDEX"),
       86 	NL			char(1) aligned int static init ("
       87 "),						/* a new_line char.				*/
       88 	NULL_NAME			char(32) int static init (""),
       89 						/* a null name for use in index.		*/
       90 	line_2NL			char(134) int static init (
       91 "____________________________________________________________________________________________________________________________________
       92 
       93 "),						/* init ((132)"_" || NL || NL)		*/
       94 	line_NL			char(133) defined line_2NL position(1),
       95 	line			char(132) defined line_2NL position(1);
       96 						/* current ring number.			*/
       97 
       98 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       99 
      100 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      101 
      102 
      103 info:	entry	(Pfcb, Pnode_list, Pname_list, Pindex_list, footing, ASrequirements, Pstarname);
      104 
      105 	e = 1;					/* set entry point indicator.			*/
      106 	eop.multiple_names = "0"b;			/* don't worry about names in footers.		*/
      107 	go to begin;
      108 
      109 
      110 map:	entry	(Pfcb, Pnode_list, Pname_list, Pindex_list, footing, ASrequirements, Pstarname);
      111 
      112 	e = 2;					/* set entry point indicator.			*/
      113 	eop.multiple_names = "1"b;			/* enable multiple names in the footers.	*/
      114 	go to begin;
      115 
      116 
      117 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      118 	/*									*/
      119 	/*      These entry points scan a sorted list of nodes to output selected node		*/
      120 	/* information.								*/
      121 	/*									*/
      122 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      123 
      124 
      125 
      126 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      127 
      128 
      129 print:	entry	(Pfcb, Pnode_list, Pname_list, Pindex_list, footing, ASrequirements, Pstarname, Ppage_list);
      130 
      131 	e = 3;					/* set entry point indicator.			*/
      132 	eop.multiple_names = "0"b;			/* suppress multiple names in the footers.	*/
      133 
      134 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      135 	/*									*/
      136 	/*      This entry point writes the contents of the printable library entries represented	*/
      137 	/* by the nodes in the list.							*/
      138 	/*									*/
      139 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      140 
      141 
      142 begin:	saved_page_text_length = fcb.page_text_length;	/* perform end-of-page processing requiring	*/
      143 	fcb.page_text_length = fcb.page_length - 4;	/*    4 lines.				*/
      144 	saved_Eend_page = fcb.Eend_page;
      145 	fcb.Eend_page = new_page;			/* establish end_page condition handler.	*/
      146 
      147 	Srequirements = ASrequirements;		/* copy requirements and suppress new_line before	*/
      148 	S.new_line = "0"b;				/*    nodes printed at levels 2-n.		*/
      149 
      150 	go to entry (e);				/* do rest of processing by entry point.	*/
      151 
      152 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      153 
      154 
      155 entry(1):						/* library_info processing.			*/
      156 	eop.Pfirst_name, eop.Plast_name = addr(NULL_NAME);/* don't worry about names in the footers.	*/
      157 	do i = 1 to index_list.I;			/* scan through the list of nodes to be output.	*/
      158 	     Pnode = node_list.e (index_list.e(i));	/* access the ith node in the list.		*/
      159 	     if Pnode = null then go to END_NODE;
      160 	     Pname = name_list.e (index_list.e(i));	/* access its name.				*/
      161 	     if first_outputable_node (Pnode, Ptarget) then do;
      162 						/* if this is the first outputable node in this	*/
      163 						/* branch of the tree, then output it at level 1.	*/
      164 		call lib_output_node_$info (Pfcb, Pnode, ASrequirements, 1, Pstarname);
      165 		if Svalid.kids then			/* if this node has kids, output them too.	*/
      166 		     call output_nodes_kids (Pnode, 2);	/* Start with kids at level 2 of the tree.	*/
      167 		end;
      168 END_NODE:	     end;
      169 	call ioa_$ioa_switch_nnl (fcb.Piocb, "^2/");	/* skip 2 lines before start of next command.	*/
      170 	go to return;
      171 
      172 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      173 
      174 
      175 entry(2):						/* library_map				*/
      176 	eop.Pfirst_name = name_list.e (index_list.e (1));	/* store name of first node to be output for use	*/
      177 						/* in the footing line.			*/
      178 	do i = 1 to index_list.I;			/* scan through the list of nodes to be output.	*/
      179 	     Pnode = node_list.e (index_list.e (i));	/* address the ith node of the list,		*/
      180 	     Pname = name_list.e (index_list.e (i));	/* and its name.				*/
      181 	     if fcb.line_no+3 > fcb.page_text_length then do;
      182 		call new_page();			/* if we can't get at least 3 lines of output	*/
      183 		eop.Pfirst_name = Pname;		/*    for this one on the current page, skip to	*/
      184 		end;				/*    a new page, and report node as 1st on page.	*/
      185 	     eop.Plast_name = Pname;			/* At this point in time, this node is the last	*/
      186 						/* on this page.				*/
      187 	     if first_outputable_node (Pnode, Ptarget) then do;
      188 						/* if this is the first outputable node in this	*/
      189 						/* branch of the tree, then output it at level 1.	*/
      190 		call lib_output_node_$map (Pfcb, Pnode, ASrequirements, 1, Pstarname);
      191 		if Svalid.kids then			/* if this node has kids, map them at level 2.	*/
      192 		     call output_nodes_kids (Pnode, 2);
      193 		end;
      194 	     else do;				/* if this node is not the first outputable node	*/
      195 						/* of the branch, then cross-reference it at	*/
      196 						/* level 1.				*/
      197 		call lib_node_path_ (Ptarget, dir, ent);/* get path name of first outputable node for use	*/
      198 		if dir = ">" then
      199 		     dir = dir || ent;
      200 		else dir = dir || ">" || ent;		/* in cross-reference entry.			*/
      201 		call lib_output_node_$cross_reference (Pfcb, Pnode, ASrequirements, 1, Pname -> name, dir);
      202 		end;
      203 	     end;
      204 	call new_page();				/* Put a footing line on the last page.		*/
      205 	go to return;				/* All done!				*/
      206 
      207 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      208 
      209 
      210 return:	fcb.page_text_length = saved_page_text_length;	/* restore previous end-of-page processor.	*/
      211 	fcb.Eend_page = saved_Eend_page;
      212 	return;
      213 
      214 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      215 
      216 
      217 entry(3):	PPOD = addr(POD_storage);
      218 	POD.version = VPOD_1;			/* fill in lib_paged_output_ data struc.	*/
      219 	POD.Lline = fcb.line_length;
      220 	POD.Lpage = fcb.page_text_length;
      221 	POD.Ltop_margin = 0;
      222 	POD.Lbottom_margin = 0;
      223 	POD.Nfrom = 1;
      224 	POD.Nto = 0;
      225 	POD.switch = fcb.Piocb;
      226 	POD.end_page = print_footer;
      227 	string(POD.switches) = "0"b;
      228 	POD.Send_page = "1"b;
      229 	POD.Spartial_last_page = "1"b;
      230 	POD.Iat_column = 0;
      231 	POD.Icolumns_used = 0;
      232 	POD.Iline = fcb.line_no-1;
      233 	POD.Ipage = fcb.page_no;
      234 	POD.Imsf_comp = -1;
      235 	POD.heading = "";
      236 
      237 	name_list.I = name_list.N;			/* make name list as large as possible.		*/
      238 	page_list.I = page_list.N;
      239 	Nentries = node_list.I;
      240 
      241 	Pchars = null;				/* initialize cleanup on-unit's variables.	*/
      242 	on cleanup begin;
      243 	     if Pchars ^= null then do;
      244 		call hcs_$terminate_noname (Pchars, 0);
      245 		Pchars = null;
      246 		end;
      247 	     end;
      248 
      249 	do i = 1 to index_list.I;			/* scan through the sorted node list.		*/
      250 	     Pnode = node_list.e (index_list.e (i));	/* address the ith sorted node.		*/
      251 	     Pname = name_list.e (index_list.e (i));	/* address the name by which it was referenced.	*/
      252 	     page_list.e (index_list.e (i)) = POD.Ipage;	/* record page number on which node is output.	*/
      253 						/* cross-reference names of node in index.	*/
      254 	     do PDnames = node.PD repeat (Dnames.Pnext) while (Dnames.T ^= Tnames);
      255 		end;
      256 	     do j = 2 to Dnames.N while (node_list.I < node_list.N);
      257 		node_list.I = node_list.I + 1;
      258 		node_list.e (node_list.I) = Pnode;
      259 		name_list.e (node_list.I) = addr (Dnames.names(j));
      260 		page_list.e (node_list.I) = POD.Ipage;
      261 		end;
      262 
      263 	     call lib_paged_output_ (addr(line_NL), length(line_NL), PPOD, code);
      264 	     fcb.line_no = POD.Iline+1;
      265 	     fcb.page_no = POD.Ipage;
      266 	     if Svalid.kids then do;			/* if node has kids, use level numbers in header.	*/
      267 		call lib_output_node_$print (Pfcb, Pnode, ASrequirements, 1, Pstarname);
      268 		call output_nodes_kids (Pnode, 2);
      269 		end;
      270 	     else
      271 		call lib_output_node_$print (Pfcb, Pnode, ASrequirements, 0, Pstarname);
      272 	     POD.Iline = fcb.line_no-1;
      273 	     POD.Ipage = fcb.page_no;
      274 	     call lib_paged_output_ (addr(line_2NL), length(line_2NL), PPOD, code);
      275 	     call output_node (Pnode);		/* print the contents of the node.		*/
      276 	     end;
      277 	fcb.line_no = POD.Iline+1;
      278 	fcb.page_no = POD.Ipage;
      279 	if Nentries > 1 then do;			/* if there was more than 1 entry output, 	*/
      280 	     name_list.I = node_list.I;		/* then generate an index.			*/
      281 	     index_list.I = node_list.I;		/* adjust bounds of name and index arrays.	*/
      282 	     call sort_items_indirect_$char (addr(name_list.I), addr(index_list.I), 32);
      283 	     call output_index;			/* sort the name array and output the index.	*/
      284 	     end;
      285 	go to return;
      286 
      287 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      288 
      289 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      290 
      291 
      292 first_outputable_node:	procedure (P, Pfirst)	/* Internal procedure to return ptr to first node	*/
      293 			returns (bit(1) aligned);	/* in tree branch containing node pointed	*/
      294 						/* to by P, which is outputable.		*/
      295      dcl	P			ptr,		/* ptr to node to be tested. (In)		*/
      296 	Pfirst			ptr,		/* ptr to the first printable node. (Out)	*/
      297 	Pn			ptr,		/* a ptr temp.				*/
      298 	Pp			ptr;		/* a ptr temp.				*/
      299 
      300 	Pn = P;					/* save ptr to node at current tree level.	*/
      301 	do Pp = P -> node.Pparent repeat (Pp -> node.Pparent) while (Pp ^= null);
      302 						/* scan up the tree looking for a non-outputable	*/
      303 						/* parent.				*/
      304 	     if Pp -> node.Sreq then;			/* when one is found, save ptr to its kid.	*/
      305 	     else
      306 		go to found;
      307 	     Pn = Pp;
      308 	     end;
      309 found:	Pfirst = Pn;				/* return ptr to first outputable node.		*/
      310 	if Pn = P then do;				/* if our input node was the first outputable,	*/
      311 	     if addr(P->node.Sreq)->Sreq.cross_ref then;	/* if node's names aren't being cross-referenced,	*/
      312 	     else return("1"b);			/*   first time we encounter node is only time,	*/
      313 						/*   and we must output it now.		*/
      314 	     do PDnames = P -> node.PD repeat (Dnames.Pnext) while (Dnames.T ^= Tnames);
      315 		end;				/* and if name from name-list is first on node,	*/
      316 	     if Pname = addr (Dnames.names(1)) then	/* then node is first outputable.		*/
      317 		return ("1"b);
      318 	     end;
      319 	return ("0"b);				/* otherwise, it is not the first outputable.	*/
      320 
      321 	end first_outputable_node;
      322 
      323 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      324 
      325 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      326 
      327 
      328 new_page:	procedure;				/* on new_page_, write a footer and skip to next	*/
      329 						/* page.					*/
      330 	     if fcb.page_text_length + 4 > fcb.page_length then
      331 		return;				/* do _n_o_t_h_i_n_g if no room on page for footer.	*/
      332 	     added_NL = fcb.page_text_length - fcb.line_no;
      333 	     if added_NL > 0 then
      334 		call ioa_$ioa_switch_nnl (fcb.Piocb, "^v/", added_NL);
      335 						/* skip to first footing line.		*/
      336 	     call ioa_$ioa_switch_nnl (fcb.Piocb, "^2/^a", line);
      337 						/* write a line of underscores to divide output	*/
      338 						/* from footer.				*/
      339 
      340 						/* output the footing line.			*/
      341 	     if eop.multiple_names then		/* if the footing line can contain two names, then*/
      342 		if eop.Pfirst_name = eop.Plast_name then/* if both names are the same, use only the first.*/
      343 		     call ioa_$ioa_switch_nnl (fcb.Piocb, "^/^45a^5x^32a^40xPage ^5d^|",
      344 					 footing, eop.Pfirst_name -> name, fcb.page_no);
      345 		else do;				/* else do, use both names in the footing line.	*/
      346 		     Lfirst_name = min (32, 33 - verify (reverse (Pfirst_name -> name), " "));
      347 		     Llast_name = min (32, 33 - verify (reverse (Plast_name -> name), " "));
      348 		     call ioa_$ioa_switch_nnl (fcb.Piocb, "^/^45a^5x^68a^4xPage ^5d^|",
      349 			footing, substr (Pfirst_name -> name, 1, Lfirst_name) ||
      350 			" -- " || substr (Plast_name -> name, 1, Llast_name), fcb.page_no);
      351 		     eop.Pfirst_name = eop.Plast_name;	/* last node on this page is first on next page.	*/
      352 		     end;
      353 	     else					/* else, output the name of the current node.	*/
      354 		call ioa_$ioa_switch_nnl (fcb.Piocb, "^/^45a^5x^32a^40xPage ^5d^|",
      355 			                footing, Pname -> name, fcb.page_no);
      356 	     fcb.page_no = fcb.page_no + 1;		/* increment page number.			*/
      357 	     fcb.line_no = 1;			/* set number of lines on this new page.	*/
      358 
      359 	end;
      360 
      361 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      362 
      363 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      364 
      365 
      366 output_index:	procedure;			/* Internal procedure to output an index of the	*/
      367 						/* node which were printed.			*/
      368 
      369      dcl	1 line (2:fcb.page_text_length) unaligned,	/* allocate the index page in the stack.	*/
      370 	 (2 column (3)		char(40),		/* page is divide into 3 columns of 40-chars.	*/
      371 	  2 new_line		char(1));
      372      dcl	column_ent		char(40) varying aligned;
      373 						/* bug bypass variable.			*/
      374 
      375 	do i = lbound(line,1) to hbound(line,1);	/* initialize new_line char at end of each line	*/
      376 	     line(i).new_line = NL;			/* of the index page.			*/
      377 	     end;
      378 	j = 1;					/* number of the current column.		*/
      379 	Pname = addr (INDEX);			/* use the word "INDEX" in footers of index pages.*/
      380 	if fcb.line_no ^= 1 then call new_page();	/* start index on a new page.			*/
      381 
      382 	do i = 1 to index_list.I;			/* scan thru the list of names to be in index.	*/
      383 	     Pindex_entry = name_list.e (index_list.e(i));/* address the ith name in the sorted list.	*/
      384 	     if Pindex_entry = addr (NULL_NAME) then;	/* skip names being excluded from the index.	*/
      385 	     else do;
      386 		fcb.line_no = fcb.line_no + 1;	/* add the ith name/page-no to next line.	*/
      387 		if fcb.line_no > hbound(line,1) then	/* if name/page-no won't fit in this column:	*/
      388 		     if j < 3 then do;		/* then put it in next column, if there is one.	*/
      389 			j = j + 1;
      390 			fcb.line_no = lbound(line,1);
      391 			end;
      392 		     else do;			/* if no more columns exist, then:		*/
      393 			call iox_$put_chars (fcb.Piocb, addr(line), length(string(line)), code);
      394 						/* output this index page.			*/
      395 			call new_page();		/* skip to a new page of the index.		*/
      396 			j = 1;			/* start with column 1, line 1 of this page.	*/
      397 			end;
      398 		Lname = min (32, 33 - verify (reverse (Pindex_entry -> name), " "));
      399 						/* compute length of ith name in sorted list.	*/
      400 		Lname = Lname + mod (Lname, 2);	/* make the length even.			*/
      401 		page = page_list.e (index_list.e(i));	/* convert page number to a character string.	*/
      402 		column_ent = substr(Pindex_entry -> name, 1, Lname) || substr(DOTS, 1, 32-Lname) || page;
      403 		line(fcb.line_no).column(j) = column_ent;
      404 		     				/* fill in the entry of the index.		*/
      405 		end;
      406 	     end;
      407 	do j = j to 3;				/* blank out unused entries on this index page.	*/
      408 	     do fcb.line_no = fcb.line_no + 1 to hbound(line,1);
      409 		line(fcb.line_no).column(j) = "";
      410 		end;
      411 	     fcb.line_no = lbound(line,1) - 1;
      412 	     end;
      413 	fcb.line_no = hbound(line,1);			/* set proper count of lines on this page.	*/
      414 	call iox_$put_chars (fcb.Piocb, addr(line), length(string(line)), code);
      415 	call new_page();				/* output the final page of the index.		*/
      416 
      417 	end output_index;
      418 
      419 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      420 
      421 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      422 
      423 
      424 output_node:	procedure	(Pnode_);			/* This internal procedure outputs the contents	*/
      425 						/* of the entry represented by a node.		*/
      426 
      427      dcl	Pnode_			ptr;		/* ptr to the node to be output.		*/
      428 
      429      dcl	length			builtin,		/* avoid name conflict.			*/
      430 	msg			char(200) varying,	/* special message to be output.		*/
      431 	msf_comp_no		fixed bin(24),	/* an MSF component number.			*/
      432 						/* a node or node-component.			*/
      433 	1 node_			aligned based (Pnode_) like node;
      434 						/* a node.				*/
      435 
      436 
      437 test_node:
      438 	if node_.T = Tsegment then do;		/* if the node is a segment, then		*/
      439 seg:	     call lib_ptr_and_bc_ (Pnode_, 0, Pnode_, Pchars, Nchars, code);
      440 	     if Pchars = null then			/* initiate the segment.			*/
      441 		go to error;
      442 segment_target:					/* compute how many chars in non-pt segment.	*/
      443 	     Nchars = divide (Nchars, 9, 24, 0);
      444 	     POD.Spartial_last_page = "0"b;
      445 	     call lib_paged_output_ (addr(chars), length(chars), PPOD, code);
      446 	     call hcs_$terminate_noname (Pchars, code);	/* terminate the segment.			*/
      447 	     end;					/* simple, wasn't it.			*/
      448 
      449 	else if node_.T = Tlink then do;		/* get link target, and process that.		*/
      450 	     msf_comp_no = 0;
      451 	     call lib_ptr_and_bc_ (Pnode_, msf_comp_no, Pnode_, Pchars, Nchars, code);
      452 	     if Pchars = null then go to error;
      453 	     if node_.T = Tsegment then go to segment_target;
      454 	     if node_.T = Tarchive then go to archive_target;
      455 	     if node_.T = Tarchive_comp then go to archive_target;
      456 	     if node_.T = Tmsf_comp then do;
      457 		Pnode_ = node_.Pparent;
      458 		go to msf_target;
      459 		end;
      460 	     go to error;
      461 	     end;
      462 
      463 	else if node_.T = Tdirectory then do;
      464 	     msg = "lib_output_node_list_$print:  The contents of a directory cannot be printed.";
      465 	     POD.Spartial_last_page = "0"b;
      466 	     call lib_paged_output_ (addr(substr(msg,1)), length(msg), PPOD, code);
      467 	     end;
      468 
      469 	else if node_.T = Tarchive_comp then		/* if the node is an archive component, treat	*/
      470 	     go to arch;				/* it like an archive.			*/
      471 
      472 	else if node_.T = Tarchive then do;		/* if the node is an archive then,		*/
      473 arch:	     call lib_ptr_and_bc_ (Pnode_, 0, null, Pchars, Nchars, code);
      474 	     if Pchars = null then
      475 		go to error;
      476 archive_target:
      477 	     Nchars = divide (Nchars, 9, 24, 0);	/* convert bit count into a character count.	*/
      478 	     POD.Spartial_last_page = "0"b;
      479 	     call lib_paged_output_ (addr(chars), length(chars), PPOD, code);
      480 	     call hcs_$terminate_noname (Pchars, code);	/* terminate the archive.			*/
      481 	     Pchars = null;
      482 	     end;
      483 
      484 	else if node_.T = Tmsf then do;		/* if the node is an MSF, then		*/
      485 	     msf_comp_no = 0;
      486 	     POD.Imsf_comp = msf_comp_no;
      487 	     call lib_ptr_and_bc_ (Pnode_, msf_comp_no, null, Pchars, Nchars, code);
      488 	     if Pchars = null then go to error;
      489 msf_target:    Nchars = divide (Nchars, 9, 24, 0);
      490 	     call lib_paged_output_ (addr(chars), length(chars), PPOD, code);
      491 	     do while (msf_comp_no < node_.bit_count);
      492 		call hcs_$terminate_noname (Pchars, code);
      493 		Pchars = null;
      494 		POD.Imsf_comp = msf_comp_no;		/* msf_comp_no is no of NEXT MSF component.	*/
      495 		call lib_ptr_and_bc_ (Pnode_, msf_comp_no, null, Pchars, Nchars, code);
      496 		if Pchars = null then go to error;
      497 		Nchars = divide (Nchars, 9, 24, 0);
      498 		call lib_paged_output_ (addr(chars), length(chars), PPOD, code);
      499 		end;
      500 	     POD.Spartial_last_page = "0"b;
      501 	     call lib_paged_output_ (addr(chars), 0, PPOD, code);
      502 						/* output footer after last component.		*/
      503 	     call hcs_$terminate_noname (Pchars, code);
      504 	     Pchars = null;
      505 	     end;
      506 
      507 	else if node_.T = Tmsf_comp then		/* treat an MSF component to be output alone as	*/
      508 	     go to seg;				/* a segment.				*/
      509 
      510 	POD.Spartial_last_page = "1"b;		/* prepare POD for next node.			*/
      511 	POD.Imsf_comp = -1;
      512 	return;
      513 
      514 error:	call convert_status_code_ (code, short, long);	/* convert error code to a string.		*/
      515 	msg = "lib_output_node_list_$print:  " || long;
      516 	POD.Spartial_last_page = "0"b;
      517 	call lib_paged_output_ (addr(substr(msg,1)), length(msg), PPOD, code);
      518 	POD.Spartial_last_page = "1"b;
      519 	POD.Imsf_comp = -1;
      520 						/* output the error message.			*/
      521 
      522 	end output_node;
      523 
      524 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      525 
      526 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      527 
      528 
      529 output_nodes_kids:	procedure (P, level);		/* Internal procedure to output the outputable	*/
      530 						/* kid nodes of a given node.			*/
      531 
      532      dcl	P			ptr,		/* ptr to node whose kids are to be printed. (In)	*/
      533 	level			fixed bin(35);	/* level at which they are to be put in map.(In)	*/
      534 
      535      dcl	PDnodes_			ptr,		/* ptr to kid's node array descriptor.		*/
      536 	Pnode_			ptr,		/* ptr to a kid node.			*/
      537 	i			fixed bin;	/* a do-group index.			*/
      538 
      539      dcl	1 Dnodes_			aligned based (PDnodes_),
      540 						/* kid's node array descriptor.		*/
      541 	  2 header		like Dnodes.header,
      542 	  2 nodes (Nnodes refer (Dnodes_.N))
      543 				like node,
      544 
      545 	1 Svalid			aligned based (addr (node_.Svalid)) like Svalid_req,
      546 						/* switches telling which kid node fields are OK.	*/
      547 	1 node_			aligned based (Pnode_) like node;
      548 						/* a kid node.				*/
      549 
      550 	do PDnodes_ = P->node_.PD repeat Dnodes_.Pnext while (Dnodes_.header.T ^= Tnodes);
      551 	     end;					/* address the node array descriptor of the kids.	*/
      552 	do i = 1 to Dnodes_.N;			/* scan through node array.			*/
      553 	     Pnode_ = addr (Dnodes_.nodes(i));		/* access the ith node of the array.		*/
      554 	     if e = 1 then
      555 		call lib_output_node_$info (Pfcb, Pnode_, Srequirements, level, Pstarname);
      556 	     else if e = 2 then
      557 		call lib_output_node_$map (Pfcb, Pnode_, Srequirements, level, Pstarname);
      558 	     else if e = 3 then do;
      559 		call lib_output_node_$print (Pfcb, Pnode_, Srequirements, level, Pstarname);
      560 		end;
      561 	     if Svalid.kids then			/* look for kid's kids to print, if any.	*/
      562 		call output_nodes_kids (Pnode_, level + 1);
      563 	     end;
      564 
      565 	end output_nodes_kids;
      566 
      567 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      568 
      569 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      570 
      571 
      572 print_footer: procedure (Ipage);			/* Internal procedure to print footing line	*/
      573 						/*   for lib_output_node_list_$print at end of	*/
      574 						/*   page (detected by lib_paged_output_).	*/
      575 
      576      dcl	Ipage			fixed bin;	/* current page number.			*/
      577 
      578 	call ioa_$ioa_switch_nnl (fcb.Piocb, "^2/^a", line);
      579 						/* write a line of underscores to divide output	*/
      580 						/* from footer.				*/
      581 	call ioa_$ioa_switch_nnl (fcb.Piocb, "^/^45a^5x^32a^40xPage ^5d^|",
      582 			                footing, Pname -> name, Ipage);
      583 						/* print footing line containing name of node.	*/
      584 	fcb.page_no = Ipage;			/* increment page number.			*/
      585 	fcb.line_no = 1;				/* set number of lines on this new page.	*/
      586 
      587 	end print_footer;
      588 
      589 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      590 
  1     1 /* START OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3      dcl	1 fcb			based (Pfcb),	/* file control block for our output file.	*/
  1     4 	  2 version		fixed bin,	/*    version number = 1;			*/
  1     5 	  2 ioname		char(32),		/*    ioname of our I/O control block.		*/
  1     6 	  2 Piocb			ptr,		/*    ptr to our I/O control block.		*/
  1     7 	  2 Eend_page		entry variable,	/*    entry which handles endpage condition.	*/
  1     8 	  2 page_length		fixed bin,	/*    number of lines per page.		*/
  1     9 	  2 page_text_length	fixed bin,	/*    number of usable lines per page, excluding	*/
  1    10 						/*       footer lines generated by end-of-page	*/
  1    11 						/*       handler.				*/
  1    12 	  2 page_no		fixed bin,	/*    current page number.			*/
  1    13 	  2 line_length		fixed bin,	/*    number of characters per line.		*/
  1    14 	  2 line_no		fixed bin;	/*    number of lines on current page.		*/
  1    15      dcl	Pfcb			ptr;		/* ptr to file control block.			*/
  1    16      dcl	Vfcb_1			fixed bin int static options(constant) init (1);
  1    17 
  1    18 /* END OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      591 
      592 
  2     1 /*	START OF:	paged_output_data_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3      dcl	1 POD			aligned based (PPOD),
  2     4 						/* data used by paged_output_ subroutine.	*/
  2     5 	  2 version		fixed bin,	/* version number of this structure. (= 1)	*/
  2     6 	  2 Lline			fixed bin,	/* max length of output lines.		*/
  2     7 	  2 Lpage			fixed bin,	/* lines per page.				*/
  2     8 	  2 Ltop_margin		fixed bin,	/* lines skipped for top margin.		*/
  2     9 	  2 Lbottom_margin		fixed bin,	/* lines skipped for bottom margin.		*/
  2    10 	  2 Nfrom			fixed bin,	/* number of first page printed.		*/
  2    11 	  2 Nto			fixed bin,	/* number of last page printed.		*/
  2    12 						/*     = 0  ==> no upper limit on last page.	*/
  2    13 	  2 switch		ptr,		/* ptr to IOCB for output switch.		*/
  2    14 	  2 end_page		entry (fixed bin),	/* endpage condition handler.			*/
  2    15 	  2 switches,
  2    16 	   (3 Send_page		bit(1),		/* on if endpage procedure to be called.	*/
  2    17 	    3 Spartial_last_page	bit(1),		/* on if last page need not be full.		*/
  2    18 						/*   (Turn on for all but last component segment	*/
  2    19 						/*    of an MSF.)				*/
  2    20 	    3 Sheader		bit(1),		/* on if heading to be printed before 1st page	*/
  2    21 						/*   of each file is output.			*/
  2    22 						/*   Heading contains pathname of file being 	*/
  2    23 						/*   printed.  It is not printed if output begins	*/
  2    24 						/*   with other than first page of the file.	*/
  2    25 	    3 pad			bit(33)) unal,
  2    26 	  2 Iat_column		fixed bin,	/* current column position of current line.	*/
  2    27 	  2 Icolumns_used		fixed bin,	/* number of columns used on current line.	*/
  2    28 	  2 Iline			fixed bin,	/* number of lines already on current page.	*/
  2    29 	  2 Ipage			fixed bin,	/* page number of the current page.		*/
  2    30 	  2 Imsf_comp		fixed bin,	/* number of MSF component being output.	*/
  2    31 						/*   = -1, a segment file is being output.	*/
  2    32 						/*   =  0, 1st component of MSF being output.	*/
  2    33 						/*   =  N, N+1st component of MSF being output.	*/
  2    34 	  2 heading		char(200) varying,	/* the heading line(s).			*/
  2    35 	PPOD			ptr,		/* ptr to this data structure.		*/
  2    36 	VPOD_1			fixed bin int static init (1) options(constant);
  2    37 
  2    38 /*	END OF:	paged_output_data_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      593 
      594 
  3     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines structures for the arrays of library names and search*/
  3     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  3     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  3    10 	/* to the lib_descriptor_ subroutine.						*/
  3    11 	/*									*/
  3    12 	/* S__t_a_t_u_s									*/
  3    13 	/*									*/
  3    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  3    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  3    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  3    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  3    18 	/*									*/
  3    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    20 
  3    21 
  3    22      dcl	1 library			aligned based (Plibrary),
  3    23 						/* a structure containing names of libraries to	*/
  3    24 						/*   be searched.				*/
  3    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  3    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  3    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  3    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  3    30 						/*     this library name.			*/
  3    31 
  3    32      dcl	1 starname		aligned based (Pstarname),
  3    33 						/* a structure containing names of library entries*/
  3    34 						/*   being searched for.			*/
  3    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  3    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  3    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  3    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    39 						/*     this starname.			*/
  3    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  3    41 
  3    42      dcl	1 exclude			aligned based (Pexclude),
  3    43 						/* a structure containing names of library entries*/
  3    44 						/*   being excluded from the search.		*/
  3    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  3    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  3    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  3    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    49 						/*     this exclude.			*/
  3    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  3    51 
  3    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      595 
      596 
  4     1 /* START OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* Name:  lib_list_.incl.pl1							*/
  4     6 	/*									*/
  4     7 	/*      This segment declares the list structures which are used by the library 	*/
  4     8 	/* maintenance tools.  The structures are filled in by lib_sort_tree_, and referenced by	*/
  4     9 	/* lib_output_node_list_, having been allocated originally by one of the maintenance	*/
  4    10 	/* commands (library_map, library_info, library_print, etc).			*/
  4    11 	/*									*/
  4    12 	/* Status									*/
  4    13 	/*									*/
  4    14 	/* 0) Created on:  May 30, 1976  by  G. C. Dixon					*/
  4    15 	/*									*/
  4    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    17 
  4    18 
  4    19      dcl	1 index_list		aligned based (Pindex_list),
  4    20 						/* an index list.				*/
  4    21 	  2 N			fixed bin(24),	/* max length of list.			*/
  4    22 	  2 I			fixed bin(24),	/* current length of list.			*/
  4    23 	  2 e (max_entries refer (index_list.N))
  4    24 				fixed bin(24),	/* the list.				*/
  4    25 	1 name_list		aligned based (Pname_list),
  4    26 						/* a name list.				*/
  4    27 	  2 N			fixed bin(24),	/* max length of list.			*/
  4    28 	  2 I			fixed bin(24),	/* current length of list.			*/
  4    29 	  2 e (max_entries refer (name_list.N))	ptr unal,	/* list of ptrs to node names.		*/
  4    30 	1 node_list		aligned based (Pnode_list),
  4    31 						/* a list of ptrs to nodes to be output.	*/
  4    32 	  2 N			fixed bin(24),	/* max length of list.			*/
  4    33 	  2 I			fixed bin(24),	/* current length of list.			*/
  4    34 	  2 e (max_entries refer (node_list.N))	ptr unal,	/* list of ptrs to nodes.			*/
  4    35 	1 page_list		aligned based (Ppage_list),
  4    36 						/* list of page numbers on which each node was	*/
  4    37 						/* output.				*/
  4    38 	  2 N			fixed bin(24),	/* max length of list.			*/
  4    39 	  2 I			fixed bin(24),	/* current length of list.			*/
  4    40 	  2 e (max_entries refer (page_list.N))	
  4    41 				fixed bin(24),	/* list of page numbers.			*/
  4    42 	max_entries		fixed bin int static init (32000),
  4    43 	Pindex_list		ptr,		/* ptr to index_list structure.		*/
  4    44 	Pname_list		ptr,		/* ptr to name_list structure.		*/
  4    45 	Pnode_list		ptr,		/* ptr to node_list structure.		*/
  4    46 	Ppage_list		ptr;		/* ptr to page_list structure.		*/
  4    47 
  4    48 /* END OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      597 
      598 
  5     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  5     6 	/*									*/
  5     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  5     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  5     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  5    10 	/* called the node target.							*/
  5    11 	/*									*/
  5    12 	/* S__t_a_t_u_s									*/
  5    13 	/*									*/
  5    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  5    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  5    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  5    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  5    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  5    19 	/*									*/
  5    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    21 
  5    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    23 	/*									*/
  5    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  5    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  5    26 	/* both types of nodes are the same length.					*/
  5    27 	/*									*/
  5    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    29 
  5    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  5    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  5    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  5    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  5    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  5    35 						/*             (= node.Svalid & Srequirements)	*/
  5    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  5    37 	  2 switches		unaligned,
  5    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  5    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  5    40 						/* 	     entry before lib_access_mode_$set.	*/
  5    41 	    3 pad			bit(22),
  5    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  5    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  5    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  5    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  5    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  5    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  5    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  5    49 						/*	     in this directory;  if off, records*/
  5    50 						/*	     charged against 1st superior	*/
  5    51 						/*	     directory with switch on.	*/
  5    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  5    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  5    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  5    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  5    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  5    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  5    58 
  5    59 						/* From here on, link_nodes differ from nodes	*/
  5    60 						/*  for other types of node targets.		*/
  5    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  5    62 
  5    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    64 	/*									*/
  5    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  5    66 	/*									*/
  5    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    68 
  5    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  5    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  5    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  5    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  5    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  5    74 						/*             (= node.Svalid & Srequirements)	*/
  5    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  5    76 	  2 switches		unaligned,
  5    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  5    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  5    79 						/* 	     entry before lib_access_mode_$set.	*/
  5    80 	    3 pad			bit(22),
  5    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  5    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  5    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  5    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  5    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  5    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  5    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  5    88 						/*	     in this directory;  if off, records*/
  5    89 						/*	     charged against 1st superior	*/
  5    90 						/*	     directory with switch on.	*/
  5    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  5    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  5    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  5    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  5    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  5    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  5    97 
  5    98 						/* From here on, other nodes differ from	*/
  5    99 						/*  link_nodes.				*/
  5   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  5   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  5   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  5   103 	  2 pad1 (1)		fixed bin,
  5   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  5   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  5   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  5   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  5   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  5   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  5   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  5   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  5   112 						/*             component from the base of archive.*/
  5   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  5   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  5   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  5   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  5   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  5   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  5   119 						/*	     updated.			*/
  5   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  5   121 						/*	     directories with Sterminal_account	*/
  5   122 						/*	     on.				*/
  5   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  5   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  5   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  5   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  5   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  5   128 						/*	     updated.			*/
  5   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  5   130 						/*	     directories with Sterminal_account	*/
  5   131 						/*	     on.				*/
  5   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  5   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  5   134 	  2 pad2 (5)		fixed bin,
  5   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  5   136 
  5   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5   138 	/*									*/
  5   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  5   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  5   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  5   142 	/* descriptors are the only ones that have been defined.				*/
  5   143 	/*									*/
  5   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5   145 
  5   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  5   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  5   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  5   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  5   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  5   152 
  5   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  5   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  5   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  5   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  5   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  5   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  5   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  5   163 	    3 zero_pad		bit(36),
  5   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  5   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  5   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  5   167 	Vacl_1			fixed bin int static options(constant) init (1),
  5   168 						/* version:   version of ACL descriptor.	*/
  5   169 	Tacl			fixed bin int static options(constant) init (7);
  5   170 						/* attribute: type of a segment ACL descriptor.	*/
  5   171 
  5   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  5   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  5   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  5   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  5   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  5   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  5   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  5   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  5   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  5   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  5   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  5   186 						/* version:   version of directory ACL descriptor.*/
  5   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  5   188 						/* attribute: type of a directory ACL descriptor.	*/
  5   189 
  5   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  5   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  5   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  5   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  5   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  5   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  5   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  5   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  5   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  5   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  5   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  5   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  5   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  5   206 						/* version:   version of dir IACL descriptor.	*/
  5   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  5   208 
  5   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  5   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  5   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  5   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  5   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  5   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  5   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  5   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  5   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  5   221 	    3 zero_pad		bit(36),
  5   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  5   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  5   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  5   225 	Viacl_1			fixed bin int static options(constant) init (1),
  5   226 						/* version:   version of segment IACL descriptor.	*/
  5   227 	Tiacl			fixed bin int static options(constant) init (10);
  5   228 						/* attribute: type of a segment IACL descriptor.	*/
  5   229 
  5   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  5   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  5   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  5   236 	  2 names (Nnames refer (Dnames.N))
  5   237 				char(32),		/* attribute: names.			*/
  5   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  5   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  5   240 	Vnames_1			fixed bin int static options(constant) init (1),
  5   241 						/* version:   version of names descriptor.	*/
  5   242 	Tnames			fixed bin int static options(constant) init (1);
  5   243 						/* attribute: type of a name descriptor.	*/
  5   244 
  5   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  5   246 						/* nodes.					*/
  5   247 	  2 header,
  5   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  5   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  5   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  5   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  5   255 				like node,
  5   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  5   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  5   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  5   259 						/* version:   version of nodes descriptor.	*/
  5   260 	Tnodes			fixed bin int static options(constant) init (2);
  5   261 						/* attribute: type of a node descriptor.	*/
  5   262 
  5   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  5   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  5   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   268 	  2 info,
  5   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  5   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  5   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  5   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  5   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  5   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  5   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  5   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  5   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  5   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  5   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  5   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  5   281 	    3 format		aligned,
  5   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  5   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  5   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  5   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  5   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  5   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  5   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  5   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  5   290 	      4 pad		bit(28) unal,
  5   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  5   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  5   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  5   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  5   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  5   296 	    3 cversion,				/* attribite: compiler version string.		*/
  5   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  5   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  5   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  5   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  5   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  5   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  5   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  5   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  5   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  5   306 	Vobj_1			fixed bin int static options(constant) init (1),
  5   307 						/* version:   version of object_info_ descriptor.	*/
  5   308 	Tobj			fixed bin int static options(constant) init (3);
  5   309 						/* attribute: type of a node descriptor.	*/
  5   310 
  5   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  5   312 						/* library root search_proc attribute descriptor.	*/
  5   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  5   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  5   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  5   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  5   320 						/* version:   version of search_proc info descrip.*/
  5   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  5   322 						/* attribute: type of a search_proc descriptor.	*/
  5   323 
  5   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  5   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  5   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  5   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  5   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  5   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  5   330 						/*            output.			*/
  5   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  5   332 	  2 info			char(Luser refer (Duser.L)),
  5   333 						/* attribute: user info string.		*/
  5   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  5   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  5   336 	Vuser_1			fixed bin int static options(constant) init (1),
  5   337 						/* version:   version of user info descriptor.	*/
  5   338 	Tuser			fixed bin int static options(constant) init (6);
  5   339 						/* attribute: type of a user descriptor.	*/
  5   340 
  6     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 	/*									*/
  6     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  6     6 	/*									*/
  6     7 	/*      This include segment defines the switches which request/validate the fields	*/
  6     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  6     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  6    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  6    11 	/* descriptor commands to obtain information about entries in a library.		*/
  6    12 	/*									*/
  6    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  6    14 	/* is requested for output.							*/
  6    15 	/*									*/
  6    16 	/* S__t_a_t_u_s									*/
  6    17 	/*									*/
  6    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  6    19 	/*									*/
  6    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    21 
  6    22 
  6    23      dcl	1 Svalid_req		aligned based,
  6    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  6    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  6    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  6    27 
  6    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  6    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  6    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  6    31 
  6    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  6    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  6    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  6    35 
  6    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  6    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  6    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  6    39 
  6    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  6    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  6    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  6    43 
  6    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  6    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  6    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  6    47 
  6    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  6    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  6    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  6    51 
  6    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  6    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  6    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  6    55 
  6    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  6    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  6    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  6    59 
  6    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  6    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  6    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  6    63 
  6    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  6    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  6    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  6    67 
  6    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  6    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  6    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  6    71 
  6    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  6    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  6    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  6    75 
  6    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  6    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  6    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  6    79 	  2 pad			bit(26) unal,
  6    80 
  6    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  6    82 
  6    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  6    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  6    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  6    86 
  6    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    88 	/*									*/
  6    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  6    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  6    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  6    92 	/*									*/
  6    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    94 
  6    95 
  6    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  6    97 	Srequirements		bit(72) aligned;
  6    98 
  6    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5   341 
  5   342 
  5   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  5   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  5   345 
  7     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7     4 	/*									*/
  7     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  7     6 	/*									*/
  7     7 	/*      This include segment defines the control switches used by library descriptor	*/
  7     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  7     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  7    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  7    11 	/* to the lib_descriptor_ subroutine.						*/
  7    12 	/*									*/
  7    13 	/* S__t_a_t_u_s									*/
  7    14 	/*									*/
  7    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  7    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  7    17 	/*									*/
  7    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    19 
  7    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  7    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  7    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  7    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  7    24 
  7    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  7    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  7    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  7    28 						/*         nodes of the tree, and about all the	*/
  7    29 						/*	 nodes below the parent.		*/
  7    30 
  7    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  7    32 						/*         nodes of the tree.			*/
  7    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  7    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  7    35 
  7    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  7    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  7    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  7    39 						/*         deletion.			*/
  7    40 
  7    41 	  2 pad			bit(10) unal,
  7    42 
  7    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  7    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  7    45 
  7    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  7    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  7    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  7    49 
  7    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  7    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  7    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  7    53 
  7    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  7    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  7    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  7    57 
  7    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  7    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  7    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  7    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  7    62 
  7    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5   346 
  5   347 
  5   348 
  5   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5   350 	/*									*/
  5   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  5   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  5   353 	/* that:		mod (type, 2) = 1;						*/
  5   354 	/*									*/
  5   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5   356 
  5   357 
  5   358      dcl (Tlink			init (0),
  5   359 	Tsegment			init (1),
  5   360 	Tdirectory		init (2),
  5   361 	Tmsf			init (3),
  5   362 	Tmsf_comp			init (4),
  5   363 	Tarchive			init (5),
  5   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  5   365 
  5   366 
  5   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5   368 	/*									*/
  5   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  5   370 	/* Both brief and long string arrays are provided.				*/
  5   371 	/*									*/
  5   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5   373 
  5   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  5   375 				"link",
  5   376 				"segment",
  5   377 				"directory",
  5   378 				"multisegment file",
  5   379 				"multi-segment file component",
  5   380 				"archive",
  5   381 				"archive component"),
  5   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  5   383 				"link",
  5   384 				"segment",
  5   385 				"directory",
  5   386 				"msf",
  5   387 				"msf comp",
  5   388 				"archive",
  5   389 				"arch comp");
  5   390 
  5   391 
  5   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      599 
      600 
      601 
      602 	end lib_output_node_list_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/22/86  1444.4  lib_output_node_list_.pl1         >spec>install>1042>lib_output_node_list_.pl1
591          1    01/05/79  1321.1  lib_fcb_.incl.pl1                 >ldd>include>lib_fcb_.incl.pl1
593          2    02/28/77  1409.2  lib_paged_output_data_.incl.pl1   >ldd>include>lib_paged_output_data_.incl.pl1
595          3    02/16/84  0928.6  lib_based_args_.incl.pl1          >ldd>include>lib_based_args_.incl.pl1
597          4    02/28/77  1409.2  lib_list_.incl.pl1                >ldd>include>lib_list_.incl.pl1
599          5    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
5-341        6    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
5-346        7    02/16/84  0928.6  lib_Scontrol_.incl.pl1            >ldd>include>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ASrequirements                         parameter       bit(72)                  dcl 23 set ref 103 110 129 147 164* 190* 201* 267*
                                                                                  270*
DOTS                            000003 constant        char(40)                 initial dcl 83 ref 402
Dnames                                 based           structure                level 1 unaligned dcl 5-230
Dnodes                                 based           structure                level 1 unaligned dcl 5-245
Dnodes_                                based           structure                level 1 dcl 539
Eend_page                14            based           entry variable           level 2 dcl 1-3 set ref 144 145* 211*
I                         1            based           fixed bin(24,0)          level 2 in structure "page_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" set ref 238*
I                         1            based           fixed bin(24,0)          level 2 in structure "name_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" set ref 237*
                                                                                  280* 282 282
I                         1            based           fixed bin(24,0)          level 2 in structure "index_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" set ref 157
                                                                                  178 249 281* 282 282 382
I                         1            based           fixed bin(24,0)          level 2 in structure "node_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" set ref 239
                                                                                  256 257* 257 258 259 260 280 281
INDEX                           000010 internal static char(32)                 initial dcl 83 set ref 379
Iat_column               17            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 230*
Icolumns_used            20            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 231*
Iline                    21            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 232* 264 272* 277
Imsf_comp                23            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 234* 486* 494* 511* 519*
Ipage                                  parameter       fixed bin(17,0)          dcl 576 in procedure "print_footer" set ref 572 581*
                                                                                  584
Ipage                    22            based           fixed bin(17,0)          level 2 in structure "POD" dcl 2-3 in procedure
                                                                                  "lib_output_node_list_" set ref 233* 252 260 265
                                                                                  273* 278
Lbottom_margin            4            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 222*
Lfirst_name                     000100 automatic       fixed bin(35,0)          dcl 29 set ref 346* 348
Llast_name                      000101 automatic       fixed bin(35,0)          dcl 29 set ref 347* 348
Lline                     1            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 219*
Lname                           000102 automatic       fixed bin(35,0)          dcl 29 set ref 398* 400* 400 400 402 402
Lpage                     2            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 220*
Ltop_margin               3            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 221*
N                         5            based           fixed bin(17,0)          level 3 in structure "Dnodes_" dcl 539 in procedure
                                                                                  "output_nodes_kids" ref 552
N                                      based           fixed bin(24,0)          level 2 in structure "name_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" ref 237
N                         4            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 5-230 in procedure
                                                                                  "lib_output_node_list_" ref 256
N                                      based           fixed bin(24,0)          level 2 in structure "node_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" ref 256
N                                      based           fixed bin(24,0)          level 2 in structure "page_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" ref 238
NL                                     constant        char(1)                  initial dcl 83 ref 376
NULL_NAME                       000020 internal static char(32)                 initial unaligned dcl 83 set ref 155 384
Nchars                          000103 automatic       fixed bin(24,0)          dcl 29 set ref 439* 442* 442 445 445 445 445 451*
                                                                                  473* 476* 476 479 479 479 479 487* 489* 489 490
                                                                                  490 490 490 495* 497* 497 498 498 498 498 501 501
Nentries                        000104 automatic       fixed bin(17,0)          dcl 29 set ref 239* 279
Nfrom                     5            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 223*
Nto                       6            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 224*
P                                      parameter       pointer                  dcl 295 in procedure "first_outputable_node" ref 292
                                                                                  300 301 310 311 314
P                                      parameter       pointer                  dcl 532 in procedure "output_nodes_kids" ref 529 550
PD                        2            based           pointer                  level 2 in structure "node" dcl 5-69 in procedure
                                                                                  "lib_output_node_list_" ref 254 314
PD                        2            based           pointer                  level 2 in structure "node_" dcl 539 in procedure
                                                                                  "output_nodes_kids" ref 550
PDnames                         000402 automatic       pointer                  dcl 5-230 set ref 254* 254* 255 256 259 314* 314*
                                                                                  315 316
PDnodes_                        000100 automatic       pointer                  dcl 535 set ref 550* 550* 551 552 553
POD                                    based           structure                level 1 dcl 2-3
POD_storage                     000106 automatic       structure                level 1 dcl 29 set ref 217
PPOD                            000376 automatic       pointer                  dcl 2-3 set ref 217* 218 219 220 221 222 223 224 225
                                                                                  226 227 228 229 230 231 232 233 234 235 252 260
                                                                                  263* 264 265 272 273 274* 277 278 444 445* 465
                                                                                  466* 478 479* 486 490* 494 498* 500 501* 510 511
                                                                                  516 517* 518 519
Pchars                          000216 automatic       pointer                  dcl 29 set ref 241* 243 244* 245* 439* 440 445 445
                                                                                  445 445 446* 451* 452 473* 474 479 479 479 479
                                                                                  480* 481* 487* 488 490 490 490 490 492* 493* 495*
                                                                                  496 498 498 498 498 501 501 503* 504*
Pfcb                                   parameter       pointer                  dcl 1-15 set ref 103 110 129 142 143 143 144 145
                                                                                  164* 169 181 181 190* 201* 210 211 219 220 225 232
                                                                                  233 264 265 267* 270* 272 273 277 278 330 330 332
                                                                                  332 333 336 341 341 348 348 353 353 356 356 357
                                                                                  369 380 386 386 387 390 393 403 408 408 409 411
                                                                                  413 414 554* 556* 559* 578 581 584 585
Pfirst                                 parameter       pointer                  dcl 295 set ref 292 309*
Pfirst_name                     000324 automatic       pointer                  level 2 dcl 29 set ref 155* 175* 183* 341 341 346
                                                                                  348 351*
Pindex_entry                    000220 automatic       pointer                  dcl 29 set ref 383* 384 398 402
Pindex_list                            parameter       pointer                  dcl 4-19 ref 103 110 129 157 158 160 175 178 179 180
                                                                                  249 250 251 252 281 282 282 382 383 401
Piocb                    12            based           pointer                  level 2 dcl 1-3 set ref 169* 225 333* 336* 341* 348*
                                                                                  353* 393* 414* 578* 581*
Plast_name                2     000324 automatic       pointer                  level 2 dcl 29 set ref 155* 185* 341 347 348 351
Pn                              000420 automatic       pointer                  dcl 295 set ref 300* 307* 309 310
Pname                           000222 automatic       pointer                  dcl 29 set ref 160* 180* 183 185 201 251* 316 353
                                                                                  379* 581
Pname_list                             parameter       pointer                  dcl 4-19 ref 103 110 129 160 175 180 237 237 251 259
                                                                                  280 282 282 383
Pnext                     2            based           pointer                  level 3 in structure "Dnodes_" dcl 539 in procedure
                                                                                  "output_nodes_kids" ref 551
Pnext                     2            based           pointer                  level 2 in structure "Dnames" dcl 5-230 in procedure
                                                                                  "lib_output_node_list_" ref 255 315
Pnode                           000400 automatic       pointer                  dcl 5-69 set ref 158* 159 161* 164* 165 165* 179*
                                                                                  187* 190* 191 191* 201* 250* 254 258 266 267* 268*
                                                                                  270* 275*
Pnode_                                 parameter       pointer                  dcl 427 in procedure "output_node" set ref 424 437
                                                                                  439* 439* 449 451* 451* 453 454 455 456 457* 457
                                                                                  463 469 472 473* 484 487* 491 495* 507
Pnode_                          000102 automatic       pointer                  dcl 535 in procedure "output_nodes_kids" set ref
                                                                                  553* 554* 556* 559* 561 561*
Pnode_list                             parameter       pointer                  dcl 4-19 ref 103 110 129 158 179 239 250 256 256 257
                                                                                  257 258 258 259 260 280 281
Pp                              000422 automatic       pointer                  dcl 295 set ref 301* 301* 304 307* 308
Ppage_list                             parameter       pointer                  dcl 4-19 ref 129 238 238 252 260 401
Pparent                                based           pointer                  level 2 in structure "node_" dcl 429 in procedure
                                                                                  "output_node" ref 457
Pparent                                based           pointer                  level 2 in structure "node" dcl 5-69 in procedure
                                                                                  "lib_output_node_list_" ref 301 308
Pstarname                              parameter       pointer                  dcl 3-40 set ref 103 110 129 164* 190* 267* 270*
                                                                                  554* 556* 559*
Ptarget                         000224 automatic       pointer                  dcl 29 set ref 161* 187* 197*
S                                      based           structure                level 1 dcl 6-96
Send_page                16            based           bit(1)                   level 3 packed unaligned dcl 2-3 set ref 228*
Spartial_last_page       16(01)        based           bit(1)                   level 3 packed unaligned dcl 2-3 set ref 229* 444*
                                                                                  465* 478* 500* 510* 516* 518*
Sreq                                   based           structure                level 1 dcl 5-343 in procedure
                                                                                  "lib_output_node_list_"
Sreq                      6            based           bit(72)                  level 2 in structure "node" dcl 5-69 in procedure
                                                                                  "lib_output_node_list_" set ref 304 311
Srequirements                   000404 automatic       bit(72)                  dcl 6-96 set ref 147* 148 554* 556* 559*
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 5-69 in procedure
                                                                                  "lib_output_node_list_" set ref 165 191 266
Svalid                                 based           structure                level 1 dcl 5-343 in procedure
                                                                                  "lib_output_node_list_"
Svalid                    4            based           bit(72)                  level 2 in structure "node_" dcl 539 in procedure
                                                                                  "output_nodes_kids" set ref 561
Svalid                                 based           structure                level 1 dcl 539 in procedure "output_nodes_kids"
Svalid_req                             based           structure                level 1 dcl 6-23
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 5-230 in procedure
                                                                                  "lib_output_node_list_" ref 254 314
T                         1            based           fixed bin(17,0)          level 3 in structure "Dnodes_" dcl 539 in procedure
                                                                                  "output_nodes_kids" ref 550
T                        10            based           fixed bin(35,0)          level 2 in structure "node_" dcl 429 in procedure
                                                                                  "output_node" ref 437 449 453 454 455 456 463 469
                                                                                  472 484 507
Tarchive                               constant        fixed bin(17,0)          initial dcl 5-358 ref 454 472
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 5-358 ref 455 469
Tdirectory                             constant        fixed bin(17,0)          initial dcl 5-358 ref 463
Tlink                                  constant        fixed bin(17,0)          initial dcl 5-358 ref 449
Tmsf                                   constant        fixed bin(17,0)          initial dcl 5-358 ref 484
Tmsf_comp                              constant        fixed bin(17,0)          initial dcl 5-358 ref 456 507
Tnames                                 constant        fixed bin(17,0)          initial dcl 5-230 ref 254 314
Tnodes                                 constant        fixed bin(17,0)          initial dcl 5-245 ref 550
Tsegment                               constant        fixed bin(17,0)          initial dcl 5-358 ref 437 453
VPOD_1                                 constant        fixed bin(17,0)          initial dcl 2-3 ref 218
added_NL                        000226 automatic       fixed bin(35,0)          dcl 29 set ref 332* 333 333*
addr                                                   builtin function         dcl 64 ref 148 155 165 191 217 259 263 263 266 274
                                                                                  274 282 282 282 282 311 316 379 384 393 393 414
                                                                                  414 445 445 466 466 479 479 490 490 498 498 501
                                                                                  501 517 517 553 561
bit_count                43            based           fixed bin(35,0)          level 2 dcl 429 ref 491
chars                                  based           char                     unaligned dcl 59 set ref 445 445 445 445 479 479 479
                                                                                  479 490 490 490 490 498 498 498 498 501 501
cleanup                         000230 stack reference condition                dcl 29 ref 242
code                            000236 automatic       fixed bin(35,0)          dcl 29 set ref 263* 274* 393* 414* 439* 445* 446*
                                                                                  451* 466* 473* 479* 480* 487* 490* 492* 495* 498*
                                                                                  501* 503* 514* 517*
column                          000100 automatic       char(40)                 array level 2 packed unaligned dcl 369 set ref 403*
                                                                                  409*
column_ent                      000100 automatic       varying char(40)         dcl 372 set ref 402* 403
convert_status_code_            000072 constant        entry                    external dcl 67 ref 514
cross_ref                 1(33)        based           bit(1)                   level 2 packed unaligned dcl 5-343 ref 311
dir                             000237 automatic       varying char(168)        dcl 29 set ref 197* 198 198* 198 200* 200 201*
divide                                                 builtin function         dcl 64 ref 442 476 489 497
e                               000312 automatic       fixed bin(17,0)          dcl 29 in procedure "lib_output_node_list_" set ref
                                                                                  105* 112* 131* 150 554 556 558
e                         2            based           pointer                  array level 2 in structure "name_list" packed
                                                                                  unaligned dcl 4-19 in procedure
                                                                                  "lib_output_node_list_" set ref 160 175 180 251
                                                                                  259* 383
e                         2            based           fixed bin(24,0)          array level 2 in structure "page_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" set ref 252*
                                                                                  260* 401
e                         2            based           fixed bin(24,0)          array level 2 in structure "index_list" dcl 4-19
                                                                                  in procedure "lib_output_node_list_" ref 158 160
                                                                                  175 179 180 250 251 252 383 401
e                         2            based           pointer                  array level 2 in structure "node_list" packed
                                                                                  unaligned dcl 4-19 in procedure
                                                                                  "lib_output_node_list_" set ref 158 179 250 258*
end_page                 12            based           entry variable           level 2 dcl 2-3 set ref 226*
ent                             000313 automatic       varying char(32)         dcl 29 set ref 197* 198 200
eop                             000324 automatic       structure                level 1 dcl 29
fcb                                    based           structure                level 1 unaligned dcl 1-3
footing                                parameter       varying char(45)         dcl 23 set ref 103 110 129 341* 348* 353* 581*
hbound                                                 builtin function         dcl 64 ref 375 387 408 413
hcs_$terminate_noname           000074 constant        entry                    external dcl 67 ref 244 446 480 492 503
header                                 based           structure                level 2 in structure "Dnodes" unaligned dcl 5-245
                                                                                  in procedure "lib_output_node_list_"
header                                 based           structure                level 2 in structure "Dnodes_" dcl 539 in procedure
                                                                                  "output_nodes_kids"
heading                  24            based           varying char(200)        level 2 dcl 2-3 set ref 235*
i                               000104 automatic       fixed bin(17,0)          dcl 535 in procedure "output_nodes_kids" set ref
                                                                                  552* 553*
i                               000331 automatic       fixed bin(17,0)          dcl 29 in procedure "lib_output_node_list_" set ref
                                                                                  157* 158 160* 178* 179 180* 249* 250 251 252* 375*
                                                                                  376* 382* 383 401*
index_list                             based           structure                level 1 dcl 4-19
ioa_$ioa_switch_nnl             000076 constant        entry                    external dcl 67 ref 169 333 336 341 348 353 578 581
iox_$put_chars                  000100 constant        entry                    external dcl 67 ref 393 414
j                               000332 automatic       fixed bin(17,0)          dcl 29 set ref 256* 259* 378* 387 389* 389 396* 403
                                                                                  407* 407* 409*
kids                      0(04)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 5-343 in procedure "lib_output_node_list_" ref
                                                                                  165 191 266
kids                      0(04)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 539 in procedure "output_nodes_kids" ref 561
lbound                                                 builtin function         dcl 64 ref 375 390 411
length                                                 builtin function         dcl 429 in procedure "output_node" ref 445 445 466
                                                                                  466 479 479 490 490 498 498 517 517
length                                                 builtin function         dcl 64 in procedure "lib_output_node_list_" ref 263
                                                                                  263 274 274 393 393 414 414
level                                  parameter       fixed bin(35,0)          dcl 532 set ref 529 554* 556* 559* 561
lib_node_path_                  000102 constant        entry                    external dcl 67 ref 197
lib_output_node_$cross_reference
                                000104 constant        entry                    external dcl 67 ref 201
lib_output_node_$info           000106 constant        entry                    external dcl 67 ref 164 554
lib_output_node_$map            000110 constant        entry                    external dcl 67 ref 190 556
lib_output_node_$print          000112 constant        entry                    external dcl 67 ref 267 270 559
lib_paged_output_               000114 constant        entry                    external dcl 67 ref 263 274 445 466 479 490 498 501
                                                                                  517
lib_ptr_and_bc_                 000116 constant        entry                    external dcl 67 ref 439 451 473 487 495
line                                   defined         char(132)                unaligned dcl 83 in procedure
                                                                                  "lib_output_node_list_" set ref 336* 578*
line                            000100 automatic       structure                array level 1 packed unaligned dcl 369 in procedure
                                                                                  "output_index" set ref 375 375 387 390 393 393 393
                                                                                  393 408 411 413 414 414 414 414
line_2NL                        000030 internal static char(134)                initial unaligned dcl 83 set ref 263 263 263 263 263
                                                                                  263 263 263 274 274 274 274 336 336 578 578
line_NL                                defined         char(133)                unaligned dcl 83 set ref 263 263 263 263
line_length              23            based           fixed bin(17,0)          level 2 dcl 1-3 ref 219
line_no                  24            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 181 232 264* 272 277* 332
                                                                                  357* 380 386* 386 387 390* 403 408* 408* 409* 411*
                                                                                  413* 585*
long                            000333 automatic       char(100)                dcl 29 set ref 514* 515
min                                                    builtin function         dcl 64 ref 346 347 398
mod                                                    builtin function         dcl 64 ref 400
msf_comp_no                     000515 automatic       fixed bin(24,0)          dcl 429 set ref 450* 451* 485* 486 487* 491 494 495*
msg                             000432 automatic       varying char(200)        dcl 429 set ref 464* 466 466 466 466 515* 517 517
                                                                                  517 517
multiple_names            4     000324 automatic       bit(1)                   level 2 dcl 29 set ref 106* 113* 132* 341
name                                   based           char(32)                 unaligned dcl 59 set ref 201* 341* 346 347 348 348
                                                                                  353* 398 402 581*
name_list                              based           structure                level 1 dcl 4-19
names                     5            based           char(32)                 array level 2 packed unaligned dcl 5-230 set ref 259
                                                                                  316
new_line                 36     000100 automatic       char(1)                  array level 2 in structure "line" packed unaligned
                                                                                  dcl 369 in procedure "output_index" set ref 376*
new_line                  1(35)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 6-96
                                                                                  in procedure "lib_output_node_list_" set ref 148*
node                                   based           structure                level 1 unaligned dcl 5-69
node_                                  based           structure                level 1 dcl 539 in procedure "output_nodes_kids"
node_                                  based           structure                level 1 dcl 429 in procedure "output_node"
node_list                              based           structure                level 1 dcl 4-19
nodes                     6            based           structure                array level 2 dcl 539 set ref 553
null                                                   builtin function         dcl 64 ref 159 241 243 245 301 440 452 473 473 474
                                                                                  481 487 487 488 493 495 495 496 504
page                            000364 automatic       picture(5)               unaligned dcl 29 set ref 401* 402
page_length              20            based           fixed bin(17,0)          level 2 dcl 1-3 ref 143 330
page_list                              based           structure                level 1 dcl 4-19
page_no                  22            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 233 265* 273 278* 341* 348*
                                                                                  353* 356* 356 584*
page_text_length         21            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 142 143* 181 210* 220 330
                                                                                  332 369
reverse                                                builtin function         dcl 64 ref 346 347 398
saved_Eend_page                 000366 automatic       entry variable           dcl 29 set ref 144* 211
saved_page_text_length          000372 automatic       fixed bin(17,0)          dcl 29 set ref 142* 210
short                           000374 automatic       char(8)                  dcl 29 set ref 514*
sort_items_indirect_$char       000120 constant        entry                    external dcl 67 ref 282
string                                                 builtin function         dcl 64 set ref 227* 393 393 414 414
substr                                                 builtin function         dcl 64 ref 348 348 402 402 466 466 517 517
switch                   10            based           pointer                  level 2 dcl 2-3 set ref 225*
switches                 16            based           structure                level 2 dcl 2-3 set ref 227*
verify                                                 builtin function         dcl 64 ref 346 347 398
version                                based           fixed bin(17,0)          level 2 dcl 2-3 set ref 218*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 5-146
Dacl                                   based           structure                level 1 unaligned dcl 5-153
Ddir_acl                               based           structure                level 1 unaligned dcl 5-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 5-190
Diacl                                  based           structure                level 1 unaligned dcl 5-209
Dobj                                   based           structure                level 1 unaligned dcl 5-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 5-311
Duser                                  based           structure                level 1 unaligned dcl 5-324
Luser                                  automatic       fixed bin(17,0)          dcl 5-324
Nacls                                  automatic       fixed bin(17,0)          dcl 5-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 5-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 5-190
Niacls                                 automatic       fixed bin(17,0)          dcl 5-209
Nnames                                 automatic       fixed bin(17,0)          dcl 5-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 5-245
PD                                     automatic       pointer                  dcl 5-146
PDacl                                  automatic       pointer                  dcl 5-153
PDdir_acl                              automatic       pointer                  dcl 5-172
PDdir_iacl                             automatic       pointer                  dcl 5-190
PDiacl                                 automatic       pointer                  dcl 5-209
PDnodes                                automatic       pointer                  dcl 5-245
PDobj                                  automatic       pointer                  dcl 5-263
PDsearch_proc                          automatic       pointer                  dcl 5-311
PDuser                                 automatic       pointer                  dcl 5-324
Pexclude                               automatic       pointer                  dcl 3-50
Plibrary                               automatic       pointer                  dcl 3-29
Sc                                     based           structure                level 1 dcl 7-20
Scontrol                               automatic       bit(36)                  dcl 7-20
Tacl                                   internal static fixed bin(17,0)          initial dcl 5-153
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 5-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 5-190
Tiacl                                  internal static fixed bin(17,0)          initial dcl 5-209
Tobj                                   internal static fixed bin(17,0)          initial dcl 5-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 5-311
Tuser                                  internal static fixed bin(17,0)          initial dcl 5-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 5-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 5-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 5-190
Vfcb_1                                 internal static fixed bin(17,0)          initial dcl 1-16
Viacl_1                                internal static fixed bin(17,0)          initial dcl 5-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 5-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 5-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 5-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 5-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 5-324
brief_node_type                        internal static varying char(12)         initial array dcl 5-374
exclude                                based           structure                level 1 dcl 3-42
library                                based           structure                level 1 dcl 3-22
link_node                              based           structure                level 1 unaligned dcl 5-30
max_entries                            internal static fixed bin(17,0)          initial dcl 4-19
node_type                              internal static varying char(32)         initial array dcl 5-374
starname                               based           structure                level 1 dcl 3-32

NAMES DECLARED BY EXPLICIT CONTEXT.
END_NODE                        000330 constant        label                    dcl 168 ref 159
arch                            002610 constant        label                    dcl 473 ref 469
archive_target                  002640 constant        label                    dcl 476 ref 454 455
begin                           000176 constant        label                    dcl 142 ref 107 114
entry                           000000 constant        label                    array(3) dcl 155 ref 150
error                           003131 constant        label                    dcl 514 set ref 440 452 460 474 488 496
first_outputable_node           001301 constant        entry                    internal dcl 292 ref 161 187
found                           001325 constant        label                    dcl 309 ref 304
info                            000132 constant        entry                    external dcl 103
lib_output_node_list_           000116 constant        entry                    external dcl 21
map                             000145 constant        entry                    external dcl 110
msf_target                      002737 constant        label                    dcl 489 ref 458
new_page                        001375 constant        entry                    internal dcl 328 ref 145 182 204 380 395 415
output_index                    001743 constant        entry                    internal dcl 366 ref 283
output_node                     002401 constant        entry                    internal dcl 424 ref 275
output_nodes_kids               003214 constant        entry                    internal dcl 529 ref 165 191 268 561
print                           000166 constant        entry                    external dcl 129
print_footer                    003374 constant        entry                    internal dcl 572 ref 226
return                          000616 constant        label                    dcl 210 ref 170 205 285
seg                             002410 constant        label                    dcl 439 ref 507
segment_target                  002437 constant        label                    dcl 442 ref 453
test_node                       002403 constant        label                    dcl 437

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3764        4106    3523        3774
Length      4474    3523       122         351     241          62

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_output_node_list_               386 external procedure  is an external procedure.  
on unit on line 242                  72 on unit               
first_outputable_node                   internal procedure  shares stack frame of external procedure lib_output_node_list_.  
new_page                            105 internal procedure  is assigned to an entry variable.  
output_index                        101 internal procedure  uses auto adjustable storage.  
output_node                             internal procedure  shares stack frame of external procedure lib_output_node_list_.  
output_nodes_kids                    83 internal procedure  calls itself recursively.  
print_footer                        102 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 INDEX                       lib_output_node_list_
000020 NULL_NAME                   lib_output_node_list_
000030 line_2NL                    lib_output_node_list_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_output_node_list_    000100 Lfirst_name                 lib_output_node_list_
                         000101 Llast_name                  lib_output_node_list_
                         000102 Lname                       lib_output_node_list_
                         000103 Nchars                      lib_output_node_list_
                         000104 Nentries                    lib_output_node_list_
                         000106 POD_storage                 lib_output_node_list_
                         000216 Pchars                      lib_output_node_list_
                         000220 Pindex_entry                lib_output_node_list_
                         000222 Pname                       lib_output_node_list_
                         000224 Ptarget                     lib_output_node_list_
                         000226 added_NL                    lib_output_node_list_
                         000236 code                        lib_output_node_list_
                         000237 dir                         lib_output_node_list_
                         000312 e                           lib_output_node_list_
                         000313 ent                         lib_output_node_list_
                         000324 eop                         lib_output_node_list_
                         000331 i                           lib_output_node_list_
                         000332 j                           lib_output_node_list_
                         000333 long                        lib_output_node_list_
                         000364 page                        lib_output_node_list_
                         000366 saved_Eend_page             lib_output_node_list_
                         000372 saved_page_text_length      lib_output_node_list_
                         000374 short                       lib_output_node_list_
                         000376 PPOD                        lib_output_node_list_
                         000400 Pnode                       lib_output_node_list_
                         000402 PDnames                     lib_output_node_list_
                         000404 Srequirements               lib_output_node_list_
                         000420 Pn                          first_outputable_node
                         000422 Pp                          first_outputable_node
                         000432 msg                         output_node
                         000515 msf_comp_no                 output_node
output_index             000100 column_ent                  output_index
                         000100 line                        output_index
output_nodes_kids        000100 PDnodes_                    output_nodes_kids
                         000102 Pnode_                      output_nodes_kids
                         000104 i                           output_nodes_kids

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              alloc_auto_adj      mod_fx1             enable              shorten_stack       ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          hcs_$terminate_noname         ioa_$ioa_switch_nnl           iox_$put_chars
lib_node_path_                lib_output_node_$cross_reference                            lib_output_node_$info
lib_output_node_$map          lib_output_node_$print        lib_paged_output_             lib_ptr_and_bc_
sort_items_indirect_$char

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000115       103 000123       105 000137       106 000141       107 000142       110 000143       112 000152
    113 000154       114 000156       129 000157       131 000173       132 000175       142 000176       143 000203
    144 000206       145 000212       147 000215       148 000221       150 000223       155 000225       157 000232
    158 000243       159 000253       160 000257       161 000263       164 000270       165 000312       168 000330
    169 000332       170 000354       175 000355       178 000364       179 000373       180 000403       181 000407
    182 000415       183 000421       185 000423       187 000425       190 000432       191 000454       193 000472
    197 000473       198 000506       200 000526       201 000562       203 000607       204 000611       205 000615
    210 000616       211 000623       212 000627       217 000630       218 000632       219 000634       220 000636
    221 000640       222 000641       223 000642       224 000644       225 000645       226 000647       227 000652
    228 000653       229 000655       230 000657       231 000660       232 000661       233 000666       234 000670
    235 000672       237 000673       238 000677       239 000703       241 000707       242 000711       243 000725
    244 000732       245 000743       247 000746       249 000747       250 000761       251 000771       252 000775
    254 001002       255 001012       256 001015       257 001033       258 001034       259 001037       260 001046
    261 001053       263 001055       264 001076       265 001105       266 001107       267 001113       268 001134
    269 001146       270 001147       272 001167       273 001176       274 001200       275 001221       276 001223
    277 001225       278 001234       279 001236       280 001241       281 001247       282 001253       283 001274
    285 001300       292 001301       300 001303       301 001306       304 001314       307 001321       308 001322
    309 001325       310 001330       311 001334       312 001342       314 001345       315 001354       316 001357
    319 001371       328 001374       330 001402       332 001412       333 001415       336 001440       341 001467
    346 001536       347 001557       348 001600       351 001665       352 001672       353 001673       356 001732
    357 001737       359 001741       366 001742       369 001750       375 001764       376 001774       377 002001
    378 002003       379 002005       380 002010       382 002023       383 002040       384 002051       386 002061
    387 002064       389 002072       390 002073       391 002075       393 002076       395 002123       396 002130
    398 002133       400 002155       401 002163       402 002204       403 002241       406 002261       407 002264
    408 002272       409 002310       410 002327       411 002331       412 002337       413 002341       414 002346
    415 002373       417 002400       424 002401       437 002403       439 002410       440 002433       442 002437
    444 002442       445 002445       446 002465       447 002476       449 002477       450 002501       451 002502
    452 002524       453 002530       454 002536       455 002540       456 002542       457 002544       458 002546
    460 002547       463 002550       464 002552       465 002557       466 002562       467 002603       469 002604
    472 002606       473 002610       474 002634       476 002640       478 002643       479 002646       480 002666
    481 002677       482 002701       484 002702       485 002704       486 002705       487 002710       488 002733
    489 002737       490 002742       491 002762       492 002770       493 003001       494 003003       495 003006
    496 003032       497 003036       498 003041       499 003061       500 003062       501 003065       503 003105
    504 003116       505 003120       507 003121       510 003123       511 003126       512 003130       514 003131
    515 003144       516 003160       517 003164       518 003205       519 003210       522 003212       529 003213
    550 003221       551 003232       552 003235       553 003245       554 003251       556 003277       558 003323
    559 003325       561 003346       563 003370       565 003372       572 003373       578 003401       581 003427
    584 003470       585 003477       587 003501


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
