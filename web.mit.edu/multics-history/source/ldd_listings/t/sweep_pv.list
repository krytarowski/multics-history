	COMPILATION LISTING OF SEGMENT sweep_pv
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 03/08/88  1039.4 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: off */
       13 
       14 sweep_pv: proc;
       15 
       16 	go to spv;
       17 
       18 
       19 /* sweep_pv by Bernard Greenberg  6/12/76 
       20*   adopter by BSG, 8/2/77 
       21*   Modified March 1982, J. Bongiovanni, to remove optimizer (ring-0 does it now),
       22*	  to fix some bugs, and generally clean up the code
       23**/
       24 
       25 
       26 /****^  HISTORY COMMENTS:
       27*  1) change(87-11-12,Farley), approve(88-03-01,MCR7816),
       28*     audit(88-03-03,Fawcett), install(88-03-08,MR12.2-1033):
       29*     Added use of hphcs_$clear_vtoce when the error code from cv_uid_path
       30*     is error_table_$bad_uidpath or the filemap in the vtoce is thought to
       31*     be bad, instead of hphcs_$delete_vtoce, when using the -delete option.
       32*     This indicates that the VTOCE is in error and attempting to possibly
       33*     free the vtoce.fm pages could cause much more damage. (phx20964)
       34*     
       35*     Corrected code so that "dir" privilege is not removed from the user's
       36*     process after this program executes. (phx17077).
       37*     
       38*     Generally cleaned up the code.
       39*                                                   END HISTORY COMMENTS */
       40 
       41 
       42 /*  Automatic  */
       43 
       44 dcl 1 acla (1) aligned,
       45     2 userid char (32),
       46     2 modes bit (36),
       47     2 aclaec fixed bin (35);
       48 dcl  adopting bit (1);
       49 dcl  areap ptr;
       50 dcl  argl fixed bin;
       51 dcl  argp ptr;
       52 dcl  chainptrs (0:15) ptr;
       53 dcl  checksum bit (36) aligned;
       54 dcl  code fixed bin (35);
       55 dcl  code1 fixed bin (35);
       56 dcl  damaged_ct fixed bin;
       57 dcl  dbsw bit (1);
       58 dcl  del_this bit (1);
       59 dcl  deleted bit (1);
       60 dcl  dir char (168);
       61 dcl  dl_mode bit (1);
       62 dcl  dswitch ptr;
       63 dcl  dts4 char (4) defined dtstart pos (11);
       64 dcl  dtstart char (24);
       65 dcl  ent char (32);
       66 dcl  eswitch ptr;
       67 dcl  excuse char (10);
       68 dcl  force bit (1);
       69 dcl  fromsw bit (1);
       70 dcl  fv fixed bin;
       71 dcl  gc_comment char (20);
       72 dcl  gcsw bit (1);
       73 dcl  i fixed bin;
       74 dcl  inhibit_on bit (1);
       75 dcl  lastv fixed bin;
       76 dcl  listopt bit (1);
       77 dcl  llines fixed bin;
       78 dcl 1 local_vtoce like vtoce aligned;
       79 dcl  lswitch ptr;
       80 dcl  myname char (32);
       81 dcl  namealloclen fixed bin;
       82 dcl  n_args fixed bin;
       83 dcl  onlysw bit (1);
       84 dcl  pageno fixed bin;
       85 dcl  pn char (168);
       86 dcl  pvid bit (36) aligned;
       87 dcl  pvname char (32);
       88 dcl  pvtx fixed bin;
       89 dcl  recsgotten fixed bin;
       90 dcl  rstate fixed bin;
       91 dcl  set_priv bit (1);
       92 dcl  started bit (1);
       93 dcl  tosw bit (1);
       94 dcl  tptr ptr;
       95 dcl  vacating bit (1);
       96 dcl  vsgotten fixed bin;
       97 dcl  vsrecovered fixed bin;
       98 dcl  vtocx fixed bin;
       99 
      100 /*  Based  */
      101 
      102 dcl  arg char (argl) based (argp);
      103 dcl  allocarea area based (areap);
      104 dcl 1 restore_name based aligned,
      105     2 fp ptr unal,
      106     2 namelen fixed bin (8) unal,
      107     2 name char (namealloclen refer (restore_name.namelen)) unal;
      108 
      109 /*  Constants  */
      110 
      111 dcl  EF_open fixed bin internal static options (constant) init (6);
      112 dcl  GC_open fixed bin internal static options (constant) init (4);
      113 dcl  LS_open fixed bin internal static options (constant) init (2);
      114 
      115 /*  External  */
      116 
      117 dcl  error_table_$action_not_performed fixed bin (35) external;
      118 dcl  error_table_$badopt fixed bin (35) external;
      119 dcl  error_table_$bad_uidpath fixed bin (35) external;
      120 dcl  error_table_$inconsistent fixed bin (35) external;
      121 dcl  error_table_$incorrect_access fixed bin (35) external;
      122 dcl  error_table_$invalid_vtocx fixed bin (35) external;
      123 dcl  error_table_$no_dir fixed bin (35) external;
      124 dcl  error_table_$noentry fixed bin (35) external;
      125 dcl  error_table_$not_privileged fixed bin (35) external;
      126 dcl  error_table_$root fixed bin (35) external;
      127 
      128 /*  Entry  */
      129 
      130 dcl  adopt_seg_ entry (char (*), char (*), bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
      131 dcl  com_err_ entry options (variable);
      132 dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
      133 dcl  cu_$arg_count entry (fixed bin, fixed bin(35));
      134 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      135 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
      136 dcl  date_time_ entry (fixed bin (52), char (*));
      137 dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
      138 dcl  date_time_$fstime entry (bit (36) aligned, char (*));
      139 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      140 dcl  filemap_checksum_ entry (ptr, fixed bin, bit (36) aligned);
      141 dcl  get_group_id_ entry returns (char (32) aligned);
      142 dcl  get_system_free_area_ entry returns (ptr);
      143 dcl  hcs_$add_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      144 dcl  hcs_$delete_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      145 dcl  hphcs_$clear_vtoce entry (bit (36) aligned, fixed bin, fixed bin (35));
      146 dcl  hphcs_$delete_vtoce entry (bit (36), bit (36) aligned, fixed bin, fixed bin (35));
      147 dcl  hphcs_$pv_move_file entry (char (*), char (*), fixed bin (35));
      148 dcl  hphcs_$stop_vacate_pv entry (fixed bin, bit (36) aligned, fixed bin (35));
      149 dcl  hphcs_$vacate_pv entry (fixed bin, bit (36) aligned, fixed bin (35));
      150 dcl  ioa_ entry options (variable);
      151 dcl  ioa_$ioa_switch entry options (variable);
      152 dcl  ioa_$rsnnl entry options (variable);
      153 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
      154 dcl  iox_$close entry (ptr, fixed bin (35));
      155 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      156 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      157 dcl  iox_$user_output ptr external;
      158 dcl  phcs_$get_vtoce entry (fixed bin, fixed bin, ptr, fixed bin (35));
      159 dcl  pvname_to_pvtx_ entry (char(*), fixed bin, bit(36) aligned, fixed bin(35));
      160 dcl  system_privilege_$dir_priv_off entry (fixed bin (35));
      161 dcl  system_privilege_$dir_priv_on entry (fixed bin (35));
      162 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      163 dcl  vpn_cv_uid_path_$ent entry (ptr, char (*), bit (36), fixed bin (35));
      164 
      165 /*  Builtin  */
      166 
      167 dcl  addr builtin;
      168 dcl  clock builtin;
      169 dcl  dim builtin;
      170 dcl  fixed builtin;
      171 dcl  hbound builtin;
      172 dcl  lbound builtin;
      173 dcl  length builtin;
      174 dcl  mod builtin;
      175 dcl  null builtin;
      176 dcl  reverse builtin;
      177 dcl  rtrim builtin;
      178 dcl  substr builtin;
      179 dcl  verify builtin;
      180 
      181 /*  Condition  */
      182 
      183 dcl  cleanup condition;
      184 dcl  linkage_error condition;
      185 
      186 
      187 /*  */
      188 inhibit_pv: entry;
      189 
      190           myname = "inhibit_pv";
      191 	inhibit_on = "1"b;
      192 	
      193 	call cu_$arg_count (n_args, code);
      194 	if code ^= 0 then do;
      195 	     call com_err_ (code, myname);
      196 	     return;
      197 	end;
      198 	
      199 	if n_args = 0 | n_args > 2 then do;
      200 	     call ioa_ ("^a: Usage is:     ^a pvname {-off}", myname, myname);
      201 	     return;
      202 	end;
      203 	
      204 	call cu_$arg_ptr (1, argp, argl, code);
      205 	pvname = arg;
      206 	call pvname_to_pvtx_ (pvname, pvtx, pvid, code);
      207 	if code ^= 0 then do;
      208 	     call com_err_ (code, myname, pvname);
      209 	     return;
      210 	end;
      211 	
      212 	if n_args >= 2 then do;
      213 	     call cu_$arg_ptr (2, argp, argl, code);
      214 	     if arg = "-off" then inhibit_on = "0"b;
      215 	     else do;
      216 		call com_err_ (error_table_$badopt, myname, arg);
      217 		return;
      218 	     end;
      219 	end;
      220 	
      221 	on linkage_error goto NOT_PRIVILEGED;
      222 
      223 	if inhibit_on
      224 	     then call hphcs_$vacate_pv (pvtx, pvid, code);
      225 	else call hphcs_$stop_vacate_pv (pvtx, pvid, code);
      226 	
      227 	revert linkage_error;
      228 
      229 	if code ^= 0 then do;
      230 	     call com_err_ (code, myname, "Attempting to ^[^;un-^]inhibit ^a",
      231 		(inhibit_on), pvname);
      232 	     return;
      233 	end;
      234 
      235 	return;
      236 
      237 
      238 /*  */
      239 spv:
      240 
      241 	myname = "sweep_pv";
      242 	adopting, dbsw, dl_mode, force, fromsw, gcsw, listopt, onlysw, set_priv,
      243 	     started, tosw, vacating = "0"b;
      244 	damaged_ct, fv, llines, recsgotten, rstate, vsgotten, vsrecovered = 0;
      245 	lastv = MAX_VTOCE_PER_PACK;
      246 	pageno = 1;
      247 	dswitch, eswitch, lswitch = null ();
      248 
      249 	call cu_$arg_count (n_args, code);
      250 	if code ^= 0 then do;
      251 	     call com_err_ (code, myname);
      252 	     return;
      253 	end;
      254 	
      255 	if n_args = 0 then do;
      256 	     call ioa_ ("^a: Usage is:  ^a pvname {-collect|-gc} {-list|-ls} {-adopt}
      257 		{-from vtocx} {-to vtocx} {-only vtocx} {-force|-fc}
      258 		{-move|-mv} {-delete|-dl}", myname, myname);
      259 	     return;
      260 	end;
      261 	
      262 	call cu_$arg_ptr (1, argp, argl, code);
      263 	pvname = arg;
      264 	call pvname_to_pvtx_ (pvname, pvtx, pvid, code);
      265 	if code ^= 0 then do;
      266 	     call com_err_ (code, myname, pvname);
      267 	     return;
      268 	end;
      269 	
      270 
      271 /*  Collect Arguments and Validate Same  */
      272 
      273           do i = 2 to n_args;
      274 	     call cu_$arg_ptr (i, argp, argl, code);
      275 	     if arg = "-gc" | arg = "-collect" then gcsw = "1"b;
      276 	     else if arg = "-ls" | arg = "-list" then listopt = "1"b;
      277 	     else if arg = "-move" | arg = "-mv" then vacating = "1"b;
      278 	     else if arg = "-adopt" then adopting = "1"b;
      279 	     else if arg = "-delete" | arg = "-dl" then dl_mode = "1"b;
      280 	     else if arg = "-debug" | arg = "-db" then dbsw = "1"b;
      281 	     else if arg = "-from" then fv = numarg (fromsw);
      282 	     else if arg = "-to" then lastv = numarg (tosw);
      283 	     else if arg = "-only" then lastv, fv = numarg (onlysw);
      284 	     else if arg = "-force" | arg = "-fc" then force = "1"b;
      285 	     else do;
      286 		call com_err_ (error_table_$badopt, myname, arg);
      287 		return;
      288 	     end;
      289 
      290 	end;
      291 
      292 	call checkincon (dl_mode & ^gcsw, "-delete requires -gc.");
      293 	call checkincon (adopting & ^gcsw, "-adopt requires -gc.");
      294 	call checkincon ((fromsw | tosw) & onlysw, "-only is inconsistent with -from/-to.");
      295 	call checkincon (fromsw & tosw & lastv < fv, "Last vtoce # is less than first.");
      296 	call checkincon (^dbsw & ^ vacating & ^ listopt & ^ gcsw, "No action specified.");
      297 
      298 	if vacating then do;
      299 	     on linkage_error goto NOT_PRIVILEGED;
      300 	     call hphcs_$vacate_pv (pvtx, pvid, code);
      301 	     revert linkage_error;
      302 	     if code ^= 0 then do;
      303 		call com_err_ (code, myname, "Attempting to inhibit ^a", pvname);
      304 		return;
      305 	     end;
      306 	     call ioa_ ("^a: Volume ^a inhibited", myname, pvname);
      307 	end;
      308 	
      309 
      310 	on cleanup call finish;
      311 
      312 	if force then do;
      313 	     areap = get_system_free_area_ ();
      314 	     chainptrs (*) = null ();
      315 	     acla (1).userid = get_group_id_ ();	/* Get acl info for forcing */
      316 	     acla (1).modes = SMA_ACCESS;
      317 
      318 	     on linkage_error begin;
      319 		call com_err_ (0, myname, "Unable to set AIM privilege. Access may be incomplete.");
      320 		go to revert_handler;
      321 	     end;
      322 	     call system_privilege_$dir_priv_on (code);	/* Try to give AIM authority */
      323 	     set_priv = (code = 0);			/* If given, remember to take away later */
      324 revert_handler:
      325 	     revert linkage_error;
      326 
      327 	end;
      328 
      329 
      330 
      331 	call date_time_ (clock (), dtstart);
      332 
      333 	if listopt then call attach (lswitch, "pvlist", "Listing");
      334 	else rstate = LS_open;			/* update so finish will work properly */
      335 
      336 	if gcsw then do;
      337 	     call attach (dswitch, "pvgc", "Disconnection");
      338 	     call ioa_$ioa_switch (dswitch, "PV COLLECTION  -- Vol ^a  ^o to ^o   ^a^3/", pvname, fv, lastv, dtstart);
      339 	end;
      340 	else rstate = GC_open;			/* update so finish will work properly */
      341 
      342 
      343 	if adopting then gc_comment = "Recovering";
      344 	else if dl_mode then gc_comment = "Deleting";
      345 	else gc_comment = "Unconnected";
      346 
      347 
      348 /*          SCAN THE VTOC
      349*
      350*   This loop walks the selected region of the VTOC, performing the following operations for
      351*   all non-free vtoces:
      352*   1. Develop the pathname, forcing all access as necessary. (See s/r cv_uid_path).
      353*   2. If reverse connection failure, and gc-mode, report and possibly delete it.
      354*   3. If adopting, attempt to construct a branch for the segment or direcory.
      355*   4. If moving segments, call hphcs to move the segment via the segment mover.
      356*   5. If listing, produce a report line.
      357*   6. Write all errors to the error file.
      358*
      359*
      360**/
      361 
      362 	started = "1"b;
      363 	vtocep = addr (local_vtoce);
      364 
      365 	do vtocx = fv to lastv by 1;
      366 	     call phcs_$get_vtoce (pvtx, vtocx, vtocep, code);
      367 	     if code ^= 0 then do;
      368 		vtoce.uid = "0"b;			/* for next thing */
      369 
      370 		if code = error_table_$invalid_vtocx then go to fin;
      371 		call ckef;
      372 		call ioa_$ioa_switch (eswitch, "^8o^3x^6a^3x^a", vtocx, time (), einterp (code));
      373 	     end;
      374 
      375 	     if vtoce.uid ^= "0"b then do;
      376 		deleted = "0"b;
      377 		call cv_uid_path (addr (vtoce.uid_path), pn, vtoce.uid, code);
      378 		if code ^= 0 then do;
      379 
      380 /* The following code deals with the case of reverse connection failure. */
      381 
      382 		     if code = error_table_$noentry | code = error_table_$no_dir then do;
      383 			if code = error_table_$noentry then excuse = "No Entry."; else excuse = "No Dir.";
      384 			if ^gcsw then go to a;
      385 			call ioa_$ioa_switch (dswitch, "^8o^3x^6a^3x^10a^3x^a Vtoce: ^a",
      386 			     vtocx, time (), excuse, gc_comment, pn);
      387 			call ioa_$ioa_switch (dswitch, "^33x= ""^a"", modified ^a, used ^a",
      388 			     vtoce.primary_name, dtc (vtoce.dtm), dtc (vtoce.dtu));
      389 			if adopting then do;
      390 			     if code = error_table_$no_dir then do;
      391 				call ioa_$ioa_switch (dswitch,
      392 				     "^33xWill not reconnect: superior directory missing.");
      393 				if dl_mode then call ioa_$ioa_switch (dswitch,
      394 				     "^33xWill attempt to delete ^a", pn);
      395 				del_this = "1"b;
      396 			     end;
      397 			     else do;		/* Entry missing- try reconnect */
      398 				call expand_pathname_ (pn, dir, (32)" ", (0));
      399 				ent = gen_uname (vtoce.primary_name);
      400 				call adopt_seg_ (dir, ent, pvid, pvtx, vtocx, code1);
      401 				if dir = ">" then dir = "";
      402 				pn = rtrim (dir) || ">" || ent;
      403 				if code1 = 0 then do;
      404 				     vsrecovered = vsrecovered + 1;
      405 				     call ioa_$ioa_switch (dswitch,
      406 					"^33xAdopted ^o as ^a.", vtocx, pn);
      407 				end;
      408 				else do;
      409 				     call ckef;
      410 				     do tptr = eswitch, dswitch;
      411 					call ioa_$ioa_switch (tptr, "^8o^3x^6a^3xError Reconnecting vtoce: ^a ^a.",
      412 					     vtocx, time (), einterp (code1), pn);
      413 				     end;
      414 				end;
      415 				del_this = "0"b;
      416 			     end;
      417 			end;
      418 			else del_this = "1"b;
      419 			deleted = "1"b;
      420 			if dl_mode & del_this then do;
      421 			     if ^vtoce.fm_damaged & vtoce.fm_checksum_valid then do;
      422 				call filemap_checksum_ (addr (vtoce.fm), fixed (vtoce.csl), checksum);
      423 				if vtoce.fm_checksum ^= checksum then vtoce.fm_damaged = "1"b;
      424 			     end;
      425 			     if code = error_table_$bad_uidpath | vtoce.fm_damaged
      426 			     then call hphcs_$clear_vtoce (pvid, vtocx, code1);
      427 			     else call hphcs_$delete_vtoce (vtoce.uid, pvid, vtocx, code1);
      428 			     if code1 ^= 0 then do;
      429 				call ckef;
      430 				do tptr = eswitch, dswitch;
      431 				     call ioa_$ioa_switch (tptr,
      432 					"^8o^3x^6a^3xError Deleting vtoce: ^a ^a",
      433 					vtocx, time (), einterp (code1), pn);
      434 				end;
      435 			     end;
      436 			end;
      437 			else code1 = 0;
      438 			if code1 = 0 then do;
      439 			     vsgotten = vsgotten + 1;
      440 			     recsgotten = recsgotten + fixed (vtoce.records, 9);
      441 			end;
      442 		     end;
      443 		     else do;
      444 a:			call ckef;
      445 			call ioa_$ioa_switch (eswitch, "^8o^3x^6a^3x^a^x^a",
      446 			     vtocx, time (), einterp (code), pn);
      447 		     end;
      448 		end;
      449 
      450 /* Check the VTOCE for consistency */
      451 
      452 		call validate_vtoce;
      453 
      454 /* See if damaged, report it if so. */
      455 
      456 		if vtoce.damaged then do;
      457 		     if listopt then do;
      458 			call cktop;
      459 			llines = llines + 1;
      460 		     end;
      461 		     call ckef;
      462 		     do tptr = eswitch, lswitch;
      463 			if tptr ^= null then call ioa_$ioa_switch (tptr, "^8o^3x^6a^3x^a^x^a",
      464 			     vtocx, time (), "This segment is damaged:", pn);
      465 		     end;
      466 		     damaged_ct = damaged_ct + 1;
      467 		end;
      468 
      469 /* If vacating, develop pathname and call hphcs. */
      470 
      471 		if vacating then do;
      472 		     if code ^= 0 then;
      473 		     else do;
      474 			call expand_pathname_ (pn, dir, ent, code1);
      475 			if dbsw then code1 = 0;
      476 			else call hphcs_$pv_move_file (dir, ent, code1);
      477 			if code1 ^= 0 then do;
      478 			     call ckef;
      479 			     call ioa_$ioa_switch (eswitch, "^8o^3x^6a^3xError Moving Segment: ^a ^a",
      480 				vtocx, time (), einterp (code1), pn);
      481 			end;
      482 		     end;
      483 		end;
      484 
      485 /* If listing, produce report line. */
      486 
      487 		if listopt then do;
      488 		     call cktop;
      489 		     call ioa_$ioa_switch (lswitch, "^8o^x^[*^;^x^]^x^[^7d^;^s^7x^]^x^a^[ (^a)^]",
      490 			vtocx, deleted, ^vtoce.dirsw, seg_vtoce.usage, pn, deleted, excuse);
      491 		     llines = llines + 1;
      492 		end;
      493 	     end;
      494 	end;
      495 
      496 	vtocx = vtocx -1;
      497 
      498 
      499 fin:
      500 nlexit:
      501 	call finish;
      502 	return;
      503 
      504 
      505 NOT_PRIVILEGED:
      506 	call com_err_ (error_table_$not_privileged, myname, "hphcs_");
      507 	return;
      508 	
      509 
      510 
      511 
      512 
      513 attach:	proc (tptr, head, name);
      514 
      515 /* Make all output file attachments, incrementing rstate as we go, so that
      516*   partially complete attachments can be cleaned up. */
      517 
      518 
      519 dcl  atdesc char (57);
      520 dcl  codea fixed bin (35);
      521 dcl  tptr ptr;
      522 dcl (head, name) char (*);
      523 
      524 	     call ioa_$rsnnl ("vfile_ ^a.^a.^a", atdesc, 0, head, pvname, dts4);
      525 
      526 	     call iox_$attach_ioname ("switch." || head, tptr, atdesc, codea);
      527 	     if codea ^= 0 then do;
      528 		call com_err_ (codea, myname, "Attaching ^a file.", head);
      529 		go to fin;
      530 	     end;
      531 	     rstate = rstate + 1;
      532 
      533 	     call iox_$open (tptr, Stream_output, "0"b, codea);
      534 	     if codea ^= 0 then do;
      535 		call com_err_ (codea, myname, "Opening ^a file", head);
      536 		go to fin;
      537 	     end;
      538 	     rstate = rstate + 1;
      539 	     call ioa_ ("^a: ^a file attached to ^a", myname, name, substr (atdesc, 7));
      540 	     return;
      541 	end;
      542 
      543 /*  */
      544 /* UNIQUE-NAME-FOR-ADOPT GENERATOR */
      545 
      546 gen_uname: proc (aname) returns (char (32));
      547 
      548 dcl  aname char (32);
      549 dcl  uname char (15);
      550 
      551 	     uname = unique_chars_ (""b);		/* Get a truly unique name */
      552 	     if length (rtrim (aname)) > 15 & substr (aname, 1, 3) = "!BB"
      553 	     then return (uname || substr (aname, 16));
      554 	     else return (uname || rtrim (aname));
      555 
      556 	end gen_uname;
      557 
      558 
      559 cktop:	proc;
      560 
      561 /* check page overflow counter */
      562 
      563 	     if mod (llines, 54) = 0 then do;
      564 		call ioa_$ioa_switch (lswitch, "^|PV LISTING^10xVolume ^a  ^a^3xfrom ^o to ^o^6xPage ^d",
      565 		     pvname, dtstart, fv, lastv, pageno);
      566 		call ioa_$ioa_switch (lswitch, "VTOC INDEX^3xUSAGE^5xPATHNAME");
      567 		pageno = pageno + 1;
      568 		call ioa_$ioa_switch (lswitch, "^2/");
      569 		llines = llines + 4;
      570 	     end;
      571 
      572 	end cktop;
      573 
      574 /*  */
      575 /* VTOCE CONSISTENCY CHECK */
      576 
      577 validate_vtoce:
      578      proc;
      579 
      580 dcl  csl fixed bin;					/* working current length */
      581 dcl  error_mess char (200);				/* Formatted message */
      582 dcl  error_mess_len fixed bin (21);			/* Length of formatted message */
      583 dcl  fmx fixed bin;					/* file map index */
      584 dcl  msl fixed bin;					/* working max length */
      585 dcl  records fixed bin;				/* working number records */
      586 
      587 
      588 
      589 
      590      csl, records = 0;
      591      msl = 256;
      592      do fmx = 0 to msl - 1;
      593 	if substr (vtoce.fm (fmx), 1, 1) ^= "1"b then do; /* non-null  address			*/
      594 	     records = records + 1;
      595 	     csl = fmx + 1;
      596 	end;
      597      end;
      598 
      599      if fixed (vtoce.records, 9) ^= records
      600 	then do;
      601 	call ioa_$rsnnl ("^8o^3x^6a^3xrecords used=^o(should be ^o):^a",
      602 	     error_mess, error_mess_len, vtocx, time (), fixed (vtoce.records), records, pn);
      603 	call report_error (error_mess);
      604      end;
      605 
      606      if fixed (vtoce.csl, 9) ^= csl
      607 	then do;
      608 	call ioa_$rsnnl ("^8o^3x^6a^3xcur length=^o(should be ^o):^a",
      609 	     error_mess, error_mess_len, vtocx, time (), fixed (vtoce.csl), csl, pn);
      610 	call report_error (error_mess);
      611      end;
      612      
      613 
      614      if fixed (vtoce.msl, 9) > msl | fixed (vtoce.msl, 9) < csl
      615 	then do;
      616 	call ioa_$rsnnl ("^8o^3x^6a^3xmax len=^o:^a", error_mess, error_mess_len,
      617 	     vtocx, time (), fixed (vtoce.msl), pn);
      618 	call report_error (error_mess);
      619      end;
      620      
      621 
      622 
      623      return;
      624 
      625 report_error:
      626      proc (message);
      627      
      628      dcl  message char (*);
      629      
      630 
      631      if listopt then do;
      632 	call cktop;
      633 	llines = llines + 1;
      634      end;
      635      call ckef;
      636      do tptr = eswitch, lswitch;
      637 	if tptr ^= null ()
      638 	     then call ioa_$ioa_switch (tptr, "^a", message);
      639      end;
      640      
      641 end report_error;
      642 
      643 
      644      end validate_vtoce;
      645      
      646 
      647 
      648 /* 	*/
      649 /* UTILITY CONVERSION ROUTINES */
      650 
      651 
      652 time: proc () returns (char (6));
      653 
      654 /* Return a printable time. */
      655 
      656 	     return ((date_time_$format ("^Hd^99v.9MH", clock (), "", "")));
      657 	end time;
      658 
      659 einterp:	proc (cd) returns (char (100));
      660 
      661 /* Provide printable error messages from error codes. It should be observed
      662*   that vpn_cv_uid_path_ (external) returns error_table_$action_not_performed if
      663*   he loses races with directory control after a sufficient number of
      664*   retries. cvuid_rcurse (below) also returns this if he loses a race with a
      665*   malicious name-changer. */
      666 
      667 dcl  ignore char (8) aligned, long char (100) aligned, cd fixed bin (35);
      668 	     if code = error_table_$action_not_performed
      669 	     then return ("Unable to get consistent copy of directories/pathnames.");
      670 	     call convert_status_code_ (cd, ignore, long);
      671 	     return (long);
      672 	end;
      673 
      674 ckef:	proc;
      675 
      676 /* Attach error file if not already attached. */
      677 
      678 	     if rstate < EF_open then do;
      679 		call attach (eswitch, "pvef", "Error");
      680 		call ioa_$ioa_switch (eswitch, "PV SWEEP ERROR FILE    Volume ^a    ^a^2/", pvname, dtstart);
      681 	     end;
      682 	end;
      683 
      684 dtc:	proc (fs_time) returns (char (24));
      685 dcl  fs_time bit (36);
      686 dcl  date char (24);
      687 
      688 	     call date_time_$fstime ((fs_time), date);
      689 	     return (date);
      690 	end;
      691 
      692 /*  */
      693 
      694 /* PROCEDURES USED IN ARGUMENT COLLECTION/VALIDATION */
      695 
      696 numarg:	proc (flag) returns (fixed bin);		/* Proc to pick up one more numeric arg */
      697 						/* THIS MUST BE PL/I QUICK BLOCK */
      698 						/* AS cu_argptr is used */
      699 
      700 dcl  key char (10) init (arg);			/* Save old thing */
      701 dcl  stuff fixed bin;
      702 dcl  flag bit (1);
      703 
      704 	     i = i + 1;				/* Step over key */
      705 	     call cu_$arg_ptr (i, argp, argl, code);
      706 	     if code ^= 0 then do;
      707 		call com_err_ (code, myname, "Octal # expected after ^a.", key);
      708 		go to nlexit;
      709 	     end;
      710 
      711 	     stuff = cv_oct_check_ (arg, code);
      712 	     if code ^= 0 then do;
      713 		call com_err_ (0, myname, "Bad octal arg for ^a: ^a", key, arg);
      714 		go to nlexit;
      715 	     end;
      716 	     flag = "1"b;
      717 	     return (stuff);
      718 	end;
      719 
      720 
      721 checkincon: proc (truth, message);
      722 
      723 dcl  truth bit (1), message char (*);
      724 
      725 	     if truth then do;
      726 		call com_err_ (error_table_$inconsistent, myname, message);
      727 		go to nlexit;
      728 	     end;
      729 	end checkincon;
      730 						/*  */
      731 
      732 /* GENERAL CLEANUP/TERMINATION PROCEDURE */
      733 
      734 
      735 finish:	proc;
      736 	     if started then do;
      737 						/* Clean up large stuff iff started. */
      738 		call ioa_ ("Processed to vtocx ^o.", vtocx);
      739 		if set_priv then call system_privilege_$dir_priv_off ((0));
      740 		if force then call restore_all_access;
      741 	     end;
      742 	     go to rrecover (rstate);
      743 						/* Undo whatever was done */
      744 rrecover (6):					/* EF_open */
      745 	     if damaged_ct > 0 then do tptr = eswitch, lswitch, iox_$user_output;
      746 		if tptr ^= null then call ioa_$ioa_switch (tptr, "^/Found ^d damaged segment^[s^].", damaged_ct, (damaged_ct > 1));
      747 	     end;
      748 	     call iox_$close (eswitch, (0));
      749 rrecover (5):
      750 	     call iox_$detach_iocb (eswitch, (0));
      751 rrecover (4):					/* GC_open, maybe */
      752 	     if gcsw then call ioa_$ioa_switch (dswitch, "^/^d Vtoces collected, ^d records", vsgotten, recsgotten);
      753 	     if adopting then call ioa_$ioa_switch (dswitch, "^d Vtoces reconnected.", vsrecovered);
      754 	     if gcsw then call iox_$close (dswitch, (0));
      755 rrecover (3):
      756 	     if gcsw then call iox_$detach_iocb (dswitch, (0));
      757 rrecover (2):					/* LS_open, maybe */
      758 	     if listopt then call ioa_$ioa_switch (lswitch, "^/Processed to VTOCX ^o", vtocx);
      759 	     if listopt then call iox_$close (lswitch, (0));
      760 rrecover (1):
      761 	     if listopt then call iox_$detach_iocb (lswitch, (0));
      762 rrecover (0):
      763 	     return;
      764 	end finish;
      765 
      766 /* PROCEDURES TO COMPUTE NAME, POTENTIALLY FORCING ACCESS */
      767 
      768 cv_uid_path: procedure (a_uidpp, a_pn, a_uid, a_code);
      769 
      770 dcl  a_uidpp ptr, a_pn char (*), a_uid bit (36), a_code fixed bin (35) aligned;
      771 
      772 dcl  lev fixed bin;
      773 dcl  uidpth (0:15) based (a_uidpp) bit (36) aligned;
      774 
      775 	     do lev = 0 to 15 while (uidpth (lev) ^= "0"b);
      776 	     end;
      777 
      778 	     if lev = 15 then if uidpth (15) ^= "0"b then lev = 16;
      779 
      780 	     call cvuid_recurse (a_uidpp, a_pn, a_uid, lev, a_code); /* Do the dirty deed */
      781 	     return;
      782 
      783 
      784 cvuid_recurse: procedure (a_uidp, a_pn, a_uid, a_lev, a_code);
      785 
      786 dcl  a_uidp ptr, a_uid bit (36), a_pn char (*), a_lev fixed bin, a_code fixed bin (35);
      787 dcl  lpn char (168), luid bit (36), lev fixed bin;
      788 dcl  locuidpth (0:15) bit (36) aligned;
      789 dcl  uidpth (0:15) bit (36) aligned based (a_uidp), pc1 fixed bin;
      790 
      791 /* Call this procedure to get pathname for (a_uidp->uidpth)>(a_uid) or reason why not.
      792*   a_lev is 1 greater than last valid component # in a_uidp -> uidpth.
      793*
      794*   Strategy is to call vpn_cv_uid_path_...
      795*   And if that fails, try to identify parent and try again...
      796*   And if that fails, give status access to parent and try again...
      797*   And if that fails, you lost a race, return action_not_perf. */
      798 
      799 
      800 		do pc1 = 1 to 3;			/* Prog ctr thru steps */
      801 		     call vpn_cv_uid_path_$ent (a_uidp, a_pn, a_uid, a_code); /* Try it */
      802 		     if a_code = 0 then return;	/* If it won, that's it. */
      803 		     if a_code ^= error_table_$incorrect_access then return; /* If not access, we can't help */
      804 		     if pc1 = 1 then do;		/* First desperation */
      805 			lev = a_lev - 1;		/* Get lower lev */
      806 			if ^force then return;	/* Not even supposed to try. */
      807 			luid = uidpth (lev);
      808 			locuidpth = uidpth;
      809 			locuidpth (lev) = "0"b;	/* Get name of father */
      810 			call cvuid_recurse (addr (locuidpth), lpn, luid, lev, a_code);
      811 			if a_code ^= 0 then return;	/* If he can't hack it, give up */
      812 		     end;				/* We may now have enough to complete */
      813 		     else if pc1 = 2 then do;		/* Must give access on father */
      814 			call giver_of_access ("100"b, lpn, lev, a_code);
      815 			if a_code ^= 0 then return;	/* He tried his best */
      816 		     end;				/* Try with new access */
      817 		end;
      818 		a_code = error_table_$action_not_performed; /* Raced pathnames */
      819 	     end cvuid_recurse;
      820 
      821 giver_of_access: procedure (abits, ac_pn, ac_lev, aa_code);
      822 
      823 /* Gives abits-access to ac_pn directory, or why not */
      824 
      825 dcl  abits bit (3), ac_pn char (*), aa_code fixed bin (35);
      826 dcl  ac_lev fixed bin;
      827 dcl  dir char (168), ent char (32);
      828 dcl  pc2 fixed bin;
      829 
      830 /* Strategy is to try to add acle. If that fails,
      831*   give sma to father. If that fails, reflect failure. */
      832 
      833 		call expand_pathname_ (ac_pn, dir, ent, (0)); /* Computers don't make mistakes */
      834 
      835 		do pc2 = 1 to 2;			/* Count desperations */
      836 		     acla.modes (1) = abits;		/* Reinit for clobberance */
      837 		     call hcs_$add_dir_acl_entries (dir, ent, addr (acla), dim (acla, 1), aa_code);
      838 		     if aa_code = 0 then do;
      839 			call register_pn (ac_pn, ac_lev); /* Remember for undo */
      840 			return;
      841 		     end;
      842 		     if aa_code = error_table_$root then do;
      843 			aa_code = error_table_$incorrect_access;
      844 			return;			/* => ultimately no access */
      845 		     end;
      846 		     if aa_code ^= error_table_$incorrect_access then return;
      847 		     if pc2 = 1 then do;		/* First desperate */
      848 			call giver_of_access ("111"b, dir, ac_lev - 1, aa_code); /* Access to father */
      849 			if aa_code ^= 0 then return;	/* Nogo */
      850 		     end;
      851 		end;
      852 						/* If we're here, we're blocked */
      853 		return;
      854 
      855 register_pn:	proc (b_pn, b_lev);
      856 
      857 /* Add b_pn to a list of pathnames at level b_lev, so that restore_all_access (below)
      858*   can hand it back reversely by level. */
      859 
      860 
      861 
      862 dcl  b_pn char (*), b_lev fixed bin;
      863 dcl  namp ptr;
      864 		     do namp = chainptrs (b_lev) repeat namp -> restore_name.fp while (namp ^= null ());
      865 		     end;
      866 		     if namp = null then do;		/* Put in table anew */
      867 			namealloclen = length (b_pn) + 1 - verify (reverse (b_pn), " ");
      868 			allocate restore_name in (allocarea) set (namp);
      869 			namp -> restore_name.namelen = namealloclen;
      870 			namp -> restore_name.fp = chainptrs (b_lev);
      871 			namp -> restore_name.name = b_pn;
      872 			chainptrs (b_lev) = namp;
      873 		     end;				/* Can refind if was s, now sma */
      874 		end register_pn;
      875 	     end giver_of_access;
      876 	end cv_uid_path;
      877 
      878 
      879 /*  */
      880 
      881 /* CLEANUP PROC FOR NAME COMPUTER */
      882 
      883 restore_all_access: procedure;			/* Invoked to give back what has been taken */
      884 
      885 dcl  lev fixed bin;
      886 dcl  rdir char (168), rent char (32);
      887 dcl (namp, pman) ptr;
      888 
      889 	     do lev = hbound (chainptrs, 1) to lbound (chainptrs, 1) by -1;
      890 		do namp = chainptrs (lev) repeat pman while (namp ^= null ());
      891 		     pman = namp -> restore_name.fp;
      892 		     call expand_pathname_ (namp -> restore_name.name, rdir, rent, (0));
      893 		     call hcs_$delete_dir_acl_entries (rdir, rent, addr (acla), dim (acla, 1), (0));
      894 		     free namp -> restore_name in (allocarea);
      895 		end;
      896 	     end;
      897 	end restore_all_access;
      898 						/*  */
      899 
      900 						/*  */
      901  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      901 
      902  /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  2     2 
  2     3 /* Created 740723 by PG */
  2     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  2     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  2     6 
  2     7 /* This structure defines the components of both an access
  2     8*   class and an access authorization as interpreted by the
  2     9*   Access Isolation Mechanism. */
  2    10 
  2    11 
  2    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  2    13        2 categories bit (36),				/* access categories */
  2    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  2    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  2    16         (3 ipc,					/* interprocess communication privilege */
  2    17          3 dir,					/* directory privilege */
  2    18          3 seg,					/* segment privilege */
  2    19          3 soos,					/* security out-of-service privilege */
  2    20          3 ring1,					/* ring 1 access privilege */
  2    21          3 rcp,					/* RCP resource access privilege */
  2    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  2    23          3 pad bit (11);
  2    24 
  2    25 
  2    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      902 
      903  /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  3     2 
  3     3 
  3     4 
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  3     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  3     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  3    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  3    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  3    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  3    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  3    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  3    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18 
  3    19 /*
  3    20*   All disk packs have the standard layout described below:
  3    21*
  3    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  3    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  3    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  3    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  3    26*   Record  7		: formerly contained bad track list; no longer used.
  3    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  3    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  3    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  3    30*
  3    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  3    32*   of the particular partition.
  3    33*
  3    34*
  3    35*
  3    36*   A conceptual declaration for a disk pack could be:
  3    37*
  3    38*   dcl 1 disk_pack,
  3    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  3    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  3    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  3    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  3    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  3    44*   2 vtoc_array_records	(8 : n-1),
  3    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  3    46*   3 unused				bit(36 * 64),
  3    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  3    48*
  3    49*
  3    50*
  3    51*
  3    52**/
  3    53 
  3    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  3    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  3    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  3    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  3    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  3    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  3    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  3    61 		         fixed bin (17) int static options (constant);
  3    62 
  3    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  3    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  3    65 /* or the physical volume table entry (pvte) device type.		      */
  3    66 
  3    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  3    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  3    69 
  3    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  3    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  3    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  3    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  3    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  3    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  3    76 
  3    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      903 
      904  /* Begin include file ..... iox_modes.incl.pl1 */
  4     2 
  4     3 /* Written by C. D. Tavares, 03/17/75 */
  4     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  4     5 
  4     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  4     7     ("stream_input", "stream_output", "stream_input_output",
  4     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  4     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  4    10      "direct_input", "direct_output", "direct_update");
  4    11 
  4    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  4    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  4    14 
  4    15 dcl (Stream_input initial (1),
  4    16      Stream_output initial (2),
  4    17      Stream_input_output initial (3),
  4    18      Sequential_input initial (4),
  4    19      Sequential_output initial (5),
  4    20      Sequential_input_output initial (6),
  4    21      Sequential_update initial (7),
  4    22      Keyed_sequential_input initial (8),
  4    23      Keyed_sequential_output initial (9),
  4    24      Keyed_sequential_update initial (10),
  4    25      Direct_input initial (11),
  4    26      Direct_output initial (12),
  4    27      Direct_update initial (13)) fixed bin int static options (constant);
  4    28 
  4    29 /* End include file ..... iox_modes.incl.pl1 */
      904 
      905  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  5     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  5     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  5     4 
  5     5 dcl  vtocep ptr;
  5     6 
  5     7 dcl 1 vtoce based (vtocep) aligned,
  5     8 
  5     9 
  5    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  5    11 
  5    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  5    13 
  5    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  5    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  5    16     2 records bit (9),				/* number of records used by the seg in second storage */
  5    17     2 pad2 bit (9),
  5    18 
  5    19     2 dtu bit (36),					/* date and time segment was last used */
  5    20 
  5    21     2 dtm bit (36),					/* date and time segment was last modified */
  5    22 
  5    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  5    24     2 deciduous bit (1),				/* true if hc_sdw */
  5    25     2 nid bit (1),					/* no incremental dump switch */
  5    26     2 dnzp bit (1),					/* Dont null zero pages */
  5    27     2 gtpd bit (1),					/* Global transparent paging device */
  5    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  5    29     2 damaged bit (1),				/* TRUE if contents damaged */
  5    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  5    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  5    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  5    33     2 pad3 bit (8),
  5    34     2 dirsw bit (1),				/* directory switch */
  5    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  5    36     2 pad4 bit (16)) unaligned,			/* not used */
  5    37 
  5    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  5    39 
  5    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  5    41 
  5    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  5    43 
  5    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  5    45 
  5    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  5    47 
  5    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  5    49 
  5    50 
  5    51 
  5    52 
  5    53 
  5    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  5    55 
  5    56     2 pad6 (10) bit (36),				/* not used */
  5    57 
  5    58     2 ncd bit (1),					/* no complete dump switch */
  5    59     2 pad7 bit (17),
  5    60     2 pad8 bit (18),
  5    61 
  5    62     2 dtd bit (36),					/* date-time-dumped */
  5    63 
  5    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  5    65 
  5    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  5    67 
  5    68 
  5    69 
  5    70 
  5    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  5    72 
  5    73     2 primary_name char (32),				/* primary name of the segment */
  5    74 
  5    75     2 time_created bit (36),				/* time the segment was created */
  5    76 
  5    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  5    78 
  5    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  5    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  5    81 
  5    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  5    83 
  5    84     2 access_class bit (72),				/* access class in branch */
  5    85     2 perm_flags aligned,
  5    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  5    87       3 pad9 bit (35) unal,
  5    88     2 owner bit (36);				/* pvid of this volume */
  5    89 
  5    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  5    91 
  5    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  5    93     2 pad1 bit (7*36),
  5    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  5    95     2 pad2 bit (184*36);
  5    96 
  5    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      905 
      906 
      907 end sweep_pv;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/08/88  1039.4  sweep_pv.pl1                      >spec>install>1033>sweep_pv.pl1
901          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
902          2    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
903          3    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
904          4    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
905          5    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EF_open                                constant        fixed bin(17,0)          initial dcl 111 ref 678
GC_open                                constant        fixed bin(17,0)          initial dcl 112 ref 340
LS_open                                constant        fixed bin(17,0)          initial dcl 113 ref 334
MAX_VTOCE_PER_PACK                     constant        fixed bin(17,0)          initial dcl 3-54 ref 245
SMA_ACCESS                             constant        bit(3)                   initial packed unaligned dcl 1-11 ref 316
Stream_output                   000122 constant        fixed bin(17,0)          initial dcl 4-15 set ref 533*
a_code                                 parameter       fixed bin(35,0)          dcl 786 in procedure "cvuid_recurse" set ref 784
                                                                                  801* 802 803 810* 811 814* 815 818*
a_code                                 parameter       fixed bin(35,0)          dcl 770 in procedure "cv_uid_path" set ref 768 780*
a_lev                                  parameter       fixed bin(17,0)          dcl 786 ref 784 805
a_pn                                   parameter       char                     packed unaligned dcl 786 in procedure
                                                                                  "cvuid_recurse" set ref 784 801*
a_pn                                   parameter       char                     packed unaligned dcl 770 in procedure "cv_uid_path"
                                                                                  set ref 768 780*
a_uid                                  parameter       bit(36)                  packed unaligned dcl 786 in procedure
                                                                                  "cvuid_recurse" set ref 784 801*
a_uid                                  parameter       bit(36)                  packed unaligned dcl 770 in procedure "cv_uid_path"
                                                                                  set ref 768 780*
a_uidp                                 parameter       pointer                  dcl 786 set ref 784 801* 807 808
a_uidpp                                parameter       pointer                  dcl 770 set ref 768 775 778 780*
aa_code                                parameter       fixed bin(35,0)          dcl 825 set ref 821 837* 838 842 843* 846 848* 849
abits                                  parameter       bit(3)                   packed unaligned dcl 825 ref 821 836
ac_lev                                 parameter       fixed bin(17,0)          dcl 826 set ref 821 839* 848
ac_pn                                  parameter       char                     packed unaligned dcl 825 set ref 821 833* 839*
acla                            000100 automatic       structure                array level 1 dcl 44 set ref 837 837 837 837 893 893
                                                                                  893 893
addr                                                   builtin function         dcl 167 ref 363 377 377 422 422 810 810 837 837 893
                                                                                  893
adopt_seg_                      000034 constant        entry                    external dcl 130 ref 400
adopting                        000112 automatic       bit(1)                   packed unaligned dcl 48 set ref 242* 278* 293 343
                                                                                  389 753
allocarea                              based           area(1024)               dcl 103 ref 868 894
aname                                  parameter       char(32)                 packed unaligned dcl 548 ref 546 552 552 552 554
areap                           000114 automatic       pointer                  dcl 49 set ref 313* 868 894
arg                                    based           char                     packed unaligned dcl 102 set ref 205 214 216* 263
                                                                                  275 275 276 276 277 277 278 279 279 280 280 281
                                                                                  282 283 284 284 286* 700 711* 713*
argl                            000116 automatic       fixed bin(17,0)          dcl 50 set ref 204* 205 213* 214 216 216 262* 263
                                                                                  274* 275 275 276 276 277 277 278 279 279 280 280
                                                                                  281 282 283 284 284 286 286 700 705* 711 711 713
                                                                                  713
argp                            000120 automatic       pointer                  dcl 51 set ref 204* 205 213* 214 216 262* 263 274*
                                                                                  275 275 276 276 277 277 278 279 279 280 280 281
                                                                                  282 283 284 284 286 700 705* 711 713
atdesc                          000764 automatic       char(57)                 packed unaligned dcl 519 set ref 524* 526* 539 539
b_lev                                  parameter       fixed bin(17,0)          dcl 862 ref 855 864 870 872
b_pn                                   parameter       char                     packed unaligned dcl 862 ref 855 867 867 871
cd                                     parameter       fixed bin(35,0)          dcl 667 set ref 659 670*
chainptrs                       000122 automatic       pointer                  array dcl 52 set ref 314* 864 870 872* 889 889 890
checksum                        000162 automatic       bit(36)                  dcl 53 set ref 422* 423
cleanup                         000726 stack reference condition                dcl 183 ref 310
clock                                                  builtin function         dcl 168 ref 331 331 656 656
code                            000163 automatic       fixed bin(35,0)          dcl 54 set ref 193* 194 195* 204* 206* 207 208* 213*
                                                                                  223* 225* 229 230* 249* 250 251* 262* 264* 265
                                                                                  266* 274* 300* 302 303* 322* 323 366* 367 370 372*
                                                                                  372* 377* 378 382 382 383 390 425 445* 445* 472
                                                                                  668 705* 706 707* 711* 712
code1                           000164 automatic       fixed bin(35,0)          dcl 55 set ref 400* 403 411* 411* 425* 427* 428 431*
                                                                                  431* 437* 438 474* 475* 476* 477 479* 479*
codea                           001003 automatic       fixed bin(35,0)          dcl 520 set ref 526* 527 528* 533* 534 535*
com_err_                        000036 constant        entry                    external dcl 131 ref 195 208 216 230 251 266 286 303
                                                                                  319 505 528 535 707 713 726
convert_status_code_            000040 constant        entry                    external dcl 132 ref 670
csl                             001032 automatic       fixed bin(17,0)          dcl 580 in procedure "validate_vtoce" set ref 590*
                                                                                  595* 606 608* 614
csl                       2(09)        based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 5-7 in procedure "sweep_pv" ref 422 422 606
                                                                                  608 608
cu_$arg_count                   000042 constant        entry                    external dcl 133 ref 193 249
cu_$arg_ptr                     000044 constant        entry                    external dcl 134 ref 204 213 262 274 705
cv_oct_check_                   000046 constant        entry                    external dcl 135 ref 711
damaged                   5(06)        based           bit(1)                   level 2 packed packed unaligned dcl 5-7 ref 456
damaged_ct                      000165 automatic       fixed bin(17,0)          dcl 56 set ref 244* 466* 466 744 746* 746
date                            001216 automatic       char(24)                 packed unaligned dcl 686 set ref 688* 689
date_time_                      000050 constant        entry                    external dcl 136 ref 331
date_time_$format               000052 constant        entry                    external dcl 137 ref 656
date_time_$fstime               000054 constant        entry                    external dcl 138 ref 688
dbsw                            000166 automatic       bit(1)                   packed unaligned dcl 57 set ref 242* 280* 296 475
del_this                        000167 automatic       bit(1)                   packed unaligned dcl 58 set ref 395* 415* 418* 420
deleted                         000170 automatic       bit(1)                   packed unaligned dcl 59 set ref 376* 419* 489* 489*
dim                                                    builtin function         dcl 169 ref 837 837 893 893
dir                             000100 automatic       char(168)                packed unaligned dcl 827 in procedure
                                                                                  "giver_of_access" set ref 833* 837* 848*
dir                             000171 automatic       char(168)                packed unaligned dcl 60 in procedure "sweep_pv" set
                                                                                  ref 398* 400* 401 401* 402 474* 476*
dirsw                     5(18)        based           bit(1)                   level 2 packed packed unaligned dcl 5-7 ref 489
dl_mode                         000243 automatic       bit(1)                   packed unaligned dcl 61 set ref 242* 279* 292 344
                                                                                  393 420
dswitch                         000244 automatic       pointer                  dcl 62 set ref 247* 337* 338* 385* 387* 391* 393*
                                                                                  405* 410 430 751* 753* 754* 755*
dtm                       4            based           bit(36)                  level 2 packed packed unaligned dcl 5-7 set ref 387*
                                                                                  387*
dts4                                   defined         char(4)                  packed unaligned dcl 63 set ref 524*
dtstart                         000246 automatic       char(24)                 packed unaligned dcl 64 set ref 331* 338* 524 524
                                                                                  564* 680*
dtu                       3            based           bit(36)                  level 2 packed packed unaligned dcl 5-7 set ref 387*
                                                                                  387*
ent                             000152 automatic       char(32)                 packed unaligned dcl 827 in procedure
                                                                                  "giver_of_access" set ref 833* 837*
ent                             000254 automatic       char(32)                 packed unaligned dcl 65 in procedure "sweep_pv" set
                                                                                  ref 399* 400* 402 474* 476*
error_mess                      001033 automatic       char(200)                packed unaligned dcl 581 set ref 601* 603* 608* 610*
                                                                                  616* 618*
error_mess_len                  001115 automatic       fixed bin(21,0)          dcl 582 set ref 601* 608* 616*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 117 ref 668 818
error_table_$bad_uidpath        000014 external static fixed bin(35,0)          dcl 119 ref 425
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 118 set ref 216* 286*
error_table_$inconsistent       000016 external static fixed bin(35,0)          dcl 120 set ref 726*
error_table_$incorrect_access   000020 external static fixed bin(35,0)          dcl 121 ref 803 843 846
error_table_$invalid_vtocx      000022 external static fixed bin(35,0)          dcl 122 ref 370
error_table_$no_dir             000024 external static fixed bin(35,0)          dcl 123 ref 382 390
error_table_$noentry            000026 external static fixed bin(35,0)          dcl 124 ref 382 383
error_table_$not_privileged     000030 external static fixed bin(35,0)          dcl 125 set ref 505*
error_table_$root               000032 external static fixed bin(35,0)          dcl 126 ref 842
eswitch                         000264 automatic       pointer                  dcl 66 set ref 247* 372* 410 430 445* 462 479* 636
                                                                                  679* 680* 744 748* 749*
excuse                          000266 automatic       char(10)                 packed unaligned dcl 67 set ref 383* 383* 385* 489*
expand_pathname_                000056 constant        entry                    external dcl 139 ref 398 474 833 892
filemap_checksum_               000060 constant        entry                    external dcl 140 ref 422
fixed                                                  builtin function         dcl 170 ref 422 422 440 599 601 601 606 608 608 614
                                                                                  614 616 616
flag                                   parameter       bit(1)                   packed unaligned dcl 702 set ref 696 716*
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 5-7 set
                                                                                  ref 422 422 593
fm_checksum               6            based           bit(36)                  level 2 dcl 5-7 ref 423
fm_checksum_valid         5(08)        based           bit(1)                   level 2 packed packed unaligned dcl 5-7 ref 421
fm_damaged                5(07)        based           bit(1)                   level 2 packed packed unaligned dcl 5-7 set ref 421
                                                                                  423* 425
fmx                             001116 automatic       fixed bin(17,0)          dcl 583 set ref 592* 593 595*
force                           000271 automatic       bit(1)                   packed unaligned dcl 68 set ref 242* 284* 312 740
                                                                                  806
fp                                     based           pointer                  level 2 packed packed unaligned dcl 104 set ref 865
                                                                                  870* 891
fromsw                          000272 automatic       bit(1)                   packed unaligned dcl 69 set ref 242* 281* 294 295
fs_time                                parameter       bit(36)                  packed unaligned dcl 685 ref 684 688
fv                              000273 automatic       fixed bin(17,0)          dcl 70 set ref 244* 281* 283* 295 338* 365 564*
gc_comment                      000274 automatic       char(20)                 packed unaligned dcl 71 set ref 343* 344* 345* 385*
gcsw                            000301 automatic       bit(1)                   packed unaligned dcl 72 set ref 242* 275* 292 293
                                                                                  296 336 384 751 754 755
get_group_id_                   000062 constant        entry                    external dcl 141 ref 315
get_system_free_area_           000064 constant        entry                    external dcl 142 ref 313
hbound                                                 builtin function         dcl 171 ref 889
hcs_$add_dir_acl_entries        000066 constant        entry                    external dcl 143 ref 837
hcs_$delete_dir_acl_entries     000070 constant        entry                    external dcl 144 ref 893
head                                   parameter       char                     packed unaligned dcl 522 set ref 513 524* 526 528*
                                                                                  535*
hphcs_$clear_vtoce              000072 constant        entry                    external dcl 145 ref 425
hphcs_$delete_vtoce             000074 constant        entry                    external dcl 146 ref 427
hphcs_$pv_move_file             000076 constant        entry                    external dcl 147 ref 476
hphcs_$stop_vacate_pv           000100 constant        entry                    external dcl 148 ref 225
hphcs_$vacate_pv                000102 constant        entry                    external dcl 149 ref 223 300
i                               000302 automatic       fixed bin(17,0)          dcl 73 set ref 273* 274* 704* 704 705*
ignore                          001146 automatic       char(8)                  dcl 667 set ref 670*
inhibit_on                      000303 automatic       bit(1)                   packed unaligned dcl 74 set ref 191* 214* 223 230
ioa_                            000104 constant        entry                    external dcl 150 ref 200 256 306 539 738
ioa_$ioa_switch                 000106 constant        entry                    external dcl 151 ref 338 372 385 387 391 393 405 411
                                                                                  431 445 463 479 489 564 566 568 637 680 746 751
                                                                                  753 757
ioa_$rsnnl                      000110 constant        entry                    external dcl 152 ref 524 601 608 616
iox_$attach_ioname              000112 constant        entry                    external dcl 153 ref 526
iox_$close                      000114 constant        entry                    external dcl 154 ref 748 754 759
iox_$detach_iocb                000116 constant        entry                    external dcl 155 ref 749 755 760
iox_$open                       000120 constant        entry                    external dcl 156 ref 533
iox_$user_output                000122 external static pointer                  dcl 157 ref 744
key                             001232 automatic       char(10)                 initial packed unaligned dcl 700 set ref 700* 707*
                                                                                  713*
lastv                           000304 automatic       fixed bin(17,0)          dcl 75 set ref 245* 282* 283* 295 338* 365 564*
lbound                                                 builtin function         dcl 172 ref 889
length                                                 builtin function         dcl 173 ref 552 867
lev                             000153 automatic       fixed bin(17,0)          dcl 787 in procedure "cvuid_recurse" set ref 805*
                                                                                  807 809 810* 814*
lev                             000110 automatic       fixed bin(17,0)          dcl 885 in procedure "restore_all_access" set ref
                                                                                  889* 890*
lev                             001252 automatic       fixed bin(17,0)          dcl 772 in procedure "cv_uid_path" set ref 775* 775*
                                                                                  778 778* 780*
linkage_error                   000734 stack reference condition                dcl 184 ref 221 227 299 301 318 324
listopt                         000305 automatic       bit(1)                   packed unaligned dcl 76 set ref 242* 276* 296 333
                                                                                  457 487 631 757 759 760
llines                          000306 automatic       fixed bin(17,0)          dcl 77 set ref 244* 459* 459 491* 491 563 569* 569
                                                                                  633* 633
local_vtoce                     000307 automatic       structure                level 1 dcl 78 set ref 363
locuidpth                       000154 automatic       bit(36)                  array dcl 788 set ref 808* 809* 810 810
long                            001150 automatic       char(100)                dcl 667 set ref 670* 671
lpn                             000100 automatic       char(168)                packed unaligned dcl 787 set ref 810* 814*
lswitch                         000610 automatic       pointer                  dcl 79 set ref 247* 333* 462 489* 564* 566* 568* 636
                                                                                  744 757* 759* 760*
luid                            000152 automatic       bit(36)                  packed unaligned dcl 787 set ref 807* 810*
message                                parameter       char                     packed unaligned dcl 723 in procedure "checkincon"
                                                                                  set ref 721 726*
message                                parameter       char                     packed unaligned dcl 628 in procedure "report_error"
                                                                                  set ref 625 637*
mod                                                    builtin function         dcl 174 ref 563
modes                    10     000100 automatic       bit(36)                  array level 2 dcl 44 set ref 316* 836*
msl                       2            based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 5-7 in procedure "sweep_pv" ref 614 614 616
                                                                                  616
msl                             001117 automatic       fixed bin(17,0)          dcl 584 in procedure "validate_vtoce" set ref 591*
                                                                                  592 614
myname                          000612 automatic       char(32)                 packed unaligned dcl 80 set ref 190* 195* 200* 200*
                                                                                  208* 216* 230* 239* 251* 256* 256* 266* 286* 303*
                                                                                  306* 319* 505* 528* 535* 539* 707* 713* 726*
n_args                          000623 automatic       fixed bin(17,0)          dcl 82 set ref 193* 199 199 212 249* 255 273
name                      1(09)        based           char                     level 2 in structure "restore_name" packed packed
                                                                                  unaligned dcl 104 in procedure "sweep_pv" set ref
                                                                                  871* 892*
name                                   parameter       char                     packed unaligned dcl 522 in procedure "attach" set
                                                                                  ref 513 539*
namealloclen                    000622 automatic       fixed bin(17,0)          dcl 81 set ref 867* 868 868 869
namelen                   1            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 104 set ref 868*
                                                                                  869* 871 892 892 894
namp                            000172 automatic       pointer                  dcl 863 in procedure "register_pn" set ref 864* 864*
                                                                                  865 866 868* 869 870 871 872
namp                            000174 automatic       pointer                  dcl 887 in procedure "restore_all_access" set ref
                                                                                  890* 890* 891 892 894*
null                                                   builtin function         dcl 175 ref 247 314 463 637 746 864 866 890
onlysw                          000624 automatic       bit(1)                   packed unaligned dcl 83 set ref 242* 283* 294
pageno                          000625 automatic       fixed bin(17,0)          dcl 84 set ref 246* 564* 567* 567
pc1                             000174 automatic       fixed bin(17,0)          dcl 789 set ref 800* 804 813*
pc2                             000162 automatic       fixed bin(17,0)          dcl 828 set ref 835* 847*
phcs_$get_vtoce                 000124 constant        entry                    external dcl 158 ref 366
pman                            000176 automatic       pointer                  dcl 887 set ref 891* 895
pn                              000626 automatic       char(168)                packed unaligned dcl 85 set ref 377* 385* 393* 398*
                                                                                  402* 405* 411* 431* 445* 463* 474* 479* 489* 601*
                                                                                  608* 616*
primary_name            260            based           char(32)                 level 2 packed packed unaligned dcl 5-7 set ref 387*
                                                                                  399*
pvid                            000700 automatic       bit(36)                  dcl 86 set ref 206* 223* 225* 264* 300* 400* 425*
                                                                                  427*
pvname                          000701 automatic       char(32)                 packed unaligned dcl 87 set ref 205* 206* 208* 230*
                                                                                  263* 264* 266* 303* 306* 338* 524* 564* 680*
pvname_to_pvtx_                 000126 constant        entry                    external dcl 159 ref 206 264
pvtx                            000711 automatic       fixed bin(17,0)          dcl 88 set ref 206* 223* 225* 264* 300* 366* 400*
rdir                            000111 automatic       char(168)                packed unaligned dcl 886 set ref 892* 893*
records                   2(18)        based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 5-7 in procedure "sweep_pv" ref 440 599 601
                                                                                  601
records                         001120 automatic       fixed bin(17,0)          dcl 585 in procedure "validate_vtoce" set ref 590*
                                                                                  594* 594 599 601*
recsgotten                      000712 automatic       fixed bin(17,0)          dcl 89 set ref 244* 440* 440 751*
rent                            000163 automatic       char(32)                 packed unaligned dcl 886 set ref 892* 893*
restore_name                           based           structure                level 1 dcl 104 set ref 868 894
reverse                                                builtin function         dcl 176 ref 867
rstate                          000713 automatic       fixed bin(17,0)          dcl 90 set ref 244* 334* 340* 531* 531 538* 538 678
                                                                                  742
rtrim                                                  builtin function         dcl 177 ref 402 552 554
seg_vtoce                              based           structure                level 1 dcl 5-92
set_priv                        000714 automatic       bit(1)                   packed unaligned dcl 91 set ref 242* 323* 739
started                         000715 automatic       bit(1)                   packed unaligned dcl 92 set ref 242* 362* 736
stuff                           001235 automatic       fixed bin(17,0)          dcl 701 set ref 711* 717
substr                                                 builtin function         dcl 178 ref 539 539 552 552 593
system_privilege_$dir_priv_off  000130 constant        entry                    external dcl 160 ref 739
system_privilege_$dir_priv_on   000132 constant        entry                    external dcl 161 ref 322
tosw                            000716 automatic       bit(1)                   packed unaligned dcl 93 set ref 242* 282* 294 295
tptr                                   parameter       pointer                  dcl 521 in procedure "attach" set ref 513 526* 533*
tptr                            000720 automatic       pointer                  dcl 94 in procedure "sweep_pv" set ref 410* 411*
                                                                                  430* 431* 462* 463 463* 636* 637 637* 744* 746
                                                                                  746*
truth                                  parameter       bit(1)                   packed unaligned dcl 723 ref 721 725
uid                       1            based           bit(36)                  level 2 packed packed unaligned dcl 5-7 set ref 368*
                                                                                  375 377* 427*
uid_path                240            based           bit(36)                  array level 2 packed packed unaligned dcl 5-7 set
                                                                                  ref 377 377
uidpth                                 based           bit(36)                  array dcl 789 in procedure "cvuid_recurse" ref 807
                                                                                  808
uidpth                                 based           bit(36)                  array dcl 773 in procedure "cv_uid_path" ref 775 778
uname                           001012 automatic       char(15)                 packed unaligned dcl 549 set ref 551* 552 554
unique_chars_                   000134 constant        entry                    external dcl 162 ref 551
usage                     7            based           fixed bin(35,0)          level 2 dcl 5-92 set ref 489*
userid                          000100 automatic       char(32)                 array level 2 dcl 44 set ref 315*
vacating                        000722 automatic       bit(1)                   packed unaligned dcl 95 set ref 242* 277* 296 298
                                                                                  471
verify                                                 builtin function         dcl 179 ref 867
vpn_cv_uid_path_$ent            000136 constant        entry                    external dcl 163 ref 801
vsgotten                        000723 automatic       fixed bin(17,0)          dcl 96 set ref 244* 439* 439 751*
vsrecovered                     000724 automatic       fixed bin(17,0)          dcl 97 set ref 244* 404* 404 753*
vtoce                                  based           structure                level 1 dcl 5-7
vtocep                          000742 automatic       pointer                  dcl 5-5 set ref 363* 366* 368 375 377 377 377 387
                                                                                  387 387 387 387 399 421 421 422 422 422 422 423
                                                                                  423 425 427 440 456 489 489 593 599 601 601 606
                                                                                  608 608 614 614 616 616
vtocx                           000725 automatic       fixed bin(17,0)          dcl 98 set ref 365* 366* 372* 385* 400* 405* 411*
                                                                                  425* 427* 431* 445* 463* 479* 489* 496* 496 601*
                                                                                  608* 616* 738* 757*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 3-54
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 3-54
Direct_input                           internal static fixed bin(17,0)          initial dcl 4-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 4-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 4-15
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 4-15
LABEL_ADDR                             internal static fixed bin(17,0)          initial dcl 3-54
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 3-67
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 3-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 3-70
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 4-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 4-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 4-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 4-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 4-15
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 3-54
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 3-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 3-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 3-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 3-54
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
aim_template                           based           structure                level 1 dcl 2-12
iox_modes                              internal static char(24)                 initial array dcl 4-6
short_iox_modes                        internal static char(4)                  initial array dcl 4-12
vtoce_parts                            based           bit(2304)                array dcl 5-90

NAMES DECLARED BY EXPLICIT CONTEXT.
NOT_PRIVILEGED                  004173 constant        label                    dcl 505 ref 221 299
a                               003577 constant        label                    dcl 444 ref 384
attach                          004217 constant        entry                    internal dcl 513 ref 333 337 679
checkincon                      005673 constant        entry                    internal dcl 721 ref 292 293 294 295 296
ckef                            005417 constant        entry                    internal dcl 674 ref 371 409 429 444 461 478 635
cktop                           004625 constant        entry                    internal dcl 559 ref 458 488 632
cv_uid_path                     006322 constant        entry                    internal dcl 768 ref 377
cvuid_recurse                   006412 constant        entry                    internal dcl 784 ref 780 810
dtc                             005463 constant        entry                    internal dcl 684 ref 387 387 387 387
einterp                         005364 constant        entry                    internal dcl 659 ref 372 372 411 411 431 431 445 445
                                                                                  479 479
fin                             004166 constant        label                    dcl 499 ref 370 529 536
finish                          005737 constant        entry                    internal dcl 735 ref 310 499
gen_uname                       004527 constant        entry                    internal dcl 546 ref 399
giver_of_access                 006614 constant        entry                    internal dcl 821 ref 814 848
inhibit_pv                      001012 constant        entry                    external dcl 188
nlexit                          004166 constant        label                    dcl 499 ref 708 714 727
numarg                          005514 constant        entry                    internal dcl 696 ref 281 282 283
register_pn                     007022 constant        entry                    internal dcl 855 ref 839
report_error                    005233 constant        entry                    internal dcl 625 ref 603 610 618
restore_all_access              007133 constant        entry                    internal dcl 883 ref 740
revert_handler                  002404 constant        label                    dcl 324 ref 320
rrecover                        000000 constant        label                    array(0:6) dcl 744 ref 742
spv                             001371 constant        label                    dcl 239 ref 16
sweep_pv                        001003 constant        entry                    external dcl 14
time                            005315 constant        entry                    internal dcl 652 ref 372 372 385 385 411 411 431 431
                                                                                  445 445 463 463 479 479 601 601 608 608 616 616
validate_vtoce                  004737 constant        entry                    internal dcl 577 ref 452

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10302       10442    7507       10312
Length     11070    7507       140         411     572           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sweep_pv                           1298 external procedure  is an external procedure.  
on unit on line 221                  64 on unit               
on unit on line 299                  64 on unit               
on unit on line 310                  64 on unit               
on unit on line 318                  94 on unit               
attach                                  internal procedure  shares stack frame of external procedure sweep_pv.  
gen_uname                               internal procedure  shares stack frame of external procedure sweep_pv.  
cktop                                   internal procedure  shares stack frame of external procedure sweep_pv.  
validate_vtoce                          internal procedure  shares stack frame of external procedure sweep_pv.  
report_error                            internal procedure  shares stack frame of external procedure sweep_pv.  
time                                    internal procedure  shares stack frame of external procedure sweep_pv.  
einterp                                 internal procedure  shares stack frame of external procedure sweep_pv.  
ckef                                    internal procedure  shares stack frame of external procedure sweep_pv.  
dtc                                     internal procedure  shares stack frame of external procedure sweep_pv.  
numarg                                  internal procedure  shares stack frame of external procedure sweep_pv.  
checkincon                              internal procedure  shares stack frame of external procedure sweep_pv.  
finish                              210 internal procedure  is called by several nonquick procedures.  
cv_uid_path                             internal procedure  shares stack frame of external procedure sweep_pv.  
cvuid_recurse                       171 internal procedure  calls itself recursively.  
giver_of_access                     172 internal procedure  calls itself recursively.  
register_pn                             internal procedure  shares stack frame of internal procedure giver_of_access.  
restore_all_access                      internal procedure  shares stack frame of internal procedure finish.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cvuid_recurse            000100 lpn                         cvuid_recurse
                         000152 luid                        cvuid_recurse
                         000153 lev                         cvuid_recurse
                         000154 locuidpth                   cvuid_recurse
                         000174 pc1                         cvuid_recurse
finish                   000110 lev                         restore_all_access
                         000111 rdir                        restore_all_access
                         000163 rent                        restore_all_access
                         000174 namp                        restore_all_access
                         000176 pman                        restore_all_access
giver_of_access          000100 dir                         giver_of_access
                         000152 ent                         giver_of_access
                         000162 pc2                         giver_of_access
                         000172 namp                        register_pn
sweep_pv                 000100 acla                        sweep_pv
                         000112 adopting                    sweep_pv
                         000114 areap                       sweep_pv
                         000116 argl                        sweep_pv
                         000120 argp                        sweep_pv
                         000122 chainptrs                   sweep_pv
                         000162 checksum                    sweep_pv
                         000163 code                        sweep_pv
                         000164 code1                       sweep_pv
                         000165 damaged_ct                  sweep_pv
                         000166 dbsw                        sweep_pv
                         000167 del_this                    sweep_pv
                         000170 deleted                     sweep_pv
                         000171 dir                         sweep_pv
                         000243 dl_mode                     sweep_pv
                         000244 dswitch                     sweep_pv
                         000246 dtstart                     sweep_pv
                         000254 ent                         sweep_pv
                         000264 eswitch                     sweep_pv
                         000266 excuse                      sweep_pv
                         000271 force                       sweep_pv
                         000272 fromsw                      sweep_pv
                         000273 fv                          sweep_pv
                         000274 gc_comment                  sweep_pv
                         000301 gcsw                        sweep_pv
                         000302 i                           sweep_pv
                         000303 inhibit_on                  sweep_pv
                         000304 lastv                       sweep_pv
                         000305 listopt                     sweep_pv
                         000306 llines                      sweep_pv
                         000307 local_vtoce                 sweep_pv
                         000610 lswitch                     sweep_pv
                         000612 myname                      sweep_pv
                         000622 namealloclen                sweep_pv
                         000623 n_args                      sweep_pv
                         000624 onlysw                      sweep_pv
                         000625 pageno                      sweep_pv
                         000626 pn                          sweep_pv
                         000700 pvid                        sweep_pv
                         000701 pvname                      sweep_pv
                         000711 pvtx                        sweep_pv
                         000712 recsgotten                  sweep_pv
                         000713 rstate                      sweep_pv
                         000714 set_priv                    sweep_pv
                         000715 started                     sweep_pv
                         000716 tosw                        sweep_pv
                         000720 tptr                        sweep_pv
                         000722 vacating                    sweep_pv
                         000723 vsgotten                    sweep_pv
                         000724 vsrecovered                 sweep_pv
                         000725 vtocx                       sweep_pv
                         000742 vtocep                      sweep_pv
                         000764 atdesc                      attach
                         001003 codea                       attach
                         001012 uname                       gen_uname
                         001032 csl                         validate_vtoce
                         001033 error_mess                  validate_vtoce
                         001115 error_mess_len              validate_vtoce
                         001116 fmx                         validate_vtoce
                         001117 msl                         validate_vtoce
                         001120 records                     validate_vtoce
                         001146 ignore                      einterp
                         001150 long                        einterp
                         001216 date                        dtc
                         001232 key                         numarg
                         001235 stuff                       numarg
                         001252 lev                         cv_uid_path

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac
tra_ext_1           mdfx1               enable_op           shorten_stack       ext_entry           int_entry
int_entry_desc      op_alloc_           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adopt_seg_                    com_err_                      convert_status_code_          cu_$arg_count
cu_$arg_ptr                   cv_oct_check_                 date_time_                    date_time_$format
date_time_$fstime             expand_pathname_              filemap_checksum_             get_group_id_
get_system_free_area_         hcs_$add_dir_acl_entries      hcs_$delete_dir_acl_entries   hphcs_$clear_vtoce
hphcs_$delete_vtoce           hphcs_$pv_move_file           hphcs_$stop_vacate_pv         hphcs_$vacate_pv
ioa_                          ioa_$ioa_switch               ioa_$rsnnl                    iox_$attach_ioname
iox_$close                    iox_$detach_iocb              iox_$open                     phcs_$get_vtoce
pvname_to_pvtx_               system_privilege_$dir_priv_off                              system_privilege_$dir_priv_on
unique_chars_                 vpn_cv_uid_path_$ent

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_uidpath      error_table_$badopt
error_table_$inconsistent     error_table_$incorrect_access error_table_$invalid_vtocx    error_table_$no_dir
error_table_$noentry          error_table_$not_privileged   error_table_$root             iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 001002        16 001010       188 001011       190 001017       191 001022       193 001024       194 001035
    195 001037       196 001054       199 001055       200 001061       201 001103       204 001104       205 001123
    206 001130       207 001155       208 001157       209 001177       212 001200       213 001203       214 001222
    216 001232       217 001256       221 001257       223 001276       225 001314       227 001327       229 001330
    230 001332       232 001367       235 001370       239 001371       242 001374       244 001410       245 001417
    246 001421       247 001423       249 001427       250 001437       251 001441       252 001456       255 001457
    256 001461       259 001503       262 001504       263 001523       264 001530       265 001555       266 001557
    267 001577       273 001600       274 001607       275 001624       276 001641       277 001654       278 001667
    279 001676       280 001711       281 001724       282 001733       283 001742       284 001754       286 001767
    287 002013       290 002014       292 002016       293 002030       294 002045       295 002066       296 002110
    298 002135       299 002137       300 002156       301 002171       302 002172       303 002174       304 002223
    306 002224       310 002247       312 002271       313 002273       314 002302       315 002315       316 002324
    318 002326       319 002342       320 002367       322 002372       323 002401       324 002404       331 002405
    333 002424       334 002436       336 002440       337 002442       338 002455       339 002514       340 002515
    343 002517       344 002525       345 002533       362 002536       363 002540       365 002542       366 002551
    367 002566       368 002570       370 002572       371 002575       372 002576       375 002641       376 002644
    377 002645       378 002673       382 002675       383 002702       383 002710       384 002713       385 002715
    387 002763       389 003041       390 003043       391 003047       393 003066       395 003114       396 003116
    398 003117       399 003146       400 003157       401 003213       402 003222       403 003261       404 003264
    405 003265       407 003315       409 003316       410 003317       411 003323       413 003367       415 003375
    417 003376       418 003377       419 003401       420 003403       421 003407       422 003416       423 003437
    425 003445       427 003467       428 003503       429 003505       430 003506       431 003512       434 003556
    436 003564       437 003565       438 003566       439 003570       440 003571       442 003576       444 003577
    445 003600       452 003647       456 003650       457 003654       458 003656       459 003657       461 003660
    462 003661       463 003665       465 003741       466 003747       471 003750       472 003752       474 003755
    475 004001       476 004005       477 004026       478 004030       479 004031       487 004075       488 004077
    489 004100       491 004161       494 004162       496 004164       499 004166       502 004172       505 004173
    507 004216       513 004217       524 004235       526 004305       527 004351       528 004354       529 004406
    531 004407       533 004410       534 004430       535 004432       536 004467       538 004470       539 004471
    540 004526       546 004527       551 004531       552 004546       554 004606       559 004625       563 004626
    564 004632       566 004674       567 004714       568 004715       569 004734       572 004736       577 004737
    590 004740       591 004742       592 004744       593 004753       594 004761       595 004762       597 004765
    599 004767       601 004775       603 005053       606 005056       608 005064       610 005142       614 005145
    616 005155       618 005227       623 005232       625 005233       631 005244       632 005246       633 005247
    635 005250       636 005251       637 005255       639 005306       641 005314       652 005315       656 005317
    659 005364       668 005366       670 005377       671 005411       674 005417       678 005420       679 005423
    680 005432       682 005462       684 005463       688 005465       689 005506       696 005514       700 005516
    704 005523       705 005524       706 005541       707 005543       708 005573       711 005574       712 005620
    713 005622       714 005662       716 005663       717 005670       721 005673       725 005704       726 005712
    727 005734       729 005735       735 005736       736 005744       738 005747       739 005766       740 006001
    742 006005       744 006010       746 006016       747 006057       748 006077       749 006112       751 006125
    753 006157       754 006206       755 006223       757 006240       759 006267       760 006304       762 006321
    768 006322       775 006333       776 006343       778 006345       780 006356       781 006410       784 006411
    800 006425       801 006433       802 006462       803 006465       804 006470       805 006473       806 006476
    807 006501       808 006504       809 006510       810 006511       811 006544       812 006547       813 006550
    814 006552       815 006601       817 006604       818 006606       819 006612       821 006613       833 006627
    835 006655       836 006663       837 006671       838 006726       839 006731       840 006746       842 006747
    843 006752       844 006754       846 006755       847 006757       848 006762       849 007014       851 007017
    853 007021       855 007022       864 007033       865 007046       866 007051       867 007055       868 007077
    870 007114       871 007121       872 007131       874 007132       883 007133       889 007134       890 007140
    891 007150       892 007152       893 007210       894 007247       895 007257       896 007262       897 007265


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
