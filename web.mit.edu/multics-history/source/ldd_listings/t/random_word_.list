	COMPILATION LISTING OF SEGMENT random_word_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1749.4 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* This procedure generates a pronounceable random word of
        7*   caller specified length and returns the
        8*   word and the hyphenated (divided into syllables) form of the word.
        9*
       10*   dcl random_word_ entry ((0:*) fixed, (0:*) bit(1) aligned, fixed, fixed, entry, entry);
       11*
       12*   call random_word_ (word, hyphens, length, n, random_unit, random_vowel);
       13*
       14*   word          random word, 1 unit per array element. (Output)
       15*
       16*   hyphens       position of hyphens, bit on indicates hyphen appears after
       17*   corresponding unit in "word". (Input)
       18*
       19*   length        length of word to be generated in letters. (Input)
       20*
       21*   n             actual length of word in units. (Output)
       22*
       23*   random_unit   routine to be called to generate a random unit. (Input)
       24*
       25*   random_vowel  routine to be called to generate a random vowel. (Input)
       26*
       27**/
       28 
       29 random_word_: procedure (password, hyphenated_word, length, word_length, random_unit, random_vowel);
       30 
  1     1 
  1     2 /* ******** include file digram_structure.incl.pl1 ******* */
  1     3 
  1     4 dcl  digrams$digrams external;
  1     5 dcl  digrams$n_units fixed bin external;
  1     6 dcl  digrams$letters external;
  1     7 dcl  digrams$rules external;
  1     8 
  1     9 /* This array contains information about all possible pairs of units */
  1    10 
  1    11 dcl 1 digrams (n_units, n_units) based (addr (digrams$digrams)),
  1    12     2 begin bit (1),				/* on if this pair must begin syllable */
  1    13     2 not_begin bit (1),				/* on if this pair must not begin */
  1    14     2 end bit (1),					/* on if this pair must end syllable */
  1    15     2 not_end bit (1),				/* on if this pair must not end */
  1    16     2 break bit (1),				/* on if this pair is a break pair */
  1    17     2 prefix bit (1),				/* on if vowel must precede this pair in same syllable */
  1    18     2 suffix bit (1),				/* on if vowel must follow this pair in same syllable */
  1    19     2 illegal_pair bit (1),				/* on if this pair may not appear */
  1    20     2 pad bit (1);					/* this makes 9 bits/entry */
  1    21 
  1    22 /* This array contains left justified 1 or 2-letter pairs representing each unit */
  1    23 
  1    24 dcl  letters (0:n_units) char (2) aligned based (addr (digrams$letters));
  1    25 
  1    26 /* This is the same as letters, but allows reference to individual characters */
  1    27 
  1    28 dcl 1 letters_split (0:n_units) based (addr (digrams$letters)),
  1    29     2 first char (1),
  1    30     2 second char (1),
  1    31     2 pad char (2);
  1    32 
  1    33 /* This array has rules for each unit */
  1    34 
  1    35 dcl 1 rules (n_units) aligned based (addr (digrams$rules)),
  1    36     2 no_final_split bit (1),				/* can't be the only vowel in last syllable */
  1    37     2 not_begin_syllable bit (1),			/* can't begin a syllable */
  1    38     2 vowel bit (1),				/* this is a vowel */
  1    39     2 alternate_vowel bit (1);			/* this is an alternate vowel, (i.e., "y") */
  1    40 
  1    41 dcl  n_units defined digrams$n_units fixed bin;
  1    42 
  1    43 /* ******** end include file digram_structure.incl.pl1 *********** */
       31 
       32 dcl  debug bit (1) aligned static init ("0"b);		/* set for printout of words that can't be generated */
       33 dcl  password (0:*) fixed bin;
       34 dcl  hyphenated_word (0:*) bit (1) aligned;
       35 dcl  length fixed bin;
       36 dcl  word_length fixed bin;
       37 dcl  number float bin (27);
       38 dcl  nchars fixed;					/* number of characters in password */
       39 dcl  index fixed init (1);				/* index of current unit in password */
       40 dcl  i fixed;
       41 dcl  syllable_length fixed init (1);			/* 1 when next unit is 1st in syllable, 2 if 2nd, etc. */
       42 dcl  cons_count fixed init (0);			/* count of consecutive consonants in syllable preceeding current unit */
       43 dcl  vowel_found aligned bit (1);			/* 1 if vowel was found in syllable before this unit */
       44 dcl  last_vowel_found aligned bit (1);			/* same for previous unit in this syllable */
       45 dcl (first, second) fixed init (1);			/* index into digram table for current pair */
       46 dcl (random_unit, random_vowel) entry (fixed);
       47 dcl  unit fixed bin;
       48 dcl  ioa_$nnl entry options (variable);
       49 
       50 	do i = 0 to length;
       51 	     password (i) = 0;
       52 	     hyphenated_word (i) = "0"b;
       53 	end;
       54 	nchars = length;
       55 
       56 /* get rest of units in password */
       57 
       58 	unit = 0;
       59 	do index = 1 by 1 while (index <= nchars);
       60 	     if syllable_length = 1
       61 	     then
       62 		do;				/* on first unit of a syllable, use any unit */
       63 keep_trying:	unit = abs (unit);			/* last unit was accepted (or first in word), make positive */
       64 		goto first_time;
       65 retry:		unit = -abs (unit);			/* last unit was not accepted, make negative */
       66 first_time:
       67 		if index = nchars			/* if last unit of word must be a syllable, it must be a vowel */
       68 		then call random_vowel (unit);
       69 		else call random_unit (unit);
       70 		password (index) = abs (unit);	/* put actual unit in word */
       71 		if index ^= 1 then if digrams (password (index-1), password (index)).illegal_pair
       72 		     then goto retry;		/* this pair is illegal */
       73 		if rules (password (index)).not_begin_syllable then goto retry;
       74 		if letters_split.second (password (index)) ^= " "
       75 		then
       76 		     if index = nchars
       77 		     then goto retry;
       78 		     else
       79 		     if index = nchars-1 & ^rules (password (index)).vowel & ^rules (password (index)).alternate_vowel
       80 		     then goto retry;		/* last unit was a double-letter unit and not a vowel */
       81 		     else if unit < 0
       82 		     then goto keep_trying;
       83 		     else nchars = nchars - 1;
       84 		else if unit < 0 then goto keep_trying;
       85 		syllable_length = 2;
       86 		if rules (password (index)).vowel | rules (password (index)).alternate_vowel
       87 		then
       88 		     do;
       89 		     cons_count = 0;
       90 		     vowel_found = "1"b;
       91 		end;
       92 		else
       93 		do;
       94 		     cons_count = 1;
       95 		     vowel_found = "0"b;
       96 		end;
       97 		last_vowel_found = "0"b;
       98 	     end;
       99 	     else
      100 	     do;
      101 		call generate_unit;
      102 		if second = 0 then goto all_done;	/* we have word already */
      103 	     end;
      104 	end;
      105 
      106 /* enter here at end of word */
      107 
      108 all_done:
      109 	word_length = index - 1;
      110 	return;
      111 
      112 /* various other entries */
      113 
      114 debug_on:	entry;
      115 	debug = "1"b;
      116 	return;
      117 
      118 debug_off: entry;
      119 	debug = "0"b;
      120 	return;
      121 						/*
      122*						    */
      123 						/* PROCEDURE GENERATE_UNIT */
      124 
      125 /* generate next unit to password, making sure
      126*   that it follows these rules:
      127*   1. Each syllable must contain exactly 1 or 2 consecutive vowels,
      128*   where y is considered a vowel.
      129*   2. Syllable end is determined as follows:
      130*   a. Vowel is generated and previous unit is a consonant and
      131*   syllable already has a vowel.  In this case new syllable is
      132*   started and already contains a vowel.
      133*   b. A pair determined to be a "break" pair is encountered.
      134*   In this case new syllable is started with second unit of this pair.
      135*   c. End of password is encountered.
      136*   d. "begin" pair is encountered legally.  New syllable is started
      137*   with this pair.
      138*   e."end" pair is legally encountered.  New syllable has nothing yet.
      139*   3. Try generating another unit if:
      140*   a. third consecutive vowel and not y.
      141*   b. "break" pair generated but no vowel yet in current syllable
      142*   or previous 2 units are "not_end".
      143*   c. "begin" pair generated but no vowel in syllable preceeding
      144*   begin pair, or both previous 2 pairs are designated "not_end".
      145*   d. "end" pair generated but no vowel in current syllable or in "end" pair.
      146*   e. "not_begin" pair generated but new syllable must begin
      147*   (because previous syllable ended as defined in 2 above).
      148*   f. vowel is generated and 2a is satisfied, but no syllable break is possible in previous 3 pairs.
      149*   g. Second & third units of syllable must begin, and first unit is "alternate_vowel".
      150*
      151*   The done routine checks for required prefix vowels & end of word conditions. */
      152 
      153 generate_unit: procedure;
      154 dcl 1 x aligned like digrams;
      155 dcl  try_for_vowel bit (1) aligned;
      156 dcl  unit_count fixed init (1);			/* count of tries to generate this unit */
      157 dcl  v bit (1) aligned;
      158 dcl  i fixed;
      159 
      160 	     first = password (index-1);
      161 
      162 /* on last unit of word and no vowel yet in syllable, or if previous pair
      163*   requires a vowel and no vowel in syllable, then try only for a vowel */
      164 
      165 	     if syllable_length = 2			/* this is the second unit of syllable */
      166 	     then try_for_vowel = ^vowel_found & index = nchars; /* last unit of word and no vowel yet, try for vowel */
      167 	     else					/* this is at least the third unit of syllable */
      168 	     if ^vowel_found | digrams (password (index-2), first).not_end
      169 	     then try_for_vowel = digrams (password (index-2), first).suffix;
      170 	     else try_for_vowel = "0"b;
      171 	     goto keep_trying;			/* on first try of a unit, don't make the tests below */
      172 
      173 /* come here to try another unit when previous one was not accepted */
      174 
      175 try_more:
      176 	     unit = -abs (unit);			/* last unit was not accepted, set sign negative */
      177 	     if unit_count = 100
      178 	     then
      179 		do;
      180 		if debug
      181 		then
      182 		     do;
      183 		     call ioa_$nnl ("100 tries failed to generate unit.^/ password so far is: ");
      184 		     do i = 1 to index;
      185 			call ioa_$nnl ("^a", letters (password (i)));
      186 		     end;
      187 		     call ioa_$nnl ("^/");
      188 		end;
      189 		call random_word_ (password, hyphenated_word, length, index, random_unit, random_vowel);
      190 		second = 0;
      191 		return;
      192 	     end;
      193 
      194 /* come here to try another unit whether last one was accepted or not */
      195 
      196 keep_trying:
      197 	     if try_for_vowel
      198 	     then call random_vowel (unit);
      199 	     else call random_unit (unit);
      200 	     second = abs (unit);			/* save real value of unit number */
      201 	     if unit > 0 then unit_count = unit_count + 1; /* count number of tries */
      202 
      203 /* check if this pair is legal */
      204 
      205 	     if digrams (first, second).illegal_pair
      206 	     then goto try_more;
      207 	     else
      208 	     if first = second			/* if legal, throw out 3 in a row */
      209 	     then
      210 		if index >2
      211 		then
      212 		     if password (index-2) = first
      213 		     then goto try_more;
      214 	     if letters_split (second).second ^= " "	/* check if this is 2 letters */
      215 	     then
      216 		if index = nchars			/* then if this is the last unit of word */
      217 		then goto try_more;			/* then a two-letter unit is illegal */
      218 		else nchars = nchars - 1;		/* otherwise decrement number of characters */
      219 	     password (index) = second;
      220 	     if rules (second).alternate_vowel
      221 	     then v = ^rules (first).vowel;
      222 	     else v = rules (second).vowel;
      223 	     x.begin = digrams (first, second).begin;
      224 	     x.not_begin = digrams (first, second).not_begin;
      225 	     x.end = digrams (first, second).end;
      226 	     x.not_end = digrams (first, second).not_end;
      227 	     x.break = digrams (first, second).break;
      228 	     x.prefix = digrams (first, second).prefix;
      229 	     x.suffix = digrams (first, second).suffix;
      230 	     x.illegal_pair = digrams (first, second).illegal_pair;
      231 	     if syllable_length > 2			/* force break if last pair must be followed by a */
      232 	     then					/* vowel and this unit is not a vowel */
      233 		if digrams (password (index-2), first).suffix
      234 		then
      235 		     if ^v then break = "1"b;		/* (if last pair was not_end, new_unit gave us a vowel) */
      236 
      237 /* In the notation to the right, the series of letters and dots stands
      238*   for the last n units in this syllable, to be interpreted as follows:
      239*   v stands for a vowel (including alternate_vowel)
      240*   c stands for a consonant
      241*   x stands for any unit
      242*   the dots are interpreted as follows (c is used as example)
      243*   c...c  one or more consecutive consonants
      244*   c..c   zero or more consecutive consonants
      245*   ...c   one or more consecutive consonants from beginning of syllable
      246*   ..c    zero or more consecutive consonants from beginning of syllable
      247*   the vertical line | marks a syllable break.
      248*   The group of symbols indicates what units there are in current
      249*   syllable.  The last symbol is always the current unit.
      250*   The first symbol is not necessarily the first unit in the
      251*   syllable, unless preceeded by dots.  Thus, "vcc..cv" should be
      252*   interpreted as "..xvcc..cv" (i.e., add "..x" to the beginning of all
      253*   syllables unless dots begin the syllable.). */
      254 
      255 	     if syllable_length = 2 & not_begin		/* pair may not begin syllable */
      256 	     then goto loop;			/* rule 3e. */
      257 	     if vowel_found
      258 	     then
      259 		if cons_count ^= 0
      260 		then
      261 		     if begin			/* vc...cx */
      262 		     then
      263 			if syllable_length ^= 3 & not_end_ (3) /* vc...cx begin */
      264 			then			/* can we break at vc..c|cx */
      265 			     if not_end_ (2)	/* no, try a break at vc...c|x */
      266 			     then goto loop;	/* rule 3c. */
      267 			     else call done (v, 2);	/* vc...c|x begin, treat as break */
      268 			else call done (v, 3);	/* vc..c|cx begin */
      269 		     else
      270 		     if not_begin			/* vc...cx ^begin */
      271 		     then
      272 			if break			/* vc...cx not_begin */
      273 			then
      274 			     if not_end_ (2)	/* vc...c|x break */
      275 			     then goto loop;	/* rule 3b, can't break */
      276 			     else call done (v, 2);	/* vc...c|x break */
      277 			else
      278 			if v			/* vc...cx ^break not_begin */
      279 			then			/* vc...cv ^break not_begin */
      280 			     if not_end_ (2)	/* try break at vc...c|v */
      281 			     then goto loop;	/* rule 3f, break no good */
      282 			     else call done ("1"b, 2); /* vc...c|v treat as break */
      283 			else
      284 			if end			/* vc...cc ^break not_begin */
      285 			then call done ("0"b, 1);	/* vc...cc| end */
      286 			else call done ("1"b, 0);	/* vc...cc ^break ^end not_begin */
      287 		     else
      288 		     if v				/* vc...cx ^begin ^not_begin */
      289 		     then
      290 			if not_end_ (3) & syllable_length ^= 3 /* vc...cv rule 2a says we must break somewhere */
      291 			then
      292 			     if not_end_ (2)	/* vc..c|cv doesn't work */
      293 			     then
      294 				if cons_count > 1	/* vc...c|v doesn't work */
      295 				then		/* vc...ccv */
      296 				     if not_end_ (4) /* try vc..c|ccv */
      297 				     | digrams (password (index-2), first).not_begin
      298 				     then goto loop; /* rule 3f */
      299 				     else call done ("1"b, 4); /* vc...c|ccv */
      300 				else goto loop;	/* vc...c|v and vc..c|cv are no good */
      301 			     else call done ("1"b, 3); /* vc...c|v treat as break */
      302 			else call done ("1"b, 3);	/* vc..c|cv treat as break */
      303 		     else call done ("1"b, 0);	/* vc...cc ^begin ^not_begin */
      304 		else				/* vowel found and last unit is not consonant => last unit is vowel */
      305 		if v & rules.vowel (password (index-2)) & index > 2
      306 		then goto loop;			/* rule 3a, 3 consecutive vowels non-y */
      307 		else
      308 		if end				/* vx */
      309 		then call done ("0"b, 1);		/* vx end */
      310 		else
      311 		if begin				/* vx ^end */
      312 		then
      313 		     if last_vowel_found		/* vx begin */
      314 		     then
      315 			if v			/* v...vvx begin */
      316 			then
      317 			     if syllable_length = 3	/* v...vvv begin */
      318 			     then
      319 				if rules (password ((index-2))).alternate_vowel /* |vvv begin */
      320 				then goto loop;	/* rule 3g, |"y"|vv is no good */
      321 				else call done ("1"b, 3); /* |v|vv begin */
      322 			     else
      323 			     if not_end_ (3)	/* v...vvv begin */
      324 			     then goto loop;	/* rule 3c, v...v|vv no good */
      325 			     else call done ("1"b, 3); /* v...v|vv begin */
      326 			else
      327 			if syllable_length = 3	/* v...vvc begin */
      328 			then
      329 			     if rules.alternate_vowel (password (index-2)) /* |vvc begin */
      330 			     then goto loop;	/* rule 3g, |"y"|vc is no good */
      331 			     else
      332 			     if rules.vowel (password (index-2)) /* |x|vc begin */
      333 			     then call done ("1"b, 3); /* |v|vc begin */
      334 			     else goto loop;	/* |c|vc begin is illegal */
      335 			else
      336 			if not_end_ (3)		/* v...vvc begin */
      337 			then			/* v...vvc begin try to split pair */
      338 			     if not_end_ (2)	/* v...vvc begin */
      339 			     then goto loop;	/* v...vv|c no good */
      340 			     else call done ("0"b, 2); /* v...vv|c */
      341 			else call done ("1"b, 3);	/* v...v|vc begin */
      342 		     else				/* try splitting begin pair */
      343 		     if syllable_length > 2		/* ..cvx begin */
      344 		     then
      345 			if not_end_ (2)		/* ...cvx begin */
      346 			then goto loop;		/* rule 3c, ...cv|x no good */
      347 			else call done (v, 2);	/* ...cv|x begin */
      348 		     else call done ("1"b, 0);	/* |vx begin */
      349 		else
      350 		if break				/* ..xvx ^begin ^end */
      351 		then
      352 		     if not_end_ (2) & syllable_length > 2 /* ..xvx break */
      353 		     then goto loop;		/* rule 3b, ..xv|x is no good */
      354 		     else call done (v, 2);		/* ..v|x break */
      355 		else call done ("1"b, 0);		/* ..vx ^end ^begin ^break */
      356 	     else
      357 	     if break				/* ...cx */
      358 	     then goto loop;			/* rule 3b, ...c|x break no good */
      359 	     else
      360 	     if end				/* ...cx ^break */
      361 	     then
      362 		if v				/* ...cx end */
      363 		then call done ("0"b, 1);		/* ...cv| end (new syllable) */
      364 		else goto loop;			/* rule 3b, ...cc| end no good */
      365 	     else
      366 	     if v					/* ...cx ^end ^break */
      367 	     then
      368 		if begin & syllable_length > 2	/* ...cv ^end ^break */
      369 		then goto loop;			/* c...c|cv ^end ^break begin, rule 3c */
      370 		else call done ("1"b, 0);		/* ...cv ^end ^break ^begin */
      371 	     else
      372 	     if begin				/* ...cc ^break ^end */
      373 	     then
      374 		if syllable_length > 2		/* ..ccc begin */
      375 		then goto loop;			/* rule 3c, ...ccc begin */
      376 		else call done ("0"b, 3);		/* |cc begin */
      377 	     else call done ("0"b, 0);		/* ..xcc ^end ^break ^begin */
      378 
      379 /* ******** return here when unit generated has been accepted ****** */
      380 
      381 	     return;
      382 
      383 /* ******** enter here when unit generated was good, but we don't want to use it because
      384*   it was supplied as a negative number by random_unit or random_vowel ********* */
      385 
      386 accepted_but_keep_trying: if letters_split (second).second ^= " "
      387 	     then nchars = nchars + 1;		/* pretend unit was no good */
      388 	     unit = -unit;				/* make positive to say that it would have been accepted */
      389 	     goto keep_trying;
      390 						/* ******** enter here when unit generated is no good ******* */
      391 
      392 loop:	     if letters_split (second).second ^= " " then nchars = nchars + 1;
      393 	     goto try_more;
      394 						/*
      395*						    */
      396 						/* PROCEDURE DONE */
      397 
      398 /* this routine is internal to generate_unit because it can return to loop */
      399 /* call done when new unit is generated and determined to be
      400*   legal. Arguments are new values of:
      401*   vf  vowel_found
      402*   mb  syllable_length (number of units in syllable. 0 means increment for this unit)
      403**/
      404 
      405 done:	     procedure (vf, sl);
      406 dcl  vf bit (1) aligned;
      407 dcl  sl fixed;
      408 
      409 /* if we are not within first 2 units of syllable, check if
      410*   vowel must precede this pair */
      411 
      412 		if sl ^= 2 then if syllable_length ^= 2 then if prefix then if ^rules.vowel (password (index-2))
      413 			     then			/* vowel must precede pair but no vowel precedes pair */
      414 				if vowel_found	/* if there is a vowel in this syllable, */
      415 				then		/* we may be able to break this pair     */
      416 				     if not_end_ (2) /* check if this pair may be treated as break */
      417 				     then goto loop; /* no, previous 2 units can't end */
      418 				     else		/* yes, break can be forced */
      419 				     do;
      420 					call done ("0"b, 2); /* ...cxx or ...cvx */
      421 					return;
      422 				     end;
      423 				else goto loop;	/* no vowel in syllable */
      424 
      425 /* Check end of word conditions.  If end of word is reached, then
      426*   1. We must have a vowel in current syllable, and
      427*   2. This pair must be allowed to end syllable
      428**/
      429 
      430 		if sl ^= 1
      431 		then
      432 		     if index = nchars
      433 		     then
      434 			if not_end
      435 			then goto loop;
      436 			else
      437 			if vf = "0"b
      438 			then goto loop;
      439 
      440 /* A final "e" may not be the only vowel in the last syllable. */
      441 
      442 		if index = nchars
      443 		then
      444 		     if rules (second).no_final_split	/* this bit is on for "e" */
      445 		     then
      446 			if sl ^= 1
      447 			then
      448 			     if rules.vowel (first)	/* e preceded by vowel is ok, however */
      449 			     then;
      450 			     else
      451 			     if ^vowel_found|syllable_length<3 /* otherwise previous 2 letters must be */
      452 			     then goto loop;	/* able to end the syllable */
      453 			     else
      454 			     if unit < 0
      455 			     then goto accepted_but_keep_trying;
      456 			     else sl = 0;
      457 		if unit < 0 then goto accepted_but_keep_trying;
      458 		if v | sl = 1
      459 		then cons_count = 0;		/* this unit is a vowel or new syllable is to begin */
      460 		else
      461 		if sl = 0
      462 		then cons_count = cons_count + 1;	/* this was a consonant, increment count */
      463 		else				/* a new syllable was started some letters back, cons_count gets */
      464 		cons_count = min (sl-1, cons_count+1);	/* incremented, but no more than number of units in syllable */
      465 		if sl = 0
      466 		then syllable_length = syllable_length + 1;
      467 		else syllable_length = sl;
      468 		if syllable_length > 3
      469 		then last_vowel_found = vowel_found;
      470 		else last_vowel_found = "0"b;
      471 		vowel_found = vf;
      472 		if index - syllable_length + 1 ^= nchars
      473 		then hyphenated_word (index - syllable_length + 1) = "1"b;
      474 
      475 	     end done;
      476 
      477 	end generate_unit;
      478 						/*
      479*						    */
      480 						/* PROCEDURE NOT_END_ */
      481 						/* not_end_(i) returns "1"b when ( password(index-i), password(index-i+1) )
      482*						   may not end a syllable, or when password(index-i+2) may not begin a syllable */
      483 
      484 not_end_:	procedure (i) returns (bit (1));
      485 dcl  i fixed;
      486 	     if i = index
      487 	     then return (^rules.vowel (password (1)));
      488 	     if i ^= 1
      489 	     then
      490 		if rules.not_begin_syllable (password (index-i+2)) then return ("1"b);
      491 	     return (digrams (password (index-i), password (index-i+1)).not_end);
      492 	end;
      493 
      494      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1530.2  random_word_.pl1                  >dumps>old>recomp>random_word_.pl1
31           1    06/16/75  2003.4  digram_structure.incl.pl1         >ldd>include>digram_structure.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
alternate_vowel           3            based           bit(1)                   array level 2 dcl 1-35 ref 78 86 220 310 326
begin                           000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 223* 257 310 365 371
begin                                  based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  223
break                     4     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 227* 231* 269 349 356
break                     0(04)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  227
cons_count                      000104 automatic       fixed bin(17,0)          initial dcl 42 set ref 42* 89* 94* 257 287 458* 460*
                                                                                  460 463* 463
debug                           000010 internal static bit(1)                   initial dcl 32 set ref 115* 119* 180
digrams                                based           structure                array level 1 packed unaligned dcl 1-11
digrams$digrams                 000012 external static fixed bin(17,0)          dcl 1-4 set ref 71 167 167 205 223 224 225 226 227
                                                                                  228 229 230 231 287 491
digrams$letters                 000016 external static fixed bin(17,0)          dcl 1-6 set ref 74 185 214 386 392
digrams$n_units                 000014 external static fixed bin(17,0)          dcl 1-5 ref 71 71 71 71 167 167 167 167 167 167 167
                                                                                  167 205 205 205 205 223 223 223 223 224 224 224
                                                                                  224 225 225 225 225 226 226 226 226 227 227 227
                                                                                  227 228 228 228 228 229 229 229 229 230 230 230
                                                                                  230 231 231 231 231 287 287 287 287 491 491 491
                                                                                  491
digrams$rules                   000020 external static fixed bin(17,0)          dcl 1-7 set ref 73 78 78 86 86 220 220 222 304 310
                                                                                  326 331 412 442 442 486 488
end                       2     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 225* 283 307 359
end                       0(02)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  225
first                           000107 automatic       fixed bin(17,0)          initial dcl 45 set ref 45* 160* 167 167 205 207 207
                                                                                  220 223 224 225 226 227 228 229 230 231 287 442
hyphenated_word                        parameter       bit(1)                   array dcl 34 set ref 29 52* 189* 472*
i                                      parameter       fixed bin(17,0)          dcl 485 in procedure "not_end_" ref 484 486 488 488
                                                                                  491 491
i                               000102 automatic       fixed bin(17,0)          dcl 40 in procedure "random_word_" set ref 50* 51
                                                                                  52*
i                               000136 automatic       fixed bin(17,0)          dcl 158 in procedure "generate_unit" set ref 184*
                                                                                  185*
illegal_pair              7     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 230*
illegal_pair              0(07)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  71 205 230
index                           000101 automatic       fixed bin(17,0)          initial dcl 39 set ref 39* 59* 59* 66 70 71 71 71 73
                                                                                  74 74 78 78 78 86 86* 108 160 165 167 167 184 189*
                                                                                  207 207 214 219 231 287 304 304 310 326 331 412
                                                                                  430 442 472 472 486 488 491 491
ioa_$nnl                        000022 constant        entry                    external dcl 48 ref 183 185 187
last_vowel_found                000106 automatic       bit(1)                   dcl 44 set ref 97* 310 468* 470*
length                                 parameter       fixed bin(17,0)          dcl 35 set ref 29 50 54 189*
letters                                based           char(2)                  array dcl 1-24 set ref 185*
letters_split                          based           structure                array level 1 packed unaligned dcl 1-28
n_units                                defined         fixed bin(17,0)          dcl 1-41 ref 71 71 167 167 167 167 205 205 223 223
                                                                                  224 224 225 225 226 226 227 227 228 228 229 229
                                                                                  230 230 231 231 287 287 491 491
nchars                          000100 automatic       fixed bin(17,0)          dcl 38 set ref 54* 59 66 74 78 83* 83 165 214 218*
                                                                                  218 386* 386 392* 392 430 442 472
no_final_split                         based           bit(1)                   array level 2 dcl 1-35 ref 442
not_begin                 0(01)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  224 287
not_begin                 1     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 224* 255 269
not_begin_syllable        1            based           bit(1)                   array level 2 dcl 1-35 ref 73 488
not_end                   3     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 226* 430
not_end                   0(03)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  167 226 491
password                               parameter       fixed bin(17,0)          array dcl 33 set ref 29 51* 70* 71 71 73 74 78 78 86
                                                                                  86 160 167 167 185 189* 207 219* 231 287 304 310
                                                                                  326 331 412 486 488 491 491
prefix                    5     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 228* 412
prefix                    0(05)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  228
random_unit                            parameter       entry variable           dcl 46 set ref 29 69 189* 199
random_vowel                           parameter       entry variable           dcl 46 set ref 29 66 189* 196
rules                                  based           structure                array level 1 dcl 1-35
second                    0(09)        based           char(1)                  array level 2 in structure "letters_split" packed
                                                                                  unaligned dcl 1-28 in procedure "random_word_" ref
                                                                                  74 214 386 392
second                          000110 automatic       fixed bin(17,0)          initial dcl 45 in procedure "random_word_" set ref
                                                                                  45* 102 190* 200* 205 207 214 219 220 222 223 224
                                                                                  225 226 227 228 229 230 386 392 442
sl                                     parameter       fixed bin(17,0)          dcl 407 set ref 405 412 430 442 456* 458 460 463 465
                                                                                  467
suffix                    0(06)        based           bit(1)                   array level 2 in structure "digrams" packed
                                                                                  unaligned dcl 1-11 in procedure "random_word_" ref
                                                                                  167 229 231
suffix                    6     000122 automatic       bit(1)                   level 2 in structure "x" dcl 154 in procedure
                                                                                  "generate_unit" set ref 229*
syllable_length                 000103 automatic       fixed bin(17,0)          initial dcl 41 set ref 41* 60 85* 165 231 255 257
                                                                                  287 310 326 342 349 365 371 412 450 465* 465 467*
                                                                                  468 472 472
try_for_vowel                   000133 automatic       bit(1)                   dcl 155 set ref 165* 167* 170* 196
unit                            000111 automatic       fixed bin(17,0)          dcl 47 set ref 58* 63* 63 65* 65 66* 69* 70 81 84
                                                                                  175* 175 196* 199* 200 201 388* 388 453 457
unit_count                      000134 automatic       fixed bin(17,0)          initial dcl 156 set ref 156* 177 201* 201
v                               000135 automatic       bit(1)                   dcl 157 set ref 220* 222* 231 267* 268* 276* 277 287
                                                                                  304 310 347* 354* 359 365 458
vf                                     parameter       bit(1)                   dcl 406 ref 405 436 471
vowel                     2            based           bit(1)                   array level 2 dcl 1-35 ref 78 86 220 222 304 331 412
                                                                                  442 486
vowel_found                     000105 automatic       bit(1)                   dcl 43 set ref 90* 95* 165 167 257 412 450 468 471*
word_length                            parameter       fixed bin(17,0)          dcl 36 set ref 29 108*
x                               000122 automatic       structure                level 1 dcl 154

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
number                                 automatic       float bin(27)            dcl 37

NAMES DECLARED BY EXPLICIT CONTEXT.
accepted_but_keep_trying        002126 constant        label                    dcl 386 ref 453 457
all_done                        000312 constant        label                    dcl 108 ref 102
debug_off                       000333 constant        entry                    external dcl 118
debug_on                        000320 constant        entry                    external dcl 114
done                            002155 constant        entry                    internal dcl 405 ref 267 268 276 282 283 286 299 301
                                                                                  302 303 307 321 325 331 340 341 347 348 354 355
                                                                                  359 370 376 377 420
first_time                      000135 constant        label                    dcl 66 ref 64
generate_unit                   000344 constant        entry                    internal dcl 153 ref 101
keep_trying                     000120 constant        label                    dcl 63 in procedure "random_word_" ref 81 84
keep_trying                     000573 constant        label                    dcl 196 in procedure "generate_unit" ref 171 389
loop                            002142 constant        label                    dcl 392 ref 255 257 269 277 287 287 304 310 322 326
                                                                                  331 335 342 349 356 359 365 371 412 412 430 436
                                                                                  450
not_end_                        002442 constant        entry                    internal dcl 484 ref 257 257 269 277 287 287 287 322
                                                                                  335 335 342 349 412
random_word_                    000054 constant        entry                    external dcl 29 ref 189
retry                           000126 constant        label                    dcl 65 ref 71 73 74 78
try_more                        000432 constant        label                    dcl 175 ref 205 207 214 393

NAMES DECLARED BY CONTEXT OR IMPLICATION.
abs                                                    builtin function         ref 63 65 70 175 200
addr                                                   builtin function         ref 71 73 74 78 78 86 86 167 167 185 205 214 220 220
                                                                                  222 223 224 225 226 227 228 229 230 231 287 304
                                                                                  310 326 331 386 392 412 442 442 486 488 491
min                                                    builtin function         ref 463

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2662        2706    2553        2672
Length      3116    2553        24         174     106           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
random_word_                        160 external procedure  is an external procedure.  
generate_unit                           internal procedure  shares stack frame of external procedure random_word_.  
done                                 74 internal procedure  calls itself recursively.  
not_end_                             67 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 debug                       random_word_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
random_word_             000100 nchars                      random_word_
                         000101 index                       random_word_
                         000102 i                           random_word_
                         000103 syllable_length             random_word_
                         000104 cons_count                  random_word_
                         000105 vowel_found                 random_word_
                         000106 last_vowel_found            random_word_
                         000107 first                       random_word_
                         000110 second                      random_word_
                         000111 unit                        random_word_
                         000122 x                           generate_unit
                         000133 try_for_vowel               generate_unit
                         000134 unit_count                  generate_unit
                         000135 v                           generate_unit
                         000136 i                           generate_unit

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             call_var            call_ext_in_desc    call_ext_out_desc
call_int_this       call_int_other      return              tra_ext             ext_entry           ext_entry_desc
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$nnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
digrams$digrams               digrams$letters               digrams$n_units               digrams$rules




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     39 000036        41 000040        42 000041        45 000042        29 000046        50 000062        51 000071
     52 000076        53 000102        54 000104        58 000107        59 000110        60 000115        63 000120
     64 000125        65 000126        66 000135        69 000150        70 000157        71 000172        73 000222
     74 000230        78 000245        81 000256        83 000260        84 000263        85 000265        86 000267
     89 000274        90 000275        91 000277        94 000300        95 000302        97 000303        98 000304
    101 000305       102 000306       104 000310       108 000312       110 000316       114 000317       115 000326
    116 000331       118 000332       119 000341       120 000343       153 000344       156 000345       160 000347
    165 000357       167 000373       170 000430       171 000431       175 000432       177 000441       180 000444
    183 000447       184 000462       185 000471       186 000520       187 000522       189 000535       190 000571
    191 000572       196 000573       199 000605       200 000614       201 000621       205 000624       207 000644
    214 000662       218 000674       219 000676       220 000706       222 000722       223 000724       224 000736
    225 000742       226 000746       227 000752       228 000756       229 000762       230 000766       231 000772
    255 001022       257 001027       267 001074       268 001107       269 001122       276 001143       277 001156
    282 001176       283 001213       286 001232       287 001246       299 001362       301 001377       302 001414
    303 001431       304 001445       307 001464       310 001503       321 001520       322 001535       325 001552
    326 001567       331 001575       335 001614       340 001646       341 001663       342 001700       347 001720
    348 001733       349 001747       354 001773       355 002006       356 002022       359 002024       365 002046
    370 002055       371 002071       376 002075       377 002112       381 002125       386 002126       388 002137
    389 002141       392 002142       393 002153       405 002154       412 002162       420 002235       421 002252
    430 002253       436 002267       442 002276       450 002321       453 002335       456 002343       457 002345
    458 002353       460 002365       463 002371       465 002402       467 002407       468 002410       470 002416
    471 002417       472 002422       475 002440       484 002441       486 002447       488 002473       491 002516


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
