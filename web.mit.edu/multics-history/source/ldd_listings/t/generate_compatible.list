	COMPILATION LISTING OF SEGMENT generate_compatible
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1705.3 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 generate_compatible: genc: proc;
       12 
       13 /* Automatic */
       14 
       15 dcl  linep ptr;
       16 dcl  c1 char (1);
       17 dcl  chars72 char (72);
       18 dcl  new bit (1);
       19 dcl  old bit (1);
       20 dcl  error_phase fixed bin;
       21 dcl  next_term fixed bin;
       22 dcl  next_pr fixed bin;
       23 dcl  pname char (36) var;
       24 dcl  search_name char (36) var;
       25 dcl (i, j, k) fixed bin;
       26 dcl  linel fixed bin;
       27 dcl  tx fixed bin;
       28 dcl  pr_ptrs (20) ptr;
       29 dcl  term_names (20) char (36) var;
       30 dcl 1 symbols (200) aligned,
       31     2 name char (36) var,
       32     2 nt_ptr ptr unal,
       33     2 unused bit (1) aligned;
       34 dcl  ptrs (1) ptr;
       35 dcl  N fixed bin;
       36 dcl  matrix (108, 108) bit (1) unal;
       37 dcl  code fixed bin (35);
       38 dcl  txp ptr;
       39 dcl  rootp ptr;
       40 dcl  temp ptr;
       41 dcl  nsymbols fixed bin;
       42 dcl  stack (108) fixed bin;
       43 dcl  depth fixed bin;
       44 dcl  bits (72) bit (72);
       45 dcl  eof bit (1) aligned;
       46 
       47 
       48 /* Based */
       49 
       50 dcl  line char (linel) based (linep);
       51 dcl  total_buffer char (8000) based (txp);
       52 dcl  chars (10000) char (1) unaligned based;
       53 dcl  area area based;
       54 dcl 1 symbol based,
       55     2 name char (36) var,
       56     2 nt_ptr ptr unal;
       57 
       58 
       59 dcl 1 pr based aligned,
       60     2 numt fixed bin,
       61     2 dummy bit (1),
       62     2 term (N refer (pr.numt)),
       63       3 terminal bit (1) unal,
       64       3 processed bit (1) unal,
       65       3 pad bit (34) unal,
       66       3 value fixed bin,
       67       3 datap ptr;
       68 
       69 dcl 1 nt based aligned,
       70     2 nump fixed bin,
       71     2 id char (36) var,
       72     2 prod (N refer (nt.nump)) ptr;
       73 
       74 /* Static */
       75 
       76 dcl  formats (10) char (48) aligned static options (constant) init (
       77      "No ""NL"" found in bnf text.",
       78      "No ""NL<"" sequence found in bnf text.",
       79      "Not enough lines in bnf text.",
       80      "No root production found.",
       81      "Missing "">"" in line:   ^s^a",
       82      "Missing "">"" in line:   ^s^a",
       83      "Keyword lookup failed: ""^a""",
       84      "Non-terminal ""^a"" is undefined.",
       85      "Non-terminal ""^a"" has never been referenced.",
       86      "Missing ""]"" in line:   ^s^a");
       87 dcl  me char (2) static options (constant) init ("gc");
       88 dcl  gc_new bit (1) static init ("1"b);
       89 dcl  gc_diff bit (1) static init ("1"b);
       90 dcl  NL char (1) static options (constant) init ("
       91 ");
       92 dcl  NL_LESS char (2) static options (constant) init ("
       93 <");
       94 dcl  WHITE char (3) static options (constant) init ("
       95 	 ");
       96 dcl  cleanup condition;
       97 
       98 /* Builtin */
       99 
      100 dcl (null, addr, substr, search, verify, index) builtin;
      101 
      102 /* External */
      103 
      104 dcl  compatible_bnf$ ext;
      105 dcl  incompatible_bnf$ ext;
      106 
      107 /* Entries */
      108 
      109 dcl  com_err_ entry options (variable);
      110 dcl  ioa_ entry options (variable);
      111 dcl (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr, fixed bin (35));
      112 dcl  area_ entry (fixed bin (19), ptr);
      113 
      114 /*  */
      115 
      116 /*
      117*
      118*   Initialize variables, set up buffer, get ptrs
      119*
      120**/
      121 
      122 	txp = addr (compatible_bnf$);
      123 	ptrs (1) = null;
      124 	on cleanup call clean;
      125 	call get_temp_segments_ (me, ptrs, code);
      126 	temp = ptrs (1);
      127 	call area_ (200000, temp);
      128 
      129 /* Initially, every attribute is incompatible with every other attribute except itself. */
      130 
      131 	do i = 1 to 108;
      132 	     do j = 1 to 108;
      133 		matrix (i, j) = "1"b;
      134 	     end;
      135 	     matrix (i, i) = "0"b;
      136 	end;
      137 
      138 /* Mark compatible attributes. */
      139 
      140 	error_phase = 0;
      141 
      142 	call parse_bnf;
      143 	call mark (rootp, "0"b);
      144 
      145 /* Now mark as incompatible certain combinations that fell out
      146*   of the compatible BNF that we didn't want */
      147 
      148 	error_phase = 10;
      149 	txp = addr (incompatible_bnf$);
      150 
      151 	call parse_bnf;
      152 	call mark (rootp, "1"b);
      153 	do i = 1 to 108;
      154 	     matrix (i, i) = "0"b;
      155 	end;
      156 
      157 /*
      158*   Output the compatible matrix, both to user_output and to file
      159**/
      160 
      161 	if gc_new then do;
      162 	     call ioa_ ("^-PROGRAM GENERATED TABLE^2/");
      163 	     call ioa_ ("          111111111122222222223333333333444444444455555555556666666666777");
      164 	     call ioa_ (" 123456789012345678901234567890123456789012345678901234567890123456789012");
      165 	     call ioa_ (" ------------------------------------------------------------------------");
      166 	end;
      167 	do i = 1 to 72;
      168 	     do j = 1 to 72;
      169 		substr (bits (i), j, 1) = matrix (i, j);
      170 	     end;
      171 	     if gc_new then call ioa_ ("""^b""b, /* ^2d ^a */", bits (i), i, lookup_keyword (i));
      172 	end;
      173 
      174 	if gc_diff then do;
      175 	     call ioa_ ("^|^2/^-DIFFERENCES FROM REAL TABLE^2/");
      176 	     call ioa_ ("          1111111111222222222233333333334444444444555555555566666666667777777");
      177 	     call ioa_ (" 1234567890123456789012345678901234567890123456789012345678901234567890123456");
      178 	     call ioa_ (" ----------------------------------------------------------------------------");
      179 	     do i = 1 to 72;
      180 		do j = 1 to 72;
      181 		     new = substr (bits (i), j, 1);
      182 		     old = substr (incompatable (i), j, 1);
      183 		     if old = new then c1 = "=";
      184 		     else if old then c1 = "I";
      185 		     else c1 = "C";
      186 		     substr (chars72, j, 1) = c1;
      187 		end;
      188 		substr (chars72, i, 1) = "\";
      189 		call ioa_ ("""^a""b, /* ^2d ^a */", chars72, i, lookup_keyword (i));
      190 	     end;
      191 	     call ioa_ (" ----------------------------------------------------------------------------");
      192 	     call ioa_ ("          1111111111222222222233333333334444444444555555555566666666667777777");
      193 	     call ioa_ (" 1234567890123456789012345678901234567890123456789012345678901234567890123456");
      194 	end;
      195 
      196 
      197 	call clean;
      198 	return;
      199 
      200 GLOBAL_ERROR:
      201 	call clean;
      202 	return;
      203 
      204 ERROR:	proc (x);
      205 
      206 dcl  x fixed bin;
      207 
      208 	     call com_err_ (0, "generate_compatible", "Error ^d while scanning ^[^;in^]compatible_bnf.", x, error_phase=0);
      209 	     call com_err_ (0, "generate_compatible", formats (x), search_name, line);
      210 	     goto GLOBAL_ERROR;
      211 	end;
      212 
      213 lookup_keyword: proc (x) returns (char (16) aligned);
      214 
      215 dcl  x fixed bin;
      216 dcl  first_i fixed bin;
      217 dcl  i fixed bin;
      218 
      219 	     first_i = 0;
      220 	     do i = 1 to hbound (keyword (*), 1);
      221 		if x = bit_index (i)
      222 		then if first_i = 0
      223 		     then first_i = i;
      224 		     else return (keyword (i));	/* short names usually preceed long names... */
      225 	     end;
      226 	     if first_i ^= 0
      227 	     then return (keyword (first_i));
      228 
      229 	     do i = 1 to hbound (system_keyword (*), 1);
      230 		if x = system_bit_index (i)
      231 		then return (system_keyword (i));
      232 	     end;
      233 
      234 	     return ("***");
      235 
      236 	end lookup_keyword;
      237 
      238 
      239 clean:	proc;
      240 
      241 	     call release_temp_segments_ (me, ptrs, code);
      242 
      243 	end;
      244 
      245 /*  */
      246 
      247 /* Subroutines */
      248 
      249 parse_bnf: proc;
      250 
      251 
      252 /* This routine parses the BNF pointed to by txp. It allocates nodes for all terminals and non-terminals
      253*   and threads them together in the indicated fashion (not necessarily tree form).
      254*
      255*   The syntax of the BNF is as follows:
      256*
      257*   first char on line is "<" implies new non-terminal, i.e. a production that defines a new non-terminal.
      258*
      259*   first char on line is blank implies another production for the current non-terminal.
      260*
      261*   first chars on line are "eof" implies no more productions.
      262*
      263*   any other first char(s) implies line is ignored.
      264*
      265*   The total BNF cannot be more than 8K characters.
      266*   A production must be entirely on a single line.
      267*   Nonterminals are distinguished by being enclosed in "<" and ">".
      268*   Symbols must be <= 36 characters.
      269*   The root of the tree is called "<root>".
      270*
      271**/
      272 
      273 	     rootp = null;
      274 	     eof = "0"b;
      275 	     nsymbols = 0;
      276 	     depth = 0;
      277 	     linep = txp;
      278 	     next_term = 1;
      279 	     next_pr = 1;
      280 	     pname = "";
      281 
      282 /* start scan with first line with a "<" at beginning */
      283 
      284 	     if substr (total_buffer, 1, 1) = "<"
      285 	     then do;
      286 		i = index (total_buffer, NL);
      287 		if i <= 0 then call ERROR (1);
      288 		linel = i;
      289 	     end;
      290 	     else do;
      291 		i = index (total_buffer, NL_LESS);
      292 		if i <= 0 then call ERROR (2);
      293 		linep = addr (linep -> chars (i+1));
      294 		linel = index (linep -> total_buffer, NL);
      295 		if linel <= 0 then call ERROR (3);
      296 	     end;
      297 
      298 	     do while (linep ^= null);
      299 		call parse_production;
      300 		call finish_production;
      301 		call get_line;
      302 	     end;
      303 	     eof = "1"b;
      304 	     linep = txp;				/* so test in parse_production will not get null ptr ref */
      305 	     call parse_production;			/* to get last NT structure allocated */
      306 
      307 /* Now scan all nodes converting pointers to symbols into pointers to non-terminal nodes */
      308 
      309 	     rootp = lookup ("<root>") -> symbol.nt_ptr;
      310 	     if rootp = null then call ERROR (4);
      311 	     call scan (rootp);
      312 
      313 	     do i = 1 to nsymbols while (symbols (i).unused = "0"b);
      314 	     end;
      315 
      316 	     if i <= nsymbols
      317 	     then do;
      318 		     search_name = symbols (i).name;
      319 		     call ERROR (9);
      320 		end;
      321 
      322 	     return;
      323 
      324 /*  */
      325 
      326 get_line:	     proc;
      327 
      328 dcl  i fixed bin;
      329 
      330 dummy_line:
      331 		linep = addr (linep -> chars (linel+1));
      332 		i = index (linep -> total_buffer, NL);
      333 		if i <= 0 then do;
      334 		     linep = null;
      335 		     return;
      336 		end;
      337 		linel = i;
      338 		if substr (line, 1, 3) = "eof"
      339 		then do;
      340 		     linep = null;
      341 		     return;
      342 		end;
      343 		if substr (line, 1, 1) = "<" | substr (line, 1, 1) = " " | substr (line, 1, 1) = "	" then return;
      344 		goto dummy_line;
      345 
      346 	     end get_line;
      347 
      348 /*  */
      349 
      350 parse_production: proc;
      351 
      352 dcl  ntp ptr;
      353 
      354 /* called with production in "line". If first char is not "<" then start filling in terms
      355*   at position 2. Else start with position 1 and finish the previous non-terminal.
      356**/
      357 
      358 		tx = 1;
      359 		if (substr (line, 1, 1) = "<" & pname ^= "") | eof
      360 		then do;				/* a new production, clean up previous */
      361 		     N = next_pr - 1;
      362 		     allocate nt in (temp -> area) set (ntp);
      363 		     ntp -> nt.nump = N;
      364 		     ntp -> nt.id = pname;
      365 		     do i = 1 to N;
      366 			ntp -> nt.prod (i) = pr_ptrs (i);
      367 		     end;
      368 		     do i = 1 to nsymbols;
      369 			if pname = symbols (i).name	/* name used on rhs before defined on lhs */
      370 			then do;
      371 			     symbols (i).nt_ptr = ntp;
      372 			     goto done;
      373 			end;
      374 		     end;
      375 		     nsymbols = nsymbols + 1;
      376 		     symbols (nsymbols).name = pname;
      377 		     symbols (nsymbols).nt_ptr = ntp;
      378 		     symbols (nsymbols).unused = "1"b;
      379 done:
      380 		     next_pr = 1;
      381 		end;
      382 
      383 		if eof then return;			/* all we wanted was to generate the nt structure */
      384 
      385 		if substr (line, 1, 1) = "<" then do;
      386 		     i = index (line, ">");
      387 		     if i <= 0 then call ERROR (5);
      388 		     pname = substr (line, 1, i);
      389 		     tx = i+1;
      390 		end;
      391 
      392 /* Now scan for specific terms */
      393 next_token:
      394 		j = verify (substr (line, tx), WHITE)-1;
      395 		if j < 0 then return;		/* all filled in */
      396 		tx = tx + j;
      397 		if substr (line, tx, 1) = "<"
      398 		then do;				/* a non-terminal term */
      399 		     k = index (substr (line, tx), ">");
      400 		     if k <= 0 then call ERROR (6);
      401 		end;
      402 		else if substr (line, tx, 1) = "["	/* optional terminal */
      403 		then do;
      404 		     k = index (substr (line, tx), "]");
      405 		     if k = 0 then call ERROR (10);
      406 		end;
      407 		else do;
      408 		     k = search (substr (line, tx), WHITE)-1;
      409 		     if k < 0 then return;
      410 		end;
      411 
      412 		term_names (next_term) = substr (line, tx, k);
      413 		next_term = next_term + 1;
      414 		tx = tx + k;
      415 		goto next_token;
      416 
      417 	     end parse_production;
      418 
      419 finish_production: proc;
      420 
      421 /* input is array of symbols in term_names. This program builds a "pr" structure and fills
      422*   in a pointer to the structure in pr_ptrs (i).
      423*
      424**/
      425 
      426 dcl  pp ptr;
      427 
      428 		N = next_term - 1;
      429 		allocate pr in (temp -> area) set (pp);
      430 		pp -> pr.numt = N;
      431 		do i = 1 to N;
      432 		     pp -> pr (i).datap = lookup (term_names (i));
      433 		     if substr (term_names (i), 1, 1) ^= "<"
      434 		     then do;
      435 			pp -> pr (i).terminal = "1"b;
      436 			pp -> pr (i).value = map_number (term_names (i));
      437 		     end;
      438 		end;
      439 		pr_ptrs (next_pr) = pp;
      440 		next_pr = next_pr + 1;
      441 		next_term = 1;
      442 		return;
      443 
      444 map_number:	proc (name) returns (fixed bin);
      445 
      446 dcl  name char (36) var;
      447 
      448 dcl  i fixed bin;
      449 
      450 		     search_name = name;
      451 		     do i = 1 to hbound (keyword (*), 1) while (keyword (i) ^= name);
      452 		     end;
      453 		     if i <= hbound (keyword (*), 1)
      454 		     then return (bit_index (i));
      455 
      456 		     do i = 1 to hbound (system_keyword (*), 1) while (system_keyword (i) ^= name);
      457 		     end;
      458 		     if i <= hbound (system_keyword (*), 1)
      459 		     then return (system_bit_index (i));
      460 
      461 		     call ERROR (7);
      462 
      463 		end;
      464 
      465 	     end /* finish_production */;
      466 
      467 lookup:		proc (tname) returns (ptr);
      468 
      469 dcl  tname char (36) var;
      470 dcl  i fixed bin;
      471 
      472 		     do i = 1 to nsymbols while (symbols (i).name ^= tname);
      473 		     end;
      474 		     if i > nsymbols
      475 		     then do;
      476 			     i, nsymbols = nsymbols + 1;
      477 			     symbols (nsymbols).name = tname;
      478 			     symbols (nsymbols).nt_ptr = null;
      479 			end;
      480 
      481 		     symbols (i).unused = "0"b;
      482 		     return (addr (symbols (i)));
      483 		end lookup;
      484 
      485 
      486 scan:	     proc (rp);
      487 
      488 dcl  rp ptr;
      489 dcl (i, j) fixed bin;
      490 dcl (pp, q) ptr;
      491 
      492 /* This routine does a recursive walk of the tree changing any non-terminal pointers
      493*   from a pointer to the symbol to a pointer to the allocated node */
      494 
      495 		do i = 1 to rp -> nt.nump;		/* scan each production of this non-terminal */
      496 		     pp = rp -> nt.prod (i);
      497 		     do j = 1 to pp -> pr.numt;	/* scan each brother of this production */
      498 			if ^ pp -> pr (j).terminal
      499 			then do;
      500 			     if ^ pp -> pr (j).processed then do;
      501 				q = pp -> pr (j).datap -> symbol.nt_ptr;
      502 				if q = null then do;
      503 				     search_name = pp -> pr (j).datap -> symbol.name;
      504 				     call ERROR (8);
      505 				end;
      506 				pp -> pr (j).datap = q;
      507 				pp -> pr (j).processed = "1"b;
      508 				call scan (q);
      509 			     end;
      510 			end;
      511 		     end;
      512 		end;
      513 
      514 	     end scan;
      515 
      516 	end parse_bnf;
      517 
      518 /*  */
      519 
      520 mark:	proc (p, mark_value);
      521 
      522 dcl  p ptr;
      523 dcl  mark_value bit (1) aligned;
      524 dcl (i, j) fixed bin;
      525 dcl  pp ptr;
      526 dcl  save_depth fixed bin;
      527 dcl  save_depth1 fixed bin;
      528 dcl  k fixed bin;
      529 
      530 /* This routine walks the tree and marks each compatible set of  attributes.
      531*   It does this by keeping a stack of all terminal symbols above the current node of the tree
      532*   that are immediate brothers to non-terminal nodes that are direct ancestors of the current node. That is,
      533*   terminal symbols in the same production as the ancestor non-terminal. Before recursing to
      534*   a lower level (when finding a non-terminal in the tree walk) all immediate brothers (of the same
      535*   production as the non-terminal) that are terminal nodes, are placed on the stack. When a terminal
      536*   node is encountered, it is placed on the stack and "reflect" is called
      537*   to mark all terminals on the stack as being compatible.
      538*
      539**/
      540 
      541 	     do i = 1 to p -> nt.nump;
      542 		pp = p -> nt.prod (i);
      543 		save_depth = depth;
      544 		do j = 1 to pp -> pr.numt;
      545 		     if pp -> pr (j).terminal
      546 		     then do;
      547 			depth = depth + 1;
      548 			stack (depth) = pp -> pr (j).value;
      549 		     end;
      550 		end;
      551 		do j = 1 to pp -> pr.numt;
      552 		     save_depth1 = depth;
      553 		     do k = 1 to pp -> pr.numt;
      554 			if (^ pp -> pr (k).terminal) & (j ^= k) then call markt (pp -> pr (k).datap, mark_value);
      555 		     end;
      556 		     if pp -> pr (j).terminal then call reflect (pp -> pr (j).value, mark_value);
      557 		     else call mark (pp -> pr (j).datap, mark_value);
      558 		     depth = save_depth1;
      559 		end;
      560 		depth = save_depth;
      561 	     end;
      562 	     return;
      563 
      564 	end mark;
      565 
      566 markt:	proc (p, mark_value);
      567 
      568 dcl  p ptr;
      569 dcl  mark_value bit (1) aligned;
      570 dcl (dx, v) fixed bin;
      571 dcl (i, j) fixed bin;
      572 dcl  pp ptr;
      573 
      574 
      575 	     do i = 1 to p -> nt.nump;
      576 		pp = p -> nt.prod (i);
      577 		do j = 1 to pp -> pr.numt;
      578 		     if pp -> pr (j).terminal
      579 		     then do;
      580 			v = pp -> pr (j).value;
      581 			do dx = 1 to depth while (stack (dx) ^= v);
      582 			end;
      583 
      584 			if dx > depth
      585 			then do;
      586 				depth = depth + 1;
      587 				stack (depth) = v;
      588 			     end;
      589 		     end;
      590 		     else call markt (pp -> pr (j).datap, mark_value);
      591 		end;
      592 	     end;
      593 	     return;
      594 
      595 	end markt;
      596 
      597 reflect:	proc (x, mark_value);
      598 
      599 dcl  x fixed bin;
      600 dcl  mark_value bit (1) aligned;
      601 
      602 dcl  i fixed bin;
      603 
      604 	     do i = 1 to depth;
      605 		matrix (x, stack (i)) = mark_value;
      606 		matrix (stack (i), x) = mark_value;
      607 	     end;
      608 
      609 	end reflect;
      610 
      611 
      612 /*  */
      613 
      614 gc_set_new: entry;
      615 
      616 	gc_new = "1"b;
      617 	return;
      618 
      619 gc_reset_new: entry;
      620 
      621 	gc_new = "0"b;
      622 	return;
      623 
      624 gc_set_diff: entry;
      625 
      626 	gc_diff = "1"b;
      627 	return;
      628 
      629 gc_reset_diff: entry;
      630 
      631 	gc_diff = "0"b;
      632 	return;
      633 
      634 /*  */
      635 
  1     1 /* BEGIN INCLUDE FILE ... pl1_attribute_table.incl.pl1 */
  1     2 
  1     3 /* Modified 780628 by PG for unsigned */
  1     4 
  1     5 dcl	index_given_letter (97:122) fixed bin (8) unal internal static
  1     6 	initial (1, 5, 10, 19, 26, 31, 35, 83, 36, 83, 43,	/* A-K */
  1     7 	44, 47, 48, 50, 53, 83, 64, 69, 83, 75, 80, (4)83);	/* L-Z */
  1     8 
  1     9 dcl	keyword (83) char (11) aligned internal static initial (
  1    10 	"aligned", "area", "auto", "automatic", "based", "bin",
  1    11 	"binary", "bit", "builtin", "char", "character", "complex",
  1    12 	"cond", "condition", "constant", "controlled", "cplx", "ctl",
  1    13 	"dec", "decimal", "def", "defined", "dim", "dimension",
  1    14 	"direct", "entry", "env", "environment", "ext", "external",
  1    15 	"file", "fixed", "float", "format", "generic", "init",
  1    16 	"initial", "input", "int", "internal", "irred", "irreducible",
  1    17 	"keyed", "label", "like", "local", "member", "nonvar",
  1    18 	"nonvarying", "offset", "options", "output", "parameter", "parm",
  1    19 	"pic", "picture", "pointer", "pos", "position", "prec",
  1    20 	"precision", "print", "ptr", "real", "record", "red",
  1    21 	"reducible", "returns", "seql", "sequential", "signed", "static",
  1    22 	"stream", "structure", "unal", "unaligned", "uns", "unsigned",
  1    23 	"update", "var", "variable", "varying", "~");
  1    24 
  1    25 dcl	system_keyword (15) char (16) aligned internal static initial (
  1    26 	"aliasable", "arg-descriptor", "interactive", "options-constant",
  1    27 	"options-variable", "parameter-desc", "reserved-1", "reserved-2",
  1    28 	"reserved-3", "reserved-4", "return-value", "stringvalue",
  1    29 	"storage-block", "temporary", "unused-1");
  1    30 
  1    31 dcl	bit_index (82) fixed bin (8) unal internal static initial (
  1    32 	22, /* aligned */  8, /* area */ 46, /* auto */ 46, /* automatic */ 47, /* based */ 30, /* bin */
  1    33 	30, /* binary */  4, /* bit */ 17, /* builtin */  5, /* char */  5, /* character */ 32, /* complex */
  1    34 	15, /* cond */ 15, /* condition */ 53, /* constant */ 49, /* controlled */ 32, /* cplx */ 49, /* ctl */
  1    35 	29, /* dec */ 29, /* decimal */ 50, /* def */ 50, /* defined */ 20, /* dim */ 20, /* dimension */
  1    36 	64, /* direct */ 10, /* entry */ 71, /* env */ 71, /* environment */ 39, /* ext */ 39, /* external */
  1    37 	11, /* file */  2, /* fixed */  3, /* float */ 16, /* format */ 18, /* generic */ 21, /* init */
  1    38 	21, /* initial */ 57, /* input */ 38, /* int */ 38, /* internal */ 35, /* irred */ 35, /* irreducible */
  1    39 	69, /* keyed */  9, /* label */ 40, /* like */ 28, /* local */ 41, /* member */ 42, /* nonvar */
  1    40 	42, /* nonvarying */  7, /* offset */ 43, /* options */ 58, /* output */ 51, /* parameter */ 51, /* parm */
  1    41 	19, /* pic */ 19, /* picture */  6, /* pointer */ 37, /* pos */ 37, /* position */ 26, /* prec */
  1    42 	26, /* precision */ 56, /* print */  6, /* ptr */ 31, /* real */ 62, /* record */ 34, /* red */
  1    43 	34, /* reducible */ 36, /* returns */ 63, /* seql */ 63, /* sequential */ 24, /* signed */ 48, /* static */
  1    44 	60, /* stream */  1, /* structure */ 23, /* unal */ 23, /* unaligned */ 25, /* uns */ 25, /* unsigned */
  1    45 	59, /* update */ 27, /* var */ 33, /* variable */ 27 /* varying */);
  1    46 
  1    47 dcl	system_bit_index (15) fixed bin (8) unal internal static initial (
  1    48 	72, /* aliasable */ 12, /* arg-descriptor */ 65, /* env(interactive) */
  1    49 	45, /* options(constant) */ 44, /* options(variable) */ 52, /* param-desc */
  1    50 	61, /* reserved-1 */ 66, /* reserved-2 */ 67, /* reserved-3 */
  1    51 	70, /* reserved-4 */ 55, /* return-value */ 68, /* env(stringvalue) */
  1    52 	13, /* storage-block */ 54, /* temporary */ 14 /* unused-1 */);
  1    53 
  1    54 dcl	incompatable (72) bit (72) aligned internal static initial (
  1    55 /*	          111111111122222222223333333333444444444455555555556666666666777
  1    56*	 123456789012345678901234567890123456789012345678901234567890123456789012
  1    57*	 ------------------------------------------------------------------------ */
  1    58 	"011111111111101111101001111111110111000001010000000010011111011110011010"b, /*  1 structure */
  1    59 	"101111111111101111100000001100000111100101010000000000011111011110011010"b, /*  2 fixed */
  1    60 	"110111111111101111100000101100000111100101010000000000011111011110011010"b, /*  3 float */
  1    61 	"111011111111101111100001110111110111000100010000000000011111011110011010"b, /*  4 bit */
  1    62 	"111101111111101111100001110111110111000100010000000000011111011110011010"b, /*  5 character */
  1    63 	"111110111111101111100001111111110111100101010000000010011111011110011010"b, /*  6 ptr */
  1    64 	"111111011111101111100001111111110111100101010000000010011111011110011010"b, /*  7 offset */
  1    65 	"111111101111101111100001111111110111100101010000000010011111011110011010"b, /*  8 area */
  1    66 	"111111110111101111100001111011110111100101010000000000011111011110011010"b, /*  9 label */
  1    67 	"111111111011101111100001111111110000100101000000000000011111011110011010"b, /* 10 entry */
  1    68 	"111111111101101111100001111111110111100101010000000000000000000000000000"b, /* 11 file */
  1    69 	"111111111110101111111111111111111111111111111111111101111111011110011010"b, /* 12 arg-descriptor */
  1    70 	"111111111111001111111111111111111111111111111111111101111111011110011010"b, /* 13 storage-block */
  1    71 	"000000000000000000000000000000000000000000000000000000000000000000000000"b, /* 14 unused-1 */
  1    72 	"111111111111100111111111111111111111110111111111111111111111011110011010"b, /* 15 condition */
  1    73 	"111111111111101011100001111011110111100101010000000000011111011110011010"b, /* 16 format */
  1    74 	"111111111111101101111111111111111111101111111111111111111111011110011010"b, /* 17 builtin */
  1    75 	"111111111111101110111111111111111111101111111111111111111111011110011010"b, /* 18 generic */
  1    76 	"111111111111101111000001111111000111000101010000000010011111011110011010"b, /* 19 picture */
  1    77 	"000000000001101011000000000000000000000000000000000000011111011110011010"b, /* 20 dimension */
  1    78 	"100000000001101011000000000000000000100100000000011111111111011110011010"b, /* 21 initial */
  1    79 	"000000000001101011000010000000000000000000000000000010011111011110011010"b, /* 22 aligned */
  1    80 	"000000000001101011000100000000000000000000000000000010011111011110011010"b, /* 23 unaligned */
  1    81 	"100111111111101111100000101100000111100101010000000000011111011110011010"b, /* 24 signed */
  1    82 	"101111111111101111100001001110010111100101010000000000011111011110011010"b, /* 25 unsigned */
  1    83 	"100111111111101111100000001100000111100101010000000000011111011110011010"b, /* 26 precision */
  1    84 	"111001111111101111100001110111110111100101010000000010011111011110011010"b, /* 27 varying */
  1    85 	"111111110111101011100001111011110111100101010000000010011111011110011010"b, /* 28 local */
  1    86 	"100111111111101111100000101101000111100101010000000000011111011110011010"b, /* 29 decimal */
  1    87 	"100111111111101111100000001110000111100101010000000000011111011110011010"b, /* 30 binary */
  1    88 	"100111111111101111000000001100010111100101010000000000011111011110011010"b, /* 31 real */
  1    89 	"100111111111101111000000101100100111100101010000000000011111011110011010"b, /* 32 cplx */
  1    90 	"000000000001101011000000000000000000000000000000000110011111011110011010"b, /* 33 variable */
  1    91 	"111111111011101111100001111111110010100101000000000000011111011110011010"b, /* 34 reducible */
  1    92 	"111111111011101111100001111111110100100101000000000000011111011110011010"b, /* 35 irreducible */
  1    93 	"111111111011101111100001111111110000100101000000000000011111011110011010"b, /* 36 returns */
  1    94 	"011001111111101111001001111111110111001010111111101111111111011110011010"b, /* 37 position */
  1    95 	"000000000001101000000000000000000000001000000000000100000000000000000000"b, /* 38 internal */
  1    96 	"000000000001100011000000000000000000110010001110011101100000000000000000"b, /* 39 external */
  1    97 	"011111111111101111101001111111110111000001010000000010011111011110011010"b, /* 40 like */
  1    98 	"000000000001101011000000000000000000101000001111111011111111011110011010"b, /* 41 member */
  1    99 	"111001111111101111100001111111110111000100010000000010011111011110011010"b, /* 42 nonvarying */
  1   100 	"000000000001101011000000000000000000100000000000000000011111011110011010"b, /* 43 options */
  1   101 	"111111111011101111100001111111110000100101000000000000011111011110011010"b, /* 44 options-variable */
  1   102 	"000000000001101011000000000000000000101010000110111111111111011110011010"b, /* 45 options-constant */
  1   103 	"000000000001101011000000000000000000101010001011111111111111011110011010"b, /* 46 automatic */
  1   104 	"000000000001101011000000000000000000101010001101111111111111011110011010"b, /* 47 based */
  1   105 	"000000000001101011000000000000000000100010000110111111111111011110011010"b, /* 48 static */
  1   106 	"000000000001101011000000000000000000100010001111011111111111011110011010"b, /* 49 ctl */
  1   107 	"000000000001101011001000000000000000001010001111101111111111011110011010"b, /* 50 defined */
  1   108 	"000000000001101011001000000000000000101010001111110111111111011110011010"b, /* 51 parm */
  1   109 	"000000000001101011001000000000001000111000001111111011111111011110011010"b, /* 52 parameter-desc */
  1   110 	"100001110000001011101110001100001000100111001111111101100000000000000000"b, /* 53 constant */
  1   111 	"000000000001101011001000000000000000101010001111111110111111011110011010"b, /* 54 temporary */
  1   112 	"000000000001101011001000000000000000101010001111111111011111011110011010"b, /* 55 return-value */
  1   113 	"111111111101101111111111111111111111100111111111111101101010011100011000"b, /* 56 print */
  1   114 	"111111111101101111111111111111111111100111111111111101110110000010000000"b, /* 57 input */
  1   115 	"111111111101101111111111111111111111100111111111111101101010000000000000"b, /* 58 output */
  1   116 	"111111111101101111111111111111111111100111111111111101111101000010000000"b, /* 59 update */
  1   117 	"111111111101101111111111111111111111100111111111111101100010011100011000"b, /* 60 stream */
  1   118 	"000000000000000000000000000000000000000000000000000000000000000000000000"b, /* 61 reserved-1 */
  1   119 	"111111111101101111111111111111111111100111111111111101110001000010000000"b, /* 62 record */
  1   120 	"111111111101101111111111111111111111100111111111111101110001000110000000"b, /* 63 sequential */
  1   121 	"111111111101101111111111111111111111100111111111111101110001001010000000"b, /* 64 direct */
  1   122 	"111111111101101111111111111111111111100111111111111101101010011100011000"b, /* 65 interactive */
  1   123 	"000000000000000000000000000000000000000000000000000000000000000000000000"b, /* 66 reserved-2 */
  1   124 	"000000000000000000000000000000000000000000000000000000000000000000000000"b, /* 67 reserved-3 */
  1   125 	"111111111101101111111111111111111111100111111111111101110001000010000000"b, /* 68 stringvalue */
  1   126 	"111111111101101111111111111111111111100111111111111101110001000010000000"b, /* 69 keyed */
  1   127 	"000000000000000000000000000000000000000000000000000000000000000000000000"b, /* 70 reserved-4 */
  1   128 	"111111111101101111111111111111111111100111111111111101100000000000000000"b, /* 71 environment */
  1   129 	"000000000000000000000000000000000000000000000000000000000000000000000000"b); /* 72 aliasable */
  1   130 /*	 ------------------------------------------------------------------------
  1   131*	          111111111122222222223333333333444444444455555555556666666666777
  1   132*	 123456789012345678901234567890123456789012345678901234567890123456789012 */
  1   133 
  1   134 /* END INCLUDE FILE ... pl1_attribute_table.incl.pl1 */
      636 
      637 
      638      end generate_compatible;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1508.9  generate_compatible.pl1           >dumps>old>recomp>generate_compatible.pl1
636          1    07/21/80  1546.3  pl1_attribute_table.incl.pl1      >ldd>include>pl1_attribute_table.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
N                               005306 automatic       fixed bin(17,0)          dcl 35 set ref 361* 362 362 363 365 428* 429 429 430
                                                                                  431
NL                                     constant        char(1)                  initial unaligned dcl 90 ref 286 294 332
NL_LESS                                constant        char(2)                  initial unaligned dcl 92 ref 291
WHITE                           000736 constant        char(3)                  initial unaligned dcl 94 ref 393 408
addr                                                   builtin function         dcl 100 ref 122 149 293 330 482
area                                   based           area(1024)               dcl 53 ref 362 429
area_                           000026 constant        entry                    external dcl 112 ref 127
bit_index                       000224 constant        fixed bin(8,0)           initial array unaligned dcl 1-31 ref 221 453
bits                            006200 automatic       bit(72)                  array unaligned dcl 44 set ref 169* 171* 181
c1                              000102 automatic       char(1)                  unaligned dcl 16 set ref 183* 184* 185* 186
chars                                  based           char(1)                  array unaligned dcl 52 set ref 293 330
chars72                         000103 automatic       char(72)                 unaligned dcl 17 set ref 186* 188* 189*
cleanup                         006422 stack reference condition                dcl 96 ref 124
code                            006013 automatic       fixed bin(35,0)          dcl 37 set ref 125* 241*
com_err_                        000016 constant        entry                    external dcl 109 ref 208 209
compatible_bnf$                 000012 external static fixed bin(17,0)          dcl 104 set ref 122
datap                     4            based           pointer                  array level 3 dcl 59 set ref 432* 501 503 506* 554*
                                                                                  557* 590*
depth                           006177 automatic       fixed bin(17,0)          dcl 43 set ref 276* 543 547* 547 548 552 558* 560*
                                                                                  581 584 586* 586 587 604
dx                              000100 automatic       fixed bin(17,0)          dcl 570 set ref 581* 581* 584
eof                             006420 automatic       bit(1)                   dcl 45 set ref 274* 303* 359 383
error_phase                     000127 automatic       fixed bin(17,0)          dcl 20 set ref 140* 148* 208
first_i                         006436 automatic       fixed bin(17,0)          dcl 216 set ref 219* 221 221* 226 226
formats                         000740 constant        char(48)                 initial array dcl 76 set ref 209*
gc_diff                         000011 internal static bit(1)                   initial unaligned dcl 89 set ref 174 626* 631*
gc_new                          000010 internal static bit(1)                   initial unaligned dcl 88 set ref 161 171 616* 621*
get_temp_segments_              000022 constant        entry                    external dcl 111 ref 125
i                               000102 automatic       fixed bin(17,0)          dcl 571 in procedure "markt" set ref 575* 576*
i                               006522 automatic       fixed bin(17,0)          dcl 470 in procedure "lookup" set ref 472* 472* 474
                                                                                  476* 481 482
i                               000100 automatic       fixed bin(17,0)          dcl 524 in procedure "mark" set ref 541* 542*
i                               006437 automatic       fixed bin(17,0)          dcl 217 in procedure "lookup_keyword" set ref 220*
                                                                                  221 221 224* 229* 230 230*
i                               006512 automatic       fixed bin(17,0)          dcl 448 in procedure "map_number" set ref 451* 451*
                                                                                  453 453 456* 456* 458 458
i                               000122 automatic       fixed bin(17,0)          dcl 602 in procedure "reflect" set ref 604* 605 606*
i                               000156 automatic       fixed bin(17,0)          dcl 25 in procedure "genc" set ref 131* 133 135 135*
                                                                                  153* 154 154* 167* 169 169 171 171* 171* 171* 179*
                                                                                  181 182 188 189* 189* 189* 286* 287 288 291* 292
                                                                                  293 313* 313* 316 318 365* 366 366* 368* 369 371*
                                                                                  386* 387 388 389 431* 432 432 433 435 436 436*
i                               000100 automatic       fixed bin(17,0)          dcl 489 in procedure "scan" set ref 495* 496*
i                               006456 automatic       fixed bin(17,0)          dcl 328 in procedure "get_line" set ref 332* 333 337
id                        1            based           varying char(36)         level 2 dcl 69 set ref 364*
incompatable                    000000 constant        bit(72)                  initial array dcl 1-54 ref 182
incompatible_bnf$               000014 external static fixed bin(17,0)          dcl 105 set ref 149
index                                                  builtin function         dcl 100 ref 286 291 294 332 386 399 404
ioa_                            000020 constant        entry                    external dcl 110 ref 162 163 164 165 171 175 176 177
                                                                                  178 189 191 192 193
j                               000157 automatic       fixed bin(17,0)          dcl 25 in procedure "genc" set ref 132* 133* 168*
                                                                                  169 169* 180* 181 182 186* 393* 395 396
j                               000101 automatic       fixed bin(17,0)          dcl 489 in procedure "scan" set ref 497* 498 500 501
                                                                                  503 506 507*
j                               000103 automatic       fixed bin(17,0)          dcl 571 in procedure "markt" set ref 577* 578 580
                                                                                  590*
j                               000101 automatic       fixed bin(17,0)          dcl 524 in procedure "mark" set ref 544* 545 548*
                                                                                  551* 554 556 556 557*
k                               000106 automatic       fixed bin(17,0)          dcl 528 in procedure "mark" set ref 553* 554 554
                                                                                  554*
k                               000160 automatic       fixed bin(17,0)          dcl 25 in procedure "genc" set ref 399* 400 404* 405
                                                                                  408* 409 412 414
keyword                         000345 constant        char(11)                 initial array dcl 1-9 ref 220 224 226 451 451 453
line                                   based           char                     unaligned dcl 50 set ref 209* 338 343 343 343 359
                                                                                  385 386 388 393 397 399 402 404 408 412
linel                           000161 automatic       fixed bin(17,0)          dcl 26 set ref 209 209 288* 294* 295 330 337* 338
                                                                                  343 343 343 359 385 386 388 393 397 399 402 404
                                                                                  408 412
linep                           000100 automatic       pointer                  dcl 15 set ref 209 277* 293* 293 294 298 304* 330*
                                                                                  330 332 334* 338 340* 343 343 343 359 385 386 388
                                                                                  393 397 399 402 404 408 412
mark_value                             parameter       bit(1)                   dcl 569 in procedure "markt" set ref 566 590*
mark_value                             parameter       bit(1)                   dcl 523 in procedure "mark" set ref 520 554* 556*
                                                                                  557*
mark_value                             parameter       bit(1)                   dcl 600 in procedure "reflect" ref 597 605 606
matrix                          005307 automatic       bit(1)                   array unaligned dcl 36 set ref 133* 135* 154* 169
                                                                                  605* 606*
me                              000737 constant        char(2)                  initial unaligned dcl 87 set ref 125* 241*
name                            000544 automatic       varying char(36)         array level 2 in structure "symbols" dcl 30
                                                                                  in procedure "genc" set ref 318 369 376* 472 477*
name                                   based           varying char(36)         level 2 in structure "symbol" dcl 54 in procedure
                                                                                  "genc" ref 503
name                                   parameter       varying char(36)         dcl 446 in procedure "map_number" ref 444 450 451
                                                                                  456
new                             000125 automatic       bit(1)                   unaligned dcl 18 set ref 181* 183
next_pr                         000131 automatic       fixed bin(17,0)          dcl 22 set ref 279* 361 379* 439 440* 440
next_term                       000130 automatic       fixed bin(17,0)          dcl 21 set ref 278* 412 413* 413 428 441*
nsymbols                        006022 automatic       fixed bin(17,0)          dcl 41 set ref 275* 313 316 368 375* 375 376 377 378
                                                                                  472 474 476 476* 477 478
nt                                     based           structure                level 1 dcl 69 set ref 362
nt_ptr                   12     000544 automatic       pointer                  array level 2 in structure "symbols" packed
                                                                                  unaligned dcl 30 in procedure "genc" set ref 371*
                                                                                  377* 478*
nt_ptr                   12            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 54 in procedure "genc" ref 309 501
ntp                             006466 automatic       pointer                  dcl 352 set ref 362* 363 364 366 371 377
null                                                   builtin function         dcl 100 ref 123 273 298 310 334 340 478 502
nump                                   based           fixed bin(17,0)          level 2 dcl 69 set ref 362* 363* 495 541 575
numt                                   based           fixed bin(17,0)          level 2 dcl 59 set ref 429* 430* 497 544 551 553 577
old                             000126 automatic       bit(1)                   unaligned dcl 19 set ref 182* 183 184
p                                      parameter       pointer                  dcl 522 in procedure "mark" ref 520 541 542
p                                      parameter       pointer                  dcl 568 in procedure "markt" ref 566 575 576
pname                           000132 automatic       varying char(36)         dcl 23 set ref 280* 359 364 369 376 388*
pp                              000102 automatic       pointer                  dcl 490 in procedure "scan" set ref 496* 497 498 500
                                                                                  501 503 506 507
pp                              000102 automatic       pointer                  dcl 525 in procedure "mark" set ref 542* 544 545 548
                                                                                  551 553 554 554 556 556 557
pp                              000104 automatic       pointer                  dcl 572 in procedure "markt" set ref 576* 577 578
                                                                                  580 590
pp                              006500 automatic       pointer                  dcl 426 in procedure "finish_production" set ref
                                                                                  429* 430 432 435 436 439
pr                                     based           structure                level 1 dcl 59 set ref 429
pr_ptrs                         000164 automatic       pointer                  array dcl 28 set ref 366 439*
processed                 2(01)        based           bit(1)                   array level 3 packed unaligned dcl 59 set ref 500
                                                                                  507*
prod                     14            based           pointer                  array level 2 dcl 69 set ref 366* 496 542 576
ptrs                            005304 automatic       pointer                  array dcl 34 set ref 123* 125* 126 241*
q                               000104 automatic       pointer                  dcl 490 set ref 501* 502 506 508*
release_temp_segments_          000024 constant        entry                    external dcl 111 ref 241
rootp                           006016 automatic       pointer                  dcl 39 set ref 143* 152* 273* 309* 310 311*
rp                                     parameter       pointer                  dcl 488 ref 486 495 496
save_depth                      000104 automatic       fixed bin(17,0)          dcl 526 set ref 543* 560
save_depth1                     000105 automatic       fixed bin(17,0)          dcl 527 set ref 552* 558
search                                                 builtin function         dcl 100 ref 408
search_name                     000144 automatic       varying char(36)         dcl 24 set ref 209* 318* 450* 503*
stack                           006023 automatic       fixed bin(17,0)          array dcl 42 set ref 548* 581 587* 605 606
substr                                                 builtin function         dcl 100 set ref 169* 181 182 186* 188* 284 338 343
                                                                                  343 343 359 385 388 393 397 399 402 404 408 412
                                                                                  433
symbol                                 based           structure                level 1 unaligned dcl 54
symbols                         000544 automatic       structure                array level 1 dcl 30 set ref 482
system_bit_index                000220 constant        fixed bin(8,0)           initial array unaligned dcl 1-47 ref 230 458
system_keyword                  000251 constant        char(16)                 initial array dcl 1-25 ref 229 230 456 456 458
temp                            006020 automatic       pointer                  dcl 40 set ref 126* 127* 362 429
term                      2            based           structure                array level 2 dcl 59
term_names                      000234 automatic       varying char(36)         array dcl 29 set ref 412* 432* 433 436*
terminal                  2            based           bit(1)                   array level 3 packed unaligned dcl 59 set ref 435*
                                                                                  498 545 554 556 578
tname                                  parameter       varying char(36)         dcl 469 ref 467 472 477
total_buffer                           based           char(8000)               unaligned dcl 51 ref 284 286 291 294 332
tx                              000162 automatic       fixed bin(17,0)          dcl 27 set ref 358* 389* 393 396* 396 397 399 402
                                                                                  404 408 412 414* 414
txp                             006014 automatic       pointer                  dcl 38 set ref 122* 149* 277 284 286 291 304
unused                   13     000544 automatic       bit(1)                   array level 2 dcl 30 set ref 313 378* 481*
v                               000101 automatic       fixed bin(17,0)          dcl 570 set ref 580* 581 587
value                     3            based           fixed bin(17,0)          array level 3 dcl 59 set ref 436* 548 556* 580
verify                                                 builtin function         dcl 100 ref 393
x                                      parameter       fixed bin(17,0)          dcl 599 in procedure "reflect" ref 597 605 606
x                                      parameter       fixed bin(17,0)          dcl 206 in procedure "ERROR" set ref 204 208* 209
x                                      parameter       fixed bin(17,0)          dcl 215 in procedure "lookup_keyword" ref 213 221
                                                                                  230

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
index_given_letter                     internal static fixed bin(8,0)           initial array unaligned dcl 1-5

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           002343 constant        entry                    internal dcl 204 ref 287 292 295 310 319 387 400 405
                                                                                  461 504
GLOBAL_ERROR                    002267 constant        label                    dcl 200 ref 210
clean                           002603 constant        entry                    internal dcl 239 ref 124 197 200
done                            003252 constant        label                    dcl 379 ref 372
dummy_line                      003064 constant        label                    dcl 330 ref 344
finish_production               003501 constant        entry                    internal dcl 419 ref 300
gc_reset_diff                   002332 constant        entry                    external dcl 629
gc_reset_new                    002307 constant        entry                    external dcl 619
gc_set_diff                     002320 constant        entry                    external dcl 624
gc_set_new                      002275 constant        entry                    external dcl 614
genc                            001436 constant        entry                    external dcl 11
generate_compatible             001445 constant        entry                    external dcl 11
get_line                        003063 constant        entry                    internal dcl 326 ref 301
lookup                          003713 constant        entry                    internal dcl 467 ref 309 432
lookup_keyword                  002471 constant        entry                    internal dcl 213 ref 171 171 189 189
map_number                      003577 constant        entry                    internal dcl 444 ref 436
mark                            004111 constant        entry                    internal dcl 520 ref 143 152 557
markt                           004302 constant        entry                    internal dcl 566 ref 554 590
next_token                      003323 constant        label                    dcl 393 ref 415
parse_bnf                       002632 constant        entry                    internal dcl 249 ref 142 151
parse_production                003132 constant        entry                    internal dcl 350 ref 299 305
reflect                         004413 constant        entry                    internal dcl 597 ref 556
scan                            003773 constant        entry                    internal dcl 486 ref 311 508

NAME DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 220 229 451 453 456 458

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5274        5324    5067        5304
Length      5560    5067        30         220     204           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
genc                               3521 external procedure  is an external procedure.  
on unit on line 124                  64 on unit               
ERROR                               106 internal procedure  is called by several nonquick procedures.  
lookup_keyword                          internal procedure  shares stack frame of external procedure genc.  
clean                                78 internal procedure  is called by several nonquick procedures.  
parse_bnf                               internal procedure  shares stack frame of external procedure genc.  
get_line                                internal procedure  shares stack frame of external procedure genc.  
parse_production                        internal procedure  shares stack frame of external procedure genc.  
finish_production                       internal procedure  shares stack frame of external procedure genc.  
map_number                              internal procedure  shares stack frame of external procedure genc.  
lookup                                  internal procedure  shares stack frame of external procedure genc.  
scan                                 80 internal procedure  calls itself recursively.  
mark                                 94 internal procedure  calls itself recursively.  
markt                                82 internal procedure  calls itself recursively.  
reflect                                 internal procedure  shares stack frame of internal procedure mark.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 gc_new                      genc
000011 gc_diff                     genc

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
genc                     000100 linep                       genc
                         000102 c1                          genc
                         000103 chars72                     genc
                         000125 new                         genc
                         000126 old                         genc
                         000127 error_phase                 genc
                         000130 next_term                   genc
                         000131 next_pr                     genc
                         000132 pname                       genc
                         000144 search_name                 genc
                         000156 i                           genc
                         000157 j                           genc
                         000160 k                           genc
                         000161 linel                       genc
                         000162 tx                          genc
                         000164 pr_ptrs                     genc
                         000234 term_names                  genc
                         000544 symbols                     genc
                         005304 ptrs                        genc
                         005306 N                           genc
                         005307 matrix                      genc
                         006013 code                        genc
                         006014 txp                         genc
                         006016 rootp                       genc
                         006020 temp                        genc
                         006022 nsymbols                    genc
                         006023 stack                       genc
                         006177 depth                       genc
                         006200 bits                        genc
                         006420 eof                         genc
                         006436 first_i                     lookup_keyword
                         006437 i                           lookup_keyword
                         006456 i                           get_line
                         006466 ntp                         parse_production
                         006500 pp                          finish_production
                         006512 i                           map_number
                         006522 i                           lookup
mark                     000100 i                           mark
                         000101 j                           mark
                         000102 pp                          mark
                         000104 save_depth                  mark
                         000105 save_depth1                 mark
                         000106 k                           mark
                         000122 i                           reflect
markt                    000100 dx                          markt
                         000101 v                           markt
                         000102 i                           markt
                         000103 j                           markt
                         000104 pp                          markt
scan                     000100 i                           scan
                         000101 j                           scan
                         000102 pp                          scan
                         000104 q                           scan

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_ext             signal              enable              ext_entry           int_entry           alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_                         com_err_                      get_temp_segments_            ioa_
release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
compatible_bnf$               incompatible_bnf$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 001435       122 001452       123 001454       124 001456       125 001500       126 001521       127 001523
    131 001536       132 001543       133 001550       134 001556       135 001560       136 001566       140 001570
    142 001571       143 001572       148 001604       149 001606       151 001611       152 001612       153 001624
    154 001631       155 001636       161 001640       162 001643       163 001656       164 001672       165 001706
    167 001722       168 001727       169 001734       170 001751       171 001753       172 002017       174 002021
    175 002024       176 002037       177 002053       178 002067       179 002103       180 002110       181 002115
    182 002127       183 002133       184 002141       185 002146       186 002150       187 002154       188 002156
    189 002162       190 002214       191 002216       192 002232       193 002246       197 002262       198 002266
    200 002267       202 002273       614 002274       616 002302       617 002305       619 002306       621 002314
    622 002316       624 002317       626 002325       627 002330       629 002331       631 002337       632 002341
    204 002342       208 002350       209 002417       210 002466       213 002471       219 002473       220 002474
    221 002501       224 002517       225 002527       226 002531       229 002543       230 002550       232 002572
    234 002574       239 002602       241 002610       243 002631       249 002632       273 002633       274 002635
    275 002636       276 002637       277 002640       278 002642       279 002644       280 002645       284 002646
    286 002652       287 002664       288 002675       289 002677       291 002700       292 002712       293 002723
    294 002727       295 002741       298 002752       299 002756       300 002757       301 002760       302 002761
    303 002762       304 002764       305 002766       309 002767       310 003001       311 003015       313 003023
    314 003035       316 003037       318 003042       319 003052       322 003062       326 003063       330 003064
    332 003070       333 003102       334 003103       335 003105       337 003106       338 003107       340 003113
    341 003115       343 003116       344 003131       350 003132       358 003133       359 003135       361 003151
    362 003154       364 003165       365 003172       366 003201       367 003205       368 003207       369 003216
    371 003227       372 003231       374 003232       375 003234       376 003235       377 003246       378 003250
    379 003252       383 003254       385 003257       386 003264       387 003276       388 003307       389 003320
    393 003323       395 003343       396 003345       397 003346       399 003355       400 003373       401 003404
    402 003405       404 003407       405 003425       406 003436       408 003437       409 003455       412 003457
    413 003475       414 003476       415 003500       419 003501       428 003502       429 003505       431 003516
    432 003524       433 003541       435 003550       436 003554       438 003565       439 003567       440 003573
    441 003574       442 003576       444 003577       450 003601       451 003607       452 003625       453 003627
    456 003643       457 003661       458 003663       461 003677       463 003707       467 003713       472 003715
    473 003736       474 003740       476 003743       477 003747       478 003761       481 003763       482 003766
    486 003772       495 004000       496 004011       497 004017       498 004026       500 004033       501 004036
    502 004041       503 004046       504 004054       506 004065       507 004071       508 004074       511 004103
    512 004105       514 004107       520 004110       541 004116       542 004127       543 004135       544 004140
    545 004147       547 004155       548 004157       550 004162       551 004164       552 004173       553 004176
    554 004205       555 004231       556 004233       557 004254       558 004266       559 004271       560 004273
    561 004276       562 004300       566 004301       575 004307       576 004320       577 004326       578 004335
    580 004343       581 004345       582 004361       584 004363       586 004367       587 004370       589 004373
    590 004374       591 004406       592 004410       593 004412       597 004413       604 004415       605 004425
    606 004437       607 004445       609 004447


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
