	COMPILATION LISTING OF SEGMENT library_cleanup
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0856.1 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* Modified:  January, 1984 by Jim Lippard to align structures passed to lib_args_			*/
       11 
       12 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       13 
       14 
       15 library_cleanup: lcln:	procedure
       16 		options	(rename ((alloc_, smart_alloc_)));
       17 
       18      dcl						/*	automatic variables			*/
       19 	Bgrace_begins		bit(36) aligned,	/* time grace period begins (fstime in bits).	*/
       20 	Idelete			fixed bin,	/* count of nodes to be deleted.		*/
       21 	Inode			fixed bin,	/* count of nodes which are candidates for delete	*/
       22 	Ngrace_begins		fixed bin(71),	/* time grace period begins.			*/
       23 	Parea			ptr,		/* ptr to an MSA.				*/
       24 	Pdelete			ptr,		/* ptr to node currently being deleted.		*/
       25 	Pprev_parent		ptr,		/* ptr to parent of node just listed/deleted.	*/
       26 	Ptree			ptr,		/* ptr to a tree of status nodes.		*/
       27 	1 arg_struc_temp		like arg_struc,	/* storage for argument structure.		*/
       28 	code			fixed bin(35),	/* a status code.				*/
       29 	dir			char(168) varying,	/* dir part of node pathname.			*/
       30 	ent			char(32)  varying,	/* ent part of node pathname.		*/
       31 	1 fcb_temp		like fcb,		/* storage for file control block.		*/
       32 	i			fixed bin,	/* a do-group index.			*/
       33 	prev_dir			char(168) varying,	/* dir part of prev node pathname.		*/
       34 	prev_ent			char(32)  varying,	/* ent part of prev node pathname.		*/
       35 	progress			fixed bin init (0),	/* integer indicating progress of our search.	*/
       36 						/*   0 = search beginning.			*/
       37 						/*   1 = finding library descriptor.		*/
       38 						/*   2 = seeing if library_cleanup command	*/
       39 						/*       supported by this descriptor.		*/
       40 						/*   3 = getting default library names if user	*/
       41 						/*       specified none.			*/
       42 						/*   4 = getting default search names if user	*/
       43 						/*       specified none.			*/
       44 						/*   5 = allocating the root nodes of the tree.	*/
       45 						/*   6 = searching each library root for entries	*/
       46 						/*       identified by the search names.	*/
       47 						/*   7 = no entries matching search names found.	*/
       48 	state			char(16),		/* an error temporary char string.		*/
       49 	unset_depth		fixed bin,	/* height/depth up/down tree to which access	*/
       50 	yes_no			char(3) varying;	/* answer to a command_query_ question.		*/
       51 						/*   was set and must be unset.		*/
       52 
       53      dcl						/* 	based variables			*/
       54 	area			area based (Parea),	/* an MSA (multi-segment area).		*/
       55 	Ngrace_begins_bits		bit(72) based (addr(Ngrace_begins));
       56 						/* bit string overlay for Ngrace_begins.	*/
       57 
       58      dcl (addr, min, null, substr)
       59 				builtin;
       60      dcl	cleanup			condition;
       61 
       62      dcl						/*	Entries Called			*/
       63 	clock_			entry returns (fixed bin(71)),
       64          (com_err_,
       65 	com_err_$suppress_name)	entry options(variable),
       66 
       67 	command_query_		entry options(variable),
       68 	condition_		entry (char(*) aligned, entry),
       69 	cu_$arg_count		entry returns (fixed bin),
       70 	cu_$arg_list_ptr		entry returns(ptr),
       71 	delete_$path 		entry (char(*), char(*), bit(6), char(*), fixed bin(35)),
       72 	get_line_length_$switch	entry (ptr, fixed bin(35)) returns (fixed bin),
       73 	get_ring_			entry returns (fixed bin),
       74 	get_system_msa_		entry (ptr, fixed bin, ptr),
       75 	hcs_$set_copysw		entry (char(*), char(*), bit(1), fixed bin(35)),
       76 	hcs_$set_safety_sw		entry (char(*), char(*), bit(1), fixed bin(35)),
       77 	ioa_			entry options(variable),
       78 	installation_tools_$set_ring_brackets
       79 				entry (char(*), char(*), (3) fixed bin(3), fixed bin(35)),
       80 	lib_access_mode_$set	entry (ptr, bit(36) aligned, fixed bin, fixed bin(35)),
       81 	lib_access_mode_$unset	entry (ptr, fixed bin, fixed bin(35)),
       82 	lib_args_			entry (1 aligned like LIBRARY, 1 aligned like STARNAME, 1 aligned like STARNAME, bit(72) aligned,
       83 				       bit(36) aligned, ptr, fixed bin(35)),
       84 	lib_descriptor_$cleanup	entry (char(168) varying, ptr, ptr, ptr, bit(72) aligned,  bit(36) aligned,
       85 				       ptr, ptr, fixed bin, fixed bin(35)),
       86 	lib_error_list_		entry (char(32) varying, ptr, char(32) varying),
       87 	lib_node_path_		entry (ptr, char(168) varying, char(32) varying),
       88 	lib_output_node_$cleanup	entry (ptr, ptr, bit(72) aligned, fixed bin, ptr, fixed bin, ptr),
       89 	lib_sort_tree_$make_node_list
       90 				entry (ptr, ptr, fixed bin(35)),
       91 	msa_manager_$area_handler	entry,
       92 	release_system_msa_		entry (ptr, fixed bin(35)),
       93 	system_info_$titles		entry (char(*) aligned, char(*) aligned, char(*) aligned,
       94 				       char(*) aligned);
       95 
       96      dcl						/*	static variables			*/
       97 	False			bit(1) aligned int static options(constant) init ("0"b),
       98 	True			bit(1) aligned int static options(constant) init ("1"b),
       99 	comment (0:1)		char(28) varying int static options(constant) init (
      100 				     "listed",
      101 				     "flagged with an asterisk (*)"),
      102          (error_table_$noarg,
      103 	error_table_$nomatch,
      104 	error_table_$not_done,
      105 	error_table_$out_of_bounds)	fixed bin(35) ext static,
      106 	iox_$user_output		ptr ext static,
      107 	ring (3)			fixed bin(3) int static init ((3)0),
      108 	sys_info$time_of_bootload	fixed bin(71) ext static;
      109 						/* iox_ opening mode for stream-output I/O.	*/
      110 
      111 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      112 
      113 
      114 	Parg_struc = addr(arg_struc_temp);		/* Initialize argument processing structure.	*/
      115 	arg_struc.version = Varg_struc_1;
      116 	arg_struc.program = "library_cleanup";
      117 	arg_struc.Parg_list = cu_$arg_list_ptr();
      118 	arg_struc.Iarg_list = 1;
      119 	arg_struc.Larg_list = cu_$arg_count();
      120 	arg_struc.put_error = com_err_;
      121 	arg_struc.Srequirements_allowed = ""b;
      122 	arg_struc.Srequirements_initial = ""b;
      123 	arg_struc.Scontrol_allowed = ""b;
      124 	arg_struc.Scontrol_initial = ""b;
      125 
      126 
      127 	Sc_allowed.descriptor     = True;		/* Mark Sc bits- show which ctl args allowed.	*/
      128 	Sc_allowed.library        = True;
      129 	Sc_allowed.search_names   = True;
      130 	Sc_allowed.delete         = True;
      131 	Sc_allowed.list           = True;
      132 	Sc_allowed.long           = True;
      133 	Sc_allowed.time           = True;
      134 
      135 	Sc_init.time              = True;
      136 	arg_struc.time = 7;				/* set default grace time of 7 days.		*/
      137 
      138 	call lib_args_ (LIBRARY, STARNAME, EXCLUDE, Srequirements, Scontrol, addr(arg_struc), code);
      139 	if code ^= 0 then return;			/* call subr to process all arguments.		*/
      140 
      141 	if arg_struc.time < 0 then go to BAD_TIME;
      142 
      143 	Sc.default = True;				/* give user default output.			*/
      144 
      145 	if Sc.long then Sc.list = True;		/* -long implies -list.			*/
      146 
      147 	if ^Sc.list then if ^Sc.delete then Sc.list = True;
      148 						/* -list is the default.			*/
      149 
      150 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      151 	/*									*/
      152 	/* 1) establish cleanup on unit.						*/
      153 	/* 2) get ptr to system multi-segment area.					*/
      154 	/* 3) search and build status tree for library entries which are candidates for deletion.	*/
      155 	/* 4) make a list of the entries found.						*/
      156 	/* 5) initialize file control block.						*/
      157 	/*									*/
      158 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      159 
      160 	Parea = null;
      161 	Pprev_parent = null;
      162 	unset_depth = 0;
      163 	Pdelete = null;
      164 	on cleanup call janitor;
      165 
      166 	call get_system_msa_ (addr(Parea), 0, null);
      167 	call condition_ ("area", msa_manager_$area_handler);
      168 
      169 	Plibrary = addr(LIBRARY);
      170 	Pstarname = addr(STARNAME);
      171 	Pexclude = addr(EXCLUDE);
      172 	call lib_descriptor_$cleanup (arg_struc.descriptor, Plibrary, Pstarname, Pexclude,
      173 	     Srequirements, Scontrol, Parea, Ptree, progress, code);
      174 	if code ^= 0 then go to BAD_SEARCH;
      175 
      176 	allocate node_list in (area);
      177 	node_list.I = 0;
      178 	call lib_sort_tree_$make_node_list (Ptree, Pnode_list, code);
      179 	if code ^= 0 then go to NO_MATCH; 
      180 
      181 	Pfcb = addr(fcb_temp);
      182 	fcb.version = Vfcb_1;
      183 	fcb.ioname = "user_output";			/* print output on user's terminal.		*/
      184 	fcb.Piocb = iox_$user_output;
      185 	fcb.Eend_page = no_end_page;
      186 	fcb.page_length = 131071;			/* use large page size to avoid footings.	*/
      187 	fcb.page_text_length = 131071;
      188 	fcb.page_no = 1;
      189 	fcb.line_length = get_line_length_$switch (fcb.Piocb, code);
      190 	if code ^= 0 then fcb.line_length = 79;
      191 	fcb.line_no = 2;				/* prevent new_line from being suppressed before	*/
      192 						/*   the first entry.  They're suppressed for 1st	*/
      193 						/*   line of a page.			*/
      194 
      195 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      196 	/*									*/
      197 	/* 1) Compute date on which grace period began.  It must be before time system came up.	*/
      198 	/* 2) For each node in the list (nodes which are candidates for deletion):		*/
      199 	/*    A) Set Svalid.delete on if node not modified within the grace period.		*/
      200 	/*    B) If -list given, output the node in a numbered list, flagging those to be deleted.*/
      201 	/* 3) If -delete given without -list, ask if user really wants to delete without listing.	*/
      202 	/*    Abide by his decision.  If the answer is yes, proceed with step 5.		*/
      203 	/* 4) Else if -delete given with -list, ask if user wants to delete flagged entries.	*/
      204 	/*    If the answer is yes, proceed with step 5.					*/
      205 	/*    If the answer is no,  then quit.						*/
      206 	/* 5) Delete the list entries eligible for deletion.				*/
      207 	/*    Only links, segments, directories, MSFs, MSF components and archives can be deleted.*/
      208 	/*									*/
      209 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      210 
      211 
      212 	Ngrace_begins = clock_() - (arg_struc.time * 86400000000);
      213 						/* subtract grace (days * micro_sec/day) from now.*/
      214 	Ngrace_begins = min (Ngrace_begins, sys_info$time_of_bootload);
      215 						/* don't delete anything if someone could be using*/
      216 						/*   it (ie, it was marked out of circulation 	*/
      217 						/*   after system came up).			*/
      218 	Bgrace_begins = substr(Ngrace_begins_bits,21,36);	
      219 
      220 	Inode = 0;
      221 	Idelete = 0;
      222 	Pprev_parent = null;
      223 	do i = 1 to node_list.I;
      224 	     Pnode = node_list.e(i);
      225 	     if node.dtem < Bgrace_begins then do;
      226  		Svalid.delete = True;
      227 		Idelete = Idelete + 1;
      228 		end;
      229 	     else Svalid.delete = False;
      230 	     if Sc.long | (Sc.list & Svalid.delete) then do;
      231 		Inode = Inode + 1;
      232 		call lib_output_node_$cleanup (Pfcb, Pnode, (72)"1"b, 0, Pstarname, Inode, Pprev_parent);
      233 		Pprev_parent = node.Pparent;
      234 		end;
      235 	     end;
      236 	if Inode > 0 then call ioa_ ("");
      237 
      238 	if Idelete = 0 then do;
      239 	     code = error_table_$nomatch;
      240 	     go to NO_MATCH;
      241 	     end;
      242 
      243 
      244 	if Sc.delete then do;
      245 	     query_info.version = 2;
      246 	     query_info.yes_or_no_sw = True;
      247 	     query_info.suppress_name_sw = False;
      248 	     query_info.status_code = 0;
      249 	     query_info.query_code = 0;
      250 	     if ^Sc.list then do;
      251 		call com_err_$suppress_name (0, arg_struc.program, "
      252   Grace Time:^-^5x^d days
      253   Descriptor:^-^5x^a", arg_struc.time,  arg_struc.descriptor);
      254 		call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      255 		call lib_error_list_ ("search name", Pstarname, arg_struc.program);
      256 		call command_query_ (addr(query_info), yes_no, arg_struc.program, "
      257   Given the information above, ^d library entries are eligible for deletion.
      258   Do you want to delete them?", Idelete);
      259 		if yes_no = "no" then go to FINISH;
      260 		end;
      261 	     else do;
      262 		call command_query_ (addr(query_info), yes_no, arg_struc.program, "
      263   Do you want to delete ALL of the ^d entries ^a above?", Idelete, comment (binary (Sc.long,1)));
      264 		if yes_no = "no" then go to FINISH;
      265 		end;
      266 	     Pprev_parent = null;
      267 	     do i = 1 to node_list.I;
      268 		Pnode = node_list.e(i);
      269 		if Svalid.delete then do;
      270 		     Pdelete = Pnode;
      271 		     call delete_entry (Pnode, Pprev_parent);
      272 		     Pdelete = null;
      273 		     Pprev_parent = node.Pparent;
      274 		     end;
      275 		end;
      276 	     end;
      277 
      278 FINISH:	call janitor;				/* clean up.				*/
      279 	return;
      280 
      281 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      282 
      283 
      284 delete_entry:	procedure (Pnode_, Pprev_parent);	/* internal procedure to delete a library entry.	*/
      285 
      286      dcl	Pnode_			ptr,		/* ptr to node for entry to be deleted.		*/
      287 	Pprev_parent		ptr;		/* ptr to parent node for last node deleted.	*/
      288 
      289      dcl	1 node_			like node based (Pnode_);
      290 		
      291 		
      292 	call lib_node_path_ (Pnode_, dir, ent);		/* get pathname of entry to be deleted.		*/
      293 
      294 	if node_.T = Tarchive_comp then do;		/* cannot delete archive components.		*/
      295 	     call com_err_ (error_table_$not_done, arg_struc.program, "
      296   Unable to delete archive components, such as
      297   ^a>^a", dir, ent);
      298 	     end;
      299 	else if node_.T = Tlink & node_.Pparent->node_.T ^= Tdirectory then do;
      300 	     call com_err_ (error_table_$not_done, arg_struc.program, "
      301   Unable to unlink links which are the target of library links, such as
      302   ^a>^a.  Library links themselves may be unlinked.", dir, ent);
      303 	     end;
      304 	else do;
      305 	     if Pprev_parent ^= node_.Pparent then do;	/* make sure user has access to delete entry.	*/
      306 		if Pprev_parent ^= null then do;
      307 		     call lib_access_mode_$unset (Pprev_parent, unset_depth, code);
      308 		     if code ^= 0 then do;
      309 			call lib_node_path_ (Pprev_parent, prev_dir, prev_ent);
      310 			call com_err_ (code, arg_struc.program, "
      311   While restoring the ACL of the library ^a
      312   ^a>^a.", node_type(Pprev_parent->node_.T), prev_dir, prev_ent);
      313 			end;
      314 		     Pprev_parent = null;
      315 		     end;
      316 		call lib_access_mode_$set ((node_.Pparent), "110"b, unset_depth, code);
      317 		if code ^= 0 then do;
      318 		     call com_err_ (code, arg_struc.program, "
      319   Unable to obtain modify access to the library ^a
      320   ^a
      321   containing entries to be deleted.", node_type(node_.Pparent->node_.T), dir);
      322 		     end;
      323 		end;
      324 
      325 	     if node_.T ^= Tlink then do;		/* take special precautions for non-links.	*/
      326 		if ring(1) = 0 then ring = get_ring_();	/*     make sure entry is in our ring.		*/
      327 		if node_.rb(1) < ring(1) then do;
      328 		     call installation_tools_$set_ring_brackets ((dir), (ent), ring, code);
      329 		     if code ^= 0 then
      330 			call com_err_ (code, arg_struc.program, "
      331   Unable to set ring brackets on library ^a
      332   ^a>^a.", node_type(node_.T), dir, ent);
      333 		     end;
      334 		if node_.Ssafety then do;		/*     Turn off safety switch to ease deletion.	*/
      335 		     call hcs_$set_safety_sw ((dir), (ent), "0"b, code);
      336 		     if code ^= 0 then
      337 			call com_err_ (code, arg_struc.program, "
      338   Unable to turn off safety switch of library ^a
      339   ^a>^a.", node_type(node_.T), dir, ent);
      340 		     end;
      341 		if node_.Scopy then do;		/*     Turn off copy switch to ease deletion.	*/
      342 		     call hcs_$set_copysw ((dir), (ent), "0"b, code);
      343 		     if code ^= 0 then
      344 			call com_err_ (code, arg_struc.program, "
      345   Unable to turn off copy switch of library ^a
      346   ^a>^a.", node_type(node_.T), dir, ent);
      347 		     end;
      348 		end;
      349 
      350 	     call delete_$path ((dir), (ent), "011110"b, (arg_struc.program), code);
      351 	     if code ^= 0 then do;			/* delete the library entry.			*/
      352 		call com_err_ (code, arg_struc.program, "
      353   Unable to delete library ^a
      354   ^a>^a", node_type(node_.T), dir, ent);
      355 		if node_.Scopy then
      356 		     call hcs_$set_copysw ((dir), (ent), "1"b, code);
      357 		if node_.Ssafety then
      358 		     call hcs_$set_safety_sw ((dir), (ent), "1"b, code);
      359 		if node_.rb(1) < ring(1) then
      360 		     call installation_tools_$set_ring_brackets ((dir), (ent), node_.rb, code);
      361 		end;
      362 	     end;
      363 	end delete_entry;
      364 
      365 
      366 
      367 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      368 
      369 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      370 
      371 
      372 janitor:	procedure;				/* cleanup procedure.			*/
      373 
      374 	if Pprev_parent ^= null then do;
      375 	     call lib_access_mode_$unset (Pprev_parent, unset_depth, code);
      376 	     Pprev_parent = null;
      377 	     end;
      378 	if Pdelete ^= null then do;
      379 	     call lib_node_path_ (Pdelete, prev_dir, prev_ent);
      380 	     call com_err_ (error_table_$not_done, arg_struc.program, "
      381   Cleanup occurred while deleting library ^a
      382   ^a>^a.
      383   This entry may not be completely deleted.  Those which follow
      384   it have not been deleted.", node_type(Pdelete->node.T), prev_dir, prev_ent);
      385 	     end;
      386 	if Parea ^= null then			/* cleanup by releasing any system MSA.		*/
      387 	     call release_system_msa_ (addr(Parea), code);
      388 
      389 	end janitor;
      390 
      391 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      392 
      393 
      394 no_end_page:	procedure;			/* This is a null end-of-page handling proc.	*/
      395 
      396 	fcb.page_no = fcb.page_no + 1;
      397 	fcb.line_no = 2;
      398 
      399 	end no_end_page;
      400 
      401 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      402 
      403 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      404 
      405 
      406 BAD_TIME:	call com_err_ (error_table_$out_of_bounds, arg_struc.program, "^d
      407   A positive grace period must be given.", arg_struc.time);
      408 	return;
      409 
      410 BAD_SEARCH:
      411 	progress = min (progress, 7);
      412 	go to BAD_S (progress);
      413 BAD_S(0): call com_err_ (code, arg_struc.program, "^/  While calling lib_descriptor_$map.");
      414 	go to FINISH;
      415 BAD_S(1): call com_err_ (code, arg_struc.program, "^/  While finding the  '^R^a^B'  library descriptor.",
      416 	     arg_struc.descriptor);
      417 	go to FINISH;
      418 BAD_S(2): call com_err_ (code, arg_struc.program,
      419 	     "^/  Library descriptor  '^R^a^B'  does not implement^/  the ^a command.",
      420 	     arg_struc.descriptor, arg_struc.program);
      421 	go to FINISH;
      422 BAD_S(3): state = "library";
      423 	go to NO_DEFAULT_NAMES;
      424 BAD_S(4): state = "search";
      425 NO_DEFAULT_NAMES:
      426 	call com_err_ (code, arg_struc.program,
      427 	     "^/  No ^a names were specified, and the  '^R^a^B'
      428   library descriptor does not define any default ^a names.", state, arg_struc.descriptor, state);
      429 	go to FINISH;
      430 BAD_S(5): call com_err_ (code, arg_struc.program, "^/  While allocating the root nodes of the library tree.");
      431 	go to FINISH;
      432 BAD_S(6):
      433 NO_MATCH:	call com_err_ (code, arg_struc.program,
      434 	     "^/  While searching for entries eligible for deletion in the library.^/  Descriptor:^-^5x^a",
      435 	     arg_struc.descriptor);
      436 	call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      437 	call lib_error_list_ ("search name", Pstarname, arg_struc.program);
      438 	go to FINISH;
      439 BAD_S(7):	call com_err_ (code, arg_struc.program, "^/  No libraries matching the library name(s) could be found.
      440   Descriptor:^-^5x^a", arg_struc.descriptor);
      441 	call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      442 	go to FINISH;
      443 
      444 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      445 
  1     1 /* START OF	lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* NAME:  lib_arg_struc_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures used by the library maintenance tools	*/
  1     8 	/* to process their input arguments.  These structures are the arguments to the		*/
  1     9 	/* lib_args_ subroutine.							*/
  1    10 	/*									*/
  1    11 	/* STATUS									*/
  1    12 	/*									*/
  1    13 	/* 0) Created on:   May 25, 1976 by   Gary C. Dixon				*/
  1    14 	/* 1) Modified:     October 24, 1983 by Jim Lippard to add page_length		*/
  1    15 	/*									*/
  1    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    17 
  1    18 
  2     1 /* START OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_args_.incl.pl1							*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines structures for the arrays of library names and search*/
  2     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  2     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  2    10 	/* to the lib_descriptor_ subroutine.						*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  2    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  2    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  2    17 	/* 3) Modified on:  January 17, 1984 by Jim Lippard to make structures aligned.		*/
  2    18 	/*									*/
  2    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    20 
  2    21 
  2    22      dcl	1 LIBRARY			aligned,		/* a structure containing names of libraries to	*/
  2    23 						/*   be searched.				*/
  2    24 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  2    25 	  2 group (100),				/*   attribute: array of library names		*/
  2    26 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  2    27 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    28 						/*     this library name.			*/
  2    29 
  2    30      dcl	1 STARNAME		aligned,		/* a structure containing names of library entries*/
  2    31 						/*   being searched for.			*/
  2    32 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  2    33 	  2 group (1000),				/*   attribute: array of starnames		*/
  2    34 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  2    35 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    36 						/*     this starname.			*/
  2    37 
  2    38      dcl 	1 EXCLUDE			aligned like STARNAME;
  2    39 						/* structure containing names of library entries	*/
  2    40 						/*   to be excluded from a search.		*/
  2    41 
  2    42 /* END OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    19 
  1    20 
  1    21      dcl	Parg_struc		ptr;		/* ptr to the structure described below.	*/
  1    22 
  1    23      dcl	1 arg_struc		structure based (Parg_struc),
  1    24 	  2 version		fixed bin,	/* version number (currently 1).		*/
  1    25 	  2 program		char(32) varying,	/* name of calling program. 			*/
  1    26 	  2 Parg_list		ptr,		/* ptr to calling program's argument list. 	*/
  1    27 	  2 Iarg_list		fixed bin,	/* first arg of calling program's argument list	*/
  1    28 						/*   to be processed.			*/
  1    29 	  2 Larg_list		fixed bin,	/* total number of arguments in calling pgm's list*/
  1    30 	  2 put_error		entry options(variable),
  1    31 						/* program to call to output an error.		*/
  1    32 	  2 Srequirements_allowed	bit(72) aligned,	/* bits on if control argument associated with	*/
  1    33 						/*   that bit is acceptable to the program. 	*/
  1    34 	  2 Scontrol_allowed	bit(36) aligned,	/* bits on if control operation associated with	*/
  1    35 						/*   that bit is acceptable to the program. 	*/
  1    36 	  2 Srequirements_initial	bit(72) aligned,	/* bits on indicating initial settings for 	*/
  1    37 						/*   Srequirements. 			*/
  1    38 	  2 Scontrol_initial	bit(36) aligned,	/* bits on indicating initial settings for	*/
  1    39 						/*   Scontrol.  				*/
  1    40 	  2 descriptor		char(168) varying,	/* name of library descriptor to be used. 	*/
  1    41 	  2 footing		char(45) varying,	/* footing to be used on output pages. 		*/
  1    42 	  2 heading		char(120) varying,	/* heading to be used on 1st output page.	*/
  1    43 	  2 into_path		char(168) varying,	/* path into which library entries to be fetched.	*/
  1    44 	  2 output_file		char(168) varying,	/* path of output file to be written.		*/
  1    45 	  2 page_length		fixed bin,	/* length of output page			*/
  1    46 	  2 time			fixed bin;	/* grace period (in days) for library_cleanup.	*/
  1    47      dcl	1 Sreq_allowed		aligned like Svalid_req based (addr(arg_struc.Srequirements_allowed));
  1    48 						/* allowed requirements switches.		*/
  1    49      dcl	1 Sreq_init		aligned like Svalid_req based (addr(arg_struc.Srequirements_initial));
  1    50 						/* initial values for requirements switches.	*/
  1    51      dcl	1 Sc_allowed		aligned like Sc based (addr(arg_struc.Scontrol_allowed));
  1    52 						/* allowed control switches.			*/
  1    53      dcl	1 Sc_init			aligned like Sc based (addr(arg_struc.Scontrol_initial));
  1    54 						/* initial values for control switches.		*/
  1    55      dcl	Varg_struc_1		fixed bin int static init (1);
  1    56 
  1    57 /* END OF		lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      446 
      447 
  3     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines structures for the arrays of library names and search*/
  3     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  3     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  3    10 	/* to the lib_descriptor_ subroutine.						*/
  3    11 	/*									*/
  3    12 	/* S__t_a_t_u_s									*/
  3    13 	/*									*/
  3    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  3    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  3    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  3    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  3    18 	/*									*/
  3    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    20 
  3    21 
  3    22      dcl	1 library			aligned based (Plibrary),
  3    23 						/* a structure containing names of libraries to	*/
  3    24 						/*   be searched.				*/
  3    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  3    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  3    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  3    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  3    30 						/*     this library name.			*/
  3    31 
  3    32      dcl	1 starname		aligned based (Pstarname),
  3    33 						/* a structure containing names of library entries*/
  3    34 						/*   being searched for.			*/
  3    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  3    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  3    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  3    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    39 						/*     this starname.			*/
  3    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  3    41 
  3    42      dcl	1 exclude			aligned based (Pexclude),
  3    43 						/* a structure containing names of library entries*/
  3    44 						/*   being excluded from the search.		*/
  3    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  3    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  3    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  3    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    49 						/*     this exclude.			*/
  3    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  3    51 
  3    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      448 
      449 
  4     1 /* START OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3      dcl	1 fcb			based (Pfcb),	/* file control block for our output file.	*/
  4     4 	  2 version		fixed bin,	/*    version number = 1;			*/
  4     5 	  2 ioname		char(32),		/*    ioname of our I/O control block.		*/
  4     6 	  2 Piocb			ptr,		/*    ptr to our I/O control block.		*/
  4     7 	  2 Eend_page		entry variable,	/*    entry which handles endpage condition.	*/
  4     8 	  2 page_length		fixed bin,	/*    number of lines per page.		*/
  4     9 	  2 page_text_length	fixed bin,	/*    number of usable lines per page, excluding	*/
  4    10 						/*       footer lines generated by end-of-page	*/
  4    11 						/*       handler.				*/
  4    12 	  2 page_no		fixed bin,	/*    current page number.			*/
  4    13 	  2 line_length		fixed bin,	/*    number of characters per line.		*/
  4    14 	  2 line_no		fixed bin;	/*    number of lines on current page.		*/
  4    15      dcl	Pfcb			ptr;		/* ptr to file control block.			*/
  4    16      dcl	Vfcb_1			fixed bin int static options(constant) init (1);
  4    17 
  4    18 /* END OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      450 
      451 
  5     1 /* START OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* Name:  lib_list_.incl.pl1							*/
  5     6 	/*									*/
  5     7 	/*      This segment declares the list structures which are used by the library 	*/
  5     8 	/* maintenance tools.  The structures are filled in by lib_sort_tree_, and referenced by	*/
  5     9 	/* lib_output_node_list_, having been allocated originally by one of the maintenance	*/
  5    10 	/* commands (library_map, library_info, library_print, etc).			*/
  5    11 	/*									*/
  5    12 	/* Status									*/
  5    13 	/*									*/
  5    14 	/* 0) Created on:  May 30, 1976  by  G. C. Dixon					*/
  5    15 	/*									*/
  5    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    17 
  5    18 
  5    19      dcl	1 index_list		aligned based (Pindex_list),
  5    20 						/* an index list.				*/
  5    21 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    22 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    23 	  2 e (max_entries refer (index_list.N))
  5    24 				fixed bin(24),	/* the list.				*/
  5    25 	1 name_list		aligned based (Pname_list),
  5    26 						/* a name list.				*/
  5    27 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    28 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    29 	  2 e (max_entries refer (name_list.N))	ptr unal,	/* list of ptrs to node names.		*/
  5    30 	1 node_list		aligned based (Pnode_list),
  5    31 						/* a list of ptrs to nodes to be output.	*/
  5    32 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    33 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    34 	  2 e (max_entries refer (node_list.N))	ptr unal,	/* list of ptrs to nodes.			*/
  5    35 	1 page_list		aligned based (Ppage_list),
  5    36 						/* list of page numbers on which each node was	*/
  5    37 						/* output.				*/
  5    38 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    39 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    40 	  2 e (max_entries refer (page_list.N))	
  5    41 				fixed bin(24),	/* list of page numbers.			*/
  5    42 	max_entries		fixed bin int static init (32000),
  5    43 	Pindex_list		ptr,		/* ptr to index_list structure.		*/
  5    44 	Pname_list		ptr,		/* ptr to name_list structure.		*/
  5    45 	Pnode_list		ptr,		/* ptr to node_list structure.		*/
  5    46 	Ppage_list		ptr;		/* ptr to page_list structure.		*/
  5    47 
  5    48 /* END OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      452 
      453 
  6     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 	/*									*/
  6     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  6     6 	/*									*/
  6     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  6     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  6     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  6    10 	/* called the node target.							*/
  6    11 	/*									*/
  6    12 	/* S__t_a_t_u_s									*/
  6    13 	/*									*/
  6    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  6    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  6    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  6    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  6    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  6    19 	/*									*/
  6    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    21 
  6    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    23 	/*									*/
  6    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  6    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  6    26 	/* both types of nodes are the same length.					*/
  6    27 	/*									*/
  6    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    29 
  6    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  6    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  6    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  6    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  6    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  6    35 						/*             (= node.Svalid & Srequirements)	*/
  6    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  6    37 	  2 switches		unaligned,
  6    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  6    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  6    40 						/* 	     entry before lib_access_mode_$set.	*/
  6    41 	    3 pad			bit(22),
  6    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  6    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  6    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  6    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  6    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  6    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  6    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  6    49 						/*	     in this directory;  if off, records*/
  6    50 						/*	     charged against 1st superior	*/
  6    51 						/*	     directory with switch on.	*/
  6    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  6    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  6    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  6    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  6    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  6    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  6    58 
  6    59 						/* From here on, link_nodes differ from nodes	*/
  6    60 						/*  for other types of node targets.		*/
  6    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  6    62 
  6    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    64 	/*									*/
  6    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  6    66 	/*									*/
  6    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    68 
  6    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  6    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  6    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  6    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  6    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  6    74 						/*             (= node.Svalid & Srequirements)	*/
  6    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  6    76 	  2 switches		unaligned,
  6    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  6    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  6    79 						/* 	     entry before lib_access_mode_$set.	*/
  6    80 	    3 pad			bit(22),
  6    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  6    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  6    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  6    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  6    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  6    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  6    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  6    88 						/*	     in this directory;  if off, records*/
  6    89 						/*	     charged against 1st superior	*/
  6    90 						/*	     directory with switch on.	*/
  6    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  6    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  6    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  6    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  6    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  6    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  6    97 
  6    98 						/* From here on, other nodes differ from	*/
  6    99 						/*  link_nodes.				*/
  6   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  6   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  6   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  6   103 	  2 pad1 (1)		fixed bin,
  6   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  6   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  6   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  6   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  6   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  6   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  6   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  6   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  6   112 						/*             component from the base of archive.*/
  6   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  6   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  6   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  6   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  6   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  6   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  6   119 						/*	     updated.			*/
  6   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  6   121 						/*	     directories with Sterminal_account	*/
  6   122 						/*	     on.				*/
  6   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  6   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  6   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  6   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  6   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  6   128 						/*	     updated.			*/
  6   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  6   130 						/*	     directories with Sterminal_account	*/
  6   131 						/*	     on.				*/
  6   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  6   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  6   134 	  2 pad2 (5)		fixed bin,
  6   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  6   136 
  6   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   138 	/*									*/
  6   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  6   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  6   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  6   142 	/* descriptors are the only ones that have been defined.				*/
  6   143 	/*									*/
  6   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   145 
  6   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  6   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  6   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  6   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  6   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  6   152 
  6   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  6   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  6   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  6   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   163 	    3 zero_pad		bit(36),
  6   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  6   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  6   167 	Vacl_1			fixed bin int static options(constant) init (1),
  6   168 						/* version:   version of ACL descriptor.	*/
  6   169 	Tacl			fixed bin int static options(constant) init (7);
  6   170 						/* attribute: type of a segment ACL descriptor.	*/
  6   171 
  6   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  6   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  6   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  6   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  6   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  6   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  6   186 						/* version:   version of directory ACL descriptor.*/
  6   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  6   188 						/* attribute: type of a directory ACL descriptor.	*/
  6   189 
  6   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  6   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  6   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  6   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  6   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  6   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  6   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  6   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  6   206 						/* version:   version of dir IACL descriptor.	*/
  6   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  6   208 
  6   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  6   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  6   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  6   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  6   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  6   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   221 	    3 zero_pad		bit(36),
  6   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  6   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  6   225 	Viacl_1			fixed bin int static options(constant) init (1),
  6   226 						/* version:   version of segment IACL descriptor.	*/
  6   227 	Tiacl			fixed bin int static options(constant) init (10);
  6   228 						/* attribute: type of a segment IACL descriptor.	*/
  6   229 
  6   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  6   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  6   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  6   236 	  2 names (Nnames refer (Dnames.N))
  6   237 				char(32),		/* attribute: names.			*/
  6   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  6   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  6   240 	Vnames_1			fixed bin int static options(constant) init (1),
  6   241 						/* version:   version of names descriptor.	*/
  6   242 	Tnames			fixed bin int static options(constant) init (1);
  6   243 						/* attribute: type of a name descriptor.	*/
  6   244 
  6   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  6   246 						/* nodes.					*/
  6   247 	  2 header,
  6   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  6   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  6   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  6   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  6   255 				like node,
  6   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  6   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  6   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  6   259 						/* version:   version of nodes descriptor.	*/
  6   260 	Tnodes			fixed bin int static options(constant) init (2);
  6   261 						/* attribute: type of a node descriptor.	*/
  6   262 
  6   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  6   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  6   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   268 	  2 info,
  6   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  6   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  6   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  6   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  6   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  6   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  6   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  6   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  6   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  6   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  6   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  6   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  6   281 	    3 format		aligned,
  6   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  6   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  6   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  6   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  6   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  6   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  6   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  6   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  6   290 	      4 pad		bit(28) unal,
  6   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  6   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  6   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  6   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  6   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  6   296 	    3 cversion,				/* attribite: compiler version string.		*/
  6   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  6   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  6   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  6   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  6   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  6   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  6   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  6   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  6   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  6   306 	Vobj_1			fixed bin int static options(constant) init (1),
  6   307 						/* version:   version of object_info_ descriptor.	*/
  6   308 	Tobj			fixed bin int static options(constant) init (3);
  6   309 						/* attribute: type of a node descriptor.	*/
  6   310 
  6   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  6   312 						/* library root search_proc attribute descriptor.	*/
  6   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  6   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  6   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  6   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  6   320 						/* version:   version of search_proc info descrip.*/
  6   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  6   322 						/* attribute: type of a search_proc descriptor.	*/
  6   323 
  6   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  6   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  6   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  6   330 						/*            output.			*/
  6   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  6   332 	  2 info			char(Luser refer (Duser.L)),
  6   333 						/* attribute: user info string.		*/
  6   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  6   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  6   336 	Vuser_1			fixed bin int static options(constant) init (1),
  6   337 						/* version:   version of user info descriptor.	*/
  6   338 	Tuser			fixed bin int static options(constant) init (6);
  6   339 						/* attribute: type of a user descriptor.	*/
  6   340 
  7     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7     4 	/*									*/
  7     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  7     6 	/*									*/
  7     7 	/*      This include segment defines the switches which request/validate the fields	*/
  7     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  7     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  7    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  7    11 	/* descriptor commands to obtain information about entries in a library.		*/
  7    12 	/*									*/
  7    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  7    14 	/* is requested for output.							*/
  7    15 	/*									*/
  7    16 	/* S__t_a_t_u_s									*/
  7    17 	/*									*/
  7    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  7    19 	/*									*/
  7    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    21 
  7    22 
  7    23      dcl	1 Svalid_req		aligned based,
  7    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  7    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  7    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  7    27 
  7    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  7    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  7    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  7    31 
  7    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  7    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  7    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  7    35 
  7    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  7    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  7    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  7    39 
  7    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  7    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  7    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  7    43 
  7    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  7    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  7    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  7    47 
  7    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  7    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  7    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  7    51 
  7    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  7    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  7    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  7    55 
  7    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  7    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  7    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  7    59 
  7    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  7    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  7    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  7    63 
  7    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  7    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  7    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  7    67 
  7    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  7    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  7    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  7    71 
  7    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  7    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  7    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  7    75 
  7    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  7    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  7    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  7    79 	  2 pad			bit(26) unal,
  7    80 
  7    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  7    82 
  7    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  7    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  7    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  7    86 
  7    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    88 	/*									*/
  7    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  7    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  7    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  7    92 	/*									*/
  7    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    94 
  7    95 
  7    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  7    97 	Srequirements		bit(72) aligned;
  7    98 
  7    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6   341 
  6   342 
  6   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  6   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  6   345 
  8     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8     4 	/*									*/
  8     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  8     6 	/*									*/
  8     7 	/*      This include segment defines the control switches used by library descriptor	*/
  8     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  8     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  8    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  8    11 	/* to the lib_descriptor_ subroutine.						*/
  8    12 	/*									*/
  8    13 	/* S__t_a_t_u_s									*/
  8    14 	/*									*/
  8    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  8    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  8    17 	/*									*/
  8    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    19 
  8    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  8    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  8    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  8    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  8    24 
  8    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  8    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  8    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  8    28 						/*         nodes of the tree, and about all the	*/
  8    29 						/*	 nodes below the parent.		*/
  8    30 
  8    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  8    32 						/*         nodes of the tree.			*/
  8    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  8    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  8    35 
  8    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  8    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  8    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  8    39 						/*         deletion.			*/
  8    40 
  8    41 	  2 pad			bit(10) unal,
  8    42 
  8    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  8    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  8    45 
  8    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  8    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  8    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  8    49 
  8    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  8    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  8    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  8    53 
  8    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  8    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  8    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  8    57 
  8    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  8    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  8    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  8    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  8    62 
  8    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6   346 
  6   347 
  6   348 
  6   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   350 	/*									*/
  6   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  6   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  6   353 	/* that:		mod (type, 2) = 1;						*/
  6   354 	/*									*/
  6   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   356 
  6   357 
  6   358      dcl (Tlink			init (0),
  6   359 	Tsegment			init (1),
  6   360 	Tdirectory		init (2),
  6   361 	Tmsf			init (3),
  6   362 	Tmsf_comp			init (4),
  6   363 	Tarchive			init (5),
  6   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  6   365 
  6   366 
  6   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   368 	/*									*/
  6   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  6   370 	/* Both brief and long string arrays are provided.				*/
  6   371 	/*									*/
  6   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   373 
  6   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  6   375 				"link",
  6   376 				"segment",
  6   377 				"directory",
  6   378 				"multisegment file",
  6   379 				"multi-segment file component",
  6   380 				"archive",
  6   381 				"archive component"),
  6   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  6   383 				"link",
  6   384 				"segment",
  6   385 				"directory",
  6   386 				"msf",
  6   387 				"msf comp",
  6   388 				"archive",
  6   389 				"arch comp");
  6   390 
  6   391 
  6   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      454 
      455 
  9     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  9     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  9     3 /*	version number changed to 4, 08/10/78 WOS */
  9     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  9     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  9     6 
  9     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  9     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  9     9     2 switches aligned,                                     /* various bit switch values */
  9    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  9    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  9    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  9    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  9    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  9    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  9    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  9    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  9    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  9    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  9    20 
  9    21 /*  Limit of data defined for version 2 */
  9    22 
  9    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  9    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  9    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  9    26 						/* minimum of 30 seconds required for repeat */
  9    27 						/* otherwise, no repeat will occur */
  9    28 /* Limit of data defined for version 4 */
  9    29 
  9    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  9    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  9    32 
  9    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  9    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  9    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  9    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  9    37 
  9    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      456 
      457 
      458 
      459 	end library_cleanup;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0749.4  library_cleanup.pl1               >special_ldd>on>6588>library_cleanup.pl1
446          1    02/15/84  0754.7  lib_arg_struc_.incl.pl1           >special_ldd>on>6588>lib_arg_struc_.incl.pl1
1-19         2    02/15/84  0754.6  lib_args_.incl.pl1                >special_ldd>on>6588>lib_args_.incl.pl1
448          3    02/15/84  0754.6  lib_based_args_.incl.pl1          >special_ldd>on>6588>lib_based_args_.incl.pl1
450          4    01/05/79  1321.1  lib_fcb_.incl.pl1                 >ldd>include>lib_fcb_.incl.pl1
452          5    02/28/77  1409.2  lib_list_.incl.pl1                >ldd>include>lib_list_.incl.pl1
454          6    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
6-341        7    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
6-346        8    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
456          9    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Bgrace_begins                   000100 automatic       bit(36)                  dcl 18 set ref 218* 225
EXCLUDE                         024120 automatic       structure                level 1 dcl 2-38 set ref 138* 171
Eend_page                14            based           entry variable           level 2 dcl 4-3 set ref 185*
False                                  constant        bit(1)                   initial dcl 96 ref 229 247
I                         1            based           fixed bin(24,0)          level 2 dcl 5-19 set ref 177* 223 267
Iarg_list                14            based           fixed bin(17,0)          level 2 dcl 1-23 set ref 118*
Idelete                         000101 automatic       fixed bin(17,0)          dcl 18 set ref 221* 227* 227 238 256* 262*
Inode                           000102 automatic       fixed bin(17,0)          dcl 18 set ref 220* 231* 231 232* 236
LIBRARY                         000642 automatic       structure                level 1 dcl 2-22 set ref 138* 169
Larg_list                15            based           fixed bin(17,0)          level 2 dcl 1-23 set ref 119*
N                                      based           fixed bin(24,0)          level 2 dcl 5-19 set ref 176*
Ngrace_begins                   000104 automatic       fixed bin(71,0)          dcl 18 set ref 212* 214* 214 218
Ngrace_begins_bits                     based           bit(72)                  unaligned dcl 53 ref 218
Parea                           000106 automatic       pointer                  dcl 18 set ref 160* 166 166 172* 176 386 386 386
Parg_list                12            based           pointer                  level 2 dcl 1-23 set ref 117*
Parg_struc                      045572 automatic       pointer                  dcl 1-21 set ref 114* 115 116 117 118 119 120 121
                                                                                  122 123 124 127 128 129 130 131 132 133 135 136
                                                                                  138 138 141 172 212 251 251 251 254 255 256 262
                                                                                  295 300 310 318 329 336 343 350 352 380 406 406
                                                                                  413 415 415 418 418 418 425 425 430 432 432 436
                                                                                  437 439 439 441
Pdelete                         000110 automatic       pointer                  dcl 18 set ref 163* 270* 272* 378 379* 380
Pexclude                        045600 automatic       pointer                  dcl 3-50 set ref 171* 172*
Pfcb                            045602 automatic       pointer                  dcl 4-15 set ref 181* 182 183 184 185 186 187 188
                                                                                  189 189 190 191 232* 396 396 397
Piocb                    12            based           pointer                  level 2 dcl 4-3 set ref 184* 189*
Plibrary                        045574 automatic       pointer                  dcl 3-29 set ref 169* 172* 254* 436* 441*
Pnode                           045606 automatic       pointer                  dcl 6-69 set ref 224* 225 226 229 230 232* 233 268*
                                                                                  269 270 271* 273
Pnode_                                 parameter       pointer                  dcl 286 set ref 284 292* 294 299 299 305 316 318 325
                                                                                  327 329 334 336 341 343 352 355 357 359 359
Pnode_list                      045604 automatic       pointer                  dcl 5-19 set ref 176* 177 178* 223 224 267 268
Pparent                                based           pointer                  level 2 in structure "node_" dcl 289 in procedure
                                                                                  "delete_entry" ref 299 305 316 318
Pparent                                based           pointer                  level 2 in structure "node" dcl 6-69 in procedure
                                                                                  "lcln" ref 233 273
Pprev_parent                    000112 automatic       pointer                  dcl 18 in procedure "lcln" set ref 161* 222* 232*
                                                                                  233* 266* 271* 273* 374 375* 376*
Pprev_parent                           parameter       pointer                  dcl 286 in procedure "delete_entry" set ref 284 305
                                                                                  306 307* 309* 310 314*
Pstarname                       045576 automatic       pointer                  dcl 3-40 set ref 170* 172* 232* 255* 437*
Ptree                           000114 automatic       pointer                  dcl 18 set ref 172* 178*
STARNAME                        002447 automatic       structure                level 1 dcl 2-30 set ref 138* 170
Sc                                     based           structure                level 1 dcl 8-20
Sc_allowed                             based           structure                level 1 dcl 1-51
Sc_init                                based           structure                level 1 dcl 1-53
Scontrol                        045612 automatic       bit(36)                  dcl 8-20 set ref 138* 143 145 145 147 147 147 172*
                                                                                  230 230 244 250 262
Scontrol_allowed         24            based           bit(36)                  level 2 dcl 1-23 set ref 123* 127 128 129 130 131
                                                                                  132 133
Scontrol_initial         27            based           bit(36)                  level 2 dcl 1-23 set ref 124* 135
Scopy                    12            based           bit(1)                   level 3 packed unaligned dcl 289 ref 341 355
Srequirements                   045610 automatic       bit(72)                  dcl 7-96 set ref 138* 172*
Srequirements_allowed
                         22            based           bit(72)                  level 2 dcl 1-23 set ref 121*
Srequirements_initial
                         25            based           bit(72)                  level 2 dcl 1-23 set ref 122*
Ssafety                  11(30)        based           bit(1)                   level 3 packed unaligned dcl 289 ref 334 357
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 6-69 in procedure
                                                                                  "lcln" set ref 226 229 230 269
Svalid                                 based           structure                level 1 dcl 6-343 in procedure "lcln"
Svalid_req                             based           structure                level 1 dcl 7-23
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 6-69 in procedure
                                                                                  "lcln" ref 380
T                        10            based           fixed bin(35,0)          level 2 in structure "node_" dcl 289 in procedure
                                                                                  "delete_entry" ref 294 299 299 310 318 325 329 336
                                                                                  343 352
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 6-358 ref 294
Tdirectory                             constant        fixed bin(17,0)          initial dcl 6-358 ref 299
Tlink                                  constant        fixed bin(17,0)          initial dcl 6-358 ref 299 325
True                                   constant        bit(1)                   initial dcl 96 ref 127 128 129 130 131 132 133 135
                                                                                  143 145 147 226 246
Varg_struc_1                           constant        fixed bin(17,0)          initial dcl 1-55 ref 115
Vfcb_1                                 constant        fixed bin(17,0)          initial dcl 4-16 ref 182
addr                                                   builtin function         dcl 58 ref 114 127 128 129 130 131 132 133 135 138
                                                                                  138 143 145 145 147 147 147 166 166 169 170 171
                                                                                  181 218 226 229 230 230 230 244 250 256 256 262
                                                                                  262 262 269 386 386
answer_iocbp              6     045614 automatic       pointer                  initial level 2 dcl 9-7 set ref 9-7*
area                                   based           area(1024)               dcl 53 ref 176
arg_struc                              based           structure                level 1 unaligned dcl 1-23 set ref 138 138
arg_struc_temp                  000116 automatic       structure                level 1 unaligned dcl 18 set ref 114
cleanup                         000634 stack reference condition                dcl 60 ref 164
clock_                          000016 constant        entry                    external dcl 62 ref 212
code                            000425 automatic       fixed bin(35,0)          dcl 18 set ref 138* 139 172* 174 178* 179 189* 190
                                                                                  239* 307* 308 310* 316* 317 318* 328* 329 329*
                                                                                  335* 336 336* 342* 343 343* 350* 351 352* 355*
                                                                                  357* 359* 375* 386* 413* 415* 418* 425* 430* 432*
                                                                                  439*
com_err_                        000020 constant        entry                    external dcl 62 ref 120 295 300 310 318 329 336 343
                                                                                  352 380 406 413 415 418 425 430 432 439
com_err_$suppress_name          000022 constant        entry                    external dcl 62 ref 251
command_query_                  000024 constant        entry                    external dcl 62 ref 256 262
comment                         000107 constant        varying char(28)         initial array dcl 96 set ref 262*
condition_                      000026 constant        entry                    external dcl 62 ref 167
cp_escape_control         1(02) 045614 automatic       bit(2)                   initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  9-7*
cu_$arg_count                   000030 constant        entry                    external dcl 62 ref 119
cu_$arg_list_ptr                000032 constant        entry                    external dcl 62 ref 117
default                   0(07)        based           bit(1)                   level 2 packed unaligned dcl 8-20 set ref 143*
delete                    0(24)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lcln" ref 147 244
delete                    0(24)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lcln" set ref 130*
delete                    1(32)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 6-343 in procedure "lcln" set ref 226* 229*
                                                                                  230 269
delete_$path                    000034 constant        entry                    external dcl 62 ref 350
descriptor               30            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lcln" set ref 172* 251* 415* 418*
                                                                                  425* 432* 439*
descriptor                0(25)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lcln" set ref 127*
dir                             000426 automatic       varying char(168)        dcl 18 set ref 292* 295* 300* 318* 328 329* 335 336*
                                                                                  342 343* 350 352* 355 357 359
dtem                     25            based           bit(36)                  level 2 packed unaligned dcl 6-69 ref 225
e                         2            based           pointer                  array level 2 packed unaligned dcl 5-19 ref 224 268
ent                             000501 automatic       varying char(32)         dcl 18 set ref 292* 295* 300* 328 329* 335 336* 342
                                                                                  343* 350 352* 355 357 359
error_table_$nomatch            000100 external static fixed bin(35,0)          dcl 96 ref 239
error_table_$not_done           000102 external static fixed bin(35,0)          dcl 96 set ref 295* 300* 380*
error_table_$out_of_bounds      000104 external static fixed bin(35,0)          dcl 96 set ref 406*
explanation_len          14     045614 automatic       fixed bin(21,0)          initial level 2 dcl 9-7 set ref 9-7*
explanation_ptr          12     045614 automatic       pointer                  initial level 2 dcl 9-7 set ref 9-7*
fcb                                    based           structure                level 1 unaligned dcl 4-3
fcb_temp                        000512 automatic       structure                level 1 unaligned dcl 18 set ref 181
get_line_length_$switch         000036 constant        entry                    external dcl 62 ref 189
get_ring_                       000040 constant        entry                    external dcl 62 ref 326
get_system_msa_                 000042 constant        entry                    external dcl 62 ref 166
hcs_$set_copysw                 000044 constant        entry                    external dcl 62 ref 342 355
hcs_$set_safety_sw              000046 constant        entry                    external dcl 62 ref 335 357
i                               000537 automatic       fixed bin(17,0)          dcl 18 set ref 223* 224* 267* 268*
installation_tools_$set_ring_brackets
                                000052 constant        entry                    external dcl 62 ref 328 359
ioa_                            000050 constant        entry                    external dcl 62 ref 236
ioname                    1            based           char(32)                 level 2 packed unaligned dcl 4-3 set ref 183*
iox_$user_output                000106 external static pointer                  dcl 96 ref 184
lib_access_mode_$set            000054 constant        entry                    external dcl 62 ref 316
lib_access_mode_$unset          000056 constant        entry                    external dcl 62 ref 307 375
lib_args_                       000060 constant        entry                    external dcl 62 ref 138
lib_descriptor_$cleanup         000062 constant        entry                    external dcl 62 ref 172
lib_error_list_                 000064 constant        entry                    external dcl 62 ref 254 255 436 437 441
lib_node_path_                  000066 constant        entry                    external dcl 62 ref 292 309 379
lib_output_node_$cleanup        000070 constant        entry                    external dcl 62 ref 232
lib_sort_tree_$make_node_list   000072 constant        entry                    external dcl 62 ref 178
library                   0(30)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 128*
line_length              23            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 189* 190*
line_no                  24            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 191* 397*
list                      0(31)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lcln" set ref 131*
list                      0(31)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lcln" set ref 145* 147 147* 230 250
literal_sw                1(05) 045614 automatic       bit(1)                   initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  9-7*
long                      0(32)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lcln" set ref 132*
long                      0(32)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lcln" ref 145 230 262
max_entries                            constant        fixed bin(17,0)          initial dcl 5-19 ref 176 176
min                                                    builtin function         dcl 58 ref 214 410
msa_manager_$area_handler       000074 constant        entry                    external dcl 62 ref 167 167
node                                   based           structure                level 1 unaligned dcl 6-69
node_                                  based           structure                level 1 unaligned dcl 289
node_list                              based           structure                level 1 dcl 5-19 set ref 176
node_type                       000010 constant        varying char(32)         initial array dcl 6-374 set ref 310* 318* 329* 336*
                                                                                  343* 352* 380*
null                                                   builtin function         dcl 58 ref 160 161 163 166 166 222 266 272 9-7 9-7
                                                                                  9-7 306 314 374 376 378 386
padding                   1(07) 045614 automatic       bit(29)                  initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  9-7*
page_length              20            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 186*
page_no                  22            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 188* 396* 396
page_text_length         21            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 187*
prev_dir                        000540 automatic       varying char(168)        dcl 18 set ref 309* 310* 379* 380*
prev_ent                        000613 automatic       varying char(32)         dcl 18 set ref 309* 310* 379* 380*
program                   1            based           varying char(32)         level 2 dcl 1-23 set ref 116* 251* 254* 255* 256*
                                                                                  262* 295* 300* 310* 318* 329* 336* 343* 350 352*
                                                                                  380* 406* 413* 415* 418* 418* 425* 430* 432* 436*
                                                                                  437* 439* 441*
progress                        000624 automatic       fixed bin(17,0)          initial dcl 18 set ref 18* 172* 410* 410 412
prompt_after_explanation
                          1(06) 045614 automatic       bit(1)                   initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  9-7*
put_error                16            based           entry variable           level 2 dcl 1-23 set ref 120*
query_code                3     045614 automatic       fixed bin(35,0)          initial level 2 dcl 9-7 set ref 249* 9-7*
query_info                      045614 automatic       structure                level 1 dcl 9-7 set ref 256 256 262 262
question_iocbp            4     045614 automatic       pointer                  initial level 2 dcl 9-7 set ref 9-7*
rb                       31            based           fixed bin(3,0)           array level 2 dcl 289 set ref 327 359 359*
release_system_msa_             000076 constant        entry                    external dcl 62 ref 386
repeat_time              10     045614 automatic       fixed bin(71,0)          initial level 2 dcl 9-7 set ref 9-7*
ring                            000010 internal static fixed bin(3,0)           initial array dcl 96 set ref 326 326* 327 328* 359
search_names              0(34)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 129*
state                           000625 automatic       char(16)                 unaligned dcl 18 set ref 422* 424* 425* 425*
status_code               2     045614 automatic       fixed bin(35,0)          initial level 2 dcl 9-7 set ref 248* 9-7*
substr                                                 builtin function         dcl 58 ref 218
suppress_name_sw          1(01) 045614 automatic       bit(1)                   initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  247* 9-7*
suppress_spacing          1(04) 045614 automatic       bit(1)                   initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  9-7*
switches                 11            based           structure                level 2 in structure "node_" packed unaligned
                                                                                  dcl 289 in procedure "delete_entry"
switches                  1     045614 automatic       structure                level 2 in structure "query_info" dcl 9-7
                                                                                  in procedure "lcln"
sys_info$time_of_bootload       000110 external static fixed bin(71,0)          dcl 96 ref 214
time                      0(35)        based           bit(1)                   level 2 in structure "Sc_init" packed unaligned
                                                                                  dcl 1-53 in procedure "lcln" set ref 135*
time                    306            based           fixed bin(17,0)          level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lcln" set ref 136* 141 212 251* 406*
time                      0(35)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lcln" set ref 133*
unset_depth                     000631 automatic       fixed bin(17,0)          dcl 18 set ref 162* 307* 316* 375*
version                                based           fixed bin(17,0)          level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lcln" set ref 115*
version                         045614 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 9-7
                                                                                  in procedure "lcln" set ref 245*
version                                based           fixed bin(17,0)          level 2 in structure "fcb" dcl 4-3 in procedure
                                                                                  "lcln" set ref 182*
yes_no                          000632 automatic       varying char(3)          dcl 18 set ref 256* 259 262* 264
yes_or_no_sw              1     045614 automatic       bit(1)                   initial level 3 packed unaligned dcl 9-7 set ref
                                                                                  246* 9-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 6-146
Dacl                                   based           structure                level 1 unaligned dcl 6-153
Ddir_acl                               based           structure                level 1 unaligned dcl 6-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 6-190
Diacl                                  based           structure                level 1 unaligned dcl 6-209
Dnames                                 based           structure                level 1 unaligned dcl 6-230
Dnodes                                 based           structure                level 1 unaligned dcl 6-245
Dobj                                   based           structure                level 1 unaligned dcl 6-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 6-311
Duser                                  based           structure                level 1 unaligned dcl 6-324
Luser                                  automatic       fixed bin(17,0)          dcl 6-324
Nacls                                  automatic       fixed bin(17,0)          dcl 6-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 6-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 6-190
Niacls                                 automatic       fixed bin(17,0)          dcl 6-209
Nnames                                 automatic       fixed bin(17,0)          dcl 6-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 6-245
PD                                     automatic       pointer                  dcl 6-146
PDacl                                  automatic       pointer                  dcl 6-153
PDdir_acl                              automatic       pointer                  dcl 6-172
PDdir_iacl                             automatic       pointer                  dcl 6-190
PDiacl                                 automatic       pointer                  dcl 6-209
PDnames                                automatic       pointer                  dcl 6-230
PDnodes                                automatic       pointer                  dcl 6-245
PDobj                                  automatic       pointer                  dcl 6-263
PDsearch_proc                          automatic       pointer                  dcl 6-311
PDuser                                 automatic       pointer                  dcl 6-324
Pindex_list                            automatic       pointer                  dcl 5-19
Pname_list                             automatic       pointer                  dcl 5-19
Ppage_list                             automatic       pointer                  dcl 5-19
S                                      based           structure                level 1 dcl 7-96
Sreq                                   based           structure                level 1 dcl 6-343
Sreq_allowed                           based           structure                level 1 dcl 1-47
Sreq_init                              based           structure                level 1 dcl 1-49
Tacl                                   internal static fixed bin(17,0)          initial dcl 6-153
Tarchive                               internal static fixed bin(17,0)          initial dcl 6-358
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 6-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 6-190
Tiacl                                  internal static fixed bin(17,0)          initial dcl 6-209
Tmsf                                   internal static fixed bin(17,0)          initial dcl 6-358
Tmsf_comp                              internal static fixed bin(17,0)          initial dcl 6-358
Tnames                                 internal static fixed bin(17,0)          initial dcl 6-230
Tnodes                                 internal static fixed bin(17,0)          initial dcl 6-245
Tobj                                   internal static fixed bin(17,0)          initial dcl 6-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 6-311
Tsegment                               internal static fixed bin(17,0)          initial dcl 6-358
Tuser                                  internal static fixed bin(17,0)          initial dcl 6-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 6-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 6-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 6-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 6-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 6-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 6-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 6-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 6-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 6-324
brief_node_type                        internal static varying char(12)         initial array dcl 6-374
error_table_$noarg                     external static fixed bin(35,0)          dcl 96
exclude                                based           structure                level 1 dcl 3-42
index_list                             based           structure                level 1 dcl 5-19
library                                based           structure                level 1 dcl 3-22
link_node                              based           structure                level 1 unaligned dcl 6-30
name_list                              based           structure                level 1 dcl 5-19
page_list                              based           structure                level 1 dcl 5-19
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 9-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 9-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 9-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 9-36
starname                               based           structure                level 1 dcl 3-32
system_info_$titles             000000 constant        entry                    external dcl 62

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_S                           000000 constant        label                    array(0:7) dcl 413 ref 412
BAD_SEARCH                      002241 constant        label                    dcl 410 set ref 174
BAD_TIME                        002207 constant        label                    dcl 406 ref 141
FINISH                          002202 constant        label                    dcl 278 ref 259 264 414 417 421 429 431 438 442
NO_DEFAULT_NAMES                002401 constant        label                    dcl 425 set ref 423
NO_MATCH                        002474 constant        label                    dcl 432 set ref 179 240
delete_entry                    002655 constant        entry                    internal dcl 284 ref 271
janitor                         004301 constant        entry                    internal dcl 372 ref 164 278
lcln                            001037 constant        entry                    external dcl 15
library_cleanup                 001047 constant        entry                    external dcl 15
no_end_page                     004436 constant        entry                    internal dcl 394 ref 185

NAME DECLARED BY CONTEXT OR IMPLICATION.
binary                                                 builtin function         ref 262

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5116        5230    4465        5126
Length      5704    4465       112         437     430           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lcln                              19554 external procedure  is an external procedure.  
on unit on line 164                  64 on unit               
delete_entry                            internal procedure  shares stack frame of external procedure lcln.  
janitor                             138 internal procedure  is called by several nonquick procedures.  
no_end_page                          64 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ring                        lcln

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lcln                     000100 Bgrace_begins               lcln
                         000101 Idelete                     lcln
                         000102 Inode                       lcln
                         000104 Ngrace_begins               lcln
                         000106 Parea                       lcln
                         000110 Pdelete                     lcln
                         000112 Pprev_parent                lcln
                         000114 Ptree                       lcln
                         000116 arg_struc_temp              lcln
                         000425 code                        lcln
                         000426 dir                         lcln
                         000501 ent                         lcln
                         000512 fcb_temp                    lcln
                         000537 i                           lcln
                         000540 prev_dir                    lcln
                         000613 prev_ent                    lcln
                         000624 progress                    lcln
                         000625 state                       lcln
                         000631 unset_depth                 lcln
                         000632 yes_no                      lcln
                         000642 LIBRARY                     lcln
                         002447 STARNAME                    lcln
                         024120 EXCLUDE                     lcln
                         045572 Parg_struc                  lcln
                         045574 Plibrary                    lcln
                         045576 Pstarname                   lcln
                         045600 Pexclude                    lcln
                         045602 Pfcb                        lcln
                         045604 Pnode_list                  lcln
                         045606 Pnode                       lcln
                         045610 Srequirements               lcln
                         045612 Scontrol                    lcln
                         045614 query_info                  lcln

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
mpfx2               enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      com_err_$suppress_name        command_query_
condition_                    cu_$arg_count                 cu_$arg_list_ptr              delete_$path
get_line_length_$switch       get_ring_                     get_system_msa_               hcs_$set_copysw
hcs_$set_safety_sw            installation_tools_$set_ring_brackets                       ioa_
lib_access_mode_$set          lib_access_mode_$unset        lib_args_                     lib_descriptor_$cleanup
lib_error_list_               lib_node_path_                lib_output_node_$cleanup      lib_sort_tree_$make_node_list
msa_manager_$area_handler     release_system_msa_           smart_alloc_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$nomatch          error_table_$not_done         error_table_$out_of_bounds    iox_$user_output
sys_info$time_of_bootload




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 001003    9    7 001004        15 001036       114 001055       115 001060       116 001062       117 001067
    118 001077       119 001103       120 001113       121 001122       122 001125       123 001127       124 001130
    127 001131       128 001133       129 001135       130 001137       131 001141       132 001143       133 001145
    135 001147       136 001151       138 001153       139 001200       141 001202       143 001206       145 001210
    147 001217       160 001227       161 001231       162 001232       163 001233       164 001234       166 001256
    167 001300       169 001325       170 001330       171 001332       172 001334       174 001367       176 001371
    177 001415       178 001417       179 001433       181 001435       182 001440       183 001442       184 001445
    185 001451       186 001454       187 001456       188 001457       189 001461       190 001474       191 001502
    212 001506       214 001526       218 001533       220 001536       221 001537       222 001540       223 001542
    224 001554       225 001557       226 001562       227 001564       228 001565       229 001566       230 001570
    231 001603       232 001604       233 001634       235 001640       236 001642       238 001656       239 001660
    240 001663       244 001664       245 001670       246 001672       247 001674       248 001676       249 001677
    250 001700       251 001705       254 001744       255 001767       256 002012       259 002053       260 002060
    262 002061       264 002131       266 002136       267 002140       268 002152       269 002155       270 002160
    271 002161       272 002172       273 002174       275 002200       278 002202       279 002206       406 002207
    408 002240       410 002241       412 002246       413 002247       414 002276       415 002277       417 002332
    418 002333       421 002371       422 002372       423 002375       424 002376       425 002401       429 002443
    430 002444       431 002473       432 002474       436 002527       437 002552       438 002575       439 002576
    441 002631       442 002654       284 002655       292 002660       294 002674       295 002703       298 002740
    299 002741       300 002747       303 003004       305 003005       306 003011       307 003015       308 003031
    309 003033       310 003051       314 003117       316 003123       317 003147       318 003151       325 003216
    326 003224       327 003253       328 003261       329 003332       334 003404       335 003413       336 003467
    341 003541       342 003550       343 003624       350 003676       351 003772       352 003775       355 004044
    357 004127       359 004213       361 004275       363 004276       372 004300       374 004306       375 004313
    376 004325       378 004330       379 004334       380 004347       386 004414       389 004434       394 004435
    396 004443       397 004447       399 004451


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
