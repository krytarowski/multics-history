	COMPILATION LISTING OF SEGMENT sweep
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 04/26/88  1214.5 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-10-06,Parisek), approve(88-02-03,MCR7845),
       17*     audit(88-04-12,Lippard), install(88-04-26,MR12.2-1043):
       18*     Implement multi-segment file application for possible >256K disk_stat
       19*     segment.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 /* format: style4 */
       24 sweep:
       25      procedure options (variable);
       26 
       27 /* This procedure does a "getquota" on all directories and puts the returned values in a file.
       28*   The quota, used, and time-page product figures for both segments and directories are recorded.
       29*   Output segment is "disk_stat" unless "-of PATH" is specified.
       30*   Root node is ">" unless a non-control arg is encountered.
       31*   If a directory has no quota, the subtree under it is not scanned, since quota must be in an
       32*   unbroken chain (so we need not look at all directories).
       33*   The program attempts to give itself access as needed and clean up later.
       34*   THVV
       35**/
       36 
       37 /* Modified June 1975 by J. C. Whitmore for setting directory privilege. */
       38 /* Modified April 1976 by THVV and TAC to implement recording of directory pages used under NSS */
       39 /* Modified December 1980 by C. Hornig for connection failures */
       40 /* Modified 83-09-25 by E. N. Kittlitz, per SGH (UNCA) to clean up AST if privileged */
       41 
       42 dcl  path char (168) init (">");
       43 dcl  dn char (168) init (get_wdir_ ());
       44 dcl  pdir char (168) init (get_pdir_ ());
       45 dcl  en char (32) init ("disk_stat");
       46 dcl  areap ptr;
       47 dcl  fcbp ptr;
       48 dcl  (quota, tot_dquota, tot_squota) fixed bin (35) init (0); /* GLOBAL variables, total quota */
       49 dcl  (used, tot_dused, tot_sused) fixed bin (35) init (0);	/* GLOBAL variables, total use */
       50 dcl  hpriv bit (1) aligned;
       51 dcl  ppriv bit (1) aligned;
       52 dcl  seg_ptr ptr;
       53 dcl  uid bit (36) aligned;
       54 dcl  (n, tn) fixed bin;				/* GLOBAL variable, number of dirs */
       55 dcl  bitc fixed bin (24);
       56 dcl  an fixed bin;
       57 dcl  ap ptr;					/* ptr to arg */
       58 dcl  al fixed bin;					/* lth of arg */
       59 dcl  bchr char (al) based (ap) unaligned;
       60 dcl  ec fixed bin (35);				/* err code */
       61 dcl  starting_level fixed bin;			/* level in hierarchy where the sweep starts (root = 0) */
       62 dcl  (i, j) fixed bin;
       63 dcl  bfsw bit (1) aligned init ("1"b);			/* default to brief mode */
       64 dcl  pddsw bit (1) aligned init ("0"b);			/* default is to omit >pdd from the sweep */
       65 dcl  priv_off bit (1) aligned;			/* flag to tell that system privileges are off */
       66 dcl  priv_set fixed bin (35);				/* this will be zero if we set system privileges */
       67 dcl  cpx fixed bin;
       68 
       69 dcl  (addr, clock, index, null, rtrim, substr, sum) builtin;
       70 
       71 dcl  (cleanup, linkage_error, seg_fault_error) condition;
       72 
  1     1 /* BEGIN INCLUDE FILE ... disk_stat.incl.pl1 */
  1     2 
  1     3 /* This segment is created by "sweep" and read by "charge_disk" when disk stats are being charged. */
  1     4 /* Modified April 1976 by TAC to add dqta, duse, and dtpp */
  1     5 
  1     6 dcl  sp ptr;					/* pointer to segment */
  1     7 
  1     8 dcl 1 disk_stat based (sp) aligned,			/* structure of segment */
  1     9     2 dents fixed bin,				/* number of entries */
  1    10     2 dpad1 fixed bin,
  1    11     2 dtime fixed bin (71),				/* Time file was generated */
  1    12     2 dreset fixed bin (71),				/* Time of disk reset */
  1    13     2 dpad2 (2) fixed bin,
  1    14     2 dtab (1000),					/* one for each dir with a quota */
  1    15       3 spth char (168),				/* path name */
  1    16       3 sqta fixed bin,				/* segment quota */
  1    17       3 dqta fixed bin,				/* directory quota */
  1    18       3 suse fixed bin,				/* segment pages qued */
  1    19       3 duse fixed bin,				/* directory pages used */
  1    20       3 stpp fixed bin (71),				/* time-page product for segments */
  1    21       3 dtpp fixed bin (71),				/* time-page product for directories */
  1    22       3 slvid bit (36),				/* son's lvid of this dir */
  1    23       3 slev fixed bin;				/* recursion level */
  1    24 
  1    25 dcl  lodh fixed bin init (8),				/* lth of disk_stat head */
  1    26      lode fixed bin init (52);			/* lth of disk_stat entry */
  1    27 
  1    28 /* END INCLUDE FILE ... disk_stat.incl.pl1 */
       73 
       74 
       75 dcl  com_err_ entry options (variable);
       76 dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
       77 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       78 dcl  ioa_ entry options (variable);
       79 dcl  get_system_free_area_ entry () returns (ptr);
       80 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       81 dcl  (get_pdir_, get_wdir_) entry () returns (char (168));
       82 dcl  get_group_id_ entry () returns (char (32));
       83 dcl  hcs_$get_uid_seg entry (ptr, bit (36) aligned, fixed bin (35));
       84 dcl  hcs_$quota_read
       85 	entry (char (*), fixed bin, fixed bin (71), fixed bin (35), bit (36), fixed bin (1), fixed bin, fixed bin (35));
       86 dcl  hcs_$dir_quota_read
       87 	entry (char (*), fixed bin, fixed bin (71), fixed bin (35), bit (36), fixed bin (1), fixed bin, fixed bin (35));
       88 dcl  hphcs_$quota_read
       89 	entry (char (*), fixed bin, fixed bin (71), fixed bin (35), bit (36), fixed bin (1), fixed bin, fixed bin (35));
       90 dcl  hphcs_$dir_quota_read
       91 	entry (char (*), fixed bin, fixed bin (71), fixed bin (35), bit (36), fixed bin (1), fixed bin, fixed bin (35));
       92 dcl  hphcs_$deactivate entry (bit (36) aligned, fixed bin (35));
       93 dcl  msf_manager_$close entry (ptr);
       94 dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
       95 dcl  msf_manager_$msf_get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
       96 dcl  msf_manager_$open entry (char (*), char (*), ptr, fixed bin (35));
       97 dcl  system_privilege_$dir_priv_on entry (fixed bin (35));
       98 dcl  system_privilege_$dir_priv_off entry (fixed bin (35));
       99 dcl  phcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      100 dcl  phcs_$terminate_noname entry (ptr, fixed bin (35));
      101 dcl  hcs_$add_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      102 dcl  hcs_$delete_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      103 dcl  hcs_$set_bc entry (char (*), char (*), fixed bin (24), fixed bin (35));
      104 dcl  hcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
      105 dcl  hphcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
      106 
      107 dcl  (
      108      error_table_$badopt,
      109      error_table_$noarg
      110      ) ext fixed bin (35);
      111 
      112 dcl  1 acla aligned,
      113        2 userid char (32),
      114        2 mode bit (36),
      115        2 rcode fixed bin (35);
      116 
      117 dcl  1 acld aligned,
      118        2 userid char (32),
      119        2 rcode fixed bin (35);
      120 dcl  cp_array (0:4) ptr;
      121 
      122 
      123 	ec = 0;
      124 	do an = 1 by 1 while (ec = 0);
      125 	     call cu_$arg_ptr (an, ap, al, ec);
      126 	     if ec = 0 then do;
      127 		if /* case */ substr (bchr, 1, 1) ^= "-" then do;
      128 		     call absolute_pathname_ (bchr, path, ec);
      129 		     if ec ^= 0 then do;
      130 			call com_err_ (ec, "sweep", "^a", bchr);
      131 			return;
      132 		     end;
      133 		end;
      134 		else if bchr = "-bf" then bfsw = "1"b;
      135 		else if bchr = "-brief" then bfsw = "1"b;
      136 		else if bchr = "-lg" then bfsw = "0"b;
      137 		else if bchr = "-long" then bfsw = "0"b;
      138 		else if bchr = "-pdd" then pddsw = "1"b;
      139 		else if bchr = "-of" | bchr = "-output_file" then do;
      140 		     an = an + 1;
      141 		     call cu_$arg_ptr (an, ap, al, ec);
      142 		     if ec ^= 0 then do;
      143 			call com_err_ (error_table_$noarg, "sweep", "after ""-output_file""");
      144 			return;
      145 		     end;
      146 		     call expand_pathname_ (bchr, dn, en, ec);
      147 		     if ec ^= 0 then do;
      148 			call com_err_ (ec, "sweep", "^a", bchr);
      149 			return;
      150 		     end;
      151 		end;
      152 		else do;
      153 		     call com_err_ (error_table_$badopt, "sweep", "^a", bchr);
      154 		     return;
      155 		end;
      156 	     end;
      157 	end;
      158 
      159 	priv_off = "1"b;				/* assume that we don't have dir privilege */
      160 	priv_set = 1;				/* and that we did not set dir priv */
      161 	hpriv = "0"b;
      162 	ppriv = "0"b;
      163 	on cleanup
      164 	     begin;				/* so we can undo what we did */
      165 		if priv_set = 0 then call system_privilege_$dir_priv_off (priv_set);
      166 	     end;
      167 
      168 /*	Now we will try to set dir privilege so we can look at each dir in the system. */
      169 
      170 	on linkage_error go to revert_handler;		/* in case of no access to system_privilege_ */
      171 
      172 	call system_privilege_$dir_priv_on (priv_set);	/* try to set it */
      173 	priv_off = "0"b;				/* privileges are on now for sure */
      174 revert_handler:
      175 	revert linkage_error;			/* it was only to catch system_privilege_ error */
      176 	on linkage_error go to revert1;
      177 	call hphcs_$star_ (">", "**", 0, null (), 0, null (), null (), 0);
      178 	hpriv = "1"b;				/* Didn't fault, so im super */
      179 revert1:
      180 	revert linkage_error;
      181 
      182 	on linkage_error goto revert2;
      183 	call phcs_$initiate (">", "", "", 0, 0, null (), 0);
      184 	ppriv = "1"b;
      185 revert2:	revert linkage_error;
      186 
      187 	if priv_off then do;			/* see if we now have the dir priv */
      188 	     if bfsw
      189 	     then call com_err_ (0, "sweep",		/* give this message if we supress others */
      190 		     "Unable to set directory privilege. Access to storage system may not be complete.");
      191 	     priv_set = 1;				/* just to be safe */
      192 	end;
      193 
      194 	cp_array (*), fcbp, sp = null ();
      195 	cpx = 0;
      196 	call msf_manager_$open (dn, en, fcbp, ec);
      197 	if fcbp = null () then do;
      198 	     call com_err_ (ec, "sweep", "");
      199 	     return;
      200 	end;
      201 
      202 	call msf_manager_$get_ptr (fcbp, cpx, "1"b, cp_array (0), 0, ec);
      203 	if cp_array (0) = null () then do;
      204 	     call com_err_ (ec, "sweep", "^a", en);
      205 	     return;
      206 	end;
      207 	if ec ^= 0 then do;
      208 	     call com_err_ (ec, "sweep", "");
      209 	     return;
      210 	end;
      211 
      212 	sp = cp_array (0);
      213 	n, tn = 0;				/* Start with no directories. */
      214 
      215 	acla.userid = get_group_id_ ();
      216 	acld.userid = acla.userid;
      217 	acla.mode = "111"b;
      218 
      219 	areap = get_system_free_area_ ();
      220 
      221 /* Compute starting level, so that a given directory will always have the same level number,
      222*   no matter where the sweep starts */
      223 
      224 	i = 2;					/* skip the leading ">" since the root is level zero */
      225 	j = 1;					/* just to get past the "while" the first time */
      226 	do starting_level = -1 by 1			/* count ">"s in path */
      227 	     while (j ^= 0);			/* and quit when there are no more */
      228 	     j = index (substr (path, i), ">");		/* look for one */
      229 	     if j ^= 0
      230 	     then					/* if there was one */
      231 		i = i + j;			/* move past it */
      232 	end;					/* increment starting_level, then go test j */
      233 						/* for root, we fall thru after setting starting_level to zero */
      234 
      235 	call process (path, starting_level);		/* Looks innocent ... */
      236 
      237 	if cpx > 0 then do;
      238 	     sp = cp_array (0);
      239 	     tn = tn + n;
      240 	end;
      241 	else tn = n;				/* to set dents below */
      242 	disk_stat.dtime = clock ();			/* read clock */
      243 	quota = tot_dquota + tot_squota;
      244 	used = tot_dused + tot_sused;
      245 	call ioa_ ("^d/^d", quota, used);		/* type total */
      246 	call ioa_ ("dir: ^d/^d", tot_dquota, tot_dused);
      247 	call ioa_ ("seg: ^d/^d", tot_squota, tot_sused);
      248 	disk_stat.dents = tn;
      249 	if fcbp ^= null then call msf_manager_$close (fcbp);
      250 	bitc = 36 * (lodh + tn * lode);		/* Compute bit count. */
      251 	call hcs_$set_bc (dn, en, bitc, ec);		/* ... */
      252 
      253 	if priv_set = 0 then call system_privilege_$dir_priv_off (priv_set);
      254 						/* reset if we did it */
      255 
      256 	return;					/* Done. */
      257 
      258 process:
      259      procedure (apth, lvl);
      260 
      261 /* internal doit procedure */
      262 
      263 dcl  apth char (168),				/* path of tree to process */
      264      lvl fixed bin;					/* recursion level */
      265 
      266 dcl  npth char (168),				/* new path for recursion */
      267      ddn char (168),				/* ... for expand */
      268      een char (32),					/* ... */
      269      error_table_$nomatch fixed bin (35) ext,
      270      (stpp, dtpp) fixed bin (71),			/* args for quota_read */
      271      updatime fixed bin (35),
      272      (squota, dquota, sused, dused) fixed bin,
      273      slvid bit (36),
      274      (dquota_sw, squota_sw) fixed bin (1),
      275      ifail fixed bin,
      276      ecc fixed bin (35),
      277      (ii, nix) fixed bin;				/* indices */
      278 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      279 
      280 	star_entry_ptr, star_names_ptr = null ();
      281 	on cleanup
      282 	     begin;				/* get ready to undo everything */
      283 		if star_names_ptr ^= null then free star_names;
      284 		if star_entry_ptr ^= null then free star_entries;
      285 		if ifail = 0 then call hcs_$delete_dir_acl_entries (ddn, een, addr (acld), 1, ecc);
      286 	     end;
      287 
      288 	call expand_pathname_ (apth, ddn, een, ecc);
      289 	if ecc ^= 0 then do;
      290 	     call com_err_ (ecc, "sweep", "^a", apth);
      291 	     return;
      292 	end;
      293 
      294 	if hpriv
      295 	then ifail = 2;
      296 	else do;
      297 	     call hcs_$add_dir_acl_entries (ddn, een, addr (acla), 1, ecc);
      298 	     if ecc ^= 0
      299 	     then ifail = 1;
      300 	     else ifail = 0;
      301 	end;
      302 
      303 	on seg_fault_error goto pexit;
      304 
      305 	if hpriv
      306 	then call hphcs_$dir_quota_read (apth, dquota, dtpp, updatime, slvid, dquota_sw, dused, ecc);
      307 	else call hcs_$dir_quota_read (apth, dquota, dtpp, updatime, slvid, dquota_sw, dused, ecc);
      308 	if ecc ^= 0 then goto gq_err;
      309 
      310 	if hpriv
      311 	then call hphcs_$quota_read (apth, squota, stpp, updatime, slvid, squota_sw, sused, ecc);
      312 	else call hcs_$quota_read (apth, squota, stpp, updatime, slvid, squota_sw, sused, ecc);
      313 	if ecc ^= 0 then do;
      314 gq_err:
      315 	     if ^bfsw then call com_err_ (ecc, "sweep", "getquota on ^a", apth);
      316 	     go to pexit;
      317 	end;
      318 
      319 	if dquota_sw + squota_sw ^= 0 then do;		/* if either dir quota or seg quota nonzero,
      320*						   add it in and keep recursing */
      321 	     tot_dused = tot_dused + dused;		/* add up global use */
      322 	     tot_sused = tot_sused + sused;
      323 	     tot_dquota = tot_dquota + dquota;		/* and global quota */
      324 	     tot_squota = tot_squota + squota;
      325 
      326 	     if (lodh + (n+1) * lode) > sys_info$max_seg_size then do;
      327 		cpx = cpx + 1;
      328 		call msf_manager_$msf_get_ptr (fcbp, cpx, "1"b, cp_array (cpx), 0, ec);
      329 		if ec ^= 0 then do;
      330 		     call com_err_ (ec, "sweep", "Cannot expand MSF for ^a", en);
      331 		     goto pexit;
      332 		end;
      333 		sp = cp_array (cpx);
      334 		tn = tn + n;
      335 		n = 0;
      336 	     end;
      337 	     n = n + 1;				/* allocate a new slot */
      338 	     disk_stat.spth (n) = apth;		/* fill in path name */
      339 	     disk_stat.sqta (n) = squota;		/* segment quota */
      340 	     disk_stat.dqta (n) = dquota;		/* directory quota */
      341 
      342 	     if squota = 0 then stpp = 0;		/* clear possible garbage, in case the */
      343 	     if dquota = 0 then dtpp = 0;		/* storage system is not careful about doing so */
      344 
      345 	     disk_stat.suse (n) = sused;		/* segment pages used */
      346 	     disk_stat.duse (n) = dused;		/* directory pages used */
      347 	     disk_stat.slvid (n) = slvid;		/* son's lvid */
      348 	     disk_stat.stpp (n) = stpp;		/* segment time-page product */
      349 	     disk_stat.dtpp (n) = dtpp;		/* directory time-page product */
      350 	     disk_stat.slev (n) = lvl;		/* .. recursion level */
      351 
      352 	     if hpriv
      353 	     then call hphcs_$star_ (apth, "**", star_BRANCHES_ONLY, areap, star_entry_count, star_entry_ptr,
      354 		     star_names_ptr, ecc);
      355 	     else call hcs_$star_ (apth, "**", star_BRANCHES_ONLY, areap, star_entry_count, star_entry_ptr,
      356 		     star_names_ptr, ecc);
      357 	     revert seg_fault_error;
      358 	     if ecc = error_table_$nomatch then go to pexit;
      359 						/* Get all names. If none, go. */
      360 	     if ecc ^= 0 then do;			/* If any other error from star, name it. */
      361 		if ^bfsw then call com_err_ (ecc, "sweep", "star on ^a", apth);
      362 		go to pexit;
      363 	     end;
      364 inloop:
      365 	     do ii = 1 to star_entry_count;		/* Now do all branches, look for sub-dirs. */
      366 		if star_entries (ii).type = star_DIRECTORY then do;
      367 		     nix = star_entries (ii).nindex;
      368 		     if apth ^= ">"			/* Fabricate path name. */
      369 		     then npth = rtrim (apth) || ">" || star_names (nix);
      370 		     else do;			/* The root is special. */
      371 			npth = ">" || star_names (nix);
      372 			if ^pddsw
      373 			then			/* unless user said to sweep >pdd */
      374 			     if (npth = ">process_dir_dir")
      375 						/* if this is >pdd */
      376 				| (npth = ">pdd") | (substr (npth, 1, 6) = ">pdd.!")
      377 			     then goto nopdir;
      378 		     end;
      379 		     call process (npth, lvl + 1);	/* recursion here */
      380 nopdir:
      381 		end;
      382 	     end inloop;
      383 	     free star_names;
      384 	     free star_entries;
      385 	end;
      386 pexit:
      387 	if ppriv & hpriv then			/* if privileged, prepare to clean up */
      388 	     call phcs_$initiate (ddn, een, "", 0, 0, seg_ptr, ecc);
      389 	else seg_ptr = null;
      390 
      391 	if (ifail = 0) & (apth ^= pdir) & ^pddsw
      392 	then					/* don't deny user access to his own pdir */
      393 	     call hcs_$delete_dir_acl_entries (ddn, een, addr (acld), 1, ecc);
      394 
      395 	if seg_ptr ^= null then do;			/* now hardcore can't possibly want to touch the thing */
      396 	     call hcs_$get_uid_seg (seg_ptr, uid, ecc);
      397 	     if ecc = 0 then call hphcs_$deactivate (uid, ecc);
      398 	     call phcs_$terminate_noname (seg_ptr, ecc);
      399 	end;
      400 	ecc = 0;
      401 
  2     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  2     2 
  2     3 /* This include file contains structures for the hcs_$star_,
  2     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  2     5*
  2     6*   Written 23 October 1978 by Monte Davidoff.
  2     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  2     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  2     9**/
  2    10 
  2    11 /* automatic */
  2    12 
  2    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  2    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  2    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  2    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  2    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  2    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  2    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  2    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  2    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  2    22 
  2    23 /* based */
  2    24 
  2    25 /* hcs_$star_ entry structure */
  2    26 
  2    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  2    28         2 type fixed binary (2) unsigned unaligned,
  2    29 						/* storage system type */
  2    30         2 nnames fixed binary (16) unsigned unaligned,
  2    31 						/* number of names of entry that match star_name */
  2    32         2 nindex fixed binary (18) unsigned unaligned;
  2    33 						/* index of first name in star_names */
  2    34 
  2    35 /* hcs_$star_ name structure */
  2    36 
  2    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  2    38 
  2    39 /* hcs_$star_list_ branch structure */
  2    40 
  2    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  2    42         2 type fixed binary (2) unsigned unaligned,
  2    43 						/* storage system type */
  2    44         2 nnames fixed binary (16) unsigned unaligned,
  2    45 						/* number of names of entry that match star_name */
  2    46         2 nindex fixed binary (18) unsigned unaligned,
  2    47 						/* index of first name in star_list_names */
  2    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  2    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  2    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  2    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  2    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  2    53         2 pad bit (7) unaligned,
  2    54         2 records fixed binary (18) unsigned unaligned;
  2    55 						/* records used by branch */
  2    56 
  2    57 /* hcs_$star_dir_list_ branch structure */
  2    58 
  2    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  2    60         2 type fixed binary (2) unsigned unaligned,
  2    61 						/* storage system type */
  2    62         2 nnames fixed binary (16) unsigned unaligned,
  2    63 						/* number of names of entry that match star_name */
  2    64         2 nindex fixed binary (18) unsigned unaligned,
  2    65 						/* index of first name in star_list_names */
  2    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  2    67         2 pad bit (36) unaligned,
  2    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  2    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  2    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  2    71         2 bit_count fixed binary (24) unaligned;
  2    72 						/* bit count of the branch */
  2    73 
  2    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  2    75 
  2    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  2    77         2 type fixed binary (2) unsigned unaligned,
  2    78 						/* storage system type */
  2    79         2 nnames fixed binary (16) unsigned unaligned,
  2    80 						/* number of names of entry that match star_name */
  2    81         2 nindex fixed binary (18) unsigned unaligned,
  2    82 						/* index of first name in star_list_names */
  2    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  2    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  2    85         2 pathname_len fixed binary (18) unsigned unaligned,
  2    86 						/* length of the pathname of the link */
  2    87         2 pathname_index fixed binary (18) unsigned unaligned;
  2    88 						/* index of start of pathname in star_list_names */
  2    89 
  2    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  2    91 
  2    92 declare  star_list_names char (32) based (star_list_names_ptr)
  2    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  2    94 	 + star_links (star_branch_count + star_link_count).nnames
  2    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  2    96 	   * binary (
  2    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  2    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  2    99 
  2   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  2   101 
  2   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  2   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  2   104 
  2   105 /* internal static */
  2   106 
  2   107 /* star_select_sw values */
  2   108 
  2   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  2   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  2   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  2   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  2   113          fixed binary (3) internal static options (constant) initial (5);
  2   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  2   115          fixed binary (3) internal static options (constant) initial (7);
  2   116 
  2   117 /* storage system types */
  2   118 
  2   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  2   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  2   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  2   122 
  2   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
      402 
      403 
      404      end process;					/* Whew. */
  3     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      405 
      406 
      407 
      408      end sweep;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/26/88  1214.5  sweep.pl1                         >spec>install>1043>sweep.pl1
73           1    06/22/76  1355.6  disk_stat.incl.pl1                >ldd>include>disk_stat.incl.pl1
402          2    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
405          3    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
absolute_pathname_              000012 constant        entry                    external dcl 76 ref 128
acla                            000366 automatic       structure                level 1 dcl 112 set ref 297 297
acld                            000400 automatic       structure                level 1 dcl 117 set ref 285 285 391 391
addr                                                   builtin function         dcl 69 ref 285 285 297 297 391 391
al                              000334 automatic       fixed bin(17,0)          dcl 58 set ref 125* 127 128 128 130 130 134 135 136
                                                                                  137 138 139 139 141* 146 146 148 148 153 153
an                              000330 automatic       fixed bin(17,0)          dcl 56 set ref 124* 125* 140* 140 141*
ap                              000332 automatic       pointer                  dcl 57 set ref 125* 127 128 130 134 135 136 137 138
                                                                                  139 139 141* 146 148 153
apth                                   parameter       char(168)                packed unaligned dcl 263 set ref 258 288* 290* 305*
                                                                                  307* 310* 312* 314* 338 352* 355* 361* 368 368 391
areap                           000306 automatic       pointer                  dcl 46 set ref 219* 352* 355*
bchr                                   based           char                     packed unaligned dcl 59 set ref 127 128* 130* 134
                                                                                  135 136 137 138 139 139 146* 148* 153*
bfsw                            000341 automatic       bit(1)                   initial dcl 63 set ref 63* 134* 135* 136* 137* 188
                                                                                  314 361
bitc                            000327 automatic       fixed bin(24,0)          dcl 55 set ref 250* 251*
cleanup                         000346 stack reference condition                dcl 71 ref 163 281
clock                                                  builtin function         dcl 69 ref 242
com_err_                        000010 constant        entry                    external dcl 75 ref 130 143 148 153 188 198 204 208
                                                                                  290 314 330 361
cp_array                        000412 automatic       pointer                  array dcl 120 set ref 194* 202* 203 212 238 328* 333
cpx                             000345 automatic       fixed bin(17,0)          dcl 67 set ref 195* 202* 237 327* 327 328* 328 333
cu_$arg_ptr                     000022 constant        entry                    external dcl 80 ref 125 141
ddn                             000152 automatic       char(168)                packed unaligned dcl 266 set ref 285* 288* 297* 386*
                                                                                  391*
dents                                  based           fixed bin(17,0)          level 2 dcl 1-8 set ref 248*
disk_stat                              based           structure                level 1 dcl 1-8
dn                              000152 automatic       char(168)                initial packed unaligned dcl 43 set ref 43* 146*
                                                                                  196* 251*
dqta                     63            based           fixed bin(17,0)          array level 3 dcl 1-8 set ref 340*
dquota                          000242 automatic       fixed bin(17,0)          dcl 266 set ref 305* 307* 323 340 343
dquota_sw                       000246 automatic       fixed bin(1,0)           dcl 266 set ref 305* 307* 319
dtab                     10            based           structure                array level 2 dcl 1-8
dtime                     2            based           fixed bin(71,0)          level 2 dcl 1-8 set ref 242*
dtpp                     70            based           fixed bin(71,0)          array level 3 in structure "disk_stat" dcl 1-8
                                                                                  in procedure "sweep" set ref 349*
dtpp                            000236 automatic       fixed bin(71,0)          dcl 266 in procedure "process" set ref 305* 307*
                                                                                  343* 349
duse                     65            based           fixed bin(17,0)          array level 3 dcl 1-8 set ref 346*
dused                           000244 automatic       fixed bin(17,0)          dcl 266 set ref 305* 307* 321 346
ec                              000335 automatic       fixed bin(35,0)          dcl 60 set ref 123* 124 125* 126 128* 129 130* 141*
                                                                                  142 146* 147 148* 196* 198* 202* 204* 207 208*
                                                                                  251* 328* 329 330*
ecc                             000251 automatic       fixed bin(35,0)          dcl 266 set ref 285* 288* 289 290* 297* 298 305*
                                                                                  307* 308 310* 312* 313 314* 352* 355* 358 360 361*
                                                                                  386* 391* 396* 397 397* 398* 400*
een                             000224 automatic       char(32)                 packed unaligned dcl 266 set ref 285* 288* 297* 386*
                                                                                  391*
en                              000276 automatic       char(32)                 initial packed unaligned dcl 45 set ref 45* 146*
                                                                                  196* 204* 251* 330*
error_table_$badopt             000100 external static fixed bin(35,0)          dcl 107 set ref 153*
error_table_$noarg              000102 external static fixed bin(35,0)          dcl 107 set ref 143*
error_table_$nomatch            000104 external static fixed bin(35,0)          dcl 266 ref 358
expand_pathname_                000014 constant        entry                    external dcl 77 ref 146 288
fcbp                            000310 automatic       pointer                  dcl 47 set ref 194* 196* 197 202* 249 249* 328*
get_group_id_                   000030 constant        entry                    external dcl 82 ref 215
get_pdir_                       000024 constant        entry                    external dcl 81 ref 44
get_system_free_area_           000020 constant        entry                    external dcl 79 ref 219
get_wdir_                       000026 constant        entry                    external dcl 81 ref 43
hcs_$add_dir_acl_entries        000066 constant        entry                    external dcl 101 ref 297
hcs_$delete_dir_acl_entries     000070 constant        entry                    external dcl 102 ref 285 391
hcs_$dir_quota_read             000036 constant        entry                    external dcl 86 ref 307
hcs_$get_uid_seg                000032 constant        entry                    external dcl 83 ref 396
hcs_$quota_read                 000034 constant        entry                    external dcl 84 ref 312
hcs_$set_bc                     000072 constant        entry                    external dcl 103 ref 251
hcs_$star_                      000074 constant        entry                    external dcl 104 ref 355
hphcs_$deactivate               000044 constant        entry                    external dcl 92 ref 397
hphcs_$dir_quota_read           000042 constant        entry                    external dcl 90 ref 305
hphcs_$quota_read               000040 constant        entry                    external dcl 88 ref 310
hphcs_$star_                    000076 constant        entry                    external dcl 105 ref 177 352
hpriv                           000320 automatic       bit(1)                   dcl 50 set ref 161* 178* 294 305 310 352 386
i                               000337 automatic       fixed bin(17,0)          dcl 62 set ref 224* 228 229* 229
ifail                           000250 automatic       fixed bin(17,0)          dcl 266 set ref 285 294* 298* 300* 391
ii                              000252 automatic       fixed bin(17,0)          dcl 266 set ref 364* 366 367*
index                                                  builtin function         dcl 69 ref 228
ioa_                            000016 constant        entry                    external dcl 78 ref 245 246 247
j                               000340 automatic       fixed bin(17,0)          dcl 62 set ref 225* 226 228* 229 229
linkage_error                   000354 stack reference condition                dcl 71 ref 170 174 176 179 182 185
lode                            000365 automatic       fixed bin(17,0)          initial dcl 1-25 set ref 250 1-25* 326
lodh                            000364 automatic       fixed bin(17,0)          initial dcl 1-25 set ref 250 1-25* 326
lvl                                    parameter       fixed bin(17,0)          dcl 263 ref 258 350 379
mode                     10     000366 automatic       bit(36)                  level 2 dcl 112 set ref 217*
msf_manager_$close              000046 constant        entry                    external dcl 93 ref 249
msf_manager_$get_ptr            000050 constant        entry                    external dcl 94 ref 202
msf_manager_$msf_get_ptr        000052 constant        entry                    external dcl 95 ref 328
msf_manager_$open               000054 constant        entry                    external dcl 96 ref 196
n                               000325 automatic       fixed bin(17,0)          dcl 54 set ref 213* 239 241 326 334 335* 337* 337
                                                                                  338 339 340 345 346 347 348 349 350
nindex                    0(18)        based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 2-27 ref 367
nix                             000253 automatic       fixed bin(17,0)          dcl 266 set ref 367* 368 371
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 2-27 ref 283 383
npth                            000100 automatic       char(168)                packed unaligned dcl 266 set ref 368* 371* 372 372
                                                                                  372 379*
null                                                   builtin function         dcl 69 ref 177 177 177 177 177 177 183 183 194 197
                                                                                  203 249 280 283 284 389 395
path                            000100 automatic       char(168)                initial packed unaligned dcl 42 set ref 42* 128* 228
                                                                                  235*
pddsw                           000342 automatic       bit(1)                   initial dcl 64 set ref 64* 138* 372 391
pdir                            000224 automatic       char(168)                initial packed unaligned dcl 44 set ref 44* 391
phcs_$initiate                  000062 constant        entry                    external dcl 99 ref 183 386
phcs_$terminate_noname          000064 constant        entry                    external dcl 100 ref 398
ppriv                           000321 automatic       bit(1)                   dcl 51 set ref 162* 184* 386
priv_off                        000343 automatic       bit(1)                   dcl 65 set ref 159* 173* 187
priv_set                        000344 automatic       fixed bin(35,0)          dcl 66 set ref 160* 165 165* 172* 191* 253 253*
quota                           000312 automatic       fixed bin(35,0)          initial dcl 48 set ref 48* 243* 245*
rtrim                                                  builtin function         dcl 69 ref 368
seg_fault_error                 000000 stack reference condition                dcl 71 ref 303 357
seg_ptr                         000322 automatic       pointer                  dcl 52 set ref 386* 389* 395 396* 398*
slev                     73            based           fixed bin(17,0)          array level 3 dcl 1-8 set ref 350*
slvid                           000245 automatic       bit(36)                  packed unaligned dcl 266 in procedure "process" set
                                                                                  ref 305* 307* 310* 312* 347
slvid                    72            based           bit(36)                  array level 3 in structure "disk_stat" dcl 1-8
                                                                                  in procedure "sweep" set ref 347*
sp                              000362 automatic       pointer                  dcl 1-6 set ref 194* 212* 238* 242 248 333* 338 339
                                                                                  340 345 346 347 348 349 350
spth                     10            based           char(168)                array level 3 dcl 1-8 set ref 338*
sqta                     62            based           fixed bin(17,0)          array level 3 dcl 1-8 set ref 339*
squota                          000241 automatic       fixed bin(17,0)          dcl 266 set ref 310* 312* 324 339 342
squota_sw                       000247 automatic       fixed bin(1,0)           dcl 266 set ref 310* 312* 319
star_BRANCHES_ONLY              000027 constant        fixed bin(2,0)           initial dcl 2-110 set ref 352* 355*
star_DIRECTORY                         constant        fixed bin(2,0)           initial unsigned dcl 2-121 ref 366
star_entries                           based           structure                array level 1 dcl 2-27 ref 284 384
star_entry_count                000254 automatic       fixed bin(17,0)          dcl 2-14 set ref 283 284 352* 355* 364 383 384
star_entry_ptr                  000256 automatic       pointer                  dcl 2-15 set ref 280* 283 284 284 352* 355* 366 367
                                                                                  383 384
star_names                             based           char(32)                 array packed unaligned dcl 2-37 ref 283 368 371 383
star_names_ptr                  000260 automatic       pointer                  dcl 2-19 set ref 280* 283 283 352* 355* 368 371 383
starting_level                  000336 automatic       fixed bin(17,0)          dcl 61 set ref 226* 235*
stpp                     66            based           fixed bin(71,0)          array level 3 in structure "disk_stat" dcl 1-8
                                                                                  in procedure "sweep" set ref 348*
stpp                            000234 automatic       fixed bin(71,0)          dcl 266 in procedure "process" set ref 310* 312*
                                                                                  342* 348
substr                                                 builtin function         dcl 69 ref 127 228 372
sum                                                    builtin function         dcl 69 ref 283 383
suse                     64            based           fixed bin(17,0)          array level 3 dcl 1-8 set ref 345*
sused                           000243 automatic       fixed bin(17,0)          dcl 266 set ref 310* 312* 322 345
sys_info$max_seg_size           000106 external static fixed bin(35,0)          dcl 278 ref 326
system_privilege_$dir_priv_off  000060 constant        entry                    external dcl 98 ref 165 253
system_privilege_$dir_priv_on   000056 constant        entry                    external dcl 97 ref 172
tn                              000326 automatic       fixed bin(17,0)          dcl 54 set ref 213* 239* 239 241* 248 250 334* 334
tot_dquota                      000313 automatic       fixed bin(35,0)          initial dcl 48 set ref 48* 243 246* 323* 323
tot_dused                       000316 automatic       fixed bin(35,0)          initial dcl 49 set ref 49* 244 246* 321* 321
tot_squota                      000314 automatic       fixed bin(35,0)          initial dcl 48 set ref 48* 243 247* 324* 324
tot_sused                       000317 automatic       fixed bin(35,0)          initial dcl 49 set ref 49* 244 247* 322* 322
type                                   based           fixed bin(2,0)           array level 2 packed packed unsigned unaligned
                                                                                  dcl 2-27 ref 366
uid                             000324 automatic       bit(36)                  dcl 53 set ref 396* 397*
updatime                        000240 automatic       fixed bin(35,0)          dcl 266 set ref 305* 307* 310* 312*
used                            000315 automatic       fixed bin(35,0)          initial dcl 49 set ref 49* 244* 245*
userid                          000400 automatic       char(32)                 level 2 in structure "acld" dcl 117 in procedure
                                                                                  "sweep" set ref 216*
userid                          000366 automatic       char(32)                 level 2 in structure "acla" dcl 112 in procedure
                                                                                  "sweep" set ref 215* 216

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
star_ALL_ENTRIES                       internal static fixed bin(2,0)           initial dcl 2-111
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 2-114
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 2-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 2-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 2-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 2-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 2-13
star_dir_list_branch                   based           structure                array level 1 dcl 2-59
star_link_count                        automatic       fixed bin(17,0)          dcl 2-17
star_link_pathname                     based           char                     packed unaligned dcl 2-102
star_links                             based           structure                array level 1 dcl 2-76
star_linkx                             automatic       fixed bin(17,0)          dcl 2-18
star_list_branch                       based           structure                array level 1 dcl 2-41
star_list_branch_ptr                   automatic       pointer                  dcl 2-16
star_list_names                        based           char(32)                 array packed unaligned dcl 2-92
star_list_names_ptr                    automatic       pointer                  dcl 2-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 2-21

NAMES DECLARED BY EXPLICIT CONTEXT.
gq_err                          002366 constant        label                    dcl 314 ref 308
inloop                          003014 constant        label                    dcl 364
nopdir                          003162 constant        label                    dcl 380 ref 372
pexit                           003214 constant        label                    dcl 386 ref 303 316 331 358 362
process                         001627 constant        entry                    internal dcl 258 ref 235 379
revert1                         000771 constant        label                    dcl 179 ref 176
revert2                         001062 constant        label                    dcl 185 ref 182
revert_handler                  000671 constant        label                    dcl 174 ref 170
sweep                           000153 constant        entry                    external dcl 24

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4040        4150    3411        4050
Length      4464    3411       110         277     427           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sweep                               369 external procedure  is an external procedure.  
on unit on line 163                  68 on unit               
on unit on line 170                  64 on unit               
on unit on line 176                  64 on unit               
on unit on line 182                  64 on unit               
process                             275 internal procedure  enables or reverts conditions.  
on unit on line 281                  90 on unit               
on unit on line 303                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
process                  000100 npth                        process
                         000152 ddn                         process
                         000224 een                         process
                         000234 stpp                        process
                         000236 dtpp                        process
                         000240 updatime                    process
                         000241 squota                      process
                         000242 dquota                      process
                         000243 sused                       process
                         000244 dused                       process
                         000245 slvid                       process
                         000246 dquota_sw                   process
                         000247 squota_sw                   process
                         000250 ifail                       process
                         000251 ecc                         process
                         000252 ii                          process
                         000253 nix                         process
                         000254 star_entry_count            process
                         000256 star_entry_ptr              process
                         000260 star_names_ptr              process
sweep                    000100 path                        sweep
                         000152 dn                          sweep
                         000224 pdir                        sweep
                         000276 en                          sweep
                         000306 areap                       sweep
                         000310 fcbp                        sweep
                         000312 quota                       sweep
                         000313 tot_dquota                  sweep
                         000314 tot_squota                  sweep
                         000315 used                        sweep
                         000316 tot_dused                   sweep
                         000317 tot_sused                   sweep
                         000320 hpriv                       sweep
                         000321 ppriv                       sweep
                         000322 seg_ptr                     sweep
                         000324 uid                         sweep
                         000325 n                           sweep
                         000326 tn                          sweep
                         000327 bitc                        sweep
                         000330 an                          sweep
                         000332 ap                          sweep
                         000334 al                          sweep
                         000335 ec                          sweep
                         000336 starting_level              sweep
                         000337 i                           sweep
                         000340 j                           sweep
                         000341 bfsw                        sweep
                         000342 pddsw                       sweep
                         000343 priv_off                    sweep
                         000344 priv_set                    sweep
                         000345 cpx                         sweep
                         000362 sp                          sweep
                         000364 lodh                        sweep
                         000365 lode                        sweep
                         000366 acla                        sweep
                         000400 acld                        sweep
                         000412 cp_array                    sweep

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           mpfx2               enable_op           shorten_stack       ext_entry
int_entry           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      cu_$arg_ptr                   expand_pathname_
get_group_id_                 get_pdir_                     get_system_free_area_         get_wdir_
hcs_$add_dir_acl_entries      hcs_$delete_dir_acl_entries   hcs_$dir_quota_read           hcs_$get_uid_seg
hcs_$quota_read               hcs_$set_bc                   hcs_$star_                    hphcs_$deactivate
hphcs_$dir_quota_read         hphcs_$quota_read             hphcs_$star_                  ioa_
msf_manager_$close            msf_manager_$get_ptr          msf_manager_$msf_get_ptr      msf_manager_$open
phcs_$initiate                phcs_$terminate_noname        system_privilege_$dir_priv_off
system_privilege_$dir_priv_on

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg            error_table_$nomatch          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000152        42 000160        43 000163        44 000171        45 000200        48 000203        49 000206
     63 000211        64 000213    1   25 000214       123 000220       124 000221       125 000226       126 000243
    127 000245       128 000252       129 000276       130 000300       131 000334       133 000335       134 000336
    135 000346       136 000355       137 000363       138 000371       139 000400       140 000410       141 000411
    142 000426       143 000430       144 000456       146 000457       147 000507       148 000511       149 000545
    151 000546       153 000547       154 000603       157 000604       159 000606       160 000610       161 000612
    162 000613       163 000614       165 000630       166 000641       170 000642       172 000661       173 000670
    174 000671       176 000672       177 000711       178 000767       179 000771       182 000772       183 001011
    184 001060       185 001062       187 001063       188 001065       191 001116       194 001120       195 001136
    196 001137       197 001164       198 001170       199 001213       202 001214       203 001240       204 001244
    205 001275       207 001276       208 001300       209 001323       212 001324       213 001326       215 001330
    216 001342       217 001345       219 001347       224 001356       225 001360       226 001362       228 001366
    229 001405       232 001407       235 001411       237 001421       238 001423       239 001425       240 001427
    241 001430       242 001432       243 001435       244 001441       245 001445       246 001467       247 001514
    248 001540       249 001542       250 001555       251 001567       253 001614       256 001625       258 001626
    280 001634       281 001637       283 001653       284 001707       285 001716       286 001757       288 001760
    289 002005       290 002007       291 002041       294 002042       297 002050       298 002105       300 002112
    303 002113       305 002132       307 002202       308 002246       310 002250       312 002320       313 002364
    314 002366       316 002427       319 002430       321 002433       322 002440       323 002444       324 002450
    326 002454       327 002466       328 002467       329 002514       330 002517       331 002554       333 002555
    334 002561       335 002563       337 002564       338 002565       339 002576       340 002602       342 002604
    343 002611       345 002615       346 002617       347 002621       348 002623       349 002625       350 002627
    352 002631       355 002701       357 002746       358 002747       360 002753       361 002755       362 003013
    364 003014       366 003023       367 003030       368 003034       370 003106       371 003107       372 003126
    379 003146       382 003162       383 003164       384 003212       386 003214       389 003265       391 003267
    395 003337       396 003344       397 003357       398 003373       400 003405       404 003406


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
