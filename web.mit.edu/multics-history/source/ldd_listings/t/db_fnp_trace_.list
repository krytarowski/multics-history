	COMPILATION LISTING OF SEGMENT db_fnp_trace_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1619.3 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* DB_FNP_TRACE_ - Implements db_fnp commands that deal with the trace table */
       12 /* Written 1977 by Larry Johnson */
       13 /* Modified August 1979 by Larry Johnson to make use of .crtsz and to improve command interface */
       14 
       15 db_fnp_trace_: proc;
       16 
       17 /* Parameters */
       18 
       19 dcl  arg_corep ptr;
       20 dcl  arg_fnp fixed bin;
       21 dcl  arg_cmd_infop ptr;
       22 dcl  arg_expr_infop ptr;
       23 
       24 /* Automatic */
       25 
       26 dcl  corep ptr;
       27 dcl  fnp fixed bin;
       28 dcl (i, j) fixed bin;
       29 dcl  code fixed bin (35);
       30 dcl  trace_mask bit (18) unal;			/* Current mask word */
       31 dcl  temp_name char (16);
       32 dcl  set bit (1);
       33 dcl  trace_sw (1) bit (18) unal;
       34 dcl  tcur fixed bin;
       35 dcl  mem_word (1) bit (18) unal;
       36 dcl (print_start, print_count) fixed bin;		/* Args on print trace */
       37 dcl  trace_message char (128) var;
       38 dcl  trace_req_msgp ptr init (null ());
       39 dcl  trace_req_msg_cnt fixed bin;
       40 dcl (start_given, count_given) bit (1);
       41 dcl  something_printed bit (1);
       42 
       43 dcl 1 modch aligned,				/* Module table required by format_fnp_trace_msg_ */
       44     2 nmodules fixed bin init (30),
       45     2 entries (30),
       46       3 name char (4),
       47       3 address fixed bin;
       48 
       49 /* Constants */
       50 
       51 dcl  mask_name (10) char (4) int static options (constant) init (
       52      "sked", "dia", "intp", "util", "lsla", "hsla", "cons", "trac", "init", "ptrc");
       53 dcl  name char (13) int static options (constant) init ("db_fnp_trace_");
       54 
       55 /* Static */
       56 
       57 dcl  symbols_looked_up bit (1) int static init ("0"b);
       58 dcl  crtra fixed bin int static;			/* Address of trace mask */
       59 dcl  crtsw fixed bin int static;			/* Global trace switch */
       60 dcl  crtrb fixed bin int static;			/* Base of trace table */
       61 dcl  crtrc fixed bin int static;			/* Current entry */
       62 dcl  crmem fixed bin int static;			/* Last word of memory */
       63 dcl  crtsz fixed bin int static;			/* Size of trace table */
       64 dcl  h1mb fixed bin int static;			/* Hsla 1 mailbox - used as lower bound on address checking */
       65 dcl  free_areap ptr int static;			/* Address of temp area */
       66 dcl  free_area area based (free_areap);
       67 
       68 /* Stuff associated with trace table */
       69 
       70 dcl  trace_tab_size fixed bin;			/* Its length */
       71 dcl  trace_tab_start fixed bin;			/* Starting memory addrress */
       72 dcl  trace_tab_current fixed bin;			/* Current entry */
       73 dcl  trace_tab_cnt fixed bin;				/* Number of entries */
       74 dcl  trace_tabp ptr init (null);			/* Address of table */
       75 dcl  trace_tab (trace_tab_size) bit (18) unal based (trace_tabp);
       76 
       77 /* Format of a trace message entry */
       78 
       79 dcl  tmsgp ptr;
       80 dcl 1 tmsg unal based (tmsgp),
       81     2 module bit (6) unal,				/* Module logging message */
       82     2 type bit (6) unal,				/* Message number */
       83     2 length bit (6) unal,				/* Number of data words */
       84     2 time bit (18) unal,
       85     2 data (1) bit (18) unal;				/* Array of tmsg.length words */
       86 dcl  flag_word bit (18) unal based (tmsgp);		/* For checking sentinels */
       87 dcl  logical_end bit (18) int static options (constant) init ("525252"b3);
       88 dcl  physical_end bit (18) int static options (constant) init ("525250"b3);
       89 
       90 /* Based */
       91 
       92 dcl  trace_req_msg (10) char (32) var based (trace_req_msgp);
       93 
       94 /* External */
       95 
       96 dcl  db_fnp_memory_$fetch entry (ptr, fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
       97 dcl  db_fnp_memory_$store entry (ptr, fixed bin, fixed bin, fixed bin, ptr, char (*), fixed bin, fixed bin (35));
       98 dcl  db_fnp_sym_util_$get_value entry (char (*)) returns (fixed bin);
       99 dcl  db_fnp_reader_$get_operand entry (ptr);
      100 dcl  db_fnp_eval_ entry (ptr, fixed bin, char (*), ptr, char (*), fixed bin, fixed bin (35));
      101 dcl  db_fnp_util_$get_special_modch entry (ptr, fixed bin, ptr, fixed bin (35));
      102 dcl  format_fnp_trace_msg_ entry (ptr, ptr, char (*) var);
      103 dcl (ioa_, ioa_$nnl) entry options (variable);
      104 dcl  com_err_ entry options (variable);
      105 dcl  get_system_free_area_ entry returns (ptr);
      106 
      107 dcl  cleanup condition;
      108 
      109 dcl (addr, bin, hbound, length, max, min, null, substr, unspec) builtin;
      110 
      111 /* Entry to print the trace table */
      112 
      113 print_trace: entry (arg_corep, arg_fnp, arg_cmd_infop, arg_expr_infop);
      114 
      115 	call init;
      116 
      117 	on cleanup call clean_up;
      118 
      119 	if corep = null then do;			/* Be sure tracing is disabled for running fnp */
      120 	     call fetch (crtsw, 1, addr (trace_sw (1)));
      121 	     if trace_sw (1) = "0"b then do;
      122 		call ioa_ ("Tracing not disabled. Use stop_trace first.");
      123 		go to error_return;
      124 	     end;
      125 	end;
      126 
      127 	print_start = 1;
      128 	print_count = -1;
      129 	start_given, count_given = "0"b;
      130 
      131 	call get_operand;
      132 	do while (^cmd_info.endline);
      133 	     if substr (operand, 1, 1) = "/" then do;	/* scan string */
      134 		if trace_req_msgp = null () then do;
      135 		     allocate trace_req_msg in (free_area);
      136 		     trace_req_msg_cnt = 0;
      137 		end;
      138 		if trace_req_msg_cnt = hbound (trace_req_msg, 1) then do;
      139 		     call ioa_ ("Too many strings requested.");
      140 		     go to error_return;
      141 		end;
      142 		trace_req_msg_cnt = trace_req_msg_cnt + 1;
      143 		i = length (operand) - 1;
      144 		if substr (operand, length (operand), 1) = "/" then i = i - 1;
      145 		trace_req_msg (trace_req_msg_cnt) = substr (operand, 2, i);
      146 	     end;
      147 	     else if ^start_given then do;
      148 		call db_fnp_eval_ (corep, fnp, operand, expr_infop, "", print_start, code);
      149 		if code ^= 0 then go to error_return;
      150 		start_given = "1"b;
      151 	     end;
      152 	     else if ^count_given then do;
      153 		call db_fnp_eval_ (corep, fnp, operand, expr_infop, "", print_count, code);
      154 		if code ^= 0 then go to error_return;
      155 		count_given = "1"b;
      156 	     end;
      157 	     else do;
      158 		call ioa_ ("Unrecognized operand: ^a", operand);
      159 		go to error_return;
      160 	     end;
      161 	     call get_operand;
      162 	end;
      163 
      164 	call db_fnp_util_$get_special_modch (corep, fnp, addr (modch), code);
      165 	if code ^= 0 then modch.nmodules = 0;
      166 
      167 	call capture_trace;				/* Find trace table */
      168 	if print_start < 0 then print_start = trace_tab_cnt + print_start + 1; /* Measuring from end */
      169 	print_start = max (1, print_start);
      170 	if print_start > trace_tab_cnt then do;
      171 	     call ioa_ ("Trace table contains only ^d entries.", trace_tab_cnt);
      172 	     go to error_return;
      173 	end;
      174 
      175 	i = 1;
      176 	tcur = trace_tab_current;
      177 	tmsgp = addr (trace_tab (tcur - trace_tab_start + 1));
      178 	do while (i < print_start);			/* Loop past unneeded entries at start */
      179 	     if flag_word = physical_end then tcur = trace_tab_start;
      180 	     else do;
      181 		i = i + 1;
      182 		tcur = tcur + bin (tmsg.length) + 2;
      183 	     end;
      184 	     tmsgp = addr (trace_tab (tcur - trace_tab_start + 1));
      185 	end;
      186 
      187 	i = 0;
      188 	something_printed = "0"b;
      189 	do while (i ^= print_count);			/* Loop till enough printed */
      190 	     if flag_word = logical_end then go to print_trace_end;
      191 	     else if flag_word = physical_end then tcur = trace_tab_start;
      192 	     else do;
      193 		call format_fnp_trace_msg_ (tmsgp, addr (modch), trace_message);
      194 		if trace_req_msgp ^= null () then do;	/* strings requested */
      195 		     do j = 1 to trace_req_msg_cnt;
      196 			if index (trace_message, trace_req_msg (j)) > 0 then
      197 			     go to print_it;
      198 		     end;
      199 		     go to skip_it;
      200 		end;
      201 print_it:		call ioa_ ("^a", trace_message);
      202 		something_printed = "1"b;
      203 skip_it:		i = i + 1;
      204 		tcur = tcur + bin (tmsg.length) + 2;
      205 	     end;
      206 	     tmsgp = addr (trace_tab (tcur - trace_tab_start + 1));
      207 	end;
      208 
      209 print_trace_end:
      210 	if trace_req_msgp ^= null & ^something_printed then do;
      211 	     call ioa_ ("No trace messages match request.");
      212 	     go to error_return;
      213 	end;
      214 
      215 	call clean_up;
      216 	return;
      217 
      218 /* Entry to set and/or print the trace mask */
      219 
      220 mask:	entry (arg_corep, arg_fnp, arg_cmd_infop, arg_expr_infop);
      221 
      222 	call init;
      223 	call fetch (crtra, 1, addr (trace_mask));	/* Read current mask */
      224 	call get_operand;				/* Get first openard */
      225 	if cmd_info.endline then do;			/* No operands, print mask */
      226 	     call ioa_$nnl ("Trace mask is ^.3b:", trace_mask);
      227 	     do i = 1 to hbound (mask_name, 1);
      228 		if substr (trace_mask, i, 1) then call ioa_$nnl (" ^a", mask_name (i));
      229 	     end;
      230 	     call ioa_ ("");
      231 	     return;
      232 	end;
      233 
      234 	do while (^cmd_info.endline);			/* Parse operands for new mask */
      235 	     if substr (operand, 1, 1) = "+" then do;	/* Must set bit */
      236 		set = "1"b;
      237 		temp_name = substr (operand, 2);
      238 	     end;
      239 	     else if substr (operand, 1, 1) = "^" | substr (operand, 1, 1) = "-" then do; /* Reset */
      240 		set = "0"b;
      241 		temp_name = substr (operand, 2);
      242 	     end;
      243 	     else do;				/* Default is to set */
      244 		set = "1"b;
      245 		temp_name = operand;
      246 	     end;
      247 	     if temp_name = "all" then do;
      248 		if set then trace_mask = "777777"b3;
      249 		else trace_mask = "0"b;
      250 		go to next_trace_name;
      251 	     end;
      252 	     else if temp_name = "none" then do;
      253 		if set then trace_mask = "0"b;
      254 		else trace_mask = "777777"b3;
      255 		go to next_trace_name;
      256 	     end;
      257 	     else do i = 1 to hbound (mask_name, 1);	/* Look op name */
      258 		if mask_name (i) = temp_name then do;	/* Got it */
      259 		     substr (trace_mask, i, 1) = set;
      260 		     go to next_trace_name;
      261 		end;
      262 	     end;
      263 	     call ioa_ ("Invalid trace mask name: ^a", temp_name);
      264 	     go to error_return;
      265 next_trace_name:
      266 	     call get_operand;
      267 	end;
      268 	call store (crtra, 1, addr (trace_mask));	/* Store result */
      269 	return;
      270 
      271 /* Entries to turn tracing on and off */
      272 
      273 start_trace: entry (arg_corep, arg_fnp, arg_cmd_infop, arg_expr_infop);
      274 
      275 	trace_sw (1) = "0"b;
      276 start_or_stop_trace:
      277 	call init;
      278 	call store (crtsw, 1, addr (trace_sw (1)));
      279 	return;
      280 
      281 stop_trace: entry (arg_corep, arg_fnp, arg_cmd_infop, arg_expr_infop);
      282 
      283 	trace_sw (1) = "000001"b3;
      284 	go to start_or_stop_trace;
      285 
      286 /* Initializatioon */
      287 
      288 init:	proc;
      289 
      290 	     corep = arg_corep;
      291 	     fnp = arg_fnp;
      292 	     cmd_infop = arg_cmd_infop;
      293 	     expr_infop = arg_expr_infop;
      294 	     if symbols_looked_up then return;
      295 	     crtra = db_fnp_sym_util_$get_value (".crtra");
      296 	     crtsw = db_fnp_sym_util_$get_value (".crtsw");
      297 	     crtrb = db_fnp_sym_util_$get_value (".crtrb");
      298 	     crtrc = db_fnp_sym_util_$get_value (".crtrc");
      299 	     crmem = db_fnp_sym_util_$get_value (".crmem");
      300 	     crtsz = db_fnp_sym_util_$get_value (".crtsz");
      301 	     h1mb = db_fnp_sym_util_$get_value ("h1mb");
      302 	     free_areap = get_system_free_area_ ();
      303 	     symbols_looked_up = "1"b;
      304 	     return;
      305 
      306 	end init;
      307 
      308 /* Read and write memory words */
      309 
      310 fetch:	proc (a, n, p);
      311 
      312 dcl  a fixed bin;
      313 dcl  n fixed bin;
      314 dcl  p ptr;
      315 
      316 	     call db_fnp_memory_$fetch (corep, fnp, a, n, p, code);
      317 	     if code = 0 then return;
      318 	     if n = 1 then call com_err_ (code, name, "Unable to read location ^o.", a);
      319 	     else call com_err_ (code, name, "Unable to read locations ^o thru ^o", a, a+n-1);
      320 	     go to error_return;
      321 
      322 store:	     entry (a, n, p);
      323 
      324 	     call db_fnp_memory_$store (corep, fnp, a, n, p, name, 0, code);
      325 	     if code = 0 then return;
      326 	     if n = 1 then call com_err_ (code, name, "Unable to write location ^o.", a);
      327 	     else call com_err_ (code, name, "Unable to write locations ^o thru ^o", a, a+n-1);
      328 	     go to error_return;
      329 
      330 	end fetch;
      331 
      332 /* Get next operand from command line */
      333 
      334 get_operand: proc;
      335 
      336 	     call db_fnp_reader_$get_operand (cmd_infop);
      337 	     if cmd_info.error then go to error_return;
      338 	     return;
      339 
      340 	end get_operand;
      341 
      342 error_return:
      343 	cmd_info.flush = "1"b;
      344 	call clean_up;
      345 	return;
      346 
      347 clean_up:	proc;
      348 
      349 	     if trace_tabp ^= null () then free trace_tab;
      350 	     if trace_req_msgp ^= null () then free trace_req_msg;
      351 	     return;
      352 
      353 	end clean_up;
      354 
      355 /* Procedure to "capture" the trace table */
      356 
      357 capture_trace: proc;
      358 
      359 dcl  offset fixed bin;				/* Offset to current section */
      360 dcl  p ptr;
      361 dcl  mem_size fixed bin;
      362 
      363 	     call fetch (crtrb, 1, addr (mem_word));	/* Read start address */
      364 	     trace_tab_start = bin (mem_word (1));
      365 	     if trace_tab_start = 0 then do;
      366 		call ioa_ ("No trace table.");
      367 		go to error_return;
      368 	     end;
      369 	     call fetch (crtrc, 1, addr (mem_word));	/* Read current pointer */
      370 	     trace_tab_current = bin (mem_word (1));
      371 	     tcur = trace_tab_current;
      372 	     call fetch (crmem, 1, addr (mem_word));
      373 	     mem_size = bin (mem_word (1));
      374 
      375 	     if (trace_tab_start < h1mb) |		/* Gullability checks on pointers */
      376 	     (trace_tab_start > mem_size) |
      377 	     (trace_tab_current < h1mb) |
      378 	     (trace_tab_current > mem_size) |
      379 	     (trace_tab_current < trace_tab_start) then do;
      380 bad_pointers:	call ioa_ ("Unable to capture trace buffers: pointers inconsistent.");
      381 		go to error_return;
      382 	     end;
      383 
      384 	     call fetch (crtsz, 1, addr (mem_word));	/* Read trace size */
      385 	     if mem_word (1) = "0"b then do;
      386 
      387 /* The following code is for pre-MR8 systems where trace size is not known */
      388 
      389 		offset = 0;
      390 		trace_tab_size = 1024;		/* Read first 1024 words */
      391 		allocate trace_tab in (free_area);
      392 fetch_more:	call fetch (trace_tab_start+offset, 1024, addr (trace_tab (offset+1))); /* Read next 1024 words */
      393 		if (trace_tab_current - trace_tab_start) >= trace_tab_size then do;
      394 						/* Dont have section with current entry yet */
      395 capture_more:					/* So must grow table */
      396 		     trace_tab_size = trace_tab_size+1024;
      397 		     allocate trace_tab in (free_area) set (p); /* Allocate bigger one */
      398 		     trace_tab_size = trace_tab_size - 1024 ; /* Revert to smaller size temporarily */
      399 		     unspec (p -> trace_tab) = unspec (trace_tab); /* Copy to new area */
      400 		     free trace_tab;
      401 		     trace_tab_size = trace_tab_size + 1024;
      402 		     trace_tabp = p;		/* New space ready */
      403 		     offset = offset+1024;
      404 		     go to fetch_more;		/* Go read next section */
      405 		end;
      406 check_next_entry:
      407 		tmsgp = addr (trace_tab (tcur - trace_tab_start + 1));
      408 		if flag_word = physical_end | flag_word = logical_end then go to count_trace_entries; /* Whole table found */
      409 		tcur = tcur + bin (tmsg.length) + 2;	/* Address of next one */
      410 		if tcur >= trace_tab_start + trace_tab_size then go to capture_more; /* Havent read necessary part yet */
      411 		else go to check_next_entry;
      412 	     end;
      413 
      414 /* The following code is MR8 and later systems where trace table size is known */
      415 
      416 	     else do;
      417 		trace_tab_size = bin (mem_word (1));
      418 		if trace_tab_current > trace_tab_start + trace_tab_size then
      419 		     go to bad_pointers;
      420 		allocate trace_tab in (free_area);
      421 		do offset = 0 to trace_tab_size - 1 by 1024;
      422 		     call fetch (trace_tab_start + offset, min (1024, trace_tab_size - offset), addr (trace_tab (offset + 1)));
      423 		end;
      424 	     end;
      425 
      426 /* Now analyze captured trace */
      427 
      428 count_trace_entries:
      429 	     trace_tab_cnt = 0;
      430 	     tcur = trace_tab_current;
      431 	     tmsgp = addr (trace_tab (tcur - trace_tab_start + 1));
      432 	     do while (flag_word ^= logical_end);	/* Loop to count entries */
      433 		if flag_word = physical_end then tcur = trace_tab_start;
      434 		else do;
      435 		     tcur = tcur + bin (tmsg.length) + 2;
      436 		     trace_tab_cnt = trace_tab_cnt + 1;
      437 		end;
      438 		tmsgp = addr (trace_tab (tcur - trace_tab_start + 1));
      439 	     end;
      440 
      441 	     return;
      442 
      443 	end capture_trace;
      444 
  1     1 /* Begin include file ..... debug_fnp_data.incl.pl1 */
  1     2 
  1     3 /* Describes various structures used by the debug_fnp command */
  1     4 
  1     5 /* Written February 1977 by Larry Johnson */
  1     6 
  1     7 /* Structures describing a symbol table used by the debug_fnp command,
  1     8*   to find values for common FNP symbols. */
  1     9 
  1    10 dcl  db_fnp_symbols_$db_fnp_symbols_ ext;
  1    11 
  1    12 dcl  symbol_tablep ptr;
  1    13 
  1    14 dcl 1 symbol_table aligned based (symbol_tablep),
  1    15     2 cnt fixed bin,				/* Number of entries */
  1    16     2 maxcnt fixed bin,				/* Max count */
  1    17     2 entry (symbol_table.cnt) unal,
  1    18       3 one_symbol like sym unal;
  1    19 
  1    20 dcl  symp ptr;					/* Pointer to one symbol */
  1    21 
  1    22 dcl 1 sym unal based (symp),
  1    23     2 name char (6),
  1    24     2 value fixed bin (17),
  1    25     2 len fixed bin (17),				/* Number of words */
  1    26     2 reloc fixed bin (17),
  1    27     2 type fixed bin (17),
  1    28     2 flag_mem char (6),				/* If non blank, name of word in which this is a flag */
  1    29     2 explain bit (18),				/* Offset to explanation for symbol */
  1    30     2 pad bit (18);
  1    31 
  1    32 dcl  exptextp ptr;
  1    33 
  1    34 dcl 1 exptext aligned based (exptextp),			/* Symbol explanation entry */
  1    35     2 len fixed bin (8) unal,
  1    36     2 data char (exptext.len) unal;
  1    37 
  1    38 /* Values for sym.reloc, which is relocation required to find the symbol */
  1    39 
  1    40 dcl (reloc_abs init (0),				/* Value is absolute */
  1    41      reloc_tib init (1),				/* Value is relative to current tib addr */
  1    42      reloc_hwcm init (2),				/* Value is relative to current hwcm */
  1    43      reloc_sfcm init (3),				/* Value is relative to software comm region */
  1    44      reloc_meters init (4))				/* Value is relative to tib meters */
  1    45      int static options (constant);
  1    46 
  1    47 /* Values for sym.type, which is the mode to be used in displaying symbol */
  1    48 
  1    49 dcl (type_oct init (0),				/* Octal, default for most symbols */
  1    50      type_char init (1),				/* Ascii characters */
  1    51      type_addr init (2),				/* Address to be converted to mod|offset */
  1    52      type_clock init (3),				/* Multics clock value */
  1    53      type_inst init (4),				/* Machine instruction */
  1    54      type_op init (5),				/* Interpreter opblock format */
  1    55      type_dec init (6),				/* Decimal */
  1    56      type_bit init (7),				/* In bits */
  1    57      type_ebcdic init (8))				/* 8-bit ebcdic characters */
  1    58      int static options (constant);
  1    59 
  1    60 dcl  long_type_names (0:8) char (12) int static options (constant) init (
  1    61      "octal", "character", "address", "clock", "instruction", "opblock", "decimal", "bit", "ebcdic");
  1    62 dcl  short_type_names (0:8) char (4) int static options (constant) init (
  1    63      "oct", "ch", "addr", "ck", "inst", "op", "dec", "bit", "ebc");
  1    64 
  1    65 
  1    66 /* Structure of suplmental data used in evaluating expressions */
  1    67 
  1    68 dcl  expr_infop ptr;
  1    69 
  1    70 dcl 1 expr_info aligned based (expr_infop),
  1    71     2 flags,
  1    72       3 star_known bit (1) unal,			/* Value of "*" is known */
  1    73       3 tib_known bit (1) unal,			/* TIB addresses may be used */
  1    74       3 hwcm_known bit (1) unal,			/* HWCM address may be used */
  1    75       3 sfcm_known bit (1) unal,			/* SFCM address may be used */
  1    76       3 pad bit (32) unal,
  1    77     2 star_addr fixed bin,				/* Value of "*" */
  1    78     2 tib_addr fixed bin,				/* Address of TIB */
  1    79     2 hwcm_addr fixed bin,				/* Address of HWCM */
  1    80     2 sfcm_addr fixed bin,				/* Address of SFCM */
  1    81     2 type fixed bin,				/* Expression type (mode for printing) */
  1    82     2 len fixed bin,				/* Implied length of expression */
  1    83     2 user_tablep ptr;				/* Pointer to a user symbol table */
  1    84 
  1    85 
  1    86 /* Structure of opcode table of machine instructions */
  1    87 
  1    88 dcl  db_fnp_opcodes_$ ext;
  1    89 
  1    90 dcl  optablep ptr;
  1    91 
  1    92 dcl 1 optable aligned based (optablep),
  1    93     2 cnt fixed bin,
  1    94     2 entry (optable.cnt) unal,
  1    95       3 one_op like op;
  1    96 
  1    97 dcl  opp ptr;
  1    98 
  1    99 dcl 1 op unal based (opp),
  1   100     2 name char (6),				/* The mneumonic */
  1   101     2 code bit (12),				/* The  opcode */
  1   102     2 mask bit (12),				/* Mask that says where the opcode is */
  1   103     2 type fixed bin (11),				/* Type of display required */
  1   104     2 pad bit (18);
  1   105 
  1   106 /* Values for op.type are:
  1   107*   0 - storage reference
  1   108*   1 - non-storage reference (immediate),
  1   109*   2 - non-storage reference (iacxn only),
  1   110*   3 - non-storage reference (shifts),
  1   111*   4 - non-storage reference (no operands) */
  1   112 
  1   113 
  1   114 /* Stuctures used while parsing commands into operands */
  1   115 
  1   116 dcl  cmd_infop ptr;
  1   117 
  1   118 dcl 1 cmd_info aligned based (cmd_infop),
  1   119     2 inbuf char (256),				/* For reading lines */
  1   120     2 opbuf char (256),				/* Used for operand in undoubling quotes */
  1   121     2 commandp ptr,					/* Address of unparsed part of command */
  1   122     2 commandl fixed bin,				/* Length of unparsed part */
  1   123     2 operandp ptr,					/* Address of current operand */
  1   124     2 operandl fixed bin,				/* And its length */
  1   125     2 error bit (1),				/* Set if error parsing operand */
  1   126     2 endline bit (1),				/* Set if no more operands on line */
  1   127     2 opstring bit (1),				/* Set if operand was unquoted string */
  1   128     2 flush bit (1),				/* If set, rest of input line will be ignored */
  1   129     2 envp ptr;					/* Pointer to the debug_fnp environment structure */
  1   130 
  1   131 dcl  command char (cmd_info.commandl) based (cmd_info.commandp);
  1   132 dcl  operand char (cmd_info.operandl) based (cmd_info.operandp);
  1   133 
  1   134 /* The following structure describes the current debug_fnp environment. */
  1   135 /* It specifies whether we are working on a dump, fnp, core image, etc. */
  1   136 
  1   137 dcl  envp ptr;
  1   138 
  1   139 dcl 1 env aligned based (envp),
  1   140     2 corep ptr,					/* Ptr to current dump or core-image. Null means live FNP */
  1   141     2 fnp fixed bin,				/* Current fnp number */
  1   142     2 dump_dir char (168) unal,			/* Directory where dumps are found */
  1   143     2 dir char (168) unal,				/* Directory for current dump or core image */
  1   144     2 ename char (32) unal,				/* Ename for current dump or core image */
  1   145     2 tty_name char (32),				/* Name of current channel */
  1   146     2 segp ptr,					/* Pointer to base of current segment */
  1   147     2 flags unal,
  1   148       3 fnps_configured bit (8),			/* Says which FNP's appear in config deck */
  1   149       3 fnp_sw bit (1),				/* 1 if currently working on fnp */
  1   150       3 image_sw bit (1),				/* 1 if currently working on a core-image */
  1   151       3 dump_sw bit (1),				/* 1 if current working on a dump */
  1   152       3 fdump_sw bit (1),				/* 1 if current dump is a fdump */
  1   153       3 pad bit (24),
  1   154     2 dump_time fixed bin (71);			/* Clock time dump occured */
  1   155 
  1   156 /* Structure of data defining table of interpreter opblock names */
  1   157 
  1   158 dcl  db_fnp_opblocks_$ ext;
  1   159 
  1   160 dcl  opblock_tablep ptr;
  1   161 
  1   162 dcl 1 opblock_table aligned based (opblock_tablep),
  1   163     2 cnt fixed bin,
  1   164     2 name (0:opblock_table.cnt) char (6) unal;
  1   165 
  1   166 /* End include file ..... debug_fnp_data.incl.pl1 */
      445 
      446 
      447      end db_fnp_trace_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1502.2  db_fnp_trace_.pl1                 >dumps>old>recomp>db_fnp_trace_.pl1
445          1    06/19/81  2115.0  debug_fnp_data.incl.pl1           >ldd>include>debug_fnp_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                                      parameter       fixed bin(17,0)          dcl 312 set ref 310 316* 318* 319* 319 322 324* 326*
                                                                                  327* 327
addr                                                   builtin function         dcl 109 ref 120 120 164 164 177 184 193 193 206 223
                                                                                  223 268 268 278 278 363 363 369 369 372 372 384
                                                                                  384 392 392 406 422 422 431 438
arg_cmd_infop                          parameter       pointer                  dcl 21 ref 113 220 273 281 292
arg_corep                              parameter       pointer                  dcl 19 ref 113 220 273 281 290
arg_expr_infop                         parameter       pointer                  dcl 22 ref 113 220 273 281 293
arg_fnp                                parameter       fixed bin(17,0)          dcl 20 ref 113 220 273 281 291
bin                                                    builtin function         dcl 109 ref 182 204 364 370 373 409 417 435
cleanup                         000276 stack reference condition                dcl 107 ref 117
cmd_info                               based           structure                level 1 dcl 1-118
cmd_infop                       000306 automatic       pointer                  dcl 1-116 set ref 132 133 133 143 143 144 144 144
                                                                                  144 145 145 148 148 148 153 153 153 158 158 158
                                                                                  225 234 235 235 237 237 239 239 239 239 241 241
                                                                                  245 245 292* 336* 337 342
code                            000105 automatic       fixed bin(35,0)          dcl 29 set ref 148* 149 153* 154 164* 165 316* 317
                                                                                  318* 319* 324* 325 326* 327*
com_err_                        000044 constant        entry                    external dcl 104 ref 318 319 326 327
corep                           000100 automatic       pointer                  dcl 26 set ref 119 148* 153* 164* 290* 316* 324*
count_given                     000166 automatic       bit(1)                   unaligned dcl 40 set ref 129* 152 155*
crmem                           000015 internal static fixed bin(17,0)          dcl 62 set ref 299* 372*
crtra                           000011 internal static fixed bin(17,0)          dcl 58 set ref 223* 268* 295*
crtrb                           000013 internal static fixed bin(17,0)          dcl 60 set ref 297* 363*
crtrc                           000014 internal static fixed bin(17,0)          dcl 61 set ref 298* 369*
crtsw                           000012 internal static fixed bin(17,0)          dcl 59 set ref 120* 278* 296*
crtsz                           000016 internal static fixed bin(17,0)          dcl 63 set ref 300* 384*
db_fnp_eval_                    000032 constant        entry                    external dcl 100 ref 148 153
db_fnp_memory_$fetch            000022 constant        entry                    external dcl 96 ref 316
db_fnp_memory_$store            000024 constant        entry                    external dcl 97 ref 324
db_fnp_reader_$get_operand      000030 constant        entry                    external dcl 99 ref 336
db_fnp_sym_util_$get_value      000026 constant        entry                    external dcl 98 ref 295 296 297 298 299 300 301
db_fnp_util_$get_special_modch  000034 constant        entry                    external dcl 101 ref 164
endline                 210            based           bit(1)                   level 2 dcl 1-118 ref 132 225 234
error                   207            based           bit(1)                   level 2 dcl 1-118 ref 337
expr_infop                      000304 automatic       pointer                  dcl 1-68 set ref 148* 153* 293*
flag_word                              based           bit(18)                  unaligned dcl 86 ref 179 190 191 408 408 432 433
flush                   212            based           bit(1)                   level 2 dcl 1-118 set ref 342*
fnp                             000102 automatic       fixed bin(17,0)          dcl 27 set ref 148* 153* 164* 291* 316* 324*
format_fnp_trace_msg_           000036 constant        entry                    external dcl 102 ref 193
free_area                              based           area(1024)               dcl 66 ref 135 391 397 420
free_areap                      000020 internal static pointer                  dcl 65 set ref 135 302* 391 397 420
get_system_free_area_           000046 constant        entry                    external dcl 105 ref 302
h1mb                            000017 internal static fixed bin(17,0)          dcl 64 set ref 301* 375 375
hbound                                                 builtin function         dcl 109 ref 138 227 257
i                               000103 automatic       fixed bin(17,0)          dcl 28 set ref 143* 144* 144 145 175* 178 181* 181
                                                                                  187* 189 203* 203 227* 228 228* 257* 258 259*
ioa_                            000040 constant        entry                    external dcl 103 ref 122 139 158 171 201 211 230 263
                                                                                  366 380
ioa_$nnl                        000042 constant        entry                    external dcl 103 ref 226 228
j                               000104 automatic       fixed bin(17,0)          dcl 28 set ref 195* 196*
length                                                 builtin function         dcl 109 in procedure "db_fnp_trace_" ref 143 144
length                    0(12)        based           bit(6)                   level 2 in structure "tmsg" packed unaligned dcl 80
                                                                                  in procedure "db_fnp_trace_" ref 182 204 409 435
logical_end                     002737 constant        bit(18)                  initial unaligned dcl 87 ref 190 408 432
mask_name                       000004 constant        char(4)                  initial array unaligned dcl 51 set ref 227 228* 257
                                                                                  258
max                                                    builtin function         dcl 109 ref 169
mem_size                        000346 automatic       fixed bin(17,0)          dcl 361 set ref 373* 375 375
mem_word                        000116 automatic       bit(18)                  array unaligned dcl 35 set ref 363 363 364 369 369
                                                                                  370 372 372 373 384 384 385 417
min                                                    builtin function         dcl 109 ref 422 422
modch                           000170 automatic       structure                level 1 dcl 43 set ref 164 164 193 193
n                                      parameter       fixed bin(17,0)          dcl 313 set ref 310 316* 318 319 322 324* 326 327
name                            000000 constant        char(13)                 initial unaligned dcl 53 set ref 318* 319* 324* 326*
                                                                                  327*
nmodules                        000170 automatic       fixed bin(17,0)          initial level 2 dcl 43 set ref 43* 165*
null                                                   builtin function         dcl 109 ref 38 74 119 134 194 209 349 350
offset                          000342 automatic       fixed bin(17,0)          dcl 359 set ref 389* 392 392 392 403* 403 421* 422
                                                                                  422 422 422 422*
op                                     based           structure                level 1 packed unaligned dcl 1-99
operand                                based           char                     unaligned dcl 1-132 set ref 133 143 144 144 145 148*
                                                                                  153* 158* 235 237 239 239 241 245
operandl                206            based           fixed bin(17,0)          level 2 dcl 1-118 ref 133 143 144 144 145 148 148
                                                                                  153 153 158 158 235 237 239 239 241 245
operandp                204            based           pointer                  level 2 dcl 1-118 ref 133 143 144 144 145 148 153
                                                                                  158 235 237 239 239 241 245
p                                      parameter       pointer                  dcl 314 in procedure "fetch" set ref 310 316* 322
                                                                                  324*
p                               000344 automatic       pointer                  dcl 360 in procedure "capture_trace" set ref 397*
                                                                                  399 402
physical_end                    002736 constant        bit(18)                  initial unaligned dcl 88 ref 179 191 408 433
print_count                     000120 automatic       fixed bin(17,0)          dcl 36 set ref 128* 153* 189
print_start                     000117 automatic       fixed bin(17,0)          dcl 36 set ref 127* 148* 168 168* 168 169* 169 170
                                                                                  178
set                             000113 automatic       bit(1)                   unaligned dcl 32 set ref 236* 240* 244* 248 253 259
something_printed               000167 automatic       bit(1)                   unaligned dcl 41 set ref 188* 202* 209
start_given                     000165 automatic       bit(1)                   unaligned dcl 40 set ref 129* 147 150*
substr                                                 builtin function         dcl 109 set ref 133 144 145 228 235 237 239 239 241
                                                                                  259*
sym                                    based           structure                level 1 packed unaligned dcl 1-22
symbols_looked_up               000010 internal static bit(1)                   initial unaligned dcl 57 set ref 294 303*
tcur                            000115 automatic       fixed bin(17,0)          dcl 34 set ref 176* 177 179* 182* 182 184 191* 204*
                                                                                  204 206 371* 406 409* 409 410 430* 431 433* 435*
                                                                                  435 438
temp_name                       000107 automatic       char(16)                 unaligned dcl 31 set ref 237* 241* 245* 247 252 258
                                                                                  263*
tmsg                                   based           structure                level 1 packed unaligned dcl 80
tmsgp                           000274 automatic       pointer                  dcl 79 set ref 177* 179 182 184* 190 191 193* 204
                                                                                  206* 406* 408 408 409 431* 432 433 435 438*
trace_mask                      000106 automatic       bit(18)                  unaligned dcl 30 set ref 223 223 226* 228 248* 249*
                                                                                  253* 254* 259* 268 268
trace_message                   000121 automatic       varying char(128)        dcl 37 set ref 193* 196 201*
trace_req_msg                          based           varying char(32)         array dcl 92 set ref 135 138 145* 196 350
trace_req_msg_cnt               000164 automatic       fixed bin(17,0)          dcl 39 set ref 136* 138 142* 142 145 195
trace_req_msgp                  000162 automatic       pointer                  initial dcl 38 set ref 38* 134 135* 138 145 194 196
                                                                                  209 350 350
trace_sw                        000114 automatic       bit(18)                  array unaligned dcl 33 set ref 120 120 121 275* 278
                                                                                  278 283*
trace_tab                              based           bit(18)                  array unaligned dcl 75 set ref 177 184 206 349 391
                                                                                  392 392 397 399* 399 400 406 420 422 422 431 438
trace_tab_cnt                   000270 automatic       fixed bin(17,0)          dcl 73 set ref 168 170 171* 428* 436* 436
trace_tab_current               000267 automatic       fixed bin(17,0)          dcl 72 set ref 176 370* 371 375 375 375 393 418 430
trace_tab_size                  000265 automatic       fixed bin(17,0)          dcl 70 set ref 349 390* 391 393 395* 395 397 398*
                                                                                  398 399 399 400 401* 401 410 417* 418 420 421 422
                                                                                  422
trace_tab_start                 000266 automatic       fixed bin(17,0)          dcl 71 set ref 177 179 184 191 206 364* 365 375 375
                                                                                  375 392 393 406 410 418 422 431 433 438
trace_tabp                      000272 automatic       pointer                  initial dcl 74 set ref 74* 177 184 206 349 349 391*
                                                                                  392 392 399 400 402* 406 420* 422 422 431 438
unspec                                                 builtin function         dcl 109 set ref 399* 399

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
command                                based           char                     unaligned dcl 1-131
db_fnp_opblocks_$                      external static fixed bin(17,0)          dcl 1-158
db_fnp_opcodes_$                       external static fixed bin(17,0)          dcl 1-88
db_fnp_symbols_$db_fnp_symbols_        external static fixed bin(17,0)          dcl 1-10
env                                    based           structure                level 1 dcl 1-139
envp                                   automatic       pointer                  dcl 1-137
expr_info                              based           structure                level 1 dcl 1-70
exptext                                based           structure                level 1 dcl 1-34
exptextp                               automatic       pointer                  dcl 1-32
long_type_names                        internal static char(12)                 initial array unaligned dcl 1-60
opblock_table                          based           structure                level 1 dcl 1-162
opblock_tablep                         automatic       pointer                  dcl 1-160
opp                                    automatic       pointer                  dcl 1-97
optable                                based           structure                level 1 dcl 1-92
optablep                               automatic       pointer                  dcl 1-90
reloc_abs                              internal static fixed bin(17,0)          initial dcl 1-40
reloc_hwcm                             internal static fixed bin(17,0)          initial dcl 1-40
reloc_meters                           internal static fixed bin(17,0)          initial dcl 1-40
reloc_sfcm                             internal static fixed bin(17,0)          initial dcl 1-40
reloc_tib                              internal static fixed bin(17,0)          initial dcl 1-40
short_type_names                       internal static char(4)                  initial array unaligned dcl 1-62
symbol_table                           based           structure                level 1 dcl 1-14
symbol_tablep                          automatic       pointer                  dcl 1-12
symp                                   automatic       pointer                  dcl 1-20
type_addr                              internal static fixed bin(17,0)          initial dcl 1-49
type_bit                               internal static fixed bin(17,0)          initial dcl 1-49
type_char                              internal static fixed bin(17,0)          initial dcl 1-49
type_clock                             internal static fixed bin(17,0)          initial dcl 1-49
type_dec                               internal static fixed bin(17,0)          initial dcl 1-49
type_ebcdic                            internal static fixed bin(17,0)          initial dcl 1-49
type_inst                              internal static fixed bin(17,0)          initial dcl 1-49
type_oct                               internal static fixed bin(17,0)          initial dcl 1-49
type_op                                internal static fixed bin(17,0)          initial dcl 1-49

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_pointers                    002417 constant        label                    dcl 380 ref 418
capture_more                    002512 constant        label                    dcl 395 ref 410
capture_trace                   002272 constant        entry                    internal dcl 357 ref 167
check_next_entry                002547 constant        label                    dcl 406 ref 411
clean_up                        002242 constant        entry                    internal dcl 347 ref 117 215 344
count_trace_entries             002651 constant        label                    dcl 428 ref 408
db_fnp_trace_                   000256 constant        entry                    external dcl 15
error_return                    001520 constant        label                    dcl 342 ref 123 140 149 154 159 172 212 264 320 328
                                                                                  337 367 381
fetch                           001734 constant        entry                    internal dcl 310 ref 120 223 363 369 372 384 392 422
fetch_more                      002472 constant        label                    dcl 392 ref 404
get_operand                     002225 constant        entry                    internal dcl 334 ref 131 161 224 265
init                            001530 constant        entry                    internal dcl 288 ref 115 222 276
mask                            001153 constant        entry                    external dcl 220
next_trace_name                 001430 constant        label                    dcl 265 ref 250 255 260
print_it                        001060 constant        label                    dcl 201 ref 196
print_trace                     000272 constant        entry                    external dcl 113
print_trace_end                 001121 constant        label                    dcl 209 ref 190
skip_it                         001101 constant        label                    dcl 203 ref 199
start_or_stop_trace             001464 constant        label                    dcl 276 ref 284
start_trace                     001454 constant        entry                    external dcl 273
stop_trace                      001507 constant        entry                    external dcl 281
store                           002060 constant        entry                    internal dcl 322 ref 268 278

NAME DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 196

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3160        3230    2741        3170
Length      3472    2741        50         225     217          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_fnp_trace_                       429 external procedure  is an external procedure.  
on unit on line 117                  64 on unit               
init                                    internal procedure  shares stack frame of external procedure db_fnp_trace_.  
fetch                                   internal procedure  shares stack frame of external procedure db_fnp_trace_.  
get_operand                             internal procedure  shares stack frame of external procedure db_fnp_trace_.  
clean_up                             64 internal procedure  is called by several nonquick procedures.  
capture_trace                           internal procedure  shares stack frame of external procedure db_fnp_trace_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 symbols_looked_up           db_fnp_trace_
000011 crtra                       db_fnp_trace_
000012 crtsw                       db_fnp_trace_
000013 crtrb                       db_fnp_trace_
000014 crtrc                       db_fnp_trace_
000015 crmem                       db_fnp_trace_
000016 crtsz                       db_fnp_trace_
000017 h1mb                        db_fnp_trace_
000020 free_areap                  db_fnp_trace_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_fnp_trace_            000100 corep                       db_fnp_trace_
                         000102 fnp                         db_fnp_trace_
                         000103 i                           db_fnp_trace_
                         000104 j                           db_fnp_trace_
                         000105 code                        db_fnp_trace_
                         000106 trace_mask                  db_fnp_trace_
                         000107 temp_name                   db_fnp_trace_
                         000113 set                         db_fnp_trace_
                         000114 trace_sw                    db_fnp_trace_
                         000115 tcur                        db_fnp_trace_
                         000116 mem_word                    db_fnp_trace_
                         000117 print_start                 db_fnp_trace_
                         000120 print_count                 db_fnp_trace_
                         000121 trace_message               db_fnp_trace_
                         000162 trace_req_msgp              db_fnp_trace_
                         000164 trace_req_msg_cnt           db_fnp_trace_
                         000165 start_given                 db_fnp_trace_
                         000166 count_given                 db_fnp_trace_
                         000167 something_printed           db_fnp_trace_
                         000170 modch                       db_fnp_trace_
                         000265 trace_tab_size              db_fnp_trace_
                         000266 trace_tab_start             db_fnp_trace_
                         000267 trace_tab_current           db_fnp_trace_
                         000270 trace_tab_cnt               db_fnp_trace_
                         000272 trace_tabp                  db_fnp_trace_
                         000274 tmsgp                       db_fnp_trace_
                         000304 expr_infop                  db_fnp_trace_
                         000306 cmd_infop                   db_fnp_trace_
                         000342 offset                      capture_trace
                         000344 p                           capture_trace
                         000346 mem_size                    capture_trace

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           set_cs_eis          index_cs_eis        alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      db_fnp_eval_                  db_fnp_memory_$fetch          db_fnp_memory_$store
db_fnp_reader_$get_operand    db_fnp_sym_util_$get_value    db_fnp_util_$get_special_modch
format_fnp_trace_msg_         get_system_free_area_         ioa_                          ioa_$nnl

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 000245        43 000247        74 000251        15 000255       113 000264       115 000300       117 000301
    119 000323       120 000327       121 000346       122 000351       123 000365       127 000366       128 000370
    129 000372       131 000374       132 000375       133 000400       134 000405       135 000411       136 000417
    138 000420       139 000423       140 000437       142 000440       143 000441       144 000445       145 000455
    146 000472       147 000473       148 000475       149 000537       150 000541       151 000543       152 000544
    153 000546       154 000610       155 000612       156 000614       158 000615       159 000640       161 000641
    162 000642       164 000643       165 000662       167 000665       168 000666       169 000673       170 000677
    171 000701       172 000721       175 000722       176 000724       177 000726       178 000733       179 000736
    181 000746       182 000747       184 000757       185 000764       187 000765       188 000766       189 000767
    190 000772       191 000777       193 001006       194 001030       195 001034       196 001043       198 001055
    199 001057       201 001060       202 001077       203 001101       204 001102       206 001113       207 001120
    209 001121       211 001127       212 001143       215 001144       216 001150       220 001151       222 001161
    223 001162       224 001201       225 001202       226 001205       227 001230       228 001235       229 001260
    230 001262       231 001273       234 001274       235 001277       236 001306       237 001310       238 001315
    239 001316       240 001322       241 001323       242 001330       244 001331       245 001333       247 001337
    248 001343       249 001350       250 001352       252 001353       253 001357       254 001364       255 001366
    257 001367       258 001374       259 001401       260 001404       262 001405       263 001407       264 001427
    265 001430       267 001431       268 001432       269 001451       273 001452       275 001462       276 001464
    278 001465       279 001504       281 001505       283 001515       284 001517       342 001520       344 001523
    345 001527       288 001530       290 001531       291 001535       292 001537       293 001542       294 001545
    295 001551       296 001567       297 001606       298 001625       299 001644       300 001663       301 001702
    302 001721       303 001730       304 001733       310 001734       316 001736       317 001760       318 001763
    319 002020       320 002057       322 002060       324 002062       325 002125       326 002130       327 002165
    328 002224       334 002225       336 002226       337 002235       338 002240       347 002241       349 002247
    350 002262       351 002271       357 002272       363 002273       364 002312       365 002315       366 002317
    367 002334       369 002335       370 002354       371 002357       372 002360       373 002377       375 002402
    380 002417       381 002433       384 002434       385 002452       389 002456       390 002457       391 002461
    392 002472       393 002506       395 002512       397 002514       398 002525       399 002527       400 002535
    401 002541       402 002543       403 002545       404 002546       406 002547       408 002555       409 002565
    410 002575       411 002601       417 002602       418 002604       420 002607       421 002620       422 002627
    423 002646       428 002651       430 002652       431 002654       432 002661       433 002670       435 002675
    436 002705       438 002706       439 002713       441 002714


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
