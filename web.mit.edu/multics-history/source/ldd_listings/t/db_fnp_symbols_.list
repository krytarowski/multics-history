	COMPILATION LISTING OF SEGMENT !BBBJQNLGmxkCQZ
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/03/86  1010.6 mst Mon
	    Options: table map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* DB_FNP_SYMBOLS_ - Procedure to create a symbol table for debug_fnp */
       12 /* The table is constructed by scanning the macros.map355 source file */
       13 
       14 /* Written February 1978 by Larry Johnson to replace the old, canned symbol table */
       15 /* Modified by R Holmstedt 6/81 to use the new library path >ldd>mcs. */
       16 db_fnp_symbols_: proc;
       17 
       18 /* Automatic */
       19 
       20 dcl  segp ptr;					/* Pointer to entire macro segment */
       21 dcl  segl fixed bin;				/* Its length */
       22 dcl  restp ptr;					/* Pointer to unscanned (rest of) segment */
       23 dcl  restl fixed bin;				/* Its length */
       24 dcl  ptr_array (2) ptr;				/* For get_temp_segments_ */
       25 dcl  linep ptr;					/* Pointer to current line */
       26 dcl  linel fixed bin;				/* Its length */
       27 dcl  code fixed bin (35);
       28 dcl  bit_count fixed bin (24);
       29 dcl  dir char (168);
       30 dcl  lineno fixed bin init (0);			/* Current line number, for errors */
       31 dcl  end_of_line bit (1);
       32 dcl  reloc_type fixed bin;
       33 dcl  wordp ptr;
       34 dcl  wordl fixed bin;
       35 dcl  sym_offset fixed bin;
       36 dcl  label char (6);
       37 dcl  flag_type char (6);
       38 dcl  n_exp_words fixed bin init (0);			/* Number of words used in explanations */
       39 dcl  explain_seg_ptr ptr;
       40 
       41 dcl 1 cds like cds_args automatic;
       42 
       43 dcl 1 dummy_symbol_table aligned,			/* To define correct entry in object segment */
       44     2 db_fnp_symbols_ fixed bin;
       45 
       46 dcl  line char (linel) based (linep);
       47 dcl  rest char (restl) based (restp);
       48 dcl  word char (wordl) based (wordp);
       49 
       50 dcl 1 explain_seg aligned based (explain_seg_ptr),	/* Explanations are accumulated in this seg */
       51     2 unused bit (36),				/* Dummy word so offset will never be 0 */
       52     2 data (1) bit (36) aligned;
       53 
       54 /* Constants */
       55 
       56 dcl  white_space char (2) int static options (constant) init (" 	"); /* Space and tab */
       57 dcl  nl char (1) int static options (constant) init ("
       58 ");
       59 dcl  name char (16) int static options (constant) init ("db_fnp_symbols_");
       60 dcl  macro_name char (13) int static options (constant) init ("macros.map355");
       61 dcl  statement_name (9) char (16) int static options (constant) init (
       62      "symrel", "symlen", "symtype", "symdef", "symflag", "symdel", "synval", "symget", "symgetr");
       63 
       64 /* External stuff */
       65 
       66 dcl  ioa_ entry options (variable);
       67 dcl  ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1) aligned, bit (1) aligned);
       68 dcl  com_err_ entry options (variable);
       69 dcl  cu_$arg_list_ptr entry (ptr);
       70 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       71 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       72 dcl  get_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       73 dcl  release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       74 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       75 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       76 dcl  get_wdir_ entry returns (char (168));
       77 dcl  create_data_segment_ entry (ptr, fixed bin (35));
       78 
       79 dcl  error_table_$noentry ext fixed bin (35);
       80 
       81 dcl  cleanup condition;
       82 
       83 dcl (addr, addrel, bin, bit, divide, hbound, index, length, null, rel, search, size, string, substr, unspec, verify) builtin;
       84 
       85 /* Initialization */
       86 
       87 	ptr_array = null;
       88 	segp = null;
       89 	on cleanup call clean_up;
       90 
       91 	call get_temp_segments_ (name, ptr_array, code);
       92 	if code ^= 0 then do;
       93 	     call com_err_ (code, name, "Unable to get temp segment.");
       94 	     go to done;
       95 	end;
       96 	symbol_tablep = ptr_array (1);
       97 	explain_seg_ptr = ptr_array (2);
       98 	exptextp = addr (explain_seg.data);		/* Start data here */
       99 
      100 	call init_macro_seg;			/* This locates the macro segment */
      101 
      102 	call build_symbol_table;			/* And this does all the work */
      103 
      104 	call relocate_explanations;			/* Copy symbols explanations in */
      105 
      106 
      107 /* Now create the data segment */
      108 
      109 	cds.p (1) = symbol_tablep;
      110 	cds.len (1) = size (symbol_table) + n_exp_words;
      111 	dummy_symbol_table.db_fnp_symbols_ = 0;		/* Reference dummy table so compiler doesnt delete it */
      112 	cds.struct_name (1) = "dummy_symbol_table";
      113 	cds.p (2) = null;
      114 	cds.len (2) = 0;
      115 	cds.struct_name (2) = "";
      116 	cds.seg_name = name;
      117 	cds.num_exclude_names = 0;
      118 	cds.exclude_array_ptr = null;
      119 	string (cds.switches) = "0"b;
      120 	cds.have_text = "1"b;
      121 	call create_data_segment_ (addr (cds), code);
      122 	if code ^= 0 then call com_err_ (code, name, "From create_data_segment_");
      123 
      124 done:	call clean_up;
      125 	return;
      126 
      127 /* Procedure  to scan the macro file and build the symbol table */
      128 
      129 build_symbol_table: proc;
      130 
      131 dcl  i fixed bin;
      132 dcl  opname char (16);
      133 dcl  r_sw bit (1);					/* Set for symgetr */
      134 dcl  start_cnt fixed bin;
      135 dcl  start_sym char (6);
      136 dcl  end_sym char (6);
      137 dcl  start_lineno fixed bin;
      138 dcl  save_restp ptr;
      139 dcl  save_restl fixed bin;
      140 
      141 read_line:
      142 	     call get_line;
      143 	     if linep = null then do;			/* End of segment */
      144 		if symbol_table.cnt = 0 then do;
      145 		     call com_err_ (0, name, "No symbols defined.");
      146 		     go to done;
      147 		end;
      148 		else return;
      149 	     end;
      150 	     if length (line) <= 6 then go to read_line;	/* Very short lines not interesting */
      151 	     if substr (line, 1, 6) ^= "*++sym" then go to read_line; /* Not a line of importance */
      152 	     call adv_line (3);			/* Skip over *++ */
      153 	     i = search (line, white_space);		/* Find end of keyword */
      154 	     if i = 0 then i = length (line);
      155 	     else i = i-1;
      156 	     opname = substr (line, 1, i);
      157 	     call adv_line (i);			/* Skip over keyword */
      158 	     call skip_white_space;			/* And white space after it */
      159 	     do i = 1 to hbound (statement_name, 1);
      160 		if statement_name (i) = opname then go to statement_type (i);
      161 	     end;
      162 	     call com_err_ (0, name, "Invalid *++^a statement on line ^d.", opname, lineno);
      163 	     go to done;
      164 
      165 statement_type (1):					/* *++ symrel */
      166 	     if end_of_line then go to no_operand;	/* Need operands */
      167 	     do while (^end_of_line);
      168 		call get_symword;
      169 		call get_word;
      170 		call check_reloc;			/* Be sure this is valid relocation keyword */
      171 		sym.reloc = reloc_type;
      172 	     end;
      173 	     go to read_line;
      174 
      175 statement_type (2):					/* *++ symlen */
      176 	     if end_of_line then go to no_operand;
      177 	     do while (^end_of_line);
      178 		call get_symword;			/* Look up symbol */
      179 		call get_word;			/* Get length */
      180 		if word = "" then do;
      181 		     call com_err_ (0, name, "Invalid length for ^a on line ^d.", sym.name, lineno);
      182 		     go to done;
      183 		end;
      184 		sym.len = eval (word);
      185 	     end;
      186 	     go to read_line;
      187 
      188 statement_type (3):					/* *++ symtype */
      189 	     if end_of_line then go to no_operand;
      190 	     do while (^end_of_line);
      191 		call get_symword;
      192 		call get_word;
      193 		do i = lbound (long_type_names, 1) to hbound (long_type_names, 1); /* Check for valid type */
      194 		     if word = long_type_names (i) | word = short_type_names (i) then go to got_type;
      195 		end;
      196 		call com_err_ (0, name, "Invalid type for ^a on line ^d.", sym.name, lineno);
      197 		go to done;
      198 got_type:		sym.type = i;
      199 	     end;
      200 	     go to read_line;
      201 
      202 statement_type (4):					/* *++symdef - define a new symbol */
      203 	     if end_of_line then go to no_operand;
      204 	     do while (^end_of_line);
      205 		call get_word;
      206 		if word = "" then go to no_operand;
      207 		do i = 1 to symbol_table.cnt;		/* Be sure not duplicate */
      208 		     symp = addr (symbol_table.entry (i));
      209 		     if sym.name = word then do;
      210 			call com_err_ (0, name, "Attempt to multiply define ^a on line ^d.", word, lineno);
      211 			go to done;
      212 		     end;
      213 		end;
      214 		symbol_table.cnt, symbol_table.maxcnt = symbol_table.cnt + 1;
      215 		symp = addr (symbol_table.entry (symbol_table.cnt)); /* Addr of new entry */
      216 		sym.name = word;
      217 		sym.value = 0;
      218 		sym.len = 1;
      219 		sym.reloc = reloc_abs;
      220 		sym.type = type_oct;
      221 		sym.flag_mem = "";
      222 		if ^end_of_line then do;		/* There is value */
      223 		     call get_word;
      224 		     sym.value = eval (word);
      225 		end;
      226 	     end;
      227 	     go to read_line;
      228 
      229 statement_type (5):					/* *++symflag */
      230 	     if end_of_line then go to no_operand;
      231 	     do while (^end_of_line);
      232 		call get_symword;
      233 		if end_of_line then sym.flag_mem = "";
      234 		else do;
      235 		     call get_word;
      236 		     sym.flag_mem = word;
      237 		end;
      238 	     end;
      239 	     go to read_line;
      240 
      241 statement_type (6):					/* *++symdel - delete a previously defined symbol */
      242 	     if end_of_line then go to no_operand;
      243 	     do while (^end_of_line);
      244 		call get_symword;
      245 		do i = sym_offset + 1 to symbol_table.cnt; /* Shift everything after it down */
      246 		     symbol_table.entry (i-1) = symbol_table.entry (i);
      247 		end;
      248 		unspec (symbol_table.entry (symbol_table.cnt)) = "0"b;
      249 		symbol_table.cnt, symbol_table.maxcnt = symbol_table.cnt - 1;
      250 	     end;
      251 	     go to read_line;
      252 
      253 statement_type (7):					/* *++symval - sets the valuue of a symbol */
      254 	     if end_of_line then go to no_operand;
      255 	     do while (^end_of_line);
      256 		call get_symword;
      257 		if end_of_line then sym.value = 0;
      258 		else do;
      259 		     call get_word;
      260 		     sym.value = eval (word);
      261 		end;
      262 	     end;
      263 	     go to read_line;
      264 
      265 statement_type (8):					/* *++symget - gets a range of symbols into table */
      266 	     r_sw = "0"b;
      267 	     go to statement_type_8_9;
      268 
      269 statement_type (9):					/* *++symgetr - like symget, but adds them in reverse order */
      270 	     r_sw = "1"b;
      271 
      272 statement_type_8_9:
      273 	     save_restp = restp;			/* Save these values incase read-ahead needed */
      274 	     save_restl = restl;
      275 	     start_lineno = lineno;
      276 	     start_cnt = symbol_table.cnt;		/* Remember origonal count */
      277 	     if end_of_line then go to no_operand;
      278 	     call get_word;				/* Get starting symbol name */
      279 	     if word = "" | end_of_line then go to no_operand;
      280 	     start_sym = word;
      281 	     call get_word;				/* Ending symbol */
      282 	     if word = "" then go to no_operand;
      283 	     end_sym = word;
      284 	     reloc_type = reloc_abs;			/* Default relocation */
      285 	     flag_type = "";			/* Default flag field */
      286 	     if ^end_of_line then do;			/* There may be relocation field */
      287 		call get_word;
      288 		if word = "" then reloc_type = reloc_abs;
      289 		else call check_reloc;
      290 	     end;
      291 	     if ^end_of_line then do;			/* May be flag field */
      292 		call get_word;
      293 		flag_type = word;
      294 	     end;
      295 
      296 scan_start_sym:
      297 	     call get_line;				/* Search for starting symbol */
      298 	     if linep = null then do;
      299 		call com_err_ (0, name, "Cant't find starting symbol ""^a"" requested on line ^d.",
      300 		     start_sym, start_lineno);
      301 		go to done;
      302 	     end;
      303 	     if substr (line, 1, 1) = "*" then go to scan_start_sym;
      304 	     call get_label;
      305 	     if label ^= start_sym then go to scan_start_sym;
      306 	     call make_sym_entry;			/* Make entry for starting symbol */
      307 	     if label = end_sym then go to done_sym_scan;
      308 scan_end_sym:
      309 	     call get_line;
      310 	     if linep = null then do;
      311 		call com_err_ (0, name, "Can't find ending symbol ""^a"" requested on line ^d.",
      312 		     end_sym, start_lineno);
      313 		go to done;
      314 	     end;
      315 	     if substr (line, 1, 1) = "*" then go to scan_end_sym;
      316 	     call get_label;
      317 	     if label = "" then go to scan_end_sym;
      318 	     call make_sym_entry;
      319 	     if label ^= end_sym then go to scan_end_sym;
      320 done_sym_scan:
      321 	     lineno = start_lineno;			/* Back up to *++symget statement */
      322 	     restp = save_restp;
      323 	     restl = save_restl;
      324 	     i = symbol_table.cnt - start_cnt;		/* Number of symbols added */
      325 	     if r_sw then begin;			/* Reverse them if symgetr */
      326 
      327 dcl  j fixed bin;
      328 dcl 1 temp_table,
      329     2 entry (i) unal,
      330       3 one_symbol like sym unal;
      331 
      332 		do j = 1 to i;			/* Copy to temp table */
      333 		     temp_table.entry (j) = symbol_table.entry (start_cnt + j);
      334 		end;
      335 		do j = i to 1 by -1;		/* Copy back */
      336 		     symbol_table.entry (symbol_table.cnt - j + 1) = temp_table.entry (j);
      337 		end;
      338 	     end;
      339 	     go to read_line;
      340 
      341 no_operand:    call com_err_ (0, name, "Missing operand for *++^a on line ^d.", opname, lineno);
      342 	     go to done;
      343 
      344 	end build_symbol_table;
      345 
      346 /* Procedure called after the symbol table is build3t to copy in explanation data and compute offsets to it */
      347 
      348 relocate_explanations: proc;
      349 
      350 dcl  words (n_exp_words) bit (36) aligned based;
      351 dcl (p, q) ptr;
      352 dcl  i fixed bin;
      353 
      354 	     if n_exp_words = 0 then return;
      355 	     p = addrel (symbol_tablep, size (symbol_table)); /* First word available for explanations */
      356 	     q = addr (explain_seg.data);
      357 	     p -> words = q -> words;			/* Copy it */
      358 	     do i = 1 to symbol_table.cnt;		/* Loop to adjust all offsets */
      359 		symp = addr (symbol_table.entry (i));
      360 		if sym.explain ^= "0"b then		/* It has explanation */
      361 		     sym.explain = bit (bin (bin (sym.explain, 17) + size (symbol_table) -1, 18), 18);
      362 	     end;
      363 	     return;
      364 
      365 	end relocate_explanations;
      366 
      367 /* Procedure to initiate the macro source segment. It looks first in the working directory,
      368*   then in >ldd>mcs>info */
      369 
      370 init_macro_seg: proc;
      371 
      372 	     dir = get_wdir_ ();
      373 	     call hcs_$initiate_count (dir, macro_name, "", bit_count, 0, segp, code);
      374 	     if segp = null then do;
      375 		if code ^= error_table_$noentry then do;
      376 macro_seg_err:	     call com_err_ (code, name, "^a^[>^]^a", dir, dir ^= ">", macro_name);
      377 		     go to done;
      378 		end;
      379 		dir = ">ldd>mcs>info";		/* Try library */
      380 		call hcs_$initiate_count (dir, macro_name, "", bit_count, 0, segp, code);
      381 		if segp = null then go to macro_seg_err;
      382 	     end;
      383 
      384 	     call ioa_ ("^a: Using ^a^[>^]^a", name, dir, (dir ^= ">"), macro_name);
      385 
      386 	     segl = divide (bit_count, 9, 17, 0);
      387 	     restp = segp;
      388 	     restl = segl;
      389 	     return;
      390 
      391 	end init_macro_seg;
      392 
      393 /* Procedure to isolate the next line in the source */
      394 
      395 get_line:	proc;
      396 
      397 dcl  i fixed bin;
      398 
      399 get_next_line: end_of_line = "0"b;
      400 	     if restl = 0 then do;			/* End of file */
      401 		linep = null;
      402 		return;
      403 	     end;
      404 	     lineno = lineno+1;
      405 
      406 	     i = index (rest, nl);
      407 	     if i = 0 then i, linel = restl;		/* No more newlines */
      408 	     else linel = i-1;
      409 	     linep = restp;
      410 	     restp = substraddr (rest, i+1);
      411 	     restl = restl - i;
      412 	     if linel = 0 then go to get_next_line;	/* Ignor empty lines */
      413 	     return;
      414 
      415 	end get_line;
      416 
      417 /* Procedure called while parsing line to move pointer down the line. */
      418 
      419 adv_line:	proc (n);
      420 
      421 dcl  n fixed bin;					/* How far too move */
      422 
      423 	     linep = substraddr (line, n+1);
      424 	     linel = linel - n;
      425 	     if linel = 0 then end_of_line = "1"b;
      426 	     return;
      427 
      428 	end adv_line;
      429 
      430 /* Procedure to skip over any white space */
      431 
      432 skip_white_space: proc;
      433 
      434 dcl  i fixed bin;
      435 
      436 	     i = verify (line, white_space);		/* Count white space characters */
      437 	     if i = 0 then i = linel;			/* All white line */
      438 	     else i = i - 1;
      439 	     call adv_line (i);
      440 	     return;
      441 
      442 	end skip_white_space;
      443 
      444 /* Procedure to get the next word from the operand field. */
      445 
      446 get_word:	proc;
      447 
      448 dcl  i fixed bin;
      449 
      450 	     if end_of_line | (linel = 0) then do;
      451 		end_of_line = "1"b;
      452 		wordp = null;
      453 		wordl = 0;
      454 		return;
      455 	     end;
      456 
      457 	     i = search (line, " 	,");		/* Space, tab, and comma */
      458 	     if i = 0 then i = length (line);
      459 	     else i = i - 1;
      460 	     wordp = linep;
      461 	     wordl = i;
      462 	     call adv_line (i);			/* More forward over the word */
      463 	     if linel > 0 then			/* Check for end of line */
      464 		if substr (line, 1, 1) ^= "," then end_of_line = "1"b;
      465 		else call adv_line (1);		/* Skip  ver  comma  */
      466 	     return;
      467 
      468 	end get_word;
      469 
      470 /* Procedure to get the next word as a symbol */
      471 
      472 get_symword: proc;
      473 
      474 	     call get_word;
      475 	     do sym_offset = 1 to symbol_table.cnt;
      476 		symp = addr (symbol_table.entry (sym_offset));
      477 		if sym.name = word then return;
      478 	     end;
      479 	     call com_err_ (0, name, "Undefined symbol ^a on line ^d", word, lineno);
      480 	     go to done;
      481 
      482 	end get_symword;
      483 
      484 /* Check current word for valid relocation type */
      485 
      486 check_reloc: proc;
      487 
      488 	     if word = "abs" then reloc_type = reloc_abs;
      489 	     else if word = "tib" then reloc_type = reloc_tib;
      490 	     else if word = "sfcm" then reloc_type = reloc_sfcm;
      491 	     else if word = "hwcm" then reloc_type = reloc_hwcm;
      492 	     else if word = "meters" then reloc_type = reloc_meters;
      493 	     else do;
      494 		call com_err_ (0, name, "Invalid relocation type of ^a on line ^d", word, lineno);
      495 		go to done;
      496 	     end;
      497 	     return;
      498 
      499 	end check_reloc;
      500 
      501 /* Extrace label from assembler statement */
      502 
      503 get_label: proc;
      504 
      505 dcl  i fixed bin;
      506 
      507 	     i = search (line, white_space);
      508 	     if i = 1 then label = "";		/* No label */
      509 	     else do;
      510 		if i = 0 then i = length (line);	/* Label is hole line */
      511 		else i = i-1;
      512 		label = substr (line, 1, i);
      513 		call adv_line (i);
      514 	     end;
      515 	     call skip_white_space;
      516 	     return;
      517 
      518 	end get_label;
      519 
      520 /* Procedure to make a new symbol table entry by compiling the curent line */
      521 
      522 make_sym_entry: proc;
      523 
      524 dcl  i fixed bin;
      525 dcl  dec_sw bit (1);
      526 
      527 	     i = search (line, white_space);		/* Find end of opcode */
      528 	     if i = 0 then i = length (line);
      529 	     else i = i-1;
      530 	     if substr (line, 1, i) = "set" | substr (line, 1, i) = "equ" then dec_sw = "1"b; /* Valid decimal op */
      531 	     else if substr (line, 1, i) = "bool" then dec_sw = "0"b;
      532 	     else do;
      533 		call com_err_ (0, name, "Unrecognized opcode ""^a"" defining ""^a"" on line ^d.",
      534 		     substr (line, 1, i), label, lineno);
      535 		go to done;
      536 	     end;
      537 	     call adv_line (i);			/* Over opcode */
      538 	     call skip_white_space;
      539 	     symbol_table.cnt, symbol_table.maxcnt = symbol_table.cnt + 1;
      540 	     symp = addr (symbol_table.entry (symbol_table.cnt));
      541 	     sym.name = label;
      542 	     sym.value = 0;
      543 	     sym.len = 1;
      544 	     sym.reloc = reloc_type;
      545 	     if flag_type = "" then sym.type = type_oct;
      546 	     else sym.type = type_bit;
      547 	     sym.flag_mem = flag_type;
      548 	     sym.explain = "0"b;
      549 	     sym.pad = "0"b;
      550 	     i = search (line, white_space);		/* Find end of expression */
      551 	     if i = 0 then i = length (line);
      552 	     else i = i-1;
      553 	     if dec_sw then sym.value = eval (substr (line, 1, i));
      554 	     else sym.value = eval_oct (substr (line, 1, i));
      555 
      556 	     call adv_line (i);			/* Over expression */
      557 	     if end_of_line then return;
      558 	     call skip_white_space;			/* Move up to comment */
      559 	     if end_of_line then return;
      560 	     exptext.len = length (line);		/* Rest of line is explanation */
      561 	     exptext.data = line;
      562 	     sym.explain = rel (exptextp);
      563 	     i = size (exptext);
      564 	     n_exp_words = n_exp_words + i;
      565 	     exptextp = addrel (exptextp, i);		/* Loc for next eplanation */
      566 
      567 	     return;
      568 
      569 	end make_sym_entry;
      570 
      571 /* Cleanup handler */
      572 
      573 clean_up:	proc;
      574 
      575 	     if segp ^= null then call hcs_$terminate_noname (segp, code);
      576 	     if ptr_array (1) ^= null then call release_temp_segments_ (name, ptr_array, code);
      577 	     return;
      578 
      579 	end clean_up;
      580 
      581 /* Simulate substraddr builtin temporarily */
      582 
      583 substraddr: proc (c, n) returns (ptr);
      584 
      585 dcl  c char (*);
      586 dcl  n fixed bin;
      587 dcl  ca (n) char (1) unal based (addr (c));
      588 
      589 	     return (addr (ca (n)));
      590 
      591 	end substraddr;
      592 
      593 /* Procedure to evaluate expressions in source lines. This code was
      594*   copied origionally from db_fnp_eval_ */
      595 
      596 eval:	proc (arg_expr) returns (fixed bin);
      597 
      598 /* Parameters */
      599 
      600 dcl  arg_expr char (*);				/* The expression to evaluate */
      601 
      602 /* Automatic */
      603 
      604 dcl  result fixed bin;
      605 dcl  code fixed bin (35);
      606 dcl  ntoken fixed bin;				/* Number of tokens */
      607 dcl  exprp ptr;					/* Pointer to unparsed part of expression */
      608 dcl  exprl fixed bin;				/* Length of unparsed part */
      609 dcl  expr char (exprl) based (exprp);			/* The unparsed part of expression */
      610 dcl  tstart fixed bin;				/* Starting token in sub-expression */
      611 dcl  tend fixed bin;				/* Last token in sub-expression */
      612 dcl  tcur fixed bin;				/* Current token */
      613 dcl  n_mult fixed bin;				/* Count of multiplies and divides */
      614 dcl  n_add fixed bin;				/* Count of adds and subtracts */
      615 dcl  dec_sw bit (1);
      616 
      617 dcl 1 token_list aligned,
      618     2 entry (255) unal,
      619       3 token like token;
      620 
      621 
      622 /* Definition of a token */
      623 
      624 dcl  tokenp ptr;
      625 
      626 dcl 1 token unaligned based (tokenp),
      627     2 prev fixed bin (8),				/* Backwards pointer */
      628     2 next fixed bin (8),				/* Forwards pointer */
      629     2 type fixed bin (8),				/* Kind of token */
      630     2 sub fixed bin (8),				/* Sub-type, for some tokens */
      631     2 val fixed bin (35);
      632 
      633 /* Values for token.type */
      634 
      635 dcl (start_token init (0),				/* Start of expression */
      636      leftp_token init (1),				/* Left parenthesis */
      637      rightp_token init (2),				/* Right parenthesis */
      638      mult_token init (3),				/* Multiply (sub=1), or divide (sub=2) */
      639      add_token init (4),				/* Add (sub=1), or subtract (sub=2) */
      640      sym_token init (6),				/* Symbol or constant */
      641      end_token init (7))				/* End of expression */
      642      fixed bin int static options (constant);
      643 
      644 
      645 /* Initialization */
      646 
      647 	     dec_sw = "1"b;				/* Called at decimal entryry */
      648 	     go to eval_start;
      649 
      650 eval_oct:	     entry (arg_expr) returns (fixed bin);
      651 
      652 	     dec_sw = "0"b;
      653 
      654 eval_start:
      655 
      656 	     exprp = addr (arg_expr);
      657 	     exprl = length (arg_expr);
      658 
      659 
      660 /* Now evaluate the expression */
      661 
      662 	     call parse_expr;
      663 
      664 	     call eval_expr;
      665 	     return (result);
      666 
      667 /* Procedure to parse the expression */
      668 
      669 parse_expr:    proc;
      670 
      671 dcl  nparen fixed bin;				/* For paren level counting */
      672 dcl  i fixed bin;
      673 
      674 		ntoken = 0;
      675 		call new_token (start_token);		/* First, start of expr token */
      676 
      677 		nparen = 0;
      678 
      679 
      680 
      681 		do while (exprl > 0);		/* Loop until end */
      682 
      683 		     i = index ("()*/+|-", substr (expr, 1, 1)); /* Check for special character */
      684 		     if i = 0 then do;		/* Must be symbol */
      685 			if sym_or_rightp () then go to bad_char;
      686 			call parse_sym;
      687 			go to next_token;
      688 		     end;
      689 		     else go to parse_op (i);		/* Branch, depending on character */
      690 
      691 parse_op (1):					/* Left paren */
      692 		     if sym_or_rightp () then go to bad_char;
      693 		     call new_token (leftp_token);
      694 		     nparen = nparen + 1;
      695 		     call adv (1);
      696 		     go to next_token;
      697 
      698 parse_op (2):					/* Right paren */
      699 		     if token.type = start_token | mult_or_add () then go to bad_char;
      700 		     if nparen ^> 0 then do;
      701 			if exprl = length (arg_expr) then go to bad_char;
      702 			else call err ("Too many "")"".");
      703 		     end;
      704 		     call new_token (rightp_token);
      705 		     nparen = nparen - 1;
      706 		     call adv (1);
      707 		     go to next_token;
      708 
      709 parse_op (3):					/* "*" - multiply */
      710 		     if ^sym_or_rightp () then go to bad_char;
      711 		     call new_token (mult_token);
      712 		     token.sub = 1;
      713 		     call adv (1);
      714 		     go to next_token;
      715 
      716 parse_op (4):					/* Divide */
      717 		     if start_or_leftp () | mult_or_add () then go to bad_char;
      718 		     call new_token (mult_token);
      719 		     token.sub = 2;
      720 		     call adv (1);
      721 		     go to next_token;
      722 
      723 parse_op (5):					/* Add */
      724 parse_op (6):					/* Add, alternate form ("|") */
      725 parse_op (7):					/* Subtract */
      726 		     if start_or_leftp () then call new_token (sym_token); /* Unary, treat as 0+ or 0- */
      727 		     else if mult_or_add () then go to bad_char;
      728 		     call new_token (add_token);
      729 		     if substr (expr, 1, 1) = "-" then token.sub = 2;
      730 		     else token.sub = 1;
      731 		     call adv (1);
      732 		     go to next_token;
      733 
      734 next_token:
      735 		end;
      736 
      737 		if nparen ^= 0 then call err ("Parens do not balance."); /* Must balance in end */
      738 
      739 		if mult_or_add () then call err ("Expression ends badly.");
      740 
      741 		call new_token (end_token);
      742 		return;
      743 
      744 	     end parse_expr;
      745 
      746 /* Procedure to parse a constant or a symbol name */
      747 
      748 parse_sym:     proc;
      749 
      750 dcl  val fixed bin (35);
      751 dcl  bval bit (36) aligned based (addr (val));
      752 dcl (i, j) fixed bin;
      753 dcl  p ptr;
      754 
      755 		i = verify (expr, "0123456789");	/* Try constant first */
      756 		if i ^= 1 then do;			/* It is a constant */
      757 		     if i = 0 then i = length (expr);	/* Rest of expr is a constant */
      758 		     else i = i - 1;
      759 		     if dec_sw then do;
      760 			val = cv_dec_check_ (substr (expr, 1, i), code);
      761 			if code ^= 0 then call err ("Invalid decimal integer: ""^a"".", substr (expr, 1, i));
      762 			if val < -262144 | val > 262143 then
      763 			     call err ("Decimal integer not in range -262144 to 262143: ^a", substr (expr, 1, i));
      764 			call adv (i);
      765 		     end;
      766 		     else do;			/* Octal number */
      767 			val = cv_oct_check_ (substr (expr, 1, i), code);
      768 			if code ^= 0 then call err ("Invalid octal integer: ""^a"".", substr (expr, 1, i));
      769 			if substr (bval, 1, 18) ^= "0"b & substr (bval, 1, 18) ^= "777777"b3 then
      770 			     call err ("Octal integer not in range -400000 to 377777: ^a", substr (expr, 1, i));
      771 			call adv (i);
      772 		     end;
      773 		     if val > 0 then if substr (bval, 19, 1) then /* Really negative */
      774 			     substr (bval, 1, 18) = "777777"b3;
      775 		     call new_token (sym_token);	/* Set up token for symbol */
      776 		     token.val = val;
      777 		     return;
      778 		end;
      779 
      780 /* Symbol must be a name */
      781 
      782 		i = search (expr, "()*/+|-");		/* Look for end */
      783 		if i = 1 then go to bad_char;
      784 		if i = 0 then i = length (expr);
      785 		else i = i - 1;
      786 
      787 		do j = 1 to symbol_table.cnt;
      788 		     p = addr (symbol_table.entry (j));
      789 		     if p -> sym.name = substr (expr, 1, i) then go to sym_found;
      790 		end;
      791 		call err ("Invalid symbol: ^a", substr (expr, 1, i));
      792 
      793 sym_found:
      794 		call new_token (sym_token);
      795 		token.val = p -> sym.value;
      796 		call adv (i);
      797 		return;
      798 
      799 	     end parse_sym;
      800 
      801 /* Procedures which to some comon tests on the previous token */
      802 
      803 mult_or_add:   proc returns (bit (1));
      804 
      805 		return (token.type = mult_token | token.type = add_token);
      806 
      807 	     end mult_or_add;
      808 
      809 start_or_leftp: proc returns (bit (1));
      810 
      811 		return (token.type = start_token | token.type = leftp_token);
      812 
      813 	     end start_or_leftp;
      814 
      815 sym_or_rightp: proc returns (bit (1));
      816 
      817 		return (token.type = sym_token | token.type = rightp_token);
      818 
      819 	     end sym_or_rightp;
      820 
      821 /* Procedure to create a new token and trhread it in */
      822 
      823 new_token:     proc (type);
      824 
      825 dcl  type fixed bin;				/* Type of new token */
      826 
      827 		if ntoken = hbound (token_list.entry, 1) then call err ("Expression too long.");
      828 		if ntoken > 0 then token.next = ntoken + 1; /* Set pointer in prev token */
      829 		ntoken = ntoken + 1;
      830 		tokenp = addr (token_list.entry (ntoken));
      831 		token.prev = ntoken - 1;
      832 		token.next = 0;
      833 		token.type = type;
      834 		token.sub = 0;
      835 		token.val = 0;
      836 		return;
      837 
      838 	     end new_token;
      839 
      840 /* Procedure to advance pointer in expression */
      841 
      842 adv:	     proc (n);
      843 
      844 dcl  n fixed bin;					/* Amount to move */
      845 
      846 		exprp = substraddr (expr, n+1);	/* Adjust pointer */
      847 		exprl = exprl - n;			/* Adjust length */
      848 		return;
      849 
      850 	     end adv;
      851 
      852 /* Procedure to evaluate the expression by scanning the list of tokens */
      853 /* The procedure is to find the inner most expression, evaluate it, and
      854*   continue. At the end, there should only be 3 tokens left: the start, the end,
      855*   and one symbol token containing the final value */
      856 
      857 eval_expr:     proc;
      858 
      859 		do while (ntoken > 3);
      860 		     call find_sub_expr;		/* Find some inner expression to work on */
      861 		     call eval_sub_expr;		/* And reduce it to a value */
      862 		end;
      863 
      864 		tokenp = addr (token_list.entry (1));	/* Pointer to start token */
      865 		tokenp = addr (token_list.entry (token.next)); /* Second token, containing the value */
      866 		result = token.val;			/* Get the answer */
      867 		return;
      868 
      869 	     end eval_expr;
      870 
      871 
      872 /* Procedure to locate an inner expression to evaluate. This will be either
      873*   a part of the expression delimited by parens, or, if no parens left, the
      874*   entire expression. */
      875 /* The following variables are set for future use:
      876*   tstart - the first token in the expression found
      877*   tend - the last
      878*   n_mult - likewise for mult tokens
      879*   n_add - likewise for add tokens */
      880 
      881 find_sub_expr: proc;
      882 
      883 		n_mult, n_add = 0;
      884 		tstart, tcur = 1;
      885 		tokenp = addr (token_list.entry (tstart));
      886 
      887 		do while ((token.type ^= rightp_token) & (token.type ^= end_token));
      888 		     if token.type = leftp_token then do;
      889 			tstart = tcur;		/* Maybe expression will start here */
      890 			n_mult, n_add = 0;		/* Must reset counters for inner level */
      891 		     end;
      892 		     else if token.type = mult_token then n_mult = n_mult + 1;
      893 		     else if token.type = add_token then n_add = n_add + 1;
      894 		     tcur = token.next;		/* On to next one */
      895 		     tokenp = addr (token_list.entry (tcur));
      896 		end;
      897 		tend = tcur;
      898 
      899 	     end find_sub_expr;
      900 
      901 /* Procedure to evaluate sub-expression once it has been isolated. */
      902 /* The sub-expression is repeatedly scanned for mult tokens, add tokens */
      903 
      904 eval_sub_expr: proc;
      905 
      906 		do while ((n_mult + n_add) > 0);
      907 		     if n_mult > 0 then call eval_op (mult_token, n_mult);
      908 		     if n_add > 0 then call eval_op (add_token, n_add);
      909 		end;
      910 
      911 		call del_token (tstart);		/* Delete parens one expression is evaluated */
      912 		call del_token (tend);
      913 		return;
      914 
      915 	     end eval_sub_expr;
      916 
      917 /* This procedure scans looking for either mult tokens or add tokens to be evaluated. */
      918 
      919 eval_op:	     proc (token_type, token_cnt);
      920 
      921 dcl  token_type fixed bin;				/* The kind of token being evaluated, mult or add */
      922 dcl  token_cnt fixed bin;				/* Number still unevaluated in sub-expression */
      923 
      924 		tcur = tstart;
      925 		tokenp = addr (token_list.entry (tcur));
      926 		do while (token_cnt > 0);
      927 		     if token.type = token_type then do; /* Got one */
      928 			call compute_op;		/* Go do the arithmetic */
      929 			token_cnt = token_cnt - 1;
      930 		     end;
      931 		     tcur = token.next;
      932 		     tokenp = addr (token_list.entry (tcur));
      933 		end;
      934 		return;				/* Every thing possible is done */
      935 
      936 	     end eval_op;
      937 
      938 /* Procedure called to evalue a mult or add token. Once the arithmetic is done,
      939*   the value is stored in the first sym token. the operator token and the second
      940*   symbol token are deleted. This procedure is called with tcur as the operator
      941*   token being evaluated */
      942 
      943 compute_op:    proc;
      944 
      945 dcl (del1, del2) fixed bin;				/* The two tokens to be deleted */
      946 dcl (val1, val2) fixed bin (35);			/* Values of the two symbols */
      947 dcl  p ptr;
      948 
      949 		del1 = tcur;			/* The operator token will be deleted */
      950 		del2 = token.next;			/* As well as the second operand */
      951 		p = addr (token_list.entry (token.next)); /* Pointter to second symbol token */
      952 		val2 = p -> token.val;
      953 		p = addr (token_list.entry (token.prev)); /* Pointer to the first symbol */
      954 		val1 = p -> token.val;
      955 		if token.type = add_token then do;	/* Add or subtract */
      956 		     if token.sub = 1 then val1 = val1 + val2;
      957 		     else val1 = val1 - val2;
      958 		end;
      959 		else do;				/* Multiply or divide */
      960 		     if token.sub = 1 then val1 = val1 * val2;
      961 		     else do;
      962 			if val2 = 0 then call err ("Division by zero.");
      963 			else val1 = divide (val1, val2, 35, 0);
      964 		     end;
      965 		end;
      966 
      967 		tcur = token.prev;			/* Make first operand the current token */
      968 		tokenp = addr (token_list.entry (tcur));
      969 		token.val = val1;			/* Save answer */
      970 		call del_token (del1);		/* Delete operator */
      971 		call del_token (del2);		/* And the sedond operand */
      972 		return;
      973 
      974 	     end compute_op;
      975 
      976 /* Procedure to delete a token by untreading it from the list */
      977 
      978 del_token:     proc (n);
      979 
      980 dcl  n fixed bin;					/* The token to go */
      981 dcl (next, prev) fixed bin;
      982 dcl  p ptr;
      983 
      984 		p = addr (token_list.entry (n));
      985 		prev = p -> token.prev;
      986 		next = p -> token.next;
      987 		if (prev = 0) | (next = 0) then return; /* Ndver delete start or end */
      988 
      989 		p = addr (token_list.entry (prev));
      990 		p -> token.next = next;
      991 		p = addr (token_list.entry (next));
      992 		p -> token.prev = prev;
      993 		ntoken = ntoken - 1;
      994 		return;
      995 
      996 	     end del_token;
      997 
      998 /* Error routines */
      999 
     1000 bad_char:
     1001 	     if exprl < length (arg_expr) then call err ("""^a"" after ""^a"" is invalid.",
     1002 		substr (expr, 1, 1), substr (arg_expr, 1, length (arg_expr) - exprl));
     1003 	     else call err ("""^a"" at beginning is invalid.", substr (expr, 1, 1));
     1004 
     1005 
     1006 /* General error subroutine */
     1007 
     1008 err:	     proc options (variable);
     1009 
     1010 dcl  s char (256);
     1011 dcl  p ptr;
     1012 
     1013 		call cu_$arg_list_ptr (p);
     1014 		call ioa_$general_rs (p, 1, 2, s, (0), "1"b, "0"b);
     1015 		call com_err_ (0, name, "Invalid expression in line ^d: ""^a"". ^a", lineno, arg_expr, s);
     1016 		go to done;
     1017 
     1018 	     end err;
     1019 
     1020 	end eval;
     1021 
  1     1 /* Begin include file ..... debug_fnp_data.incl.pl1 */
  1     2 
  1     3 /* Describes various structures used by the debug_fnp command */
  1     4 
  1     5 /* Written February 1977 by Larry Johnson */
  1     6 
  1     7 /* Structures describing a symbol table used by the debug_fnp command,
  1     8*   to find values for common FNP symbols. */
  1     9 
  1    10 dcl  db_fnp_symbols_$db_fnp_symbols_ ext;
  1    11 
  1    12 dcl  symbol_tablep ptr;
  1    13 
  1    14 dcl 1 symbol_table aligned based (symbol_tablep),
  1    15     2 cnt fixed bin,				/* Number of entries */
  1    16     2 maxcnt fixed bin,				/* Max count */
  1    17     2 entry (symbol_table.cnt) unal,
  1    18       3 one_symbol like sym unal;
  1    19 
  1    20 dcl  symp ptr;					/* Pointer to one symbol */
  1    21 
  1    22 dcl 1 sym unal based (symp),
  1    23     2 name char (6),
  1    24     2 value fixed bin (17),
  1    25     2 len fixed bin (17),				/* Number of words */
  1    26     2 reloc fixed bin (17),
  1    27     2 type fixed bin (17),
  1    28     2 flag_mem char (6),				/* If non blank, name of word in which this is a flag */
  1    29     2 explain bit (18),				/* Offset to explanation for symbol */
  1    30     2 pad bit (18);
  1    31 
  1    32 dcl  exptextp ptr;
  1    33 
  1    34 dcl 1 exptext aligned based (exptextp),			/* Symbol explanation entry */
  1    35     2 len fixed bin (8) unal,
  1    36     2 data char (exptext.len) unal;
  1    37 
  1    38 /* Values for sym.reloc, which is relocation required to find the symbol */
  1    39 
  1    40 dcl (reloc_abs init (0),				/* Value is absolute */
  1    41      reloc_tib init (1),				/* Value is relative to current tib addr */
  1    42      reloc_hwcm init (2),				/* Value is relative to current hwcm */
  1    43      reloc_sfcm init (3),				/* Value is relative to software comm region */
  1    44      reloc_meters init (4))				/* Value is relative to tib meters */
  1    45      int static options (constant);
  1    46 
  1    47 /* Values for sym.type, which is the mode to be used in displaying symbol */
  1    48 
  1    49 dcl (type_oct init (0),				/* Octal, default for most symbols */
  1    50      type_char init (1),				/* Ascii characters */
  1    51      type_addr init (2),				/* Address to be converted to mod|offset */
  1    52      type_clock init (3),				/* Multics clock value */
  1    53      type_inst init (4),				/* Machine instruction */
  1    54      type_op init (5),				/* Interpreter opblock format */
  1    55      type_dec init (6),				/* Decimal */
  1    56      type_bit init (7),				/* In bits */
  1    57      type_ebcdic init (8))				/* 8-bit ebcdic characters */
  1    58      int static options (constant);
  1    59 
  1    60 dcl  long_type_names (0:8) char (12) int static options (constant) init (
  1    61      "octal", "character", "address", "clock", "instruction", "opblock", "decimal", "bit", "ebcdic");
  1    62 dcl  short_type_names (0:8) char (4) int static options (constant) init (
  1    63      "oct", "ch", "addr", "ck", "inst", "op", "dec", "bit", "ebc");
  1    64 
  1    65 
  1    66 /* Structure of suplmental data used in evaluating expressions */
  1    67 
  1    68 dcl  expr_infop ptr;
  1    69 
  1    70 dcl 1 expr_info aligned based (expr_infop),
  1    71     2 flags,
  1    72       3 star_known bit (1) unal,			/* Value of "*" is known */
  1    73       3 tib_known bit (1) unal,			/* TIB addresses may be used */
  1    74       3 hwcm_known bit (1) unal,			/* HWCM address may be used */
  1    75       3 sfcm_known bit (1) unal,			/* SFCM address may be used */
  1    76       3 pad bit (32) unal,
  1    77     2 star_addr fixed bin,				/* Value of "*" */
  1    78     2 tib_addr fixed bin,				/* Address of TIB */
  1    79     2 hwcm_addr fixed bin,				/* Address of HWCM */
  1    80     2 sfcm_addr fixed bin,				/* Address of SFCM */
  1    81     2 type fixed bin,				/* Expression type (mode for printing) */
  1    82     2 len fixed bin,				/* Implied length of expression */
  1    83     2 user_tablep ptr;				/* Pointer to a user symbol table */
  1    84 
  1    85 
  1    86 /* Structure of opcode table of machine instructions */
  1    87 
  1    88 dcl  db_fnp_opcodes_$ ext;
  1    89 
  1    90 dcl  optablep ptr;
  1    91 
  1    92 dcl 1 optable aligned based (optablep),
  1    93     2 cnt fixed bin,
  1    94     2 entry (optable.cnt) unal,
  1    95       3 one_op like op;
  1    96 
  1    97 dcl  opp ptr;
  1    98 
  1    99 dcl 1 op unal based (opp),
  1   100     2 name char (6),				/* The mneumonic */
  1   101     2 code bit (12),				/* The  opcode */
  1   102     2 mask bit (12),				/* Mask that says where the opcode is */
  1   103     2 type fixed bin (11),				/* Type of display required */
  1   104     2 pad bit (18);
  1   105 
  1   106 /* Values for op.type are:
  1   107*   0 - storage reference
  1   108*   1 - non-storage reference (immediate),
  1   109*   2 - non-storage reference (iacxn only),
  1   110*   3 - non-storage reference (shifts),
  1   111*   4 - non-storage reference (no operands) */
  1   112 
  1   113 
  1   114 /* Stuctures used while parsing commands into operands */
  1   115 
  1   116 dcl  cmd_infop ptr;
  1   117 
  1   118 dcl 1 cmd_info aligned based (cmd_infop),
  1   119     2 inbuf char (256),				/* For reading lines */
  1   120     2 opbuf char (256),				/* Used for operand in undoubling quotes */
  1   121     2 commandp ptr,					/* Address of unparsed part of command */
  1   122     2 commandl fixed bin,				/* Length of unparsed part */
  1   123     2 operandp ptr,					/* Address of current operand */
  1   124     2 operandl fixed bin,				/* And its length */
  1   125     2 error bit (1),				/* Set if error parsing operand */
  1   126     2 endline bit (1),				/* Set if no more operands on line */
  1   127     2 opstring bit (1),				/* Set if operand was unquoted string */
  1   128     2 flush bit (1),				/* If set, rest of input line will be ignored */
  1   129     2 envp ptr;					/* Pointer to the debug_fnp environment structure */
  1   130 
  1   131 dcl  command char (cmd_info.commandl) based (cmd_info.commandp);
  1   132 dcl  operand char (cmd_info.operandl) based (cmd_info.operandp);
  1   133 
  1   134 /* The following structure describes the current debug_fnp environment. */
  1   135 /* It specifies whether we are working on a dump, fnp, core image, etc. */
  1   136 
  1   137 dcl  envp ptr;
  1   138 
  1   139 dcl 1 env aligned based (envp),
  1   140     2 corep ptr,					/* Ptr to current dump or core-image. Null means live FNP */
  1   141     2 fnp fixed bin,				/* Current fnp number */
  1   142     2 dump_dir char (168) unal,			/* Directory where dumps are found */
  1   143     2 dir char (168) unal,				/* Directory for current dump or core image */
  1   144     2 ename char (32) unal,				/* Ename for current dump or core image */
  1   145     2 tty_name char (32),				/* Name of current channel */
  1   146     2 segp ptr,					/* Pointer to base of current segment */
  1   147     2 flags unal,
  1   148       3 fnps_configured bit (8),			/* Says which FNP's appear in config deck */
  1   149       3 fnp_sw bit (1),				/* 1 if currently working on fnp */
  1   150       3 image_sw bit (1),				/* 1 if currently working on a core-image */
  1   151       3 dump_sw bit (1),				/* 1 if current working on a dump */
  1   152       3 fdump_sw bit (1),				/* 1 if current dump is a fdump */
  1   153       3 pad bit (24),
  1   154     2 dump_time fixed bin (71);			/* Clock time dump occured */
  1   155 
  1   156 /* Structure of data defining table of interpreter opblock names */
  1   157 
  1   158 dcl  db_fnp_opblocks_$ ext;
  1   159 
  1   160 dcl  opblock_tablep ptr;
  1   161 
  1   162 dcl 1 opblock_table aligned based (opblock_tablep),
  1   163     2 cnt fixed bin,
  1   164     2 name (0:opblock_table.cnt) char (6) unal;
  1   165 
  1   166 /* End include file ..... debug_fnp_data.incl.pl1 */
     1022 
     1023 
  2     1 /* BEGIN INCLUDE FILE cds_args.incl.pl1 */
  2     2 
  2     3 dcl 1 cds_args based aligned,
  2     4     2 sections (2),
  2     5       3 p ptr,					/* pointer to data for text/static section */
  2     6       3 len fixed bin (18),				/* size of text/static section */
  2     7       3 struct_name char (32),			/* name of declared structure for this section */
  2     8     2 seg_name char (32),				/* name to create segment by */
  2     9     2 num_exclude_names fixed bin,			/* number of names in exclude array */
  2    10     2 exclude_array_ptr ptr,				/* pointer to array of exclude names */
  2    11     2 switches,					/* control switches */
  2    12       3 defs_in_link bit (1) unal,			/* says put defs in linkage */
  2    13       3 separate_static bit (1) unal,			/* says separate static section is wanted */
  2    14       3 have_text bit (1) unal,			/* ON if text section given */
  2    15       3 have_static bit (1) unal,			/* ON if static section given */
  2    16       3 pad bit (32) unal;
  2    17 
  2    18 dcl  exclude_names (1) char (32) based;			/* pointed to be cds_args.exclude_array_ptr */
  2    19 
  2    20 /* END INCLUDE FILE cds_args.incl.pl1 */
     1024 
     1025 
     1026      end db_fnp_symbols_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/03/86  0924.6  !BBBJQNLGmxkCQZ.pl1               >spec>install>1011>db_fnp_symbols_.cds
1022         1    06/19/81  2115.0  debug_fnp_data.incl.pl1           >ldd>include>debug_fnp_data.incl.pl1
1024         2    04/01/76  2209.5  cds_args.incl.pl1                 >ldd>include>cds_args.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
add_token                       000226 constant        fixed bin(17,0)          initial dcl 635 set ref 728* 805 893 908* 955
addr                                                   builtin function         dcl 83 ref 98 121 121 208 215 356 359 476 540 587
                                                                                  589 589 654 751 769 769 773 773 788 830 864 865
                                                                                  885 895 925 932 951 953 968 984 989 991
addrel                                                 builtin function         dcl 83 ref 355 565
arg_expr                               parameter       char                     unaligned dcl 600 set ref 596 650 654 657 701 1000
                                                                                  1000 1000 1000 1000 1015*
bin                                                    builtin function         dcl 83 ref 360 360
bit                                                    builtin function         dcl 83 ref 360
bit_count                       000120 automatic       fixed bin(24,0)          dcl 28 set ref 373* 380* 386
bval                                   based           bit(36)                  dcl 751 set ref 769 769 773 773*
c                                      parameter       char                     unaligned dcl 585 set ref 583 587 589
ca                                     based           char(1)                  array unaligned dcl 587 set ref 589
cds                             000212 automatic       structure                level 1 unaligned dcl 41 set ref 121 121
cds_args                               based           structure                level 1 dcl 2-3
cleanup                         000260 stack reference condition                dcl 81 ref 89
cnt                                    based           fixed bin(17,0)          level 2 dcl 1-14 set ref 110 144 207 214 214* 215
                                                                                  245 248 249 249* 276 324 336 355 358 360 475 539
                                                                                  539* 540 787 1-14 1-14 1-14 1-14 1-14 1-14 1-14
                                                                                  1-14 1-14 1-14
code                            000101 automatic       fixed bin(35,0)          dcl 605 in procedure "eval" set ref 760* 761 767*
                                                                                  768
code                            000117 automatic       fixed bin(35,0)          dcl 27 in procedure "db_fnp_symbols_" set ref 91* 92
                                                                                  93* 121* 122 122* 373* 375 376* 380* 575* 576*
com_err_                        000016 constant        entry                    external dcl 68 ref 93 122 145 162 181 196 210 299
                                                                                  311 341 376 479 494 533 1015
create_data_segment_            000040 constant        entry                    external dcl 77 ref 121
cu_$arg_list_ptr                000020 constant        entry                    external dcl 69 ref 1013
cv_dec_check_                   000024 constant        entry                    external dcl 71 ref 760
cv_oct_check_                   000022 constant        entry                    external dcl 70 ref 767
data                      1            based           bit(36)                  array level 2 in structure "explain_seg" dcl 50
                                                                                  in procedure "db_fnp_symbols_" set ref 98 356
data                      0(09)        based           char                     level 2 in structure "exptext" packed unaligned
                                                                                  dcl 1-34 in procedure "db_fnp_symbols_" set ref
                                                                                  561*
db_fnp_symbols_                 000257 automatic       fixed bin(17,0)          level 2 dcl 43 set ref 111*
dec_sw                          000114 automatic       bit(1)                   unaligned dcl 615 in procedure "eval" set ref 647*
                                                                                  652* 759
dec_sw                          000461 automatic       bit(1)                   unaligned dcl 525 in procedure "make_sym_entry" set
                                                                                  ref 530* 531* 553
del1                            001240 automatic       fixed bin(17,0)          dcl 945 set ref 949* 970*
del2                            001241 automatic       fixed bin(17,0)          dcl 945 set ref 950* 971*
dir                             000121 automatic       char(168)                unaligned dcl 29 set ref 372* 373* 376* 376 379*
                                                                                  380* 384* 384
divide                                                 builtin function         dcl 83 ref 386 963
dummy_symbol_table              000257 automatic       structure                level 1 dcl 43
end_of_line                     000174 automatic       bit(1)                   unaligned dcl 31 set ref 165 167 175 177 188 190 202
                                                                                  204 222 229 231 233 241 243 253 255 257 277 279
                                                                                  286 291 399* 425* 450 451* 463* 557 559
end_sym                         000332 automatic       char(6)                  unaligned dcl 136 set ref 283* 307 311* 319
end_token                       000064 constant        fixed bin(17,0)          initial dcl 635 set ref 741* 887
entry                           000101 automatic       structure                array level 2 in structure "temp_table" packed
                                                                                  unaligned dcl 328 in begin block on line 325 set
                                                                                  ref 333* 336
entry                           000115 automatic       structure                array level 2 in structure "token_list" packed
                                                                                  unaligned dcl 617 in procedure "eval" set ref 827
                                                                                  830 864 865 885 895 925 932 951 953 968 984 989
                                                                                  991
entry                     2            based           structure                array level 2 in structure "symbol_table" packed
                                                                                  unaligned dcl 1-14 in procedure "db_fnp_symbols_"
                                                                                  set ref 208 215 246* 246 248* 333 336* 359 476 540
                                                                                  788
error_table_$noentry            000042 external static fixed bin(35,0)          dcl 79 ref 375
exclude_array_ptr        42     000212 automatic       pointer                  level 2 dcl 41 set ref 118*
explain                   5            based           bit(18)                  level 2 packed unaligned dcl 1-22 set ref 360 360*
                                                                                  360 548* 562*
explain_seg                            based           structure                level 1 dcl 50
explain_seg_ptr                 000210 automatic       pointer                  dcl 39 set ref 50 50 50 97* 98 356
expr                                   based           char                     unaligned dcl 609 set ref 683 729 755 757 760 760
                                                                                  761 761 762 762 767 767 768 768 769 769 782 784
                                                                                  789 791 791 846* 1000 1000 1003 1003
exprl                           000106 automatic       fixed bin(17,0)          dcl 608 set ref 609 657* 681 683 701 729 755 757 760
                                                                                  760 761 761 762 762 767 767 768 768 769 769 782
                                                                                  784 789 791 791 846 846 847* 847 1000 1000 1000
                                                                                  1000 1000 1003 1003
exprp                           000104 automatic       pointer                  dcl 607 set ref 609 654* 683 729 755 757 760 760 761
                                                                                  761 762 762 767 767 768 768 769 769 782 784 789
                                                                                  791 791 846* 846 1000 1000 1003 1003
exptext                                based           structure                level 1 dcl 1-34 set ref 563
exptextp                        000272 automatic       pointer                  dcl 1-32 set ref 98* 560 561 561 562 563 563 565*
                                                                                  565 1-34 1-34 1-34
flag_mem                  3(18)        based           char(6)                  level 2 packed unaligned dcl 1-22 set ref 221* 233*
                                                                                  236* 547*
flag_type                       000204 automatic       char(6)                  unaligned dcl 37 set ref 285* 293* 545 547
get_temp_segments_              000026 constant        entry                    external dcl 72 ref 91
get_wdir_                       000036 constant        entry                    external dcl 76 ref 372
have_text                44(02) 000212 automatic       bit(1)                   level 3 packed unaligned dcl 41 set ref 120*
hbound                                                 builtin function         dcl 83 ref 159 193 827
hcs_$initiate_count             000032 constant        entry                    external dcl 74 ref 373 380
hcs_$terminate_noname           000034 constant        entry                    external dcl 75 ref 575
i                               001125 automatic       fixed bin(17,0)          dcl 672 in procedure "parse_expr" set ref 683* 684
                                                                                  689
i                               000422 automatic       fixed bin(17,0)          dcl 448 in procedure "get_word" set ref 457* 458
                                                                                  458* 459* 459 461 462*
i                               000450 automatic       fixed bin(17,0)          dcl 505 in procedure "get_label" set ref 507* 508
                                                                                  510 510* 511* 511 512 513*
i                               000320 automatic       fixed bin(17,0)          dcl 131 in procedure "build_symbol_table" set ref
                                                                                  153* 154 154* 155* 155 156 157* 159* 160 160* 193*
                                                                                  194 194* 198 207* 208* 245* 246 246* 324* 328 332
                                                                                  335
i                               001135 automatic       fixed bin(17,0)          dcl 752 in procedure "parse_sym" set ref 755* 756
                                                                                  757 757* 758* 758 760 760 761 761 762 762 764* 767
                                                                                  767 768 768 769 769 771* 782* 783 784 784* 785*
                                                                                  785 789 791 791 796*
i                               000460 automatic       fixed bin(17,0)          dcl 524 in procedure "make_sym_entry" set ref 527*
                                                                                  528 528* 529* 529 530 530 531 533 533 537* 550*
                                                                                  551 551* 552* 552 553 553 554 554 556* 563* 564
                                                                                  565
i                               000374 automatic       fixed bin(17,0)          dcl 397 in procedure "get_line" set ref 406* 407
                                                                                  407* 408 410 411
i                               000356 automatic       fixed bin(17,0)          dcl 352 in procedure "relocate_explanations" set ref
                                                                                  358* 359*
i                               000412 automatic       fixed bin(17,0)          dcl 434 in procedure "skip_white_space" set ref 436*
                                                                                  437 437* 438* 438 439*
index                                                  builtin function         dcl 83 ref 406 683
ioa_                            000012 constant        entry                    external dcl 66 ref 384
ioa_$general_rs                 000014 constant        entry                    external dcl 67 ref 1014
j                               000100 automatic       fixed bin(17,0)          dcl 327 in begin block on line 325 set ref 332* 333
                                                                                  333* 335* 336 336*
j                               001136 automatic       fixed bin(17,0)          dcl 752 in procedure "parse_sym" set ref 787* 788*
label                           000202 automatic       char(6)                  unaligned dcl 36 set ref 305 307 317 319 508* 512*
                                                                                  533* 541
leftp_token                     000227 constant        fixed bin(17,0)          initial dcl 635 set ref 693* 811 888
len                                    based           fixed bin(8,0)           level 2 in structure "exptext" packed unaligned
                                                                                  dcl 1-34 in procedure "db_fnp_symbols_" set ref
                                                                                  560* 561 563 1-34
len                       2            based           fixed bin(17,0)          level 2 in structure "sym" packed unaligned dcl 1-22
                                                                                  in procedure "db_fnp_symbols_" set ref 184* 218*
                                                                                  543*
len                       2     000212 automatic       fixed bin(18,0)          array level 3 in structure "cds" dcl 41 in procedure
                                                                                  "db_fnp_symbols_" set ref 110* 114*
length                                                 builtin function         dcl 83 ref 150 154 458 510 528 551 560 657 701 757
                                                                                  784 1000 1000 1000
line                                   based           char                     unaligned dcl 46 set ref 150 151 153 154 156 303 315
                                                                                  423* 436 457 458 463 507 510 512 527 528 530 530
                                                                                  531 533 533 550 551 553 553 554 554 560 561
linel                           000116 automatic       fixed bin(17,0)          dcl 26 set ref 46 150 151 153 154 156 303 315 407*
                                                                                  408* 412 423 423 424* 424 425 436 437 450 457 458
                                                                                  463 463 507 510 512 527 528 530 530 531 533 533
                                                                                  550 551 553 553 554 554 560 561
lineno                          000173 automatic       fixed bin(17,0)          initial dcl 30 set ref 30* 162* 181* 196* 210* 275
                                                                                  320* 341* 404* 404 479* 494* 533* 1015*
linep                           000114 automatic       pointer                  dcl 25 set ref 46 143 150 151 153 154 156 298 303
                                                                                  310 315 401* 409* 423* 423 436 457 458 460 463 507
                                                                                  510 512 527 528 530 530 531 533 533 550 551 553
                                                                                  553 554 554 560 561
long_type_names                 000031 constant        char(12)                 initial array unaligned dcl 1-60 ref 193 193 194
macro_name                      000131 constant        char(13)                 initial unaligned dcl 60 set ref 373* 376* 380* 384*
maxcnt                    1            based           fixed bin(17,0)          level 2 dcl 1-14 set ref 214* 249* 539*
mult_token                      000220 constant        fixed bin(17,0)          initial dcl 635 set ref 711* 718* 805 892 907*
n                                      parameter       fixed bin(17,0)          dcl 844 in procedure "adv" ref 842 846 847
n                                      parameter       fixed bin(17,0)          dcl 421 in procedure "adv_line" ref 419 423 424
n                                      parameter       fixed bin(17,0)          dcl 586 in procedure "substraddr" ref 583 587 589
n                                      parameter       fixed bin(17,0)          dcl 980 in procedure "del_token" ref 978 984
n_add                           000113 automatic       fixed bin(17,0)          dcl 614 set ref 883* 890* 893* 893 906 908 908*
n_exp_words                     000206 automatic       fixed bin(17,0)          initial dcl 38 set ref 38* 110 350 354 357 564* 564
n_mult                          000112 automatic       fixed bin(17,0)          dcl 613 set ref 883* 890* 892* 892 906 907 907*
name                            000135 constant        char(16)                 initial unaligned dcl 59 in procedure
                                                                                  "db_fnp_symbols_" set ref 91* 93* 116 122* 145*
                                                                                  162* 181* 196* 210* 299* 311* 341* 376* 384* 479*
                                                                                  494* 533* 576* 1015*
name                                   based           char(6)                  level 2 in structure "sym" packed unaligned dcl 1-22
                                                                                  in procedure "db_fnp_symbols_" set ref 181* 196*
                                                                                  209 216* 477 541* 789
next                            001254 automatic       fixed bin(17,0)          dcl 981 in procedure "del_token" set ref 986* 987
                                                                                  990 991
next                      0(09)        based           fixed bin(8,0)           level 2 in structure "token" packed unaligned
                                                                                  dcl 626 in procedure "eval" set ref 828* 832* 865
                                                                                  894 931 950 951 986 990*
nl                              000141 constant        char(1)                  initial unaligned dcl 57 ref 406
nparen                          001124 automatic       fixed bin(17,0)          dcl 671 set ref 677* 694* 694 700 705* 705 737
ntoken                          000102 automatic       fixed bin(17,0)          dcl 606 set ref 674* 827 828 828 829* 829 830 831
                                                                                  859 993* 993
null                                                   builtin function         dcl 83 ref 87 88 113 118 143 298 310 374 381 401 452
                                                                                  575 576
num_exclude_names        40     000212 automatic       fixed bin(17,0)          level 2 dcl 41 set ref 117*
op                                     based           structure                level 1 packed unaligned dcl 1-99
opname                          000321 automatic       char(16)                 unaligned dcl 132 set ref 156* 160 162* 341*
opp                             000300 automatic       pointer                  dcl 1-97 ref 1-99 1-99 1-99 1-99 1-99 1-99
p                               001256 automatic       pointer                  dcl 982 in procedure "del_token" set ref 984* 985
                                                                                  986 989* 990 991* 992
p                               001140 automatic       pointer                  dcl 753 in procedure "parse_sym" set ref 788* 789
                                                                                  795
p                               001244 automatic       pointer                  dcl 947 in procedure "compute_op" set ref 951* 952
                                                                                  953* 954
p                               000352 automatic       pointer                  dcl 351 in procedure "relocate_explanations" set ref
                                                                                  355* 357
p                               000212 automatic       pointer                  array level 3 in structure "cds" dcl 41 in procedure
                                                                                  "db_fnp_symbols_" set ref 109* 113*
p                               000200 automatic       pointer                  dcl 1011 in procedure "err" set ref 1013* 1014*
pad                       5(18)        based           bit(18)                  level 2 packed unaligned dcl 1-22 set ref 549*
prev                            001255 automatic       fixed bin(17,0)          dcl 981 in procedure "del_token" set ref 985* 987
                                                                                  989 992
prev                                   based           fixed bin(8,0)           level 2 in structure "token" packed unaligned
                                                                                  dcl 626 in procedure "eval" set ref 831* 953 967
                                                                                  985 992*
ptr_array                       000110 automatic       pointer                  array dcl 24 set ref 87* 91* 96 97 576 576*
q                               000354 automatic       pointer                  dcl 351 set ref 356* 357
r_sw                            000325 automatic       bit(1)                   unaligned dcl 133 set ref 265* 269* 325
rel                                                    builtin function         dcl 83 ref 562
release_temp_segments_          000030 constant        entry                    external dcl 73 ref 576
reloc                     2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-22 set ref 171* 219*
                                                                                  544*
reloc_abs                       000216 constant        fixed bin(17,0)          initial dcl 1-40 ref 219 284 288 488
reloc_hwcm                      000230 constant        fixed bin(17,0)          initial dcl 1-40 ref 491
reloc_meters                    000226 constant        fixed bin(17,0)          initial dcl 1-40 ref 492
reloc_sfcm                      000220 constant        fixed bin(17,0)          initial dcl 1-40 ref 490
reloc_tib                       000227 constant        fixed bin(17,0)          initial dcl 1-40 ref 489
reloc_type                      000175 automatic       fixed bin(17,0)          dcl 32 set ref 171 284* 288* 488* 489* 490* 491*
                                                                                  492* 544
rest                                   based           char                     unaligned dcl 47 set ref 406 410*
restl                           000106 automatic       fixed bin(17,0)          dcl 23 set ref 47 274 323* 388* 400 406 407 410 410
                                                                                  411* 411
restp                           000104 automatic       pointer                  dcl 22 set ref 47 272 322* 387* 406 409 410* 410
result                          000100 automatic       fixed bin(17,0)          dcl 604 set ref 665 866*
rightp_token                    000230 constant        fixed bin(17,0)          initial dcl 635 set ref 704* 817 887
s                               000100 automatic       char(256)                unaligned dcl 1010 set ref 1014* 1015*
save_restl                      000340 automatic       fixed bin(17,0)          dcl 139 set ref 274* 323
save_restp                      000336 automatic       pointer                  dcl 138 set ref 272* 322
search                                                 builtin function         dcl 83 ref 153 457 507 527 550 782
sections                        000212 automatic       structure                array level 2 unaligned dcl 41
seg_name                 30     000212 automatic       char(32)                 level 2 packed unaligned dcl 41 set ref 116*
segl                            000102 automatic       fixed bin(17,0)          dcl 21 set ref 386* 388
segp                            000100 automatic       pointer                  dcl 20 set ref 88* 373* 374 380* 381 387 575 575*
short_type_names                000020 constant        char(4)                  initial array unaligned dcl 1-62 ref 194
size                                                   builtin function         dcl 83 ref 110 355 360 563
start_cnt                       000326 automatic       fixed bin(17,0)          dcl 134 set ref 276* 324 333
start_lineno                    000334 automatic       fixed bin(17,0)          dcl 137 set ref 275* 299* 311* 320
start_sym                       000330 automatic       char(6)                  unaligned dcl 135 set ref 280* 299* 305
start_token                     000216 constant        fixed bin(17,0)          initial dcl 635 set ref 675* 698 811
statement_name                  000065 constant        char(16)                 initial array unaligned dcl 61 ref 159 160
string                                                 builtin function         dcl 83 set ref 119*
struct_name               3     000212 automatic       char(32)                 array level 3 packed unaligned dcl 41 set ref 112*
                                                                                  115*
sub                       0(27)        based           fixed bin(8,0)           level 2 packed unaligned dcl 626 set ref 712* 719*
                                                                                  729* 730* 834* 956 960
substr                                                 builtin function         dcl 83 set ref 151 156 303 315 463 512 530 530 531
                                                                                  533 533 553 553 554 554 683 729 760 760 761 761
                                                                                  762 762 767 767 768 768 769 769 769 769 773 773*
                                                                                  789 791 791 1000 1000 1000 1000 1003 1003
switches                 44     000212 automatic       structure                level 2 packed unaligned dcl 41 set ref 119*
sym                                    based           structure                level 1 packed unaligned dcl 1-22
sym_offset                      000201 automatic       fixed bin(17,0)          dcl 35 set ref 245 475* 476*
sym_token                       000221 constant        fixed bin(17,0)          initial dcl 635 set ref 723* 775* 793* 817
symbol_table                           based           structure                level 1 dcl 1-14 set ref 110 355 360
symbol_tablep                   000266 automatic       pointer                  dcl 1-12 set ref 96* 109 110 110 144 207 208 214 214
                                                                                  214 215 215 245 246 246 248 248 249 249 249 276
                                                                                  324 333 336 336 355 355 355 358 359 360 360 475
                                                                                  476 539 539 539 540 540 787 788 1-14 1-14 1-14
                                                                                  1-14 1-14 1-14 1-14 1-14 1-14 1-14 1-14 1-14 1-14
symp                            000270 automatic       pointer                  dcl 1-20 set ref 171 181 184 196 198 208* 209 215*
                                                                                  216 217 218 219 220 221 224 233 236 257 260 359*
                                                                                  360 360 360 476* 477 540* 541 542 543 544 545 546
                                                                                  547 548 549 553 554 562 1-22 1-22 1-22 1-22 1-22
                                                                                  1-22 1-22 1-22 1-22
tcur                            000111 automatic       fixed bin(17,0)          dcl 612 set ref 884* 889 894* 895 897 924* 925 931*
                                                                                  932 949 967* 968
temp_table                      000101 automatic       structure                level 1 packed unaligned dcl 328
tend                            000110 automatic       fixed bin(17,0)          dcl 611 set ref 897* 912*
token                                  based           structure                level 1 packed unaligned dcl 626
token_cnt                              parameter       fixed bin(17,0)          dcl 922 set ref 919 926 929* 929
token_list                      000115 automatic       structure                level 1 dcl 617
token_type                             parameter       fixed bin(17,0)          dcl 921 ref 919 927
tokenp                          001114 automatic       pointer                  dcl 624 set ref 626 626 626 626 626 626 698 712 719
                                                                                  729 730 776 795 805 805 811 811 817 817 828 830*
                                                                                  831 832 833 834 835 864* 865* 865 866 885* 887 887
                                                                                  888 892 893 894 895* 925* 927 931 932* 950 951 953
                                                                                  955 956 960 967 968* 969
tstart                          000107 automatic       fixed bin(17,0)          dcl 610 set ref 884* 885 889* 911* 924
type                      3            based           fixed bin(17,0)          level 2 in structure "sym" packed unaligned dcl 1-22
                                                                                  in procedure "db_fnp_symbols_" set ref 198* 220*
                                                                                  545* 546*
type                                   parameter       fixed bin(17,0)          dcl 825 in procedure "new_token" ref 823 833
type                      0(18)        based           fixed bin(8,0)           level 2 in structure "token" packed unaligned
                                                                                  dcl 626 in procedure "eval" set ref 698 805 805
                                                                                  811 811 817 817 833* 887 887 888 892 893 927 955
type_bit                        000064 constant        fixed bin(17,0)          initial dcl 1-49 ref 546
type_oct                        000216 constant        fixed bin(17,0)          initial dcl 1-49 ref 220 545
unspec                                                 builtin function         dcl 83 set ref 248*
val                       1            based           fixed bin(35,0)          level 2 in structure "token" packed unaligned
                                                                                  dcl 626 in procedure "eval" set ref 776* 795* 835*
                                                                                  866 952 954 969*
val                             001134 automatic       fixed bin(35,0)          dcl 750 in procedure "parse_sym" set ref 751 760*
                                                                                  762 762 767* 769 769 773 773 773 776
val1                            001242 automatic       fixed bin(35,0)          dcl 946 set ref 954* 956* 956 957* 957 960* 960 963*
                                                                                  963 969
val2                            001243 automatic       fixed bin(35,0)          dcl 946 set ref 952* 956 957 960 962 963
value                     1(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-22 set ref 217* 224*
                                                                                  257* 260* 542* 553* 554* 795
verify                                                 builtin function         dcl 83 ref 436 755
white_space                     000142 constant        char(2)                  initial unaligned dcl 56 ref 153 436 507 527 550
word                                   based           char                     unaligned dcl 48 set ref 180 184* 194 194 206 209
                                                                                  210* 216 224* 236 260* 279 280 282 283 288 293 477
                                                                                  479* 488 489 490 491 492 494*
wordl                           000200 automatic       fixed bin(17,0)          dcl 34 set ref 48 180 184 184 194 194 206 209 210
                                                                                  210 216 224 224 236 260 260 279 280 282 283 288
                                                                                  293 453* 461* 477 479 479 488 489 490 491 492 494
                                                                                  494
wordp                           000176 automatic       pointer                  dcl 33 set ref 48 180 184 194 194 206 209 210 216
                                                                                  224 236 260 279 280 282 283 288 293 452* 460* 477
                                                                                  479 488 489 490 491 492 494
words                                  based           bit(36)                  array dcl 350 set ref 357* 357

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
cmd_info                               based           structure                level 1 dcl 1-118
cmd_infop                       000302 automatic       pointer                  dcl 1-116
command                                based           char                     unaligned dcl 1-131
db_fnp_opblocks_$               000050 external static fixed bin(17,0)          dcl 1-158
db_fnp_opcodes_$                000046 external static fixed bin(17,0)          dcl 1-88
db_fnp_symbols_$db_fnp_symbols_ 000044 external static fixed bin(17,0)          dcl 1-10
env                                    based           structure                level 1 dcl 1-139
envp                            000304 automatic       pointer                  dcl 1-137
exclude_names                          based           char(32)                 array unaligned dcl 2-18
expr_info                              based           structure                level 1 dcl 1-70
expr_infop                      000274 automatic       pointer                  dcl 1-68
opblock_table                          based           structure                level 1 dcl 1-162
opblock_tablep                  000306 automatic       pointer                  dcl 1-160
operand                                based           char                     unaligned dcl 1-132
optable                                based           structure                level 1 dcl 1-92
optablep                        000276 automatic       pointer                  dcl 1-90
type_addr                              constant        fixed bin(17,0)          initial dcl 1-49
type_char                              constant        fixed bin(17,0)          initial dcl 1-49
type_clock                             constant        fixed bin(17,0)          initial dcl 1-49
type_dec                               constant        fixed bin(17,0)          initial dcl 1-49
type_ebcdic                            constant        fixed bin(17,0)          initial dcl 1-49
type_inst                              constant        fixed bin(17,0)          initial dcl 1-49
type_op                                constant        fixed bin(17,0)          initial dcl 1-49

NAMES DECLARED BY EXPLICIT CONTEXT.
adv                             005566 constant        entry                    internal dcl 842 ref 695 706 713 720 731 764 771 796
adv_line                        003152 constant        entry                    internal dcl 419 ref 152 157 439 462 465 513 537 556
bad_char                        004310 constant        label                    dcl 1000 ref 685 691 698 701 709 716 727 783
build_symbol_table              001103 constant        entry                    internal dcl 129 ref 102
check_reloc                     003407 constant        entry                    internal dcl 486 ref 170 289
clean_up                        004144 constant        entry                    internal dcl 573 ref 89 124
compute_op                      006045 constant        entry                    internal dcl 943 ref 928
db_fnp_symbols_                 000654 constant        entry                    external dcl 16
del_token                       006230 constant        entry                    internal dcl 978 ref 911 912 970 971
done                            001076 constant        label                    dcl 124 ref 94 146 163 182 197 211 301 313 342 377
                                                                                  480 495 535 1016
done_sym_scan                   002357 constant        label                    dcl 320 ref 307
err                             006310 constant        entry                    internal dcl 1008 ref 702 737 739 761 762 768 769
                                                                                  791 827 962 1000 1003
eval                            004242 constant        entry                    internal dcl 596 ref 184 224 260 553
eval_expr                       005623 constant        entry                    internal dcl 857 ref 664
eval_oct                        004261 constant        entry                    internal dcl 650 ref 554
eval_op                         006003 constant        entry                    internal dcl 919 ref 907 908
eval_start                      004275 constant        label                    dcl 654 ref 648
eval_sub_expr                   005760 constant        entry                    internal dcl 904 ref 861
find_sub_expr                   005653 constant        entry                    internal dcl 881 ref 860
get_label                       003517 constant        entry                    internal dcl 503 ref 304 316
get_line                        003064 constant        entry                    internal dcl 395 ref 141 296 308
get_next_line                   003065 constant        label                    dcl 399 ref 412
get_symword                     003320 constant        entry                    internal dcl 472 ref 168 178 191 232 244 256
get_word                        003240 constant        entry                    internal dcl 446 ref 169 179 192 205 223 235 259 278
                                                                                  281 287 292 474
got_type                        001514 constant        label                    dcl 198 ref 194
init_macro_seg                  002611 constant        entry                    internal dcl 370 ref 100
macro_seg_err                   002673 constant        label                    dcl 376 ref 381
make_sym_entry                  003561 constant        entry                    internal dcl 522 ref 306 318
mult_or_add                     005366 constant        entry                    internal dcl 803 ref 698 716 727 739
new_token                       005500 constant        entry                    internal dcl 823 ref 675 693 704 711 718 723 728 741
                                                                                  775 793
next_token                      004647 constant        label                    dcl 734 ref 687 696 707 714 721 732
no_operand                      002465 constant        label                    dcl 341 ref 165 175 188 202 206 229 241 253 277 279
                                                                                  282
parse_expr                      004410 constant        entry                    internal dcl 669 ref 662
parse_op                        000011 constant        label                    array(7) dcl 691 ref 689
parse_sym                       004716 constant        entry                    internal dcl 748 ref 686
read_line                       001104 constant        label                    dcl 141 ref 150 151 173 186 200 227 239 251 263 339
relocate_explanations           002522 constant        entry                    internal dcl 348 ref 104
scan_end_sym                    002263 constant        label                    dcl 308 ref 315 317 319
scan_start_sym                  002170 constant        label                    dcl 296 ref 303 305
skip_white_space                003212 constant        entry                    internal dcl 432 ref 158 515 538 558
start_or_leftp                  005417 constant        entry                    internal dcl 809 ref 716 723
statement_type                  000000 constant        label                    array(9) dcl 165 ref 160
statement_type_8_9              002071 constant        label                    dcl 272 ref 267
substraddr                      004216 constant        entry                    internal dcl 583 ref 410 423 846
sym_found                       005345 constant        label                    dcl 793 ref 789
sym_or_rightp                   005447 constant        entry                    internal dcl 815 ref 685 691 709

NAME DECLARED BY CONTEXT OR IMPLICATION.
lbound                                                 builtin function         ref 193

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10300       10352   10017       10310
Length     17702   10017        52        7313     260           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_fnp_symbols_                     592 external procedure  is an external procedure.  
on unit on line 89                   64 on unit               
build_symbol_table                      internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
begin block on line 325              72 begin block         uses auto adjustable storage.  
relocate_explanations                   internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
init_macro_seg                          internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
get_line                                internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
adv_line                                internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
skip_white_space                        internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
get_word                                internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
get_symword                             internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
check_reloc                             internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
get_label                               internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
make_sym_entry                          internal procedure  shares stack frame of external procedure db_fnp_symbols_.  
clean_up                             84 internal procedure  is called by several nonquick procedures.  
substraddr                           65 internal procedure  is called by several nonquick procedures.  
eval                                835 internal procedure  is called during a stack extension.  
parse_expr                              internal procedure  shares stack frame of internal procedure eval.  
parse_sym                               internal procedure  shares stack frame of internal procedure eval.  
mult_or_add                             internal procedure  shares stack frame of internal procedure eval.  
start_or_leftp                          internal procedure  shares stack frame of internal procedure eval.  
sym_or_rightp                           internal procedure  shares stack frame of internal procedure eval.  
new_token                               internal procedure  shares stack frame of internal procedure eval.  
adv                                     internal procedure  shares stack frame of internal procedure eval.  
eval_expr                               internal procedure  shares stack frame of internal procedure eval.  
find_sub_expr                           internal procedure  shares stack frame of internal procedure eval.  
eval_sub_expr                           internal procedure  shares stack frame of internal procedure eval.  
eval_op                                 internal procedure  shares stack frame of internal procedure eval.  
compute_op                              internal procedure  shares stack frame of internal procedure eval.  
del_token                               internal procedure  shares stack frame of internal procedure eval.  
err                                 196 internal procedure  is called during a stack extension, and is declared options(variable).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 325  000100 j                           begin block on line 325
                         000101 temp_table                  begin block on line 325
db_fnp_symbols_          000100 segp                        db_fnp_symbols_
                         000102 segl                        db_fnp_symbols_
                         000104 restp                       db_fnp_symbols_
                         000106 restl                       db_fnp_symbols_
                         000110 ptr_array                   db_fnp_symbols_
                         000114 linep                       db_fnp_symbols_
                         000116 linel                       db_fnp_symbols_
                         000117 code                        db_fnp_symbols_
                         000120 bit_count                   db_fnp_symbols_
                         000121 dir                         db_fnp_symbols_
                         000173 lineno                      db_fnp_symbols_
                         000174 end_of_line                 db_fnp_symbols_
                         000175 reloc_type                  db_fnp_symbols_
                         000176 wordp                       db_fnp_symbols_
                         000200 wordl                       db_fnp_symbols_
                         000201 sym_offset                  db_fnp_symbols_
                         000202 label                       db_fnp_symbols_
                         000204 flag_type                   db_fnp_symbols_
                         000206 n_exp_words                 db_fnp_symbols_
                         000210 explain_seg_ptr             db_fnp_symbols_
                         000212 cds                         db_fnp_symbols_
                         000257 dummy_symbol_table          db_fnp_symbols_
                         000266 symbol_tablep               db_fnp_symbols_
                         000270 symp                        db_fnp_symbols_
                         000272 exptextp                    db_fnp_symbols_
                         000274 expr_infop                  db_fnp_symbols_
                         000276 optablep                    db_fnp_symbols_
                         000300 opp                         db_fnp_symbols_
                         000302 cmd_infop                   db_fnp_symbols_
                         000304 envp                        db_fnp_symbols_
                         000306 opblock_tablep              db_fnp_symbols_
                         000320 i                           build_symbol_table
                         000321 opname                      build_symbol_table
                         000325 r_sw                        build_symbol_table
                         000326 start_cnt                   build_symbol_table
                         000330 start_sym                   build_symbol_table
                         000332 end_sym                     build_symbol_table
                         000334 start_lineno                build_symbol_table
                         000336 save_restp                  build_symbol_table
                         000340 save_restl                  build_symbol_table
                         000352 p                           relocate_explanations
                         000354 q                           relocate_explanations
                         000356 i                           relocate_explanations
                         000374 i                           get_line
                         000412 i                           skip_white_space
                         000422 i                           get_word
                         000450 i                           get_label
                         000460 i                           make_sym_entry
                         000461 dec_sw                      make_sym_entry
err                      000100 s                           err
                         000200 p                           err
eval                     000100 result                      eval
                         000101 code                        eval
                         000102 ntoken                      eval
                         000104 exprp                       eval
                         000106 exprl                       eval
                         000107 tstart                      eval
                         000110 tend                        eval
                         000111 tcur                        eval
                         000112 n_mult                      eval
                         000113 n_add                       eval
                         000114 dec_sw                      eval
                         000115 token_list                  eval
                         001114 tokenp                      eval
                         001124 nparen                      parse_expr
                         001125 i                           parse_expr
                         001134 val                         parse_sym
                         001135 i                           parse_sym
                         001136 j                           parse_sym
                         001140 p                           parse_sym
                         001240 del1                        compute_op
                         001241 del2                        compute_op
                         001242 val1                        compute_op
                         001243 val2                        compute_op
                         001244 p                           compute_op
                         001254 next                        del_token
                         001255 prev                        del_token
                         001256 p                           del_token

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_e_as              r_ne_as             alloc_cs            enter_begin
leave_begin         call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc
call_int_other      return              tra_ext             alloc_auto_adj      signal              enable
shorten_stack       ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      create_data_segment_          cu_$arg_list_ptr              cv_dec_check_
cv_oct_check_                 get_temp_segments_            get_wdir_                     hcs_$initiate_count
hcs_$terminate_noname         ioa_                          ioa_$general_rs               release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_fnp_opblocks_$             db_fnp_opcodes_$              db_fnp_symbols_$db_fnp_symbols_
error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000653        30 000661        38 000662        87 000663        88 000677        89 000701        91 000723
     92 000744        93 000746        94 000772        96 000773        97 000775        98 000777       100 001001
    102 001002       104 001003       109 001004       110 001006       111 001013       112 001014       113 001017
    114 001021       115 001022       116 001025       117 001030       118 001031       119 001032       120 001033
    121 001035       122 001050       124 001076       125 001102       129 001103       141 001104       143 001105
    144 001111       145 001113       146 001143       148 001144       150 001145       151 001151       152 001157
    153 001163       154 001177       155 001203       156 001205       157 001211       158 001213       159 001214
    160 001221       161 001231       162 001233       163 001267       165 001270       167 001273       168 001276
    169 001277       170 001300       171 001301       172 001310       173 001311       175 001312       177 001315
    178 001320       179 001321       180 001322       181 001330       182 001365       184 001366       185 001414
    186 001415       188 001416       190 001421       191 001424       192 001425       193 001426       194 001433
    195 001454       196 001456       197 001513       198 001514       199 001523       200 001524       202 001525
    204 001530       205 001532       206 001533       207 001542       208 001551       209 001555       210 001563
    211 001623       213 001624       214 001626       215 001633       216 001637       217 001644       218 001647
    219 001652       220 001655       221 001660       222 001663       223 001665       224 001666       226 001714
    227 001715       229 001716       231 001721       232 001724       233 001725       235 001734       236 001735
    238 001743       239 001744       241 001745       243 001750       244 001752       245 001753       246 001763
    247 001776       248 002000       249 002007       250 002014       251 002015       253 002016       255 002021
    256 002024       257 002025       259 002034       260 002035       262 002063       263 002064       265 002065
    267 002066       269 002067       272 002071       274 002073       275 002075       276 002077       277 002101
    278 002104       279 002105       280 002116       281 002122       282 002123       283 002132       284 002136
    285 002140       286 002142       287 002144       288 002145       289 002156       291 002157       292 002161
    293 002162       296 002170       298 002171       299 002175       301 002232       303 002233       304 002241
    305 002242       306 002252       307 002253       308 002263       310 002264       311 002270       313 002325
    315 002326       316 002334       317 002335       318 002346       319 002347       320 002357       322 002361
    323 002363       324 002365       325 002370       328 002375       332 002404       333 002413       334 002431
    335 002433       336 002441       337 002460       338 002463       339 002464       341 002465       342 002521
    348 002522       354 002523       355 002526       356 002534       357 002537       358 002544       359 002553
    360 002557       362 002606       363 002610       370 002611       372 002612       373 002621       374 002663
    375 002667       376 002673       377 002742       379 002743       380 002746       381 003007       384 003014
    386 003055       387 003060       388 003062       389 003063       395 003064       399 003065       400 003066
    401 003070       402 003072       404 003073       406 003074       407 003106       408 003113       409 003115
    410 003116       411 003144       412 003146       413 003151       419 003152       423 003154       424 003202
    425 003205       426 003211       432 003212       436 003213       437 003227       438 003233       439 003235
    440 003237       446 003240       450 003241       451 003245       452 003247       453 003251       454 003252
    457 003253       458 003266       459 003272       460 003274       461 003275       462 003277       463 003301
    465 003313       466 003317       472 003320       474 003321       475 003322       476 003331       477 003335
    478 003344       479 003346       480 003406       486 003407       488 003410       489 003421       490 003430
    491 003437       492 003446       494 003455       495 003515       497 003516       503 003517       507 003520
    508 003534       510 003542       511 003547       512 003551       513 003555       515 003557       516 003560
    522 003561       527 003562       528 003576       529 003602       530 003604       531 003623       533 003631
    535 003701       537 003703       538 003705       539 003706       540 003713       541 003717       542 003722
    543 003725       544 003730       545 003736       546 003747       547 003752       548 003755       549 003760
    550 003763       551 003777       552 004003       553 004005       554 004042       556 004075       557 004100
    558 004103       559 004104       560 004107       561 004113       562 004123       563 004131       564 004137
    565 004140       567 004142       573 004143       575 004151       576 004166       577 004214       583 004215
    589 004231       596 004241       647 004255       648 004257       650 004260       652 004274       654 004275
    657 004300       662 004302       664 004303       665 004304      1000 004310      1003 004357      1020 004404
    669 004410       674 004411       675 004412       677 004414       681 004415       683 004420       684 004432
    685 004433       686 004441       687 004442       689 004443       691 004444       693 004452       694 004454
    695 004455       696 004461       698 004462       700 004501       701 004503       702 004507       704 004523
    705 004525       706 004527       707 004533       709 004534       711 004542       712 004544       713 004550
    714 004554       716 004555       718 004571       719 004573       720 004577       721 004603       723 004604
    727 004614       728 004622       729 004624       730 004636       731 004642       732 004646       734 004647
    737 004650       739 004670       741 004713       742 004715       748 004716       755 004717       756 004733
    757 004735       758 004742       759 004744       760 004746       761 004775       762 005027       764 005067
    765 005072       767 005073       768 005122       769 005154       771 005216       773 005221       775 005230
    776 005232       777 005240       782 005241       783 005253       784 005256       785 005263       787 005265
    788 005275       789 005302       790 005311       791 005313       793 005345       795 005350       796 005363
    797 005365       803 005366       805 005370       809 005417       811 005421       815 005447       817 005451
    823 005500       827 005502       828 005520       829 005531       830 005532       831 005536       832 005545
    833 005550       834 005557       835 005562       836 005565       842 005566       846 005570       847 005617
    848 005622       857 005623       859 005624       860 005627       861 005630       862 005631       864 005632
    865 005634       866 005644       867 005652       881 005653       883 005654       884 005656       885 005661
    887 005664       888 005706       889 005715       890 005717       891 005721       892 005722       893 005733
    894 005743       895 005751       896 005754       897 005755       899 005757       904 005760       906 005761
    907 005765       908 005771       909 005775       911 005776       912 006000       913 006002       919 006003
    924 006005       925 006007       926 006012       927 006015       928 006025       929 006026       931 006031
    932 006040       933 006043       934 006044       943 006045       949 006046       950 006050       951 006057
    952 006067       953 006075       954 006105       955 006113       956 006122       957 006136       958 006144
    960 006145       962 006160       963 006201       967 006204       968 006213       969 006216       970 006223
    971 006225       972 006227       978 006230       984 006232       985 006236       986 006244       987 006252
    989 006261       990 006264       991 006272       992 006276       993 006304       994 006306      1008 006307
   1013 006315      1014 006323      1015 006372      1016 006440


Object Segment >spec>install>1011>db_fnp_symbols_
Created on 02/03/86  1011.2 mst Mon
by GJohnson.SysMaint.a
using create_data_segment_, Version II of Friday, November 30, 1984

        Object    Text    Defs    Link    Symb  Static
Start        0       0   12704   12734   12744   12744
Length   13634   12704      30      10     654       0


3 Definitions:


segname:    db_fnp_symbols_

text|0          db_fnp_symbols_
symb|0          symbol_table


No Links.





                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
