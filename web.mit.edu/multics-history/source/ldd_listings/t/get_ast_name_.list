	COMPILATION LISTING OF SEGMENT get_ast_name_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1522.9 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 get_ast_name_: proc (a_astep, a_sstp, a_sstnp, retstr);
       12 
       13 dcl (a_astep, a_sstp, a_sstnp) ptr;
       14 
       15 dcl  retstr char (*);
  1     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
       16 
  2     1 /* Begin include file sstnt.incl.pl1   */
  2     2 
  2     3 /* Created 10/03/74 by Bernard Greenberg */
  2     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
  2     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
  2     6 
  2     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
  2     8 
  2     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
  2    10 
  2    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
  2    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
  2    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
  2    14     2 nentries fixed bin,				/* number of entries in the sstnt */
  2    15     2 pad1 (5) fixed bin,
  2    16 
  2    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
  2    18      ast_name_offsets,				/* Starting index for names at each level */
  2    19      ast_offsets,					/* Starting rel addr of each AST region */
  2    20      pad2) (0 : 3) fixed bin,
  2    21 
  2    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
  2    23 
  2    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
  2    25 
  2    26 dcl  nm_astep ptr;					/* astep to be used */
  2    27 
  2    28 /* End include file sstnt.incl.pl1 */
       17 
  3     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  3     2 
  3     3 /* Template for an AST entry. Length = 12 words. */
  3     4 
  3     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  3     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  3     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  3     8 
  3     9 dcl  astep ptr;
  3    10 
  3    11 dcl 1 aste based (astep) aligned,
  3    12 
  3    13     (2 fp bit (18),					/* forward  used list rel pointer */
  3    14     2 bp bit (18),					/* backward used list rel pointer */
  3    15 
  3    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  3    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  3    18 
  3    19     2 strp bit (18),				/* rel pointer to process trailer */
  3    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  3    21 
  3    22     2 uid bit (36),					/* segment unique id */
  3    23 
  3    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    25     2 pvtx fixed bin (8),				/* physical volume table index */
  3    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    27 
  3    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  3    29     2 init bit (1),					/* used bit - insure 1 lap */
  3    30     2 gtus bit (1),					/* global transparent usage switch */
  3    31     2 gtms bit (1),					/* global transparent modified switch */
  3    32     2 hc bit (1),					/* hard core segment */
  3    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  3    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  3    35     2 write_access_on bit (1),			/* any sdw allows write access */
  3    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  3    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  3    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  3    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  3    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  3    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  3    42     2 pad1 bit (2),					/* OO */
  3    43     2 dius bit (1),					/* dumper in use switch */
  3    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  3    45     2 dmpr_pad bit (1),
  3    46     2 ehs bit (1),					/* entry hold switch */
  3    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    48     2 dirsw bit (1),				/* directory switch */
  3    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  3    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  3    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  3    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  3    53 
  3    54     2 dtu bit (36),					/* date and time segment last used */
  3    55 
  3    56     2 dtm bit (36),					/* date and time segment last modified */
  3    57 
  3    58 
  3    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    60 
  3    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    62 
  3    63     2 csl bit (9),					/* current segment length in 1024 words units */
  3    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  3    65     2 fms bit (1),					/* file modified switch */
  3    66     2 npfs bit (1),					/* no page fault switch */
  3    67     2 gtpd bit (1),					/* global transparent paging device switch */
  3    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  3    69     2 per_process bit (1),				/* use master quota for this entry */
  3    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  3    71     2 pad2 bit (2),
  3    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  3    73     2 np bit (9),					/* number of pages in core */
  3    74 
  3    75 
  3    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  3    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  3    78     2 damaged bit (1),				/* PC declared segment unusable */
  3    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  3    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  3    81     2 pad3 bit (6),					/* OOOOOOOOO */
  3    82     2 ptsi bit (2),					/* page table size index */
  3    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  3    84 
  3    85 
  3    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  3    87 
  3    88 
  3    89 dcl 1 aste_part aligned based (astep),
  3    90 
  3    91     2 one bit (36) unaligned,				/* fp and bp */
  3    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  3    93     2 three bit (8) unaligned;			/* ptsi and marker */
  3    94 
  3    95 
  3    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  3    97     2 pad1 bit (8*36),
  3    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    99     2 pad2 bit (3*36);
  3   100 
  3   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
       18 
       19 
       20 
       21 	astep = a_astep;
       22 	sstp = a_sstp;
       23 	sstnp = a_sstnp;
       24 
       25 	if fixed (rel (astep), 18) < fixed (rel (sstp -> sst.astap), 18) then do;
       26 fail:	     retstr = "CANNOT GET PATHNAME";
       27 	     return;
       28 	end;
       29 
       30 	if rel (astep) = rel (sstp -> sst.root_astep) then do;
       31 	     retstr = ">";
       32 	     return;
       33 	end;
       34 
       35 	retstr = recurse (astep, length (retstr));
       36 	return;
       37 
       38 recurse:	proc (astep, namel) returns (char (*));
       39 
       40 dcl (ptsi, ra) fixed bin;
       41 dcl  namel fixed bin;
       42 
       43 dcl  astep ptr, name char (32) varying;
       44 
       45 	     ra = fixed (rel (astep), 18);		/* for ease */
       46 	     if ra < fixed (rel (sstp -> sst.astap), 18) then go to fail;
       47 	     do ptsi = 3 to 0 by -1 while (ra < sstnp -> sstnt.ast_offsets (ptsi));
       48 	     end;
       49 	     if ptsi < 0 then go to fail;
       50 
       51 	     if ptsi ^= fixed (astep -> aste.ptsi, 2) then go to fail;
       52 
       53 	     name = sstnp -> sstnt.names (
       54 		divide (ra - sstnp -> sstnt.ast_offsets (ptsi),
       55 		sstnp -> sstnt.ast_sizes (ptsi), 18, 0) +
       56 		sstnp -> sstnt.ast_name_offsets (ptsi));
       57 
       58 	     if length (name) = 0 then name = "CANNOT-GET";
       59 
       60 	     if astep -> aste.par_astep = rel (sstp -> sst.root_astep) then do;
       61 		if length (name) >= namel then return ("");
       62 		else return (">" || name);
       63 	     end;
       64 
       65 
       66 	     if namel = 1 then return (">");
       67 	     if length (name) >= namel then return (
       68 		recurse (ptr (astep, astep -> aste.par_astep),
       69 		namel -1) || ">");
       70 
       71 	     return (recurse (ptr (astep, astep -> aste.par_astep),
       72 		namel - length (name) - 1)
       73 		|| ">" || name);
       74 	end;
       75      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1311.1  get_ast_name_.pl1                 >spec>temp>41-5>get_ast_name_.pl1
16           1    01/22/85  1321.6  sst.incl.pl1                      >spec>temp>41-5>sst.incl.pl1
17           2    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
18           3    01/22/85  1321.5  aste.incl.pl1                     >spec>temp>41-5>aste.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_astep                                parameter       pointer                  dcl 13 ref 11 21
a_sstnp                                parameter       pointer                  dcl 13 ref 11 23
a_sstp                                 parameter       pointer                  dcl 13 ref 11 22
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 2-11 ref 53
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 2-11 ref 47 53
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 2-11 ref 53
astap                    30            based           pointer                  level 2 dcl 1-9 ref 25 46
aste                                   based           structure                level 1 dcl 3-11
astep                                  parameter       pointer                  dcl 43 in procedure "recurse" ref 38 45 51 60 67 67
                                                                                  67 67 71 71 71 71
astep                           000104 automatic       pointer                  dcl 3-9 in procedure "get_ast_name_" set ref 21* 25
                                                                                  30 35*
name                            000102 automatic       varying char(32)         dcl 43 set ref 53* 58 58* 61 62 67 71 71
namel                                  parameter       fixed bin(17,0)          dcl 41 ref 38 61 66 67 67 71
names                    30            based           varying char(32)         array level 2 dcl 2-11 ref 53
par_astep                 2(18)        based           bit(18)                  level 2 packed unaligned dcl 3-11 ref 60 67 67 71 71
ptsi                            000100 automatic       fixed bin(17,0)          dcl 40 in procedure "recurse" set ref 47* 47* 49 51
                                                                                  53 53 53
ptsi                     13(28)        based           bit(2)                   level 2 in structure "aste" packed unaligned
                                                                                  dcl 3-11 in procedure "get_ast_name_" ref 51
ra                              000101 automatic       fixed bin(17,0)          dcl 40 set ref 45* 46 47 53
retstr                                 parameter       char                     unaligned dcl 15 set ref 11 26* 31* 35* 35 35
root_astep               36            based           pointer                  level 2 dcl 1-9 ref 30 60
sst                                    based           structure                level 1 dcl 1-9
sstnp                           000102 automatic       pointer                  dcl 2-9 set ref 23* 47 53 53 53 53
sstnt                                  based           structure                level 1 dcl 2-11
sstp                            000100 automatic       pointer                  dcl 1-7 set ref 22* 25 30 46 60

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
asta                                   based           bit(432)                 array dcl 3-86
aste_part                              based           structure                level 1 dcl 3-89
nm_astep                               automatic       pointer                  dcl 2-26
ptsi_a                                 automatic       fixed bin(17,0)          dcl 2-24
seg_aste                               based           structure                level 1 dcl 3-96
sst_names_$                            external static fixed bin(17,0)          dcl 2-7
sst_seg$                               external static fixed bin(17,0)          dcl 1-6
sstnmx                                 automatic       fixed bin(17,0)          dcl 2-24

NAMES DECLARED BY EXPLICIT CONTEXT.
fail                            000056 constant        label                    dcl 26 ref 46 49 51
get_ast_name_                   000021 constant        entry                    external dcl 11
recurse                         000136 constant        entry                    internal dcl 38 ref 35 67 71

NAMES DECLARED BY CONTEXT OR IMPLICATION.
divide                                                 builtin function         ref 53
fixed                                                  builtin function         ref 25 25 45 46 51
length                                                 builtin function         ref 35 35 58 61 67 71
ptr                                                    builtin function         ref 67 67 71 71
rel                                                    builtin function         ref 25 25 30 30 45 46 60

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       526         536     474         536
Length       744     474        10         172      32           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_ast_name_                        92 external procedure  is an external procedure.  
recurse                             101 internal procedure  uses returns(char(*)) or returns(bit(*)).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_ast_name_            000100 sstp                        get_ast_name_
                         000102 sstnp                       get_ast_name_
                         000104 astep                       get_ast_name_
recurse                  000100 ptsi                        recurse
                         000101 ra                          recurse
                         000102 name                        recurse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_int_this_desc  call_int_other_desc return              tra_ext
shorten_stack       ext_entry_desc      int_entry_desc      return_chars_eis

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS

000000  aa     526000000000

000001  aa     404000000021

000473  aa  076 000 000 000	>

000002  aa     526077777777

000003  aa     464000000000

000004  aa  103 101 116 116	CANN
000005  aa  117 124 055 107	OT-G
000006  aa  105 124 000 000	ET

000007  aa  103 101 116 116	CANN
000010  aa  117 124 040 107	OT G
000011  aa  105 124 040 120	ET P
000012  aa  101 124 110 116	ATHN
000013  aa  101 115 105 000	AME

BEGIN PROCEDURE get_ast_name_
ENTRY TO get_ast_name_                                      STATEMENT 1 ON LINE 11
get_ast_name_: proc (a_astep, a_sstp, a_sstnp, retstr);

000014  at     000004000003
000015  tt     000003000003
000016  ta     000002000000
000017  ta     000014000000
000020  da     000021300000
000021  aa   000140 6270 00	eax7 	96
000022  aa  7 00034 3521 20	epp2 	pr7|28,*
000023  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000024  aa     000010000000
000025  aa     000000000000
000026  aa  6 00042 3735 20	epp7 	pr6|34,*
000027  aa  7 00006 2361 20	ldq  	pr7|6,*
000030  aa   000002 6040 04	tmi  	2,ic		000032
000031  aa   777777 3760 07	anq  	262143,dl
000032  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000033  aa  6 00106 7561 00	stq  	pr6|70
						STATEMENT 1 ON LINE 21
	astep = a_astep;

000034  aa  6 00032 3715 20	epp5 	pr6|26,*
000035  aa  5 00002 3535 20	epp3 	pr5|2,*		a_astep
000036  aa  3 00000 3535 20	epp3 	pr3|0,*		a_astep
000037  aa  6 00104 2535 00	spri3	pr6|68		astep
						STATEMENT 1 ON LINE 22
	sstp = a_sstp;

000040  aa  5 00004 3515 20	epp1 	pr5|4,*		a_sstp
000041  aa  1 00000 3515 20	epp1 	pr1|0,*		a_sstp
000042  aa  6 00100 2515 00	spri1	pr6|64		sstp
						STATEMENT 1 ON LINE 23
	sstnp = a_sstnp;

000043  aa  5 00006 3735 20	epp7 	pr5|6,*		a_sstnp
000044  aa  7 00000 3735 20	epp7 	pr7|0,*		a_sstnp
000045  aa  6 00102 6535 00	spri7	pr6|66		sstnp
						STATEMENT 1 ON LINE 25
	if fixed (rel (astep), 18) < fixed (rel (sstp -> sst.astap), 18) then do;

000046  aa  1 00030 6351 20	eaa  	pr1|24,*		sst.astap
000047  aa   000066 7730 00	lrl  	54
000050  aa  6 00107 7561 00	stq  	pr6|71
000051  aa  3 00000 6351 00	eaa  	pr3|0		astep
000052  aa  6 00110 7551 00	sta  	pr6|72
000053  aa   000066 7730 00	lrl  	54
000054  aa  6 00107 1161 00	cmpq 	pr6|71
000055  aa   000010 6050 04	tpl  	8,ic		000065
						STATEMENT 1 ON LINE 26
fail:	     retstr = "CANNOT GET PATHNAME";

000056  aa  6 00032 3735 20	epp7 	pr6|26,*
000057  aa  7 00010 3715 20	epp5 	pr7|8,*
000060  aa  6 00106 2351 00	lda  	pr6|70
000061  aa  040 140 100 404	mlr  	(ic),(pr,rl),fill(040)
000062  aa   777726 00 0023	desc9a	-42,19		000007 = 103101116116
000063  aa  5 00000 00 0005	desc9a	pr5|0,al		retstr
						STATEMENT 1 ON LINE 27
	     return;

000064  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 28
	end;

						STATEMENT 1 ON LINE 30
	if rel (astep) = rel (sstp -> sst.root_astep) then do;

000065  aa  1 00036 6351 20	eaa  	pr1|30,*		sst.root_astep
000066  aa  6 00110 1151 00	cmpa 	pr6|72
000067  aa   000007 6010 04	tnz  	7,ic		000076
						STATEMENT 1 ON LINE 31
	     retstr = ">";

000070  aa  5 00010 3535 20	epp3 	pr5|8,*
000071  aa  6 00106 2361 00	ldq  	pr6|70
000072  aa  040 140 100 404	mlr  	(ic),(pr,rl),fill(040)
000073  aa   000401 00 0001	desc9a	257,1		000473 = 076000000000
000074  aa  3 00000 00 0006	desc9a	pr3|0,ql		retstr
						STATEMENT 1 ON LINE 32
	     return;

000075  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 33
	end;

						STATEMENT 1 ON LINE 35
	retstr = recurse (astep, length (retstr));

000076  aa  6 00106 2361 00	ldq  	pr6|70
000077  aa  6 00110 7561 00	stq  	pr6|72
000100  aa  6 00104 3521 00	epp2 	pr6|68		astep
000101  aa  6 00114 2521 00	spri2	pr6|76
000102  aa  6 00110 3521 00	epp2 	pr6|72
000103  aa  6 00116 2521 00	spri2	pr6|78
000104  aa  6 00132 3521 00	epp2 	pr6|90
000105  aa  6 00120 2521 00	spri2	pr6|80
000106  aa   777675 3520 04	epp2 	-67,ic		000003 = 464000000000
000107  aa  6 00124 2521 00	spri2	pr6|84
000110  aa   777671 3520 04	epp2 	-71,ic		000001 = 404000000021
000111  aa  6 00126 2521 00	spri2	pr6|86
000112  aa  6 00111 3521 00	epp2 	pr6|73
000113  aa  6 00130 2521 00	spri2	pr6|88
000114  aa  6 00112 6211 00	eax1 	pr6|74
000115  aa   014000 4310 07	fld  	6144,dl
000116  aa   000020 3520 04	epp2 	16,ic		000136 = 000160627000
000117  aa  0 00624 7001 00	tsx0 	pr0|404		call_int_this_desc
000120  aa  6 00111 2361 00	ldq  	pr6|73
000121  aa   000002 6040 04	tmi  	2,ic		000123
000122  aa   777777 3760 07	anq  	262143,dl
000123  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000124  aa  6 00032 3735 20	epp7 	pr6|26,*
000125  aa  7 00010 3715 20	epp5 	pr7|8,*
000126  aa  6 00132 3535 20	epp3 	pr6|90,*
000127  aa  6 00106 2351 00	lda  	pr6|70
000130  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000131  aa  3 00000 00 0006	desc9a	pr3|0,ql
000132  aa  5 00000 00 0005	desc9a	pr5|0,al		retstr
						STATEMENT 1 ON LINE 36
	return;

000133  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000134  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 75
     end;

BEGIN PROCEDURE recurse
ENTRY TO recurse                                            STATEMENT 1 ON LINE 38
recurse:	proc (astep, namel) returns (char (*));

000135  da     000026220000
000136  aa   000160 6270 00	eax7 	112
000137  aa  7 00034 3521 20	epp2 	pr7|28,*
000140  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
000141  aa     000006000000
000142  aa     000000000000
						STATEMENT 1 ON LINE 45
	     ra = fixed (rel (astep), 18);

000143  aa  6 00032 3735 20	epp7 	pr6|26,*
000144  aa  7 00002 3715 20	epp5 	pr7|2,*		astep
000145  aa  5 00000 3715 20	epp5 	pr5|0,*		astep
000146  aa  5 00000 6351 00	eaa  	pr5|0		astep
000147  aa   000066 7730 00	lrl  	54
000150  aa  6 00101 7561 00	stq  	pr6|65		ra
						STATEMENT 1 ON LINE 46
	     if ra < fixed (rel (sstp -> sst.astap), 18) then go to fail;

000151  aa  6 00040 3535 20	epp3 	pr6|32,*
000152  aa  3 00100 3515 20	epp1 	pr3|64,*		sstp
000153  aa  1 00030 6351 20	eaa  	pr1|24,*		sst.astap
000154  aa   000066 7730 00	lrl  	54
000155  aa  6 00101 1161 00	cmpq 	pr6|65		ra
000156  aa   000004 6044 04	tmoz 	4,ic		000162
000157  aa   777677 3520 04	epp2 	-65,ic		000056 = 600032373520
000160  aa   000001 7270 07	lxl7 	1,dl
000161  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 47
	     do ptsi = 3 to 0 by -1 while (ra < sstnp -> sstnt.ast_offsets (ptsi));

000162  aa   000003 2360 07	ldq  	3,dl
000163  aa  6 00100 7561 00	stq  	pr6|64		ptsi
000164  aa  6 00100 2361 00	ldq  	pr6|64		ptsi
000165  aa   000012 6040 04	tmi  	10,ic		000177
000166  aa  6 00101 2361 00	ldq  	pr6|65		ra
000167  aa  6 00040 3735 20	epp7 	pr6|32,*
000170  aa  6 00100 7271 00	lxl7 	pr6|64		ptsi
000171  aa  7 00102 3715 20	epp5 	pr7|66,*		sstnp
000172  aa  5 00020 1161 17	cmpq 	pr5|16,7		sstnt.ast_offsets
000173  aa   000004 6050 04	tpl  	4,ic		000177
						STATEMENT 1 ON LINE 48
	     end;

000174  aa   000001 3360 07	lcq  	1,dl
000175  aa  6 00100 0561 00	asq  	pr6|64		ptsi
000176  aa   777766 7100 04	tra  	-10,ic		000164
						STATEMENT 1 ON LINE 49
	     if ptsi < 0 then go to fail;

000177  aa  6 00100 2361 00	ldq  	pr6|64		ptsi
000200  aa   000004 6050 04	tpl  	4,ic		000204
000201  aa   777655 3520 04	epp2 	-83,ic		000056 = 600032373520
000202  aa   000001 7270 07	lxl7 	1,dl
000203  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 51
	     if ptsi ^= fixed (astep -> aste.ptsi, 2) then go to fail;

000204  aa  6 00032 3735 20	epp7 	pr6|26,*
000205  aa  7 00002 3715 20	epp5 	pr7|2,*		astep
000206  aa  5 00000 3715 20	epp5 	pr5|0,*		astep
000207  aa  5 00013 2351 00	lda  	pr5|11		aste.ptsi
000210  aa   000034 7350 00	als  	28
000211  aa   000106 7730 00	lrl  	70
000212  aa  6 00100 1161 00	cmpq 	pr6|64		ptsi
000213  aa   000004 6000 04	tze  	4,ic		000217
000214  aa   777642 3520 04	epp2 	-94,ic		000056 = 600032373520
000215  aa   000001 7270 07	lxl7 	1,dl
000216  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 53
	     name = sstnp -> sstnt.names (
		divide (ra - sstnp -> sstnt.ast_offsets (ptsi),
		sstnp -> sstnt.ast_sizes (ptsi), 18, 0) +
		sstnp -> sstnt.ast_name_offsets (ptsi));

000217  aa  6 00101 2361 00	ldq  	pr6|65		ra
000220  aa  6 00040 3735 20	epp7 	pr6|32,*
000221  aa  6 00100 7271 00	lxl7 	pr6|64		ptsi
000222  aa  7 00102 3715 20	epp5 	pr7|66,*		sstnp
000223  aa  5 00020 1761 17	sbq  	pr5|16,7		sstnt.ast_offsets
000224  aa  5 00010 5061 17	div  	pr5|8,7		sstnt.ast_sizes
000225  aa  5 00014 0761 17	adq  	pr5|12,7		sstnt.ast_name_offsets
000226  aa   000011 4020 07	mpy  	9,dl
000227  aa   000000 6260 06	eax6 	0,ql
000230  aa  5 00030 2361 06	ldq  	pr5|24,ql		sstnt.names
000231  aa  5 00031 3535 16	epp3 	pr5|25,6		sstnt.names
000232  aa  6 00102 7561 00	stq  	pr6|66		name
000233  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000234  aa  3 00000 00 0006	desc9a	pr3|0,ql		sstnt.names
000235  aa  6 00103 00 0006	desc9a	pr6|67,ql		name
						STATEMENT 1 ON LINE 58
	     if length (name) = 0 then name = "CANNOT-GET";

000236  aa  6 00102 2361 00	ldq  	pr6|66		name
000237  aa   000006 6010 04	tnz  	6,ic		000245
000240  aa   000012 2360 07	ldq  	10,dl
000241  aa  6 00102 7561 00	stq  	pr6|66		name
000242  aa  040 140 100 444	mlr  	(rl,ic),(pr,rl),fill(040)
000243  aa   777542 00 0006	desc9a	-158,ql		000004 = 103101116116
000244  aa  6 00103 00 0006	desc9a	pr6|67,ql		name
						STATEMENT 1 ON LINE 60
	     if astep -> aste.par_astep = rel (sstp -> sst.root_astep) then do;

000245  aa  6 00032 3515 20	epp1 	pr6|26,*
000246  aa  1 00002 3535 20	epp3 	pr1|2,*		astep
000247  aa  3 00000 3535 20	epp3 	pr3|0,*		astep
000250  aa  3 00002 2351 00	lda  	pr3|2		aste.par_astep
000251  aa   000022 7350 00	als  	18
000252  aa  6 00113 7551 00	sta  	pr6|75		aste.par_astep
000253  aa  7 00100 3715 20	epp5 	pr7|64,*		sstp
000254  aa  5 00036 6351 20	eaa  	pr5|30,*		sst.root_astep
000255  aa  6 00113 1151 00	cmpa 	pr6|75		aste.par_astep
000256  aa   000034 6010 04	tnz  	28,ic		000312
						STATEMENT 1 ON LINE 61
		if length (name) >= namel then return ("");

000257  aa  6 00102 2361 00	ldq  	pr6|66		name
000260  aa  1 00004 1161 20	cmpq 	pr1|4,*		namel
000261  aa   000011 6040 04	tmi  	9,ic		000272
000262  aa   000000 2360 07	ldq  	0,dl
000263  aa  6 00042 3715 20	epp5 	pr6|34,*
000264  aa   526000 2760 03	orq  	175104,du
000265  aa  5 00004 7561 20	stq  	pr5|4,*
000266  aa   000000 2360 07	ldq  	0,dl
000267  aa   000000 7200 07	lxl0 	0,dl
000270  aa   000203 3520 04	epp2 	131,ic		000473 = 076000000000
000271  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 62
		else return (">" || name);

000272  aa   000001 0760 07	adq  	1,dl
000273  aa  6 00042 3715 20	epp5 	pr6|34,*
000274  aa  6 00114 7561 00	stq  	pr6|76
000275  aa   526000 2760 03	orq  	175104,du
000276  aa  5 00004 7561 20	stq  	pr5|4,*
000277  aa  6 00114 2361 00	ldq  	pr6|76
000300  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_cs
000301  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000302  aa   000172 00 0001	desc9a	122,1		000473 = 076000000000
000303  aa  2 00000 00 0001	desc9a	pr2|0,1
000304  aa  6 00102 7251 00	lxl5 	pr6|66		name
000305  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000306  aa  6 00103 00 0015	desc9a	pr6|67,x5		name
000307  aa  2 00000 20 0015	desc9a	pr2|0(1),x5
000310  aa   000000 7200 07	lxl0 	0,dl
000311  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 63
	     end;

						STATEMENT 1 ON LINE 66
	     if namel = 1 then return (">");

000312  aa  1 00004 2361 20	ldq  	pr1|4,*		namel
000313  aa   000001 1160 07	cmpq 	1,dl
000314  aa   000011 6010 04	tnz  	9,ic		000325
000315  aa   000001 2360 07	ldq  	1,dl
000316  aa  6 00042 3715 20	epp5 	pr6|34,*
000317  aa   526000 2760 03	orq  	175104,du
000320  aa  5 00004 7561 20	stq  	pr5|4,*
000321  aa   000001 2360 07	ldq  	1,dl
000322  aa   000000 7200 07	lxl0 	0,dl
000323  aa   000150 3520 04	epp2 	104,ic		000473 = 076000000000
000324  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 67
	     if length (name) >= namel then return (
		recurse (ptr (astep, astep -> aste.par_astep),
		namel -1) || ">");

000325  aa  6 00102 1161 00	cmpq 	pr6|66		name
000326  aa   000056 6054 04	tpnz 	46,ic		000404
000327  aa  6 00113 2351 00	lda  	pr6|75		aste.par_astep
000330  aa  3 00000 3521 00	epp2 	pr3|0
000331  aa   000000 3120 01	eawp2	0,au
000332  aa  6 00116 2521 00	spri2	pr6|78
000333  aa   000001 1760 07	sbq  	1,dl
000334  aa  6 00115 7561 00	stq  	pr6|77
000335  aa  6 00116 3521 00	epp2 	pr6|78
000336  aa  6 00122 2521 00	spri2	pr6|82
000337  aa  6 00115 3521 00	epp2 	pr6|77
000340  aa  6 00124 2521 00	spri2	pr6|84
000341  aa  6 00140 3521 00	epp2 	pr6|96
000342  aa  6 00126 2521 00	spri2	pr6|86
000343  aa   777440 3520 04	epp2 	-224,ic		000003 = 464000000000
000344  aa  6 00132 2521 00	spri2	pr6|90
000345  aa   777434 3520 04	epp2 	-228,ic		000001 = 404000000021
000346  aa  6 00134 2521 00	spri2	pr6|92
000347  aa  6 00142 3521 00	epp2 	pr6|98
000350  aa  6 00136 2521 00	spri2	pr6|94
000351  aa   000001 7270 07	lxl7 	1,dl
000352  aa  6 00120 6211 00	eax1 	pr6|80
000353  aa   014000 4310 07	fld  	6144,dl
000354  aa   777562 3520 04	epp2 	-142,ic		000136 = 000160627000
000355  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
000356  aa  6 00142 2361 00	ldq  	pr6|98
000357  aa   000002 6040 04	tmi  	2,ic		000361
000360  aa   777777 3760 07	anq  	262143,dl
000361  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000362  aa  6 00115 7561 00	stq  	pr6|77
000363  aa   000001 0760 07	adq  	1,dl
000364  aa  6 00042 3735 20	epp7 	pr6|34,*
000365  aa  6 00143 7561 00	stq  	pr6|99
000366  aa   526000 2760 03	orq  	175104,du
000367  aa  7 00004 7561 20	stq  	pr7|4,*
000370  aa  6 00143 2361 00	ldq  	pr6|99
000371  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_cs
000372  aa  6 00140 3715 20	epp5 	pr6|96,*
000373  aa  6 00115 2351 00	lda  	pr6|77
000374  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000375  aa  5 00000 00 0005	desc9a	pr5|0,al
000376  aa  2 00000 00 0005	desc9a	pr2|0,al
000377  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000400  aa   000074 00 0001	desc9a	60,1		000473 = 076000000000
000401  aa  2 00000 00 0001	desc9a	pr2|0,1
000402  aa   000000 7200 07	lxl0 	0,dl
000403  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 71
	     return (recurse (ptr (astep, astep -> aste.par_astep),
		namel - length (name) - 1)
		|| ">" || name);

000404  aa  6 00113 2351 00	lda  	pr6|75		aste.par_astep
000405  aa   000000 3134 01	eawp3	0,au
000406  aa  6 00140 2535 00	spri3	pr6|96
000407  aa  6 00102 1761 00	sbq  	pr6|66		name
000410  aa   000001 1760 07	sbq  	1,dl
000411  aa  6 00113 7561 00	stq  	pr6|75
000412  aa  6 00140 3521 00	epp2 	pr6|96
000413  aa  6 00122 2521 00	spri2	pr6|82
000414  aa  6 00113 3521 00	epp2 	pr6|75
000415  aa  6 00124 2521 00	spri2	pr6|84
000416  aa  6 00116 3521 00	epp2 	pr6|78
000417  aa  6 00126 2521 00	spri2	pr6|86
000420  aa   777363 3520 04	epp2 	-269,ic		000003 = 464000000000
000421  aa  6 00132 2521 00	spri2	pr6|90
000422  aa   777357 3520 04	epp2 	-273,ic		000001 = 404000000021
000423  aa  6 00134 2521 00	spri2	pr6|92
000424  aa  6 00142 3521 00	epp2 	pr6|98
000425  aa  6 00136 2521 00	spri2	pr6|94
000426  aa   000001 7270 07	lxl7 	1,dl
000427  aa  6 00120 6211 00	eax1 	pr6|80
000430  aa   014000 4310 07	fld  	6144,dl
000431  aa   777505 3520 04	epp2 	-187,ic		000136 = 000160627000
000432  aa  0 00626 7001 00	tsx0 	pr0|406		call_int_other_desc
000433  aa  6 00142 2361 00	ldq  	pr6|98
000434  aa   000002 6040 04	tmi  	2,ic		000436
000435  aa   777777 3760 07	anq  	262143,dl
000436  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000437  aa  6 00113 7561 00	stq  	pr6|75
000440  aa   000001 0760 07	adq  	1,dl
000441  aa  6 00115 7561 00	stq  	pr6|77
000442  aa  6 00102 0761 00	adq  	pr6|66		name
000443  aa  6 00042 3735 20	epp7 	pr6|34,*
000444  aa  6 00144 7561 00	stq  	pr6|100
000445  aa   526000 2760 03	orq  	175104,du
000446  aa  7 00004 7561 20	stq  	pr7|4,*
000447  aa  6 00115 2361 00	ldq  	pr6|77
000450  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_cs
000451  aa  6 00116 3715 20	epp5 	pr6|78,*
000452  aa  6 00113 2351 00	lda  	pr6|75
000453  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000454  aa  5 00000 00 0005	desc9a	pr5|0,al
000455  aa  2 00000 00 0005	desc9a	pr2|0,al
000456  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000457  aa   000015 00 0001	desc9a	13,1		000473 = 076000000000
000460  aa  2 00000 00 0001	desc9a	pr2|0,1
000461  aa  6 00144 2361 00	ldq  	pr6|100
000462  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_cs
000463  aa  6 00115 2351 00	lda  	pr6|77
000464  aa  6 00102 7271 00	lxl7 	pr6|66		name
000465  aa  040 145 100 540	mlr  	(pr,rl),(pr,rl,al),fill(040)
000466  aa  6 00103 00 0017	desc9a	pr6|67,x7		name
000467  aa  2 00000 00 0017	desc9a	pr2|0,x7
000470  aa  6 00144 2361 00	ldq  	pr6|100
000471  aa   000000 7200 07	lxl0 	0,dl
000472  aa  0 01235 7101 00	tra  	pr0|669		return_chars_eis
						STATEMENT 1 ON LINE 74
	end;

  END PROCEDURE recurse
  END PROCEDURE get_ast_name_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
