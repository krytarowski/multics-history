	COMPILATION LISTING OF SEGMENT exercise_disk
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/28/86  1515.8 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
       15*     audit(86-02-18,Coppola), install(86-07-18,MR12.0-1098):
       16*     Support FIPS.
       17*  2) change(86-01-16,Fawcett), approve(86-04-10,MCR7383),
       18*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
       19*     Add support for 512_WORD_IO devices.
       20*  3) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
       21*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
       22*     Changed to use version constant in rcp_disk_info.incl.pl1
       23*  4) change(86-10-21,Fawcett), approve(86-10-21,PBF7383),
       24*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
       25*     Change the d338 to 3380 and d339 to 3381.
       26*                                                   END HISTORY COMMENTS */
       27 
       28 exercise_disk: proc;
       29 
       30 
       31 /* Written by B. Greenberg sometime in '75 */
       32 /* Modified by P.B. Kelley 02/05/79 - to add the "-all" control argument.	  	*/
       33 /*	The sector ranges were changed to NOT include those in the ALT partition,	*/
       34 /*	unless the  "-all" control argument were given.				*/
       35 /* Modified by Michael R. Jordan 1/80  to add -system (-sys) */
       36 
       37 
       38 /* ********************************************************
       39*   *    Completely re-written July 1980 by R.L. Coppola   *
       40*   ******************************************************** */
       41 
       42 /*  Modified 5/81 by Rich Coppola to remove PL1 I/O. */
       43 /*  Modified 5/81 by Rich Coppola to add -no_write_compare (-nwc) */
       44 /*  Modified 5/81 by Rich coppola to call analyze_detail_stat_ to have
       45*   detailed status interpreted. */
       46 /*  Modified Oct 1982 by Rich Coppola to change call to analyze_detail_stat_
       47*   to use new calling sequence.
       48**/
       49 /*  Modified 6/85 by Rich Fawcett
       50*	   to use only 512_seeks for MSU3380s and MSU3381s and delete MSU0509 */
       51 /* ****************************************************************************
       52*   *   This test is intended to be an extension of the standard T&D's.	 *
       53*   *   when they cannot reproduce a problem the FER should invoke this 	 *
       54*   *   test to attempt to replicate the problem experienced by the customer.	 *
       55*   *   This test uses the write and verify command to ensure that,
       56*   *   as much as possible, all error conditions are captured.
       57*   *
       58*   **************************************************************************** */
       59 
       60 
       61 
       62 /* Subroutine entry declarations */
       63 
       64 
       65 	dcl     iox_$find_iocb	 entry (char (*), ptr, fixed bin (35));
       66 
       67 	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
       68 
       69 	dcl     analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);
       70 
       71 	dcl     analyze_detail_stat_$rsnnl entry (char (*), bit (36) aligned, bit (*) unal, char (*) var, bit (1), fixed bin (35));
       72 
       73 	dcl     disk_status_table_$disk_status_table_ ext;
       74 
       75 	dcl     clock_		 entry returns (fixed bin (52));
       76 
       77 	dcl     command_query_	 entry options (variable);
       78 
       79 	dcl     error_table_$badopt	 external fixed bin (35);
       80 
       81 	dcl     error_table_$noarg	 external fixed bin (35);
       82 
       83 
       84 	dcl     error_table_$device_parity fixed bin (35) ext static;
       85 
       86 	dcl     com_err_		 entry options (variable);
       87 
       88 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
       89 
       90 	dcl     cu_$arg_count	 entry () returns (fixed bin);
       91 
       92 	dcl     date_time_		 entry (fixed bin (52), char (*));
       93 
       94 	dcl     ioa_		 entry options (variable);
       95 
       96 	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
       97 
       98 	dcl     error_table_$wrong_no_of_args fixed bin (35) ext static;
       99 
      100 
      101 /* Automatic */
      102 
      103 	dcl     dt		 char (24);
      104 	dcl     code		 fixed bin (35);
      105 	dcl     argptr		 ptr,		/* Pointers to input args  */
      106 	        argcnt		 fixed bin,	/* number of args */
      107 	        arglen		 fixed bin,	/* Lengths of input args  */
      108 	        arg		 char (arglen) based (argptr),
      109 	        arg_sw		 bit (1) init ("1"b);
      110 	dcl     i			 fixed bin;	/* iteration var's */
      111 	dcl     arg1		 char (8) varying;
      112 	dcl     pack_id		 char (12);
      113 	dcl     (from_sw, to_sw, dev_sw) bit (1) init ("0"b);
      114 	dcl     (from, to_)		 fixed bin (24);
      115 	dcl     dev_idx		 fixed bin;
      116 	dcl     words_per_sector	 fixed bin init (64);
      117 	dcl     (a, seek_counter)	 fixed bin;	/* counter) for the write read pass */
      118 	dcl     (x, y, sectors_written, sectors_read, highest_sector, loest_sector) fixed bin (24);
      119 	dcl     seek_addr_read	 fixed bin (24);
      120 	dcl     to_sector		 fixed bin (24);
      121 	dcl     device_type		 char (4);
      122 	dcl     model_num		 fixed bin;
      123 
      124 	dcl     1 my_key1,
      125 		2 key1_len	 fixed bin init (8),
      126 		2 f91		 pic "99999999";
      127 
      128 	dcl     1 my_key2,
      129 		2 key2_len	 fixed bin init (8),
      130 		2 f92		 pic "99999999";
      131 
      132 	dcl     key1		 char (256) var based (addr (my_key1));
      133 	dcl     key2		 char (256) var based (addr (my_key2));
      134 	dcl     (data_init_sw, compare_err) bit (1) init ("0"b);
      135 	dcl     constant_		 bit (36) init ("0"b);
      136 	dcl     doing		 char (5) var init ("");
      137 	dcl     (cleanup, program_interrupt) condition;
      138 	dcl     (ii, err_cnt)	 fixed bin init (0);
      139 	dcl     system		 char (4) varying init ("");
      140 	dcl     write_compare	 char (7) varying init ("wrtcmp");
      141 	dcl     (rec_len, read_data_len) fixed bin (21);
      142 
      143 
      144 	dcl     1 errors		 (50) aligned,
      145 		2 iom_status_	 bit (72),
      146 		2 det_status	 (11) bit (8) unal,
      147 		2 dev_cmd_	 fixed bin,
      148 		2 seek_addr_	 fixed bin (24);
      149 
      150 	dcl     (quit_flag, ndc_sw, alt_sw) bit (1) init ("0"b);
      151 	dcl     (random_sw, read_sw, write_sw) bit (1);	/* bit switches for program modes */
      152 	dcl     (seq_sw, range_sw, dev_evn, dev_attached, dev_open) bit (1) init ("0"b);
      153 	dcl     mode_string		 char (11);	/* string storage for ioa_ */
      154 	dcl     (write_errors, read_errors, read_cmp_err, seek_errors) fixed bin;
      155 	dcl     answer		 char (32) varying;
      156 	dcl     (data_bufp, read_ptr, stat_tablep, iocbp, dev_infop, dev_statp, querie) ptr;
      157 	dcl     (sa1, sn1, cn1, hn1, seek, seek1, seek2) fixed bin (24);
      158 	dcl     (PC, PH, epc, opc)	 fixed bin (24);
      159 
      160 	dcl     1 device_info	 aligned,		/* my dev info from exdim_ */
      161 		2 dev_type_	 char (4),	/* the model number */
      162 		2 dev_name	 char (8),	/* i.e. dskx_xx */
      163 		2 sect_per_dev_	 fixed bin (35),
      164 		2 cyl_per_dev_	 fixed bin,
      165 		2 sect_per_cyl_	 fixed bin,
      166 		2 sect_per_track_	 fixed bin,
      167 		2 num_label_sect_	 fixed bin,
      168 		2 num_alt_sect_	 fixed bin,
      169 		2 sect_size_	 fixed bin (12);
      170 
      171 	dcl     1 device_status_info	 aligned,		/* device status info */
      172 		2 iom_status	 bit (72),
      173 		2 detail_status	 (11) bit (8) unal,
      174 		2 dev_cmd		 fixed bin,
      175 		2 seek_addr	 fixed bin (24);
      176 
      177 	dcl     device_name		 char (8);
      178 	dcl     open_mode		 fixed bin init (13); /* assume write oper. */
      179 	dcl     options_ptr		 ptr;
      180 	dcl     1 options_,
      181 		2 num_opts	 fixed bin,
      182 		2 options		 (6) char (32) varying;
      183 
      184 
      185 /* Static */
      186 
      187 	dcl     myname		 char (13) init ("exercise_disk") static options (constant);
      188 	dcl     str1		 bit (4) init ("1101"b) static options (constant);
      189 	dcl     str2		 bit (4) init ("1011"b) static options (constant);
      190 	dcl     str3		 bit (4) init ("0110"b) static options (constant);
      191 	dcl     err_retry		 fixed bin static init (0);
      192 	dcl     cmd_tbl		 (26:28) char (1) int static options (constant) init
      193 				 ("R", "W", "S");
      194 	dcl     TRUE		 bit (1) int static options (constant) init ("1"b);
      195 	dcl     FALSE		 bit (1) int static options (constant) init ("0"b);
      196 	dcl     test_in_progress	 fixed bin internal static;
      197 	dcl     d500_sw		 bit (1) init ("0"b);
      198 
      199 
      200 /* Based */
      201 
      202 	dcl     data		 (0:(words_per_sector - 1)) bit (36) based (data_bufp) aligned;
      203 	dcl     read_data		 (0:(words_per_sector - 1)) bit (36) based (read_ptr);
      204 
      205 /* Builtins */
      206 
      207 	dcl     (addr, addrel, bin, bit, ceil, char, clock, divide, fixed, floor, hbound, index, length, ltrim, max, min, mod, null, rel, rtrim, substr, unspec) builtin;
      208 
      209 
      210 	if test_in_progress = -1 then do;
      211 		call com_err_ (0, myname, "exercise_disk has been recursively invoked ");
      212 		call com_err_ (0, myname, "enter the release (rl) command and re-call");
      213 		return;
      214 	     end;
      215 
      216 /*                  Housekeeping                  */
      217 
      218 	stat_tablep = addr (disk_status_table_$disk_status_table_);
      219 	device_name = "";
      220 	sectors_written, sectors_read, write_errors = 0;
      221 	read_errors, seek_errors, read_cmp_err = 0;
      222 	querie = addr (query_info);
      223 	yes_or_no_sw = TRUE;
      224 	repeat_time = 60;
      225 	cp_escape_control = "11"b;			/* allow cp escape */
      226 	suppress_name_sw = FALSE;
      227 	constant_ = str1 || str2 || str3 || str1 || str2 || str3 || str1 || str2 || str3;
      228 	data_bufp = null;
      229 	read_ptr = null;
      230 	from, to_, loest_sector = 0;
      231 
      232 
      233 	on cleanup begin;
      234 		call EXIT;
      235 		test_in_progress = 0;
      236 	     end;
      237 
      238 	argcnt = cu_$arg_count ();
      239 
      240 	if argcnt < 2 then do;
      241 		arg_sw = "0"b;
      242 		code = error_table_$wrong_no_of_args;
      243 		go to bad_arg;
      244 	     end;
      245 
      246 	a = 1;					/* set to get first argument */
      247 	call cu_$arg_ptr (a, argptr, arglen, code);
      248 	if code ^= 0				/* No arg1  */
      249 	then do;
      250 		arg_sw = "0"b;
      251 		go to bad_arg;			/* inform user on correct call */
      252 	     end;
      253 
      254 	arg1, device_type = arg;
      255 						/*        Verify Device Type    */
      256 
      257 	do i = 1 to maxdevt;
      258 	     if device_type = device_names (i) then do;
      259 		     model_num = MODELN (i);
      260 		     if MODELN (i) >= 500 then
      261 			d500_sw = "1"b;
      262 		     dev_idx = i;
      263 		end;
      264 	end;
      265 
      266 
      267 
      268 /*                            Get high sector no.                            */
      269 	highest_sector = get_dev_size (code);
      270 	if code ^= 0
      271 	then go to bad_arg;				/* inform user on correct call */
      272 
      273 
      274 /*                            Get pack Ser No. for Mount MSG.                */
      275 
      276 	a = 2;					/* set up to get second argument */
      277 	call cu_$arg_ptr (a, argptr, arglen, code);
      278 	if code ^= 0
      279 	then do;
      280 		arg_sw = "0"b;
      281 		go to bad_arg;			/* tell him how to invoke */
      282 	     end;
      283 
      284 	pack_id = rtrim (arg);
      285 						/*                            See if there are anymore args                  */
      286 
      287 	random_sw, write_sw, read_sw = TRUE;		/* set defaults */
      288 	seq_sw, range_sw, ndc_sw, alt_sw = FALSE;	/* set defaults */
      289 	from, to_ = 0;
      290 
      291 	if argcnt > 2 then /* process control args if they exist */
      292 	     do a = 3 to argcnt;
      293 
      294 		arg_sw = "1"b;
      295 		call cu_$arg_ptr (a, argptr, arglen, code);
      296 		if code ^= 0
      297 		then go to bad_arg;
      298 
      299 		if arg = "-w" | arg = "-write" then do;
      300 			read_sw = FALSE;		/* turn off read switch */
      301 			write_sw = TRUE;		/* turn on write switch */
      302 
      303 		     end;
      304 
      305 
      306 		else if arg = "-r" | arg = "-read" then do;
      307 			read_sw = TRUE;
      308 			write_sw = FALSE;		/* turn off write switch */
      309 			open_mode = 11;		/* set to read only */
      310 		     end;
      311 
      312 
      313 
      314 
      315 		else if arg = "-wr" | arg = "-write_read" then do; /* default but set them, anyway */
      316 			read_sw = TRUE;
      317 			write_sw = TRUE;
      318 
      319 		     end;
      320 
      321 		else if arg = "-device" |
      322 		     arg = "-dv" then do;		/* he wants to select a specific  drive */
      323 			a = a + 1;		/* bump arg ptr */
      324 			call cu_$arg_ptr (a, argptr, arglen, code);
      325 
      326 			if code ^= 0 then
      327 			     go to bad_arg;
      328 
      329 			if (arglen ^= 7) | (substr (arg, 1, 3) ^= "dsk") then do;
      330 				a = a - 1;
      331 				go to bad_arg;
      332 			     end;
      333 
      334 			else device_name = arg;
      335 			dev_sw = "1"b;
      336 		     end;
      337 
      338 
      339 		else if arg = "-ndc" | arg = "-no_data_compare" then
      340 		     ndc_sw = TRUE;			/* Turn off data compare on read  */
      341 
      342 		else if arg = "-alternate_track" | arg = "-altrk" then /* pack formatted with alt tracks */
      343 		     alt_sw = TRUE;
      344 
      345 
      346 		else if arg = "-random" then /* random option */
      347 		     random_sw = TRUE;
      348 
      349 
      350 		else if arg = "-sequential" | arg = "-sq" then do; /* sequential seek option */
      351 			random_sw = FALSE;
      352 			seq_sw = TRUE;
      353 		     end;
      354 
      355 		else if arg = "-from" | arg = "-fm" then do;
      356 			range_sw = TRUE;
      357 			random_sw = FALSE;
      358 			a = a + 1;
      359 			call cu_$arg_ptr (a, argptr, arglen, code);
      360 
      361 			if code ^= 0 then
      362 			     go to bad_arg;
      363 
      364 			if index (arg, "-") ^= 0
      365 			then go to bad_arg;
      366 
      367 			from = cv_dec_check_ (arg, code);
      368 
      369 			if code ^= 0 then
      370 			     go to bad_arg;
      371 
      372 			loest_sector = get_seek_addr (from, code);
      373 			if code ^= 0 then
      374 			     go to bad_arg;
      375 
      376 			from_sw = TRUE;
      377 		     end;
      378 
      379 		else if arg = "-to" then do;
      380 
      381 			range_sw = TRUE;
      382 			a = a + 1;
      383 			call cu_$arg_ptr (a, argptr, arglen, code);
      384 
      385 			if code ^= 0 then
      386 			     go to bad_arg;
      387 
      388 			if index (arg, "-") ^= 0
      389 			then go to bad_arg;
      390 
      391 			to_ = cv_dec_check_ (arg, code);
      392 
      393 			if code ^= 0 then
      394 			     go to bad_arg;
      395 
      396 			to_sector = get_seek_addr (to_, code);
      397 			if code ^= 0 then
      398 			     go to bad_arg;
      399 
      400 			to_sw = TRUE;
      401 		     end;
      402 
      403 		else if arg = "-system" | arg = "-sys"
      404 		then system = "-sys";
      405 
      406 		else if arg = "-no_write_compare" | arg = "-nwc" then
      407 		     write_compare = "^wrtcmp";
      408 
      409 
      410 		else do;				/* unrecognizable arg */
      411 bad_arg:
      412 
      413 			if arg_sw = "1"b then do;
      414 				code = error_table_$badopt;
      415 				call com_err_ (code, myname, "Invalid or unrecognizable control arg in string (^a).", arg);
      416 			     end;
      417 			else do;
      418 				code = error_table_$noarg;
      419 				call com_err_ (code, myname, "Number of args received insufficient.");
      420 			     end;
      421 			call ioa_ ("^a: Usage: exercise_disk DEVICE_TYPE PACK_ID {-control_args}", myname);
      422 			return;
      423 		     end;
      424 	     end;
      425 
      426 
      427 done_args:
      428 
      429 
      430 	if MODELN (dev_idx) > 451 then /* all 5xx have alt tracks */
      431 	     alt_sw = "1"b;
      432 
      433 
      434 	call ioa_ ("^/^a: Device type is ^a pack serial no. is ^a", myname, arg1, pack_id);
      435 	if write_sw then do;			/* ask only if writing */
      436 		call ioa_ ("^a: exercise_disk will destroy all data on this pack ! ", myname);
      437 		call command_query_ (querie, answer, myname, "Do You Wish To Continue?");
      438 		if answer ^= "yes" then
      439 		     return;
      440 	     end;
      441 start:
      442 
      443 	options_.num_opts = 2;
      444 	options_.options (*) = "";			/* init options */
      445 	options_.options (1) = arg1;			/* now fill 'em in */
      446 	options_.options (2) = pack_id;
      447 
      448 	if dev_sw then do;
      449 		options_.num_opts = options_.num_opts + 2;
      450 		options_.options (options_.num_opts - 1) = "-dv";
      451 		options_.options (options_.num_opts) = device_name;
      452 	     end;
      453 	if write_sw then do;
      454 		options_.num_opts = options_.num_opts + 1;
      455 		options_.options (options_.num_opts) = "-write";
      456 	     end;
      457 	if system = "-sys" then do;
      458 		options_.num_opts = options_.num_opts + 1;
      459 		options_.options (options_.num_opts) = system;
      460 	     end;
      461 
      462 
      463 	call ioa_ ("^a: Requesting mount of volume ^a^[ on ^a^].", myname, pack_id, dev_sw, device_name);
      464 
      465 	iocbp = null;
      466 
      467 	call iox_$find_iocb ("exercise_disk", iocbp, code);
      468 	if code ^= 0 then do;
      469 		call com_err_ (code, myname, "Finding IOCB.");
      470 		return;
      471 	     end;
      472 
      473 	test_in_progress = -1;			/* we have really started */
      474 
      475 	options_ptr = addr (options_);
      476 	call exdim_attach (iocbp, options_ptr, "0"b, code);
      477 
      478 	if code ^= 0 then do;
      479 		call com_err_ (code, "exercise_disk", "Attaching I/O disk.");
      480 		go to llose;
      481 	     end;
      482 
      483 	dev_attached = "1"b;
      484 
      485 	call exdim_open (iocbp, open_mode, code);
      486 	if code ^= 0 then do;
      487 		call com_err_ (code, myname, "Setting opening mode ^a", open_mode);
      488 		go to llose;
      489 	     end;
      490 
      491 	dev_open = "1"b;
      492 
      493 	if alt_sw then do;				/* Alt track setup */
      494 		call exdim_modes (iocbp, "^label,alttrk," || write_compare, code);
      495 		if code ^= 0 then do;
      496 			call com_err_ (code, myname, "Setting modes (altrk).");
      497 			go to llose;
      498 		     end;
      499 
      500 		highest_sector = last_sect_num (dev_idx);
      501 	     end;
      502 
      503 
      504 
      505 	else do;					/* No ^alt. trk format */
      506 		call exdim_modes (iocbp, "^label," || write_compare, code);
      507 		if code ^= 0 then do;
      508 			call com_err_ (code, myname, "Setting modes.");
      509 		     end;
      510 	     end;
      511 
      512 	words_per_sector = words_per_sect (dev_idx);
      513 
      514 
      515 	if write_sw then /* option w or wr */
      516 	     allocate data set (data_bufp);
      517 
      518 	if read_sw then do;
      519 		allocate read_data set (read_ptr);	/* option wr or r */
      520 		if ^write_sw then
      521 		     if ^ndc_sw then
      522 			allocate data set (data_bufp);/* option r */
      523 	     end;
      524 
      525 	if random_sw				/* fill in string for startup message */
      526 	then mode_string = "random";
      527 
      528 	else if seq_sw
      529 	then mode_string = "sequential";
      530 
      531 	else mode_string = "range";
      532 
      533 	dev_infop = addr (device_info);
      534 	call exdim_control (iocbp, "device_info", dev_infop, code);
      535 	device_name = dev_name;
      536 
      537 	if mod (bin (substr (device_name, 6, 2)), 2) = 0 then
      538 	     dev_evn = "1"b;
      539 
      540 	else dev_evn = "0"b;
      541 
      542 	rec_len, read_data_len = 4 * sect_size_;	/* num chars in a sector */
      543 
      544 	call date_time_ (clock_ (), dt);
      545 	call ioa_ ("^/^a: Begin ^a test on ^a (^a) @  ^a", myname, mode_string, dev_name, dev_type_, substr (dt, 11, 6));
      546 
      547 	on program_interrupt begin;
      548 		call convert_seek_addr (seek, sa1, sn1, cn1, hn1); /* get cyl and head info */
      549 		call ioa_ ("^a:^2xCurrently at cyl ^d head ^d", myname, cn1, hn1);
      550 		call ioa_ ("^a:^2xsectors read^10d; sectors written^10d.", myname, sectors_read, sectors_written);
      551 	     end;
      552 
      553 	if random_sw				/* check random versus sequential */
      554 	then do;					/* random test */
      555 		seek_counter = 0;
      556 		do while (seek_counter < 10000000);	/* a nominal number */
      557 start_rand:	     x = mod (clock (), highest_sector);/* generate one seek address */
      558 		     y = highest_sector - x;		/* and its converse */
      559 		     err_retry = 0;			/* zero on successful io */
      560 random_write:	     if write_sw then do;		/* first do the write of two sectors */
      561 			     seek1 = x;
      562 			     seek2 = y;
      563 			     call write_sector;
      564 			     seek_counter = seek_counter + 2; /* bump counter */
      565 			end;			/* end of write of two sectors */
      566 
      567 		     if read_sw then do;		/* do read of two sectors */
      568 			     seek1 = x;
      569 rand_read:		     call read_sector;
      570 			     seek1 = y;
      571 			     call read_sector;
      572 			     seek_counter = seek_counter + 2; /* bump counter by number of reads */
      573 			end;			/* end of read of two sectors */
      574 		end;				/* seek_counter now max */
      575 	     end;					/* end of a random pass */
      576 
      577 	else if seq_sw then
      578 	     do x = 0 to (highest_sector - 1) by 2;	/* walk through sequentially */
      579 start_seq:	y = x + 1;
      580 		err_retry = 0;			/* zero on successful io */
      581 seq_write:	if write_sw then do;		/* write two sectors */
      582 			seek1 = x;
      583 			seek2 = y;
      584 			call write_sector;
      585 		     end;				/* end of writing two */
      586 
      587 		if read_sw then do;			/* read two sectors */
      588 			seek1 = x;
      589 seq_read:			call read_sector;
      590 			seek1 = y;
      591 			call read_sector;
      592 		     end;				/* end of read of two sectors */
      593 	     end;					/* end of a sequential pass */
      594 
      595 
      596 	else do;					/* Must be a range */
      597 
      598 start_range:	x = loest_sector;			/* Beginning seek addr */
      599 		y = to_sector;
      600 range_cont:	err_retry = 0;
      601 
      602 range_write:	if write_sw then do;
      603 			seek1 = x;
      604 			seek2 = y;
      605 			call write_sector;
      606 		     end;
      607 
      608 range_read:	if read_sw then do;
      609 			seek1 = x;
      610 			call read_sector;
      611 			seek1 = y;
      612 			call read_sector;
      613 		     end;
      614 
      615 		err_retry = 0;
      616 
      617 		x = x + 1;
      618 		y = y - 1;
      619 
      620 
      621 		if x = to_sector then
      622 		     go to start_range;
      623 
      624 		else go to range_write;
      625 	     end;
      626 
      627 llose:
      628 	call EXIT;
      629 	return;
      630 
      631 
      632 error1:
      633 
      634 	err_retry = err_retry + 1;
      635 	call error;
      636 
      637 	if quit_flag then /* time to go home */
      638 	     go to llose;
      639 
      640 	if err_retry = 5 then do;			/* have reached the limit */
      641 		err_retry = 0;
      642 		call command_query_ (querie, answer, myname, "Unrecoverable disk error.  Do you wish to continue?");
      643 		if answer ^= "yes" then do;
      644 			go to llose;
      645 		     end;
      646 
      647 
      648 		if random_sw then go to start_rand;
      649 
      650 		else if seq_sw then go to start_seq;
      651 		else go to range_write;
      652 	     end;
      653 
      654 	if random_sw & ^compare_err then
      655 	     go to random_write;			/* go retry */
      656 
      657 	if random_sw & compare_err then
      658 	     go to rand_read;			/* see if we can read and display the mis-compare */
      659 
      660 	if seq_sw & ^compare_err then
      661 	     go to seq_write;
      662 
      663 	if seq_sw & compare_err then
      664 	     go to seq_read;
      665 
      666 	if range_sw & ^compare_err then
      667 	     go to range_write;
      668 
      669 	if range_sw & compare_err then
      670 	     go to range_read;
      671 
      672 	else go to llose;				/* must be lost */
      673 
      674 
      675 
      676 
      677 write_sector: proc;
      678 
      679 /* ************************************************************************
      680*   *   this routine is used to issue the write and read and compare the    *
      681*   *   data read from the read command			       *
      682*   ************************************************************************ */
      683 
      684 	dcl     (data_was, data_sb)	 bit (36 * words_per_sector) based;
      685 	dcl     (seek_addr, sect_no, cylno, hdno) fixed bin (24);
      686 	dcl     z			 fixed bin;
      687 
      688 
      689 
      690 	f91 = seek1;
      691 	f92 = seek2;
      692 	seek = seek1;
      693 	call build_sb;				/* build the data buffer */
      694 	call exdim_seek (iocbp, key1, rec_len, code);
      695 
      696 	if code ^= 0 then do;
      697 		call com_err_ (code, myname, "Attempt to use an invalid seek key (^a).", f91);
      698 		go to llose;
      699 	     end;
      700 
      701 
      702 	call exdim_rewrite (iocbp, data_bufp, rec_len, code);
      703 
      704 	if code ^= 0 then do;
      705 		if code ^= error_table_$device_parity then do; /* my prob */
      706 			call com_err_ (code, myname, "Performing rewrite operation.");
      707 			go to llose;
      708 		     end;
      709 
      710 		else go to error1;
      711 	     end;
      712 
      713 	seek = seek2;
      714 	call build_sb;				/* build the data buffer */
      715 	call exdim_seek (iocbp, key2, rec_len, code);
      716 
      717 	if code ^= 0 then do;
      718 		call com_err_ (code, myname, "Attempt to use an invalid seek key (^a).", f92);
      719 		go to llose;
      720 	     end;
      721 
      722 
      723 	call exdim_rewrite (iocbp, data_bufp, rec_len, code);
      724 
      725 	if code ^= 0 then do;
      726 		if code ^= error_table_$device_parity then do; /* my prob */
      727 			call com_err_ (code, myname, "Performing rewrite operation.");
      728 			go to llose;
      729 		     end;
      730 
      731 		else go to error1;
      732 	     end;
      733 
      734 	sectors_written = sectors_written + 2;		/* keeep track of what weve done */
      735 
      736 	return;
      737 
      738 read_sector: entry;
      739 	seek, f91 = seek1;
      740 	if ndc_sw then ;				/* do nothing if not checking data */
      741 
      742 	else do;					/* user requested data compare */
      743 		call build_sb;			/* so generate a "should be" image */
      744 		read_ptr -> data_was = FALSE;		/* zap the read buffer */
      745 	     end;					/* finished preparingg for data compare */
      746 
      747 
      748 	call exdim_seek (iocbp, key1, rec_len, code);
      749 
      750 	if code ^= 0 then do;
      751 		call com_err_ (code, myname, "Attempt to use an invalid seek key (^a).", f91);
      752 		go to llose;
      753 	     end;
      754 
      755 
      756 	call exdim_read (iocbp, read_ptr, read_data_len, rec_len, code);
      757 
      758 	if code ^= 0 then do;
      759 		if code ^= error_table_$device_parity then do; /* my prob */
      760 			call com_err_ (code, myname, "Performing read operation.");
      761 			go to llose;
      762 		     end;
      763 
      764 		else go to error1;
      765 	     end;
      766 
      767 	sectors_read = sectors_read + 1;		/* keep track of what weve done */
      768 	if ndc_sw					/* check not data compare switch */
      769 	then ;					/* no data compare wanted */
      770 
      771 	else do;					/* now check the read versus the should be */
      772 		if read_ptr -> data_was = data_bufp -> data_sb /* fast compare on entire sector */
      773 		then ;				/* they are equal...all is well */
      774 
      775 		else do z = 0 to (words_per_sector - 1);/* fast compare failed so walk and find first error */
      776 			if data (z) ^= read_data (z) then do;
      777 				call ioa_ ("^/^a data compare error at address ^d, word ^d", myname, seek, z);
      778 				call convert_seek_addr (seek, seek_addr, sect_no, cylno, hdno);
      779 				if z = 0 then do;	/* error in seek addr */
      780 					seek_addr_read = bin (substr (read_data (0), 13, 24), 24);
      781 					call ioa_ ("Word in error is the seek address.");
      782 					call ioa_ ("Word 0 should be: ^d (cyl ^4d, head ^3d, sector ^4d).",
      783 					     seek, cylno, hdno, sect_no);
      784 
      785 					call convert_seek_addr (seek_addr_read, seek_addr, sect_no, cylno, hdno);
      786 					call ioa_ ("Word 0 was      : ^d (cyl ^4d, head ^3d, sector ^4d).",
      787 					     seek_addr_read, cylno, hdno, sect_no);
      788 					read_cmp_err = read_cmp_err + 1;
      789 					return;
      790 				     end;
      791 
      792 
      793 				call ioa_ ("^9x Seek Address^2x^d^2xSector^2x^d^2xCyl^2x^d^2xHead^2x^d",
      794 				     seek_addr, sect_no, cylno, hdno);
      795 
      796 				call ioa_ ("^/^9xWord ^d^5xWord ^d^5xWord ^d^5xWord ^d", z, z + 1, z + 2, z + 3);
      797 				call ioa_ ("^2xis:^3x^.4b^2x^.4b^2x^.4b^2x^.4b", read_data (z), read_data (z + 1), read_data (z + 2), read_data (z + 3));
      798 
      799 				call ioa_ ("^xs/b:^3x^.4b^2x^.4b^2x^.4b^2x^.4b", data (z), data (z + 1), data (z + 2), data (z + 3));
      800 				read_cmp_err = read_cmp_err + 1;
      801 				return;
      802 			     end;
      803 		     end;
      804 	     end;
      805 
      806 	return;
      807      end write_sector;
      808 
      809 
      810 build_sb: proc;					/*  build up the should be buffer for the read compare */
      811 
      812 	dcl     i			 fixed bin;
      813 
      814 	data (0) = bit (0, 12) || bit (seek, 24);	/* put in seek address */
      815 	do i = 1 to words_per_sector - 1;
      816 	     data (i) = constant_;
      817 	end;
      818 
      819 	return;
      820      end build_sb;
      821 
      822 
      823 error: proc;
      824 
      825 
      826 /* ************************************************************************
      827*   *   this routine displays the error data to the user and stores the     *
      828*   *   error info away for test summarization. On an attention condition   *
      829*   *   it will ask the user whether or not he wishes to continue.          *
      830*   ************************************************************************ */
      831 
      832 	dcl     (s_a, se_n, cyl_no, hd_no) fixed bin (24);
      833 	dcl     my_analyses		 (20) char (40) varying;
      834 
      835 	dcl     detailed_status	 bit (88) unal based (addr (detail_status));
      836 	dcl     msg		 char (256) var init ("");
      837 	dcl     is_interesting	 bit (1);
      838 	dcl     DATA_ALRT_CMPRR	 bit (10) int static options (constant) init (
      839 				 "0011100000"b);	/* Data Alert, Compare Error */
      840 	dcl     ATTN		 bit (4) int static options (constant) init (
      841 				 "0010"b);	/* Attention Condition major status */
      842 
      843 	is_interesting = "0"b;
      844 	compare_err = FALSE;
      845 	my_analyses (*) = "";
      846 	dev_statp = addr (device_status_info);
      847 	call exdim_control (iocbp, "hardware_status", dev_statp, code); /* get the status */
      848 
      849 	if dev_cmd = 27 then do;
      850 		doing = "write";
      851 		write_errors = write_errors + 1;
      852 	     end;
      853 
      854 	else if dev_cmd = 21 then do;
      855 		doing = "read";
      856 		read_errors = read_errors + 1;
      857 		dev_cmd = dev_cmd + 5;
      858 	     end;
      859 
      860 	else if dev_cmd = 28 then do;
      861 		doing = "seek";
      862 		seek_errors = seek_errors + 1;
      863 	     end;
      864 
      865 	if substr (iom_status, 3, 10) = DATA_ALRT_CMPRR then
      866 	     compare_err = TRUE;
      867 
      868 	if err_cnt < 50 then do;
      869 		err_cnt = err_cnt + 1;
      870 
      871 		device_status_info.seek_addr = seek;
      872 		errors (err_cnt) = device_status_info;	/* save this for later analysis */
      873 	     end;
      874 
      875 	else do;
      876 		call ioa_ ("^/^a: Too many errors encountered in test!^/^15xFix disk drive (^a) and re-run.", myname, device_name);
      877 		quit_flag = TRUE;
      878 	     end;
      879 
      880 	call convert_seek_addr (seek, s_a, se_n, cyl_no, hd_no);
      881 
      882 	call analyze_device_stat_$rsnnl (msg, stat_tablep, (iom_status), ("0"b));
      883 	call date_time_ (clock_ (), dt);
      884 
      885 	call ioa_ ("^/^a: ^a error on ^a @ ^a;",
      886 	     myname, doing, device_name, substr (dt, 11, 6));
      887 
      888 	call ioa_ ("^15xSeek Addr ^o, ^[Logical ^]cyl ^d hd ^d^[, Physical cyl ^d hd ^d^]",
      889 	     seek, d500_sw, cyl_no, hd_no, d500_sw, PC, PH);
      890 
      891 
      892 	call ioa_ ("^15x^a (^2o/^2o)", msg, substr (iom_status, 3, 4),
      893 	     substr (iom_status, 7, 6));
      894 
      895 	if detail_status (1) then do;
      896 		msg = "";
      897 		call analyze_detail_stat_$rsnnl (device_name, substr (iom_status, 1, 36),
      898 		     detailed_status, msg, is_interesting, code);
      899 		if msg ^= "" then
      900 		     call ioa_ ("^15xDetailed Status: ^a", msg);
      901 	     end;
      902 
      903 
      904 	if quit_flag then return;
      905 
      906 	if substr (iom_status, 3, 4) = ATTN then do;	/* is it an attention cond? */
      907 		call command_query_ (querie, answer, myname,
      908 		     "Your disk drive (^a) requires attention.^/^-^5xPlease check it out or have the operator do so
      909 ^-^5xand reply appropriately AFTER the device has been checked.
      910 
      911 ^-^5xDo you wish to retry?", device_name);
      912 
      913 		if answer ^= "yes" then
      914 		     quit_flag = TRUE;
      915 
      916 	     end;
      917 
      918 
      919 
      920 	return;
      921      end error;
      922 
      923 
      924 get_dev_size: proc (acode) returns (fixed bin (24));
      925 
      926 /* **********************************************************************
      927*   *   Returns the highest sector address for the specified device type   *
      928*   ********************************************************************** */
      929 
      930 	dcl     acode		 fixed bin (35);
      931 	dcl     dvt		 fixed bin;
      932 
      933 	acode = 0;
      934 	do dvt = 1 to maxdevt;
      935 	     if device_type = device_names (dvt) then do;
      936 		     acode = 0;
      937 		     return (last_alt_sect_num (dvt));
      938 		end;
      939 	end;
      940 	acode = 1;
      941 	return (0);
      942 
      943 
      944      end;
      945 
      946 
      947 convert_seek_addr: proc (sector, sa, se_no, cyl_, hd_);
      948 
      949 /* **********************************************************************
      950*   *   given a seek address, this routine returns the sector, head and   *
      951*   *   cylinder information from that address			     *
      952*   ********************************************************************** */
      953 
      954 	dcl     ecode		 fixed bin (35);
      955 	dcl     (sector, se_no, sa, cyl_, hd_) fixed bin (24);
      956 
      957 
      958 	sa = divide (sector, sect_per_track (dev_idx), 24, 0);
      959 	se_no = mod (sector, sect_per_track (dev_idx));
      960 	cyl_ = divide (sa, tracks_per_cyl (dev_idx), 24, 0);
      961 	hd_ = mod (sa, tracks_per_cyl (dev_idx));
      962 
      963 	if model_num >= 500 then do;
      964 		if mod (cyl_, 2) = 0 then do;
      965 			epc = cyl_ + 1;
      966 			opc = cyl_;
      967 			PH = hd_ * 2;
      968 		     end;
      969 
      970 		else do;
      971 			epc = cyl_;
      972 			opc = cyl_ - 1;
      973 			PH = (hd_ * 2) + 1;
      974 		     end;
      975 		if dev_evn then
      976 		     PC = epc;
      977 		else PC = opc;
      978 
      979 	     end;
      980 
      981 
      982 	return;
      983 
      984 
      985 get_seek_addr: entry (sector, ecode) returns (fixed bin (24));
      986 
      987 
      988 /* This routine returns a seek address from the user supplied
      989*   * starting/ending  cylinder number (from/to N) */
      990 
      991 
      992 	ecode = 0;
      993 	if alt_sw then /* check that the cyl input is not > largest cyl allowed */
      994 	     if (sector * sect_per_cyl (dev_idx)) >
      995 		last_sect_num (dev_idx) then do;
      996 bad_ret:		     ecode = 1;
      997 		     return (0);
      998 		end;
      999 
     1000 	if ^alt_sw then
     1001 	     if (sector * sect_per_cyl (dev_idx)) >
     1002 		last_alt_sect_num (dev_idx) then
     1003 		go to bad_ret;
     1004 
     1005 	return (sector * sect_per_cyl (dev_idx));
     1006 
     1007      end convert_seek_addr;
     1008 
     1009 EXIT: proc;
     1010 
     1011 	dcl     (sect_addr, sect, cyl, hd) fixed bin (24);
     1012 	dcl     temp_		 (err_cnt + 1) char (100) var init ((err_cnt + 1) (""));
     1013 	dcl     temp_str		 char (100) var init ("");
     1014 	dcl     (i, j, count_)	 fixed bin;
     1015 	dcl     (CA, PORT)		 char (10) var;
     1016 	dcl     ioa_$rsnnl		 entry () options (variable);
     1017 	dcl     linelth		 fixed bin;
     1018 
     1019 	if test_in_progress = 0 then /* haven't really started */
     1020 	     return;
     1021 
     1022 	if dev_open then do;
     1023 		call exdim_close (iocbp, code);
     1024 		dev_open = "0"b;
     1025 	     end;
     1026 
     1027 	if dev_attached then do;
     1028 		call exdim_detach (iocbp, code);
     1029 		if code ^= 0 then
     1030 		     call com_err_ (code, myname, "Problems detaching, suggest a ""new_proc""");
     1031 		dev_attached = "0"b;
     1032 	     end;
     1033 	if data_bufp ^= null then
     1034 	     free data;				/* clean up if used */
     1035 	if read_ptr ^= null then /* ditto */
     1036 	     free read_data;
     1037 
     1038 	if iocbp ^= null then
     1039 	     call iox_$destroy_iocb (iocbp, code);
     1040 
     1041 	test_in_progress = 0;			/* truly I am dead */
     1042 
     1043 	if sectors_written + sectors_read + err_cnt + read_cmp_err > 0 then do;
     1044 
     1045 		call ioa_ ("^/^a: Testing Completed for ^a (^a).", myname, device_name, device_type);
     1046 		call ioa_ ("Test Summary:");
     1047 		call ioa_ ("Number of Sectors Written   ^12d", sectors_written);
     1048 		call ioa_ ("Number of Sectors Read^6x^12d", sectors_read);
     1049 
     1050 		if err_cnt + read_cmp_err > 0 then do;
     1051 
     1052 			call ioa_ ("Number of Write  I/O errors^7x ^5d", write_errors);
     1053 			call ioa_ ("Number of Read   I/O errors^7x ^5d", read_errors);
     1054 			call ioa_ ("Number of Read Compare Errors^6x^5d", read_cmp_err);
     1055 			if err_cnt < 1 then return;
     1056 
     1057 
     1058 			call ioa_ ("^/Error Location Summary:^/^/^xError Count^4xCylinder^2xHead^3xR/W^2xCA^2xPort^[ Physical  CYL/HD^]", d500_sw);
     1059 			call ioa_ ("^x===========^4x========^2x====^3x===^2x==^2x====^[ ================^]", d500_sw);
     1060 
     1061 			do ii = 1 to err_cnt;
     1062 			     if errors (ii).det_status (1) then do;
     1063 				     CA = ltrim (rtrim (char (fixed (substr (errors (ii).det_status (10), 8, 1), 1))));
     1064 				     PORT = ltrim (rtrim (char (fixed (substr (errors (ii).det_status (11), 4, 5), 5))));
     1065 				end;
     1066 			     else do;
     1067 				     CA = " ";
     1068 				     PORT = "     ";
     1069 				end;
     1070 
     1071 			     if length (PORT) = 1 then
     1072 				PORT = "    " || PORT;
     1073 			     else if length (PORT) = 2 then
     1074 				PORT = "   " || PORT;
     1075 
     1076 			     call convert_seek_addr (errors (ii).seek_addr_, sect_addr, sect, cyl, hd);
     1077 			     call ioa_$rsnnl ("^12d^2x^4d^4x^1a^4x^1a^x^5a^[^46t^3d/^2d^]",
     1078 				temp_ (ii), linelth, cyl, hd,
     1079 				cmd_tbl (errors (ii).dev_cmd_),
     1080 				CA, PORT, d500_sw, PC, PH);
     1081 
     1082 
     1083 			end;
     1084 
     1085 			do i = 1 to err_cnt - 1;	/* sort the errors */
     1086 			     do j = (i + 1) to err_cnt;
     1087 				if temp_ (i) > temp_ (j) then do;
     1088 					temp_str = temp_ (i);
     1089 					temp_ (i) = temp_ (j);
     1090 					temp_ (j) = temp_str;
     1091 				     end;
     1092 			     end;
     1093 			end;
     1094 
     1095 			count_, x = 1;
     1096 
     1097 print_it:			do i = x to err_cnt;
     1098 			     do j = (i + 1) to err_cnt + 1;
     1099 				if temp_ (i) = temp_ (j) then
     1100 				     count_ = count_ + 1;
     1101 				else do;
     1102 					call ioa_ ("^7x^5d^a", count_, temp_ (i));
     1103 					x = j;
     1104 					count_ = 1; /* reset the counter */
     1105 					go to print_it;
     1106 				     end;
     1107 			     end;
     1108 			end;
     1109 
     1110 			call ioa_ ("^/^/");
     1111 		     end;
     1112 
     1113 
     1114 		else call ioa_ ("^/^a: No errors encountered in test.", myname);
     1115 	     end;
     1116 
     1117 	return;
     1118      end EXIT;
     1119 
     1120 
     1121 
     1122 /* This subroutine is a modified version of rdisk_. It has been modisfied to
     1123*   * support exercise_disk in a streamline fashion, with a much improved
     1124*   * error handling capability. */
     1125 
     1126 
     1127 exdim_: proc;
     1128 	return;					/* do not enter here */
     1129 
     1130 
     1131 	dcl     1 disk_data		 based (disk_ptr),	/*  exdim_ data structure  */
     1132 		2 attach_descrip	 aligned,		/*  Current attach description  */
     1133 		  3 length	 fixed bin (17),	/*  Length of description in chars.  */
     1134 		  3 descrip	 char (168),	/* the actual description  */
     1135 		2 attach_data	 aligned,		/*  attachment data for use by  exdim_  */
     1136 		  3 sze		 fixed bin (35),	/* if ^= 0 => size specified in attach or control  */
     1137 		  (3 err_sw,			/* on if error messages are to be printed  */
     1138 		  3 write_sw,			/*  on if  device is to be mounted in write mode  */
     1139 		  3 compare_sw,			/*   on if Write_and_Compare idcw is to be used for writes  */
     1140 		  3 raw_sw,			/* ON => raw mode */
     1141 		  3 alt_sw,			/* ON => alt mode */
     1142 		  3 label_sw,			/* ON => label mode */
     1143 		  3 sys_sw)	 bit (1) unal,	/*  on if this is a privileged system process  */
     1144 		  3 pack_id	 char (32),	/*  Current disk pack id.  */
     1145 		  3 rcp_id	 bit (36),	/* rcp unique id. */
     1146 		  3 max_buff_size	 fixed bin (19),	/* ioi_ buffer size limit set by rcp_ */
     1147 		  3 wait_list,			/*  event channel information  */
     1148 		    4 nchan	 fixed bin,	/* number of channels (currently using 1)  */
     1149 		    4 ev_chan	 fixed bin (71),	/* event channel id.  */
     1150 		  3 dev_type	 fixed bin,	/*  device type indicator   */
     1151 		  3 devx		 fixed bin,	/* device index returned by ioi_ */
     1152 		  3 drive		 fixed bin (6),	/* drive number returned by ioi_ */
     1153 		  3 errors	 fixed bin,	/* error count */
     1154 		  3 sect_per_dev	 fixed bin (35),	/* sectors per device */
     1155 		  3 sect_size	 fixed bin (12),	/* quantity of words in one sector */
     1156 		  3 num_alt_sect	 fixed bin,	/* quantity of sectors reserved for alternate sector usage */
     1157 		  3 device_group	 fixed bin,	/* 1 = MSU04XX */
     1158 						/* 2 = MSU0500/1 */
     1159 						/* 3 = MSU3380 & MSU3381 */
     1160 		2 open_descrip	 aligned,		/* open description */
     1161 		  3 length	 fixed bin (17),	/* number of characters in open descrip. */
     1162 		  3 descrip	 char (32),	/* the actual open descrip. */
     1163 		2 open_data	 aligned,		/* more exdim_ data */
     1164 		  3 mode		 fixed bin,	/* mode number:  4 = sq_i, 5 = sq_o, 7 = sq_u,
     1165*						   11 = d_i, 13 = d_u    */
     1166 		  3 buf_ptr	 ptr,		/* pointer to buffer created by ioi_$workspace */
     1167 		  3 fill		 bit (9),		/* Fill left-over part of last sector of the current record with this value when writing. */
     1168 		  3 buf_len	 fixed bin (19),	/*  length (words) of buffer */
     1169 		  3 data_len	 fixed bin (19),	/* length of data area in buffer */
     1170 		  3 time_int	 fixed bin (52),	/* current time out interval */
     1171 		  3 next_key	 fixed bin (35),	/* next key as per iox_ */
     1172 		  3 current_key	 fixed bin (35),	/* current key as per iox_ */
     1173 		  3 key_for_insertion fixed bin (35),	/* key for insertion as per iox_  */
     1174 						/* key_for_insertion is always null for the
     1175*						   present implementation, since write_record
     1176*						   is not supported for direct_update.  */
     1177 		  3 bounds,			/* current key  boundaries */
     1178 		    4 low		 fixed bin (35),	/* the lower bound */
     1179 		    4 high	 fixed bin (35),	/* higher bound */
     1180 		  3 mode_string	 char (32) varying, /* current modes */
     1181 		  3 rcp_data	 (size (disk_info)) fixed bin (35); /* area for rcp_disk_info structure */
     1182 
     1183 	dcl     1 status		 based (addr (iom_stat)), /* breakout of iom_stat */
     1184 		2 pad		 bit (2) unal,	/* not used */
     1185 		2 maj		 bit (4) unal,	/* major status */
     1186 		2 sub		 bit (6) unal,	/* sub status */
     1187 		2 pad2		 bit (48) unal,	/* not used */
     1188 		2 residue		 bit (12) unal;	/* tally residue */
     1189 
     1190 	dcl     1 seek		 aligned,
     1191 		2 block_count_limit	 fixed bin (12) unsigned unal,
     1192 		2 ti		 bit (2) unal,
     1193 		2 mbz		 bit (1) unal,
     1194 		2 sector		 fixed bin (21) unsigned unal;
     1195 
     1196 	dcl     1 super_seek	 aligned,
     1197 		2 sector_number	 fixed bin (8) unsigned unal,
     1198 		2 mbz1		 bit (4) unal,
     1199 		2 ti		 bit (2) unal,
     1200 		2 is_super_seek	 bit (1) unal,
     1201 		2 flag		 bit (1) unal,
     1202 		2 mbz2		 bit (4) unal,
     1203 		2 cyl_lower	 fixed bin (8) unsigned unal,
     1204 		2 cyl_upper	 fixed bin (2) unsigned unal,
     1205 		2 head		 fixed bin (6) unsigned unal;
     1206 
     1207 	dcl     1 buffer		 based (buf_ptr),	/* ioi_ buffer */
     1208 		2 control_info,			/* device control data */
     1209 		  3 (rst_idcw, sk_idcw, sk_dcw, rw_idcw, rw_dcw) fixed bin (35), /* DCW's */
     1210 		  3 seek_data	 like seek,	/* Information for seek DCW */
     1211 		  3 rsr_data	 bit (88) unal,	/* detailed device status read by RSR */
     1212 		  3 reserved	 (5) fixed bin (35),/* pad for future expansion */
     1213 		  3 istat		 aligned,		/* I/O Interfacer status structure */
     1214 		    4 completion,			/* completion flags */
     1215 		    ( 5 st	 bit (1),		/* "1"b if status returned */
     1216 		      5 er	 bit (1),		/* "1"b if status indicates error condition */
     1217 		      5 run	 bit (1),		/* "1"b if channel still running */
     1218 		      5 time_out	 bit (1)) unal,	/* "1"b if time-out occurred */
     1219 		    4 level	 fixed bin (3),	/* IOM interrupt level */
     1220 		    4 offset	 fixed bin (18),	/* DCW list offset */
     1221 		    4 absaddr	 fixed bin (24),	/* absolute address of workspace */
     1222 		    4 iom_stat	 bit (72),	/* IOM status */
     1223 		    4 lpw		 bit (72),	/* LPW residue */
     1224 		2 data		 char (4 * data_len); /* data area  */
     1225 
     1226 	dcl     1 event_info	 aligned,		/*  event message info  */
     1227 		2 chan_id		 fixed bin (71),
     1228 		2 message,
     1229 		  3 pad1		 bit (15) unal,
     1230 		  3 int_level	 bit (3) unal,
     1231 		  3 pad2		 bit (36) unal,
     1232 		  3 special_type	 fixed bin (17) unal,
     1233 		2 sender		 bit (36),
     1234 		2 origin,
     1235 		  3 dev_signal	 bit (18) unal,
     1236 		  3 ring		 bit (18) unal,
     1237 		2 chan_x		 fixed bin;
     1238 
     1239 	dcl     1 tp_info,				/*  terminate_process_ information */
     1240 		2 version		 fixed bin,	/* version no. (currently 0) */
     1241 		2 code		 fixed bin (35);	/* error code to be printed before process is termed */
     1242 
     1243 	dcl     (disk_ptr, iocb_ptr, real_iocb_ptr, ubuf_ptr, block_ptr, rs_ptr, info_ptr, fmdp) ptr init (null); /* pointers */
     1244 	dcl     dcw_offset		 fixed bin (18);	/* offset in ioi_ buffer to first IDCW */
     1245 	dcl     (code, rec_len, data_left, mode_len, mode_start) fixed bin (35);
     1246 	dcl     key		 fixed bin (21);	/* working seek key */
     1247 	dcl     track_indicators	 bit (2) init ("00"b); /* track indicator bits for seek cmd */
     1248 	dcl     (count_limit_fixed, block_len) fixed bin (12);
     1249 	dcl     (i, num_opts, err_ct, rcp_state) fixed bin;
     1250 	dcl     (cyl, head)		 fixed bin (16);
     1251 	dcl     (again, not_sw, mode_err_sw) bit (1) unal;
     1252 
     1253 	dcl     block		 char (4 * block_len) based (block_ptr); /*  current user data block */
     1254 	dcl     dev_id		 char (4);	/* alpha device id, e.g. D191 */
     1255 	dcl     rs_mode		 fixed bin (5);	/* rcp_sys_ access mode for this process */
     1256 
     1257 	dcl     1 user_bounds	 based (info_ptr),	/* current bounds returned via this structure */
     1258 		2 low		 fixed bin (35),
     1259 		2 high		 fixed bin (35);
     1260 
     1261 	dcl     new_modes		 char (24);	/* new modes for  modes oper. */
     1262 	dcl     next_mode		 char (8) varying init ("dummy");
     1263 	dcl     mask_str		 bit (36) aligned;	/* ips_ mask */
     1264 	dcl     1 mask		 based (addr (mask_str)), /* different def'n of above */
     1265 		2 pad		 bit (35) unal,	/* we don't use this */
     1266 		2 masked		 bit (1) unal;	/* flag to indicate if we are masked */
     1267 	dcl     temp_key		 fixed bin (35);
     1268 	dcl     1 drive_number,
     1269 		2 sign		 char (1),
     1270 		2 number		 char (2);
     1271 	dcl     drive_dec		 dec (2) based (addr (drive_number)); /* used for drive number conversion */
     1272 	dcl     drive_name		 char (8);	/* name of the requested device or spaces */
     1273 	dcl     model_number	 fixed bin;	/* model number requested by user */
     1274 
     1275 
     1276 /*	The following internal static items should all become constants when exdim_ is compiled.  */
     1277 
     1278 
     1279 	dcl     DEVICE_GROUP	 (9) fixed bin int static init (0, 2, 1, 1, 1, 1, 2, 3, 3);
     1280 						/* "bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380" "3381" */
     1281 	dcl     MSU04XX		 fixed bin int static init (1);
     1282 	dcl     overhead		 fixed bin int static init (24); /* number of control words reserved in ioi_ buffer */
     1283 	dcl     max_retries		 int static fixed bin init (110); /* number of times we will retry certain operations */
     1284 	dcl     ATTENTION		 int static bit (4) init ("0010"b);
     1285 	dcl     EOF		 int static bit (4) init ("0100"b);
     1286 	dcl     LAST_BLOCK		 int static bit (6) init ("000001"b);
     1287 	dcl     LAST_BLOCK_MASK	 int static bit (6) init ("111101"b);
     1288 	dcl     EXEC		 bit (5) int static init ("00100"b);
     1289 	dcl     STANDBY		 int static bit (6) init ("010000"b);
     1290 	dcl     INHIB_AUTO_RETRY	 bit (6) int static init ("010001"b);
     1291 	dcl     SPECIAL_SEEK	 bit (6) int static init ("011110"b);
     1292 	dcl     SEEK_512		 bit (6) int static init ("30"b3);
     1293 	dcl     SPECIAL_SEEK_512	 bit (6) int static init ("35"b3);
     1294 	dcl     LONG_WAIT		 fixed bin int static init (2);
     1295 	dcl     COMPLETE		 fixed bin int static init (0);
     1296 	dcl     DEFAULT		 bit (1) int static init ("0"b);
     1297 	dcl     NOT_SET		 fixed bin (6) int static init (-1);
     1298 	dcl     num_label_sect	 fixed bin int static init (8);
     1299 	dcl     rcp_dev_type	 char (32) int static init ("disk_drive");
     1300 
     1301 /*	This is the end of the set of internal static items which should all become constants during compilation. */
     1302 
     1303 
     1304 
     1305 	dcl     standby_idcw_string	 int static bit (36) init ("720000720201"b3);
     1306 	dcl     restore_idcw_string	 int static bit (36) init ("420000720201"b3);
     1307 	dcl     seek_idcw_string	 int static bit (36) init ("340000720000"b3);
     1308 	dcl     seek_dcw_string	 int static bit (36) init ("000000000001"b3);
     1309 	dcl     read_idcw_string	 int static bit (36) init ("250000700000"b3);
     1310 	dcl     write_idcw_string	 int static bit (36) init ("310000700000"b3);
     1311 	dcl     write_and_compare_idcw_string int static bit (36) init ("330000700000"b3);
     1312 	dcl     read_write_dcw_string	 int static bit (36) init ("000000000000"b3);
     1313 
     1314 	dcl     1 standby_idcw_template defined (standby_idcw_string) like idcw;
     1315 	dcl     1 restore_idcw_template defined (restore_idcw_string) like idcw;
     1316 	dcl     1 seek_idcw_template	 defined (seek_idcw_string) like idcw;
     1317 	dcl     1 seek_dcw_template	 defined (seek_dcw_string) like dcw;
     1318 	dcl     1 read_idcw_template	 defined (read_idcw_string) like idcw;
     1319 	dcl     1 write_and_compare_idcw_template defined (write_and_compare_idcw_string) like idcw;
     1320 	dcl     1 write_idcw_template	 defined (write_idcw_string) like idcw;
     1321 	dcl     1 read_write_dcw_template defined (read_write_dcw_string) like dcw;
     1322 
     1323 	dcl     (
     1324 
     1325 	        error_table_$action_not_performed,	/*  notacted, The requested action was not performed.;  */
     1326 	        error_table_$bad_arg,			/*  bad_arg , Illegal command or subroutine argument.;  */
     1327 	        error_table_$bad_mode,		/*  badmode , Improper mode specification for this device.;  */
     1328 	        error_table_$device_end,		/*  devend  , Physical end of device encountered.;  */
     1329 	        error_table_$device_parity,		/*  xmiterr , Unrecoverable data-transmission error on physical device.;  */
     1330 	        error_table_$incompatible_attach,	/*  att^=opn, Attach and open are incompatible.;  */
     1331 
     1332 
     1333 	        error_table_$no_operation,		/*  no_oper , Invalid I/O operation.;  */
     1334 	        error_table_$no_record,		/*  no_rec  , Record not located.;  */
     1335 	        error_table_$noarg,			/*          , Expected argument missing.;  */
     1336 	        error_table_$not_attached,		/*  notattch, I/O switch (or device) is not attached.;  */
     1337 	        error_table_$not_closed,		/*  not_clsd, I/O switch is not closed.;  */
     1338 	        error_table_$not_detached,		/*  not_det , I/O switch is not detached.;  */
     1339 	        error_table_$not_open,		/*  not_open, I/O switch is not open.;  */
     1340 	        error_table_$request_not_recognized,	/*  reqnorec, Request not recognized.;  */
     1341 	        error_table_$termination_requested,	/*  termrqu , Process terminated because of system defined error condition.;  */
     1342 	        error_table_$user_not_found,		/*  usernfd , User-name not on access control list for branch.;  */
     1343 	        error_table_$unimplemented_version
     1344 
     1345 	        )			 external static fixed bin (35);
     1346 
     1347 
     1348 
     1349 
     1350 	dcl     ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));
     1351 	dcl     iox_$err_no_operation	 entry options (variable);
     1352 	dcl     iox_$err_not_closed	 entry options (variable);
     1353 	dcl     iox_$err_not_open	 entry options (variable);
     1354 	dcl     ioi_$timeout	 entry (fixed bin, fixed bin (52), fixed bin (35));
     1355 	dcl     ioi_$workspace	 entry (fixed bin, ptr, fixed bin (19), fixed bin (35));
     1356 	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
     1357 	dcl     hcs_$delentry_seg	 entry (ptr, fixed bin (35));
     1358 	dcl     iox_$propagate	 entry (ptr);
     1359 	dcl     ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
     1360 	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
     1361 	dcl     ioi_$connect	 entry (fixed bin, fixed bin (18), fixed bin (35));
     1362 	dcl     ipc_$block		 entry (ptr, ptr, fixed bin (35));
     1363 	dcl     ioi_$set_status	 entry (fixed bin, fixed bin (18), fixed bin (8), fixed bin (35));
     1364 	dcl     ioi_$get_detailed_status entry (fixed bin, bit (1) aligned, bit (*), fixed bin (35));
     1365 	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
     1366 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
     1367 	dcl     hcs_$fs_get_mode	 entry (ptr, fixed bin (5), fixed bin (35));
     1368 	dcl     hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
     1369 	dcl     hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
     1370 	dcl     default_handler_$set	 entry (entry);
     1371 	dcl     terminate_process_	 entry (char (*), ptr);
     1372 	dcl     rcp_$attach		 entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
     1373 	dcl     rcp_$check_attach	 entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (71),
     1374 				 fixed bin, fixed bin (35));
     1375 	dcl     rcp_$detach		 entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
     1376 	dcl     a_iocb_ptr		 ptr;		/* parameter:  IOCB pointer */
     1377 	dcl     a_code		 fixed bin (35);	/* parameter:  return code */
     1378 	dcl     a_rec_len		 fixed bin (21);	/* parameter:  user record length */
     1379 	dcl     a_ubuf_ptr		 ptr;		/* parameter:  pointer to user buffer */
     1380 	dcl     a_ubuf_len		 fixed bin (21);	/* parameter: length (chars.) of user buffer */
     1381 
     1382 	dcl     based_rsr_data	 (11) bit (8) unal based (addr (buffer.control_info.rsr_data));
     1383 	dcl     found		 bit (1) aligned;
     1384 
     1385 	dcl     1 user_dev_char_table	 based (info_ptr) aligned, /* Users device Characteristics Table */
     1386 		2 user_subsystem_name char (4),	/* Disk subsystem name */
     1387 		2 user_device_name	 char (8),	/* Device name */
     1388 		2 user_sect_per_dev	 fixed bin (35),	/* total no. of non-T&D sectors on pack */
     1389 		2 user_cyl_per_dev	 fixed bin,	/* no. of non-T&D cylinders on pack */
     1390 		2 user_sect_per_cyl	 fixed bin,	/* no of sectors per cylinder */
     1391 		2 user_sect_per_track fixed bin,	/* no. of sectors per track */
     1392 		2 user_num_label_sect fixed bin,	/* no. of sectors to reserve for label */
     1393 		2 user_num_alt_sect	 fixed bin,	/* no. of sectors to reserve for alt. track area */
     1394 		2 user_sect_size	 fixed bin (12);	/* no. of words in sector */
     1395 
     1396 	dcl     1 user_status_info	 based (info_ptr) aligned, /* user's status data */
     1397 		2 user_hardware_status bit (72),	/* iom status */
     1398 		2 user_dev_detail_status (11) bit (8) unal, /* 11 bytes of dev detail status */
     1399 		2 user_dev_cmd	 fixed bin;	/* the command issued to the disk */
     1400 	dcl     last_cmd_		 fixed bin static;	/* last command to experience an error */
     1401 
     1402 	dcl     io_command		 char (8) varying;	/* values are "read", "write", or "rewrite" */
     1403 	dcl     current_mode_name	 char (24);	/* name of current opening mode */
     1404 
     1405 	dcl     END		 fixed bin int static init (-5); /* used to indicate that a key is at the end of the file */
     1406 	dcl     NULL		 fixed bin int static init (-1); /* used to flag keys as currently being invalid */
     1407 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
     1408 	dcl     unique_entry_name	 char (22);
     1409           dcl     length		 builtin;
     1410 
     1411 
     1412 /*  Start of ATTACH module  */
     1413 
     1414 exdim_attach: entry (a_iocb_ptr, options_ptr, a_err_sw, a_code);
     1415 
     1416 
     1417 	dcl     options_ptr		 ptr;
     1418 	dcl     1 options_		 based (options_ptr), /* parameter:  attach description elements */
     1419 		2 number_opts	 fixed bin,
     1420 		2 options		 (number_opts) char (32) varying;
     1421 
     1422 
     1423 	dcl     a_err_sw		 bit (1) aligned;	/* parameter: print errors flag */
     1424 
     1425 
     1426 	code = 0;					/* clear return code */
     1427 
     1428 	unique_entry_name = unique_chars_ ("0"b) || ".exdim_";
     1429 	call hcs_$make_seg ("", unique_entry_name, "", 01010b, disk_ptr, code); /* make our work segment */
     1430 	if disk_ptr = null then call error (code, "");	/* if it didn't work */
     1431 
     1432 	err_sw = a_err_sw;				/* fill in print errors flag */
     1433 	iocb_ptr = a_iocb_ptr;			/* grab IOCB pointer */
     1434 
     1435 	if iocb_ptr -> attach_descrip_ptr ^= null then call att_err (error_table_$not_detached);
     1436 						/* must be detached */
     1437 
     1438 	write_sw, sys_sw, compare_sw = "0"b;		/* initialize switches */
     1439 	pack_id = " ";				/* clear pack id */
     1440 	sze = 0;					/* reset size field */
     1441 	drive = NOT_SET;				/* init drive field */
     1442 	drive_name = "";				/* no specific drive specified */
     1443 	model_number = 0;
     1444 
     1445 	num_opts = options_.number_opts;		/* how many descrip. elements? */
     1446 
     1447 	if num_opts >= 2 then do;			/* if enough */
     1448 		dev_id = options (1);		/* set device name */
     1449 		pack_id = options (2);		/* set pack id */
     1450 	     end;
     1451 	else call att_err (error_table_$noarg);		/* complain if not enough  */
     1452 
     1453 	if dev_id = "d191" then dev_id = "d400";	/* set up for compatibility */
     1454 						/* ******** */
     1455 	else if dev_id = "d450" then dev_id = "d451";
     1456 
     1457 
     1458 	dev_type = 0;				/* clear device type indicator */
     1459 	do i = 1 to maxdevt while (dev_type = 0);	/*  look up dev. name in dev. char. table */
     1460 	     if dev_id = device_names (i) then dev_type = i; /* if found, set device type indicator */
     1461 	end;
     1462 						/* ******** */
     1463 
     1464 
     1465 	do i = 3 to num_opts;			/* check out attach options */
     1466 
     1467 	     if options (i) = "-write" then write_sw = "1"b; /* if -write set write mode switch */
     1468 
     1469 
     1470 	     else if options (i) = "-device"
     1471 		| options (i) = "-dv"
     1472 	     then do;				/* -device device-name */
     1473 		     if i >= num_opts
     1474 		     then call att_err (error_table_$noarg);
     1475 		     i = i + 1;
     1476 		     drive_name = options (i);
     1477 		     if drive_name ^= options (i)
     1478 		     then call att_err (error_table_$bad_arg);
     1479 		end;
     1480 
     1481 
     1482 	     else if options (i) = "-system" | options (i) = "-sys"
     1483 	     then do;				/* if a reserved drive is wanted */
     1484 
     1485 		     call hcs_$initiate (">system_library_1", "rcp_sys_", "", 0, 0, rs_ptr, code); /* test rcp_sys_ access */
     1486 		     if rs_ptr ^= null then do;	/* if can be initiated */
     1487 			     call hcs_$fs_get_mode (rs_ptr, rs_mode, code); /* check caller's access */
     1488 			     if code = 0 then if bit (rs_mode) & EXEC then sys_sw = "1"b; /* if execute, then priv. process */
     1489 			end;
     1490 		     if ^sys_sw then call att_err (error_table_$user_not_found); /* User does not have correct access to rcp_sys_ gate. */
     1491 		end;
     1492 
     1493 	     else call att_err (error_table_$request_not_recognized); /* if not valid option, complain */
     1494 
     1495 	end;
     1496 
     1497 	if dev_type = 0
     1498 	then attach_descrip.descrip = "exdim_ """" " || pack_id;
     1499 	else attach_descrip.descrip = "exdim_ " || device_names (dev_type) || " " || pack_id; /* init. att. descrip. */
     1500 	attach_descrip.length = length (rtrim (attach_descrip.descrip));
     1501 	do i = 3 to num_opts;			/* add the options */
     1502 	     attach_descrip.descrip = substr (attach_descrip.descrip, 1, attach_descrip.length)
     1503 		|| " " || options (i);		/* concatenate the next option */
     1504 	     attach_descrip.length = length (rtrim (attach_descrip.descrip));
     1505 	end;
     1506 
     1507 	call ipc_$create_ev_chn (ev_chan, code);	/* create an event channel */
     1508 	if code ^= 0 then call att_err (code);		/* if we didn't make it */
     1509 	nchan = 1;				/* only one channel */
     1510 
     1511 	disk_info_ptr = addr (rcp_data);		/* init. disk info prior to assignment */
     1512 	disk_info.version_num = DISK_INFO_VERSION_1;
     1513 	disk_info.usage_time, disk_info.wait_time = 0;
     1514 	disk_info.system_flag = sys_sw;
     1515 	if dev_type ^= 0
     1516 	then disk_info.model = MODELN (dev_type);
     1517 	else disk_info.model = 0;
     1518 	disk_info.device_name = drive_name;
     1519 	disk_info.write_flag = write_sw;
     1520 	raw_sw = "0"b;				/* reset raw mode if set */
     1521 	alt_sw = "0"b;
     1522 	label_sw = "1"b;
     1523 	call mount ();				/* attach drive, and mount pack */
     1524 	if code ^= 0 then call att_err (code);		/* complain if we didn't make it */
     1525 
     1526 	dev_type = 0;
     1527 	do i = 1 to hbound (MODELN, 1) while (dev_type = 0);
     1528 	     if disk_info.model = MODELN (i)
     1529 	     then dev_type = i;
     1530 	end;
     1531 
     1532 
     1533 	device_group = DEVICE_GROUP (dev_type);
     1534 
     1535 	sect_per_dev = sect_per_cyl (dev_type) * cyl_per_dev (dev_type); /* Set up device specific constants */
     1536 	sect_size = words_per_sect (dev_type);
     1537 	num_alt_sect = last_alt_sect_num (dev_type) - first_alt_sect_num (dev_type) + 1;
     1538 
     1539 	if sys_sw then bounds.low = 0;
     1540 	else bounds.low = num_label_sect;		/* initialize the seek low bound */
     1541 	if device_group = MSU04XX
     1542 	then bounds.high = last_alt_sect_num (dev_type);
     1543 	else bounds.high = last_sect_num (dev_type);
     1544 
     1545 	mode_string = "label,^alttrk,^wrtcmp,^raw";	/* set the modes string */
     1546 
     1547 	mask_str = "0"b;				/* initialize ips_ mask */
     1548 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     1549 	call hcs_$set_ips_mask (mask_str, mask_str);
     1550 
     1551 	iocb_ptr -> attach_descrip_ptr = addr (attach_descrip); /* fill in IOCB; attach descrip. */
     1552 	iocb_ptr -> attach_data_ptr = disk_ptr;		/* attach data */
     1553 	iocb_ptr -> detach_iocb = exdim_detach;		/* detach entry */
     1554 	iocb_ptr -> iocb.open = exdim_open;		/* open entry */
     1555 	iocb_ptr -> iocb.control = exdim_control;	/* control entry */
     1556 	iocb_ptr -> iocb.modes = exdim_modes;		/* modes entry */
     1557 
     1558 	call iox_$propagate (iocb_ptr);		/*  let iox_ have its turn */
     1559 
     1560 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     1561 
     1562 	next_key, current_key, key_for_insertion = NULL;	/* Change when valid values established */
     1563 
     1564 
     1565 exit:	a_code = code;				/* return the code */
     1566 	return;					/* bye-bye */
     1567 
     1568 /*  Internal handler for errors occurring during ATTACH  */
     1569 
     1570 att_err: proc (b_code);
     1571 
     1572 	dcl     (b_code, c_code)	 fixed bin (35);	/* error code */
     1573 
     1574 	c_code = b_code;
     1575 
     1576 	call hcs_$delentry_seg (disk_ptr, c_code);	/* get rid of work segment */
     1577 	code = b_code;				/* set code */
     1578 	go to exit;				/* return */
     1579 
     1580      end att_err;
     1581 
     1582 
     1583 /*  End of ATTACH module  */
     1584 
     1585 /*  Start of OPEN module  */
     1586 
     1587 exdim_open: entry (a_iocb_ptr, a_mode, a_code);
     1588 
     1589 /*
     1590*   *           Only the direct_update and direct_input opening modes are
     1591*   *           supported:
     1592*
     1593*   *           Note that the  attach  description  must  include the  -write
     1594*
     1595*   *           control  argument  so  that  the operator  will not  press  the
     1596*
     1597*   *           PROTECT button when pack is mounted if direct_update is used.
     1598**/
     1599 
     1600 	dcl     a_mode		 fixed bin;	/* parameter:  open mode  */
     1601 
     1602 	call setup ("closed");			/* set up working environment */
     1603 						/* If setup returns to here, the switch is closed. */
     1604 
     1605 	mode = a_mode;				/* pick up requested opening mode */
     1606 
     1607 
     1608 /*  Set up various items which are opening-mode dependent.  */
     1609 /*  Since current_key remains NULL for all modes, it is not changed and hence does not show below. */
     1610 
     1611 
     1612 
     1613 	if mode = Direct_update then do;
     1614 		if ^write_sw then call error (error_table_$incompatible_attach,
     1615 			"direct_update requires -write control arg."); /* complain if not attached for write */
     1616 		open_descrip.length = 13;
     1617 		open_descrip.descrip = "direct_update";
     1618 		real_iocb_ptr -> read_record = exdim_read;
     1619 		real_iocb_ptr -> rewrite_record = exdim_rewrite;
     1620 		real_iocb_ptr -> seek_key = exdim_seek;
     1621 						/* next_key remains NULL */
     1622 		fill = "000000000"b;		/* Zero fill last sector when write. */
     1623 	     end;
     1624 
     1625 
     1626 	else if mode = Direct_input then do;
     1627 		open_descrip.length = 12;
     1628 		open_descrip.descrip = "direct_input";
     1629 		real_iocb_ptr -> read_record = exdim_read;
     1630 		real_iocb_ptr -> seek_key = exdim_seek;
     1631 						/* next_key remains NULL */
     1632 		fill = "110110110"b;		/* Should never be used. */
     1633 	     end;
     1634 
     1635 
     1636 	else do;					/* complain if an invalid opening mode was requested. */
     1637 		current_mode_name = iox_modes (mode);
     1638 		call error (error_table_$request_not_recognized, current_mode_name); /* complain if invalid opening mode */
     1639 	     end;
     1640 
     1641 
     1642 	mask_str = "0"b;				/* initialize ips_ mask */
     1643 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     1644 	call hcs_$set_ips_mask (mask_str, mask_str);
     1645 
     1646 /*  The file is now open.  Set up to allow a close, but not an open or detach. */
     1647 
     1648 	real_iocb_ptr -> close = exdim_close;
     1649 	real_iocb_ptr -> open,
     1650 	     real_iocb_ptr -> detach_iocb = iox_$err_not_closed;
     1651 
     1652 
     1653 	real_iocb_ptr -> open_descrip_ptr = addr (open_descrip); /* fill in IOCB open descrip. pointer */
     1654 
     1655 	call iox_$propagate (iocb_ptr);		/* let iox_ have a turn again */
     1656 
     1657 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     1658 
     1659 	a_code = 0;				/* give successful code */
     1660 	return;					/* auf wiedersehen */
     1661 
     1662 /*  End of OPEN module  */
     1663 
     1664 /*  Start of SEEK module  */
     1665 
     1666 exdim_seek: entry (a_iocb_ptr, a_key, a_rec_len, a_code);
     1667 
     1668 /*
     1669*   *      S__e_e_k_K__e_y_O__p_e_r_a_t_i_o_n
     1670*
     1671*
     1672*   *           This operation returns a status code of 0 for any key that  is  a
     1673*   *      valid  sector  number.   The  record  length  returned  is  always 256
     1674*   *      (current physical sector size in characters) for any valid  key.   The
     1675*   *      specified key must be a character string that could have been produced
     1676*   *      by  editing  through  a  PL/I picture of "(8)9".
     1677*   *      This operation is supported for only the direct opening modes.
     1678**/
     1679 
     1680 	dcl     a_key		 char (256) varying;/* parameter:   key to seek on  */
     1681 
     1682 	call setup ("open");			/* set up working environment */
     1683 	if mode = Direct_input | mode = Direct_update then ;
     1684 	else call error (error_table_$no_record, "seek valid only for direct openings.");
     1685 
     1686 	temp_key = cv_dec_check_ (ltrim (rtrim (a_key)), code);
     1687 	if code ^= 0
     1688 	then call error (error_table_$no_record, (a_key));
     1689 
     1690 	if (temp_key < bounds.low) | (temp_key > bounds.high) then
     1691 	     call error (error_table_$no_record, "Requested sector outside available area.");
     1692 	else next_key, current_key = temp_key;
     1693 						/* key_for_insertion is not changed */
     1694 
     1695 	a_rec_len = 4 * sect_size;			/* return canned rec. len. of sect. size (chars.) */
     1696 	a_code = 0;				/* and good code */
     1697 	return;					/* 'til next time */
     1698 
     1699 /*  End of SEEK module  */
     1700 
     1701 
     1702 /*  Start of READ and WRITE modules  */
     1703 
     1704 exdim_read: entry (a_iocb_ptr, a_ubuf_ptr, a_ubuf_len, a_rec_len, a_code);
     1705 
     1706 /*
     1707*   *	     If the amount of data to be read does  not  terminate  on  a
     1708*   *	sector  boundary,  the  excess portion of the last sector will be
     1709*   *	discarded.  A zero code will be  returned  in  this  case.
     1710**/
     1711 
     1712 	call setup ("open");			/* set up working environment */
     1713 
     1714 
     1715 	if next_key = NULL then
     1716 	     call error (error_table_$no_record, "next_key must be non-null to read");
     1717 	else if next_key = END then do;
     1718 		next_key = NULL;
     1719 		current_key = NULL;
     1720 		call error (error_table_$device_end, "Attempted to read (di, du) past end of avilable area.");
     1721 	     end;
     1722 	io_command = "read";			/* set switch for read */
     1723 
     1724 	rec_len = a_ubuf_len;
     1725 	a_rec_len = 0;
     1726 	key = next_key;				/* set working key value */
     1727 	go to read_write_common;			/* proceed  to common code */
     1728 
     1729 exdim_rewrite: entry (a_iocb_ptr, a_ubuf_ptr, a_rec_len, a_code);
     1730 
     1731 /*
     1732*   *           If the amount of data to be  written  does  not  terminate  on  a
     1733*   *      sector  boundary,  the  remaining portion of the last sector is filled
     1734*   *      with  spaces in  sequential modes and binary zeros in direct modes.  A
     1735*   *      code  of 0  is returned  in  this  case.  This
     1736*   *      operation is supported for only the update opening modes.
     1737**/
     1738 
     1739 	call setup ("open");			/* set up working environment */
     1740 
     1741 	if current_key = NULL then
     1742 	     call error (error_table_$no_record, "Attempted to rewrite before the start of the file.");
     1743 	else if current_key = END then do;
     1744 		next_key = END;
     1745 		call error (error_table_$device_end, "Attempted to rewrite when already at the end of the file.");
     1746 	     end;
     1747 
     1748 	io_command = "rewrite";			/* set switch for rewrite */
     1749 
     1750 
     1751 	rec_len = a_rec_len;			/* set output record length */
     1752 	key = current_key;				/* set working key */
     1753 
     1754 
     1755 read_write_common:
     1756 
     1757 /*
     1758*   *      For  all other opening modes, if an attempt is made to read or
     1759*   *      write beyond the end of the user-accessible area on disk, the  code
     1760*   *      error_table_$device_end  is   returned.   If  a  defective  track  is
     1761*   *      encountered or if any other unrecoverable data transmission  error  is
     1762*   *      encountered, the code error_table_$device_parity is returned.
     1763*   *
     1764*   *           The  record length is specified through the buff_len parameter in
     1765*   *      the read_record operation, and through the rec_len parameter  for
     1766*   *      rewrite  operation.
     1767**/
     1768 
     1769 	dcl     sectors_for_record	 fixed bin;	/* Qty. of sectors necessary to hold the record to be written */
     1770 	dcl     potential_next_sector	 fixed bin (21);	/* Tentative address of sector immediately following the last */
     1771 						/* sector this record will occupy if this is a write. */
     1772 
     1773 	sectors_for_record = ceil (rec_len / (4 * sect_size));
     1774 
     1775 	potential_next_sector = key + sectors_for_record;
     1776 
     1777 	if key = NULL then do;			/* if he didn't do a seek */
     1778 		code = error_table_$no_record;	/* complain */
     1779 		call io_err ("0"b);
     1780 	     end;
     1781 
     1782 	if io_command = "rewrite" then
     1783 	     if potential_next_sector > bounds.high + 1 then
     1784 		call error (error_table_$no_operation, "Record will not fit in space left on disk.");
     1785 
     1786 	ubuf_ptr = a_ubuf_ptr;			/* grab pointer to user buffer */
     1787 
     1788 	track_indicators = "00"b;			/* reset ti bits if set */
     1789 
     1790 
     1791 
     1792 /*  if record longer than maximum or current ioi_ buffer size */
     1793 
     1794 
     1795 	if (rec_len > 4 * (floor ((max_buff_size - overhead) / sect_size) * sect_size))
     1796 	     | (rec_len > 4 * floor (data_len / sect_size) * sect_size) then
     1797 	     call error (error_table_$no_operation, "Invalid record length.");
     1798 
     1799 
     1800 	block_ptr = ubuf_ptr;			/* initialize block pointer */
     1801 	block_len = ceil (ceil (rec_len / 4) / sect_size) * sect_size; /* and block length */
     1802 	data_left = rec_len;			/* and data left to xmit */
     1803 	call do_io;				/* go do the I/O  */
     1804 
     1805 
     1806 io_succeeded:
     1807 
     1808 /* 			PATH 1 */
     1809 
     1810 	if io_command = "read" then do;
     1811 
     1812 		current_key = next_key;
     1813 		a_rec_len = rec_len;		/* Send back length of data actually read. */
     1814 		next_key = NULL;			/* mode = direct_update */
     1815 
     1816 
     1817 	     end;
     1818 
     1819 
     1820 /* 			PATH 2 */
     1821 
     1822 	else if io_command = "rewrite" then /* No change to  current_key  */
     1823 
     1824 	     next_key = NULL;			/* mode = direct_update */
     1825 
     1826 
     1827 /* Do this every time, for any case */
     1828 
     1829 	a_code = 0;				/* give good  code */
     1830 	return;					/* come again, sometime */
     1831 
     1832 
     1833 
     1834 /*  Internal Procedure to  reset certain fields after the occurrence of an I/O error  */
     1835 
     1836 io_err: proc (clear_space);
     1837 
     1838 	dcl     clear_space		 bit (1);		/*  flag to tell us to zap ioi_ workspace */
     1839 
     1840 	if clear_space then do;			/* if space  no good */
     1841 		buf_ptr = null;			/* zap it!! */
     1842 		buf_len, data_len = 0;
     1843 	     end;
     1844 
     1845 	call error (code, "");			/* let user know */
     1846 
     1847      end io_err;
     1848 
     1849 
     1850 
     1851 /*  Internal procedure to actually perform I/O  */
     1852 
     1853 do_io: proc;
     1854 
     1855 	dcl     (true_len, data_read)	 fixed bin (35);	/* internal data  manipulation variables */
     1856 
     1857 	true_len = min (4 * block_len, data_left);	/* set true amount to xmit */
     1858 
     1859 
     1860 /* If we are going to write onto the disk, fill in unused area at end of the disk sector
     1861*   with zeros for direct opening modes
     1862*   or with ASCII spaces for sequential opening modes. */
     1863 /*  and fill in unused space with zeros */
     1864 
     1865 	if io_command ^= "read" then do;		/* if an output command  */
     1866 		substr (data, 1, true_len) = substr (block, 1, true_len); /* move data to ioi_ buffer */
     1867 		if true_len < 4 * block_len then unspec (substr (data, true_len + 1, 4 * block_len - true_len)) = fill;
     1868 	     end;
     1869 
     1870 	idcwp = addr (sk_idcw);			/* get pointer to  seek IDCW */
     1871 	idcw = seek_idcw_template;			/* move in template seek IDCW */
     1872 	idcw.device = bit (drive);			/* set drive no. */
     1873 	count_limit_fixed = ceil (block_len / sect_size); /* and sector  count limit  in seek data */
     1874 
     1875 	if key <= last_sect_num (dev_type)		/* in the data region */
     1876 	then goto BUILD_DATA_SEEK (device_group);
     1877 	else if key <= last_alt_sect_num (dev_type)	/* in the alternate region */
     1878 	then goto BUILD_ALT_SEEK (device_group);
     1879 
     1880 	else
     1881 	     call error (error_table_$no_record, "Requested record outside available area.");
     1882 
     1883 
     1884 BUILD_DATA_SEEK (1):				/* Data region on MSU04XX device */
     1885 BUILD_ALT_SEEK (1):					/* Alternate track region on MSU04XX device */
     1886 BUILD_DATA_SEEK (2):				/* Data region on MSU0500/1 device */
     1887 BUILD_NORMAL_SEEK:
     1888 
     1889 	unspec (seek) = "0"b;
     1890 	seek.block_count_limit = count_limit_fixed;
     1891 	seek.ti = track_indicators;
     1892 	seek.sector = key;
     1893 	unspec (seek_data) = unspec (seek);
     1894 	goto SEEK_BUILT;
     1895 
     1896 
     1897 BUILD_ALT_SEEK (2):					/* Alternate track region on MSU0500/1 device */
     1898 
     1899 
     1900 	idcw.command = SPECIAL_SEEK;
     1901 
     1902 
     1903 BUILD_SUPER_SEEK:
     1904 
     1905 	unspec (super_seek) = "0"b;
     1906 	super_seek.sector_number = mod (key, sect_per_track (dev_type));
     1907 	super_seek.ti = track_indicators;
     1908 	super_seek.is_super_seek = "1"b;
     1909 	super_seek.flag = "1"b;			/* ON => sector number in 0-12 rather than block count limit */
     1910 	cyl = divide (key, sect_per_cyl (dev_type), 16, 0);
     1911 	head = mod (key, sect_per_cyl (dev_type));
     1912 	head = divide (head, sect_per_track (dev_type), 16, 0) * 2 + mod (cyl, 2);
     1913 	if mod (cyl, 2) = mod (drive, 2) then /* see EPS for details of this crock */
     1914 	     if mod (cyl, 2) = 0 then cyl = cyl + 1;
     1915 	     else cyl = cyl - 1;
     1916 	super_seek.cyl_lower = mod (cyl, 256);
     1917 	super_seek.cyl_upper = divide (cyl, 256, 2, 0);
     1918 	super_seek.head = head;
     1919 	unspec (seek_data) = unspec (super_seek);
     1920 	goto SEEK_BUILT;
     1921 
     1922 
     1923 BUILD_DATA_SEEK (3):				/* Data region on MSU3380 & MSU3381 devices */
     1924 
     1925 	idcw.command = SEEK_512;
     1926 	goto BUILD_NORMAL_SEEK;
     1927 
     1928 
     1929 BUILD_ALT_SEEK (3):					/* Alternate track region on MSU3380 & MSU3381 devices */
     1930 
     1931 
     1932 	idcw.command = SPECIAL_SEEK_512;
     1933 	goto BUILD_SUPER_SEEK;
     1934 
     1935 
     1936 SEEK_BUILT:					/* Seek command and data are ready */
     1937 
     1938 	dcwp = addr (sk_dcw);			/* get pointer to seek DCW */
     1939 	dcw = seek_dcw_template;			/* put in canned value */
     1940 	dcw.address = rel (addr (seek_data));		/* fill in data address */
     1941 
     1942 	idcwp = addr (rw_idcw);			/* get pointer to read/write IDCW */
     1943 
     1944 	if (io_command = "read") then idcw = read_idcw_template; /* if read, put in canned read value */
     1945 	else if compare_sw then /*  put in compare comd. if in that mode */
     1946 	     idcw = write_and_compare_idcw_template;
     1947 	else idcw = write_idcw_template;		/* normal write */
     1948 
     1949 
     1950 	idcw.chan_cmd = INHIB_AUTO_RETRY;		/* inhibit mpc auto retries */
     1951 	idcw.device = bit (drive);			/*  fill in drive number */
     1952 
     1953 	dcwp = addr (rw_dcw);			/* get pointer to read/write DCW */
     1954 	dcw = read_write_dcw_template;		/* put in canned value */
     1955 	dcw.address = rel (addr (data));		/* fill in data address */
     1956 	dcw.tally = bit (block_len);			/* fill in tally */
     1957 
     1958 	dcw_offset = fixed (rel (addr (sk_idcw)));	/* set offset for ioi_ */
     1959 
     1960 	again = "1"b;				/* so we do it at least once */
     1961 	err_ct = 0;				/* init. error count */
     1962 
     1963 	do while (again);				/* I/O loop */
     1964 
     1965 	     completion.st = "0"b;			/* initialize status entry */
     1966 	     completion.run = "1"b;
     1967 
     1968 	     call ioi_$connect (devx, dcw_offset, code);	/* Start I/O */
     1969 	     if code ^= 0 then call io_err ("0"b);	/* didn't get away from the starting line */
     1970 
     1971 	     do while (^completion.st & completion.run);	/* while connected and no status */
     1972 
     1973 		call ipc_$block (addr (wait_list), addr (event_info), code); /* wait for completion */
     1974 		if code ^= 0 then call io_err ("0"b);	/* No loiterers?? */
     1975 
     1976 	     end;
     1977 
     1978 	     again = "0"b;				/* set for no retry */
     1979 
     1980 	     if completion.time_out |
     1981 		^(completion.st | completion.er | completion.run | completion.time_out) /* if nothing */
     1982 	     then call retry;			/* try again */
     1983 
     1984 	     else if level <= 1 then call perm_err;	/* if fault */
     1985 
     1986 	     else if level > 3 then call retry;		/* if special or marker */
     1987 
     1988 	     else if status.maj = ATTENTION then
     1989 		if status.sub & STANDBY then call delay_retry; /* other MPC may have control */
     1990 		else call perm_err;			/* just plain attention, let user know */
     1991 
     1992 	     else if status.maj = EOF then
     1993 		if (status.sub & LAST_BLOCK_MASK = LAST_BLOCK) then do; /* if we've run off end of the pack */
     1994 			if (io_command = "read") then do; /* and we were reading */
     1995 				data_read = min (true_len, (block_len - fixed (status.residue) - 1) * 4); /* amount read */
     1996 				substr (block, 1, data_read) = substr (data, 1, data_read); /* give user what we can */
     1997 				a_rec_len, rec_len = rec_len - data_left + data_read; /* and tell him how much */
     1998 				unspec (substr (block, rec_len + 1, data_left - data_read)) = fill;
     1999 						/* spaces for sequential; zeros for direct */
     2000 			     end;
     2001 
     2002 
     2003 			else code = error_table_$device_end; /* all other modes */
     2004 
     2005 
     2006 			call io_err ("0"b);		/* tell user */
     2007 		     end;
     2008 
     2009 		else call perm_err;			/* any other EOF is bad news */
     2010 
     2011 	     else if status.maj ^= "0000"b then call perm_err; /* don't beat a dead horse */
     2012 
     2013 	end;
     2014 
     2015 	if (io_command = "read") then do;		/* if normal read command */
     2016 		substr (block, 1, true_len) = substr (data, 1, true_len); /* give the user his data */
     2017 		rec_len = true_len;			/* Send back length of data actually read. */
     2018 	     end;
     2019 
     2020 
     2021      end do_io;
     2022 
     2023 
     2024 
     2025 /*  Internal procedure to retry I/O  */
     2026 
     2027 retry: proc;
     2028 
     2029 	if status.maj ^= ATTENTION then err_ct = err_ct + 1; /* don't keep track of attentions */
     2030 
     2031 	if err_ct <= max_retries then do;		/* is it worth while? */
     2032 		idcwp = addr (rst_idcw);		/* yes, get pointer to restore IDCW */
     2033 		idcw = restore_idcw_template;		/* put in canned restore value */
     2034 		idcw.device = bit (drive);		/* fill in drive no. */
     2035 		dcw_offset = fixed (rel (addr (rst_idcw))); /* set up offset for ioi_ */
     2036 		again = "1"b;			/* and set flag to try again */
     2037 	     end;
     2038 	else call perm_err;				/* our patience has worn thin */
     2039 
     2040      end retry;
     2041 
     2042 
     2043 
     2044 /*  Internal procedure to handle ATTENTION status with STANDBY sub-status.  */
     2045 
     2046 delay_retry: proc;
     2047 
     2048 /*  Have been told that this status occurs in dual-MPC configurations
     2049*   if the other MPC has the device.  This procedure merely delays for a
     2050*   short time, and then retries.  */
     2051 
     2052 	err_ct = err_ct + 1;			/* keep track of how often we do this */
     2053 
     2054 	if err_ct >= max_retries then do;		/* if too often */
     2055 		err_ct = 0;			/* reset error count */
     2056 		call perm_err;			/* let user decide what to do */
     2057 	     end;
     2058 	else do;
     2059 		call timer_manager_$sleep (500000, "10"b); /* delay for 1/2 sec.  */
     2060 		call retry;			/* and try again */
     2061 	     end;
     2062 
     2063      end delay_retry;
     2064 
     2065 
     2066 
     2067 
     2068 /*  Internal procedure to handle permanent I/O errors  */
     2069 
     2070 perm_err: proc;
     2071 
     2072 
     2073 
     2074 
     2075 	idcwp = addrel (buf_ptr, offset);		/* look at the offending DCW chain */
     2076 	do while (idcw.code ^= "111"b & fixed (rel (idcwp)) > 0); /* look for IDCW or beginning of seg */
     2077 	     idcwp = addrel (idcwp, -1);		/* back track */
     2078 	end;
     2079 	dcwp = addrel (idcwp, 1);			/* set to corresponding DCW */
     2080 	disk_info_ptr = addr (rcp_data);		/* initialize pointer first */
     2081 	call ioi_$get_detailed_status (devx, found, buffer.control_info.rsr_data, code);
     2082 	last_cmd_ = fixed ((substr (idcw.command, 1, 6)), 6);
     2083 
     2084 	if level <= 1 then do;
     2085 		call com_err_ (0, "exercise_disk:",
     2086 		     "Unrecoverable error on ^a device ^a, sector ^o (^d.).^/IOM Status:^-^w ^w^/IDCW/DCW Pair:^-^w ^w",
     2087 		     device_names (dev_type), disk_info.device_name, key, key,
     2088 		     substr (iom_stat, 1, 36), substr (iom_stat, 37, 36), idcw, dcw);
     2089 
     2090 	     end;
     2091 	errors = errors + 1;			/* increment pack  error count */
     2092 
     2093 	code = error_table_$device_parity;		/* tell user about his misfortune */
     2094 	goto exit;
     2095 
     2096      end perm_err;
     2097 
     2098 
     2099 
     2100 /*  Start of CONTROL module  */
     2101 
     2102 exdim_control: entry (a_iocb_ptr, order, a_info_ptr, a_code);
     2103 
     2104 /*
     2105*   *	     The  following  orders  are supported when the I/O switch is
     2106*   *	open, except for getbounds, which is supported while  the  switch
     2107*   *	is attached.
     2108**/
     2109 
     2110 	dcl     order		 char (*);	/* parameter: the control order */
     2111 	dcl     a_info_ptr		 ptr;		/* parameter:  pointer to supplemental information */
     2112 
     2113 	call setup ("don't_care");			/* set up working environment */
     2114 
     2115 	if order ^= "getbounds" then if real_iocb_ptr -> open_descrip_ptr = null then
     2116 		call error (error_table_$not_open,
     2117 		     "Only getbounds is allowed when file is not open.");
     2118 
     2119 	info_ptr = a_info_ptr;			/* grab pointer to additional info */
     2120 
     2121 	if order = "getbounds" then do;		/* process the "getbounds" order */
     2122 		user_bounds.low = bounds.low;		/* pass back the low bound */
     2123 		user_bounds.high = bounds.high;	/* and the high bound */
     2124 	     end;					/*  getbounds  */
     2125 
     2126 
     2127 	else if order = "disk_info" then do;		/* process the disk_info order */
     2128 		disk_info_ptr = addr (rcp_data);
     2129 		if info_ptr -> disk_info.version_num ^= disk_info.version_num
     2130 		then do;
     2131 			a_code = error_table_$unimplemented_version;
     2132 			return;
     2133 		     end;
     2134 		info_ptr -> disk_info = disk_info;
     2135 	     end;
     2136 
     2137 	else if order = "device_info" then do;		/* process the device_info order */
     2138 		disk_info_ptr = addr (rcp_data);	/* initialize pointer first */
     2139 		user_dev_char_table.user_subsystem_name = device_names (dev_type);
     2140 		user_dev_char_table.user_device_name = disk_info.device_name;
     2141 		user_dev_char_table.user_sect_per_dev = sect_per_dev;
     2142 		user_dev_char_table.user_cyl_per_dev = cyl_per_dev (dev_type);
     2143 		user_dev_char_table.user_sect_per_cyl = sect_per_cyl (dev_type);
     2144 		user_dev_char_table.user_sect_per_track = sect_per_track (dev_type);
     2145 		user_dev_char_table.user_num_label_sect = num_label_sect;
     2146 		user_dev_char_table.user_num_alt_sect = num_alt_sect;
     2147 		user_dev_char_table.user_sect_size = sect_size;
     2148 	     end;
     2149 
     2150 
     2151 
     2152 	else if order = "hardware_status" then do;	/* give user the hardware details */
     2153 		user_hardware_status = iom_stat;
     2154 		user_dev_detail_status = based_rsr_data;
     2155 		user_dev_cmd = last_cmd_;
     2156 	     end;
     2157 
     2158 	else call error (error_table_$no_operation, order); /* if bad order,  tell the user */
     2159 
     2160 	a_code = 0;				/* made it */
     2161 	return;					/* au revoir */
     2162 
     2163 /*  End of CONTROL module  */
     2164 
     2165 
     2166 
     2167 /*  Start of MODES module  */
     2168 
     2169 exdim_modes: entry (a_iocb_ptr, a_new_modes, a_code);
     2170 
     2171 /*
     2172*   *	     The modes operation is supported  when  the  I/O  switch  is
     2173*   *	attached. Each mode has a complement indicated by the character
     2174*   *      "^" (e.g. "^label")  that turns the mode off.
     2175*   *
     2176**/
     2177 
     2178 	dcl     a_new_modes		 char (*);	/* parameter: new modes string */
     2179 	dcl     temp_next_mode	 char (16);	/* for type conversion for call error */
     2180 
     2181 	call setup ("don't_care");			/* set up working environment */
     2182 
     2183 	mode_len = length (a_new_modes);		/* see how much we've got */
     2184 	if mode_len > 0 then do;			/* if something */
     2185 
     2186 		new_modes = a_new_modes;		/* grab the new modes */
     2187 		mode_start = 1;			/* keep track of where we are in the string */
     2188 
     2189 		do while (next_mode ^= "");		/* mode processing loop */
     2190 
     2191 		     call get_next_mode;		/* extract a  mode */
     2192 		     if next_mode ^= "" then do;	/* if we got one, do something with it */
     2193 
     2194 			     mode_err_sw = "0"b;	/* give user  the benefit of the doubt */
     2195 
     2196 			     if next_mode = "label"
     2197 			     then do;
     2198 				     bounds.low = num_label_sect; /* reserve label area */
     2199 				     label_sw = "1"b;
     2200 				end;
     2201 			     else if next_mode = "^label"
     2202 			     then do;
     2203 				     bounds.low = 0;/* let him  play,starting at sect. 0 */
     2204 				     label_sw = "0"b;
     2205 				end;
     2206 
     2207 			     else if (next_mode = "alttrk")
     2208 			     then do;
     2209 				     bounds.high = last_sect_num (dev_type); /* reserve alternate track area */
     2210 				     alt_sw = "1"b;
     2211 				end;
     2212 			     else if next_mode = "^alttrk"
     2213 			     then do;
     2214 				     if device_group = MSU04XX
     2215 				     then bounds.high = last_alt_sect_num (dev_type);
     2216 				     else bounds.high = last_sect_num (dev_type);
     2217 				     alt_sw = "0"b;
     2218 				end;
     2219 
     2220 			     else if next_mode = "wrtcmp" then compare_sw = "1"b; /* set compare mode switch */
     2221 			     else if next_mode = "^wrtcmp" then compare_sw = "0"b; /* set for ordinary write */
     2222 
     2223 			     else if next_mode = "raw" then do;
     2224 				     bounds.low = 0;/* let user have entire pack in this mode */
     2225 				     bounds.high = last_physical_sect_num (dev_type);
     2226 				     raw_sw = "1"b; /* set indicator */
     2227 				end;
     2228 			     else if next_mode = "^raw" then do;
     2229 				     if label_sw	/* in label mode */
     2230 				     then bounds.low = num_label_sect; /* reset origial defaults */
     2231 				     else bounds.low = 0;
     2232 				     if ^alt_sw /* in alt mode */
     2233 					& device_group = MSU04XX /* and on a 400 series device */
     2234 				     then bounds.high = last_alt_sect_num (dev_type);
     2235 				     else bounds.high = last_sect_num (dev_type);
     2236 				     raw_sw = "0"b; /* reset raw indicator */
     2237 				end;
     2238 			     else do;		/* oh oh */
     2239 				     code = error_table_$bad_mode; /* tried to fool mother exdim_, eh?  */
     2240 				     mode_err_sw = "1"b; /* can't let that happen */
     2241 				end;
     2242 
     2243 			     if ^mode_err_sw then call set_mode; /* update the mode string */
     2244 
     2245 			end;
     2246 		end;
     2247 	     end;
     2248 
     2249 	temp_next_mode = next_mode || "                "; /* obtain proper type for */
     2250 	temp_next_mode = substr (temp_next_mode, 1, 16);	/* the call to error */
     2251 	if code ^= 0 then call error (code, temp_next_mode); /* let him know how he did */
     2252 	else a_code = 0;
     2253 
     2254 	return;					/* don't rush off */
     2255 
     2256 /*  Internal procedure to extract single modes from the mode string  */
     2257 
     2258 get_next_mode: proc;
     2259 
     2260 	if mode_len > 0 then do;			/* if we still have something left */
     2261 
     2262 		new_modes = substr (new_modes, mode_start, mode_len); /* update work string */
     2263 
     2264 		i = index (new_modes, ",");		/* set i to length of next mode + 1 */
     2265 		if i = 0 then do;
     2266 			i = index (new_modes, " ");
     2267 			if i = 0 then i = mode_len + 1;
     2268 		     end;
     2269 
     2270 		mode_len = mode_len - i;		/* keep track of how much we have left */
     2271 		mode_start = i + 1;			/* and where to start */
     2272 		next_mode = substr (new_modes, 1, i - 1); /* pass back the mode */
     2273 
     2274 	     end;
     2275 
     2276 	else next_mode = "";			/* nothing to return */
     2277 
     2278      end get_next_mode;
     2279 
     2280 /*  Internal procedure to update the mode string  */
     2281 
     2282 set_mode: proc;
     2283 
     2284 	not_sw = (substr (next_mode, 1, 1) = "^");	/* set switch if a  "^" mode */
     2285 
     2286 	i = index (mode_string, substr (next_mode, 1 + fixed (not_sw))); /* point to basic mode */
     2287 
     2288 	if i <= 1 then if not_sw then mode_string = "^" || mode_string; else ; /* if at beg. just prefix "^" */
     2289 
     2290 	else if not_sw & (substr (mode_string, i - 1, 1) ^= "^") /* insert a  "^" */
     2291 	then substr (mode_string, i) = "^" || substr (mode_string, i);
     2292 
     2293 	else if ^not_sw & (substr (mode_string, i - 1, 1) = "^") then /* delete a "^" */
     2294 	     substr (mode_string, i - 1) = substr (mode_string, i);
     2295 
     2296      end set_mode;
     2297 
     2298 /*  End of MODES module  */
     2299 
     2300 
     2301 
     2302 /*  Start of CLOSE module  */
     2303 
     2304 exdim_close: entry (a_iocb_ptr, a_code);
     2305 
     2306 /*
     2307*   This operation has no effect on the device, but merely  resets some
     2308*   fields in the IOCB.
     2309**/
     2310 
     2311 	call setup ("open");			/* set up working environment */
     2312 
     2313 	mask_str = "0"b;				/* initialize ips_ mask */
     2314 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     2315 	call hcs_$set_ips_mask (mask_str, mask_str);
     2316 
     2317 	real_iocb_ptr -> open_descrip_ptr = null;	/* put IOCB in closed state;  open descrip. pointer */
     2318 
     2319 	real_iocb_ptr -> open = exdim_open;		/* set open entry */
     2320 	real_iocb_ptr -> detach_iocb = exdim_detach;	/* and detach entry */
     2321 
     2322 	real_iocb_ptr -> close,			/* shut the close entry */
     2323 	     real_iocb_ptr -> read_record,		/* and the read record entry */
     2324 	     real_iocb_ptr -> rewrite_record,		/* and the rewrite record entry */
     2325 	     real_iocb_ptr -> position,		/* and the position entry */
     2326 	     real_iocb_ptr -> write_record,		/* and the write record entry */
     2327 	     real_iocb_ptr -> seek_key = iox_$err_not_open; /* and the seek key entry */
     2328 
     2329 	call iox_$propagate (iocb_ptr);		/* give iox_ a turn */
     2330 
     2331 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     2332 
     2333 	next_key, current_key, key_for_insertion = NULL;	/* reset all keys to invalid state */
     2334 
     2335 	a_code = 0;				/* be nice to him */
     2336 	return;					/* and he may call us again, sometime */
     2337 
     2338 /*  End of CLOSE module  */
     2339 
     2340 /*  Start of DETACH  module  */
     2341 
     2342 exdim_detach: entry (a_iocb_ptr, a_code);
     2343 
     2344 /*
     2345*   This operation dismounts and detaches the device, and cleans up the IOCB.
     2346**/
     2347 
     2348 	call setup ("closed");			/* set up working environment */
     2349 
     2350 /* The following code dismounts the pack.  It can be deleted when RCP gets around to doing this. */
     2351 
     2352 	if media_removable (dev_type)
     2353 	then do;					/* unload the pack */
     2354 		idcwp = addr (rst_idcw);		/* use the restore IDCW slot */
     2355 		idcw = standby_idcw_template;		/* and put in canned standby idcw */
     2356 		idcw.device = bit (drive);		/* fill in drive number */
     2357 		dcw_offset = fixed (rel (addr (rst_idcw))); /* and offset  for ioi_ */
     2358 		call ioi_$connect (devx, dcw_offset, code); /* start it up, we won't wait for it to finish */
     2359 	     end;
     2360 
     2361 
     2362 	call rcp_$detach (rcp_id, (DEFAULT), errors, "", code); /* detach the device */
     2363 
     2364 	call ipc_$delete_ev_chn (ev_chan, code);	/* get rid of event channel */
     2365 
     2366 	call hcs_$delentry_seg (disk_ptr, code);	/* get rid of work segment */
     2367 	disk_ptr = null;				/* null the pointer */
     2368 
     2369 	mask_str = "0"b;				/* initialize ips_ mask */
     2370 	call default_handler_$set (cond_hdlr);		/* protect ourselves */
     2371 	call hcs_$set_ips_mask (mask_str, mask_str);
     2372 
     2373 	iocb_ptr -> attach_data_ptr = null;		/* clean up the IOCB;  null the data pointer */
     2374 	iocb_ptr -> attach_descrip_ptr = null;		/* and the attach descrip. pointer */
     2375 
     2376 	iocb_ptr -> iocb.control,			/* reset control */
     2377 	     iocb_ptr -> iocb.modes = iox_$err_no_operation; /* and modes operations */
     2378 
     2379 	call iox_$propagate (iocb_ptr);		/* tell iox_ */
     2380 
     2381 	call hcs_$reset_ips_mask (mask_str, mask_str);	/* back to normal */
     2382 
     2383 	if code ^= 0 then call error (code, "Problem in detaching."); /* tell user if something went wrong */
     2384 
     2385 	a_code = 0;				/* otherwise, give him a good send-off */
     2386 	return;
     2387 
     2388 /*  End of DETACH module  */
     2389 
     2390 /*  Internal SETUP Procedure  */
     2391 
     2392 setup: proc (setup_input_arg);
     2393 
     2394 	dcl     setup_input_arg	 char (*);
     2395 	dcl     desired_switch_state	 char (12) varying;
     2396 
     2397 /*  call setup ("open")       means the switch should be open   -- complain if it is closed.  */
     2398 /*  call setup ("closed")       "    "     "     "    "  closed --    "     "  "  "    open.  */
     2399 /*  call setup ("don't_care") means that the switch can be either open or closed.  */
     2400 
     2401 	dcl     who_did_the_attach	 char (6);	/*  Which I/O module attached this file?  */
     2402 	dcl     setup_error_msg	 char (36);	/*  temporary error message  */
     2403 
     2404 	code = 0;					/* give him a chance to make it */
     2405 
     2406 	desired_switch_state = setup_input_arg;
     2407 	iocb_ptr = a_iocb_ptr;			/* pick up pointer to IOCB */
     2408 	real_iocb_ptr = iocb_ptr -> actual_iocb_ptr;	/* the real one, this time */
     2409 	disk_ptr = real_iocb_ptr -> attach_data_ptr;	/* and a pointer to our work seg */
     2410 
     2411 	if real_iocb_ptr -> attach_descrip_ptr = null then
     2412 	     call error (error_table_$not_attached, "");
     2413 						/*  must be attached */
     2414 
     2415 	who_did_the_attach = substr (attach_descrip.descrip, 1, index (attach_descrip.descrip, " ") - 1);
     2416 	if who_did_the_attach ^= "exdim_" then do;
     2417 		setup_error_msg = "Not attached by exdim_ but by " || who_did_the_attach;
     2418 		call error (error_table_$not_attached, setup_error_msg);
     2419 	     end;
     2420 
     2421 
     2422 	if desired_switch_state = "open" then
     2423 	     if real_iocb_ptr -> open_descrip_ptr = null then
     2424 		call error (error_table_$not_open, "");
     2425 
     2426 	     else if desired_switch_state = "closed" then
     2427 		if real_iocb_ptr -> open_descrip_ptr ^= null then
     2428 		     call error (error_table_$not_closed, "");
     2429 
     2430 		else if desired_switch_state = "don't_care" then
     2431 		     return;
     2432 
     2433      end setup;
     2434 
     2435 
     2436 /*  Internal ERROR Procedure  */
     2437 
     2438 error: proc (cd, err_msg);
     2439 
     2440 	dcl     cd		 fixed bin (35);	/* code */
     2441 	dcl     err_msg		 char (*);	/* Additional text. */
     2442 
     2443 	code = cd;				/* set code */
     2444 	go to exit;				/* and exit, stage right */
     2445 
     2446      end error;
     2447 
     2448 
     2449 
     2450 /*  Internal PACK MOUNT procedure  */
     2451 
     2452 mount: proc;
     2453 
     2454 
     2455 	errors = 0;				/* give the pack a fresh start */
     2456 
     2457 	disk_info_ptr = addr (rcp_data);		/* init. disk info prior to attaching device */
     2458 	disk_info.volume_name = pack_id;		/* fill in new pack id */
     2459 
     2460 	call rcp_$attach ((rcp_dev_type), disk_info_ptr, ev_chan, "", rcp_id, code); /* attach device */
     2461 	if code ^= 0 then return;			/* let caller handle problems */
     2462 
     2463 	call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, (time_int), rcp_state, code);
     2464 	if code ^= 0 then return;			/* check attachment completion */
     2465 
     2466 	do while (rcp_state ^= COMPLETE);		/* loop until attachment is complete or fails */
     2467 	     on cleanup call detach;			/* detach disk if user aborting */
     2468 	     call ipc_$block (addr (wait_list), addr (event_info), code); /* wait to hear from rcp_ */
     2469 	     revert cleanup;
     2470 	     if code ^= 0 then return;
     2471 	     call rcp_$check_attach (rcp_id, disk_info_ptr, "", devx, max_buff_size, (time_int), rcp_state, code);
     2472 	     if code ^= 0 then return;		/* let caller worry about it */
     2473 	     if rcp_state < COMPLETE | rcp_state >= LONG_WAIT then do;
     2474 		     code = error_table_$action_not_performed; /* let user know he has a problem */
     2475 		     return;			/* let caller pass bad news to user */
     2476 		end;
     2477 	end;
     2478 
     2479 	if drive = NOT_SET then do;
     2480 		drive_number.sign = "+";		/* successful assignment, convert and save drive number */
     2481 		drive_number.number = substr (disk_info.device_name, 6, 2);
     2482 		drive = drive_dec;
     2483 	     end;
     2484 
     2485 	buf_len = min (max (divide (sze, 4, 17, 0), 1024), max_buff_size); /* determine ioi_ buffer size */
     2486 	call ioi_$workspace (devx, buf_ptr, buf_len, code); /* and try to get it */
     2487 	if code ^= 0 then return;			/* win some -- lose some */
     2488 	data_len = buf_len - overhead;		/* set length of data area */
     2489 
     2490 	call ioi_$set_status (devx, fixed (rel (addr (istat))), 1, code); /* tell ioi_ how to reach us */
     2491 	if code ^= 0 then return;
     2492 
     2493 	call ioi_$timeout (devx, time_int, code);	/* have ioi_ do it */
     2494 	if code ^= 0 then return;			/* how do you like that! */
     2495 
     2496 detach: proc;
     2497 	call rcp_$detach (rcp_id, "0"b, (0), "", (0));
     2498 	return;
     2499      end detach;
     2500 
     2501      end mount;
     2502 
     2503 
     2504 
     2505 /*  Internal CONDITION HANDLER */
     2506 
     2507 cond_hdlr: proc (mc_ptr, cond_name, wc_mc_ptr, info_ptr, cont_sw);
     2508 
     2509 /*
     2510*   This procedure handles any unusual conditions signaled while we are
     2511*   masked by terminating the process.  This avoids problems we
     2512*   would have if we attempted to use an IOCB  which was left in an
     2513*   inconsistent state.
     2514**/
     2515 	dcl     (mc_ptr, wc_mc_ptr, info_ptr) ptr;
     2516 	dcl     cond_name		 char (*);	/* condition name */
     2517 	dcl     cont_sw		 bit (1) aligned;	/* continuation switch */
     2518 
     2519 	if masked then do;				/* if we were masked, kill the process */
     2520 		tp_info.version = 0;		/* currently version 0 */
     2521 		tp_info.code = error_table_$termination_requested; /* as good a reason as any */
     2522 		call terminate_process_ ("fatal_error", addr (tp_info)); /* do the dirty deed */
     2523 	     end;
     2524 
     2525 	if cond_name ^= "cleanup" then cont_sw = "1"b;	/* don't pass on cleanup */
     2526 
     2527      end cond_hdlr;
     2528 
     2529 
     2530 
     2531      end exdim_;
     2532 
     2533 
  1     1 /* BEGIN INCLUDE FILE iocbx.incl.pl1 */
  1     2 /* written 27 Dec 1973, M. G. Smith */
  1     3 /* returns attributes removed, hashing support BIM Spring 1981 */
  1     4 /* version made character string June 1981 BIM */
  1     5 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     6*      version number to IOX2. */
  1     7 /* format: style2 */
  1     8 
  1     9      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1    10 	     2 version	      character (4) aligned,	/* IOX2 */
  1    11 	     2 name	      char (32),		/* I/O name of this block. */
  1    12 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    13 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    14 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    15 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    16 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    17 	     2 event_channel      bit (72),		/* Event channel for asynchronous I/O. */
  1    18 	     2 detach_iocb	      entry (ptr, fixed bin (35)),
  1    19 						/* detach_iocb(p) */
  1    20 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed bin (35)),
  1    21 						/* open(p,mode,not_used) */
  1    22 	     2 close	      entry (ptr, fixed bin (35)),
  1    23 						/* close(p) */
  1    24 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
  1    25 						/* get_line(p,bufptr,buflen,actlen) */
  1    26 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
  1    27 						/* get_chars(p,bufptr,buflen,actlen) */
  1    28 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed bin (35)),
  1    29 						/* put_chars(p,bufptr,buflen) */
  1    30 	     2 modes	      entry (ptr, char (*), char (*), fixed bin (35)),
  1    31 						/* modes(p,newmode,oldmode) */
  1    32 	     2 position	      entry (ptr, fixed, fixed (21), fixed bin (35)),
  1    33 						/* position(p,u1,u2) */
  1    34 	     2 control	      entry (ptr, char (*), ptr, fixed bin (35)),
  1    35 						/* control(p,order,infptr) */
  1    36 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
  1    37 						/* read_record(p,bufptr,buflen,actlen) */
  1    38 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed bin (35)),
  1    39 						/* write_record(p,bufptr,buflen) */
  1    40 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed bin (35)),
  1    41 						/* rewrite_record(p,bufptr,buflen) */
  1    42 	     2 delete_record      entry (ptr, fixed bin (35)),
  1    43 						/* delete_record(p) */
  1    44 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed bin (35)),
  1    45 						/* seek_key(p,key,len) */
  1    46 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed bin (35)),
  1    47 						/* read_key(p,key,len) */
  1    48 	     2 read_length	      entry (ptr, fixed (21), fixed bin (35)),
  1    49 						/* read_length(p,len) */
  1    50 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    51 						/* open_file(p,mode,desc,not_used,s) */
  1    52 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    53 						/* close_file(p,desc,s) */
  1    54 	     2 detach	      entry (ptr, char (*), fixed bin (35)),
  1    55 						/* detach(p,desc,s) */
  1    56 						/* Hidden information, to support SYN attachments. */
  1    57 	     2 ios_compatibility  ptr,		/* Ptr to old DIM's IOS transfer vector. */
  1    58 	     2 syn_inhibits	      bit (36),		/* Operations inhibited by SYN. */
  1    59 	     2 syn_father	      ptr,		/* IOCB immediately SYNed to. */
  1    60 	     2 syn_brother	      ptr,		/* Next IOCB SYNed as this one is. */
  1    61 	     2 syn_son	      ptr,		/* First IOCB SYNed to this one. */
  1    62 	     2 hash_chain_ptr     ptr;		/* Next IOCB in hash bucket */
  1    63 
  1    64      declare iox_$iocb_version_sentinel
  1    65 			      character (4) aligned external static;
  1    66 
  1    67 /* END INCLUDE FILE iocbx.incl.pl1 */
     2534 
     2535 
  2     1 
  2     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  2     3 
  2     4 dcl  pcwp ptr;					/* pointer to PCW */
  2     5 
  2     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  2     7      (2 command bit (6),				/* device command */
  2     8       2 device bit (6),				/* device code */
  2     9       2 ext bit (6),				/* address extension */
  2    10       2 code bit (3),				/* should be "111"b for PCW */
  2    11       2 mask bit (1),				/* channel mask bit */
  2    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  2    13       2 chan_cmd bit (6),				/* type of I/O operation */
  2    14       2 count bit (6),				/* record count or control character */
  2    15       2 mbz1 bit (3),
  2    16       2 channel bit (6),				/* channel number */
  2    17       2 mbz2 bit (27)) unal;
  2    18 
  2    19 dcl  idcwp ptr;					/* pointer to IDCW */
  2    20 
  2    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  2    22      (2 command bit (6),				/* device command */
  2    23       2 device bit (6),				/* device code */
  2    24       2 ext bit (6),				/* address extension */
  2    25       2 code bit (3),				/* should be "111"b for PCW */
  2    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  2    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  2    28       2 chan_cmd bit (6),				/* type of I/O operation */
  2    29       2 count bit (6)) unal;				/* record count or control character */
  2    30 
  2    31 /* End include file ...... iom_pcw.incl.pl1 */
  2    32 
     2536 
     2537 
  3     1 
  3     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  3     3 
  3     4 dcl  dcwp ptr,					/* pointer to DCW */
  3     5      tdcwp ptr;					/* pointer to TDCW */
  3     6 
  3     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  3     8      (2 address bit (18),				/* address for data transfer */
  3     9       2 char_pos bit (3),				/* character position */
  3    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  3    11       2 type bit (2),				/* DCW type */
  3    12       2 tally bit (12)) unal;				/* tally for data transfer */
  3    13 
  3    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  3    15      (2 address bit (18),				/* address to transfer to */
  3    16       2 mbz1 bit (4),
  3    17       2 type bit (2),				/* should be "10"b for TDCW */
  3    18       2 mbz2 bit (9),
  3    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  3    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  3    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  3    22 
  3    23 /* End of include file ...... iom_dcw.incl.pl1 */
  3    24 
     2538 
     2539 
  4     1 /*	Begin  include file rcp_disk_info.incl.pl1
  4     2**
  4     3**	Created on 03/31/74 by Bill Silver.
  4     4**	This include file defines the RCP device info structure for disks.
  4     5**/
  4     6 
  4     7 
  4     8 
  4     9 
  4    10 /****^  HISTORY COMMENTS:
  4    11*  1) change(86-06-03,Hartogs), approve(86-06-03,MCR7383),
  4    12*     audit(86-06-06,GWMay), install(86-07-18,MR12.0-1098):
  4    13*     Added DISK_INFO_VERSION_1 constant.
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 
  4    17 dcl	disk_info_ptr	ptr;		/* Pointer to disk device info structure. */
  4    18 
  4    19 dcl    1	disk_info based(disk_info_ptr) aligned,	/* RCP device info structure for disks. */
  4    20 	2  version_num	fixed bin,	/* Version number of this structure. */
  4    21 	2  usage_time	fixed bin,	/* Number of minutes drive will/may be used. */
  4    22 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
  4    23 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
  4    24 	2  device_name	char(8),		/* Disk drive name. */
  4    25 	2  model		fixed bin,	/* Disk drive model number. */
  4    26 	2  volume_name	char(32),		/* Disk pack name. */
  4    27 	2  write_flag	bit(1);		/* ON => writing on disk pack. */
  4    28 
  4    29 dcl       DISK_INFO_VERSION_1 fixed bin int static options (constant) init (1);
  4    30 
  4    31 /*	End of include file ... rcp_disk_info.incl.pl1	*/
     2540 
     2541 
  5     1 /* Begin include file ..... iox_modes.incl.pl1 */
  5     2 
  5     3 /* Written by C. D. Tavares, 03/17/75 */
  5     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  5     5 
  5     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  5     7     ("stream_input", "stream_output", "stream_input_output",
  5     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  5     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  5    10      "direct_input", "direct_output", "direct_update");
  5    11 
  5    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  5    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  5    14 
  5    15 dcl (Stream_input initial (1),
  5    16      Stream_output initial (2),
  5    17      Stream_input_output initial (3),
  5    18      Sequential_input initial (4),
  5    19      Sequential_output initial (5),
  5    20      Sequential_input_output initial (6),
  5    21      Sequential_update initial (7),
  5    22      Keyed_sequential_input initial (8),
  5    23      Keyed_sequential_output initial (9),
  5    24      Keyed_sequential_update initial (10),
  5    25      Direct_input initial (11),
  5    26      Direct_output initial (12),
  5    27      Direct_update initial (13)) fixed bin int static options (constant);
  5    28 
  5    29 /* End include file ..... iox_modes.incl.pl1 */
     2542 
     2543 
  6     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  6     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  6     6*     Add support for FIPS
  6     7*     3380.
  6     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  6     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  6    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  6    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  6    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  6    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  6    14*                                                   END HISTORY COMMENTS */
  6    15 
  6    16 /* Modified 5/19/76 by N. I. Morris */
  6    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  6    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  6    19 /* Modified '82 by BIM for needs_alt_part */
  6    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  6    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  6    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  6    23*   volmap and record stock can be expanded. */
  6    24 
  6    25 /*
  6    26********************************************************************************
  6    27**							        *
  6    28**                           WARNING:                                          *
  6    29**							        *
  6    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  6    31**   type is added.						        *
  6    32**							        *
  6    33**   There are other include files that contain arrays indexed by the device   *
  6    34**   index obtained by references to MODELX or MODELN in this include file.    *
  6    35**   These must be modified when a new device type is added:		        *
  6    36**   disk_pack.incl.pl1					        *
  6    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  6    38**							        *
  6    39********************************************************************************
  6    40**/
  6    41 
  6    42 
  6    43 dcl (maxdevt init (9),				/* maximum legal devt */
  6    44      bulkdevt init (1),				/* bulk store devt */
  6    45      msu0500devt init (2),				/* MSU0500 device type */
  6    46      msu0451devt init (3),				/* MSU0451 device type */
  6    47      msu0450devt init (3),				/* MSU0450 device type */
  6    48      msu0400devt init (4),				/* MSU0400 device type */
  6    49      dsu191devt init (4),				/* DSU191 device type */
  6    50      dsu190devt init (5),				/* DSU190 device type */
  6    51      dsu181devt init (6),				/* DSU181 device type */
  6    52      msu0501devt init (7),				/* MSU0501 device type */
  6    53      fips3380devt init (8),				/* 3380D FIPS device type */
  6    54      fips3381devt init (9)				/* 3380E FIPS device type */
  6    55      ) fixed bin (4) static options (constant);
  6    56 
  6    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  6    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  6    59 
  6    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  6    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  6    62 
  6    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  6    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  6    65 
  6    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  6    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  6    68 
  6    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  6    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  6    71 
  6    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  6    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  6    74 
  6    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  6    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  6    77 
  6    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  6    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  6    80 
  6    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  6    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  6    83 
  6    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  6    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  6    86 
  6    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  6    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  6    89 
  6    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  6    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  6    92 
  6    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  6    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  6    95 
  6    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  6    97      ("abc");
  6    98 
  6    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  6   100      init ("a","b","c");
  6   101 
  6   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  6   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  6   104 
  6   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  6   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  6   107 
  6   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  6   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  6   110 
  6   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  6   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  6   113 
  6   114 
  6   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  6   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  6   117 
  6   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  6   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  6   120 
  6   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  6   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  6   123 
  6   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  6   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  6   126 
  6   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  6   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  6   129 
  6   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  6   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  6   132 
  6   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  6   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  6   135 
  6   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  6   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  6   138 
  6   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  6   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  6   141 
  7     1 /* Begin fs_dev_types_sector.incl.pl1 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  7     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  7     7*     Add the sector differance for devices that do 64 word IO and devices that
  7     8*     do 512 word IO.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  7    12*	 need all the data in fs_dev_types. This is also included in
  7    13*	 fs_dev_types.incl.pl1  */
  7    14 
  7    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  7    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  7    17 
  7    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  7    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  7    20 
  7    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  7    22  /* table of # of sectors per record on each device */
  7    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  7    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  7    25 
  7    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  7    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  7    28 	
  7    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  7    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  7    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  7    32 
  7    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  7    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  7    35 
  7    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  7    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  7    38 
  7    39 /* End fs_dev_types_sector.incl.pl1 */
  7    40 
  6   142 
  6   143 
  6   144 /* End of include file ...... fs_dev_types.incl.pl1 */
     2544 
     2545 
  8     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  8     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  8     3 /*	version number changed to 4, 08/10/78 WOS */
  8     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  8     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  8     6 
  8     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  8     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  8     9     2 switches aligned,                                     /* various bit switch values */
  8    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  8    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  8    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  8    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  8    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  8    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  8    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  8    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  8    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  8    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  8    20 
  8    21 /*  Limit of data defined for version 2 */
  8    22 
  8    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  8    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  8    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  8    26 						/* minimum of 30 seconds required for repeat */
  8    27 						/* otherwise, no repeat will occur */
  8    28 /* Limit of data defined for version 4 */
  8    29 
  8    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  8    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  8    32 
  8    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  8    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  8    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  8    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  8    37 
  8    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     2546 
     2547 
     2548 
     2549      end exercise_disk;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/86  1023.5  exercise_disk.pl1                 >special_ldd>install>MR12.0-1200>exercise_disk.pl1
2534         1    06/03/83  1008.5  iocbx.incl.pl1                    >ldd>include>iocbx.incl.pl1
2536         2    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
2538         3    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
2540         4    07/24/86  2051.8  rcp_disk_info.incl.pl1            >ldd>include>rcp_disk_info.incl.pl1
2542         5    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
2544         6    10/28/86  0943.0  fs_dev_types.incl.pl1             >special_ldd>install>MR12.0-1200>fs_dev_types.incl.pl1
6-142        7    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
2546         8    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTENTION                              constant        bit(4)                   initial unaligned dcl 1284 ref 1988 2029
ATTN                                   constant        bit(4)                   initial unaligned dcl 840 ref 906
CA                              000141 automatic       varying char(10)         dcl 1015 set ref 1063* 1067* 1077*
COMPLETE                               constant        fixed bin(17,0)          initial dcl 1295 ref 2466 2473
DATA_ALRT_CMPRR                        constant        bit(10)                  initial unaligned dcl 838 ref 865
DEFAULT                                constant        bit(1)                   initial unaligned dcl 1296 ref 2362
DEVICE_GROUP                    000016 constant        fixed bin(17,0)          initial array dcl 1279 ref 1533
DISK_INFO_VERSION_1                    constant        fixed bin(17,0)          initial dcl 4-29 ref 1512
Direct_input                           constant        fixed bin(17,0)          initial dcl 5-15 ref 1626 1683
Direct_update                          constant        fixed bin(17,0)          initial dcl 5-15 ref 1613 1683
END                             017275 constant        fixed bin(17,0)          initial dcl 1405 ref 1717 1743 1744
EOF                                    constant        bit(4)                   initial unaligned dcl 1285 ref 1992
EXEC                                   constant        bit(5)                   initial unaligned dcl 1288 ref 1488
FALSE                                  constant        bit(1)                   initial unaligned dcl 195 ref 226 288 300 308 351
                                                                                  357 744 844
INHIB_AUTO_RETRY                       constant        bit(6)                   initial unaligned dcl 1290 ref 1950
LAST_BLOCK                             constant        bit(6)                   initial unaligned dcl 1286 ref 1992
LAST_BLOCK_MASK                        constant        bit(6)                   initial unaligned dcl 1287 ref 1992
LONG_WAIT                              constant        fixed bin(17,0)          initial dcl 1294 ref 2473
MODELN                          000162 constant        fixed bin(17,0)          initial array dcl 6-63 ref 259 260 427 1515 1527
                                                                                  1528
MSU04XX                                constant        fixed bin(17,0)          initial dcl 1281 ref 1541 2214 2232
NOT_SET                         017274 constant        fixed bin(6,0)           initial dcl 1297 ref 1441 2479
NULL                            017274 constant        fixed bin(17,0)          initial dcl 1406 ref 1562 1715 1718 1719 1741 1777
                                                                                  1814 1822 2333
PC                              001027 automatic       fixed bin(24,0)          dcl 158 set ref 888* 975* 977* 1077*
PH                              001030 automatic       fixed bin(24,0)          dcl 158 set ref 888* 967* 973* 1077*
PORT                            000145 automatic       varying char(10)         dcl 1015 set ref 1064* 1068* 1071 1071* 1071 1073
                                                                                  1073* 1073 1077*
SEEK_512                               constant        bit(6)                   initial unaligned dcl 1292 ref 1923
SPECIAL_SEEK                           constant        bit(6)                   initial unaligned dcl 1291 ref 1897
SPECIAL_SEEK_512                       constant        bit(6)                   initial unaligned dcl 1293 ref 1929
STANDBY                                constant        bit(6)                   initial unaligned dcl 1289 ref 1988
TRUE                                   constant        bit(1)                   initial unaligned dcl 194 ref 223 287 301 307 316
                                                                                  317 339 342 346 352 356 376 381 400 865 877 913
a                               000133 automatic       fixed bin(17,0)          dcl 117 set ref 246* 247* 276* 277* 291* 295* 323*
                                                                                  323 324* 330* 330 358* 358 359* 382* 382 383*
a_code                                 parameter       fixed bin(35,0)          dcl 1377 set ref 1414 1565* 1587 1659* 1666 1696*
                                                                                  1704 1729 1829* 2102 2131* 2160* 2169 2252* 2304
                                                                                  2335* 2342 2385*
a_err_sw                               parameter       bit(1)                   dcl 1423 ref 1414 1432
a_info_ptr                             parameter       pointer                  dcl 2111 ref 2102 2119
a_iocb_ptr                             parameter       pointer                  dcl 1376 ref 1414 1433 1587 1666 1704 1729 2102 2169
                                                                                  2304 2342 2407
a_key                                  parameter       varying char(256)        dcl 1680 ref 1666 1686 1686 1687
a_mode                                 parameter       fixed bin(17,0)          dcl 1600 ref 1587 1605
a_new_modes                            parameter       char                     unaligned dcl 2178 ref 2169 2183 2186
a_rec_len                              parameter       fixed bin(21,0)          dcl 1378 set ref 1666 1695* 1704 1725* 1729 1751
                                                                                  1813* 1997*
a_ubuf_len                             parameter       fixed bin(21,0)          dcl 1380 ref 1704 1724
a_ubuf_ptr                             parameter       pointer                  dcl 1379 ref 1704 1729 1786
acode                                  parameter       fixed bin(35,0)          dcl 930 set ref 924 933* 936* 940*
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-9 ref 2408
addr                                                   builtin function         dcl 207 ref 218 222 475 533 694 715 748 846 897 1511
                                                                                  1551 1653 1870 1936 1940 1942 1953 1955 1958 1973
                                                                                  1973 1973 1973 1988 1988 1992 1992 1995 2011 2029
                                                                                  2032 2035 2080 2128 2138 2154 2354 2357 2457 2468
                                                                                  2468 2468 2468 2482 2490 2490 2519 2522 2522
addrel                                                 builtin function         dcl 207 ref 2075 2077 2079
address                                based           bit(18)                  level 2 packed unaligned dcl 3-7 set ref 1940* 1955*
again                           000154 automatic       bit(1)                   unaligned dcl 1251 set ref 1960* 1963 1978* 2036*
alt_sw                          000751 automatic       bit(1)                   initial unaligned dcl 150 in procedure
                                                                                  "exercise_disk" set ref 150* 288* 342* 427* 493
                                                                                  993 1000
alt_sw                   55(04)        based           bit(1)                   level 3 in structure "disk_data" packed unaligned
                                                                                  dcl 1131 in procedure "exdim_" set ref 1521* 2210*
                                                                                  2217* 2232
analyze_detail_stat_$rsnnl      000032 constant        entry                    external dcl 71 ref 897
analyze_device_stat_$rsnnl      000030 constant        entry                    external dcl 69 ref 882
answer                          000771 automatic       varying char(32)         dcl 155 set ref 437* 438 642* 643 907* 913
answer_iocbp              6     001162 automatic       pointer                  initial level 2 dcl 8-7 set ref 8-7*
arg                                    based           char                     unaligned dcl 105 set ref 254 284 299 299 306 306
                                                                                  315 315 321 321 329 334 339 339 342 342 346 350
                                                                                  350 355 355 364 367* 379 388 391* 403 403 406 406
                                                                                  415*
arg1                            000116 automatic       varying char(8)          dcl 111 set ref 254* 434* 445
arg_sw                          000114 automatic       bit(1)                   initial unaligned dcl 105 set ref 105* 241* 250*
                                                                                  280* 294* 411
argcnt                          000112 automatic       fixed bin(17,0)          dcl 105 set ref 238* 240 291 291
arglen                          000113 automatic       fixed bin(17,0)          dcl 105 set ref 247* 254 277* 284 295* 299 299 306
                                                                                  306 315 315 321 321 324* 329 329 334 339 339 342
                                                                                  342 346 350 350 355 355 359* 364 367 367 379 383*
                                                                                  388 391 391 403 403 406 406 415 415
argptr                          000110 automatic       pointer                  dcl 105 set ref 247* 254 277* 284 295* 299 299 306
                                                                                  306 315 315 321 321 324* 329 334 339 339 342 342
                                                                                  346 350 350 355 355 359* 364 367 379 383* 388 391
                                                                                  403 403 406 406 415
attach_data              54            based           structure                level 2 dcl 1131
attach_data_ptr          16            based           pointer                  level 2 dcl 1-9 set ref 1552* 2373* 2409
attach_descrip                         based           structure                level 2 dcl 1131 set ref 1551
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-9 set ref 1435 1551* 2374* 2411
b_code                                 parameter       fixed bin(35,0)          dcl 1572 ref 1570 1574 1577
based_rsr_data                         based           bit(8)                   array unaligned dcl 1382 ref 2154
bin                                                    builtin function         dcl 207 ref 537 780
bit                                                    builtin function         dcl 207 ref 814 814 1488 1872 1951 1956 2034 2356
block                                  based           char                     unaligned dcl 1253 set ref 1866 1996* 1998* 2016*
block_count_limit               000100 automatic       fixed bin(12,0)          level 2 packed unsigned unaligned dcl 1190 set ref
                                                                                  1890*
block_len                       000145 automatic       fixed bin(12,0)          dcl 1248 set ref 1801* 1857 1866 1867 1867 1873 1956
                                                                                  1995 1996 1998 2016
block_ptr                       000124 automatic       pointer                  initial dcl 1243 set ref 1243* 1800* 1866 1996 1998
                                                                                  2016
bounds                  133            based           structure                level 3 dcl 1131
buf_len                 123            based           fixed bin(19,0)          level 3 dcl 1131 set ref 1842* 2485* 2486* 2488
buf_ptr                 120            based           pointer                  level 3 dcl 1131 set ref 1841* 1866 1867 1870 1893
                                                                                  1919 1936 1940 1942 1953 1955 1958 1965 1966 1971
                                                                                  1971 1980 1980 1980 1980 1980 1984 1986 1988 1988
                                                                                  1992 1992 1995 1996 2011 2016 2029 2032 2035 2075
                                                                                  2075 2081 2084 2085 2085 2085 2085 2153 2154 2354
                                                                                  2357 2486* 2490 2490
buffer                                 based           structure                level 1 unaligned dcl 1207
c_code                          000246 automatic       fixed bin(35,0)          dcl 1572 set ref 1574* 1576*
cd                                     parameter       fixed bin(35,0)          dcl 2440 ref 2438 2443
ceil                                                   builtin function         dcl 207 ref 1773 1801 1801 1873
chan_cmd                  0(24)        based           bit(6)                   level 2 packed unaligned dcl 2-21 set ref 1950*
char                                                   builtin function         dcl 207 ref 1063 1064
cleanup                         000164 stack reference condition                dcl 137 ref 233 2467 2469
clear_space                            parameter       bit(1)                   unaligned dcl 1838 ref 1836 1840
clock                                                  builtin function         dcl 207 ref 557
clock_                          000036 constant        entry                    external dcl 75 ref 544 544 883 883
close                    36            based           entry variable           level 2 dcl 1-9 set ref 1648* 2322*
cmd_tbl                         000311 constant        char(1)                  initial array unaligned dcl 192 set ref 1077*
cn1                             001022 automatic       fixed bin(24,0)          dcl 157 set ref 548* 549*
code                      1     000112 automatic       fixed bin(35,0)          level 2 in structure "tp_info" dcl 1239 in procedure
                                                                                  "exdim_" set ref 2521*
code                      0(18)        based           bit(3)                   level 2 in structure "idcw" packed unaligned
                                                                                  dcl 2-21 in procedure "exercise_disk" set ref 2076
code                            000135 automatic       fixed bin(35,0)          dcl 1245 in procedure "exdim_" set ref 1426* 1429*
                                                                                  1430* 1485* 1487* 1488 1507* 1508 1508* 1524 1524*
                                                                                  1565 1577* 1686* 1687 1778* 1845* 1968* 1969 1973*
                                                                                  1974 2003* 2081* 2093* 2239* 2251 2251* 2358*
                                                                                  2362* 2364* 2366* 2383 2383* 2404* 2443* 2460*
                                                                                  2461 2463* 2464 2468* 2470 2471* 2472 2474* 2486*
                                                                                  2487 2490* 2491 2493* 2494
code                            000106 automatic       fixed bin(35,0)          dcl 104 in procedure "exercise_disk" set ref 242*
                                                                                  247* 248 269* 270 277* 278 295* 296 324* 326 359*
                                                                                  361 367* 369 372* 373 383* 385 391* 393 396* 397
                                                                                  414* 415* 418* 419* 467* 468 469* 476* 478 479*
                                                                                  485* 486 487* 494* 495 496* 506* 507 508* 534*
                                                                                  694* 696 697* 702* 704 705 706* 715* 717 718* 723*
                                                                                  725 726 727* 748* 750 751* 756* 758 759 760* 847*
                                                                                  897* 1023* 1028* 1029 1029* 1038*
com_err_                        000050 constant        entry                    external dcl 86 ref 211 212 415 419 469 479 487 496
                                                                                  508 697 706 718 727 751 760 1029 2085
command                                based           bit(6)                   level 2 packed unaligned dcl 2-21 set ref 1897*
                                                                                  1923* 1929* 2082
command_query_                  000040 constant        entry                    external dcl 77 ref 437 642 907
compare_err                     000156 automatic       bit(1)                   initial unaligned dcl 134 set ref 134* 654 657 660
                                                                                  663 666 669 844* 865*
compare_sw               55(02)        based           bit(1)                   level 3 packed unaligned dcl 1131 set ref 1438* 1945
                                                                                  2220* 2221*
completion               16            based           structure                level 4 dcl 1207
cond_name                              parameter       char                     unaligned dcl 2516 ref 2507 2525
constant_                       000157 automatic       bit(36)                  initial unaligned dcl 135 set ref 135* 227* 816
cont_sw                                parameter       bit(1)                   dcl 2517 set ref 2507 2525*
control                  66            based           entry variable           level 2 dcl 1-9 set ref 1555* 2376*
control_info                           based           structure                level 2 unaligned dcl 1207
count_                          000140 automatic       fixed bin(17,0)          dcl 1014 set ref 1095* 1099* 1099 1102* 1104*
count_limit_fixed               000144 automatic       fixed bin(12,0)          dcl 1248 set ref 1873* 1890
cp_escape_control         1(02) 001162 automatic       bit(2)                   initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  225* 8-7*
cu_$arg_count                   000054 constant        entry                    external dcl 90 ref 238
cu_$arg_ptr                     000052 constant        entry                    external dcl 88 ref 247 277 295 324 359 383
current_key             131            based           fixed bin(35,0)          level 3 dcl 1131 set ref 1562* 1692* 1719* 1741 1743
                                                                                  1752 1812* 2333*
current_mode_name               000205 automatic       char(24)                 unaligned dcl 1403 set ref 1637* 1638*
cv_dec_check_                   000062 constant        entry                    external dcl 96 in procedure "exercise_disk" ref 367
                                                                                  391
cv_dec_check_                   000156 constant        entry                    external dcl 1360 in procedure "exdim_" ref 1686
cyl                             000102 automatic       fixed bin(24,0)          dcl 1011 in procedure "EXIT" set ref 1076* 1077*
cyl                             000152 automatic       fixed bin(16,0)          dcl 1250 in procedure "exdim_" set ref 1910* 1912
                                                                                  1913 1913 1913* 1913 1915* 1915 1916 1917
cyl_                                   parameter       fixed bin(24,0)          dcl 955 set ref 947 960* 964 965 966 971 972
cyl_lower                 0(20) 000101 automatic       fixed bin(8,0)           level 2 packed unsigned unaligned dcl 1196 set ref
                                                                                  1916*
cyl_no                          001240 automatic       fixed bin(24,0)          dcl 832 set ref 880* 888*
cyl_per_dev                     000137 constant        fixed bin(17,0)          initial array dcl 6-102 ref 1535 2142
cyl_upper                 0(28) 000101 automatic       fixed bin(2,0)           level 2 packed unsigned unaligned dcl 1196 set ref
                                                                                  1917*
cylno                           001214 automatic       fixed bin(24,0)          dcl 685 set ref 778* 782* 785* 786* 793*
d500_sw                         001151 automatic       bit(1)                   initial unaligned dcl 197 set ref 197* 260* 888*
                                                                                  888* 1058* 1059* 1077*
data                                   based           bit(36)                  array dcl 202 in procedure "exercise_disk" set ref
                                                                                  515 520 776 799* 799* 799* 799* 814* 816* 1033
data                     26            based           char                     level 2 in structure "buffer" packed unaligned
                                                                                  dcl 1207 in procedure "exdim_" set ref 1866* 1867*
                                                                                  1955 1996 2016
data_bufp                       001002 automatic       pointer                  dcl 156 set ref 228* 515* 520* 702* 723* 772 776 799
                                                                                  799 799 799 814 816 1033 1033
data_init_sw                    000155 automatic       bit(1)                   initial unaligned dcl 134 set ref 134*
data_left                       000137 automatic       fixed bin(35,0)          dcl 1245 set ref 1802* 1857 1997 1998
data_len                124            based           fixed bin(19,0)          level 3 dcl 1131 set ref 1795 1842* 1866 1867 1955
                                                                                  1996 2016 2488*
data_read                       000265 automatic       fixed bin(35,0)          dcl 1855 set ref 1995* 1996 1996 1997 1998
data_sb                                based           bit                      unaligned dcl 684 ref 772
data_was                               based           bit                      unaligned dcl 684 set ref 744* 772
date_time_                      000056 constant        entry                    external dcl 92 ref 544 883
dcw                                    based           structure                level 1 dcl 3-7 set ref 1939* 1954* 2085*
dcw_offset                      000134 automatic       fixed bin(18,0)          dcl 1244 set ref 1958* 1968* 2035* 2357* 2358*
dcwp                            001154 automatic       pointer                  dcl 3-4 set ref 1936* 1939 1940 1953* 1954 1955 1956
                                                                                  2079* 2085
default_handler_$set            000202 constant        entry                    external dcl 1370 ref 1548 1643 2314 2370
descrip                   1            based           char(168)                level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1497* 1499* 1500
                                                                                  1502* 1502 1504 2415 2415
descrip                 105            based           char(32)                 level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1617* 1628*
desired_switch_state            000332 automatic       varying char(12)         dcl 2395 set ref 2406* 2422 2426 2430
det_status                2     000211 automatic       bit(8)                   array level 2 packed unaligned dcl 144 set ref 1062
                                                                                  1063 1064
detach_iocb              26            based           entry variable           level 2 dcl 1-9 set ref 1553* 1649* 2320*
detail_status             2     001045 automatic       bit(8)                   array level 2 packed unaligned dcl 171 set ref 895
                                                                                  897
detailed_status                        based           bit(88)                  unaligned dcl 835 set ref 897*
dev_attached                    000760 automatic       bit(1)                   initial unaligned dcl 152 set ref 152* 483* 1027
                                                                                  1031*
dev_cmd                   5     001045 automatic       fixed bin(17,0)          level 2 dcl 171 set ref 849 854 857* 857 860
dev_cmd_                  5     000211 automatic       fixed bin(17,0)          array level 2 dcl 144 set ref 1077
dev_evn                         000757 automatic       bit(1)                   initial unaligned dcl 152 set ref 152* 537* 540* 975
dev_id                          000157 automatic       char(4)                  unaligned dcl 1254 set ref 1448* 1453 1453* 1455
                                                                                  1455* 1460
dev_idx                         000131 automatic       fixed bin(17,0)          dcl 115 set ref 262* 427 500 512 958 959 960 961 993
                                                                                  993 1000 1000 1005
dev_infop                       001012 automatic       pointer                  dcl 156 set ref 533* 534*
dev_name                  1     001033 automatic       char(8)                  level 2 dcl 160 set ref 535 545*
dev_open                        000761 automatic       bit(1)                   initial unaligned dcl 152 set ref 152* 491* 1022
                                                                                  1024*
dev_statp                       001014 automatic       pointer                  dcl 156 set ref 846* 847*
dev_sw                          000126 automatic       bit(1)                   initial unaligned dcl 113 set ref 113* 335* 448 463*
dev_type                 74            based           fixed bin(17,0)          level 3 dcl 1131 set ref 1458* 1459 1460* 1497 1499
                                                                                  1515 1515 1526* 1527 1528* 1533 1535 1535 1536
                                                                                  1537 1537 1541 1543 1875 1877 1906 1910 1911 1912
                                                                                  2085 2139 2142 2143 2144 2209 2214 2216 2225 2232
                                                                                  2235 2352
dev_type_                       001033 automatic       char(4)                  level 2 dcl 160 set ref 545*
device                    0(06)        based           bit(6)                   level 2 packed unaligned dcl 2-21 set ref 1872*
                                                                                  1951* 2034* 2356*
device_group            103            based           fixed bin(17,0)          level 3 dcl 1131 set ref 1533* 1541 1875 1877 2214
                                                                                  2232
device_info                     001033 automatic       structure                level 1 dcl 160 set ref 533
device_name               4            based           char(8)                  level 2 in structure "disk_info" dcl 4-19
                                                                                  in procedure "exercise_disk" set ref 1518* 2085*
                                                                                  2140 2481
device_name                     001054 automatic       char(8)                  unaligned dcl 177 in procedure "exercise_disk" set
                                                                                  ref 219* 334* 451 463* 535* 537 876* 885* 897*
                                                                                  907* 1045*
device_names                    000151 constant        char(4)                  initial array dcl 6-66 set ref 258 935 1460 1499
                                                                                  2085* 2139
device_status_info              001045 automatic       structure                level 1 dcl 171 set ref 846 872
device_type                     000145 automatic       char(4)                  unaligned dcl 121 set ref 254* 258 935 1045*
devx                     75            based           fixed bin(17,0)          level 3 dcl 1131 set ref 1968* 2081* 2358* 2463*
                                                                                  2471* 2486* 2490* 2493*
disk_data                              based           structure                level 1 unaligned dcl 1131
disk_info                              based           structure                level 1 dcl 4-19 set ref 2134* 2134
disk_info_ptr                   001156 automatic       pointer                  dcl 4-17 set ref 1511* 1512 1513 1513 1514 1515 1517
                                                                                  1518 1519 1528 2080* 2085 2128* 2129 2134 2138*
                                                                                  2140 2457* 2458 2460* 2463* 2471* 2481
disk_ptr                        000114 automatic       pointer                  initial dcl 1243 set ref 1243* 1429* 1430 1432 1438
                                                                                  1438 1438 1439 1440 1441 1449 1458 1459 1460 1467
                                                                                  1488 1490 1497 1497 1497 1499 1499 1499 1500 1500
                                                                                  1502 1502 1502 1504 1504 1507 1509 1511 1514 1515
                                                                                  1515 1519 1520 1521 1522 1526 1527 1528 1533 1533
                                                                                  1535 1535 1535 1536 1536 1537 1537 1537 1539 1539
                                                                                  1540 1541 1541 1541 1543 1543 1545 1551 1552 1562
                                                                                  1562 1562 1576* 1605 1613 1614 1616 1617 1622 1626
                                                                                  1627 1628 1632 1637 1653 1683 1683 1690 1690 1692
                                                                                  1692 1695 1715 1717 1718 1719 1726 1741 1743 1744
                                                                                  1752 1773 1782 1795 1795 1795 1795 1795 1795 1801
                                                                                  1801 1812 1812 1814 1822 1841 1842 1842 1866 1866
                                                                                  1867 1867 1867 1870 1872 1873 1875 1875 1877 1877
                                                                                  1893 1906 1910 1911 1912 1913 1919 1936 1940 1942
                                                                                  1945 1951 1953 1955 1955 1958 1965 1966 1968 1971
                                                                                  1971 1973 1973 1980 1980 1980 1980 1980 1984 1986
                                                                                  1988 1988 1992 1992 1995 1996 1996 1998 2011 2016
                                                                                  2016 2029 2032 2034 2035 2075 2075 2080 2081 2081
                                                                                  2084 2085 2085 2085 2085 2085 2091 2091 2122 2123
                                                                                  2128 2138 2139 2141 2142 2143 2144 2146 2147 2153
                                                                                  2154 2198 2199 2203 2204 2209 2209 2210 2214 2214
                                                                                  2214 2216 2216 2217 2220 2221 2224 2225 2225 2226
                                                                                  2229 2229 2231 2232 2232 2232 2232 2235 2235 2236
                                                                                  2286 2288 2288 2290 2290 2290 2293 2293 2293 2333
                                                                                  2333 2333 2352 2354 2356 2357 2358 2362 2362 2364
                                                                                  2366* 2367* 2409* 2415 2415 2455 2457 2458 2460
                                                                                  2460 2463 2463 2463 2463 2468 2468 2471 2471 2471
                                                                                  2471 2479 2482 2485 2485 2485 2486 2486 2486 2488
                                                                                  2488 2490 2490 2490 2493 2493 2497
disk_status_table_$disk_status_table_
                                000034 external static fixed bin(17,0)          dcl 73 set ref 218
divide                                                 builtin function         dcl 207 ref 958 960 1910 1912 1917 2485
doing                           000160 automatic       varying char(5)          initial dcl 136 set ref 136* 850* 855* 861* 885*
drive                    76            based           fixed bin(6,0)           level 3 dcl 1131 set ref 1441* 1872 1913 1951 2034
                                                                                  2356 2479 2482*
drive_dec                              based           fixed dec(2,0)           dcl 1271 ref 2482
drive_name                      000176 automatic       char(8)                  unaligned dcl 1272 set ref 1442* 1476* 1477 1518
drive_number                    000174 automatic       structure                level 1 packed unaligned dcl 1268 set ref 2482
dt                              000100 automatic       char(24)                 unaligned dcl 103 set ref 544* 545 545 883* 885 885
dvt                             001710 automatic       fixed bin(17,0)          dcl 931 set ref 934* 935 937*
ecode                                  parameter       fixed bin(35,0)          dcl 954 set ref 985 992* 996*
epc                             001031 automatic       fixed bin(24,0)          dcl 158 set ref 965* 971* 975
er                       16(01)        based           bit(1)                   level 5 packed unaligned dcl 1207 set ref 1980
err_cnt                         000201 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 868 869* 869 872 1012
                                                                                  1012 1043 1050 1055 1061 1085 1086 1097 1098
err_ct                          000150 automatic       fixed bin(17,0)          dcl 1249 set ref 1961* 2029* 2029 2031 2052* 2052
                                                                                  2054 2055*
err_msg                                parameter       char                     unaligned dcl 2441 ref 2438
err_retry                       000010 internal static fixed bin(17,0)          initial dcl 191 set ref 559* 580* 600* 615* 632* 632
                                                                                  640 641*
err_sw                   55            based           bit(1)                   level 3 packed unaligned dcl 1131 set ref 1432*
error_table_$action_not_performed
                                000070 external static fixed bin(35,0)          dcl 1323 ref 2474
error_table_$bad_arg            000072 external static fixed bin(35,0)          dcl 1323 set ref 1477*
error_table_$bad_mode           000074 external static fixed bin(35,0)          dcl 1323 ref 2239
error_table_$badopt             000042 external static fixed bin(35,0)          dcl 79 ref 414
error_table_$device_end         000076 external static fixed bin(35,0)          dcl 1323 set ref 1720* 1745* 2003
error_table_$device_parity      000100 external static fixed bin(35,0)          dcl 1323 in procedure "exdim_" ref 2093
error_table_$device_parity      000046 external static fixed bin(35,0)          dcl 84 in procedure "exercise_disk" ref 705 726 759
error_table_$incompatible_attach
                                000102 external static fixed bin(35,0)          dcl 1323 set ref 1614*
error_table_$no_operation       000104 external static fixed bin(35,0)          dcl 1323 set ref 1782* 1795* 2158*
error_table_$no_record          000106 external static fixed bin(35,0)          dcl 1323 set ref 1684* 1687* 1690* 1715* 1741* 1778
                                                                                  1880*
error_table_$noarg              000044 external static fixed bin(35,0)          dcl 81 in procedure "exercise_disk" ref 418
error_table_$noarg              000110 external static fixed bin(35,0)          dcl 1323 in procedure "exdim_" set ref 1451* 1473*
error_table_$not_attached       000112 external static fixed bin(35,0)          dcl 1323 set ref 2411* 2418*
error_table_$not_closed         000114 external static fixed bin(35,0)          dcl 1323 set ref 2426*
error_table_$not_detached       000116 external static fixed bin(35,0)          dcl 1323 set ref 1435*
error_table_$not_open           000120 external static fixed bin(35,0)          dcl 1323 set ref 2115* 2422*
error_table_$request_not_recognized
                                000122 external static fixed bin(35,0)          dcl 1323 set ref 1493* 1638*
error_table_$termination_requested
                                000124 external static fixed bin(35,0)          dcl 1323 ref 2521
error_table_$unimplemented_version
                                000130 external static fixed bin(35,0)          dcl 1323 ref 2131
error_table_$user_not_found     000126 external static fixed bin(35,0)          dcl 1323 set ref 1490*
error_table_$wrong_no_of_args   000064 external static fixed bin(35,0)          dcl 98 ref 242
errors                          000211 automatic       structure                array level 1 dcl 144 in procedure "exercise_disk"
                                                                                  set ref 872*
errors                   77            based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 2091* 2091 2362*
                                                                                  2455*
ev_chan                  72            based           fixed bin(71,0)          level 4 dcl 1131 set ref 1507* 2364* 2460*
event_info                      000102 automatic       structure                level 1 dcl 1226 set ref 1973 1973 2468 2468
explanation_len          14     001162 automatic       fixed bin(21,0)          initial level 2 dcl 8-7 set ref 8-7*
explanation_ptr          12     001162 automatic       pointer                  initial level 2 dcl 8-7 set ref 8-7*
f91                       1     000147 automatic       picture(8)               level 2 packed unaligned dcl 124 set ref 690* 697*
                                                                                  739* 751*
f92                       1     000152 automatic       picture(8)               level 2 packed unaligned dcl 128 set ref 691* 718*
fill                    122            based           bit(9)                   level 3 dcl 1131 set ref 1622* 1632* 1867 1998
first_alt_sect_num              000104 constant        fixed bin(24,0)          initial array dcl 6-130 ref 1537
fixed                                                  builtin function         dcl 207 ref 1063 1064 1958 1995 2035 2076 2082 2286
                                                                                  2357 2490 2490
flag                      0(15) 000101 automatic       bit(1)                   level 2 packed unaligned dcl 1196 set ref 1909*
floor                                                  builtin function         dcl 207 ref 1795 1795
fmdp                            000132 automatic       pointer                  initial dcl 1243 set ref 1243*
found                           000201 automatic       bit(1)                   dcl 1383 set ref 2081*
from                            000127 automatic       fixed bin(24,0)          dcl 114 set ref 230* 289* 367* 372*
from_sw                         000124 automatic       bit(1)                   initial unaligned dcl 113 set ref 113* 376*
hbound                                                 builtin function         dcl 207 ref 1527
hcs_$delentry_seg               000150 constant        entry                    external dcl 1357 ref 1576 2366
hcs_$fs_get_mode                000174 constant        entry                    external dcl 1367 ref 1487
hcs_$initiate                   000172 constant        entry                    external dcl 1366 ref 1485
hcs_$make_seg                   000146 constant        entry                    external dcl 1356 ref 1429
hcs_$reset_ips_mask             000200 constant        entry                    external dcl 1369 ref 1560 1657 2331 2381
hcs_$set_ips_mask               000176 constant        entry                    external dcl 1368 ref 1549 1644 2315 2371
hd                              000103 automatic       fixed bin(24,0)          dcl 1011 set ref 1076* 1077*
hd_                                    parameter       fixed bin(24,0)          dcl 955 set ref 947 961* 967 973
hd_no                           001241 automatic       fixed bin(24,0)          dcl 832 set ref 880* 888*
hdno                            001215 automatic       fixed bin(24,0)          dcl 685 set ref 778* 782* 785* 786* 793*
head                            000153 automatic       fixed bin(16,0)          dcl 1250 in procedure "exdim_" set ref 1911* 1912*
                                                                                  1912 1918
head                      0(30) 000101 automatic       fixed bin(6,0)           level 2 in structure "super_seek" packed unsigned
                                                                                  unaligned dcl 1196 in procedure "exdim_" set ref
                                                                                  1918*
high                      1            based           fixed bin(35,0)          level 2 in structure "user_bounds" dcl 1257
                                                                                  in procedure "exdim_" set ref 2123*
high                    134            based           fixed bin(35,0)          level 4 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1541* 1543* 1690
                                                                                  1782 2123 2209* 2214* 2216* 2225* 2232* 2235*
highest_sector                  000141 automatic       fixed bin(24,0)          dcl 118 set ref 269* 500* 557 558 577
hn1                             001023 automatic       fixed bin(24,0)          dcl 157 set ref 548* 549*
i                               000136 automatic       fixed bin(17,0)          dcl 1014 in procedure "EXIT" set ref 1085* 1086 1087
                                                                                  1088 1089* 1097* 1098 1099 1102*
i                               001226 automatic       fixed bin(17,0)          dcl 812 in procedure "build_sb" set ref 815* 816*
i                               000146 automatic       fixed bin(17,0)          dcl 1249 in procedure "exdim_" set ref 1459* 1460
                                                                                  1460* 1465* 1467 1470 1470 1473 1475* 1475 1476
                                                                                  1477 1482 1482* 1501* 1502* 1527* 1528 1528* 2264*
                                                                                  2265 2266* 2267 2267* 2270 2271 2272 2286* 2288
                                                                                  2290 2290 2290 2293 2293 2293
i                               000115 automatic       fixed bin(17,0)          dcl 110 in procedure "exercise_disk" set ref 257*
                                                                                  258 259 260 262*
idcw                                   based           structure                level 1 dcl 2-21 set ref 1871* 1944* 1945* 1947*
                                                                                  2033* 2085* 2355*
idcwp                           001152 automatic       pointer                  dcl 2-19 set ref 1870* 1871 1872 1897 1923 1929
                                                                                  1942* 1944 1945 1947 1950 1951 2032* 2033 2034
                                                                                  2075* 2076 2076 2077* 2077 2079 2082 2085 2354*
                                                                                  2355 2356
ii                              000200 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 1061* 1062 1063 1064
                                                                                  1076 1077 1077*
index                                                  builtin function         dcl 207 ref 364 388 2264 2266 2286 2415
info_ptr                        000130 automatic       pointer                  initial dcl 1243 in procedure "exdim_" set ref 1243*
                                                                                  2119* 2122 2123 2129 2134 2139 2140 2141 2142 2143
                                                                                  2144 2145 2146 2147 2153 2154 2155
info_ptr                               parameter       pointer                  dcl 2515 in procedure "cond_hdlr" ref 2507
io_command                      000202 automatic       varying char(8)          dcl 1402 set ref 1722* 1748* 1782 1806 1822 1865
                                                                                  1944 1994 2015
ioa_                            000060 constant        entry                    external dcl 94 ref 421 434 436 463 545 549 550 777
                                                                                  781 782 786 793 796 797 799 876 885 888 892 899
                                                                                  1045 1046 1047 1048 1052 1053 1054 1058 1059 1102
                                                                                  1110 1114
ioa_$rsnnl                      000066 constant        entry                    external dcl 1016 ref 1077
iocb                                   based           structure                level 1 dcl 1-9
iocb_ptr                        000116 automatic       pointer                  initial dcl 1243 set ref 1243* 1433* 1435 1551 1552
                                                                                  1553 1554 1555 1556 1558* 1655* 2329* 2373 2374
                                                                                  2376 2376 2379* 2407* 2408
iocbp                           001010 automatic       pointer                  dcl 156 set ref 465* 467* 476* 485* 494* 506* 534*
                                                                                  694* 702* 715* 723* 748* 756* 847* 1023* 1028*
                                                                                  1038 1038*
ioi_$connect                    000160 constant        entry                    external dcl 1361 ref 1968 2358
ioi_$get_detailed_status        000166 constant        entry                    external dcl 1364 ref 2081
ioi_$set_status                 000164 constant        entry                    external dcl 1363 ref 2490
ioi_$timeout                    000142 constant        entry                    external dcl 1354 ref 2493
ioi_$workspace                  000144 constant        entry                    external dcl 1355 ref 2486
iom_stat                 22            based           bit(72)                  level 4 dcl 1207 set ref 1988 1988 1992 1992 1995
                                                                                  2011 2029 2085 2085 2085 2085 2153
iom_status                      001045 automatic       bit(72)                  level 2 dcl 171 set ref 865 882 892 892 892 892 897
                                                                                  897 906
iox_$destroy_iocb               000026 constant        entry                    external dcl 67 ref 1038
iox_$err_no_operation           000134 constant        entry                    external dcl 1351 ref 2376
iox_$err_not_closed             000136 constant        entry                    external dcl 1352 ref 1649
iox_$err_not_open               000140 constant        entry                    external dcl 1353 ref 2322
iox_$find_iocb                  000024 constant        entry                    external dcl 65 ref 467
iox_$propagate                  000152 constant        entry                    external dcl 1358 ref 1558 1655 2329 2379
iox_modes                       000173 constant        char(24)                 initial array dcl 5-6 ref 1637
ipc_$block                      000162 constant        entry                    external dcl 1362 ref 1973 2468
ipc_$create_ev_chn              000154 constant        entry                    external dcl 1359 ref 1507
ipc_$delete_ev_chn              000132 constant        entry                    external dcl 1350 ref 2364
is_interesting                  001677 automatic       bit(1)                   unaligned dcl 837 set ref 843* 897*
is_super_seek             0(14) 000101 automatic       bit(1)                   level 2 packed unaligned dcl 1196 set ref 1908*
istat                    16            based           structure                level 3 dcl 1207 set ref 2490 2490
j                               000137 automatic       fixed bin(17,0)          dcl 1014 set ref 1086* 1087 1089 1090* 1098* 1099
                                                                                  1103*
key                             000142 automatic       fixed bin(21,0)          dcl 1246 set ref 1726* 1752* 1775 1777 1875 1877
                                                                                  1892 1906 1910 1911 2085* 2085*
key1                                   based           varying char(256)        dcl 132 set ref 694* 748*
key1_len                        000147 automatic       fixed bin(17,0)          initial level 2 dcl 124 set ref 124*
key2                                   based           varying char(256)        dcl 133 set ref 715*
key2_len                        000152 automatic       fixed bin(17,0)          initial level 2 dcl 128 set ref 128*
key_for_insertion       132            based           fixed bin(35,0)          level 3 dcl 1131 set ref 1562* 2333*
label_sw                 55(05)        based           bit(1)                   level 3 packed unaligned dcl 1131 set ref 1522*
                                                                                  2199* 2204* 2229
last_alt_sect_num               000073 constant        fixed bin(24,0)          initial array dcl 6-133 ref 937 1000 1537 1541 1877
                                                                                  2214 2232
last_cmd_                       000022 internal static fixed bin(17,0)          dcl 1400 set ref 2082* 2155
last_physical_sect_num          000062 constant        fixed bin(24,0)          initial array dcl 6-136 ref 2225
last_sect_num                   000115 constant        fixed bin(24,0)          initial array dcl 6-127 ref 500 993 1543 1875 2209
                                                                                  2216 2235
length                                                 builtin function         dcl 1409 in procedure "exdim_" ref 1500 1504 2183
length                                 based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1500* 1502 1504*
length                  104            based           fixed bin(17,0)          level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1616* 1627*
length                                                 builtin function         dcl 207 in procedure "exercise_disk" ref 1071 1073
level                    17            based           fixed bin(3,0)           level 4 dcl 1207 set ref 1984 1986 2084
linelth                         000151 automatic       fixed bin(17,0)          dcl 1017 set ref 1077*
literal_sw                1(05) 001162 automatic       bit(1)                   initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  8-7*
loest_sector                    000142 automatic       fixed bin(24,0)          dcl 118 set ref 230* 372* 598
low                                    based           fixed bin(35,0)          level 2 in structure "user_bounds" dcl 1257
                                                                                  in procedure "exdim_" set ref 2122*
low                     133            based           fixed bin(35,0)          level 4 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1539* 1540* 1690
                                                                                  2122 2198* 2203* 2224* 2229* 2231*
ltrim                                                  builtin function         dcl 207 ref 1063 1064 1686 1686
maj                       0(02)        based           bit(4)                   level 2 packed unaligned dcl 1183 ref 1988 1992 2011
                                                                                  2029
mask                                   based           structure                level 1 packed unaligned dcl 1264
mask_str                        000172 automatic       bit(36)                  dcl 1263 set ref 1547* 1549* 1549* 1560* 1560* 1642*
                                                                                  1644* 1644* 1657* 1657* 2313* 2315* 2315* 2331*
                                                                                  2331* 2369* 2371* 2371* 2381* 2381* 2519
masked                    0(35)        based           bit(1)                   level 2 packed unaligned dcl 1264 ref 2519
max                                                    builtin function         dcl 207 ref 2485
max_buff_size            67            based           fixed bin(19,0)          level 3 dcl 1131 set ref 1795 2463* 2471* 2485
max_retries                            constant        fixed bin(17,0)          initial dcl 1283 ref 2031 2054
maxdevt                                constant        fixed bin(4,0)           initial dcl 6-43 ref 257 934 1459
mc_ptr                                 parameter       pointer                  dcl 2515 ref 2507
media_removable                 000150 constant        bit(1)                   initial array unaligned dcl 6-75 ref 2352
min                                                    builtin function         dcl 207 ref 1857 1995 2485
mod                                                    builtin function         dcl 207 ref 537 557 959 961 964 1906 1911 1912 1913
                                                                                  1913 1913 1916
mode                    116            based           fixed bin(17,0)          level 3 dcl 1131 set ref 1605* 1613 1626 1637 1683
                                                                                  1683
mode_err_sw                     000156 automatic       bit(1)                   unaligned dcl 1251 set ref 2194* 2240* 2243
mode_len                        000140 automatic       fixed bin(35,0)          dcl 1245 set ref 2183* 2184 2260 2262 2267 2270*
                                                                                  2270
mode_start                      000141 automatic       fixed bin(35,0)          dcl 1245 set ref 2187* 2262 2271*
mode_string             135            based           varying char(32)         level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1545* 2286 2288*
                                                                                  2288 2290 2290* 2290 2293 2293* 2293
mode_string                     000762 automatic       char(11)                 unaligned dcl 153 in procedure "exercise_disk" set
                                                                                  ref 525* 528* 531* 545*
model                     6            based           fixed bin(17,0)          level 2 dcl 4-19 set ref 1515* 1517* 1528
model_num                       000146 automatic       fixed bin(17,0)          dcl 122 set ref 259* 963
model_number                    000200 automatic       fixed bin(17,0)          dcl 1273 set ref 1443*
modes                    56            based           entry variable           level 2 dcl 1-9 set ref 1556* 2376*
msg                             001576 automatic       varying char(256)        initial dcl 836 set ref 836* 882* 892* 896* 897* 899
                                                                                  899*
my_analyses                     001242 automatic       varying char(40)         array dcl 833 set ref 845*
my_key1                         000147 automatic       structure                level 1 unaligned dcl 124 set ref 694 748
my_key2                         000152 automatic       structure                level 1 unaligned dcl 128 set ref 715
myname                          000312 constant        char(13)                 initial unaligned dcl 187 set ref 211* 212* 415*
                                                                                  419* 421* 434* 436* 437* 463* 469* 487* 496* 508*
                                                                                  545* 549* 550* 642* 697* 706* 718* 727* 751* 760*
                                                                                  777* 876* 885* 907* 1029* 1045* 1114*
nchan                    70            based           fixed bin(17,0)          level 4 dcl 1131 set ref 1509*
ndc_sw                          000750 automatic       bit(1)                   initial unaligned dcl 150 set ref 150* 288* 339* 520
                                                                                  740 768
new_modes                       000161 automatic       char(24)                 unaligned dcl 1261 set ref 2186* 2262* 2262 2264
                                                                                  2266 2272
next_key                130            based           fixed bin(35,0)          level 3 dcl 1131 set ref 1562* 1692* 1715 1717 1718*
                                                                                  1726 1744* 1812 1814* 1822* 2333*
next_mode                       000167 automatic       varying char(8)          initial dcl 1262 set ref 1262* 2189 2192 2196 2201
                                                                                  2207 2212 2220 2221 2223 2228 2249 2272* 2276*
                                                                                  2284 2286
not_sw                          000155 automatic       bit(1)                   unaligned dcl 1251 set ref 2284* 2286 2288 2290 2293
null                                                   builtin function         dcl 207 ref 228 229 465 8-7 8-7 8-7 1033 1035 1038
                                                                                  1243 1243 1243 1243 1243 1243 1243 1243 1430 1435
                                                                                  1486 1841 2115 2317 2367 2373 2374 2411 2422 2426
num_alt_sect            102            based           fixed bin(17,0)          level 3 dcl 1131 set ref 1537* 2146
num_label_sect                         constant        fixed bin(17,0)          initial dcl 1298 ref 1540 2145 2198 2229
num_opts                        001062 automatic       fixed bin(17,0)          level 2 in structure "options_" dcl 180 in procedure
                                                                                  "exercise_disk" set ref 441* 449* 449 450 451 454*
                                                                                  454 455 458* 458 459
num_opts                        000147 automatic       fixed bin(17,0)          dcl 1249 in procedure "exdim_" set ref 1445* 1447
                                                                                  1465 1473 1501
number                    0(09) 000174 automatic       char(2)                  level 2 packed unaligned dcl 1268 set ref 2481*
number_opts                            based           fixed bin(17,0)          level 2 dcl 1418 ref 1445
offset                   20            based           fixed bin(18,0)          level 4 dcl 1207 set ref 2075
opc                             001032 automatic       fixed bin(24,0)          dcl 158 set ref 966* 972* 977
open                     32            based           entry variable           level 2 dcl 1-9 set ref 1554* 1649* 2319*
open_data               116            based           structure                level 2 dcl 1131
open_descrip            104            based           structure                level 2 dcl 1131 set ref 1653
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-9 set ref 1653* 2115 2317* 2422 2426
open_mode                       001056 automatic       fixed bin(17,0)          initial dcl 178 set ref 178* 309* 485* 487*
options                   1     001062 automatic       varying char(32)         array level 2 in structure "options_" dcl 180
                                                                                  in procedure "exercise_disk" set ref 444* 445*
                                                                                  446* 450* 451* 455* 459*
options                   1            based           varying char(32)         array level 2 in structure "options_" dcl 1418
                                                                                  in procedure "exdim_" ref 1448 1449 1467 1470 1470
                                                                                  1476 1477 1482 1482 1502
options_                               based           structure                level 1 unaligned dcl 1418 in procedure "exdim_"
options_                        001062 automatic       structure                level 1 unaligned dcl 180 in procedure
                                                                                  "exercise_disk" set ref 475
options_ptr                     001060 automatic       pointer                  dcl 179 in procedure "exercise_disk" set ref 475*
                                                                                  476*
options_ptr                            parameter       pointer                  dcl 1417 in procedure "exdim_" ref 1414 1445 1448
                                                                                  1449 1467 1470 1470 1476 1477 1482 1482 1502
order                                  parameter       char                     unaligned dcl 2110 set ref 2102 2115 2121 2127 2137
                                                                                  2152 2158*
overhead                               constant        fixed bin(17,0)          initial dcl 1282 ref 1795 2488
pack_id                  56            based           char(32)                 level 3 in structure "disk_data" dcl 1131
                                                                                  in procedure "exdim_" set ref 1439* 1449* 1497
                                                                                  1499 2458
pack_id                         000121 automatic       char(12)                 unaligned dcl 112 in procedure "exercise_disk" set
                                                                                  ref 284* 434* 446 463*
padding                   1(07) 001162 automatic       bit(29)                  initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  8-7*
position                 62            based           entry variable           level 2 dcl 1-9 set ref 2322*
potential_next_sector           000222 automatic       fixed bin(21,0)          dcl 1770 set ref 1775* 1782
program_interrupt               000172 stack reference condition                dcl 137 ref 547
prompt_after_explanation
                          1(06) 001162 automatic       bit(1)                   initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  8-7*
querie                          001016 automatic       pointer                  dcl 156 set ref 222* 437* 642* 907*
query_code                3     001162 automatic       fixed bin(35,0)          initial level 2 dcl 8-7 set ref 8-7*
query_info                      001162 automatic       structure                level 1 dcl 8-7 set ref 222
question_iocbp            4     001162 automatic       pointer                  initial level 2 dcl 8-7 set ref 8-7*
quit_flag                       000747 automatic       bit(1)                   initial unaligned dcl 150 set ref 150* 637 877* 904
                                                                                  913*
random_sw                       000752 automatic       bit(1)                   unaligned dcl 151 set ref 287* 346* 351* 357* 525
                                                                                  553 648 654 657
range_sw                        000756 automatic       bit(1)                   initial unaligned dcl 152 set ref 152* 288* 356*
                                                                                  381* 666 669
raw_sw                   55(03)        based           bit(1)                   level 3 packed unaligned dcl 1131 set ref 1520*
                                                                                  2226* 2236*
rcp_$attach                     000206 constant        entry                    external dcl 1372 ref 2460
rcp_$check_attach               000210 constant        entry                    external dcl 1373 ref 2463 2471
rcp_$detach                     000212 constant        entry                    external dcl 1375 ref 2362 2497
rcp_data                146            based           fixed bin(35,0)          array level 3 dcl 1131 set ref 1511 2080 2128 2138
                                                                                  2457
rcp_dev_type                    000006 constant        char(32)                 initial unaligned dcl 1299 ref 2460
rcp_id                   66            based           bit(36)                  level 3 dcl 1131 set ref 2362* 2460* 2463* 2471*
                                                                                  2497*
rcp_state                       000151 automatic       fixed bin(17,0)          dcl 1249 set ref 2463* 2466 2471* 2473 2473
read_cmp_err                    000767 automatic       fixed bin(17,0)          dcl 154 set ref 221* 788* 788 800* 800 1043 1050
                                                                                  1054*
read_data                              based           bit(36)                  array unaligned dcl 203 set ref 519 776 780 797*
                                                                                  797* 797* 797* 1035
read_data_len                   000210 automatic       fixed bin(21,0)          dcl 141 set ref 542* 756*
read_errors                     000766 automatic       fixed bin(17,0)          dcl 154 set ref 221* 856* 856 1053*
read_idcw_string                000016 internal static bit(36)                  initial unaligned dcl 1309 ref 1944 1944 1944 1944
                                                                                  1944 1944 1944 1944 1944 1944 1944 1944 1944 1944
                                                                                  1944 1944
read_idcw_template                     defined         structure                level 1 packed unaligned dcl 1318 ref 1944
read_ptr                        001004 automatic       pointer                  dcl 156 set ref 229* 519* 744 756* 772 776 780 797
                                                                                  797 797 797 1035 1035
read_record              72            based           entry variable           level 2 dcl 1-9 set ref 1618* 1629* 2322*
read_sw                         000753 automatic       bit(1)                   unaligned dcl 151 set ref 287* 300* 307* 316* 518
                                                                                  567 587 608
read_write_dcw_string           000021 internal static bit(36)                  initial unaligned dcl 1312 ref 1954 1954 1954 1954
                                                                                  1954 1954 1954 1954 1954 1954
read_write_dcw_template                defined         structure                level 1 packed unaligned dcl 1321 ref 1954
real_iocb_ptr                   000120 automatic       pointer                  initial dcl 1243 set ref 1243* 1618 1619 1620 1629
                                                                                  1630 1648 1649 1649 1653 2115 2317 2319 2320 2322
                                                                                  2322 2322 2322 2322 2322 2408* 2409 2411 2422 2426
rec_len                         000136 automatic       fixed bin(35,0)          dcl 1245 in procedure "exdim_" set ref 1724* 1751*
                                                                                  1773 1795 1795 1801 1802 1813 1997 1997* 1998
                                                                                  2017*
rec_len                         000207 automatic       fixed bin(21,0)          dcl 141 in procedure "exercise_disk" set ref 542*
                                                                                  694* 702* 715* 723* 748* 756*
rel                                                    builtin function         dcl 207 ref 1940 1955 1958 2035 2076 2357 2490 2490
repeat_time              10     001162 automatic       fixed bin(71,0)          initial level 2 dcl 8-7 set ref 224* 8-7*
residue                   1(24)        based           bit(12)                  level 2 packed unaligned dcl 1183 ref 1995
restore_idcw_string             000013 internal static bit(36)                  initial unaligned dcl 1306 ref 2033 2033 2033 2033
                                                                                  2033 2033 2033 2033 2033 2033 2033 2033 2033 2033
                                                                                  2033 2033
restore_idcw_template                  defined         structure                level 1 packed unaligned dcl 1315 ref 2033
rewrite_record          102            based           entry variable           level 2 dcl 1-9 set ref 1619* 2322*
rs_mode                         000160 automatic       fixed bin(5,0)           dcl 1255 set ref 1487* 1488
rs_ptr                          000126 automatic       pointer                  initial dcl 1243 set ref 1243* 1485* 1486 1487*
rsr_data                  6            based           bit(88)                  level 3 packed unaligned dcl 1207 set ref 2081* 2154
rst_idcw                               based           fixed bin(35,0)          level 3 dcl 1207 set ref 2032 2035 2354 2357
rtrim                                                  builtin function         dcl 207 ref 284 1063 1064 1500 1504 1686 1686
run                      16(02)        based           bit(1)                   level 5 packed unaligned dcl 1207 set ref 1966* 1971
                                                                                  1980
rw_dcw                    4            based           fixed bin(35,0)          level 3 dcl 1207 set ref 1953
rw_idcw                   3            based           fixed bin(35,0)          level 3 dcl 1207 set ref 1942
s_a                             001236 automatic       fixed bin(24,0)          dcl 832 set ref 880*
sa                                     parameter       fixed bin(24,0)          dcl 955 set ref 947 958* 960 961
sa1                             001020 automatic       fixed bin(24,0)          dcl 157 set ref 548*
se_n                            001237 automatic       fixed bin(24,0)          dcl 832 set ref 880*
se_no                                  parameter       fixed bin(24,0)          dcl 955 set ref 947 959*
sect                            000101 automatic       fixed bin(24,0)          dcl 1011 set ref 1076*
sect_addr                       000100 automatic       fixed bin(24,0)          dcl 1011 set ref 1076*
sect_no                         001213 automatic       fixed bin(24,0)          dcl 685 set ref 778* 782* 785* 786* 793*
sect_per_cyl                    000051 constant        fixed bin(17,0)          initial array dcl 7-15 ref 993 1000 1005 1535 1910
                                                                                  1911 2143
sect_per_dev            100            based           fixed bin(35,0)          level 3 dcl 1131 set ref 1535* 2141
sect_per_track                  000040 constant        fixed bin(17,0)          initial array dcl 7-33 ref 958 959 1906 1912 2144
sect_size               101            based           fixed bin(12,0)          level 3 dcl 1131 set ref 1536* 1695 1773 1795 1795
                                                                                  1795 1795 1801 1801 1873 2147
sect_size_               11     001033 automatic       fixed bin(12,0)          level 2 dcl 160 set ref 542
sector                                 parameter       fixed bin(24,0)          dcl 955 in procedure "convert_seek_addr" ref 947 958
                                                                                  959 985 993 1000 1005
sector                    0(15) 000100 automatic       fixed bin(21,0)          level 2 in structure "seek" packed unsigned
                                                                                  unaligned dcl 1190 in procedure "exdim_" set ref
                                                                                  1892*
sector_number                   000101 automatic       fixed bin(8,0)           level 2 packed unsigned unaligned dcl 1196 set ref
                                                                                  1906*
sectors_for_record              000221 automatic       fixed bin(17,0)          dcl 1755 set ref 1773* 1775
sectors_read                    000140 automatic       fixed bin(24,0)          dcl 118 set ref 220* 550* 767* 767 1043 1048*
sectors_written                 000137 automatic       fixed bin(24,0)          dcl 118 set ref 220* 550* 734* 734 1043 1047*
seek                            000100 automatic       structure                level 1 dcl 1190 in procedure "exdim_" set ref 1884*
                                                                                  1893
seek                            001024 automatic       fixed bin(24,0)          dcl 157 in procedure "exercise_disk" set ref 548*
                                                                                  692* 713* 739* 777* 778* 782* 814 871 880* 888*
seek1                           001025 automatic       fixed bin(24,0)          dcl 157 set ref 561* 568* 570* 582* 588* 590* 603*
                                                                                  609* 611* 690 692 739
seek2                           001026 automatic       fixed bin(24,0)          dcl 157 set ref 562* 583* 604* 691 713
seek_addr                 6     001045 automatic       fixed bin(24,0)          level 2 in structure "device_status_info" dcl 171
                                                                                  in procedure "exercise_disk" set ref 871*
seek_addr                       001212 automatic       fixed bin(24,0)          dcl 685 in procedure "write_sector" set ref 778*
                                                                                  785* 793*
seek_addr_                6     000211 automatic       fixed bin(24,0)          array level 2 dcl 144 set ref 1076*
seek_addr_read                  000143 automatic       fixed bin(24,0)          dcl 119 set ref 780* 785* 786*
seek_command                    001160 automatic       bit(6)                   initial array unaligned dcl 6-84 set ref 6-84* 6-84*
                                                                                  6-84* 6-84* 6-84* 6-84* 6-84* 6-84* 6-84*
seek_counter                    000134 automatic       fixed bin(17,0)          dcl 117 set ref 555* 556 564* 564 572* 572
seek_data                 5            based           structure                level 3 packed unaligned dcl 1207 set ref 1893*
                                                                                  1919* 1940
seek_dcw_string                 000015 internal static bit(36)                  initial unaligned dcl 1308 ref 1939 1939 1939 1939
                                                                                  1939 1939 1939 1939 1939 1939
seek_dcw_template                      defined         structure                level 1 packed unaligned dcl 1317 ref 1939
seek_errors                     000770 automatic       fixed bin(17,0)          dcl 154 set ref 221* 862* 862
seek_idcw_string                000014 internal static bit(36)                  initial unaligned dcl 1307 ref 1871 1871 1871 1871
                                                                                  1871 1871 1871 1871 1871 1871 1871 1871 1871 1871
                                                                                  1871 1871
seek_idcw_template                     defined         structure                level 1 packed unaligned dcl 1316 ref 1871
seek_key                112            based           entry variable           level 2 dcl 1-9 set ref 1620* 1630* 2322*
seq_sw                          000755 automatic       bit(1)                   initial unaligned dcl 152 set ref 152* 288* 352* 528
                                                                                  577 650 660 663
setup_error_msg                 000340 automatic       char(36)                 unaligned dcl 2402 set ref 2417* 2418*
setup_input_arg                        parameter       char                     unaligned dcl 2394 ref 2392 2406
sign                            000174 automatic       char(1)                  level 2 packed unaligned dcl 1268 set ref 2480*
sk_dcw                    2            based           fixed bin(35,0)          level 3 dcl 1207 set ref 1936
sk_idcw                   1            based           fixed bin(35,0)          level 3 dcl 1207 set ref 1870 1958
sn1                             001021 automatic       fixed bin(24,0)          dcl 157 set ref 548*
st                       16            based           bit(1)                   level 5 packed unaligned dcl 1207 set ref 1965* 1971
                                                                                  1980
standby_idcw_string             000012 internal static bit(36)                  initial unaligned dcl 1305 ref 2355 2355 2355 2355
                                                                                  2355 2355 2355 2355 2355 2355 2355 2355 2355 2355
                                                                                  2355 2355
standby_idcw_template                  defined         structure                level 1 packed unaligned dcl 1314 ref 2355
stat_tablep                     001006 automatic       pointer                  dcl 156 set ref 218* 882*
status                                 based           structure                level 1 packed unaligned dcl 1183
status_code               2     001162 automatic       fixed bin(35,0)          initial level 2 dcl 8-7 set ref 8-7*
str1                                   constant        bit(4)                   initial unaligned dcl 188 ref 227 227 227
str2                                   constant        bit(4)                   initial unaligned dcl 189 ref 227 227 227
str3                                   constant        bit(4)                   initial unaligned dcl 190 ref 227 227 227
sub                       0(06)        based           bit(6)                   level 2 packed unaligned dcl 1183 ref 1988 1992
substr                                                 builtin function         dcl 207 set ref 329 537 545 545 780 865 885 885 892
                                                                                  892 892 892 897 897 906 1063 1064 1502 1866* 1866
                                                                                  1867 1996* 1996 1998 2016* 2016 2082 2085 2085
                                                                                  2085 2085 2250 2262 2272 2284 2286 2290 2290* 2290
                                                                                  2293 2293* 2293 2415 2481
super_seek                      000101 automatic       structure                level 1 dcl 1196 set ref 1903* 1919
suppress_name_sw          1(01) 001162 automatic       bit(1)                   initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  226* 8-7*
suppress_spacing          1(04) 001162 automatic       bit(1)                   initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  8-7*
switches                  1     001162 automatic       structure                level 2 dcl 8-7
sys_sw                   55(06)        based           bit(1)                   level 3 packed unaligned dcl 1131 set ref 1438*
                                                                                  1488* 1490 1514 1539
system                          000202 automatic       varying char(4)          initial dcl 139 set ref 139* 403* 457 459
system_flag               3            based           bit(1)                   level 2 dcl 4-19 set ref 1514*
sze                      54            based           fixed bin(35,0)          level 3 dcl 1131 set ref 1440* 2485
tally                     0(24)        based           bit(12)                  level 2 packed unaligned dcl 3-7 set ref 1956*
temp_                           000104 automatic       varying char(100)        initial array dcl 1012 set ref 1012* 1077* 1087 1087
                                                                                  1088 1089* 1089 1090* 1099 1099 1102*
temp_key                        000173 automatic       fixed bin(35,0)          dcl 1267 set ref 1686* 1690 1690 1692
temp_next_mode                  000223 automatic       char(16)                 unaligned dcl 2179 set ref 2249* 2250* 2250 2251*
temp_str                        000104 automatic       varying char(100)        initial dcl 1013 set ref 1013* 1088* 1090
terminate_process_              000204 constant        entry                    external dcl 1371 ref 2522
test_in_progress                000011 internal static fixed bin(17,0)          dcl 196 set ref 210 235* 473* 1019 1041*
ti                        0(12) 000100 automatic       bit(2)                   level 2 in structure "seek" packed unaligned
                                                                                  dcl 1190 in procedure "exdim_" set ref 1891*
ti                        0(12) 000101 automatic       bit(2)                   level 2 in structure "super_seek" packed unaligned
                                                                                  dcl 1196 in procedure "exdim_" set ref 1907*
time_int                126            based           fixed bin(52,0)          level 3 dcl 1131 set ref 2463 2471 2493*
time_out                 16(03)        based           bit(1)                   level 5 packed unaligned dcl 1207 set ref 1980 1980
timer_manager_$sleep            000170 constant        entry                    external dcl 1365 ref 2059
to_                             000130 automatic       fixed bin(24,0)          dcl 114 set ref 230* 289* 391* 396*
to_sector                       000144 automatic       fixed bin(24,0)          dcl 120 set ref 396* 599 621
to_sw                           000125 automatic       bit(1)                   initial unaligned dcl 113 set ref 113* 400*
tp_info                         000112 automatic       structure                level 1 unaligned dcl 1239 set ref 2522 2522
track_indicators                000143 automatic       bit(2)                   initial unaligned dcl 1247 set ref 1247* 1788* 1891
                                                                                  1907
tracks_per_cyl                  000126 constant        fixed bin(17,0)          initial array dcl 6-111 ref 960 961
true_len                        000264 automatic       fixed bin(35,0)          dcl 1855 set ref 1857* 1866 1866 1867 1867 1867 1995
                                                                                  2016 2016 2017
ubuf_ptr                        000122 automatic       pointer                  initial dcl 1243 set ref 1243* 1786* 1800
unique_chars_                   000214 constant        entry                    external dcl 1407 ref 1428
unique_entry_name               000213 automatic       char(22)                 unaligned dcl 1408 set ref 1428* 1429*
unspec                                                 builtin function         dcl 207 set ref 1867* 1884* 1893* 1893 1903* 1919*
                                                                                  1919 1998*
usage_time                1            based           fixed bin(17,0)          level 2 dcl 4-19 set ref 1513*
user_bounds                            based           structure                level 1 unaligned dcl 1257
user_cyl_per_dev          4            based           fixed bin(17,0)          level 2 dcl 1385 set ref 2142*
user_dev_char_table                    based           structure                level 1 dcl 1385
user_dev_cmd              5            based           fixed bin(17,0)          level 2 dcl 1396 set ref 2155*
user_dev_detail_status
                          2            based           bit(8)                   array level 2 packed unaligned dcl 1396 set ref
                                                                                  2154*
user_device_name          1            based           char(8)                  level 2 dcl 1385 set ref 2140*
user_hardware_status                   based           bit(72)                  level 2 dcl 1396 set ref 2153*
user_num_alt_sect        10            based           fixed bin(17,0)          level 2 dcl 1385 set ref 2146*
user_num_label_sect       7            based           fixed bin(17,0)          level 2 dcl 1385 set ref 2145*
user_sect_per_cyl         5            based           fixed bin(17,0)          level 2 dcl 1385 set ref 2143*
user_sect_per_dev         3            based           fixed bin(35,0)          level 2 dcl 1385 set ref 2141*
user_sect_per_track       6            based           fixed bin(17,0)          level 2 dcl 1385 set ref 2144*
user_sect_size           11            based           fixed bin(12,0)          level 2 dcl 1385 set ref 2147*
user_status_info                       based           structure                level 1 dcl 1396
user_subsystem_name                    based           char(4)                  level 2 dcl 1385 set ref 2139*
version                         000112 automatic       fixed bin(17,0)          level 2 dcl 1239 set ref 2520*
version_num                            based           fixed bin(17,0)          level 2 dcl 4-19 set ref 1512* 2129 2129
volume_name               7            based           char(32)                 level 2 dcl 4-19 set ref 2458*
wait_list                70            based           structure                level 3 dcl 1131 set ref 1973 1973 2468 2468
wait_time                 2            based           fixed bin(17,0)          level 2 dcl 4-19 set ref 1513*
wc_mc_ptr                              parameter       pointer                  dcl 2515 ref 2507
who_did_the_attach              000336 automatic       char(6)                  unaligned dcl 2401 set ref 2415* 2416 2417
words_per_sect                  000027 constant        fixed bin(17,0)          initial array dcl 7-36 ref 512 1536
words_per_sector                000132 automatic       fixed bin(17,0)          initial dcl 116 set ref 116* 512* 515 519 520 744
                                                                                  772 772 775 815 1033 1035
write_and_compare_idcw_string   000020 internal static bit(36)                  initial unaligned dcl 1311 ref 1945 1945 1945 1945
                                                                                  1945 1945 1945 1945 1945 1945 1945 1945 1945 1945
                                                                                  1945 1945
write_and_compare_idcw_template        defined         structure                level 1 packed unaligned dcl 1319 ref 1945
write_compare                   000204 automatic       varying char(7)          initial dcl 140 set ref 140* 406* 494 506
write_errors                    000765 automatic       fixed bin(17,0)          dcl 154 set ref 220* 851* 851 1052*
write_flag               17            based           bit(1)                   level 2 dcl 4-19 set ref 1519*
write_idcw_string               000017 internal static bit(36)                  initial unaligned dcl 1310 ref 1947 1947 1947 1947
                                                                                  1947 1947 1947 1947 1947 1947 1947 1947 1947 1947
                                                                                  1947 1947
write_idcw_template                    defined         structure                level 1 packed unaligned dcl 1320 ref 1947
write_record             76            based           entry variable           level 2 dcl 1-9 set ref 2322*
write_sw                 55(01)        based           bit(1)                   level 3 in structure "disk_data" packed unaligned
                                                                                  dcl 1131 in procedure "exdim_" set ref 1438* 1467*
                                                                                  1519 1614
write_sw                        000754 automatic       bit(1)                   unaligned dcl 151 in procedure "exercise_disk" set
                                                                                  ref 287* 301* 308* 317* 435 453 515 520 560 581
                                                                                  602
x                               000135 automatic       fixed bin(24,0)          dcl 118 set ref 557* 558 561 568 577* 579 582 588*
                                                                                  598* 603 609 617* 617 621 1095* 1097 1103*
y                               000136 automatic       fixed bin(24,0)          dcl 118 set ref 558* 562 570 579* 583 590 599* 604
                                                                                  611 618* 618
yes_or_no_sw              1     001162 automatic       bit(1)                   initial level 3 packed unaligned dcl 8-7 set ref
                                                                                  223* 8-7*
z                               001216 automatic       fixed bin(17,0)          dcl 686 set ref 775* 776 776 777* 779 796* 796 796
                                                                                  796 797 797 797 797 799 799 799 799*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_output                          internal static fixed bin(17,0)          initial dcl 5-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 5-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 5-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 5-15
MODEL                                  internal static fixed bin(17,0)          initial array dcl 6-57
MODELX                                 internal static fixed bin(17,0)          initial array dcl 6-60
Sequential_input                       internal static fixed bin(17,0)          initial dcl 5-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 5-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 5-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 5-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 5-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 5-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 5-15
bulkdevt                               internal static fixed bin(4,0)           initial dcl 6-43
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 6-105
dev_time                               internal static float bin(27)            initial array dcl 6-139
dsu181devt                             internal static fixed bin(4,0)           initial dcl 6-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 6-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 6-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 6-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 6-43
fips_type_disk                         internal static bit(1)                   initial array unaligned dcl 6-72
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 6-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 6-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 6-124
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-64
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 6-118
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 6-121
msu0400devt                            internal static fixed bin(4,0)           initial dcl 6-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 6-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 6-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 6-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 6-43
needs_alt_part                         internal static bit(1)                   initial array unaligned dcl 6-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 6-93
pcw                                    based           structure                level 1 dcl 2-6
pcwp                                   automatic       pointer                  dcl 2-4
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 8-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 8-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 8-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 8-36
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 6-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 6-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 6-90
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 7-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 7-18
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 7-26
shared_spindle                         internal static bit(1)                   initial array unaligned dcl 6-78
short_iox_modes                        internal static char(4)                  initial array dcl 5-12
tdcw                                   based           structure                level 1 dcl 3-14
tdcwp                                  automatic       pointer                  dcl 3-4
valid_sv_array                         internal static char(1)                  initial array unaligned dcl 6-99
valid_sv_string                        internal static char(3)                  initial unaligned dcl 6-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 7-29

NAMES DECLARED BY EXPLICIT CONTEXT.
BUILD_ALT_SEEK                  000003 constant        label                    array(3) dcl 1884 ref 1877
BUILD_DATA_SEEK                 000000 constant        label                    array(3) dcl 1884 ref 1875
BUILD_NORMAL_SEEK               014571 constant        label                    dcl 1884 ref 1926
BUILD_SUPER_SEEK                014615 constant        label                    dcl 1903 ref 1933
EXIT                            007356 constant        entry                    internal dcl 1009 ref 234 627
SEEK_BUILT                      014723 constant        label                    dcl 1936 ref 1894 1920
att_err                         014353 constant        entry                    internal dcl 1570 ref 1435 1451 1473 1477 1490 1493
                                                                                  1508 1524
bad_arg                         003450 constant        label                    dcl 411 ref 243 251 270 281 296 326 331 361 364 369
                                                                                  373 385 388 393 397
bad_ret                         007313 constant        label                    dcl 996 ref 1000
build_sb                        006327 constant        entry                    internal dcl 810 ref 693 714 743
cond_hdlr                       017121 constant        entry                    internal dcl 2507 ref 1548 1548 1643 1643 2314 2314
                                                                                  2370 2370
convert_seek_addr               007171 constant        entry                    internal dcl 947 ref 548 778 785 880 1076
delay_retry                     015546 constant        entry                    internal dcl 2046 ref 1988
detach                          017056 constant        entry                    internal dcl 2496 ref 2467
do_io                           014426 constant        entry                    internal dcl 1853 ref 1803
done_args                       003562 constant        label                    dcl 427
error                           006356 constant        entry                    internal dcl 823 in procedure "exercise_disk" ref
                                                                                  635
error                           016420 constant        entry                    internal dcl 2438 in procedure "exdim_" ref 1430
                                                                                  1614 1638 1684 1687 1690 1715 1720 1741 1745 1782
                                                                                  1795 1845 1880 2115 2158 2251 2383 2411 2418 2422
                                                                                  2426
error1                          005136 constant        label                    dcl 632 ref 705 726 759
exdim_                          010636 constant        entry                    internal dcl 1127
exdim_attach                    010646 constant        entry                    internal dcl 1414 ref 476
exdim_close                     013716 constant        entry                    internal dcl 2304 ref 1023 1648
exdim_control                   013140 constant        entry                    internal dcl 2102 ref 534 847 1555
exdim_detach                    014057 constant        entry                    internal dcl 2342 ref 1028 1553 2320
exdim_modes                     013401 constant        entry                    internal dcl 2169 ref 494 506 1556
exdim_open                      012012 constant        entry                    internal dcl 1587 ref 485 1554 2319
exdim_read                      012473 constant        entry                    internal dcl 1704 ref 756 1618 1629
exdim_rewrite                   012602 constant        entry                    internal dcl 1729 ref 702 723 1619
exdim_seek                      012253 constant        entry                    internal dcl 1666 ref 694 715 748 1620 1630
exercise_disk                   002204 constant        entry                    external dcl 28
exit                            012006 constant        label                    dcl 1565 ref 1578 2094 2444
get_dev_size                    007137 constant        entry                    internal dcl 924 ref 269
get_next_mode                   015771 constant        entry                    internal dcl 2258 ref 2191
get_seek_addr                   007270 constant        entry                    internal dcl 985 ref 372 396
io_err                          014374 constant        entry                    internal dcl 1836 ref 1779 1969 1974 2006
io_succeeded                    013110 constant        label                    dcl 1806
llose                           005131 constant        label                    dcl 627 ref 480 488 497 637 644 672 698 707 719 728
                                                                                  752 761
mount                           016443 constant        entry                    internal dcl 2452 ref 1523
perm_err                        015575 constant        entry                    internal dcl 2070 ref 1984 1990 2009 2011 2038 2056
print_it                        010455 constant        label                    dcl 1097 ref 1105
rand_read                       005021 constant        label                    dcl 569 ref 657
random_write                    005004 constant        label                    dcl 560 ref 654
range_cont                      005077 constant        label                    dcl 600
range_read                      005110 constant        label                    dcl 608 ref 669
range_write                     005101 constant        label                    dcl 602 ref 624 651 666
read_sector                     005525 constant        entry                    internal dcl 738 ref 569 571 589 591 610 612
read_write_common               012705 constant        label                    dcl 1755 ref 1727
retry                           015461 constant        entry                    internal dcl 2027 ref 1980 1986 2060
seq_read                        005063 constant        label                    dcl 589 ref 663
seq_write                       005050 constant        label                    dcl 581 ref 660
set_mode                        016055 constant        entry                    internal dcl 2282 ref 2243
setup                           016213 constant        entry                    internal dcl 2392 ref 1602 1682 1712 1739 2113 2181
                                                                                  2311 2348
start                           003702 constant        label                    dcl 441
start_rand                      004773 constant        label                    dcl 557 ref 648
start_range                     005073 constant        label                    dcl 598 ref 621
start_seq                       005043 constant        label                    dcl 579 ref 650
write_sector                    005245 constant        entry                    internal dcl 677 ref 563 584 605

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     20364       20602   17313       20374
Length     21454   17313       216         636    1051          14

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
exercise_disk                      1405 external procedure  is an external procedure.  
on unit on line 233                  64 on unit               
on unit on line 547                  96 on unit               
write_sector                            internal procedure  shares stack frame of external procedure exercise_disk.  
build_sb                                internal procedure  shares stack frame of external procedure exercise_disk.  
error                                   internal procedure  shares stack frame of external procedure exercise_disk.  
get_dev_size                            internal procedure  shares stack frame of external procedure exercise_disk.  
convert_seek_addr                    68 internal procedure  is called by several nonquick procedures.  
EXIT                                244 internal procedure  uses auto adjustable storage.  
exdim_                              488 internal procedure  is called during a stack extension, and   
                                                            is assigned to an entry variable.  
att_err                                 internal procedure  shares stack frame of internal procedure exdim_.  
io_err                                  internal procedure  shares stack frame of internal procedure exdim_.  
do_io                                   internal procedure  shares stack frame of internal procedure exdim_.  
retry                                   internal procedure  shares stack frame of internal procedure exdim_.  
delay_retry                             internal procedure  shares stack frame of internal procedure exdim_.  
perm_err                                internal procedure  shares stack frame of internal procedure exdim_.  
get_next_mode                           internal procedure  shares stack frame of internal procedure exdim_.  
set_mode                                internal procedure  shares stack frame of internal procedure exdim_.  
setup                                   internal procedure  shares stack frame of internal procedure exdim_.  
error                                65 internal procedure  is called during a stack extension.  
mount                               144 internal procedure  enables or reverts conditions.  
on unit on line 2467                 96 on unit               
detach                                  internal procedure  shares stack frame of on unit on line 2467.  
cond_hdlr                            82 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 err_retry                   exercise_disk
000011 test_in_progress            exercise_disk
000012 standby_idcw_string         exdim_
000013 restore_idcw_string         exdim_
000014 seek_idcw_string            exdim_
000015 seek_dcw_string             exdim_
000016 read_idcw_string            exdim_
000017 write_idcw_string           exdim_
000020 write_and_compare_idcw_string
                                   exdim_
000021 read_write_dcw_string       exdim_
000022 last_cmd_                   exdim_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
EXIT                     000100 sect_addr                   EXIT
                         000101 sect                        EXIT
                         000102 cyl                         EXIT
                         000103 hd                          EXIT
                         000104 temp_                       EXIT
                         000104 temp_str                    EXIT
                         000136 i                           EXIT
                         000137 j                           EXIT
                         000140 count_                      EXIT
                         000141 CA                          EXIT
                         000145 PORT                        EXIT
                         000151 linelth                     EXIT
exdim_                   000100 seek                        exdim_
                         000101 super_seek                  exdim_
                         000102 event_info                  exdim_
                         000112 tp_info                     exdim_
                         000114 disk_ptr                    exdim_
                         000116 iocb_ptr                    exdim_
                         000120 real_iocb_ptr               exdim_
                         000122 ubuf_ptr                    exdim_
                         000124 block_ptr                   exdim_
                         000126 rs_ptr                      exdim_
                         000130 info_ptr                    exdim_
                         000132 fmdp                        exdim_
                         000134 dcw_offset                  exdim_
                         000135 code                        exdim_
                         000136 rec_len                     exdim_
                         000137 data_left                   exdim_
                         000140 mode_len                    exdim_
                         000141 mode_start                  exdim_
                         000142 key                         exdim_
                         000143 track_indicators            exdim_
                         000144 count_limit_fixed           exdim_
                         000145 block_len                   exdim_
                         000146 i                           exdim_
                         000147 num_opts                    exdim_
                         000150 err_ct                      exdim_
                         000151 rcp_state                   exdim_
                         000152 cyl                         exdim_
                         000153 head                        exdim_
                         000154 again                       exdim_
                         000155 not_sw                      exdim_
                         000156 mode_err_sw                 exdim_
                         000157 dev_id                      exdim_
                         000160 rs_mode                     exdim_
                         000161 new_modes                   exdim_
                         000167 next_mode                   exdim_
                         000172 mask_str                    exdim_
                         000173 temp_key                    exdim_
                         000174 drive_number                exdim_
                         000176 drive_name                  exdim_
                         000200 model_number                exdim_
                         000201 found                       exdim_
                         000202 io_command                  exdim_
                         000205 current_mode_name           exdim_
                         000213 unique_entry_name           exdim_
                         000221 sectors_for_record          exdim_
                         000222 potential_next_sector       exdim_
                         000223 temp_next_mode              exdim_
                         000246 c_code                      att_err
                         000264 true_len                    do_io
                         000265 data_read                   do_io
                         000332 desired_switch_state        setup
                         000336 who_did_the_attach          setup
                         000340 setup_error_msg             setup
exercise_disk            000100 dt                          exercise_disk
                         000106 code                        exercise_disk
                         000110 argptr                      exercise_disk
                         000112 argcnt                      exercise_disk
                         000113 arglen                      exercise_disk
                         000114 arg_sw                      exercise_disk
                         000115 i                           exercise_disk
                         000116 arg1                        exercise_disk
                         000121 pack_id                     exercise_disk
                         000124 from_sw                     exercise_disk
                         000125 to_sw                       exercise_disk
                         000126 dev_sw                      exercise_disk
                         000127 from                        exercise_disk
                         000130 to_                         exercise_disk
                         000131 dev_idx                     exercise_disk
                         000132 words_per_sector            exercise_disk
                         000133 a                           exercise_disk
                         000134 seek_counter                exercise_disk
                         000135 x                           exercise_disk
                         000136 y                           exercise_disk
                         000137 sectors_written             exercise_disk
                         000140 sectors_read                exercise_disk
                         000141 highest_sector              exercise_disk
                         000142 loest_sector                exercise_disk
                         000143 seek_addr_read              exercise_disk
                         000144 to_sector                   exercise_disk
                         000145 device_type                 exercise_disk
                         000146 model_num                   exercise_disk
                         000147 my_key1                     exercise_disk
                         000152 my_key2                     exercise_disk
                         000155 data_init_sw                exercise_disk
                         000156 compare_err                 exercise_disk
                         000157 constant_                   exercise_disk
                         000160 doing                       exercise_disk
                         000200 ii                          exercise_disk
                         000201 err_cnt                     exercise_disk
                         000202 system                      exercise_disk
                         000204 write_compare               exercise_disk
                         000207 rec_len                     exercise_disk
                         000210 read_data_len               exercise_disk
                         000211 errors                      exercise_disk
                         000747 quit_flag                   exercise_disk
                         000750 ndc_sw                      exercise_disk
                         000751 alt_sw                      exercise_disk
                         000752 random_sw                   exercise_disk
                         000753 read_sw                     exercise_disk
                         000754 write_sw                    exercise_disk
                         000755 seq_sw                      exercise_disk
                         000756 range_sw                    exercise_disk
                         000757 dev_evn                     exercise_disk
                         000760 dev_attached                exercise_disk
                         000761 dev_open                    exercise_disk
                         000762 mode_string                 exercise_disk
                         000765 write_errors                exercise_disk
                         000766 read_errors                 exercise_disk
                         000767 read_cmp_err                exercise_disk
                         000770 seek_errors                 exercise_disk
                         000771 answer                      exercise_disk
                         001002 data_bufp                   exercise_disk
                         001004 read_ptr                    exercise_disk
                         001006 stat_tablep                 exercise_disk
                         001010 iocbp                       exercise_disk
                         001012 dev_infop                   exercise_disk
                         001014 dev_statp                   exercise_disk
                         001016 querie                      exercise_disk
                         001020 sa1                         exercise_disk
                         001021 sn1                         exercise_disk
                         001022 cn1                         exercise_disk
                         001023 hn1                         exercise_disk
                         001024 seek                        exercise_disk
                         001025 seek1                       exercise_disk
                         001026 seek2                       exercise_disk
                         001027 PC                          exercise_disk
                         001030 PH                          exercise_disk
                         001031 epc                         exercise_disk
                         001032 opc                         exercise_disk
                         001033 device_info                 exercise_disk
                         001045 device_status_info          exercise_disk
                         001054 device_name                 exercise_disk
                         001056 open_mode                   exercise_disk
                         001060 options_ptr                 exercise_disk
                         001062 options_                    exercise_disk
                         001151 d500_sw                     exercise_disk
                         001152 idcwp                       exercise_disk
                         001154 dcwp                        exercise_disk
                         001156 disk_info_ptr               exercise_disk
                         001160 seek_command                exercise_disk
                         001162 query_info                  exercise_disk
                         001212 seek_addr                   write_sector
                         001213 sect_no                     write_sector
                         001214 cylno                       write_sector
                         001215 hdno                        write_sector
                         001216 z                           write_sector
                         001226 i                           build_sb
                         001236 s_a                         error
                         001237 se_n                        error
                         001240 cyl_no                      error
                         001241 hd_no                       error
                         001242 my_analyses                 error
                         001576 msg                         error
                         001677 is_interesting              error
                         001710 dvt                         get_dev_size

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          move_label_var      make_label_var      tra_ext_1
alloc_auto_adj      mpfx2               mdfx1               mdfx3               signal_op           enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      ceil_fx2            floor_fx2
set_chars_eis       index_chars_eis     any_to_any_truncate_divide_fx1          divide_fx3          alloc_storage
op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
analyze_detail_stat_$rsnnl    analyze_device_stat_$rsnnl    clock_                        com_err_
command_query_                cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_
cv_dec_check_                 date_time_                    default_handler_$set          hcs_$delentry_seg
hcs_$fs_get_mode              hcs_$initiate                 hcs_$make_seg                 hcs_$reset_ips_mask
hcs_$set_ips_mask             ioa_                          ioa_$rsnnl                    ioi_$connect
ioi_$get_detailed_status      ioi_$set_status               ioi_$timeout                  ioi_$workspace
iox_$destroy_iocb             iox_$err_no_operation         iox_$err_not_closed           iox_$err_not_open
iox_$find_iocb                iox_$propagate                ipc_$block                    ipc_$create_ev_chn
ipc_$delete_ev_chn            rcp_$attach                   rcp_$check_attach             rcp_$detach
terminate_process_            timer_manager_$sleep          unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
disk_status_table_$disk_status_table_                       error_table_$action_not_performed
error_table_$bad_arg          error_table_$bad_mode         error_table_$badopt           error_table_$device_end
error_table_$device_parity    error_table_$device_parity    error_table_$incompatible_attach
error_table_$no_operation     error_table_$no_record        error_table_$noarg            error_table_$noarg
error_table_$not_attached     error_table_$not_closed       error_table_$not_detached     error_table_$not_open
error_table_$request_not_recognized                         error_table_$termination_requested
error_table_$unimplemented_version                          error_table_$user_not_found   error_table_$wrong_no_of_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 002203       105 002211       113 002213       116 002216       124 002220       128 002222       134 002223
    135 002225       136 002226       138 002227       139 002231       140 002232       150 002237       152 002242
    178 002247       197 002251    6   84 002252    8    7 002341       210 002371       211 002374       212 002420
    213 002445       218 002446       219 002450       220 002452       221 002455       222 002460       223 002462
    224 002464       225 002466       226 002470       227 002472       228 002523       229 002525       230 002526
    233 002531       234 002545       235 002552       236 002554       238 002555       240 002564       241 002567
    242 002570       243 002573       246 002574       247 002576       248 002613       250 002615       251 002616
    254 002617       257 002640       258 002651       259 002654       260 002656       262 002662       264 002664
    269 002666       270 002670       276 002672       277 002674       278 002711       280 002713       281 002714
    284 002715       287 002733       288 002737       289 002744       291 002746       294 002757       295 002761
    296 002776       299 003000       300 003012       301 003013       303 003015       306 003016       307 003026
    308 003030       309 003031       310 003033       315 003034       316 003044       317 003046       319 003047
    321 003050       323 003060       324 003061       326 003076       329 003100       330 003110       331 003112
    334 003113       335 003116       336 003120       339 003121       342 003134       346 003147       350 003156
    351 003166       352 003167       353 003171       355 003172       356 003202       357 003204       358 003205
    359 003206       361 003223       364 003225       367 003240       369 003265       372 003267       373 003301
    376 003303       377 003305       379 003306       381 003312       382 003314       383 003315       385 003332
    388 003334       391 003347       393 003374       396 003376       397 003410       400 003412       401 003414
    403 003415       406 003432       411 003450       414 003453       415 003456       416 003510       418 003511
    419 003514       421 003537       422 003557       424 003560       427 003562       434 003570       435 003620
    436 003622       437 003642       438 003675       441 003702       444 003704       445 003715       446 003722
    448 003727       449 003732       450 003734       451 003742       453 003750       454 003752       455 003753
    457 003763       458 003770       459 003771       463 004002       465 004036       467 004040       468 004065
    469 004067       470 004114       473 004115       475 004120       476 004122       478 004140       479 004142
    480 004172       483 004173       485 004175       486 004207       487 004211       488 004244       491 004245
    493 004247       494 004251       495 004306       496 004311       497 004340       500 004341       501 004344
    506 004345       507 004402       508 004405       512 004432       515 004435       518 004443       519 004445
    520 004451       525 004461       528 004467       531 004475       533 004500       534 004502       535 004531
    537 004533       540 004554       542 004555       544 004561       545 004605       547 004650       548 004664
    549 004704       550 004734       551 004764       553 004765       555 004767       556 004770       557 004773
    558 004777       559 005002       560 005004       561 005006       562 005010       563 005012       564 005013
    567 005015       568 005017       569 005021       570 005022       571 005024       572 005025       574 005027
    575 005030       577 005031       579 005043       580 005046       581 005050       582 005052       583 005054
    584 005056       587 005057       588 005061       589 005063       590 005064       591 005066       593 005067
    598 005073       599 005075       600 005077       602 005101       603 005103       604 005105       605 005107
    608 005110       609 005112       610 005114       611 005115       612 005117       615 005120       617 005122
    618 005123       621 005125       624 005130       627 005131       629 005135       632 005136       635 005140
    637 005141       640 005143       641 005147       642 005150       643 005177       644 005204       648 005205
    650 005207       651 005211       654 005212       657 005220       660 005224       663 005230       666 005234
    669 005240       672 005244       677 005245       690 005246       691 005255       692 005264       693 005266
    694 005267       696 005303       697 005305       698 005335       702 005336       704 005352       705 005354
    706 005357       707 005402       713 005403       714 005405       715 005406       717 005422       718 005424
    719 005454       723 005455       725 005471       726 005473       727 005476       728 005521       734 005522
    736 005524       738 005525       739 005526       740 005540       743 005543       744 005544       748 005552
    750 005566       751 005570       752 005620       756 005621       758 005637       759 005641       760 005644
    761 005667       767 005670       768 005671       772 005674       775 005705       776 005715       777 005723
    778 005753       779 005771       780 005773       781 006002       782 006016       785 006047       786 006065
    788 006116       789 006117       793 006120       796 006151       797 006214       799 006257       800 006322
    801 006323       803 006324       806 006326       810 006327       814 006330       815 006340       816 006351
    817 006353       819 006355       823 006356       836 006357       843 006360       844 006361       845 006362
    846 006373       847 006375       849 006424       850 006427       851 006434       852 006435       854 006436
    855 006440       856 006444       857 006445       858 006447       860 006450       861 006452       862 006456
    865 006457       868 006466       869 006471       871 006472       872 006474       873 006502       876 006503
    877 006527       880 006531       882 006547       883 006601       885 006625       888 006664       892 006727
    895 006770       896 006773       897 006774       899 007033       904 007063       906 007066       907 007073
    913 007127       920 007136       924 007137       933 007141       934 007142       935 007151       936 007154
    937 007156       939 007161       940 007163       941 007166       947 007170       958 007200       959 007206
    960 007212       961 007215       963 007221       964 007224       965 007230       966 007233       967 007235
    968 007240       971 007241       972 007243       973 007245       975 007251       977 007256       982 007260
    985 007267       992 007276       993 007300       996 007313       997 007316      1000 007326      1005 007340
   1009 007355      1012 007363      1013 007413      1077 007414      1019 007416      1022 007421      1023 007424
   1024 007435      1027 007437      1028 007442      1029 007453      1031 007502      1033 007504      1035 007513
   1038 007523      1041 007541      1043 007543      1045 007551      1046 007600      1047 007615      1048 007636
   1050 007657      1052 007663      1053 007703      1054 007724      1055 007745      1058 007752      1059 007772
   1061 010013      1062 010024      1063 010032      1064 010103      1065 010155      1067 010156      1068 010162
   1071 010166      1073 010212      1076 010235      1077 010257      1083 010351      1085 010354      1086 010365
   1087 010377      1088 010421      1089 010426      1090 010435      1092 010444      1093 010446      1095 010450
   1097 010455      1098 010465      1099 010477      1102 010521      1103 010545      1104 010550      1105 010552
   1107 010553      1108 010555      1110 010557      1111 010572      1114 010573      1117 010613      1243 010615
   1247 010626      1262 010627      1127 010635      1128 010644      1414 010645      1426 010657      1428 010660
   1429 010705      1430 010743      1432 010763      1433 010771      1435 010774      1438 011007      1439 011016
   1440 011021      1441 011022      1442 011024      1443 011026      1445 011027      1447 011033      1448 011035
   1449 011042      1450 011046      1451 011047      1453 011056      1455 011064      1458 011070      1459 011072
   1460 011104      1461 011112      1465 011114      1467 011123      1470 011142      1473 011154      1475 011166
   1476 011167      1477 011201      1479 011215      1482 011216      1485 011230      1486 011303      1487 011307
   1488 011322      1490 011335      1491 011350      1493 011351      1495 011360      1497 011362      1499 011401
   1500 011431      1501 011444      1502 011453      1504 011511      1505 011524      1507 011526      1508 011540
   1509 011544      1511 011547      1512 011552      1513 011554      1514 011556      1515 011562      1517 011567
   1518 011570      1519 011573      1520 011577      1521 011601      1522 011603      1523 011605      1524 011611
   1526 011615      1527 011617      1528 011630      1530 011640      1533 011642      1535 011646      1536 011652
   1537 011654      1539 011660      1540 011665      1541 011667      1543 011676      1545 011701      1547 011706
   1548 011707      1549 011721      1551 011731      1552 011734      1553 011736      1554 011743      1555 011750
   1556 011755      1558 011762      1560 011771      1562 012001      1565 012006      1566 012010      1587 012011
   1602 012023      1605 012030      1613 012034      1614 012036      1616 012061      1617 012064      1618 012067
   1619 012075      1620 012102      1622 012107      1623 012110      1626 012111      1627 012113      1628 012115
   1629 012120      1630 012126      1632 012133      1633 012135      1637 012136      1638 012144      1642 012161
   1643 012162      1644 012174      1648 012204      1649 012212      1653 012227      1655 012232      1657 012240
   1659 012250      1660 012251      1666 012252      1682 012266      1683 012273      1684 012302      1686 012322
   1687 012400      1690 012432      1692 012462      1695 012464      1696 012470      1697 012471      1704 012472
   1712 012506      1715 012513      1717 012540      1718 012542      1719 012544      1720 012545      1722 012565
   1724 012571      1725 012574      1726 012575      1727 012600      1729 012601      1739 012615      1741 012622
   1743 012647      1744 012651      1745 012653      1748 012673      1751 012700      1752 012702      1773 012705
   1775 012721      1777 012723      1778 012726      1779 012731      1782 012735      1786 012773      1788 012777
   1795 013000      1800 013060      1801 013062      1802 013105      1803 013107      1806 013110      1812 013115
   1813 013120      1814 013122      1817 013124      1822 013125      1829 013135      1830 013136      2102 013137
   2113 013157      2115 013167      2119 013223      2121 013227      2122 013235      2123 013240      2124 013242
   2127 013243      2128 013247      2129 013253      2131 013256      2132 013261      2134 013262      2135 013266
   2137 013267      2138 013273      2139 013277      2140 013303      2141 013310      2142 013313      2143 013315
   2144 013320      2145 013323      2146 013325      2147 013327      2148 013331      2152 013332      2153 013336
   2154 013345      2155 013354      2156 013357      2158 013360      2160 013376      2161 013377      2169 013400
   2181 013420      2183 013430      2184 013432      2186 013433      2187 013440      2189 013442      2191 013447
   2192 013450      2194 013455      2196 013456      2198 013463      2199 013466      2200 013470      2201 013471
   2203 013476      2204 013500      2205 013502      2207 013503      2209 013510      2210 013514      2211 013516
   2212 013517      2214 013524      2216 013534      2217 013537      2218 013541      2220 013542      2221 013553
   2223 013564      2224 013571      2225 013573      2226 013576      2227 013600      2228 013601      2229 013606
   2231 013615      2232 013616      2235 013630      2236 013633      2237 013635      2239 013636      2240 013641
   2243 013643      2246 013646      2249 013647      2250 013665      2251 013674      2252 013713      2254 013714
   2304 013715      2311 013727      2313 013734      2314 013735      2315 013747      2317 013757      2319 013762
   2320 013767      2322 013774      2329 014031      2331 014037      2333 014047      2335 014054      2336 014055
   2342 014056      2348 014070      2352 014075      2354 014103      2355 014106      2356 014135      2357 014143
   2358 014147      2362 014162      2364 014216      2366 014230      2367 014241      2369 014243      2370 014244
   2371 014256      2373 014266      2374 014271      2376 014272      2379 014307      2381 014315      2383 014325
   2385 014351      2386 014352      1570 014353      1574 014355      1576 014357      1577 014370      1578 014373
   1836 014374      1840 014376      1841 014403      1842 014406      1845 014411      1847 014425      1853 014426
   1857 014427      1865 014436      1866 014443      1867 014451      1870 014465      1871 014472      1872 014521
   1873 014530      1875 014540      1877 014546      1880 014552      1884 014571      1890 014572      1891 014575
   1892 014602      1893 014606      1894 014612      1897 014613      1903 014615      1906 014616      1907 014627
   1908 014634      1909 014636      1910 014640      1911 014643      1912 014647      1913 014660      1915 014670
   1916 014672      1917 014701      1918 014707      1919 014711      1920 014714      1923 014715      1926 014717
   1929 014720      1933 014722      1936 014723      1939 014727      1940 014750      1942 014753      1944 014755
   1945 015012      1947 015052      1950 015105      1951 015110      1953 015120      1954 015122      1955 015142
   1956 015146      1958 015155      1960 015161      1961 015163      1963 015164      1965 015170      1966 015174
   1968 015176      1969 015211      1971 015217      1973 015234      1974 015253      1976 015261      1978 015262
   1980 015263      1984 015302      1986 015307      1988 015313      1990 015332      1992 015334      1994 015347
   1995 015354      1996 015376      1997 015402      1998 015412      2000 015424      2003 015425      2006 015430
   2007 015434      2009 015435      2011 015437      2013 015442      2015 015443      2016 015450      2017 015457
   2021 015460      2027 015461      2029 015462      2031 015472      2032 015475      2033 015500      2034 015527
   2035 015535      2036 015541      2037 015543      2038 015544      2040 015545      2046 015546      2052 015547
   2054 015550      2055 015553      2056 015554      2057 015555      2059 015556      2060 015573      2063 015574
   2070 015575      2075 015576      2076 015604      2077 015615      2078 015620      2079 015621      2080 015624
   2081 015627      2082 015656      2084 015663      2085 015670      2091 015763      2093 015765      2094 015770
   2258 015771      2260 015772      2262 015774      2264 016000      2265 016011      2266 016012      2267 016023
   2270 016030      2271 016036      2272 016041      2274 016052      2276 016053      2278 016054      2282 016055
   2284 016056      2286 016063      2288 016106      2288 016133      2290 016135      2293 016167      2296 016212
   2392 016213      2404 016224      2406 016225      2407 016236      2408 016242      2409 016244      2411 016246
   2415 016267      2416 016303      2417 016306      2418 016314      2422 016331      2426 016361      2430 016410
   2433 016416      2438 016417      2443 016433      2444 016437      2452 016442      2455 016450      2457 016453
   2458 016456      2460 016462      2461 016521      2463 016524      2464 016574      2466 016577      2467 016603
   2468 016621      2469 016644      2470 016645      2471 016650      2472 016720      2473 016723      2474 016727
   2475 016732      2477 016733      2479 016734      2480 016740      2481 016742      2482 016746      2485 016751
   2486 016762      2487 016777      2488 017002      2490 017006      2491 017033      2493 017036      2494 017052
   2501 017055      2496 017056      2497 017057      2498 017117      2507 017120      2519 017134      2520 017140
   2521 017141      2522 017143      2525 017165      2527 017176


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
