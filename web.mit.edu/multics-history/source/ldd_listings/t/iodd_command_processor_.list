	COMPILATION LISTING OF SEGMENT iodd_command_processor_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1337.1 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,^ifthendo */
       13 
       14 /* format: off */
       15 
       16 iodd_command_processor_: proc (source, state, command_line, ec);
       17 
       18 /* This procedure is called by an io_daemon driver when it's ready
       19*   to process an operator command.  The validity of a command will depend
       20*   on the source terminal and the state of the driver in processing requests.
       21*
       22*   state = 0 means that there are no active devices.
       23*   state = 1 means that we were called from iodd_listen_ with devices ready.
       24*   state = 2 means that we were called while processing another command (or??)
       25*   state = 3 means that we were called while processing a request (request command level).
       26*   state = 4 means that we were called after a quit.
       27*   state = 5 means that we were called from the signal handler (test mode)
       28**/
       29 
       30 
       31 /* Originally coded as input_cmd_ in August 1973 by Robert S. Coren */
       32 /* Modified and renamed in January 1975 by J. C. Whitmore for generalization and access isolation */
       33 /* Modified in Dec 1975 by J. C. Whitmore for new restart functions & control terminal hangup before detach */
       34 /* Modified in April 1976 by J. C. Whitmore to expand the dcl of ios_ mode variables to 256 */
       35 /* Modified in August 1977 by J. C. Whitmore to extend input "state" and add new ctl_term options */
       36 /* Modified in Nov 1977 by J. C. Whitmore to use iodd_msg_ and add new slave_term option */
       37 /* Modified in May 1978 by J. C. Whitmore to add the x command and minor bug fixes */
       38 /* Modified in July 1978 by J. C. Whitmore to add cmds: restart_q, auto_start_delay, defer, next, defer_time;
       39*   to change the coord communication strategy; and to extend the save and restart commands */
       40 /* Modified in August 1978 by J. C. Whitmore to add slave_term echo cmd and per device admin ec calls */
       41 /* Modified 10/78 by J. C. Whitmore: go bug fix and status attach type 4 */
       42 /* Modified 3/79 by J. C. Whitmore to support "-a" ctl arg to halt command */
       43 /* Modified 6/81 by E. N. Kittlitz for new condition_info structures */
       44 /* Modified January 1984 by C. Marker  Added probe as a legal command in test mode. */
       45 /* Modified February 23, 1985 by C. Marker to use version 5 message segments */
       46 
       47 
       48 /****^  HISTORY COMMENTS:
       49*  1) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       50*     audit(88-10-19,Wallman), install(88-10-28,MR12.2-1199):
       51*     Upgraded to version 5 iod tables.  Status command fixed to handle long
       52*     minor device names.
       53*                                                   END HISTORY COMMENTS */
       54 
       55 
       56 /* format: on */
       57 
       58 /*	ARGUMENTS	*/
       59 
       60 dcl  source fixed bin;
       61 dcl  state fixed bin;
       62 dcl  command_line char (*);
       63 dcl  ec fixed bin (35);
       64 
       65 
       66 /*	AUTOMATIC		*/
       67 
       68 dcl  att_desc char (64);
       69 dcl  code fixed bin (35);
       70 dcl  command char (256) aligned;			/* for the x command line to the command processor */
       71 dcl  change_data bit (1);				/* flag for ok to change info */
       72 dcl  dr_ptr ptr;
       73 dcl  desc_ptr ptr;
       74 dcl  ec_name char (32);
       75 dcl  segp ptr;
       76 dcl  lg_sw bit (1) aligned;				/* long option switch as needed */
       77 dcl  number fixed bin (35);
       78 dcl  msgp ptr;
       79 dcl  err_mess char (128);
       80 dcl  error_flag bit (1);
       81 dcl  message char (64);				/* general message string */
       82 dcl  what char (16);
       83 dcl  mode char (256);
       84 dcl  omode char (256);
       85 dcl  i fixed bin;
       86 dcl  idx fixed bin;
       87 dcl  len fixed bin;
       88 dcl  tried_once bit (1);
       89 dcl  person char (24);
       90 dcl  project char (24);
       91 dcl  restart_series fixed bin (35);
       92 dcl  seq_id fixed bin (35);
       93 dcl  series fixed bin (35);
       94 dcl  series_sw bit (1);
       95 dcl  device_id_length fixed bin;
       96 dcl  req_type_label_length fixed bin;
       97 
       98 dcl  io_stat bit (72) aligned;
       99 
      100 dcl  1 st aligned based (addr (io_stat)),
      101        2 code fixed bin (35),
      102        2 junk bit (36);
      103 
      104 dcl  1 arg_list aligned,				/* structure of parsed command line tokens */
      105        2 max_args fixed bin init (21),			/* the amount of storage we allocated */
      106        2 n fixed bin,
      107        2 cmd char (64) var,				/* first token is always the command */
      108        2 args (20) char (64) var;			/* up to 20 args per command */
      109 
      110 dcl  1 ev_chan_list aligned,				/* IPC event list for coord communication */
      111        2 number fixed bin,				/* number of channels in list (we use 2) */
      112        2 pad fixed bin,
      113        2 chan (2) fixed bin (71);
      114 
      115 dcl  1 event_info aligned,				/* info returned from ipc_$block */
      116        2 chan fixed bin (71),				/* channel wakeup came in on */
      117        2 msg fixed bin (71),				/* event message from sender */
      118        2 sender bit (36),				/* proc id of sender */
      119        2 origin fixed bin,				/* junk - ring, or device flag, or ? */
      120        2 wait_list_idx fixed bin;			/* index of chan in ev_chan_list */
      121 
      122 dcl  1 option aligned,				/* control option bits for next command */
      123        2 dev bit (1) unal,
      124        2 q bit (1) unal,
      125        2 user bit (1) unal,
      126        2 id bit (1) unal,
      127        2 et bit (1) unal,
      128        2 pn bit (1) unal;
      129 
      130 dcl  1 cond_info aligned like condition_info;
      131 
      132 /*	BASED VARIABLES	*/
      133 
      134 dcl  sys_dir char (168) aligned based;			/* string for the variable in iodd_'s static */
      135 dcl  floating float bin based;			/* for the convert builtin */
      136 dcl  fixed_bin fixed bin based;			/*   "  "  "  */
      137 dcl  fixed_bin_35 fixed bin (35) based;			/*   "  "  "  */
      138 
      139 
      140 /*	CONSTANTS		*/
      141 
      142 dcl  master fixed bin int static init (1) options (constant);
      143 						/* constant indicating the master device */
      144 dcl  slave fixed bin int static init (2) options (constant);/* constant indicating the slave device */
      145 dcl  both fixed bin int static init (0) options (constant); /* both the salve and master */
      146 dcl  normal fixed bin int static init (1) options (constant);
      147 dcl  whoami char (24) int static options (constant) init ("iodd_command_processor_");
      148 dcl  null_cmd_level fixed bin int static options (constant) init (0);
      149 						/* command level of state 0 */
      150 dcl  listen_cmd_level fixed bin int static options (constant) init (1);
      151 						/* command level of state 3 */
      152 dcl  quit_cmd_level fixed bin int static options (constant) init (4);
      153 						/* command level of state 4 */
      154 dcl  signal_cmd_level fixed bin int static options (constant) init (5);
      155 						/* command level of state 5 */
      156 dcl  null_stream char (32) int static options (constant) init ("iodd_null_stream");
      157 dcl  unknown_cmd_code fixed bin (35) int static options (constant) init (1239);
      158 dcl  bad_chars char (5) int static options (constant) init ("([]);");
      159 dcl  chn_type (4) char (8) int static options (constant) init ("iom ch", "tty ch", "dial id", "tty ch");
      160 
      161 
      162 /*	ENTRIES		*/
      163 
      164 dcl  continue_to_signal_ entry (fixed bin (35));
      165 dcl  convert_ipc_code_ entry (fixed bin (35));
      166 dcl  cu_$cp entry (ptr, fixed bin, fixed bin (35));
      167 dcl  debug entry;
      168 dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
      169 dcl  logout entry ();
      170 dcl  hcs_$initiate entry (char (*) aligned, char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      171 dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      172 dcl  iodd_msg_ entry options (variable);
      173 dcl  (
      174      ioa_,
      175      ioa_$rsnnl
      176      ) entry options (variable);
      177 dcl  ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
      178 dcl  ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*), bit (72) aligned);
      179 dcl  ios_$order entry (char (*) aligned, char (*), ptr, bit (72) aligned);
      180 dcl  ios_$changemode entry (char (*) aligned, char (*), char (*), bit (72) aligned);
      181 dcl  iox_$attach_ptr entry (ptr, char (*), ptr, fixed bin (35));
      182 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      183 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      184 dcl  iodd_parse_$command entry (char (*), ptr, fixed bin (35));
      185 dcl  iodc_$command_level entry ();
      186 dcl  message_segment_$add_file entry (char (*) aligned, char (*), ptr, fixed bin (24), bit (72) aligned, fixed bin (35));
      187 dcl  probe entry ();
      188 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
      189 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      190 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
      191 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
      192 
      193 /*	BUILTINS		*/
      194 
      195 dcl  (addr, fixed, index, divide, stac, convert, null, substr, before, after, string, mod, rtrim, length, search,
      196      currentsize, unspec, float, verify) builtin;
      197 
      198 
      199 /*	EXTERNAL  STATIC	*/
      200 
      201 dcl  error_table_$noarg fixed bin (35) ext static;
      202 dcl  error_table_$noentry fixed bin (35) ext static;
      203 dcl  error_table_$namedup fixed bin (35) ext static;
      204 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      205 dcl  error_table_$request_not_recognized fixed bin (35) ext static;
      206 
      207 dcl  iox_$user_output ptr ext;
      208 dcl  iox_$user_input ptr ext;
      209 dcl  iox_$error_output ptr ext;
      210 
      211 
      212 /*	CONDITIONS		*/
      213 
      214 dcl  (conversion, no_coord, re_init, daemon_logout, daemon_slave_logout, daemon_again, daemon_cancel, daemon_kill,
      215      daemon_new_device, daemon_again_slave, program_interrupt, daemon_defer, resume, size) condition;
      216 
      217 dcl  (any_other, cleanup, daemon_save) condition;
      218 
      219 /* include file no longer declares version 5 */
      220 
      221 dcl  cq_info_version_5 fixed bin int static init (5);
      222 
      223 dcl  coord_msg (50) fixed bin (71) aligned;		/* this is the last dcl to make indent happy */
      224 						/* must hold iodd_comm but PL/I will not allow */
      225 						/* us to set the size to the size (iodd_comm) */
      226 
      227 /*	START OF MAIN PROGRAM	*/
      228 
      229 
      230 	comm_ptr = addr (coord_msg);			/* get ready for special commands */
      231 
      232 	on conversion
      233 	     begin;
      234 	     call iodd_msg_ (normal, source, 0, "", "Argument conversion error. Try again.");
      235 	     go to ignore;
      236 	end;
      237 
      238 	on size
      239 	     begin;
      240 	     call iodd_msg_ (normal, source, 0, "", "Argument numerical size error. Try again.");
      241 	     go to ignore;
      242 	end;
      243 
      244 	call iodd_parse_$command (command_line, addr (arg_list), ec);
      245 						/* see what he said */
      246 	if ec ^= 0
      247 	then do;
      248 	     if ec = error_table_$noarg
      249 	     then do;				/* just a blank line */
      250 ignore:
      251 		ec = 0;				/* don't force a reset read */
      252 		return;
      253 	     end;
      254 	     err_mess = "Unable to parse command line.";
      255 error:
      256 	     call iodd_msg_ (normal, source, 0, "", "^a driver: ^a", iodd_static.major_device, err_mess);
      257 	     return;
      258 	end;
      259 
      260 /* Now the command and all the arguments are in the arg_list structure */
      261 
      262 /* find which command it is and branch to the correct label */
      263 
      264 
      265 	if cmd = "."
      266 	then go to ignore;				/* just ask for a command */
      267 
      268 /*  The full list of commands is getting long, so start on the next page */
      269 
      270 /* Here is the real list of commands for the standard driver */
      271 
      272 /* All commands must be accepted without the undersocre character for remote devices. */
      273 
      274 
      275 	if cmd = "auto_start_delay" | cmd = "autostartdelay"
      276 	then go to auto_start_delay_command;
      277 	if cmd = "cancel"
      278 	then go to cancel_command;
      279 	if cmd = "coord"
      280 	then go to coord_command;
      281 	if cmd = "ctl_term" | cmd = "ctlterm"
      282 	then go to ctl_term_command;
      283 	if cmd = "debug"
      284 	then go to debug_command;
      285 	if cmd = "defer"
      286 	then go to defer_command;
      287 	if cmd = "defer_time" | cmd = "defertime"
      288 	then go to defer_time_command;
      289 	if cmd = "go"
      290 	then go to go_command;
      291 	if cmd = "halt"
      292 	then go to halt_command;
      293 	if cmd = "help"
      294 	then go to help_command;
      295 	if cmd = "hold"
      296 	then go to hold_command;
      297 	if cmd = "inactive_limit" | cmd = "inactivelimit"
      298 	then go to inactive_limit_command;
      299 	if cmd = "kill"
      300 	then go to kill_command;
      301 	if cmd = "logout"
      302 	then go to logout_command;
      303 	if cmd = "master"
      304 	then go to master_command;
      305 	if cmd = "new_device" | cmd = "newdevice"
      306 	then go to new_device_command;
      307 	if cmd = "next"
      308 	then go to next_command;
      309 	if cmd = "pi"
      310 	then go to pi_command;
      311 	if cmd = "probe" | cmd = "pb"
      312 	then go to probe_command;
      313 	if cmd = "ready"
      314 	then go to ready_command;
      315 	if cmd = "reinit"
      316 	then go to reinit_command;
      317 	if cmd = "release" | cmd = "rl"
      318 	then go to release_command;
      319 	if cmd = "restart"
      320 	then go to restart_command;
      321 	if cmd = "restart_q" | cmd = "restartq"
      322 	then go to restart_q_command;
      323 	if cmd = "resume"
      324 	then go to resume_command;
      325 	if cmd = "return"
      326 	then go to return_command;
      327 	if cmd = "save"
      328 	then go to save_command;
      329 	if cmd = "slave"
      330 	then go to slave_command;
      331 	if cmd = "slave_term" | cmd = "slaveterm"
      332 	then go to slave_term_command;
      333 	if cmd = "start"
      334 	then go to start_command;
      335 	if cmd = "status"
      336 	then go to status_command;
      337 	if cmd = "step"
      338 	then go to step_command;
      339 	if cmd = "x"
      340 	then go to x_command;
      341 
      342 /*	The command is not implemented here.  See if the driver module wants it. */
      343 
      344 	ec = unknown_cmd_code;			/* set to an unlikely value in case driver module just returns */
      345 	err_mess = "Invalid command for driver - " || cmd;
      346 
      347 pass_on:
      348 	call iodd_static.driver_command (source, state, addr (arg_list), ec);
      349 
      350 	if ec = unknown_cmd_code
      351 	then go to error;				/* no one home...other errors were already reported */
      352 	if ec = 1 | ec = 2
      353 	then ec = 0;				/* driver module cannot force a continue */
      354 	return;					/* clean return for a valid driver_module command */
      355 
      356 /* **************************************************************************************** */
      357 
      358 /*	This is where the real work starts.  One label for each command.  */
      359 
      360 
      361 auto_start_delay_command:
      362 	if arg_list.n > 1
      363 	then do;					/* set the value */
      364 	     number = convert (fixed_bin, args (1));	/* make it fixed bin */
      365 	     if number < 30
      366 	     then do;				/* this is the lower limit */
      367 		call iodd_msg_ (normal, source, 0, "", "The lower limit for the delay time is 30 seconds.");
      368 		return;
      369 	     end;
      370 	     iodd_static.auto_start_delay = number;
      371 	end;
      372 
      373 	call iodd_msg_ (normal, source, 0, "", "The auto start delay is:  ^d seconds.", iodd_static.auto_start_delay);
      374 	return;
      375 
      376 
      377 cancel_command:
      378 	what = "cancel";				/* make next section common with the kill command */
      379 
      380 cancel_or_kill:
      381 	if source = slave
      382 	then if iodd_static.master_hold
      383 	     then do;
      384 		err_mess = "Driver in hold by master terminal.";
      385 		go to error;
      386 	     end;
      387 
      388 	if iodd_static.request_in_progress
      389 	then do;					/* can only kill or cancel active request */
      390 	     dr_ptr = iodd_static.driver_ptr;		/* find the current request number */
      391 	     desc_ptr = addr (dr_ptr -> driver_status.descriptor);
      392 	     desc_ptr -> request_descriptor.dont_delete = "1"b;
      393 						/* cancel any delete option, just in case */
      394 	     iodd_static.master_hold = "0"b;		/* already 0 if not the master */
      395 	     iodd_static.slave_hold = "0"b;		/* both MBZ for next command level */
      396 	     call iox_$control (iodd_static.master_in, "start", null, ec);
      397 						/* avoid lost wakeups */
      398 	     if iodd_static.slave.active
      399 	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
      400 	     if what = "cancel"
      401 	     then do;
      402 		desc_ptr -> request_descriptor.cancelled = "1"b;
      403 						/* mark the request */
      404 		signal daemon_cancel;		/* let the driver module clean out */
      405 	     end;
      406 	     else signal daemon_kill;			/* the other action */
      407 	     return;
      408 	end;
      409 
      410 	err_mess = "No current request to " || what;
      411 	go to error;
      412 
      413 
      414 coord_command:					/* for calling coord command level when testing */
      415 						/* coord and driver in one process */
      416 	if iodd_static.test_entry
      417 	then if source = master
      418 	     then do;				/* only the master can do this */
      419 
      420 		call iodc_$command_level ();		/* coord will do its own i/o */
      421 
      422 		call iox_$control (iodd_static.master_in, "start", null, ec);
      423 						/* just to be safe */
      424 
      425 		return;
      426 	     end;
      427 
      428 	err_mess = "The coord command is for master terminal test mode only.";
      429 	go to error;
      430 
      431 
      432 ctl_term_command:
      433 	if arg_list.n < 2
      434 	then do;					/* must be one arg to the command */
      435 	     err_mess = "Expected argument missing.";
      436 	     go to error;
      437 	end;
      438 
      439 	if ^iodd_static.ctl_term.attached
      440 	then do;					/* there must be one attached */
      441 	     err_mess = "Control terminal not attached.";
      442 	     go to error;
      443 	end;
      444 
      445 	if args (1) = "detach"
      446 	then do;					/* drop the thing forever */
      447 	     if source = master
      448 	     then do;				/* if the master says so */
      449 		call ios_$order (iodd_static.ctl_io, "hangup", null, io_stat);
      450 						/* give back to answering service */
      451 		if (iodd_static.slave_output = iodd_static.ctl_output) & iodd_static.slave.active
      452 		then do;
      453 		     iodd_static.slave.active = "0"b;	/* it was also the slave..drop it too */
      454 		     call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
      455 						/* don't forget this */
      456 		     call ios_$detach ("broadcast_errors", iodd_static.slave_output, "", io_stat);
      457 		     iodd_static.slave.allow_quits = "0"b;
      458 		     iodd_static.slave.print_errors = "0"b;
      459 		     iodd_static.slave.log_msg = "0"b;
      460 		     iodd_static.slave.accept_input = "0"b;
      461 		     iodd_static.slave_out = null;	/* cancel the iocb ptrs too */
      462 		     iodd_static.slave_in = null;
      463 		     iodd_static.slave_output = null_stream;
      464 		     iodd_static.slave_input = null_stream;
      465 		end;
      466 		call ios_$detach (iodd_static.ctl_io, "", "", io_stat);
      467 		call ios_$detach (iodd_static.ctl_output, "", "", io_stat);
      468 		call ios_$detach (iodd_static.ctl_input, "", "", io_stat);
      469 		iodd_static.ctl_term.attached = "0"b;
      470 		iodd_static.ctl_term.forms = "0"b;
      471 		iodd_static.ctl_output = null_stream;
      472 		iodd_static.ctl_input = null_stream;
      473 		iodd_static.ctl_io = null_stream;
      474 		return;
      475 	     end;					/* all cleared out now */
      476 	     err_mess = "Only the master terminal can detach the control terminal.";
      477 	     go to error;
      478 
      479 	end;
      480 
      481 	if args (1) = "simulate"
      482 	then do;					/* initiate terminal FF simulation */
      483 
      484 	     if ^iodd_static.forms
      485 	     then do;				/* be sure we are not already doing so */
      486 		iodd_static.ctl_term.ctl_dev_dim = "form_";
      487 						/* record the new dim name */
      488 		call ios_$attach (iodd_static.ctl_output, "form_", iodd_static.ctl_io, "", io_stat);
      489 						/* was using "syn" */
      490 		call ios_$attach (iodd_static.ctl_input, "form_", iodd_static.ctl_io, "", io_stat);
      491 		if st.code ^= 0
      492 		then do;				/* errors??? */
      493 		     ec = st.code;
      494 		     call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
      495 		     iodd_static.master_hold = "1"b;
      496 		     return;
      497 		end;
      498 
      499 		iodd_static.forms = "1"b;		/* this is the important part */
      500 
      501 		call iodd_msg_ (normal, source, 0, "", "Forms will have to be aligned.");
      502 
      503 		return;
      504 	     end;
      505 
      506 	     err_mess = "Already simulating forms.";	/* someone goofed */
      507 	     go to error;
      508 	end;
      509 
      510 	if args (1) = "aligned"
      511 	then do;
      512 
      513 	     if iodd_static.forms
      514 	     then do;				/* only when simulating */
      515 		call ios_$order (iodd_static.ctl_output, "form_aligned", null, io_stat);
      516 		if st.code ^= 0
      517 		then do;
      518 		     ec = st.code;
      519 		     call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
      520 		     iodd_static.master_hold = "1"b;
      521 		end;
      522 		return;
      523 	     end;
      524 
      525 	     err_mess = "Driver not simulating forms.";
      526 	     go to error;
      527 	end;
      528 
      529 /*	The remaining functions of this command require an additional argument */
      530 
      531 	if arg_list.n < 3
      532 	then do;					/* one check for all command keywords */
      533 	     err_mess = "Invalid ctl_term command request:" || substr (command_line, 9);
      534 	     go to error;
      535 	end;
      536 
      537 	if args (1) = "form_type" | args (1) = "formtype"
      538 	then do;
      539 
      540 	     if args (2) = "default"
      541 	     then do;				/* we can't really set the default here */
      542 		iodd_static.form_type = "undefined_form";
      543 						/* so do what we can and then... */
      544 		go to pass_on;			/* see if the driver_module wants to change it */
      545 	     end;
      546 
      547 	     if args (2) = "none"
      548 	     then iodd_static.form_type = "undefined";	/* special type to supress forms */
      549 	     else iodd_static.form_type = args (2);	/* gobble it up...we'll check it later */
      550 
      551 	     return;
      552 	end;
      553 
      554 	if args (1) = "modes"
      555 	then do;					/* change the modes of the output stream */
      556 
      557 	     mode = args (2);			/* copy them to fixed length string */
      558 	     omode = "not returned";			/* just to make the message clear */
      559 
      560 	     call ios_$changemode (iodd_static.ctl_output, mode, omode, io_stat);
      561 	     if st.code ^= 0
      562 	     then do;				/* OOPS */
      563 		ec = st.code;			/* report the error */
      564 		call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
      565 		iodd_static.master_hold = "1"b;
      566 	     end;
      567 
      568 	     call iodd_msg_ (normal, source, 0, "", "Mode was: ^a", omode);
      569 
      570 	     return;
      571 	end;
      572 
      573 	if args (1) = "page_length" | args (1) = "pagelength"
      574 	then do;
      575 	     if ^iodd_static.forms
      576 	     then do;				/* must be simulating paging */
      577 		err_mess = "Driver not simulating forms.";
      578 		go to error;
      579 	     end;
      580 
      581 	     i = convert (fixed_bin, args (2));
      582 
      583 	     call ios_$order (iodd_static.ctl_output, "page_length", addr (i), io_stat);
      584 	     if st.code ^= 0
      585 	     then do;
      586 		ec = st.code;
      587 		call iodd_msg_ (normal, both, ec, whoami, "Driver goes into master hold.");
      588 		iodd_static.master_hold = "1"b;
      589 	     end;
      590 
      591 	     return;
      592 	end;
      593 
      594 	err_mess = "Undefined ctl_term request:" || substr (command_line, 9);
      595 	go to error;
      596 
      597 
      598 debug_command:
      599 	if source = master
      600 	then if iodd_static.test_entry
      601 	     then do;
      602 
      603 		call iodd_msg_ (normal, master, 0, "", "Calling debug");
      604 						/* give reassuring message */
      605 		call debug ();
      606 		return;
      607 	     end;
      608 
      609 	err_mess = "The debug command is for master terminal test mode only.";
      610 	go to error;
      611 
      612 
      613 defer_command:
      614 	if iodd_static.request_in_progress
      615 	then do;
      616 	     desc_ptr = addr (iodd_static.driver_ptr -> driver_status.descriptor);
      617 	     if desc_ptr -> request_descriptor.restarted
      618 	     then do;
      619 
      620 		err_mess = "Request was restarted and is no longer in the queue. Use ""save"".";
      621 		go to error;
      622 	     end;
      623 	     if source = slave
      624 	     then if iodd_static.master_hold
      625 		then do;				/* don't interrupt the master */
      626 		     err_mess = "Driver in hold by master terminal.";
      627 		     go to error;
      628 		end;
      629 	     desc_ptr -> request_descriptor.finished = "1"b;
      630 	     desc_ptr -> request_descriptor.keep_in_queue = "1"b;
      631 	     call iox_$control (iodd_static.master_in, "start", null, ec);
      632 						/* avoid lost wakeups */
      633 	     if iodd_static.slave.active
      634 	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
      635 	     signal daemon_defer;			/* tell the driver module (or subr ) */
      636 	     return;
      637 	end;
      638 	err_mess = "No current request to defer.";
      639 	go to error;
      640 
      641 
      642 defer_time_command:
      643 	if arg_list.n = 1
      644 	then do;					/* command and no args */
      645 	     if iodd_static.assigned_devices > 1
      646 	     then do;				/* ambiguous */
      647 		err_mess = "Multiple minor devices require a second argument - dev.";
      648 		go to error;
      649 	     end;
      650 	     change_data = "0"b;			/* can only give current values */
      651 	     dr_ptr = iodd_static.driver_ptr;		/* only one driver status seg */
      652 	end;
      653 	else if arg_list.n = 2
      654 	then do;					/* one arg case dev or number */
      655 	     if iodd_static.assigned_devices = 1 & verify (args (1), "1234567890.") = 0
      656 	     then change_data = "1"b;			/* looks like a real number and its legal */
      657 	     else change_data = "0"b;			/* must be a device id */
      658 
      659 	     if ^change_data
      660 	     then do;
      661 		call find_minor_dev (args (1), dr_ptr, code);
      662 		if code ^= 0
      663 		then go to error;
      664 	     end;
      665 	     else do;
      666 		what = args (1);			/* store the value to be converted */
      667 		dr_ptr = iodd_static.driver_ptr;	/* must be current driver status seg */
      668 	     end;
      669 	end;
      670 	else do;					/* 3 args case (don't look at any more) */
      671 	     call find_minor_dev (args (1), dr_ptr, code);
      672 	     if code ^= 0
      673 	     then go to error;
      674 	     change_data = "1"b;			/* there must be a time value */
      675 	     what = args (2);			/* in the second argument */
      676 	end;
      677 
      678 	if ^change_data
      679 	then do;					/* no data, just print current values */
      680 	     if dr_ptr -> driver_status.defer_time_limit = 0
      681 	     then message = "No auto defer time limit has been set.";
      682 	     else call ioa_$rsnnl ("Auto defer time limit:  ^.1f minutes", message, i,
      683 		     float (dr_ptr -> driver_status.defer_time_limit) / 60.0e0);
      684 
      685 	     number = dr_ptr -> driver_status.bit_rate_est;
      686 						/* get the xfr rate */
      687 
      688 	     call iodd_msg_ (normal, source, 0, "",
      689 		"^a^/Current transfer rate:  ^[^d bits/sec (^d chars/sec)^;undefined^s^s^]", message, (number > 0),
      690 		number, divide (number, 9, 17));
      691 	     return;				/* and we're done */
      692 	end;
      693 
      694 	number = fixed (convert (floating, what) * 60);	/* input is in minutes, store as seconds */
      695 	if number < 10
      696 	then number = 0;
      697 	dr_ptr -> driver_status.defer_time_limit = number;
      698 
      699 	call iodd_msg_ (normal, source, 0, "", "Changing auto defer time limit to:  ^[^.1f minutes^;no limit^s^]",
      700 	     (number > 0), float (number) / 60.0e0);
      701 
      702 	return;
      703 
      704 
      705 go_command:					/* start processing requests */
      706 	if state > listen_cmd_level
      707 	then do;
      708 	     err_mess = "The go command is not valid at this command level.";
      709 	     go to error;
      710 	end;
      711 
      712 	if state = null_cmd_level & ^iodd_static.runout_requests
      713 	then do;
      714 	     err_mess = "No ready device.";
      715 	     go to error;
      716 	end;
      717 
      718 	if source = slave & iodd_static.master_hold
      719 	then do;
      720 	     err_mess = "Driver in hold by master terminal.";
      721 	     go to error;
      722 	end;
      723 
      724 	if arg_list.n = 1
      725 	then iodd_static.requests_til_cmd = 0;
      726 	else do;					/* operator wants to go for N requests */
      727 	     if iodd_static.step
      728 	     then do;
      729 		err_mess = "The go command cannot recognize a number while in step mode.";
      730 		go to error;
      731 	     end;
      732 	     i = convert (fixed_bin, args (1));		/* get the N as fixed bin */
      733 	     if i < 1
      734 	     then do;				/* a real value? */
      735 		err_mess = "Invalid number of requests specified: " || args (1);
      736 		go to error;
      737 	     end;
      738 
      739 	     iodd_static.requests_til_cmd = i;		/* OK, use the new value */
      740 	end;
      741 
      742 	iodd_static.master_hold = "0"b;
      743 	iodd_static.slave_hold = "0"b;
      744 	ec = 1;					/* give the "go" code */
      745 	return;					/* let 'er rip */
      746 
      747 
      748 halt_command:
      749 	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */
      750 
      751 	if arg_list.n < 2
      752 	then do;					/* no arguments */
      753 	     if iodd_static.assigned_devices = 1
      754 	     then call halt_all;			/* only legal for the one device case */
      755 	     else do;				/* give error msg */
      756 		err_mess = "Multiple minor devices require an argument.";
      757 		go to error;
      758 	     end;
      759 	end;
      760 
      761 	else do;					/* there were args ... check them */
      762 	     if args (1) = "-all" | args (1) = "-a"
      763 	     then call halt_all;			/* ctl arg must be first arg */
      764 	     else do i = 1 to arg_list.n - 1;		/* only devices given ... search for them */
      765 
      766 		call find_minor_dev (args (i), dr_ptr, code);
      767 		if code = 0
      768 		then do;
      769 		     if dr_ptr -> driver_status.ready
      770 		     then iodd_static.current_devices = iodd_static.current_devices - 1;
      771 						/* reduce count */
      772 		     dr_ptr -> driver_status.ready = "0"b;
      773 						/* turn off the ready flag to stop driver */
      774 		     if ^stac (addr (dr_ptr -> driver_status.request_pending), iodd_static.driver_proc_id)
      775 		     then if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
      776 			then do;
      777 			     call iodd_msg_ (normal, source, 0, "", "Pending request for device ""^a""", args (i));
      778 			     iodd_static.runout_requests = "1"b;
      779 			end;
      780 		end;
      781 		else call iodd_msg_ (normal, source, 0, "", "Minor device ""^a"" not assigned.", args (i));
      782 	     end;					/* look for next device arg */
      783 	end;
      784 
      785 	if iodd_static.runout_requests
      786 	then do;					/* there was a pending request */
      787 	     call iodd_msg_ (normal, source, 0, "", "Pending requests for halted devices will be processed.");
      788 	     if state <= listen_cmd_level
      789 	     then do;				/* avoid resetting after a quit */
      790 		if source = master
      791 		then iodd_static.master_hold = "0"b;	/* can we go? */
      792 		if iodd_static.master_hold
      793 		then do;
      794 		     err_mess = "Driver in hold by master terminal.";
      795 		     go to error;
      796 		end;
      797 		iodd_static.slave_hold = "0"b;	/* don't come back for another command until done */
      798 		ec = 1;				/* do an automatic "go" from normal command level */
      799 		return;
      800 	     end;
      801 	     return;
      802 	end;
      803 
      804 	if iodd_static.current_devices = 0
      805 	then do;					/* nothing to run */
      806 	     err_mess = "All devices are halted.";
      807 	     go to error;
      808 	end;
      809 	return;
      810 
      811 
      812 help_command:					/*	Put in a 1 line syntax description for each legal command */
      813 	call iodd_msg_ (normal, source, 0, "", "^/** Standard Driver Commands **^/");
      814 						/* title */
      815 
      816 	call iodd_msg_ (normal, source, 0, "", "auto_start_delay [seconds]");
      817 	call iodd_msg_ (normal, source, 0, "", "cancel");
      818 	call iodd_msg_ (normal, source, 0, "", "ctl_term   <function>  [<function_value>]");
      819 	call iodd_msg_ (normal, source, 0, "", "defer");
      820 	call iodd_msg_ (normal, source, 0, "", "defer_time [dev] [mins]");
      821 	call iodd_msg_ (normal, source, 0, "", "go [N]");
      822 	call iodd_msg_ (normal, source, 0, "", "halt    (<dev1>...<devn>) | (-a|-all)");
      823 	call iodd_msg_ (normal, source, 0, "", "hold");
      824 	call iodd_msg_ (normal, source, 0, "", "inactive_limit [<minutes>]");
      825 	call iodd_msg_ (normal, source, 0, "", "kill");
      826 	call iodd_msg_ (normal, source, 0, "", "logout");
      827 	call iodd_msg_ (normal, source, 0, "", "master  <message for master terminal>");
      828 	call iodd_msg_ (normal, source, 0, "", "new_device");
      829 	call iodd_msg_ (normal, source, 0, "", "next -user <pers.proj> -id ID -pn <path> -et <entry> -dev <dev>");
      830 	call iodd_msg_ (normal, source, 0, "", "ready   (<dev1>...<devn>) | (-a|-all)");
      831 	call iodd_msg_ (normal, source, 0, "", "reinit");
      832 	call iodd_msg_ (normal, source, 0, "", "release | rl");
      833 	call iodd_msg_ (normal, source, 0, "", "restart [<request_no> | -from <request_no>]");
      834 	call iodd_msg_ (normal, source, 0, "", "restart_q [<minor_dev>]");
      835 	call iodd_msg_ (normal, source, 0, "", "save    [<request_no> | -from <request_no>]");
      836 	call iodd_msg_ (normal, source, 0, "", "slave   <message for slave terminal>");
      837 	call iodd_msg_ (normal, source, 0, "", "slave_term <function>");
      838 	call iodd_msg_ (normal, source, 0, "", "start");
      839 	call iodd_msg_ (normal, source, 0, "", "status [-lg]");
      840 	call iodd_msg_ (normal, source, 0, "", "step    [set|reset]");
      841 	call iodd_msg_ (normal, source, 0, "", "x <site defined key> [<args>]");
      842 
      843 	if iodd_static.test_entry
      844 	then do;					/* only give the test commands in test mode */
      845 	     call iodd_msg_ (normal, source, 0, "", "^/** Test Mode Commands **^/");
      846 	     call iodd_msg_ (normal, source, 0, "", "coord");
      847 	     call iodd_msg_ (normal, source, 0, "", "debug");
      848 	     call iodd_msg_ (normal, source, 0, "", "probe");
      849 	     call iodd_msg_ (normal, source, 0, "", "pi");
      850 	     call iodd_msg_ (normal, source, 0, "", "resume");
      851 	     call iodd_msg_ (normal, source, 0, "", "return");
      852 	end;
      853 
      854 	call driver_command (source, state, addr (arg_list), ec);
      855 
      856 	call iodd_msg_ (normal, source, 0, "", "");	/* separate from command request */
      857 	return;
      858 
      859 
      860 hold_command:
      861 	if source = slave
      862 	then iodd_static.slave_hold = "1"b;		/* master hold will override */
      863 	if source = master
      864 	then iodd_static.master_hold = "1"b;
      865 	return;
      866 
      867 
      868 inactive_limit_command:
      869 	if arg_list.n > 1
      870 	then do;					/* new limit data? */
      871 	     number = convert (fixed_bin, args (1));	/* get the value as fixed bin */
      872 	     if number < 0 | number > 200
      873 	     then do;
      874 		err_mess = "Unreasonable inactivity time limit value: " || args (1) || " minutes";
      875 		go to error;
      876 	     end;
      877 
      878 	     if number > 0
      879 	     then do;				/* if not reseting, must be long enough for coord response */
      880 		i = divide (2 * iodd_static.wakeup_time + 59, 60, 17);
      881 						/* minutes for at least 2 wakeup intervals */
      882 		if number < i
      883 		then do;
      884 		     call iodd_msg_ (normal, source, 0, "",
      885 			"The minimum inactivity time limit for this driver is ^d minute^[s^], or zero to reset.", i,
      886 			i > 1);
      887 		     return;
      888 		end;
      889 	     end;
      890 
      891 	     iodd_static.auto_logout_interval = number * 60;
      892 						/* store as seconds for timer_manager_ */
      893 	end;
      894 
      895 	number = divide (iodd_static.auto_logout_interval, 60, 17);
      896 						/* get current value as minutes */
      897 
      898 	if number = 0
      899 	then call iodd_msg_ (normal, source, 0, "", "Driver will not logout for inactivity.");
      900 	else call iodd_msg_ (normal, source, 0, "",
      901 		"Driver will automatically logout after ^d minute^[s^] of inactivity.", number, number > 1);
      902 
      903 	return;
      904 
      905 
      906 kill_command:
      907 	what = "kill";				/* ready to make use of common code with cancel */
      908 
      909 	go to cancel_or_kill;			/* see the cancel command */
      910 
      911 
      912 logout_command:
      913 	if source = master
      914 	then iodd_static.master_hold = "0"b;
      915 
      916 	if iodd_static.master_hold
      917 	then do;
      918 	     err_mess = "Cannot logout while driver in hold by master terminal.";
      919 	     go to error;
      920 	end;
      921 
      922 	if arg_list.n > 1
      923 	then if arg_list.args (1) ^= "-force"
      924 	     then do;				/* recognize the obsolete arg */
      925 		err_mess = "Invalid argument to logout command:  " || arg_list.args (1);
      926 		go to error;
      927 	     end;
      928 
      929 	if source = slave
      930 	then call iodd_msg_ (normal, master, 0, "", "Driver logout received from slave.");
      931 	if iodd_static.slave.active
      932 	then do;
      933 	     call iodd_msg_ (normal, slave, 0, "", "^/Driver is logging out.^/");
      934 	     call iox_$control (iodd_static.slave_out, "runout", null, ec);
      935 	end;
      936 
      937 	if (source = slave) & ^iodd_static.ctl_term.attached
      938 						/* use special signal for remote slave */
      939 	then signal daemon_slave_logout;		/* in case the driver module wants it */
      940 	signal daemon_logout;			/* normal logout for the master or control terminal */
      941 	return;					/* just to be tidy */
      942 
      943 
      944 master_command:					/* slave wants to send master a message */
      945 	if source = slave
      946 	then do;
      947 	     call iodd_msg_ (normal, master, 0, "From slave", substr (command_line, index (command_line, "master") + 6))
      948 		;
      949 	     return;
      950 	end;
      951 	call iodd_msg_ (normal, master, 0, "", "Invalid command for master terminal.");
      952 						/* master talking to itself?? */
      953 	return;
      954 
      955 
      956 new_device_command:
      957 	if source ^= master
      958 	then do;					/* this one is restricted to the master */
      959 	     err_mess = "The new_device command is valid from the master terminal only.";
      960 	     go to error;
      961 	end;
      962 
      963 	if iodd_static.slave.active
      964 	then call iodd_msg_ (normal, slave, 0, "", "^/Driver process changing to new device.^/");
      965 
      966 	signal daemon_new_device;			/* if halt ran to completion, we are all set */
      967 						/* if operator "QUIT" let it pass any way */
      968 	return;
      969 
      970 next_command:
      971 	if iodd_static.assigned_devices = 1
      972 	then number = 4;
      973 	else number = 6;
      974 
      975 	if arg_list.n < number + 1
      976 	then do;
      977 	     call ioa_$rsnnl ("Too few args. Specify -user <user> [-entry, -path or -id] <name> ^[-dev <minor_dev>^]",
      978 		err_mess, len, (number = 6));
      979 	     go to error;
      980 	end;
      981 
      982 	if mod (arg_list.n, 2) = 0
      983 	then do;					/* must have command plus even number of args */
      984 	     err_mess = "Arguments must be given in pairs.";
      985 	     go to error;
      986 	end;
      987 
      988 	error_flag = ""b;
      989 	string (option) = ""b;			/* clear the given option flags */
      990 	coord_msg (*) = 0;				/* clear the message */
      991 	iodd_comm.req_id = "";			/* set the char string which is optional */
      992 
      993 	do idx = 1 to arg_list.n - 1 by 2;		/* go through the args */
      994 
      995 	     if args (idx) = "-queue" | args (idx) = "-q"
      996 	     then do;				/* OPTION = -queue */
      997 		if option.q
      998 		then do;
      999 		     error_flag = "1"b;
     1000 		     call iodd_msg_ (normal, source, 0, "", "The -queue control argument can only be given once.");
     1001 		end;
     1002 		else do;
     1003 		     option.q = "1"b;		/* mark it as given */
     1004 		     if substr (args (idx + 1), 1, 1) = "-"
     1005 		     then go to bad_order;		/* was it an option? */
     1006 		     iodd_comm.queue_no = convert (fixed_bin, args (idx + 1));
     1007 		     if iodd_comm.queue_no < 1 | iodd_comm.queue_no > 4
     1008 		     then do;
     1009 			error_flag = "1"b;
     1010 			call iodd_msg_ (normal, source, 0, "", "Invalid queue number - ^a", args (idx + 1));
     1011 		     end;
     1012 		end;
     1013 	     end;
     1014 	     else if args (idx) = "-entry" | args (idx) = "-et"
     1015 	     then do;				/* OPTION = -entry */
     1016 		if option.pn
     1017 		then do;
     1018 		     error_flag = "1"b;
     1019 		     call iodd_msg_ (normal, source, 0, "", "The -entry and -path control args are incomaptible.");
     1020 		end;
     1021 		else if option.et
     1022 		then do;
     1023 		     error_flag = "1"b;
     1024 		     call iodd_msg_ (normal, source, 0, "", "The -entry control argument can only be given once.");
     1025 		end;
     1026 		else do;				/* OK to use it */
     1027 		     option.et = "1"b;		/* mark it */
     1028 		     if substr (args (idx + 1), 1, 1) = "-"
     1029 		     then go to bad_order;		/* was it an option? */
     1030 		     iodd_comm.data_len = length (args (idx + 1));
     1031 		     iodd_comm.data = args (idx + 1);
     1032 		end;
     1033 	     end;
     1034 	     else if args (idx) = "-path" | args (idx) = "-pn"
     1035 	     then do;				/* OPTION = -path */
     1036 		if option.et
     1037 		then do;
     1038 		     error_flag = "1"b;
     1039 		     call iodd_msg_ (normal, source, 0, "", "The -path and -entry control args are incompatible.");
     1040 		end;
     1041 		else if option.pn
     1042 		then do;
     1043 		     error_flag = "1"b;
     1044 		     call iodd_msg_ (normal, source, 0, "", "The -path control argument can only be given once.");
     1045 		end;
     1046 		else do;				/* OK to use it */
     1047 		     option.pn = "1"b;		/* mark it */
     1048 		     if substr (args (idx + 1), 1, 1) = "-"
     1049 		     then go to bad_order;		/* was it an option? */
     1050 		     iodd_comm.data_len = length (args (idx + 1));
     1051 		     iodd_comm.data = args (idx + 1);
     1052 		     if substr (args (idx + 1), 1, 1) ^= ">"
     1053 		     then do;
     1054 			error_flag = "1"b;
     1055 			call iodd_msg_ (normal, source, 0, "", "Full pathname must be given: ^a", args (idx + 1));
     1056 		     end;
     1057 		end;
     1058 	     end;
     1059 	     else if args (idx) = "-id"
     1060 	     then do;				/* OPTION = -id */
     1061 		if option.id
     1062 		then do;
     1063 		     error_flag = "1"b;
     1064 		     call iodd_msg_ (normal, source, 0, "", "The -id control argument can only be given once.");
     1065 		end;
     1066 		else do;				/* OK to use it */
     1067 		     option.id = "1"b;		/* mark it as used */
     1068 		     if substr (args (idx + 1), 1, 1) = "-"
     1069 		     then go to bad_order;		/* was it an option? */
     1070 		     iodd_comm.req_id = args (idx + 1);
     1071 		     if verify (iodd_comm.req_id, "0123456789. ") > 0
     1072 		     then do;
     1073 			error_flag = "1"b;
     1074 			call iodd_msg_ (normal, source, 0, "", "Invalid request id: ^a", iodd_comm.req_id);
     1075 		     end;
     1076 		end;
     1077 	     end;
     1078 	     else if args (idx) = "-user"
     1079 	     then do;				/* OPTION = -user */
     1080 		if option.user
     1081 		then do;
     1082 		     error_flag = "1"b;
     1083 		     call iodd_msg_ (normal, source, 0, "", "The -user control argument can only be given once.");
     1084 		end;
     1085 		else do;				/* OK record the user name */
     1086 		     option.user = "1"b;
     1087 		     if substr (args (idx + 1), 1, 1) = "-"
     1088 		     then go to bad_order;		/* was it an option? */
     1089 		     person = before (args (idx + 1), ".");
     1090 		     project = before (after (args (idx + 1), "."), ".");
     1091 						/* in case the tag was given */
     1092 		     if person = "" | project = ""
     1093 		     then do;			/* not nice */
     1094 			error_flag = "1"b;
     1095 			call iodd_msg_ (normal, source, 0, "", "The full person and project names must be given.");
     1096 		     end;
     1097 		     iodd_comm.user_id = rtrim (person) || "." || project;
     1098 		end;
     1099 	     end;
     1100 	     else if args (idx) = "-device" | args (idx) = "-dev"
     1101 	     then do;				/* OPTION = -device */
     1102 		if option.dev
     1103 		then do;
     1104 		     error_flag = "1"b;
     1105 		     call iodd_msg_ (normal, source, 0, "", "The -device control argument can only be given once.");
     1106 		end;
     1107 		else do;
     1108 		     option.dev = "1"b;
     1109 		     if substr (args (idx + 1), 1, 1) = "-"
     1110 		     then go to bad_order;		/* was it an option? */
     1111 		     call find_minor_dev (args (idx + 1), dr_ptr, code);
     1112 		     if code ^= 0
     1113 		     then do;
     1114 			error_flag = "1"b;
     1115 			call iodd_msg_ (normal, source, 0, "", err_mess);
     1116 		     end;
     1117 		     else iodd_comm.minor_idx = dr_ptr -> driver_status.dev_index;
     1118 		end;
     1119 	     end;
     1120 	     else do;				/* OPTION = Not Defined Here */
     1121 		if substr (args (idx), 1, 1) = "-"
     1122 		then call iodd_msg_ (normal, source, 0, "", "Undefined control argument ^d", args (idx));
     1123 		else do;
     1124 bad_order:
     1125 		     call iodd_msg_ (normal, source, 0, "", "Arguments missing or out of sequence at: ^a", args (idx))
     1126 			;
     1127 		end;
     1128 		error_flag = "1"b;
     1129 		idx = idx - 1;			/* try to get back in sync */
     1130 	     end;
     1131 	end;
     1132 
     1133 	if error_flag
     1134 	then return;				/* that's all */
     1135 
     1136 	if ^option.dev
     1137 	then do;
     1138 	     if iodd_static.assigned_devices > 1
     1139 	     then do;
     1140 		err_mess = "For multiple minor devices, the -device control argument must be given.";
     1141 		go to error;
     1142 	     end;
     1143 	     option.dev = "1"b;			/* single device, we will assume it */
     1144 	     iodd_comm.minor_idx = iodd_static.driver_ptr -> driver_status.dev_index;
     1145 	end;
     1146 
     1147 	error_flag = ^option.user | ^(option.et | option.pn | option.id);
     1148 
     1149 	if error_flag
     1150 	then do;
     1151 	     err_mess = "Minimum args required are user and some request identifier.";
     1152 	     go to error;
     1153 	end;
     1154 
     1155 /*	we should have a good request now */
     1156 
     1157 	iodd_comm.type = next_req;			/* finish off the data */
     1158 	iodd_comm.type_ext = string (option);		/* show the given options to coord */
     1159 
     1160 	err_mess = "";
     1161 	call send_coord_msg (code, number);
     1162 	if code ^= 0
     1163 	then call iodd_msg_ (normal, source, code, "", err_mess);
     1164 	else call iodd_msg_ (normal, source, 0, "", "Request found.");
     1165 
     1166 	return;
     1167 
     1168 
     1169 probe_command:
     1170 	if source = master
     1171 	then if iodd_static.test_entry
     1172 	     then do;
     1173 
     1174 		call iodd_msg_ (normal, master, 0, "", "Calling probe");
     1175 						/* give reassuring message */
     1176 		call probe ();
     1177 		return;
     1178 	     end;
     1179 
     1180 	err_mess = "The probe command is for master terminal test mode only.";
     1181 	go to error;
     1182 
     1183 pi_command:
     1184 	if iodd_static.test_entry
     1185 	then if source = master
     1186 	     then do;				/* very restricted */
     1187 
     1188 		call iox_$control (iodd_static.master_in, "start", null, ec);
     1189 						/* play safe */
     1190 		signal program_interrupt;		/* back to debug .. we hope */
     1191 
     1192 		return;
     1193 	     end;
     1194 
     1195 	err_mess = "The pi command is only valid from the master terminal in test mode.";
     1196 
     1197 	go to error;
     1198 
     1199 
     1200 ready_command:					/* put the devices in the ready state */
     1201 	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */
     1202 
     1203 	if arg_list.n < 2
     1204 	then do;					/* no arguments */
     1205 	     if iodd_static.assigned_devices = 1
     1206 	     then call ready_all;			/* only legal for the one device case */
     1207 	     else do;				/* give error msg */
     1208 		err_mess = "Multiple minor devices require an argument.";
     1209 		go to error;
     1210 	     end;
     1211 	end;
     1212 	else do;					/* there were args ... check them */
     1213 	     do i = 1 to arg_list.n - 1;		/* if we find "-all" we are done */
     1214 		if args (i) = "-a" | args (i) = "-all"
     1215 		then do;
     1216 		     call ready_all;
     1217 		     return;			/* that's all there is to it */
     1218 		end;
     1219 	     end;
     1220 	     do i = 1 to arg_list.n - 1;		/* only devices given ... search for them */
     1221 
     1222 		call find_minor_dev (args (i), dr_ptr, code);
     1223 		if code = 0
     1224 		then do;
     1225 		     if dr_ptr -> driver_status.attached
     1226 		     then do;			/* can only ready attached devices */
     1227 			if ^dr_ptr -> driver_status.ready
     1228 			then do;
     1229 			     iodd_static.current_devices = iodd_static.current_devices + 1;
     1230 						/* increase count */
     1231 			     dr_ptr -> driver_status.ready = "1"b;
     1232 						/* turn on the ready flag to ready driver */
     1233 			end;
     1234 			if dr_ptr -> driver_status.request_pending
     1235 			then			/* check for driver pid */
     1236 			     if dr_ptr -> driver_status.request_pending ^= iodd_static.coord_proc_id
     1237 			     then dr_ptr -> driver_status.request_pending = (36)"0"b;
     1238 		     end;
     1239 		     else do;			/* not attached, check the count */
     1240 			if dr_ptr -> driver_status.ready
     1241 			then current_devices = current_devices - 1;
     1242 			dr_ptr -> driver_status.ready = "0"b;
     1243 						/* be sure it is not ready */
     1244 			call iodd_msg_ (normal, source, 0, "", "Device ""^a"" is not attached.", args (i));
     1245 		     end;
     1246 		end;
     1247 		else call iodd_msg_ (normal, source, 0, "", "Minor device ""^a"" not assigned.", args (i));
     1248 	     end;					/* look for next device arg */
     1249 	end;
     1250 	return;
     1251 
     1252 
     1253 reinit_command:					/* this will force the driver to re-initialize */
     1254 	if source = master
     1255 	then iodd_static.master_hold = "0"b;		/* always go for master */
     1256 	if iodd_static.master_hold
     1257 	then do;					/* protect the master */
     1258 	     err_mess = "Driver in hold by master terminal.";
     1259 	     go to error;
     1260 	end;
     1261 
     1262 	signal re_init;				/* OK, here we go! */
     1263 
     1264 	return;
     1265 
     1266 
     1267 release_command:
     1268 	if (state < signal_cmd_level) | (source = master)
     1269 	then do;
     1270 	     if source = master
     1271 	     then iodd_static.master_hold = "0"b;
     1272 	     if iodd_static.master_hold
     1273 	     then do;				/* don't interrupt the master */
     1274 		err_mess = "Driver in hold by master terminal.";
     1275 		go to error;
     1276 	     end;
     1277 	     if iodd_static.request_in_progress
     1278 	     then call iodd_msg_ (normal, source, 0, "", "Warning - Request in progress will be run again.");
     1279 	     iodd_static.driver_ptr -> driver_status.busy = "0"b;
     1280 						/* don't throw away a pending request */
     1281 	     iodd_static.slave_hold = "1"b;		/* force a command at normal level */
     1282 	     call iox_$control (iodd_static.master_in, "start", null, ec);
     1283 						/* avoid lost wakeups */
     1284 	     if iodd_static.slave.active
     1285 	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
     1286 	     signal resume;				/* go back to iodd_listen_ */
     1287 	     iodd_static.master_hold = "1"b;		/* OOPS, trouble. */
     1288 	     return;
     1289 	end;
     1290 	err_mess = "The release command is only valid from the master terminal at this command level.";
     1291 	go to error;
     1292 
     1293 
     1294 restart_command:
     1295 	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */
     1296 
     1297 	if source = slave
     1298 	then if iodd_static.master_hold
     1299 	     then do;				/* can't override the master */
     1300 		err_mess = "Command not valid while process is in hold by master terminal.";
     1301 		go to error;
     1302 	     end;
     1303 
     1304 	if arg_list.n = 1
     1305 	then do;					/* no sequence number given */
     1306 	     if (state > listen_cmd_level) & iodd_static.request_in_progress
     1307 	     then do;
     1308 		iodd_static.master_hold = "0"b;	/* this must be the master or value is already 0 */
     1309 		iodd_static.slave_hold = "0"b;	/* be sure they are off for next command level */
     1310 		call iox_$control (iodd_static.master_in, "start", null, ec);
     1311 						/* avoid lost wakeups */
     1312 		if iodd_static.slave.active
     1313 		then call iox_$control (iodd_static.slave_in, "start", null, ec);
     1314 		if source = master
     1315 		then signal daemon_again;		/* say it was the master */
     1316 		else signal daemon_again_slave;	/* otherwise it was the slave */
     1317 	     end;
     1318 	     else do;
     1319 		err_mess = "No current request to restart.";
     1320 		go to error;
     1321 	     end;
     1322 	     return;
     1323 	end;
     1324 
     1325 	iodd_comm.type = restart;			/* mark the type so following can be used for save */
     1326 
     1327 restart_or_save:
     1328 	if args (1) = "-from"
     1329 	then do;					/* this is a series request */
     1330 	     series_sw = "1"b;
     1331 	     seq_id = convert (fixed_bin_35, args (2));
     1332 	end;
     1333 	else do;					/* a single request */
     1334 	     seq_id = convert (fixed_bin_35, args (1));
     1335 	     series_sw = "0"b;
     1336 	end;
     1337 
     1338 	iodd_comm.data_len = 0;			/* construct the command for the coord */
     1339 	iodd_comm.queue_no = 0;
     1340 	iodd_comm.user_id = "";			/* don't care, but initialize */
     1341 	iodd_comm.req_id = "";
     1342 	dr_ptr = iodd_static.driver_ptr;		/* need any minor device index, use current */
     1343 	iodd_comm.minor_idx = dr_ptr -> driver_status.dev_index;
     1344 						/* say who we are */
     1345 	iodd_comm.dvc_idx = dr_ptr -> driver_status.maj_index;
     1346 	iodd_comm.request_no = seq_id;		/* pass on the request number */
     1347 	iodd_comm.type_ext = series_sw;		/* use type extension to indicate single/series */
     1348 	err_mess = "";				/* clear the message for the int proc */
     1349 
     1350 	call send_coord_msg (code, number);		/* ship it */
     1351 	if code ^= 0
     1352 	then do;
     1353 	     if code = error_table_$namedup
     1354 	     then err_mess = "A restart is already in progress.";
     1355 	     else if code = error_table_$noentry
     1356 	     then err_mess = "Request number not found in saved list.";
     1357 	     else if code = error_table_$action_not_performed
     1358 	     then err_mess = "The specified request series is invalid for this driver.";
     1359 	     call iodd_msg_ (normal, source, code, rtrim (iodd_static.major_device) || " driver", "^a", err_mess);
     1360 	     return;
     1361 	end;
     1362 
     1363 	if ^series_sw | iodd_comm.type = save
     1364 	then return;
     1365 
     1366 	if number ^= seq_id
     1367 	then call iodd_msg_ (normal, source, code, rtrim (iodd_static.major_device) || " driver",
     1368 		"Series will be restarted from request ^d", number);
     1369 
     1370 	restart_series = divide (seq_id, 10000, 35, 0);	/* get the series he restarted */
     1371 
     1372 	do i = 1 to iodd_static.assigned_devices;	/* see if there is a pending request */
     1373 						/* of the same series */
     1374 	     dr_ptr = driver_ptr_list.stat_segp (i);	/* look at each driver_status seg */
     1375 	     desc_ptr = addr (dr_ptr -> driver_status.descriptor);
     1376 						/* and request descriptor */
     1377 
     1378 	     series = desc_ptr -> request_descriptor.seq_id;
     1379 						/* get the seq no of this request */
     1380 
     1381 	     series = divide (series, 10000, 35, 0);	/* strip out the series number */
     1382 
     1383 	     if restart_series = series
     1384 	     then do;				/* if they match, we are done with the search */
     1385 		if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
     1386 		then do;				/* is it active? */
     1387 		     desc_ptr -> request_descriptor.finished = "1"b;
     1388 						/* mark it done so we can pass back */
     1389 		     if dr_ptr -> driver_status.ready
     1390 		     then dr_ptr -> driver_status.request_pending = (36)"0"b;
     1391 						/* clear the pending flag */
     1392 		     else dr_ptr -> driver_status.request_pending = iodd_static.driver_proc_id;
     1393 						/* or busy the driver */
     1394 		     if dr_ptr -> driver_status.busy
     1395 		     then do;			/* was driver processing the request? */
     1396 			iodd_static.slave_hold = "1"b;/* return to command level after aborting request */
     1397 			if iodd_static.request_in_progress
     1398 			then signal daemon_save;	/* try a normal save, or ... */
     1399 			signal resume;		/* send the current request back to the coord */
     1400 		     end;
     1401 		     else do;			/* we want to send a pending request back to the coord */
     1402 			dr_ptr -> driver_status.last_wake_time = 0;
     1403 						/* force driver to request new one */
     1404 			event_message = 0;		/* clear the message to the coord */
     1405 			msgp = addr (event_message);
     1406 			msgp -> ev_msg.code = 0;	/* code 0 means take back this request and wait */
     1407 			msgp -> ev_msg.minor_dev_index =
     1408 						/* tell which driver it was */
     1409 			     fixed (dr_ptr -> driver_status.dev_index, 17);
     1410 
     1411 			call hcs_$wakeup (iodd_static.coord_proc_id, dr_ptr -> driver_status.coord_chan,
     1412 			     event_message, code);
     1413 
     1414 			if code ^= 0
     1415 			then signal no_coord;	/* again, errors are bad news!! */
     1416 		     end;
     1417 		end;
     1418 		return;				/* we don't have to look at anything more */
     1419 	     end;
     1420 	end;					/* end of the loop for assigned devices */
     1421 	return;
     1422 
     1423 
     1424 restart_q_command:
     1425 	if iodd_static.assigned_devices > 1 & arg_list.n = 1
     1426 	then do;					/* device needed? */
     1427 	     err_mess = "Multiple minor devices require an argument.";
     1428 	     go to error;
     1429 	end;
     1430 
     1431 	if arg_list.n > 1
     1432 	then do;					/* find the minor device index as requested */
     1433 	     call find_minor_dev (args (1), dr_ptr, code);
     1434 	     if code ^= 0
     1435 	     then go to error;			/* msg has been set */
     1436 	     iodd_comm.minor_idx = dr_ptr -> driver_status.dev_index;
     1437 	     iodd_comm.dvc_idx = dr_ptr -> driver_status.maj_index;
     1438 	end;
     1439 	else do;
     1440 	     iodd_comm.minor_idx = iodd_static.driver_ptr -> driver_status.dev_index;
     1441 	     iodd_comm.dvc_idx = iodd_static.driver_ptr -> driver_status.maj_index;
     1442 	end;
     1443 
     1444 /*	now complete the message */
     1445 
     1446 	iodd_comm.type = restart_q;
     1447 	iodd_comm.type_ext = ""b;
     1448 	iodd_comm.request_no = 0;
     1449 	iodd_comm.queue_no = 0;			/* we restart all queues */
     1450 	iodd_comm.data_len = 0;			/* define a null char string */
     1451 	iodd_comm.req_id = "";
     1452 	iodd_comm.user_id = "";
     1453 	err_mess = "";
     1454 
     1455 	call send_coord_msg (code, number);
     1456 
     1457 	if code ^= 0
     1458 	then call iodd_msg_ (normal, source, code, rtrim (iodd_static.major_device) || " driver", err_mess);
     1459 
     1460 	else call iodd_msg_ (normal, source, 0, "", "Coord has restarted the queues.");
     1461 
     1462 
     1463 	return;
     1464 
     1465 
     1466 resume_command:
     1467 	if iodd_static.test_entry & (source = master)
     1468 	then do;
     1469 	     iodd_static.slave_hold = "1"b;		/* force a command at normal level */
     1470 	     call iox_$control (iodd_static.master_in, "start", null, ec);
     1471 						/* avoid lost wakeups */
     1472 	     if iodd_static.slave.active
     1473 	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
     1474 	     signal resume;				/* go back to iodd_listen_ */
     1475 	     iodd_static.master_hold = "1"b;		/* OOPS, trouble.  But, master did it */
     1476 	     return;
     1477 	end;
     1478 
     1479 	err_mess = "The resume command is valid from the master terminal in test mode only.";
     1480 
     1481 	go to error;
     1482 
     1483 
     1484 return_command:
     1485 	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */
     1486 
     1487 	if iodd_static.test_entry
     1488 	then if source = master
     1489 	     then do;
     1490 		driver_ptr_list.number = 0;		/* don't tell the coord we are going away */
     1491 		signal daemon_logout;
     1492 		iodd_static.master_hold = "1"b;	/* we won't get here, but.... */
     1493 		return;
     1494 	     end;
     1495 
     1496 	err_mess = "The return command is only valid from the master terminal in test mode.";
     1497 	return;
     1498 
     1499 
     1500 save_command:					/* ask coord to save requests in our device class */
     1501 	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */
     1502 
     1503 	if arg_list.n > 1
     1504 	then do;					/* the N or -from N case */
     1505 	     iodd_comm.type = save;			/* mark the type of command */
     1506 	     go to restart_or_save;			/* use some common code with restart */
     1507 	end;
     1508 	if source = slave
     1509 	then if iodd_static.master_hold
     1510 	     then do;				/* can't override the master */
     1511 		err_mess = "Command not valid while process is in hold by master terminal.";
     1512 		go to error;
     1513 	     end;
     1514 
     1515 	if (state > listen_cmd_level) & iodd_static.request_in_progress
     1516 	then do;
     1517 	     iodd_static.master_hold = "0"b;		/* this must be the master or value is already 0 */
     1518 	     iodd_static.slave_hold = "0"b;		/* be sure they are off for next command level */
     1519 	     call iox_$control (iodd_static.master_in, "start", null, ec);
     1520 						/* avoid lost wakeups */
     1521 	     if iodd_static.slave.active
     1522 	     then call iox_$control (iodd_static.slave_in, "start", null, ec);
     1523 	     desc_ptr = addr (iodd_static.driver_ptr -> driver_status.descriptor);
     1524 	     desc_ptr -> request_descriptor.saved = "1"b;
     1525 	     desc_ptr -> request_descriptor.finished = "1"b;
     1526 	     desc_ptr -> request_descriptor.cancelled = ""b;
     1527 						/* just to be sure */
     1528 
     1529 	     signal daemon_save;			/* try for a clean finish of what was done */
     1530 	     ec = 2;				/* make like a start command was given */
     1531 	     return;
     1532 	end;
     1533 	else do;
     1534 	     err_mess = "No current request to save.";
     1535 	     go to error;
     1536 	end;
     1537 
     1538 	return;
     1539 
     1540 
     1541 slave_command:
     1542 	if source = master
     1543 	then					/* slave can't send itself a message */
     1544 	     if iodd_static.slave.active
     1545 	     then do;
     1546 		call iodd_msg_ (normal, slave, 0, "", "From master: ^a",
     1547 		     substr (command_line, index (command_line, "slave") + 5));
     1548 		call iox_$control (iodd_static.slave_out, "runout", null, code);
     1549 		return;
     1550 	     end;
     1551 	     else do;
     1552 		err_mess = "Slave device is not active.";
     1553 		go to error;
     1554 	     end;
     1555 
     1556 	err_mess = "Invalid command for slave terminal.";
     1557 	go to error;
     1558 
     1559 
     1560 slave_term_command:
     1561 	if ^iodd_static.slave.active
     1562 	then do;
     1563 	     err_mess = "Slave terminal is not active.";
     1564 	     go to error;
     1565 	end;
     1566 
     1567 	if arg_list.n < 2
     1568 	then do;
     1569 	     err_mess = "Expected argument missing.";
     1570 	     go to error;
     1571 	end;
     1572 
     1573 	if args (1) = "errors"
     1574 	then do;
     1575 	     iodd_static.slave.print_errors = "1"b;
     1576 	     call ios_$attach ("error_output", "syn", "broadcast_errors", "", io_stat);
     1577 	end;
     1578 
     1579 	else if args (1) = "no_errors" | args (1) = "noerrors"
     1580 	then do;
     1581 	     iodd_static.slave.print_errors = "0"b;
     1582 	     call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
     1583 	end;
     1584 
     1585 	else if args (1) = "commands"
     1586 	then do;
     1587 	     if source = slave
     1588 	     then do;
     1589 		call master_only ("slave_term " || args (1));
     1590 		return;
     1591 	     end;
     1592 	     iodd_static.accept_input = "1"b;
     1593 	     if state >= quit_cmd_level & ^iodd_static.slave.allow_quits
     1594 	     then call iodd_msg_ (normal, master, 0, "",
     1595 		     "This will not be effective at this level while quits are disabled.");
     1596 	end;
     1597 
     1598 	else if args (1) = "no_commands" | args (1) = "nocommands"
     1599 	then do;
     1600 	     if source = slave
     1601 	     then do;
     1602 		call master_only ("slave_term " || args (1));
     1603 		return;
     1604 	     end;
     1605 	     iodd_static.accept_input = "0"b;
     1606 	     if state >= quit_cmd_level
     1607 	     then call iodd_msg_ (normal, master, 0, "",
     1608 		     "WARNING: The previous command input state may be restored after start.");
     1609 	end;
     1610 
     1611 	else if args (1) = "quits"
     1612 	then do;
     1613 	     if source = slave
     1614 	     then do;
     1615 		call master_only ("slave_term " || args (1));
     1616 		return;
     1617 	     end;
     1618 	     iodd_static.allow_quits = "1"b;
     1619 	end;
     1620 
     1621 	else if args (1) = "no_quits" | args (1) = "noquits"
     1622 	then do;
     1623 	     if source = slave
     1624 	     then do;
     1625 		call master_only ("slave_term " || args (1));
     1626 		return;
     1627 	     end;
     1628 	     iodd_static.allow_quits = "0"b;
     1629 	end;
     1630 
     1631 	else if args (1) = "log"
     1632 	then do;
     1633 	     iodd_static.slave.log_msg = "1"b;
     1634 	end;
     1635 
     1636 	else if args (1) = "no_log" | args (1) = "nolog"
     1637 	then do;
     1638 	     iodd_static.slave.log_msg = "0"b;
     1639 	end;
     1640 
     1641 	else if args (1) = "echo"
     1642 	then do;
     1643 	     iodd_static.slave.echo_cmd = "1"b;
     1644 	end;
     1645 
     1646 	else if args (1) = "no_echo" | args (1) = "noecho"
     1647 	then do;
     1648 	     iodd_static.slave.echo_cmd = "0"b;
     1649 	end;
     1650 
     1651 	else if args (1) = "modes"
     1652 	then do;					/* see if he wants a changemode */
     1653 	     if arg_list.n < 3
     1654 	     then do;				/* just report current mode */
     1655 		mode = "";
     1656 		message = "Current_modes:";
     1657 	     end;
     1658 	     else do;
     1659 		mode = args (2);
     1660 		message = "Modes were:";
     1661 	     end;
     1662 	     omode = "not returned";			/* just to make the message clear */
     1663 
     1664 	     call ios_$changemode (iodd_static.slave_output, mode, omode, io_stat);
     1665 	     if st.code ^= 0
     1666 	     then do;				/* OOPS */
     1667 		ec = st.code;			/* report the error */
     1668 		call iodd_msg_ (normal, both, ec, whoami);
     1669 	     end;
     1670 	     call iodd_msg_ (normal, source, 0, "", "^a ^a", message, omode);
     1671 	end;
     1672 
     1673 	else do;					/* otherwise ...not implemented here */
     1674 	     ec = unknown_cmd_code;			/* see if driver module recognizes it */
     1675 	     err_mess = "Invalid function for slave_term command: " || args (1);
     1676 	     go to pass_on;				/* give it to the driver module for action */
     1677 	end;
     1678 	return;
     1679 
     1680 
     1681 start_command:
     1682 	if state > listen_cmd_level
     1683 	then do;					/* we use start after a quit */
     1684 	     iodd_static.slave_hold = "0"b;
     1685 	     if source = master
     1686 	     then iodd_static.master_hold = "0"b;
     1687 	     if iodd_static.master_hold
     1688 	     then do;
     1689 		err_mess = "Driver in hold by master terminal.";
     1690 		go to error;
     1691 	     end;
     1692 	     ec = 2;				/* this is the start code for the quit handler */
     1693 	     return;
     1694 	end;
     1695 
     1696 	err_mess = "The ""start"" command is not valid at this level.";
     1697 	go to error;
     1698 
     1699 
     1700 
     1701 status_command:
     1702 	if arg_list.n > 1
     1703 	then do;
     1704 	     if args (1) = "-long" | args (1) = "-lg"
     1705 	     then lg_sw = "1"b;			/* gave the long option */
     1706 	     else do;
     1707 		err_mess = "Invalid control argument: " || args (1);
     1708 		go to error;
     1709 	     end;
     1710 	end;
     1711 	else lg_sw = "0"b;
     1712 
     1713 	list_ptr = iodd_static.driver_list_ptr;		/* make the reference easier */
     1714 
     1715 	if iodd_static.step
     1716 	then message = "(step mode set)";
     1717 	else message = "";
     1718 
     1719 	call iodd_msg_ (normal, source, 0, "", "^/IO Daemon Version: ^a^/Device:^2x^a^3x^a:^2x^a^3x^a",
     1720 	     iodd_static.io_daemon_version, iodd_static.major_device, chn_type (iodd_static.attach_type),
     1721 	     iodd_static.attach_name, message);
     1722 
     1723 	if iodd_static.assigned_devices = 1
     1724 	then do;					/* different form for one device */
     1725 	     dr_ptr = iodd_static.driver_ptr;		/* use the current driver */
     1726 	     call iodd_msg_ (normal, source, 0, "", "Request type:  ^a", dr_ptr -> driver_status.req_type_label);
     1727 	     call get_driver_status (message);
     1728 	     call iodd_msg_ (normal, source, 0, "", "Status:^8x^a^/", message);
     1729 	     return;
     1730 	end;
     1731 
     1732 /* determine length to generate legible display */
     1733 	device_id_length, req_type_label_length = 12;
     1734 	do i = 1 to iodd_static.assigned_devices;
     1735 	     dr_ptr = driver_ptr_list.stat_segp (i);
     1736 	     if dr_ptr -> driver_status.attached | lg_sw
     1737 	     then do;
     1738 		if length (rtrim (dr_ptr -> driver_status.device_id)) > device_id_length
     1739 		then device_id_length = length (rtrim (dr_ptr -> driver_status.device_id));
     1740 		if length (rtrim (dr_ptr -> driver_status.req_type_label)) > req_type_label_length
     1741 		then req_type_label_length = length (rtrim (dr_ptr -> driver_status.req_type_label));
     1742 	     end;
     1743 	end;
     1744 	call iodd_msg_ (normal, source, 0, "", "^/minor device^vx  request type^vx  status^/", device_id_length - 12,
     1745 	     req_type_label_length - 12);
     1746 
     1747 	do i = 1 to iodd_static.assigned_devices;
     1748 	     dr_ptr = driver_ptr_list.stat_segp (i);
     1749 	     if dr_ptr -> driver_status.attached | lg_sw
     1750 	     then do;
     1751 		call get_driver_status (message);
     1752 		call iodd_msg_ (normal, source, 0, "", "^va  ^va  ^a", device_id_length,
     1753 		     dr_ptr -> driver_status.device_id, req_type_label_length, dr_ptr -> driver_status.req_type_label,
     1754 		     message);
     1755 	     end;
     1756 	end;
     1757 
     1758 	call iodd_msg_ (normal, source, 0, "", "^/");	/* separate from command request */
     1759 
     1760 	return;
     1761 
     1762 
     1763 step_command:
     1764 	if arg_list.n > 1
     1765 	then do;					/* an argument was given */
     1766 	     if args (1) = "set"
     1767 	     then iodd_static.step = "1"b;
     1768 	     else if args (1) = "reset"
     1769 	     then iodd_static.step = "0"b;
     1770 	     else do;				/* unknown arg */
     1771 		err_mess = "Valid arguments are set and reset.";
     1772 		go to error;
     1773 	     end;
     1774 	end;
     1775 	else iodd_static.step = "1"b;
     1776 	return;
     1777 
     1778 
     1779 x_command:
     1780 	if search (command_line, bad_chars) > 0
     1781 	then do;					/* trying to trick us? */
     1782 	     call iodd_msg_ (normal, source, 0, "", "Invalid characters in command line.");
     1783 	     ec = unknown_cmd_code;
     1784 	     return;
     1785 	end;
     1786 
     1787 	on any_other call x_cmd_handler;		/* in case ec gets into trouble */
     1788 	on cleanup call reattach_master;
     1789 
     1790 	if source = slave
     1791 	then do;					/* for slave, we must swap streams around */
     1792 	     call swap_user_io_streams (ec);
     1793 	     if ec ^= 0
     1794 	     then do;
     1795 		err_mess = "Unable to switch user io switches to salve.";
     1796 		call reattach_master;
     1797 		go to error;
     1798 	     end;
     1799 	end;
     1800 	else do;					/* for master, be sure slave doesn't get error messages */
     1801 	     att_desc = "syn_ error_i/o -inhibit close";
     1802 	     call iox_$detach_iocb (iox_$error_output, ec);
     1803 	     call iox_$attach_ptr (iox_$error_output, att_desc, null, ec);
     1804 	     if ec ^= 0
     1805 	     then do;
     1806 		err_mess = "Error switching error_output.";
     1807 		call reattach_master;		/* try like hell */
     1808 		go to error;
     1809 	     end;
     1810 	end;
     1811 
     1812 	tried_once = "0"b;				/* get set for not finding <device>_admin.ec */
     1813 	ec_name = iodd_static.admin_ec_name;		/* get the first name */
     1814 
     1815 once_more:
     1816 	call hcs_$initiate (iodd_static.sys_dir_ptr -> sys_dir, ec_name, "", 0, 1, segp, code);
     1817 	if segp = null
     1818 	then do;					/* not there */
     1819 	     if ^tried_once
     1820 	     then do;				/* look for iod_admin.ec */
     1821 		ec_name = "iod_admin.ec";
     1822 		tried_once = "1"b;			/* say we have tried once already */
     1823 		go to once_more;			/* try_again */
     1824 	     end;
     1825 	     ec = code;				/* too bad, give up */
     1826 	     err_mess = "Unable to find " || rtrim (iodd_static.admin_ec_name) || " or iod_admin.ec for this driver.";
     1827 	     call reattach_master;
     1828 	     go to error;
     1829 	end;
     1830 
     1831 	if iodd_static.admin_ec_name ^= ec_name
     1832 	then do;					/* if we switched, tell operator */
     1833 	     call iodd_msg_ (normal, source, 0, "", "Using ^a for x command.", ec_name);
     1834 	     iodd_static.admin_ec_name = ec_name;	/* incase we had to switch */
     1835 	end;
     1836 
     1837 	command =
     1838 	     "exec_com " || rtrim (iodd_static.sys_dir_ptr -> sys_dir) || ">" || rtrim (ec_name)
     1839 	     || substr (command_line, index (command_line, "x") + 1);
     1840 						/* be sure to leave in the leading space */
     1841 
     1842 	call cu_$cp (addr (command), length (rtrim (command)), code);
     1843 	if code ^= 0
     1844 	then ec = unknown_cmd_code;			/* force a reset_read */
     1845 
     1846 	call reattach_master;
     1847 
     1848 	return;
     1849 
     1850 
     1851 /*      END OF DEFINED COMMANDS     */
     1852 /* ************************************ */
     1853 
     1854 /* *********************************** */
     1855 
     1856 
     1857 
     1858 
     1859 
     1860 init:
     1861      entry (a_ptr);					/* initialize the static data */
     1862 
     1863 dcl  a_ptr ptr;
     1864 
     1865 	stat_p = a_ptr;				/* set the pointer to iodd_static */
     1866 
     1867 
     1868 	return;
     1869 
     1870 /*	**** INTERNAL PROCEDURES ****		*/
     1871 
     1872 
     1873 halt_all:
     1874      proc;					/* unready all devices assigned to the process */
     1875 
     1876 dcl  i fixed bin;					/* don't destroy the one in the external proc */
     1877 
     1878 	do i = 1 to iodd_static.assigned_devices;
     1879 
     1880 	     dr_ptr = driver_ptr_list.stat_segp (i);
     1881 	     dr_ptr -> driver_status.ready = "0"b;	/* turn off the ready flag to stop driver */
     1882 	     if ^stac (addr (dr_ptr -> driver_status.request_pending), iodd_static.driver_proc_id)
     1883 	     then do;
     1884 		if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
     1885 		then iodd_static.runout_requests = "1"b;/* there was a pending request */
     1886 	     end;
     1887 	     iodd_static.current_devices = 0;		/* reset the count...all stopped */
     1888 
     1889 	end;
     1890 
     1891      end halt_all;
     1892 
     1893 
     1894 
     1895 ready_all:
     1896      proc;					/* ready all attached minor devices */
     1897 
     1898 dcl  i fixed bin;					/* save the variable in external proc */
     1899 
     1900 	iodd_static.current_devices = 0;		/* clear the count */
     1901 
     1902 	do i = 1 to iodd_static.assigned_devices;
     1903 	     dr_ptr = driver_ptr_list.stat_segp (i);	/* get driver ptr */
     1904 	     if dr_ptr -> driver_status.attached
     1905 	     then do;
     1906 		dr_ptr -> driver_status.ready = "1"b;
     1907 		iodd_static.current_devices = iodd_static.current_devices + 1;
     1908 						/* one more ready */
     1909 		if dr_ptr -> driver_status.request_pending
     1910 		then				/* if open to coord, leave it alone */
     1911 		     if dr_ptr -> driver_status.request_pending ^= iodd_static.coord_proc_id
     1912 		     then dr_ptr -> driver_status.request_pending = (36)"0"b;
     1913 	     end;
     1914 	     else do;
     1915 		dr_ptr -> driver_status.ready = "0"b;	/* just to be sure */
     1916 		dr_ptr -> driver_status.busy = "0"b;
     1917 	     end;
     1918 	end;
     1919 
     1920      end ready_all;
     1921 
     1922 
     1923 get_driver_status:
     1924      proc (status);
     1925 
     1926 /* internal procedure to set a string description of the driver status seg pointed */
     1927 /* to by dr_ptr. */
     1928 
     1929 dcl  status char (*);
     1930 dcl  string char (32);
     1931 dcl  len fixed bin;
     1932 dcl  pending bit (1);
     1933 
     1934 	if dr_ptr -> driver_status.ready
     1935 	then status = "ready";
     1936 
     1937 	else if dr_ptr -> driver_status.attached
     1938 	then status = "halted";
     1939 
     1940 	else status = "not attached";
     1941 
     1942 	if dr_ptr -> driver_status.request_pending = iodd_static.coord_proc_id
     1943 	then do;					/* request there? */
     1944 	     desc_ptr = addr (dr_ptr -> driver_status.descriptor);
     1945 	     pending = ^((dr_ptr = iodd_static.driver_ptr) & iodd_static.request_in_progress);
     1946 	     seq_id = desc_ptr -> request_descriptor.seq_id;
     1947 	     call ioa_$rsnnl ("request ^d ^[pending^;in progress^]", string, len, seq_id, pending);
     1948 	     substr (status, 16) = string;
     1949 	end;
     1950 
     1951 	return;
     1952 
     1953      end get_driver_status;
     1954 
     1955 
     1956 find_minor_dev:
     1957      proc (dev_id, dr_ptr, code);
     1958 
     1959 dcl  dev_id char (*) var;
     1960 dcl  dr_ptr ptr;
     1961 dcl  code fixed bin (35);
     1962 dcl  j fixed bin;
     1963 
     1964 
     1965 	code = 0;
     1966 	list_ptr = iodd_static.driver_list_ptr;
     1967 	do j = 1 to iodd_static.assigned_devices;
     1968 	     dr_ptr = driver_ptr_list.stat_segp (j);
     1969 	     if dr_ptr -> driver_status.device_id = dev_id
     1970 	     then return;				/* found the device */
     1971 	end;
     1972 	code = error_table_$noentry;
     1973 	err_mess = "Invalid minor device name: " || dev_id;
     1974 	return;
     1975 
     1976      end find_minor_dev;
     1977 
     1978 master_only:
     1979      proc (msg);
     1980 
     1981 dcl  msg char (*);
     1982 
     1983 	call iodd_msg_ (normal, source, 0, "", "^a driver:  Invalid function from the slave terminal.  ^a",
     1984 	     iodd_static.major_device, msg);
     1985 
     1986 	ec = unknown_cmd_code;
     1987 
     1988 	return;
     1989 
     1990      end master_only;
     1991 
     1992 
     1993 
     1994 x_cmd_handler:
     1995      proc;					/* any_other handler for the x command */
     1996 
     1997 dcl  code fixed bin (35);				/* local error code */
     1998 dcl  type char (32);
     1999 
     2000 	cond_info.version = 1;
     2001 
     2002 	call find_condition_info_ (null, addr (cond_info), code);
     2003 
     2004 	type = cond_info.condition_name;		/* for easy reference */
     2005 	if type = "cput"
     2006 	then do;
     2007 continue_signal:
     2008 	     call continue_to_signal_ (code);		/* this is harmless */
     2009 	     return;
     2010 	end;
     2011 	if type = "alrm"
     2012 	then go to continue_signal;
     2013 	if type = "finish"
     2014 	then go to continue_signal;
     2015 	if type = "command_error"
     2016 	then return;
     2017 	if type = "command_question"
     2018 	then do;
     2019 	     cq_info_ptr = cond_info.info_ptr;		/* get pointer to question info structure */
     2020 	     if command_question_info.version >= cq_info_version_5
     2021 	     then do;				/* if we can */
     2022 		command_question_info.question_iocbp = iox_$user_output;
     2023 						/* set the switches for Q and A */
     2024 		command_question_info.answer_iocbp = iox_$user_input;
     2025 		command_question_info.repeat_time = 120;/* ask every 2 minutes */
     2026 	     end;
     2027 	     return;
     2028 	end;
     2029 	if iodd_static.test_entry
     2030 	then if type = "mme2"
     2031 	     then go to continue_signal;
     2032 	     else if type = "program_interrupt"
     2033 	     then go to continue_signal;
     2034 
     2035 	call ioa_ ("Error: ^a condition during the driver x command.  Command aborted.", type);
     2036 
     2037 	call reattach_master;
     2038 
     2039 	go to ignore;				/* go back to command level */
     2040 
     2041      end x_cmd_handler;
     2042 
     2043 swap_user_io_streams:
     2044      proc (code);
     2045 
     2046 dcl  code fixed bin (35);
     2047 
     2048 	code = 0;
     2049 
     2050 	att_desc = "syn_ " || rtrim (iodd_static.slave_output) || " -inhibit close";
     2051 
     2052 	call iox_$detach_iocb (iox_$user_output, code);
     2053 	if code ^= 0
     2054 	then return;
     2055 
     2056 	call iox_$attach_ptr (iox_$user_output, att_desc, null, code);
     2057 	if code ^= 0
     2058 	then return;
     2059 
     2060 	call iox_$detach_iocb (iox_$error_output, ec);
     2061 	if ec ^= 0
     2062 	then return;
     2063 
     2064 	call iox_$attach_ptr (iox_$error_output, att_desc, null, ec);
     2065 	if ec ^= 0
     2066 	then return;
     2067 
     2068 	att_desc = "syn_ " || rtrim (iodd_static.slave_input) || " -inhibit close ";
     2069 
     2070 	call iox_$detach_iocb (iox_$user_input, code);
     2071 	if code ^= 0
     2072 	then return;
     2073 
     2074 	call iox_$attach_ptr (iox_$user_input, att_desc, null, code);
     2075 
     2076 	return;
     2077 
     2078      end swap_user_io_streams;
     2079 
     2080 reattach_master:
     2081      proc;
     2082 
     2083 /*	reconnect the user_output, error_output and user_input switches to user_i/o */
     2084 
     2085 dcl  code fixed bin (35);
     2086 
     2087 	code = 0;
     2088 
     2089 	att_desc = "syn_ user_i/o -inhibit close";
     2090 
     2091 	call iox_$detach_iocb (iox_$user_output, code);
     2092 	if code ^= 0
     2093 	then go to fatal_error;
     2094 
     2095 	call iox_$attach_ptr (iox_$user_output, att_desc, null, code);
     2096 	if code ^= 0
     2097 	then go to fatal_error;
     2098 
     2099 	call iox_$detach_iocb (iox_$user_input, code);
     2100 	if code ^= 0
     2101 	then go to fatal_error;
     2102 
     2103 	call iox_$attach_ptr (iox_$user_input, att_desc, null, code);
     2104 	if code ^= 0
     2105 	then go to fatal_error;
     2106 
     2107 	if iodd_static.slave.active & iodd_static.slave.print_errors
     2108 	then att_desc = "syn_ broadcast_errors -inhibit close";
     2109 	else att_desc = "syn_ error_i/o -inhibit close";
     2110 
     2111 	call iox_$detach_iocb (iox_$error_output, code);
     2112 	if code ^= 0
     2113 	then go to fatal_error;
     2114 
     2115 	call iox_$attach_ptr (iox_$error_output, att_desc, null, code);
     2116 	if code = 0
     2117 	then return;
     2118 
     2119 fatal_error:
     2120 	call iodd_msg_ (error, both, code, whoami, "Fatal error swapping user io streams.");
     2121 
     2122 	if iodd_static.test_entry
     2123 	then do;
     2124 	     call iodd_msg_ (normal, master, 0, "", "Calling Probe - and hope for the best.");
     2125 	     call probe;
     2126 	     return;
     2127 	end;
     2128 
     2129 	call logout;
     2130 
     2131 	return;
     2132 
     2133      end reattach_master;
     2134 
     2135 send_coord_msg:
     2136      proc (code, number);
     2137 
     2138 dcl  code fixed bin (35);
     2139 dcl  number fixed bin (35);
     2140 dcl  len fixed bin;
     2141 dcl  msg_id bit (72) aligned;
     2142 
     2143 	iodd_comm.ack_chan = iodd_static.cmd_ack_chan;	/* this is how we expext to get confirmation */
     2144 	len = currentsize (iodd_comm);		/* get size of message */
     2145 
     2146 	call message_segment_$add_file (iodd_static.sys_dir_ptr -> sys_dir, "coord_comm.ms", comm_ptr, len * 36, msg_id,
     2147 	     code);
     2148 	if code ^= 0
     2149 	then do;
     2150 	     err_mess = "unable to add command request to coord_comm.ms.";
     2151 	     return;
     2152 	end;
     2153 
     2154 	call ipc_$drain_chn (iodd_static.cmd_ack_chan, code);
     2155 						/* clear any pending wakeups */
     2156 	call ipc_$drain_chn (iodd_static.timer_chan, code);
     2157 						/* especially this one */
     2158 
     2159 	unspec (event_message) = msg_id;		/* give the message id to the coord in ev message */
     2160 
     2161 	call hcs_$wakeup (iodd_static.coord_proc_id, iodd_static.coord_cmd_chan, event_message, code);
     2162 	if code ^= 0
     2163 	then go to bad_ipc;				/* errors are bad news */
     2164 
     2165 /* set up a timer to be sure we don't block too long */
     2166 
     2167 	call timer_manager_$alarm_wakeup (120, "11"b, iodd_static.timer_chan);
     2168 						/* allow coord two munutes */
     2169 
     2170 	ev_chan_list.number = 2;			/* get ready to block */
     2171 	ev_chan_list.chan (1) = iodd_static.cmd_ack_chan; /* first priority is coord */
     2172 	ev_chan_list.chan (2) = iodd_static.timer_chan;	/* next is the timer */
     2173 
     2174 	call ipc_$block (addr (ev_chan_list), addr (event_info), code);
     2175 
     2176 	call timer_manager_$reset_alarm_wakeup (iodd_static.timer_chan);
     2177 						/* stop the timer, if possible */
     2178 
     2179 	if code ^= 0
     2180 	then do;					/* very bad news */
     2181 bad_ipc:
     2182 	     call convert_ipc_code_ (code);
     2183 	     call iodd_msg_ (normal, both, code, whoami, "Fatal error.  Driver will reinitialize.");
     2184 	     signal re_init;
     2185 	end;
     2186 
     2187 	if event_info.wait_list_idx = 1
     2188 	then do;					/* it was from the coord */
     2189 	     msgp = addr (event_info.msg);
     2190 	     code = msgp -> ack_msg.code;
     2191 	     number = msgp -> ack_msg.num;
     2192 	end;
     2193 	else do;					/* the timer went off, is ther a coord at all? */
     2194 	     code = error_table_$request_not_recognized;
     2195 	     err_mess = "Coordinator did not respond to command.";
     2196 	end;
     2197 	return;
     2198 
     2199      end send_coord_msg;
     2200 
  1     1 /* BEGIN INCLUDE FILE:  command_question_info.incl.pl1 */
  1     2 
  1     3 /*	Last modified: 11/02/78 W. Olin Sibert to change to version 5 and make compatible with query_info */
  1     4 /* Added explanation_ptr & explanation_len (Version 6) 05/13/81 S. Herbst */
  1     5 /* switched to condition_info_header June 1981 B. Margulies */
  1     6 
  1     7 /* This include file depends on condition_info_header.incl.pl1 */
  1     8 /* It must be included as well */
  1     9 /* Added interpret_cp_escape, literal_sw, prompt_after_explanation 12/16/82 S. Herbst */
  1    10 /* Changed ("" max_)(question answer)_lth declarations to fixed bin (21) 02/08/84 S. Herbst */
  1    11 
  1    12 
  1    13 dcl 1 command_question_info based (cq_info_ptr) aligned,
  1    14     2 header aligned like condition_info_header,
  1    15     2 query_code fixed bin (35),			/* extra information supplied by caller */
  1    16     2 switches aligned,                                     /* various bit switches */
  1    17       3 question_sw bit (1) unaligned,			/* should command_query_ print the question? */
  1    18       3 yes_or_no_sw bit (1) unaligned,			/* must question be answered yes or no? */
  1    19       3 preset_sw bit (1) unaligned,			/* is handler supplying a canned answer? */
  1    20       3 answer_sw bit (1) unaligned,			/* should canned answer be printed? */
  1    21       3 allow_cp_escape bit (1) unaligned,                  /* whether to allow answers to begin with ".." */
  1    22       3 suppress_spacing bit (1) unaligned,                 /* whether to print extra newline and spaces */
  1    23       3 interpret_cp_escape bit (1) unaligned,		/* whether to treat ".." as a cp escape */
  1    24       3 literal_sw bit (1) unaligned,			/* ON => don't strip whitespace or handle ".." */
  1    25       3 prompt_after_explanation bit (1) unaligned,	/* ON => repeat question after explanation */
  1    26       3 mbz bit (27) unaligned,
  1    27     2 name_ptr pointer,				/* ptr to caller's name */
  1    28     2 name_lth fixed bin,				/* length of caller's name */
  1    29     2 question_ptr pointer,				/* ptr to quetion being asked */
  1    30     2 question_lth fixed bin (21),			/* lentgh of question */
  1    31     2 max_question_lth fixed bin (21),			/* max question lth in case handler alters question */
  1    32     2 answer_ptr pointer,				/* pointer to space to return answer in */
  1    33     2 answer_lth fixed bin (21),			/* length of returned answer */
  1    34     2 max_answer_lth fixed bin (21),			/* max space in answer space */
  1    35     2 question_iocbp ptr,				/* IO switch to ask (write) question on */
  1    36     2 answer_iocbp ptr,				/* IO switch to read the answer from */
  1    37     2 repeat_time fixed bin (71),			/* repeat question every N seconds if no answer */
  1    38     2 explanation_ptr ptr,				/* ptr to string to print if user answers "?" */
  1    39     2 explanation_len fixed bin (21);			/* length of explanation string */
  1    40 						/* if N < 30 no repeat will occur */
  1    41 
  1    42 dcl  cq_info_ptr pointer;
  1    43 
  1    44 dcl  cq_info_version_7 fixed bin internal static options (constant) init (7);
  1    45 
  1    46 /* END INCLUDE FILE:  command_question_info.incl.pl1 */
     2201 
     2202 
  2     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  2     2 
  2     3 /* Structure for find_condition_info_.
  2     4*
  2     5*   Written 1-Mar-79 by M. N. Davidoff.
  2     6**/
  2     7 
  2     8 /* automatic */
  2     9 
  2    10      declare condition_info_ptr     pointer;
  2    11 
  2    12 /* based */
  2    13 
  2    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  2    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  2    16 	     2 version	      fixed binary,		/* Must be 1 */
  2    17 	     2 condition_name     char (32) varying,	/* name of condition */
  2    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  2    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  2    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  2    21 	     2 flags	      unaligned,
  2    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  2    23 	       3 pad1	      bit (35),
  2    24 	     2 pad2	      bit (36),
  2    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  2    26 	     2 pad3	      (4) bit (36);
  2    27 
  2    28 /* internal static */
  2    29 
  2    30      declare condition_info_version_1
  2    31 			      fixed binary internal static options (constant) initial (1);
  2    32 
  2    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
     2203 
     2204 
  3     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  3     2 /* format: style2 */
  3     3 
  3     4      declare condition_info_header_ptr
  3     5 			      pointer;
  3     6      declare 1 condition_info_header
  3     7 			      aligned based (condition_info_header_ptr),
  3     8 	     2 length	      fixed bin,		/* length in words of this structure */
  3     9 	     2 version	      fixed bin,		/* version number of this structure */
  3    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  3    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  3    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  3    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  3    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  3    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  3    16 	       3 pad	      bit (32) unaligned,
  3    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  3    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  3    19 
  3    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
     2205 
     2206 
  4     1 /* BEGIN INCLUDE FILE ... driver_ptr_list.incl.pl1   */
  4     2 
  4     3 /* This is a list of pointers to the driver status segments used by this process */
  4     4 
  4     5 
  4     6 
  4     7 dcl list_ptr pointer;		/* should be set to iodd_static.driver_list_ptr */
  4     8 
  4     9 dcl 1 driver_ptr_list based(list_ptr),
  4    10        2 number fixed bin,		/* number of pointer entries */
  4    11        2 list_pad fixed bin,		/* pad to even word boundry */
  4    12        2 stat_seg(0 refer(driver_ptr_list.number)),
  4    13           3 stat_segp ptr;		/* pointer to driver status seg(i) */
  4    14 
  4    15 
  4    16 /* END INCLUDE FILE ... driver_ptr_list.incl.pl1  */
     2207 
     2208 
  5     1 /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Coded by Robert S. Coren August 1973
  5     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  5    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  5    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  5    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  5    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  5    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  5    16*     to denote accounting ^= nothing.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 /* status data for a logical device driver */
  5    21 
  5    22 /* format: style4 */
  5    23 
  5    24 dcl  driver_status_ptr ptr;
  5    25 dcl  1 driver_status aligned based (driver_status_ptr),
  5    26        2 req_type_label char (32),			/* string to describe the request type */
  5    27        2 dev_name_label char (32),			/* string to describe the device */
  5    28        2 device_id char (32),				/* minor device name used by this logical driver */
  5    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  5    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  5    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  5    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  5    33        2 request_pending bit (36),			/* locking word for communication with coord */
  5    34 						/* 0 = ready for a request  */
  5    35 						/* driver pid = don't bug me */
  5    36 						/* coord  pid = got a request */
  5    37        2 status_flags,
  5    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  5    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  5    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  5    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  5    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  5    43          3 pad bit (31) unal,
  5    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  5    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  5    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  5    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  5    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  5    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  5    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  5    51 						/* for this logical driver */
  5    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  5    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  5    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  5    55        2 dev_out_stream char (32),			/* output stream for minor device */
  5    56        2 dev_in_stream char (32),			/* input stream for minor device */
  5    57        2 elem_size fixed bin,				/* element size for the stream */
  5    58        2 message_type fixed bin,			/* expected format of user request */
  5    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  5    60        2 forms_validation_ptr ptr,			/* forms validation data */
  5    61        2 dev_ptr1 ptr,				/* another one */
  5    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  5    63        2 dev_fb2 fixed bin,				/* and another */
  5    64        2 dev_fb3 fixed bin,				/* and another */
  5    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  5    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  5    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  5    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  5    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  5    70        2 generic_type char (32),			/* generic type of this minor device */
  5    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  5    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  5    73        2 desc_pad (13) fixed bin,
  5    74        2 message fixed bin;				/* place-holder for copy of request message */
  5    75 
  5    76 
  5    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
     2209 
     2210 
  6     1 /* BEGIN INCLUDE FILE. . . iod_event_message.incl.pl1 */
  6     2 
  6     3 /* Format of event message used to signal io_daemon coordinator */
  6     4 /* and the acknowledge message for signalling the driver */
  6     5 
  6     6 dcl event_message fixed bin(71);
  6     7 
  6     8 dcl 1 ev_msg based aligned,
  6     9 	2 code fixed bin(17) unal,		/* Purpose of wakeup: */
  6    10 					/* 0 = request completed */
  6    11 					/* 1 = request completed, new request wanted */
  6    12 					/* 2 = restart */
  6    13 					/* 3 = save  */
  6    14 					/* 4 = logout */
  6    15 	2 minor_dev_index fixed bin(17) unal,	/* minor device index for driver sending this message */
  6    16 	2 seq_id fixed bin(35);		/* id of request to be restarted/saved */
  6    17 
  6    18 dcl 1 ack_msg aligned based,			/* driver command acknowledgement message */
  6    19 	2 code fixed bin (35),		/* error_table_ code */
  6    20 	2 num fixed bin (35);		/* number for further info */
  6    21 
  6    22 /* END INCLUDE FILE. . . iod_event_message.incl.pl1 */
     2211 
     2212 
  7     1 /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  7     7*     Ancient History
  7     8*     Created by J. Stern, 1/20/75
  7     9*     Modified by J. C. Whitmore April 1978 for enhancements
  7    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  7    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  7    12*     q_group_tab
  7    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  7    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  7    15*     Change version number to reflect changes in q_group_tab and
  7    16*     iod_device_tab for laser printer support.  Added font tables.
  7    17*                                                   END HISTORY COMMENTS */
  7    18 
  7    19 
  7    20 /* format: style4 */
  7    21 
  7    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  7    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  7    24        2 version char (8),				/* version of this structure */
  7    25        2 date_time_compiled fixed bin (71),
  7    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  7    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  7    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  7    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  7    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  7    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  7    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  7    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  7    34        2 text_strings_offset fixed bin (18),
  7    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  7    36 
  7    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  7    38 dcl  text_strings_ptr ptr;
  7    39 dcl  1 text_strings aligned based (text_strings_ptr),
  7    40        2 length fixed bin,
  7    41        2 chars char (1 refer (text_strings.length)) unaligned;
  7    42 
  7    43 /* this defines text offsets used to locate i/o daemon tables strings in
  7    44*   the text_strings structure */
  7    45 dcl  1 text_offset based,
  7    46        2 first_char fixed bin (18) unsigned unaligned,
  7    47        2 total_chars fixed bin (18) unsigned unaligned;
  7    48 
  7    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  7    50 
  7    51 
  7    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
     2213 
     2214 
  8     1 /* ..... BEGIN INCLUDE FILE  ...  iodd_comm.incl.pl1  ..... */
  8     2 
  8     3 /* structure used by a driver to send a command/request to the coordinator */
  8     4 
  8     5 dcl  comm_ptr ptr;
  8     6 
  8     7 dcl 1 iodd_comm aligned based (comm_ptr),
  8     8      2 ack_chan fixed bin (71),			/* IPC event channel for coord to return status code */
  8     9      2 type fixed bin,				/* command/request type code
  8    10*						   0 = reserved [done & wait (direct - special ev chan)]
  8    11*						   1 = reserved [done & next   (also direct)]
  8    12*						   2 = restart - single or series
  8    13*						   3 = save - single or series
  8    14*						   4 = reserved [driver logout (direct)]
  8    15*						   5 = reserved [get cmd ev chan (direct)]
  8    16*						   6 = next_req - run a given request next
  8    17*						   7 = restart_q - back to first messages in my queues
  8    18*						*/
  8    19      2 type_ext bit (36),				/* defined by each command type */
  8    20      2 minor_idx fixed bin,				/* index of minor device sending this request */
  8    21      2 dvc_idx fixed bin,				/* index of associated device class */
  8    22      2 request_no fixed bin,				/* request number for save/restart */
  8    23      2 queue_no fixed bin,				/* specified queue for next_req */
  8    24      2 user_id char (32),				/* sender id for next_req */
  8    25      2 req_id char (24),				/* request id from -id arg */
  8    26      2 pad_space (3) fixed bin,
  8    27      2 data_len fixed bin,				/* length of following string */
  8    28      2 data char (256 refer (iodd_comm.data_len));		/* data for command type if needed */
  8    29 
  8    30 dcl restart fixed bin int static options (constant) init (2);
  8    31 dcl save fixed bin int static options (constant) init (3);
  8    32 dcl next_req fixed bin int static options (constant) init (6);
  8    33 dcl restart_q fixed bin int static options (constant) init (7);
  8    34 
  8    35 
  8    36 /* ..... END INCLUDE FILE  ...  iodd_comm.incl.pl1  ..... */
     2215 
     2216 
  9     1 /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  9     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  9     7*     Add support for logout_on_hangup option.
  9     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  9     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  9    10*     Add head/tail_sheet entry variables and paper_type variable.
  9    11*                                                   END HISTORY COMMENTS */
  9    12 
  9    13 /* format: style4 */
  9    14 
  9    15 dcl  stat_p int static ptr;
  9    16 
  9    17 dcl  1 iodd_static based (stat_p) aligned,
  9    18 
  9    19 /*    The first part is set only once for a device driver */
  9    20 
  9    21        2 ithp ptr,					/* pointer to iod tables header */
  9    22        2 ltp ptr,					/* pointer to line table */
  9    23        2 idtp ptr,					/* pointer to device tab */
  9    24        2 mdtp ptr,					/* pointer to minor device table */
  9    25        2 qgtp ptr,					/* pointer to q_group table */
  9    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  9    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  9    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  9    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  9    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  9    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  9    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  9    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  9    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  9    35        2 log_stream char (32),			/* stream name used for log output */
  9    36        2 master_input char (32),			/* master console input stream for commands */
  9    37        2 master_output char (32),			/* master console output stream for messages */
  9    38        2 master_out ptr,				/* master output iocbp */
  9    39        2 master_in ptr,				/* master input iocbp */
  9    40        2 log_iocbp ptr,				/* log output iocbp */
  9    41        2 error_io ptr,				/* error i/o iocbp */
  9    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  9    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  9    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  9    45        2 device_dim char (32),			/* dim which drives the major device */
  9    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  9    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  9    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  9    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  9    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  9    51        2 major_device char (32),			/* name of the major device */
  9    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  9    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  9    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  9    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  9    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  9    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  9    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  9    59 
  9    60 /*    driver module entrypoints are defined by the following entry variables */
  9    61 
  9    62        2 driver_init entry variable options (variable),
  9    63        2 driver_request entry variable options (variable),
  9    64        2 driver_command entry variable options (variable),
  9    65        2 driver_default_handler entry variable options (variable),
  9    66 
  9    67 /*    entrypoints for head/tail_sheet_ entries */
  9    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  9    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  9    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  9    71 
  9    72        2 paper_type fixed bin,			/* type of paper being used */
  9    73 						/* 1 = single sheet */
  9    74 						/* 2 = continuous forms */
  9    75 
  9    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  9    77 
  9    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  9    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  9    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  9    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  9    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  9    83        2 output_device char (32),			/* name of minor device currently in use */
  9    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  9    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  9    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  9    87        2 segptr ptr,				/* ptr to current user segment being processed */
  9    88        2 flags,					/* control flags */
  9    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  9    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  9    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  9    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  9    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  9    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  9    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  9    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  9    97          3 step bit (1) unal,				/* run in step mode */
  9    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  9    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  9   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  9   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  9   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  9   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  9   104          3 pad bit (21) unal,				/* unused space */
  9   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  9   106          3 slave_input char (32),			/* slave input stream name */
  9   107          3 slave_output char (32),			/* slave output stream name */
  9   108          3 slave_pad fixed bin,			/* allocation breakage */
  9   109          3 slave_in ptr,				/* slave input iocbp */
  9   110          3 slave_out ptr,				/* slave output iocbp */
  9   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  9   112          3 active bit (1) unal,			/* on if there is a slave */
  9   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  9   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  9   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  9   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  9   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  9   118          3 priv2 bit (1) unal,
  9   119          3 priv3 bit (1) unal,
  9   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  9   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  9   122        2 ctl_term,					/* control terminal data */
  9   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  9   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  9   125          3 ctl_pad fixed bin,				/* allocation breakage */
  9   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  9   127          3 ctl_input char (32),			/* ctl input stream name */
  9   128          3 ctl_output char (32),			/* ctl output stream name */
  9   129          3 ctl_io char (32),				/* ctl i/o stream name */
  9   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  9   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  9   132          3 ctl_device char (32),			/* ctl terminal device name */
  9   133          3 form_type char (16),			/* format type if printing forms */
  9   134          3 attached bit (1) unal,			/* ctl term attached to process */
  9   135          3 forms bit (1) unal,			/* on if printing forms */
  9   136          3 pad bit (34) unal,
  9   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  9   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  9   139 
  9   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
     2217 
     2218 
 10     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
 10     2 /* format: style3,idind30 */
 10     3 
 10     4 /* structure returned when message is read from a message segment */
 10     5 
 10     6 
 10     7 dcl	mseg_message_info_ptr	pointer;
 10     8 
 10     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
 10    10 	  2 version		char (8) aligned,
 10    11 	  2 message_code		fixed bin,
 10    12 	  2 control_flags		unaligned,
 10    13 	    3 own			bit (1),
 10    14 	    3 delete		bit (1),
 10    15 	    3 pad			bit (34),
 10    16 	  2 ms_ptr		ptr,		/* pointer to message */
 10    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
 10    18 	  2 ms_id			bit (72),		/* unique ID of message */
 10    19 						/* input in some cases */
 10    20 	  2 ms_access_class		bit (72),		/* message access class */
 10    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
 10    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
 10    23 	  2 sender_level		fixed bin,	/* validation level of sender */
 10    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
 10    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
 10    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
 10    27 
 10    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
 10    29 
 10    30 declare	(
 10    31 	MSEG_READ_FIRST		init (1),
 10    32 	MSEG_READ_LAST		init (2),
 10    33 	MSEG_READ_SPECIFIED		init (3),
 10    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
 10    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
 10    36 	fixed bin int static options (constant);
 10    37 
 10    38 declare  (MSEG_READ_OWN		init ("1"b),
 10    39 	MSEG_READ_DELETE		init ("01"b)
 10    40 	)			bit (36) aligned internal static options (constant);
 10    41 
 10    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     2219 
     2220 
 11     1 /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 11     2 
 11     3 /* Descriptor associated with an I/O daemon request */
 11     4 /* Coded August 1973 by Robert S. Coren */
 11     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 11     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 11     7 
 11     8 dcl  1 request_descriptor based aligned,
 11     9 	2 mseg_message_info_copy like mseg_message_info,
 11    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 11    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 11    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 11    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 11    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 11    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 11    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 11    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 11    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 11    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 11    20 	2 driver_data bit(252),	/* driver maintained data */
 11    21 	2 flags,
 11    22 	   (3 continued,		/* unfinished by one driver and given to another */
 11    23 	    3 finished,
 11    24 	    3 restarted,
 11    25 	    3 cancelled,
 11    26 	    3 dont_delete,
 11    27 	    3 saved,		/* not to be freed */
 11    28 	    3 keep_in_queue,	/* keep request in queue */
 11    29 	    3 series_restart,	/* this request is part of restarted series */
 11    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 11    31 	    3 pad bit(27) unal,
 11    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 11    33 
 11    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
     2221 
     2222 
     2223      end iodd_command_processor_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1233.5  iodd_command_processor_.pl1       >special_ldd>install>MR12.2-1199>iodd_command_processor_.pl1
2201         1    02/27/84  1141.9  command_question_info.incl.pl1    >ldd>include>command_question_info.incl.pl1
2203         2    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
2205         3    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
2207         4    08/29/75  1310.5  driver_ptr_list.incl.pl1          >ldd>include>driver_ptr_list.incl.pl1
2209         5    10/28/88  1226.9  driver_status.incl.pl1            >special_ldd>install>MR12.2-1199>driver_status.incl.pl1
2211         6    09/28/78  1359.8  iod_event_message.incl.pl1        >ldd>include>iod_event_message.incl.pl1
2213         7    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
2215         8    09/28/78  1359.8  iodd_comm.incl.pl1                >ldd>include>iodd_comm.incl.pl1
2217         9    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
2219        10    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
2221        11    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_ptr                                  parameter       pointer                  dcl 1863 ref 1860 1865
accept_input            342(01)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  460* 1592* 1605*
ack_chan                               based           fixed bin(71,0)          level 2 dcl 8-7 set ref 2143*
ack_msg                                based           structure                level 1 dcl 6-18
active                  342            based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref 398
                                                                                  451 453* 633 931 963 1284 1312 1472 1521 1541 1560
                                                                                  2107
addr                                                   builtin function         dcl 195 ref 230 244 244 347 347 391 491 493 516 518
                                                                                  561 563 583 583 584 586 616 774 854 854 1375 1405
                                                                                  1523 1665 1667 1842 1842 1882 1944 2002 2002 2174
                                                                                  2174 2174 2174 2189
admin_ec_name           437            based           char(32)                 level 2 dcl 9-17 set ref 1813 1826 1831 1834*
after                                                  builtin function         dcl 195 ref 1090
allow_quits             342(02)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  457* 1593 1618* 1628*
answer_iocbp            126            based           pointer                  level 2 dcl 1-13 set ref 2024*
any_other                       001526 stack reference condition                dcl 217 ref 1787
arg_list                        000562 automatic       structure                level 1 dcl 104 set ref 244 244 347 347 854 854
args                     23     000562 automatic       varying char(64)         array level 2 dcl 104 set ref 364 445 481 510 537
                                                                                  537 540 547 549 554 557 573 573 581 655 661* 666
                                                                                  671* 675 732 735 762 762 766* 777* 781* 871 874
                                                                                  922 925 995 995 1004 1006 1010* 1014 1014 1028
                                                                                  1030 1031 1034 1034 1048 1050 1051 1052 1055* 1059
                                                                                  1068 1070 1078 1087 1089 1090 1100 1100 1109 1111*
                                                                                  1121 1121* 1124* 1214 1214 1222* 1244* 1247* 1327
                                                                                  1331 1334 1433* 1573 1579 1579 1585 1589 1598 1598
                                                                                  1602 1611 1615 1621 1621 1625 1631 1636 1636 1641
                                                                                  1646 1646 1651 1659 1675 1704 1704 1707 1766 1768
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 9-17 ref 645 655 753 970 1138 1205 1372
                                                                                  1424 1723 1734 1747 1878 1902 1967
att_desc                        000100 automatic       char(64)                 packed unaligned dcl 68 set ref 1801* 1803* 2050*
                                                                                  2056* 2064* 2068* 2074* 2089* 2095* 2103* 2107*
                                                                                  2109* 2115*
attach_name             136            based           char(32)                 level 2 dcl 9-17 set ref 1719*
attach_type             146            based           fixed bin(17,0)          level 2 dcl 9-17 ref 1719
attached                436            based           bit(1)                   level 3 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 9-17 in procedure
                                                                                  "iodd_command_processor_" set ref 439 469* 937
attached                 47            based           bit(1)                   level 3 in structure "driver_status" packed packed
                                                                                  unaligned dcl 5-25 in procedure
                                                                                  "iodd_command_processor_" ref 1225 1736 1749 1904
                                                                                  1937
auto_logout_interval    263            based           fixed bin(17,0)          level 2 dcl 9-17 set ref 891* 895
auto_start_delay        302            based           fixed bin(71,0)          level 2 dcl 9-17 set ref 370* 373*
bad_chars                       000010 constant        char(5)                  initial packed unaligned dcl 158 ref 1779
before                                                 builtin function         dcl 195 ref 1089 1090
bit_rate_est            132            based           fixed bin(35,0)          level 2 dcl 5-25 ref 685
both                            000167 constant        fixed bin(17,0)          initial dcl 145 set ref 494* 519* 564* 587* 1668*
                                                                                  2119* 2183*
busy                     47(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-25 set ref
                                                                                  1279* 1394 1916*
cancelled                53(03)        based           bit(1)                   level 3 packed packed unaligned dcl 11-8 set ref
                                                                                  402* 1526*
chan                      2     001332 automatic       fixed bin(71,0)          array level 2 dcl 110 set ref 2171* 2172*
change_data                     000221 automatic       bit(1)                   packed unaligned dcl 71 set ref 650* 655* 657* 659
                                                                                  674* 678
chn_type                        000000 constant        char(8)                  initial array packed unaligned dcl 159 set ref 1719*
cleanup                         001534 stack reference condition                dcl 217 ref 1788
cmd                       2     000562 automatic       varying char(64)         level 2 dcl 104 set ref 265 275 275 277 279 281 281
                                                                                  283 285 287 287 289 291 293 295 297 297 299 301
                                                                                  303 305 305 307 309 311 311 313 315 317 317 319
                                                                                  321 321 323 325 327 329 331 331 333 335 337 339
                                                                                  345
cmd_ack_chan            170            based           fixed bin(71,0)          level 2 dcl 9-17 set ref 2143 2154* 2171
code                            000100 automatic       fixed bin(35,0)          dcl 2085 in procedure "reattach_master" set ref
                                                                                  2087* 2091* 2092 2095* 2096 2099* 2100 2103* 2104
                                                                                  2111* 2112 2115* 2116 2119*
code                                   parameter       fixed bin(35,0)          dcl 2046 in procedure "swap_user_io_streams" set ref
                                                                                  2043 2048* 2052* 2053 2056* 2057 2070* 2071 2074*
code                                   based           fixed bin(17,0)          level 2 in structure "ev_msg" packed packed
                                                                                  unaligned dcl 6-8 in procedure
                                                                                  "iodd_command_processor_" set ref 1406*
code                                   parameter       fixed bin(35,0)          dcl 1961 in procedure "find_minor_dev" set ref 1956
                                                                                  1965* 1972*
code                            000120 automatic       fixed bin(35,0)          dcl 69 in procedure "iodd_command_processor_" set
                                                                                  ref 661* 662 671* 672 766* 767 1111* 1112 1161*
                                                                                  1162 1162* 1222* 1223 1350* 1351 1353 1355 1357
                                                                                  1359* 1366* 1411* 1414 1433* 1434 1455* 1457 1457*
                                                                                  1548* 1815* 1825 1842* 1843
code                                   parameter       fixed bin(35,0)          dcl 2138 in procedure "send_coord_msg" set ref 2135
                                                                                  2146* 2148 2154* 2156* 2161* 2162 2174* 2179 2181*
                                                                                  2183* 2190* 2194*
code                            000106 automatic       fixed bin(35,0)          dcl 1997 in procedure "x_cmd_handler" set ref 2002*
                                                                                  2007*
code                                   based           fixed bin(35,0)          level 2 in structure "ack_msg" dcl 6-18 in procedure
                                                                                  "iodd_command_processor_" ref 2190
code                                   based           fixed bin(35,0)          level 2 in structure "st" dcl 100 in procedure
                                                                                  "iodd_command_processor_" ref 491 493 516 518 561
                                                                                  563 584 586 1665 1667
comm_ptr                        001722 automatic       pointer                  dcl 8-5 set ref 230* 991 1006 1007 1007 1030 1031
                                                                                  1050 1051 1070 1071 1074 1097 1117 1144 1157 1158
                                                                                  1325 1338 1339 1340 1341 1343 1345 1346 1347 1363
                                                                                  1436 1437 1440 1441 1446 1447 1448 1449 1450 1451
                                                                                  1452 1505 2143 2144 2146*
command                         000121 automatic       char(256)                dcl 70 set ref 1837* 1842 1842 1842 1842
command_line                           parameter       char                     packed unaligned dcl 62 set ref 16 244* 533 594 947
                                                                                  947 947 947 1546 1546 1546 1546 1779 1837 1837
command_question_info                  based           structure                level 1 dcl 1-13
cond_info                       001350 automatic       structure                level 1 dcl 130 set ref 2002 2002
condition_info                         based           structure                level 1 dcl 2-14
condition_info_header                  based           structure                level 1 dcl 3-6
condition_name            3     001350 automatic       varying char(32)         level 2 dcl 130 set ref 2004
continue_to_signal_             000012 constant        entry                    external dcl 164 ref 2007
conversion                      001402 stack reference condition                dcl 214 ref 232
convert                                                builtin function         dcl 195 ref 364 581 694 732 871 1006 1331 1334
convert_ipc_code_               000014 constant        entry                    external dcl 165 ref 2181
coord_chan               40            based           fixed bin(71,0)          level 2 dcl 5-25 set ref 1411*
coord_cmd_chan          166            based           fixed bin(71,0)          level 2 dcl 9-17 set ref 2161*
coord_msg                       001550 automatic       fixed bin(71,0)          array dcl 223 set ref 230 990*
coord_proc_id            24            based           bit(36)                  level 2 dcl 9-17 set ref 774 1234 1385 1411* 1884
                                                                                  1909 1942 2161*
cq_info_ptr                     001714 automatic       pointer                  dcl 1-42 set ref 2019* 2020 2022 2024 2025
cq_info_version_5                      constant        fixed bin(17,0)          initial dcl 221 ref 2020
ctl_dev_dim             410            based           char(32)                 level 3 dcl 9-17 set ref 486*
ctl_input               360            based           char(32)                 level 3 dcl 9-17 set ref 468* 472* 490*
ctl_io                  400            based           char(32)                 level 3 dcl 9-17 set ref 449* 466* 473* 488* 490*
ctl_output              370            based           char(32)                 level 3 dcl 9-17 set ref 451 467* 471* 488* 515*
                                                                                  560* 583*
ctl_term                344            based           structure                level 2 dcl 9-17
cu_$cp                          000016 constant        entry                    external dcl 166 ref 1842
current_devices         266            based           fixed bin(17,0)          level 2 dcl 9-17 set ref 769* 769 804 1229* 1229
                                                                                  1240* 1240 1887* 1900* 1907* 1907
currentsize                                            builtin function         dcl 195 ref 2144
daemon_again                    001440 stack reference condition                dcl 214 ref 1314
daemon_again_slave              001470 stack reference condition                dcl 214 ref 1316
daemon_cancel                   001446 stack reference condition                dcl 214 ref 404
daemon_defer                    001504 stack reference condition                dcl 214 ref 635
daemon_kill                     001454 stack reference condition                dcl 214 ref 406
daemon_logout                   001424 stack reference condition                dcl 214 ref 940 1491
daemon_new_device               001462 stack reference condition                dcl 214 ref 966
daemon_save                     001542 stack reference condition                dcl 217 ref 1397 1529
daemon_slave_logout             001432 stack reference condition                dcl 214 ref 937
data                     32            based           char                     level 2 dcl 8-7 set ref 1031* 1051*
data_len                 31            based           fixed bin(17,0)          level 2 dcl 8-7 set ref 1030* 1031 1050* 1051 1338*
                                                                                  1450* 2144
debug                           000020 constant        entry                    external dcl 167 ref 605
defer_time_limit        133            based           fixed bin(35,0)          level 2 dcl 5-25 set ref 680 682 697*
desc_ptr                        000224 automatic       pointer                  dcl 73 set ref 391* 392 402 616* 617 629 630 1375*
                                                                                  1378 1387 1523* 1524 1525 1526 1944* 1946
descriptor              146            based           structure                level 2 dcl 5-25 set ref 391 616 1375 1523 1944
dev                             001347 automatic       bit(1)                   level 2 packed packed unaligned dcl 122 set ref 1102
                                                                                  1108* 1136 1143*
dev_id                                 parameter       varying char             dcl 1959 ref 1956 1969 1973
dev_index                51            based           fixed bin(17,0)          level 2 dcl 5-25 ref 1117 1144 1343 1407 1436 1440
device_id                20            based           char(32)                 level 2 dcl 5-25 set ref 1738 1738 1752* 1969
device_id_length                000555 automatic       fixed bin(17,0)          dcl 95 set ref 1733* 1738 1738* 1744 1752*
divide                                                 builtin function         dcl 195 ref 688 688 880 895 1370 1381
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 11-8 set ref
                                                                                  392*
dr_ptr                                 parameter       pointer                  dcl 1960 in procedure "find_minor_dev" set ref 1956
                                                                                  1968* 1969
dr_ptr                          000222 automatic       pointer                  dcl 72 in procedure "iodd_command_processor_" set
                                                                                  ref 390* 391 651* 661* 667* 671* 680 682 685 697
                                                                                  766* 769 772 774 774 1111* 1117 1222* 1225 1227
                                                                                  1231 1234 1234 1234 1240 1242 1342* 1343 1345
                                                                                  1374* 1375 1385 1389 1389 1392 1394 1402 1407 1411
                                                                                  1433* 1436 1437 1725* 1726 1735* 1736 1738 1738
                                                                                  1740 1740 1748* 1749 1752 1752 1880* 1881 1882
                                                                                  1884 1903* 1904 1906 1909 1909 1909 1915 1916 1934
                                                                                  1937 1942 1944 1945
driver_command          220            based           entry variable           level 2 dcl 9-17 ref 347 854
driver_list_ptr          16            based           pointer                  level 2 dcl 9-17 ref 748 1200 1294 1484 1500 1713
                                                                                  1966
driver_proc_id           25            based           bit(36)                  level 2 dcl 9-17 ref 774 1392 1882
driver_ptr              304            based           pointer                  level 2 dcl 9-17 ref 390 616 651 667 1144 1279 1342
                                                                                  1440 1441 1523 1725 1945
driver_ptr_list                        based           structure                level 1 unaligned dcl 4-9
driver_status                          based           structure                level 1 dcl 5-25
dvc_idx                   5            based           fixed bin(17,0)          level 2 dcl 8-7 set ref 1345* 1437* 1441*
ec                                     parameter       fixed bin(35,0)          dcl 63 set ref 16 244* 246 248 250* 344* 347* 350
                                                                                  352 352 352* 396* 398* 422* 493* 494* 518* 519*
                                                                                  563* 564* 586* 587* 631* 633* 744* 798* 854* 934*
                                                                                  1188* 1282* 1284* 1310* 1312* 1470* 1472* 1519*
                                                                                  1521* 1530* 1667* 1668* 1674* 1692* 1783* 1792*
                                                                                  1793 1802* 1803* 1804 1825* 1843* 1986* 2060* 2061
                                                                                  2064* 2065
ec_name                         000226 automatic       char(32)                 packed unaligned dcl 74 set ref 1813* 1815* 1821*
                                                                                  1831 1833* 1834 1837
echo_cmd                342(08)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  1643* 1648*
err_mess                        000244 automatic       char(128)                packed unaligned dcl 79 set ref 254* 255* 345* 384*
                                                                                  410* 428* 435* 441* 476* 506* 525* 533* 577* 594*
                                                                                  609* 620* 626* 638* 647* 708* 714* 720* 729* 735*
                                                                                  756* 794* 806* 874* 918* 925* 959* 977* 984* 1115*
                                                                                  1140* 1151* 1160* 1162* 1180* 1195* 1208* 1258*
                                                                                  1274* 1290* 1300* 1319* 1348* 1353* 1355* 1357*
                                                                                  1359* 1427* 1453* 1457* 1479* 1496* 1511* 1534*
                                                                                  1552* 1556* 1563* 1569* 1675* 1689* 1696* 1707*
                                                                                  1771* 1795* 1806* 1826* 1973* 2150* 2195*
error_flag                      000304 automatic       bit(1)                   packed unaligned dcl 80 set ref 988* 999* 1009*
                                                                                  1018* 1023* 1038* 1043* 1054* 1063* 1073* 1082*
                                                                                  1094* 1104* 1114* 1128* 1133 1147* 1149
error_table_$action_not_performed
                                000104 external static fixed bin(35,0)          dcl 204 ref 1357
error_table_$namedup            000102 external static fixed bin(35,0)          dcl 203 ref 1353
error_table_$noarg              000076 external static fixed bin(35,0)          dcl 201 ref 248
error_table_$noentry            000100 external static fixed bin(35,0)          dcl 202 ref 1355 1972
error_table_$request_not_recognized
                                000106 external static fixed bin(35,0)          dcl 205 ref 2194
et                        0(04) 001347 automatic       bit(1)                   level 2 packed packed unaligned dcl 122 set ref 1021
                                                                                  1027* 1036 1147
ev_chan_list                    001332 automatic       structure                level 1 dcl 110 set ref 2174 2174
ev_msg                                 based           structure                level 1 dcl 6-8
event_info                      001340 automatic       structure                level 1 dcl 115 set ref 2174 2174
event_message                   001720 automatic       fixed bin(71,0)          dcl 6-6 set ref 1404* 1405 1411* 2159* 2161*
find_condition_info_            000022 constant        entry                    external dcl 168 ref 2002
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-8 set ref
                                                                                  629* 1387* 1525*
fixed                                                  builtin function         dcl 195 ref 694 1407
fixed_bin                              based           fixed bin(17,0)          dcl 136 ref 364 581 732 871 1006
fixed_bin_35                           based           fixed bin(35,0)          dcl 137 ref 1331 1334
flags                   310            based           structure                level 2 in structure "iodd_static" dcl 9-17
                                                                                  in procedure "iodd_command_processor_"
flags                    53            based           structure                level 2 in structure "request_descriptor" dcl 11-8
                                                                                  in procedure "iodd_command_processor_"
float                                                  builtin function         dcl 195 ref 682 699
floating                               based           float bin(27)            dcl 135 ref 694
form_type               432            based           char(16)                 level 3 dcl 9-17 set ref 542* 547* 549*
forms                   436(01)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  470* 484 499* 513 575
hcs_$initiate                   000026 constant        entry                    external dcl 170 ref 1815
hcs_$wakeup                     000030 constant        entry                    external dcl 171 ref 1411 2161
header                                 based           structure                level 2 dcl 1-13
i                               000531 automatic       fixed bin(17,0)          dcl 85 in procedure "iodd_command_processor_" set
                                                                                  ref 581* 583 583 682* 732* 733 739 764* 766 777
                                                                                  781* 880* 882 884* 884 1213* 1214 1214* 1220* 1222
                                                                                  1244 1247* 1372* 1374* 1734* 1735* 1747* 1748*
i                               001742 automatic       fixed bin(17,0)          dcl 1876 in procedure "halt_all" set ref 1878* 1880*
i                               001752 automatic       fixed bin(17,0)          dcl 1898 in procedure "ready_all" set ref 1902*
                                                                                  1903*
id                        0(03) 001347 automatic       bit(1)                   level 2 packed packed unaligned dcl 122 set ref 1061
                                                                                  1067* 1147
idx                             000532 automatic       fixed bin(17,0)          dcl 86 set ref 993* 995 995 1004 1006 1010 1014 1014
                                                                                  1028 1030 1031 1034 1034 1048 1050 1051 1052 1055
                                                                                  1059 1068 1070 1078 1087 1089 1090 1100 1100 1109
                                                                                  1111 1121 1121 1124 1129* 1129*
index                                                  builtin function         dcl 195 ref 947 947 1546 1546 1837
info_ptr                 14     001350 automatic       pointer                  level 2 dcl 130 set ref 2019
io_daemon_version       174            based           char(8)                  level 2 dcl 9-17 set ref 1719*
io_stat                         000560 automatic       bit(72)                  dcl 98 set ref 449* 454* 456* 466* 467* 468* 488*
                                                                                  490* 491 493 515* 516 518 560* 561 563 583* 584
                                                                                  586 1576* 1582* 1664* 1665 1667
ioa_                            000034 constant        entry                    external dcl 173 ref 2035
ioa_$rsnnl                      000036 constant        entry                    external dcl 173 ref 682 977 1947
iodc_$command_level             000060 constant        entry                    external dcl 185 ref 420
iodd_comm                              based           structure                level 1 dcl 8-7 set ref 2144
iodd_msg_                       000032 constant        entry                    external dcl 172 ref 234 240 255 367 373 494 501 519
                                                                                  564 568 587 603 688 699 777 781 787 812 816 817
                                                                                  818 819 820 821 822 823 824 825 826 827 828 829
                                                                                  830 831 832 833 834 835 836 837 838 839 840 841
                                                                                  845 846 847 848 849 850 851 856 884 898 900 929
                                                                                  933 947 951 963 1000 1010 1019 1024 1039 1044 1055
                                                                                  1064 1074 1083 1095 1105 1115 1121 1124 1162 1164
                                                                                  1174 1244 1247 1277 1359 1366 1457 1460 1546 1593
                                                                                  1606 1668 1670 1719 1726 1728 1744 1752 1758 1782
                                                                                  1833 1983 2119 2124 2183
iodd_parse_$command             000056 constant        entry                    external dcl 184 ref 244
iodd_static                            based           structure                level 1 dcl 9-17
ios_$attach                     000042 constant        entry                    external dcl 178 ref 454 488 490 1576 1582
ios_$changemode                 000046 constant        entry                    external dcl 180 ref 560 1664
ios_$detach                     000040 constant        entry                    external dcl 177 ref 456 466 467 468
ios_$order                      000044 constant        entry                    external dcl 179 ref 449 515 583
iox_$attach_ptr                 000050 constant        entry                    external dcl 181 ref 1803 2056 2064 2074 2095 2103
                                                                                  2115
iox_$control                    000052 constant        entry                    external dcl 182 ref 396 398 422 631 633 934 1188
                                                                                  1282 1284 1310 1312 1470 1472 1519 1521 1548
iox_$detach_iocb                000054 constant        entry                    external dcl 183 ref 1802 2052 2060 2070 2091 2099
                                                                                  2111
iox_$error_output               000114 external static pointer                  dcl 209 set ref 1802* 1803* 2060* 2064* 2111* 2115*
iox_$user_input                 000112 external static pointer                  dcl 208 set ref 2024 2070* 2074* 2099* 2103*
iox_$user_output                000110 external static pointer                  dcl 207 set ref 2022 2052* 2056* 2091* 2095*
ipc_$block                      000074 constant        entry                    external dcl 191 ref 2174
ipc_$drain_chn                  000072 constant        entry                    external dcl 190 ref 2154 2156
j                               002002 automatic       fixed bin(17,0)          dcl 1962 set ref 1967* 1968*
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 11-8 set ref
                                                                                  630*
last_wake_time           44            based           fixed bin(71,0)          level 2 dcl 5-25 set ref 1402*
len                             002020 automatic       fixed bin(17,0)          dcl 2140 in procedure "send_coord_msg" set ref 2144*
                                                                                  2146
len                             001772 automatic       fixed bin(17,0)          dcl 1931 in procedure "get_driver_status" set ref
                                                                                  1947*
len                             000533 automatic       fixed bin(17,0)          dcl 87 in procedure "iodd_command_processor_" set
                                                                                  ref 977*
length                                                 builtin function         dcl 195 ref 1030 1050 1738 1738 1740 1740 1842 1842
lg_sw                           000240 automatic       bit(1)                   dcl 76 set ref 1704* 1711* 1736 1749
list_ptr                        001716 automatic       pointer                  dcl 4-7 set ref 748* 1200* 1294* 1374 1484* 1490
                                                                                  1500* 1713* 1735 1748 1880 1903 1966* 1968
listen_cmd_level                       constant        fixed bin(17,0)          initial dcl 150 ref 705 788 1306 1515 1681
log_msg                 342(04)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  459* 1633* 1638*
logout                          000024 constant        entry                    external dcl 169 ref 2129
maj_index                52            based           fixed bin(17,0)          level 2 dcl 5-25 ref 1345 1437 1441
major_device            154            based           char(32)                 level 2 dcl 9-17 set ref 255* 1359 1366 1457 1719*
                                                                                  1983*
master                          000175 constant        fixed bin(17,0)          initial dcl 142 set ref 414 447 598 603* 790 863 912
                                                                                  929* 947* 951* 956 1169 1174* 1183 1253 1267 1270
                                                                                  1314 1466 1487 1541 1593* 1606* 1685 2124*
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref 380
                                                                                  394* 495* 520* 565* 588* 623 718 742* 790* 792
                                                                                  863* 912* 916 1253* 1256 1270* 1272 1287* 1297
                                                                                  1308* 1475* 1492* 1508 1517* 1685* 1687
master_in                70            based           pointer                  level 2 dcl 9-17 set ref 396* 422* 631* 1188* 1282*
                                                                                  1310* 1470* 1519*
max_args                        000562 automatic       fixed bin(17,0)          initial level 2 dcl 104 set ref 104*
message                         000305 automatic       char(64)                 packed unaligned dcl 81 set ref 680* 682* 688* 1656*
                                                                                  1660* 1670* 1715* 1717* 1719* 1727* 1728* 1751*
                                                                                  1752*
message_segment_$add_file       000062 constant        entry                    external dcl 186 ref 2146
minor_dev_index           0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-8 set ref
                                                                                  1407*
minor_idx                 4            based           fixed bin(17,0)          level 2 dcl 8-7 set ref 1117* 1144* 1343* 1436*
                                                                                  1440*
mod                                                    builtin function         dcl 195 ref 982
mode                            000331 automatic       char(256)                packed unaligned dcl 83 set ref 557* 560* 1655*
                                                                                  1659* 1664*
mseg_message_info                      based           structure                level 1 dcl 10-9
msg                       2     001340 automatic       fixed bin(71,0)          level 2 in structure "event_info" dcl 115
                                                                                  in procedure "iodd_command_processor_" set ref
                                                                                  2189
msg                                    parameter       char                     packed unaligned dcl 1981 in procedure "master_only"
                                                                                  set ref 1978 1983*
msg_id                          002022 automatic       bit(72)                  dcl 2141 set ref 2146* 2159
msgp                            000242 automatic       pointer                  dcl 78 set ref 1405* 1406 1407 2189* 2190 2191
n                         1     000562 automatic       fixed bin(17,0)          level 2 dcl 104 set ref 361 432 531 642 653 724 751
                                                                                  764 868 922 975 982 993 1203 1213 1220 1304 1424
                                                                                  1431 1503 1567 1653 1701 1763
next_req                               constant        fixed bin(17,0)          initial dcl 8-32 ref 1157
no_coord                        001410 stack reference condition                dcl 214 ref 1414
normal                          000175 constant        fixed bin(17,0)          initial dcl 146 set ref 234* 240* 255* 367* 373*
                                                                                  494* 501* 519* 564* 568* 587* 603* 688* 699* 777*
                                                                                  781* 787* 812* 816* 817* 818* 819* 820* 821* 822*
                                                                                  823* 824* 825* 826* 827* 828* 829* 830* 831* 832*
                                                                                  833* 834* 835* 836* 837* 838* 839* 840* 841* 845*
                                                                                  846* 847* 848* 849* 850* 851* 856* 884* 898* 900*
                                                                                  929* 933* 947* 951* 963* 1000* 1010* 1019* 1024*
                                                                                  1039* 1044* 1055* 1064* 1074* 1083* 1095* 1105*
                                                                                  1115* 1121* 1124* 1162* 1164* 1174* 1244* 1247*
                                                                                  1277* 1359* 1366* 1457* 1460* 1546* 1593* 1606*
                                                                                  1668* 1670* 1719* 1726* 1728* 1744* 1752* 1758*
                                                                                  1782* 1833* 1983* 2124* 2183*
null                                                   builtin function         dcl 195 ref 396 396 398 398 422 422 449 449 461 462
                                                                                  515 515 631 631 633 633 934 934 1188 1188 1282
                                                                                  1282 1284 1284 1310 1310 1312 1312 1470 1470 1472
                                                                                  1472 1519 1519 1521 1521 1548 1548 1803 1803 1817
                                                                                  2002 2002 2056 2056 2064 2064 2074 2074 2095 2095
                                                                                  2103 2103 2115 2115
null_cmd_level                         constant        fixed bin(17,0)          initial dcl 148 ref 712
null_stream                     000012 constant        char(32)                 initial packed unaligned dcl 156 ref 463 464 471 472
                                                                                  473
num                       1            based           fixed bin(35,0)          level 2 dcl 6-18 ref 2191
number                                 parameter       fixed bin(35,0)          dcl 2139 in procedure "send_coord_msg" set ref 2135
                                                                                  2191*
number                          001332 automatic       fixed bin(17,0)          level 2 in structure "ev_chan_list" dcl 110
                                                                                  in procedure "iodd_command_processor_" set ref
                                                                                  2170*
number                          000241 automatic       fixed bin(35,0)          dcl 77 in procedure "iodd_command_processor_" set
                                                                                  ref 364* 365 370 685* 688 688* 688 688 694* 695
                                                                                  695* 697 699 699 871* 872 872 878 882 891 895* 898
                                                                                  900* 900 970* 973* 975 977 1161* 1350* 1366 1366*
                                                                                  1455*
number                                 based           fixed bin(17,0)          level 2 in structure "driver_ptr_list" dcl 4-9
                                                                                  in procedure "iodd_command_processor_" set ref
                                                                                  1490*
omode                           000431 automatic       char(256)                packed unaligned dcl 84 set ref 558* 560* 568* 1662*
                                                                                  1664* 1670*
option                          001347 automatic       structure                level 1 dcl 122 set ref 989* 1158
pending                         001773 automatic       bit(1)                   packed unaligned dcl 1932 set ref 1945* 1947*
person                          000535 automatic       char(24)                 packed unaligned dcl 89 set ref 1089* 1092 1097
pn                        0(05) 001347 automatic       bit(1)                   level 2 packed packed unaligned dcl 122 set ref 1016
                                                                                  1041 1047* 1147
print_errors            342(03)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  458* 1575* 1581* 2107
probe                           000064 constant        entry                    external dcl 187 ref 1176 2125
program_interrupt               001476 stack reference condition                dcl 214 ref 1190
project                         000543 automatic       char(24)                 packed unaligned dcl 90 set ref 1090* 1092 1097
q                         0(01) 001347 automatic       bit(1)                   level 2 packed packed unaligned dcl 122 set ref 997
                                                                                  1003*
question_iocbp          124            based           pointer                  level 2 dcl 1-13 set ref 2022*
queue_no                  7            based           fixed bin(17,0)          level 2 dcl 8-7 set ref 1006* 1007 1007 1339* 1449*
quit_cmd_level                         constant        fixed bin(17,0)          initial dcl 152 ref 1593 1606
re_init                         001416 stack reference condition                dcl 214 ref 1262 2184
ready                    47(02)        based           bit(1)                   level 3 packed packed unaligned dcl 5-25 set ref 769
                                                                                  772* 1227 1231* 1240 1242* 1389 1881* 1906* 1915*
                                                                                  1934
repeat_time             130            based           fixed bin(71,0)          level 2 dcl 1-13 set ref 2025*
req_id                   20            based           char(24)                 level 2 dcl 8-7 set ref 991* 1070* 1071 1074* 1341*
                                                                                  1451*
req_type_label                         based           char(32)                 level 2 dcl 5-25 set ref 1726* 1740 1740 1752*
req_type_label_length           000556 automatic       fixed bin(17,0)          dcl 96 set ref 1733* 1740 1740* 1744 1752*
request_descriptor                     based           structure                level 1 dcl 11-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 ref 388 613
                                                                                  1277 1306 1397 1515 1945
request_no                6            based           fixed bin(17,0)          level 2 dcl 8-7 set ref 1346* 1448*
request_pending          46            based           bit(36)                  level 2 dcl 5-25 set ref 774 774 1234 1234 1234*
                                                                                  1385 1389* 1392* 1882 1884 1909 1909 1909* 1942
requests_til_cmd        264            based           fixed bin(17,0)          level 2 dcl 9-17 set ref 724* 739*
restart                                constant        fixed bin(17,0)          initial dcl 8-30 ref 1325
restart_q                              constant        fixed bin(17,0)          initial dcl 8-33 ref 1446
restart_series                  000551 automatic       fixed bin(35,0)          dcl 91 set ref 1370* 1383
restarted                53(02)        based           bit(1)                   level 3 packed packed unaligned dcl 11-8 ref 617
resume                          001512 stack reference condition                dcl 214 ref 1286 1399 1474
rtrim                                                  builtin function         dcl 195 ref 1097 1359 1366 1457 1738 1738 1740 1740
                                                                                  1826 1837 1837 1842 1842 2050 2068
runout_requests         310(10)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref 712
                                                                                  778* 785 1884*
save                                   constant        fixed bin(17,0)          initial dcl 8-31 ref 1363 1505
saved                    53(05)        based           bit(1)                   level 3 packed packed unaligned dcl 11-8 set ref
                                                                                  1524*
search                                                 builtin function         dcl 195 ref 1779
segp                            000236 automatic       pointer                  dcl 75 set ref 1815* 1817
seq_id                   32            based           fixed bin(35,0)          level 2 in structure "request_descriptor" dcl 11-8
                                                                                  in procedure "iodd_command_processor_" ref 1378
                                                                                  1946
seq_id                          000552 automatic       fixed bin(35,0)          dcl 92 in procedure "iodd_command_processor_" set
                                                                                  ref 1331* 1334* 1346 1366 1370 1946* 1947*
series                          000553 automatic       fixed bin(35,0)          dcl 93 set ref 1378* 1381* 1381 1383
series_sw                       000554 automatic       bit(1)                   packed unaligned dcl 94 set ref 1330* 1335* 1347
                                                                                  1363
signal_cmd_level                       constant        fixed bin(17,0)          initial dcl 154 ref 1267
size                            001520 stack reference condition                dcl 214 ref 238
slave                           000174 constant        fixed bin(17,0)          initial dcl 144 in procedure
                                                                                  "iodd_command_processor_" set ref 380 623 718 860
                                                                                  929 933* 937 944 963* 1297 1508 1546* 1587 1600
                                                                                  1613 1623 1790
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 9-17
                                                                                  in procedure "iodd_command_processor_"
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref
                                                                                  395* 743* 797* 860* 1281* 1309* 1396* 1469* 1518*
                                                                                  1684*
slave_in                334            based           pointer                  level 3 dcl 9-17 set ref 398* 462* 633* 1284* 1312*
                                                                                  1472* 1521*
slave_input             312            based           char(32)                 level 3 dcl 9-17 set ref 464* 2068
slave_out               336            based           pointer                  level 3 dcl 9-17 set ref 461* 934* 1548*
slave_output            322            based           char(32)                 level 3 dcl 9-17 set ref 451 456* 463* 1664* 2050
source                                 parameter       fixed bin(17,0)          dcl 60 set ref 16 234* 240* 255* 347* 367* 373* 380
                                                                                  414 447 501* 568* 598 623 688* 699* 718 777* 781*
                                                                                  787* 790 812* 816* 817* 818* 819* 820* 821* 822*
                                                                                  823* 824* 825* 826* 827* 828* 829* 830* 831* 832*
                                                                                  833* 834* 835* 836* 837* 838* 839* 840* 841* 845*
                                                                                  846* 847* 848* 849* 850* 851* 854* 856* 860 863
                                                                                  884* 898* 900* 912 929 937 944 956 1000* 1010*
                                                                                  1019* 1024* 1039* 1044* 1055* 1064* 1074* 1083*
                                                                                  1095* 1105* 1115* 1121* 1124* 1162* 1164* 1169
                                                                                  1183 1244* 1247* 1253 1267 1270 1277* 1297 1314
                                                                                  1359* 1366* 1457* 1460* 1466 1487 1508 1541 1587
                                                                                  1600 1613 1623 1670* 1685 1719* 1726* 1728* 1744*
                                                                                  1752* 1758* 1782* 1790 1833* 1983*
st                                     based           structure                level 1 dcl 100
stac                                                   builtin function         dcl 195 ref 774 1882
stat_p                          000010 internal static pointer                  dcl 9-15 set ref 255 347 370 373 380 388 390 394 395
                                                                                  396 398 398 414 422 439 449 451 451 451 453 456
                                                                                  457 458 459 460 461 462 463 464 466 467 468 469
                                                                                  470 471 472 473 484 486 488 488 490 490 495 499
                                                                                  513 515 520 542 547 549 560 565 575 583 588 598
                                                                                  613 616 623 631 633 633 645 651 655 667 712 718
                                                                                  724 727 739 742 743 748 753 769 769 774 774 778
                                                                                  785 790 792 797 804 843 854 860 863 880 891 895
                                                                                  912 916 931 934 937 963 970 1138 1144 1169 1183
                                                                                  1188 1200 1205 1229 1229 1234 1240 1240 1253 1256
                                                                                  1270 1272 1277 1279 1281 1282 1284 1284 1287 1294
                                                                                  1297 1306 1308 1309 1310 1312 1312 1342 1359 1366
                                                                                  1372 1385 1392 1396 1397 1411 1424 1440 1441 1457
                                                                                  1466 1469 1470 1472 1472 1475 1484 1487 1492 1500
                                                                                  1508 1515 1517 1518 1519 1521 1521 1523 1541 1548
                                                                                  1560 1575 1581 1592 1593 1605 1618 1628 1633 1638
                                                                                  1643 1648 1664 1684 1685 1687 1713 1715 1719 1719
                                                                                  1719 1719 1723 1725 1734 1747 1766 1768 1775 1813
                                                                                  1815 1826 1831 1834 1837 1865* 1878 1882 1884 1884
                                                                                  1887 1900 1902 1907 1907 1909 1942 1945 1945 1966
                                                                                  1967 1983 2029 2050 2068 2107 2107 2122 2143 2146
                                                                                  2154 2156 2161 2161 2167 2171 2172 2176
stat_seg                  2            based           structure                array level 2 unaligned dcl 4-9
stat_segp                 2            based           pointer                  array level 3 dcl 4-9 ref 1374 1735 1748 1880 1903
                                                                                  1968
state                                  parameter       fixed bin(17,0)          dcl 61 set ref 16 347* 705 712 788 854* 1267 1306
                                                                                  1515 1593 1606 1681
status                                 parameter       char                     packed unaligned dcl 1929 set ref 1923 1934* 1937*
                                                                                  1940* 1948*
status_flags             47            based           structure                level 2 dcl 5-25
step                    310(08)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 set ref 727
                                                                                  1715 1766* 1768* 1775*
string                          001762 automatic       char(32)                 packed unaligned dcl 1930 in procedure
                                                                                  "get_driver_status" set ref 1947* 1948
string                                                 builtin function         dcl 195 in procedure "iodd_command_processor_" set
                                                                                  ref 989* 1158
substr                                                 builtin function         dcl 195 set ref 533 594 947 947 1004 1028 1048 1052
                                                                                  1068 1087 1109 1121 1546 1546 1837 1948*
sys_dir                                based           char(168)                dcl 134 set ref 1815* 1837 2146*
sys_dir_ptr              22            based           pointer                  level 2 dcl 9-17 ref 1815 1837 2146
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 9-17 ref 414 598
                                                                                  843 1169 1183 1466 1487 2029 2122
text_offset                            based           structure                level 1 packed packed unaligned dcl 7-45
timer_chan              172            based           fixed bin(71,0)          level 2 dcl 9-17 set ref 2156* 2167* 2172 2176*
timer_manager_$alarm_wakeup     000066 constant        entry                    external dcl 188 ref 2167
timer_manager_$reset_alarm_wakeup
                                000070 constant        entry                    external dcl 189 ref 2176
tried_once                      000534 automatic       bit(1)                   packed unaligned dcl 88 set ref 1812* 1819 1822*
type                            000107 automatic       char(32)                 packed unaligned dcl 1998 in procedure
                                                                                  "x_cmd_handler" set ref 2004* 2005 2011 2013 2015
                                                                                  2017 2029 2032 2035*
type                      2            based           fixed bin(17,0)          level 2 in structure "iodd_comm" dcl 8-7
                                                                                  in procedure "iodd_command_processor_" set ref
                                                                                  1157* 1325* 1363 1446* 1505*
type_ext                  3            based           bit(36)                  level 2 dcl 8-7 set ref 1158* 1347* 1447*
unknown_cmd_code                       constant        fixed bin(35,0)          initial dcl 157 ref 344 350 1674 1783 1843 1986
unspec                                                 builtin function         dcl 195 set ref 2159*
user                      0(02) 001347 automatic       bit(1)                   level 2 packed packed unaligned dcl 122 set ref 1080
                                                                                  1086* 1147
user_id                  10            based           char(32)                 level 2 dcl 8-7 set ref 1097* 1340* 1452*
verify                                                 builtin function         dcl 195 ref 655 1071
version                   2     001350 automatic       fixed bin(17,0)          level 2 in structure "cond_info" dcl 130
                                                                                  in procedure "iodd_command_processor_" set ref
                                                                                  2000*
version                   1            based           fixed bin(17,0)          level 3 in structure "command_question_info"
                                                                                  dcl 1-13 in procedure "iodd_command_processor_"
                                                                                  ref 2020
wait_list_idx             6     001340 automatic       fixed bin(17,0)          level 2 dcl 115 set ref 2187
wakeup_time             300            based           fixed bin(71,0)          level 2 dcl 9-17 ref 880
what                            000325 automatic       char(16)                 packed unaligned dcl 82 set ref 377* 400 410 666*
                                                                                  675* 694 906*
whoami                          000022 constant        char(24)                 initial packed unaligned dcl 147 set ref 494* 519*
                                                                                  564* 587* 1668* 2119* 2183*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 7-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 10-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 10-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 10-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 10-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 10-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 10-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 10-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 10-30
condition_info_header_ptr              automatic       pointer                  dcl 3-4
condition_info_ptr                     automatic       pointer                  dcl 2-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 2-30
cq_info_version_7                      internal static fixed bin(17,0)          initial dcl 1-44
driver_status_ptr                      automatic       pointer                  dcl 5-24
iod_tables_hdr                         based           structure                level 1 dcl 7-23
ithp                                   automatic       pointer                  dcl 7-22
mseg_message_info_ptr                  automatic       pointer                  dcl 10-7
text_strings                           based           structure                level 1 dcl 7-39
text_strings_ptr                       automatic       pointer                  dcl 7-38

NAMES DECLARED BY EXPLICIT CONTEXT.
auto_start_delay_command        004325 constant        label                    dcl 361 ref 275
bad_ipc                         023061 constant        label                    dcl 2181 ref 2162
bad_order                       014032 constant        label                    dcl 1124 ref 1004 1028 1048 1068 1087 1109
cancel_command                  004452 constant        label                    dcl 377 ref 277
cancel_or_kill                  004455 constant        label                    dcl 380 ref 909
continue_signal                 021710 constant        label                    dcl 2007 ref 2011 2013 2029 2032
coord_command                   004631 constant        label                    dcl 414 ref 279
ctl_term_command                004704 constant        label                    dcl 432 ref 281
debug_command                   006170 constant        label                    dcl 598 ref 283
defer_command                   006246 constant        label                    dcl 613 ref 285
defer_time_command              006377 constant        label                    dcl 642 ref 287
error                           003644 constant        label                    dcl 255 ref 350 385 411 429 436 442 477 507 526 534
                                                                                  578 595 610 621 627 639 648 662 672 709 715 721
                                                                                  730 736 757 795 807 875 919 926 960 979 985 1141
                                                                                  1152 1181 1197 1209 1259 1275 1291 1301 1320 1428
                                                                                  1434 1481 1512 1535 1553 1557 1564 1570 1690 1697
                                                                                  1708 1772 1797 1808 1828 2119 2119
fatal_error                     022523 constant        label                    dcl 2119 ref 2092 2096 2100 2104 2112
find_minor_dev                  021472 constant        entry                    internal dcl 1956 ref 661 671 766 1111 1222 1433
get_driver_status               021342 constant        entry                    internal dcl 1923 ref 1727 1751
go_command                      006732 constant        label                    dcl 705 ref 289
halt_all                        021231 constant        entry                    internal dcl 1873 ref 753 762
halt_command                    007056 constant        label                    dcl 748 ref 291
help_command                    007413 constant        label                    dcl 812 set ref 293
hold_command                    011432 constant        label                    dcl 860 ref 295
ignore                          003636 constant        label                    dcl 250 ref 235 241 265 2039
inactive_limit_command          011450 constant        label                    dcl 868 ref 297
init                            021215 constant        entry                    external dcl 1860
iodd_command_processor_         003435 constant        entry                    external dcl 16
kill_command                    011725 constant        label                    dcl 906 ref 299
logout_command                  011731 constant        label                    dcl 912 ref 301
master_command                  012150 constant        label                    dcl 944 ref 303
master_only                     021564 constant        entry                    internal dcl 1978 ref 1589 1602 1615 1625
new_device_command              012273 constant        label                    dcl 956 ref 305
next_command                    012346 constant        label                    dcl 970 ref 307
once_more                       020622 constant        label                    dcl 1815 ref 1823
pass_on                         004262 constant        label                    dcl 347 ref 544 1676
pi_command                      014345 constant        label                    dcl 1183 ref 309
probe_command                   014267 constant        label                    dcl 1169 ref 311
ready_all                       021275 constant        entry                    internal dcl 1895 ref 1205 1216
ready_command                   014414 constant        label                    dcl 1200 ref 313
reattach_master                 022320 constant        entry                    internal dcl 2080 ref 1788 1796 1807 1827 1846 2037
reinit_command                  014671 constant        label                    dcl 1253 ref 315
release_command                 014715 constant        label                    dcl 1267 ref 317
restart_command                 015111 constant        label                    dcl 1294 ref 319
restart_or_save                 015256 constant        label                    dcl 1327 ref 1506
restart_q_command               015700 constant        label                    dcl 1424 ref 321
resume_command                  016105 constant        label                    dcl 1466 ref 323
return_command                  016217 constant        label                    dcl 1484 ref 325
save_command                    016247 constant        label                    dcl 1500 ref 327
send_coord_msg                  022637 constant        entry                    internal dcl 2135 ref 1161 1350 1455
slave_command                   016422 constant        label                    dcl 1541 ref 329
slave_term_command              016561 constant        label                    dcl 1560 ref 331
start_command                   017520 constant        label                    dcl 1681 ref 333
status_command                  017552 constant        label                    dcl 1701 ref 335
step_command                    020333 constant        label                    dcl 1763 ref 337
swap_user_io_streams            022025 constant        entry                    internal dcl 2043 ref 1792
x_cmd_handler                   021654 constant        entry                    internal dcl 1994 ref 1787
x_command                       020374 constant        label                    dcl 1779 ref 339

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     24500       24616   24027       24510
Length     25562   24027       116         727     451           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iodd_command_processor_            1392 external procedure  is an external procedure.  
on unit on line 232                  98 on unit               
on unit on line 238                 100 on unit               
on unit on line 1787                120 on unit               
on unit on line 1788                 64 on unit               
halt_all                                internal procedure  shares stack frame of external procedure iodd_command_processor_.  
ready_all                               internal procedure  shares stack frame of external procedure iodd_command_processor_.  
get_driver_status                       internal procedure  shares stack frame of external procedure iodd_command_processor_.  
find_minor_dev                          internal procedure  shares stack frame of external procedure iodd_command_processor_.  
master_only                         114 internal procedure  is called during a stack extension.  
x_cmd_handler                           internal procedure  shares stack frame of on unit on line 1787.  
swap_user_io_streams                    internal procedure  shares stack frame of external procedure iodd_command_processor_.  
reattach_master                     115 internal procedure  is called by several nonquick procedures.  
send_coord_msg                          internal procedure  shares stack frame of external procedure iodd_command_processor_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 stat_p                      iodd_command_processor_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
iodd_command_processor_  000100 att_desc                    iodd_command_processor_
                         000120 code                        iodd_command_processor_
                         000121 command                     iodd_command_processor_
                         000221 change_data                 iodd_command_processor_
                         000222 dr_ptr                      iodd_command_processor_
                         000224 desc_ptr                    iodd_command_processor_
                         000226 ec_name                     iodd_command_processor_
                         000236 segp                        iodd_command_processor_
                         000240 lg_sw                       iodd_command_processor_
                         000241 number                      iodd_command_processor_
                         000242 msgp                        iodd_command_processor_
                         000244 err_mess                    iodd_command_processor_
                         000304 error_flag                  iodd_command_processor_
                         000305 message                     iodd_command_processor_
                         000325 what                        iodd_command_processor_
                         000331 mode                        iodd_command_processor_
                         000431 omode                       iodd_command_processor_
                         000531 i                           iodd_command_processor_
                         000532 idx                         iodd_command_processor_
                         000533 len                         iodd_command_processor_
                         000534 tried_once                  iodd_command_processor_
                         000535 person                      iodd_command_processor_
                         000543 project                     iodd_command_processor_
                         000551 restart_series              iodd_command_processor_
                         000552 seq_id                      iodd_command_processor_
                         000553 series                      iodd_command_processor_
                         000554 series_sw                   iodd_command_processor_
                         000555 device_id_length            iodd_command_processor_
                         000556 req_type_label_length       iodd_command_processor_
                         000560 io_stat                     iodd_command_processor_
                         000562 arg_list                    iodd_command_processor_
                         001332 ev_chan_list                iodd_command_processor_
                         001340 event_info                  iodd_command_processor_
                         001347 option                      iodd_command_processor_
                         001350 cond_info                   iodd_command_processor_
                         001550 coord_msg                   iodd_command_processor_
                         001714 cq_info_ptr                 iodd_command_processor_
                         001716 list_ptr                    iodd_command_processor_
                         001720 event_message               iodd_command_processor_
                         001722 comm_ptr                    iodd_command_processor_
                         001742 i                           halt_all
                         001752 i                           ready_all
                         001762 string                      get_driver_status
                         001772 len                         get_driver_status
                         001773 pending                     get_driver_status
                         002002 j                           find_minor_dev
                         002020 len                         send_coord_msg
                         002022 msg_id                      send_coord_msg
on unit on line 1787     000106 code                        x_cmd_handler
                         000107 type                        x_cmd_handler
reattach_master          000100 code                        reattach_master

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               r_e_as              alloc_char_temp     cat_realloc_chars   call_ent_var_desc
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other      return_mac
move_label_var      make_label_var      fl2_to_fx1          tra_ext_1           stac_mac            mpfx2
mdfx1               signal_op           enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           int_entry_desc      set_chars_eis       index_chars_eis     any_to_any_round_   any_to_any_truncate_
divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           convert_ipc_code_             cu_$cp                        debug
find_condition_info_          hcs_$initiate                 hcs_$wakeup                   ioa_
ioa_$rsnnl                    iodc_$command_level           iodd_msg_                     iodd_parse_$command
ios_$attach                   ios_$changemode               ios_$detach                   ios_$order
iox_$attach_ptr               iox_$control                  iox_$detach_iocb              ipc_$block
ipc_$drain_chn                logout                        message_segment_$add_file     probe
timer_manager_$alarm_wakeup   timer_manager_$reset_alarm_wakeup

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$namedup          error_table_$noarg
error_table_$noentry          error_table_$request_not_recognized                         iox_$error_output
iox_$user_input               iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    104 003424        16 003430       230 003451       232 003453       234 003467       235 003524       238 003527
    240 003543       241 003600       244 003603       246 003630       248 003633       250 003636       252 003640
    254 003641       255 003644       257 003713       265 003714       275 003721       277 003733       279 003740
    281 003745       283 003757       285 003764       287 003771       289 004003       291 004010       293 004015
    295 004022       297 004027       299 004041       301 004046       303 004053       305 004060       307 004072
    309 004077       311 004104       313 004116       315 004123       317 004130       319 004142       321 004147
    323 004161       325 004166       327 004173       329 004200       331 004205       333 004217       335 004224
    337 004231       339 004236       344 004243       345 004245       347 004262       350 004313       352 004317
    354 004324       361 004325       364 004330       365 004342       367 004344       368 004401       370 004402
    373 004407       374 004451       377 004452       380 004455       384 004466       385 004471       388 004472
    390 004477       391 004501       392 004503       394 004505       395 004507       396 004511       398 004540
    400 004575       402 004601       404 004604       405 004607       406 004610       407 004613       410 004614
    411 004627       414 004631       420 004641       422 004645       425 004677       428 004700       429 004703
    432 004704       435 004707       436 004712       439 004713       441 004720       442 004723       445 004724
    447 004731       449 004734       451 004764       453 004775       454 004777       456 005042       457 005074
    458 005100       459 005102       460 005104       461 005106       462 005110       463 005111       464 005114
    466 005117       467 005142       468 005167       469 005214       470 005220       471 005222       472 005225
    473 005230       474 005233       476 005234       477 005237       481 005240       484 005245       486 005250
    488 005253       490 005304       491 005337       493 005341       494 005343       495 005376       496 005402
    499 005403       501 005407       503 005443       506 005444       507 005447       510 005450       513 005455
    515 005460       516 005512       518 005514       519 005516       520 005551       522 005555       525 005556
    526 005561       531 005562       533 005564       534 005604       537 005606       540 005620       542 005625
    544 005630       547 005631       549 005642       551 005646       554 005647       557 005654       558 005660
    560 005663       561 005706       563 005710       564 005712       565 005745       568 005751       570 006013
    573 006014       575 006026       577 006031       578 006034       581 006035       583 006045       584 006102
    586 006104       587 006106       588 006141       591 006145       594 006146       595 006166       598 006170
    603 006200       605 006234       606 006241       609 006242       610 006245       613 006246       616 006253
    617 006256       620 006261       621 006264       623 006265       626 006273       627 006276       629 006277
    630 006301       631 006303       633 006332       635 006367       636 006372       638 006373       639 006376
    642 006377       645 006402       647 006407       648 006412       650 006413       651 006414       652 006416
    653 006417       655 006421       657 006444       659 006445       661 006447       662 006452       664 006454
    666 006455       667 006461       669 006463       671 006464       672 006467       674 006471       675 006473
    678 006477       680 006501       682 006510       685 006546       688 006551       691 006631       694 006632
    695 006646       697 006651       699 006654       702 006731       705 006732       708 006735       709 006740
    712 006741       714 006750       715 006753       718 006754       720 006764       721 006767       724 006770
    727 006777       729 007004       730 007007       732 007010       733 007020       735 007023       736 007040
    739 007042       742 007045       743 007050       744 007052       745 007055       748 007056       751 007062
    753 007065       756 007073       757 007076       759 007077       762 007100       764 007114       766 007123
    767 007144       769 007146       772 007156       774 007160       777 007175       778 007237       780 007243
    781 007244       782 007307       785 007311       787 007316       788 007352       790 007356       792 007365
    794 007372       795 007375       797 007376       798 007400       799 007402       801 007403       804 007404
    806 007406       807 007411       809 007412       812 007413       816 007447       817 007504       818 007540
    819 007575       820 007631       821 007671       822 007725       823 007762       824 010016       825 010053
    826 010107       827 010143       828 010200       829 010237       830 010274       831 010331       832 010365
    833 010423       834 010460       835 010520       836 010555       837 010612       838 010652       839 010706
    840 010745       841 011002       843 011037       845 011044       846 011100       847 011134       848 011170
    849 011224       850 011260       851 011314       854 011350       856 011400       857 011431       860 011432
    863 011441       865 011447       868 011450       871 011453       872 011465       874 011470       875 011516
    878 011520       880 011522       882 011534       884 011536       887 011604       891 011605       895 011612
    898 011617       900 011655       903 011724       906 011725       909 011730       912 011731       916 011740
    918 011745       919 011750       922 011751       925 011761       926 011776       929 012000       931 012036
    933 012043       934 012076       937 012130       940 012144       941 012147       944 012150       947 012153
    949 012234       951 012236       953 012272       956 012273       959 012276       960 012301       963 012302
    966 012342       968 012345       970 012346       973 012356       975 012360       977 012370       979 012423
    982 012424       984 012430       985 012433       988 012434       989 012435       990 012436       991 012451
    993 012455       995 012465       997 012502       999 012505      1000 012507      1001 012544      1003 012545
   1004 012547      1006 012553      1007 012565      1009 012573      1010 012575      1013 012637      1014 012640
   1016 012652      1018 012655      1019 012657      1020 012714      1021 012715      1023 012720      1024 012722
   1025 012757      1027 012760      1028 012762      1030 012766      1031 012772      1033 012777      1034 013000
   1036 013012      1038 013015      1039 013017      1040 013054      1041 013055      1043 013060      1044 013062
   1045 013117      1047 013120      1048 013122      1050 013126      1051 013132      1052 013137      1054 013141
   1055 013143      1058 013204      1059 013205      1061 013212      1063 013215      1064 013217      1065 013254
   1067 013255      1068 013257      1070 013263      1071 013272      1073 013304      1074 013306      1077 013352
   1078 013353      1080 013360      1082 013363      1083 013365      1084 013422      1086 013423      1087 013425
   1089 013431      1090 013450      1092 013502      1094 013512      1095 013514      1097 013551      1098 013611
   1099 013612      1100 013613      1102 013625      1104 013630      1105 013632      1106 013667      1108 013670
   1109 013672      1111 013676      1112 013717      1114 013721      1115 013723      1116 013755      1117 013756
   1119 013762      1121 013763      1124 014032      1128 014074      1129 014076      1131 014100      1133 014103
   1136 014105      1138 014110      1140 014115      1141 014120      1143 014121      1144 014123      1147 014127
   1149 014154      1151 014155      1152 014160      1157 014161      1158 014164      1160 014167      1161 014172
   1162 014174      1164 014230      1166 014266      1169 014267      1174 014277      1176 014333      1177 014340
   1180 014341      1181 014344      1183 014345      1188 014355      1190 014404      1192 014407      1195 014410
   1197 014413      1200 014414      1203 014420      1205 014423      1208 014431      1209 014434      1211 014435
   1213 014436      1214 014445      1216 014462      1217 014463      1219 014464      1220 014466      1222 014477
   1223 014520      1225 014522      1227 014526      1229 014531      1231 014534      1234 014536      1238 014545
   1240 014546      1242 014555      1244 014557      1246 014622      1247 014623      1248 014666      1250 014670
   1253 014671      1256 014700      1258 014705      1259 014710      1262 014711      1264 014714      1267 014715
   1270 014723      1272 014732      1274 014737      1275 014742      1277 014743      1279 015001      1281 015006
   1282 015010      1284 015040      1286 015075      1287 015100      1288 015104      1290 015105      1291 015110
   1294 015111      1297 015115      1300 015124      1301 015127      1304 015130      1306 015133      1308 015142
   1309 015144      1310 015146      1312 015175      1314 015232      1316 015242      1317 015245      1319 015246
   1320 015251      1322 015252      1325 015253      1327 015256      1330 015263      1331 015265      1332 015275
   1334 015276      1335 015306      1338 015307      1339 015311      1340 015312      1341 015315      1342 015320
   1343 015324      1345 015326      1346 015330      1347 015332      1348 015334      1350 015337      1351 015341
   1353 015343      1355 015352      1357 015360      1359 015365      1360 015452      1363 015454      1366 015462
   1370 015553      1372 015557      1374 015571      1375 015575      1378 015577      1381 015601      1383 015603
   1385 015605      1387 015612      1389 015614      1392 015621      1394 015623      1396 015626      1397 015630
   1399 015636      1400 015641      1402 015642      1404 015644      1405 015645      1406 015647      1407 015651
   1411 015653      1414 015667      1418 015674      1420 015675      1421 015677      1424 015700      1427 015710
   1428 015713      1431 015714      1433 015717      1434 015722      1436 015724      1437 015730      1438 015732
   1440 015733      1441 015737      1446 015741      1447 015744      1448 015745      1449 015746      1450 015747
   1451 015750      1452 015753      1453 015756      1455 015761      1457 015763      1460 016046      1463 016104
   1466 016105      1469 016115      1470 016117      1472 016146      1474 016203      1475 016206      1476 016212
   1479 016213      1481 016216      1484 016217      1487 016223      1490 016232      1491 016233      1492 016236
   1493 016242      1496 016243      1497 016246      1500 016247      1503 016253      1505 016256      1506 016261
   1508 016262      1511 016271      1512 016274      1515 016275      1517 016304      1518 016306      1519 016310
   1521 016337      1523 016374      1524 016401      1525 016403      1526 016405      1529 016407      1530 016412
   1531 016415      1534 016416      1535 016421      1541 016422      1546 016432      1548 016516      1549 016550
   1552 016551      1553 016554      1556 016555      1557 016560      1560 016561      1563 016566      1564 016571
   1567 016572      1569 016575      1570 016600      1573 016601      1575 016606      1576 016610      1577 016652
   1579 016653      1581 016665      1582 016667      1583 016732      1585 016733      1587 016740      1589 016743
   1590 016770      1592 016772      1593 016774      1596 017035      1598 017036      1600 017050      1602 017053
   1603 017100      1605 017102      1606 017104      1609 017142      1611 017143      1613 017150      1615 017153
   1616 017200      1618 017202      1619 017204      1621 017205      1623 017217      1625 017222      1626 017247
   1628 017251      1629 017253      1631 017254      1633 017261      1634 017263      1636 017264      1638 017276
   1639 017300      1641 017301      1643 017306      1644 017310      1646 017311      1648 017323      1649 017325
   1651 017326      1653 017333      1655 017335      1656 017340      1657 017343      1659 017344      1660 017350
   1662 017353      1664 017356      1665 017401      1667 017403      1668 017405      1670 017431      1671 017475
   1674 017476      1675 017500      1676 017515      1678 017517      1681 017520      1684 017523      1685 017527
   1687 017534      1689 017537      1690 017542      1692 017543      1693 017545      1696 017546      1697 017551
   1701 017552      1704 017555      1707 017572      1708 017607      1710 017611      1711 017612      1713 017613
   1715 017617      1717 017627      1719 017632      1723 017713      1725 017720      1726 017722      1727 017765
   1728 017770      1729 020032      1733 020033      1734 020036      1735 020045      1736 020051      1738 020056
   1740 020074      1743 020112      1744 020114      1747 020166      1748 020177      1749 020203      1751 020210
   1752 020213      1756 020274      1758 020276      1760 020332      1763 020333      1766 020336      1768 020350
   1771 020362      1772 020365      1774 020366      1775 020367      1776 020373      1779 020374      1782 020410
   1783 020444      1784 020447      1787 020450      1788 020466      1790 020510      1792 020514      1793 020522
   1795 020525      1796 020530      1797 020534      1799 020535      1801 020536      1802 020541      1803 020552
   1804 020601      1806 020604      1807 020607      1808 020613      1812 020614      1813 020615      1815 020622
   1817 020667      1819 020673      1821 020675      1822 020700      1823 020702      1825 020703      1826 020706
   1827 020747      1828 020754      1831 020755      1833 020763      1834 021026      1837 021033      1842 021151
   1843 021200      1846 021205      1848 021211      1860 021212      1865 021223      1868 021230      1873 021231
   1878 021232      1880 021243      1881 021247      1882 021251      1884 021261      1887 021270      1889 021272
   1891 021274      1895 021275      1900 021276      1902 021301      1903 021311      1904 021315      1906 021320
   1907 021322      1909 021325      1913 021332      1915 021333      1916 021335      1918 021337      1920 021341
   1923 021342      1934 021353      1937 021365      1940 021376      1942 021403      1944 021410      1945 021412
   1946 021425      1947 021427      1948 021462      1951 021471      1956 021472      1965 021503      1966 021505
   1967 021511      1968 021521      1969 021526      1971 021535      1972 021537      1973 021543      1974 021561
   1978 021563      1983 021577      1986 021647      1988 021653      1994 021654      2000 021655      2002 021660
   2004 021677      2005 021704      2007 021710      2009 021717      2011 021720      2013 021724      2015 021730
   2017 021735      2019 021741      2020 021743      2022 021747      2024 021753      2025 021756      2027 021760
   2029 021761      2032 021772      2035 021776      2037 022015      2039 022022      2043 022025      2048 022027
   2050 022030      2052 022071      2053 022103      2056 022107      2057 022135      2060 022141      2061 022153
   2064 022157      2065 022205      2068 022211      2070 022252      2071 022264      2074 022270      2076 022316
   2080 022317      2087 022325      2089 022326      2091 022332      2092 022342      2095 022344      2096 022373
   2099 022375      2100 022406      2103 022410      2104 022437      2107 022441      2109 022454      2111 022460
   2112 022470      2115 022472      2116 022521      2119 022523      2122 022564      2124 022571      2125 022624
   2126 022631      2129 022632      2131 022636      2135 022637      2143 022641      2144 022645      2146 022653
   2148 022717      2150 022722      2151 022725      2154 022726      2156 022740      2159 022753      2161 022755
   2162 022774      2167 022777      2170 023017      2171 023021      2172 023025      2174 023027      2176 023046
   2179 023056      2181 023061      2183 023070      2184 023124      2187 023127      2189 023132      2190 023134
   2191 023137      2192 023141      2194 023142      2195 023146      2197 023151


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
