	COMPILATION LISTING OF SEGMENT pdir_volume_manager_
	Compiled by: Multics PL/I Compiler, Release 33c, of October 25, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 91-12-12_2150.60_Thu_mst
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1991   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 /* format: style4 */
       15 pdir_volume_manager_: proc;
       16 
       17 /* This procedure manages the placement of process directories on logical volumes.
       18*   It also manages the quota on >pdd, to prevent it from running out or overflowing.
       19*
       20*   PDIR VOLUME MANAGEMENT:
       21*
       22*   The intention is to spread the space requirements and paging load for process
       23*   directory segments among several logical volumes, to increase system performance
       24*   and to eliminate the need for a site to have one logical volume large enough to
       25*   accomodate all process directory segments.
       26*
       27*   The segments of a process directory are placed on a particular logical volume
       28*   by setting the sons volume of >pdd to that volume just before creating
       29*   the process directory. It takes its sons volume from its parent (>pdd) and
       30*   retains that sons volume even when the sons volume of >pdd is changed at the
       31*   time of the next process creation. Thus all the segments in a process directory
       32*   reside on the same logical volume. The directories themselves are on the root
       33*   logical volume, as are all directories. We will speak of a process directory
       34*   being on a volume, for brevity, when we really mean that the segments of the
       35*   process directory are on that volume.
       36*
       37*   The placement algorithm could be arbitrarily complex, taking into account
       38*   the size and current space available of each logical volume, the current
       39*   distribution of process directories among logical volumes, and even the amount
       40*   of recent paging activity on each volume. Different groups of users could
       41*   be restricted to having their process directory segments on certain logical
       42*   volumes only. It is unclear which, if any, of these criteria would lead to the
       43*   best improvement in system performance. Therefore the algorithm used in this
       44*   initial implementation is the simplest possible one. It is expected to result
       45*   in a measurable performance improvement. Refinements to the placement algorithm
       46*   can be made later if they are found to be necessary and effective.
       47*
       48*   A list of logical volumes available for process directory segments is kept by
       49*   using a bit in the disk table. Thus only mounted logical volumes can be in
       50*   the list, and the list must be initialized at each bootload. Process directories
       51*   are placed on the volumes in this list in proportion to the number of physical
       52*   volumes in each logical volume. The proportion is observed only in the creation
       53*   of process directories. It is assumed that process destructions will be
       54*   spread evenly over the entire set of processes, and so the proportion of
       55*   process directories on each logical volume will remain as desired even though the
       56*   deletion of process directories is not recorded and used by the placement algorithm.
       57*
       58*   The desired proportion is achieved by going through the physical volume entries
       59*   in the disk table, in rotation, and if a pv is part of an lv available for
       60*   pdirs, choosing that lv. A static variable remembers the last pv entry used,
       61*   so that the rotation can be resumed with that entry at the next process creation.
       62*
       63*   The index in the disk table of the logical volume on which a user's process
       64*   directory is placed is recorded in the process's user table entry, so that it
       65*   is possible to determine where all the process directories are (as_who will
       66*   print this information if requested), but searching all 3 user tables at each
       67*   process creation to count the process directories on each volume would be impractical.
       68*
       69*   Volumes can be added to or deleted from the list of process directory volumes
       70*   during system operation. To demount a volume containing process directory
       71*   segments, it is necessary to remove it from the list, thus halting the placing
       72*   of new process directories on it, and then wait for processes whose process
       73*   directories are already on it to be destroyed (by logout, new_proc, or bump).
       74*   The pdir volume indices in the user tables are the means by which these
       75*   processes can be identified.
       76*
       77*   Alternately, the process directories may be force evacuated to another
       78*   logical volume via the vacate_pdir_volume operator command entry. This
       79*   command takes any number of specified logical volumes, suspending further
       80*   process directory creation on them and then calling a routine which will
       81*   find users with process directories on the volumes and walk their process
       82*   directories, force moving the segments contained therein. It should be
       83*   noted that this operation may cause an imbalance as established in the
       84*   normal process directory allocation scheme.
       85*
       86*   The system administrator must ensure that volumes placed in the pdir
       87*   volume list have enough space available on them to accomodate the expected
       88*   number of process directories. We do not monitor space available in this
       89*   initial implementation.
       90*
       91*   PDD QUOTA MANAGEMENT:
       92*
       93*   The problem is that quota is a fixed bin (17) unaligned variable in the ASTE, limiting it to 131,071 (2**17-1).
       94*   With large numbers of processes, or larger than normal quotas on some pdirs, >pdd could easily
       95*   run out of quota. This procedure is called just before each process creation and destruction.
       96*   It keeps track of the quota on >pdd, and sets it higher or lower if it is in danger of running out or overflowing
       97*   because of the process directory that is about to be created or deleted. Whenever the quota on
       98*   >pdd must be changed, it is set to half the maximum quota, to attempt to minimize the
       99*   number of times it has to be set.
      100*
      101*   USER RING DISK TABLE MANAGEMENT:
      102*
      103*   There is a little magic that goes on here that one should be aware of.
      104*   The disk_table resides in ring 1 and this procedure works with a copy of
      105*   it, residing in our process directory, as provided by disk_table_$get_dtp.
      106*   Those entries contained herin that modify the disk_table do so by calling
      107*   the disk_table_ procedure.  That procedure, after modifying the disk_table_
      108*   calls the appropriate routine, (mdx$...) to update our copy.
      109*
      110*   ENTRYPOINTS:
      111*
      112*   This procedure contains 10 entry points:
      113*
      114*   $init		    called by as_init_ at startup time
      115*   $select_pdir_volume  called by cpg_ before a process directory is created; sets sons volume of >pdd to the selected volume,
      116*   .		    updates pdd quota records, and sets >pdd quota if necessary
      117*   $set_pdir_volumes    operator command; replaces the list of pdir volumes
      118*   $add_pdir_volume     operator command; adds a pdir volume to the list
      119*   $del_pdir_volume     operator command; deletes a pdir volume from the list
      120*   $note_pdir_deletion  called by dpg_ at process destruction time; updates pdd quota records; sets >pdd quota if necessary
      121*   $print_pdq	    operator command; prints internal variables, for debugging
      122*   $shared_spindle_on   operator command; turns on optimization for shared-spindle
      123*   devices (this is the default)
      124*   $shared_spindle_off  operator command; turns off optimization for shared-spindle
      125*   devices (emergency bypass)
      126*
      127*   $vacate_pdir_volume  operator command; suspends creation of pdirs on the specified
      128*   volumes and then moves perprocess segments off of those volumes.
      129*
      130*   Modification history:
      131*
      132*   Initial coding by T. Casey, August 1977
      133*
      134*   Modified by T. Casey, October 1977 to put while clause on both sections of disk table search, in select_pdir_volume
      135*   Modified by T. Casey, January 1978 to check used bit before turning off pdirs_ok, in set_pdir_volumes
      136*   Modified by T. Casey, May 1978, to add >pdd quota management.
      137*   Modified by J. Bongiovanni, April 1981, for shared spindle devices
      138*   Modified by J. Bongiovanni, September 1981, for emergency bypass of shared
      139*   spindle optimization
      140*   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
      141*   Modified March 1982, E. N. Kittlitz. added xxx_pdv as synonyms for xxx_pdir_volume.
      142*   Modified April 1982, E. N. Kittlitz. New AS initialization.
      143*   Modified 831122 for PDIR vacating... -E. A. Ranzenbach
      144*   <<< NOTE >>> THIS PROCEDURE CONTAINS QUESTIONABLE PROGRAMMING TECHNIQUES AND
      145*   SHOULD BE REWRITTEN AS TIME PERMITS... -ear
      146*
      147*   Modified 83-12-06 BIM to check AIM for LV.
      148*   Modified 84-12-27 Keith Loepere for pdir dir_quota.
      149*   Modified 85-01-17 E. A. Ranzenbach to change vac_pdv to ignore lve.pdirs_ok
      150*     and to only print one message per directory...
      151**/
      152 
      153 /****^  HISTORY COMMENTS:
      154*  1) change(86-05-12,Fawcett), approve(86-05-12,MCR7383),
      155*     audit(86-05-21,Coppola), install(86-07-18,MR12.0-1098):
      156*     Changed because of a compiler warning found during recompile.
      157*  2) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
      158*     audit(87-07-27,Hartogs), install(87-08-04,MR12.1-1055):
      159*     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
      160*  3) change(88-04-27,GDixon), approve(88-08-15,MCR7969),
      161*     audit(88-08-03,Lippard), install(88-08-29,MR12.2-1093):
      162*      A) Set ename identifier variable at print_pdq ep to avoid garbage in
      163*         error messages. (phx17303)
      164*  4) change(91-03-11,Vu), approve(91-03-11,MCR8243), audit(91-12-09,Zimmerman),
      165*     install(91-12-12,MR12.5-1009):
      166*     Bad argument list for call to sys_log_.
      167*                                                   END HISTORY COMMENTS */
      168 
      169 
      170 /* DECLARATIONS */
      171 
      172 /* Parameters */
      173 
      174 dcl  a_atep ptr;
      175 dcl  a_code fixed bin (35);
      176 
      177 /* Constants */
      178 
      179 dcl  HALF_MAXQ fixed bin int static options (constant) init (65535); /* half of largest possible quota */
      180 dcl  MAXQ fixed bin int static options (constant) init (131071); /* largest possible quota */
      181 dcl  SAFETY_MARGIN fixed bin int static options (constant) init (1024); /* let >pdd's quota get only this close to limits */
      182 dcl  zzBB char (20) int static options (constant) init (">pdd>!zzzzzzzbBBBBBB"); /* pathname of initializer's pdir */
      183 
      184 /* Internal Static Variables */
      185 
      186 dcl  already_init bit (1) aligned int static init (""b);
      187 dcl  (cur_lvix, cur_pvix, n_pdir_volumes) fixed bin int static;
      188 dcl  static_dtp ptr int static init (null);
      189 dcl  shared_spindle_hack bit (1) aligned int static init ("1"b);
      190 
      191 dcl  default_pddir_q fixed bin int static;		/* default pdir dir_quota */
      192 dcl  default_pdq fixed bin int static;			/* the default pdir quota that we think hardcore is using */
      193 dcl  npd fixed bin int static;			/* number of pdirs we know about */
      194 dcl  pdddir_q fixed bin int static;			/* current dir_quota on >pdd (we think) */
      195 dcl  pddq fixed bin int static;			/* current quota on >pdd (we think) */
      196 dcl  pddir_q fixed bin int static;			/* sum of dir_quotas on all pdirs */
      197 dcl  pdq fixed bin int static;			/* sum of quotas on all pdirs */
      198 dcl  pddq_known bit (1) aligned int static init (""b);	/* "1"b if we think we know >pdd's quota */
      199 dcl  more_than_one_pdir_vol bit (1);			/* true until we run out...		*/
      200 
      201 /* External Static */
      202 
      203 dcl  error_table_$action_not_performed ext fixed bin (35);
      204 dcl  error_table_$out_of_sequence fixed bin (35) ext static;
      205 dcl  error_table_$badopt fixed bin (35) ext static;
      206 
      207 /* External Entries */
      208 
      209 dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
      210 dcl  cu_$arg_count entry (fixed bin);
      211 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      212 dcl  disk_table_$get_dtp entry (ptr);
      213 dcl  disk_table_$set_lv_pdir_bit entry (char (*), bit (1) aligned, fixed bin (35));
      214 dcl  disk_table_$set_vacate_pdirs_bit entry (char (*), bit (1) aligned, fixed bin (35));
      215 dcl  hcs_$dir_quota_read entry (char (*), fixed bin, fixed bin (71), fixed bin (35), bit (36),
      216 	fixed bin (1), fixed bin, fixed bin (35));
      217 dcl  hcs_$quota_read entry (char (*), fixed bin, fixed bin (71), fixed bin (35), bit (36),
      218 	fixed bin (1), fixed bin, fixed bin (35));
      219 dcl  hphcs_$dir_quota_set entry (char (*), fixed bin, fixed bin (35));
      220 dcl  hphcs_$quota_set entry (char (*), fixed bin, fixed bin (35));
      221 dcl  hphcs_$pv_move_file entry (char (*), char (*), fixed bin (35));
      222 dcl  hphcs_$set_sons_lvid entry (char (*), char (*), bit (36), fixed bin (35));
      223 dcl  hphcs_$set_pdir_sons_lvid entry (char (*), char (*), bit (36), fixed bin (35));
      224 dcl  read_allowed_ entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      225 dcl  sub_err_ entry () options (variable);
      226 dcl  (sys_log_, sys_log_$error_log) entry options (variable);
      227 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      228 dcl  sweep_disk_$dir_list entry (char (168) aligned, entry);
      229 dcl  write_allowed_ entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      230 
      231 /* Automatic */
      232 
      233 dcl  ename char (32);
      234 dcl  loud fixed bin;				/* sys_log_ severity... */
      235 dcl  code fixed bin (35);
      236 dcl  i fixed bin;
      237 dcl  n_new_pdir_volumes fixed bin;
      238 dcl  pvix fixed bin;
      239 dcl  idx fixed bin (17);				/* miscellaneous index...		*/
      240 dcl  pdir char (168) aligned;
      241 dcl  pdir_to_move char (168);
      242 dcl  pdir_vol_name char (32);
      243 dcl  pdir_lvid bit (36);
      244 dcl  proc_lvix fixed bin (17);
      245 
      246 dcl  (argl, argno, nargs) fixed bin;
      247 dcl  argp ptr;
      248 dcl  dir_discrepancy fixed bin;
      249 dcl  discrepancy fixed bin;
      250 dcl  pass_number fixed bin;
      251 dcl  pddq_was_known bit (1) aligned;
      252 dcl  just_got_quota bit (1) aligned init (""b);
      253 dcl  long_sw bit (1);
      254 dcl  (dir_quota, quota, qused) fixed bin, tpp fixed bin (71), uptime fixed bin (35),
      255      slvid bit (36), qswitch fixed bin (1);		/* args for quota_read call */
      256 
      257 /* Based */
      258 
      259 dcl  arg char (argl) based (argp);
      260 
      261 /* Builtin */
      262 
      263 dcl  (addr, index, max, min, null, rtrim) builtin;
      264 
      265 
      266 /* PROCEDURE */
      267 
      268 init: entry;
      269 
      270 	ename = "pdir_volume_manager_$init";
      271 	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed then
      272 	     call sub_err_ (error_table_$out_of_sequence, ename, "s");
      273 
      274 	already_init = "0"b;			/* indicate that we are initializing */
      275 
      276 	call disk_table_$get_dtp (static_dtp);		/* and disk table ptr */
      277 	cur_pvix = 1;				/* start with first pv in disk table */
      278 	cur_lvix = 0;				/* most recently selected lv; none right now */
      279 
      280 	dtp = static_dtp;				/* we are about to reference disk_table */
      281 	n_pdir_volumes = count_pdir_volumes ();		/* to count pdir volumes left from last bootload */
      282 
      283 	npd = 1;					/* zzBB (initializer's pdir) */
      284 	call get_pdd_quota;				/* initialize our copy of >pdd's quota, and get zzBB's quota */
      285 
      286 	already_init = "1"b;
      287 	return;					/* all done */
      288 
      289 
      290 select_pdir_volume: entry (a_atep, a_code);
      291 
      292 	ename = "select_pdir_volume";
      293 	if ^valid_call () then return;		/* check for init and copy static ptrs */
      294 	utep = a_atep;
      295 	a_code = 0;
      296 	code = 0;
      297 
      298 	if ^pddq_known then call get_pdd_quota;		/* if we have lost track of >pdd's quota, go read it */
      299 
      300 	if (pddq - ute.pdir_quota - SAFETY_MARGIN < 0)	/* if >pdd's quota is in danger of going negative */
      301 	     | (pdddir_q - ute.pdir_dir_quota - SAFETY_MARGIN < 0) then 
      302 	     call set_pdd_quota;			/* set it higher */
      303 
      304 	if ute.pdir_quota > 0 then do;		/* if we know the quota of the pdir about to be created */
      305 	     pddq = pddq - ute.pdir_quota;		/* update our records */
      306 	     pdq = pdq + ute.pdir_quota;
      307 	end;
      308 	else do;					/* if not, */
      309 	     pddq_known = ""b;			/* we may have just lost track of >pdd's quota */
      310 	     pddq = pddq - default_pdq;		/* but we can make a good guess */
      311 	     pdq = pdq + default_pdq;
      312 	end;
      313 	if ute.pdir_dir_quota > 0 then do;		/* if we know the dir quota of the new pdir */
      314 	     pdddir_q = pdddir_q - ute.pdir_dir_quota;	/* update our records */
      315 	     pddir_q = pddir_q + ute.pdir_dir_quota;
      316 	end;
      317 	else do;
      318 	     pddq_known = ""b;			/* we may have lost track */
      319 	     pdddir_q = pdddir_q - default_pddir_q;	/* pdir dir_quota */
      320 	     pddir_q = pddir_q + default_pddir_q;
      321 	end;
      322 
      323 	npd = npd + 1;				/* count pdirs */
      324 
      325 	if n_pdir_volumes = 0 then do;		/* if none, avoid time-wasting search of all pvs */
      326 	     ute.pdir_lvix = 0;			/* we don't know the sons volume of >pdd */
      327 	     return;				/* but it's probably ok the way it is */
      328 	end;
      329 
      330 	call select_pdir_vol (pdir_vol_name, proc_lvix, pdir_lvid, code);
      331 	if code ^= 0 then do;
      332 	     a_code = code;
      333 	     return;
      334 	end;
      335 	if cur_lvix ^= proc_lvix then do;
      336 	     call hphcs_$set_sons_lvid (">", "pdd", pdir_lvid, code); /* set sons lvid for the new one...	*/
      337 	     if code ^= 0 then do;
      338 		a_code = code;
      339 		return;
      340 	     end;
      341 	     cur_lvix = proc_lvix;
      342 	end;
      343 
      344 	ute.pdir_lvix = proc_lvix;			/* note PDIR LV for the process...	*/
      345 
      346 	return;
      347 
      348 
      349 note_pdir_deletion: entry (a_atep);
      350 
      351 	ename = "note_pdir_deletion";
      352 	if ^valid_call () then return;		/* check that we are initialized, and copy static pointers */
      353 	utep = a_atep;
      354 
      355 	if ^pddq_known then call get_pdd_quota;		/* if we lost track of >pdd's quota, go read it */
      356 
      357 	if (pddq + ute.pdir_quota + SAFETY_MARGIN > MAXQ)	/* if >pdd's quota is in danger of overflowing */
      358 	     | (pdddir_q + ute.pdir_dir_quota + SAFETY_MARGIN > MAXQ) then
      359 	     call set_pdd_quota;			/* set it lower */
      360 
      361 	if ute.pdir_quota > 0 then do;		/* if we know the quota of the pdir that is about to be deleted */
      362 	     pddq = pddq + ute.pdir_quota;		/* update our records */
      363 	     pdq = pdq - ute.pdir_quota;
      364 	end;
      365 	else do;					/* if not, */
      366 	     pddq_known = ""b;			/* we may have just lost track of >pdd's quota */
      367 	     pddq = pddq + default_pdq;		/* but we can make a good guess */
      368 	     pdq = pdq - default_pdq;
      369 	end;
      370 	if ute.pdir_dir_quota > 0 then do;		/* if we know how much is being deleted */
      371 	     pdddir_q = pdddir_q + ute.pdir_dir_quota;	/* update ourt records */
      372 	     pddir_q = pddir_q - ute.pdir_dir_quota;
      373 	end;
      374 	else do;
      375 	     pddq_known = ""b;			/* we may have lost track */
      376 	     pdddir_q = pdddir_q + default_pddir_q;	/* dir_quota */
      377 	     pddir_q = pddir_q - default_pddir_q;
      378 	end;
      379 
      380 	npd = npd - 1;				/* count pdirs */
      381 
      382 	return;
      383 
      384 
      385 print_pdq: entry;					/* operator command, for debugging */
      386 
      387 	ename = "pdir_volume_manager_$print_pdq";
      388 	pddq_was_known = pddq_known;			/* remember if it was known */
      389 	call get_pdd_quota;				/* be sure we have correct value */
      390 	call sys_log_ (-1, "pddq = ^d, pdq = ^d, npd = ^d,^[ ^[un^]expected discrepancy was ^d^;^s^s^]^/pdddir_q = ^d, pddir_q = ^d,^[ ^[un^]expected discrepancy was ^d^]",
      391 	     pddq, pdq, npd, (discrepancy ^= 0), pddq_was_known, discrepancy,
      392 	     pdddir_q, pddir_q, (dir_discrepancy ^= 0), pddq_was_known, dir_discrepancy);
      393 	call sys_log_ (-1, "lvix = ^d, pvix = ^d, npdv = ^d", cur_lvix, cur_pvix, n_pdir_volumes);
      394 	return;
      395 
      396 
      397 add_pdir_volume: entry;
      398 add_pdv: entry;
      399 
      400 	ename = "add_pdir_volume";
      401 
      402 	if ^valid_call () then return;
      403 
      404 	call cu_$arg_count (nargs);
      405 	if nargs ^= 1 then do;
      406 one_arg_wanted: call sys_log_ (2, "^a: one argument required: logical volume name", ename);
      407 	     return;
      408 	end;
      409 
      410 	call cu_$arg_ptr (1, argp, argl, code);
      411 	if code ^= 0 then do;
      412 err_log_no_msg: call sys_log_$error_log (2, code, "^a", ename);
      413 	     return;
      414 	end;
      415 
      416 	if ^find_lve (arg) then do;
      417 vol_not_found: call sys_log_ (2, "^a: volume ""^a"" not in disk table", ename, arg);
      418 	     return;
      419 	end;
      420 
      421 	if ^lve.hv_mounted | ^lve.public then do;
      422 	     call sys_log_ (2, "^a: volume ""^a"" must be mounted and public to be used for pdirs", ename, arg);
      423 	     return;
      424 	end;
      425 
      426 	call disk_table_$set_lv_pdir_bit (arg, ("1"b), code);
      427 	if code ^= 0 then goto err_log_no_msg;
      428 
      429 	n_pdir_volumes = count_pdir_volumes ();		/* update static pdir volume count */
      430 
      431 	return;
      432 
      433 
      434 del_pdir_volume: entry;
      435 del_pdv: entry;
      436 
      437 	ename = "del_pdir_volume";
      438 
      439 	if ^valid_call () then return;
      440 
      441 	call cu_$arg_count (nargs);
      442 	if nargs ^= 1 then goto one_arg_wanted;
      443 
      444 	call cu_$arg_ptr (1, argp, argl, code);
      445 	if code ^= 0 then goto err_log_no_msg;
      446 
      447 	if ^find_lve (arg) then goto vol_not_found;
      448 
      449 	if ^lve.pdirs_ok then do;
      450 	     call sys_log_ (2, "^a: volume ""^a"" is not a pdir volume", ename, arg);
      451 	     return;
      452 	end;
      453 
      454 	if count_pdir_volumes () ^> 1 then do;		/* if there is only one pdir volume */
      455 	     call sys_log_ (2, "^a: deleting volume ""^a"" would leave no pdir volumes", ename, arg);
      456 	     return;
      457 	end;
      458 
      459 	call disk_table_$set_lv_pdir_bit (arg, (""b), code);
      460 	if code ^= 0 then goto err_log_no_msg;
      461 
      462 	n_pdir_volumes = count_pdir_volumes ();
      463 	return;
      464 
      465 
      466 set_pdir_volumes: entry;
      467 set_pdv: entry;
      468 
      469 	ename = "set_pdir_volumes";
      470 	if ^valid_call () then return;
      471 
      472 	call cu_$arg_count (nargs);
      473 	if nargs ^> 0 then do;
      474 	     call sys_log_ (2, "^a: names of pdir volumes must be given", ename);
      475 	     return;
      476 	end;
      477 
      478 /* Check the specified volumes for suitability */
      479 
      480 	n_new_pdir_volumes = 0;
      481 	do argno = 1 to nargs;
      482 	     call cu_$arg_ptr (argno, argp, argl, code);
      483 	     if code ^= 0 then goto err_log_no_msg;
      484 	     if ^find_lve (arg) then
      485 		call sys_log_ (2, "^a: volume ""^a"" not in disk table", ename, arg);
      486 	     else if ^lve.hv_mounted | ^lve.public then
      487 		call sys_log_ (2, "^a: volume ""^a"" must be mounted and public to be used for pdirs", ename, arg);
      488 	     else n_new_pdir_volumes = n_new_pdir_volumes + 1;
      489 	end;
      490 
      491 	if n_new_pdir_volumes = 0 then return;
      492 	if n_new_pdir_volumes < nargs then
      493 	     call sys_log_ (2, "^a: ^d of ^d specified volumes unusable for pdirs; the others will be used",
      494 		ename, nargs - n_new_pdir_volumes, nargs);
      495 
      496 /* Clear current pdir volumes */
      497 
      498 	do i = 1 to dt.n_lv_entries;
      499 	     if dt.lv_array (i).used & dt.lv_array (i).pdirs_ok then do;
      500 		call disk_table_$set_lv_pdir_bit ((dt.lv_array (i).lvname), (""b), code);
      501 		if code ^= 0 then
      502 		     call sys_log_$error_log (2, code, ename, dt.lv_array (i).lvname);
      503 	     end;
      504 	end;
      505 
      506 /* Set new pdir volumes */
      507 
      508 	do argno = 1 to nargs;
      509 	     call cu_$arg_ptr (argno, argp, argl, code);
      510 	     if code ^= 0 then goto err_log_no_msg;
      511 	     if find_lve (arg) then do;
      512 		if lve.hv_mounted & lve.public then do;
      513 		     call disk_table_$set_lv_pdir_bit (arg, ("1"b), code);
      514 		     if code ^= 0 then
      515 			call sys_log_$error_log (2, code, ename, arg);
      516 		end;
      517 	     end;
      518 	end;
      519 
      520 	n_pdir_volumes = count_pdir_volumes ();
      521 
      522 	return;
      523 
      524 vacate_pdir_volume:
      525      entry;
      526 vac_pdv: entry;
      527 
      528 	ename = "vacate_pdir_volume";
      529 	if ^valid_call () then return;
      530 
      531 	call cu_$arg_count (nargs);
      532 	if nargs < 1 then do;
      533 	     call sys_log_ (2, "^a: At least one logical volume must be specified.", ename);
      534 	     return;
      535 	end;
      536 
      537 	more_than_one_pdir_vol = "1"b;
      538 	long_sw = "0"b;
      539 
      540 	loud = 0;					/* log only...			*/
      541 
      542 	do argno = 1 to nargs while (more_than_one_pdir_vol);
      543 	     call cu_$arg_ptr (argno, argp, argl, code);
      544 	     if code ^= 0 then go to err_log_no_msg;
      545 	     if index (arg, "-") = 1 then do;
      546 		if arg = "-long" | arg = "-lg" then loud = 2;
      547 		else do;
      548 		     call sys_log_$error_log (2, error_table_$badopt,"^a",  arg);
      549 		     return;
      550 		end;
      551 	     end;
      552 	     else do;
      553 		if ^find_lve (arg) then call sys_log_ (2, "^a: ^a is not a logical volume and will not be processed.", ename, arg);
      554 		else do;
      555 		     if lve.pdirs_ok & (count_pdir_volumes () ^>1) then do;
      556 			call sys_log_ (2, "^a: Deleting volume ^a would leave no pdir volumes.^/Further volume processing suspended.", ename, arg);
      557 			more_than_one_pdir_vol = "0"b;
      558 		     end;
      559 		     else do;
      560 			call disk_table_$set_vacate_pdirs_bit (arg, ("1"b), code);
      561 			if code ^= 0 then call sys_log_$error_log (2, code, "^a: Processing of this volume suspended.",
      562 			     ename);
      563 		     end;
      564 		end;
      565 	     end;
      566 	end;
      567 
      568 	do i = 1 to dt.n_lv_entries;			/* do each lv that needs vacating...	*/
      569 	     if dt.lv_array (i).used & dt.lv_array (i).vacate_pdirs then do; /* this one needs working...		*/
      570 		lvep = addr (dt.lv_array (i));
      571 		call find_user_move_pdir (i);		/* move the user's pdir...		*/
      572 		call disk_table_$set_vacate_pdirs_bit ((dt.lv_array (i).lvname), "0"b, code);
      573 		if code ^= 0 then call sys_log_ (2, "^a: Unable to clear vacate_pdirs switch for logical volume ^a.",
      574 			ename, dt.lv_array (i).lvname);
      575 	     end;
      576 	end;
      577 
      578 	return;
      579 
      580 shared_spindle_on: entry;
      581 
      582 	ename = "pdir_volume_manager_";
      583 	call set_shared_spindle ("1"b);
      584 	return;
      585 
      586 shared_spindle_off: entry;
      587 
      588 	ename = "pdir_volume_manager_";
      589 	call set_shared_spindle ("0"b);
      590 	return;
      591 
      592 count_pdir_volumes: proc returns (fixed bin);
      593 
      594 dcl  nvol fixed bin;
      595 dcl  i fixed bin;
      596 
      597 	nvol = 0;
      598 	do i = 1 to dt.n_lv_entries;
      599 	     if dt.lv_array (i).used & dt.lv_array (i).public & dt.lv_array (i).hv_mounted
      600 		& dt.lv_array (i).pdirs_ok then nvol = nvol + 1;
      601 	end;
      602 	return (nvol);
      603 
      604      end count_pdir_volumes;
      605 
      606 /* ---------- */
      607 
      608 find_lve: proc (a_lvname) returns (bit (1) aligned);
      609 
      610 dcl  a_lvname char (*);
      611 dcl  i fixed bin;
      612 
      613 	do i = 1 to dt.n_lv_entries;
      614 	     if dt.lv_array (i).used & dt.lv_array (i).lvname = a_lvname then do;
      615 		lvep = addr (dt.lv_array (i));
      616 		return ("1"b);
      617 	     end;
      618 	end;
      619 
      620 	return (""b);
      621 
      622      end find_lve;
      623 
      624 find_user_move_pdir:
      625      proc (lv_idx);
      626 
      627 
      628 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      629 /*										*/
      630 /* Internal procedure to walk the answer_table looking for users whose process directory is on the	*/
      631 /* logical volume specified by lv_idx. These users process directories are then seg_moved to a	*/
      632 /* different logical volume.								*/
      633 /*										*/
      634 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      635 
      636 dcl  lv_idx fixed bin (17) parameter;			/* index of the LV to vacate...	*/
      637 
      638 /* START_find_user_move_pdir: */
      639           ansp = as_data_$ansp;
      640 	do idx = 1 to anstbl.current_size;		/* search the answer_table...		*/
      641 	     utep = addr (anstbl.entry (idx));		/* -> user_table_entry...		*/
      642 	     if ute.active = NOW_HAS_PROCESS & ute.pdir_lvix = lv_idx then do; /* this one must be moved...		*/
      643 		pdir = ">pdd>" || unique_chars_ ((ute.proc_id));
      644 		call sys_log_ (loud, "vacate_pdir_volume:  Processing ^a (^a.^a) on ^a.",
      645 		     pdir, ute.person, ute.project, lve.lvname);
      646 		call select_pdir_vol (pdir_vol_name, proc_lvix, pdir_lvid, code);
      647 		if code ^= 0 then return;
      648 		call hphcs_$set_pdir_sons_lvid (">pdd", unique_chars_ ((ute.proc_id)), pdir_lvid, code);
      649 		if code ^= 0 then do;
      650 		     call sys_log_$error_log (2, code, "Unable to set sons lvid for ^a.", pdir);
      651 		     return;
      652 		end;
      653 		call sweep_disk_$dir_list ((pdir), move_pdir_segs);
      654 		ute.pdir_lvix = proc_lvix;
      655 	     end;
      656 	end;
      657 
      658           autp = as_data_$autp;
      659 	do idx = 1 to autbl.current_size;		/* search the absentee_user_table...	*/
      660 	     utep = addr (autbl.entry (idx));		/* -> user_table_entry...		*/
      661 	     if ute.active = NOW_HAS_PROCESS & ute.pdir_lvix = lv_idx then do; /* this one must be moved...		*/
      662 		pdir = ">pdd>" || unique_chars_ ((ute.proc_id));
      663 		call sys_log_ (loud, "vacate_pdir_volume:  Processing ^a (^a.^a) on ^a.",
      664 		     pdir, ute.person, ute.project, lve.lvname);
      665 		call select_pdir_vol (pdir_vol_name, proc_lvix, pdir_lvid, code);
      666 		if code ^= 0 then return;
      667 		call hphcs_$set_pdir_sons_lvid (">pdd", unique_chars_ ((ute.proc_id)), pdir_lvid, code);
      668 		if code ^= 0 then do;
      669 		     call sys_log_$error_log (2, code, "Unable to set sons lvid for ^a.", pdir);
      670 		     return;
      671 		end;
      672 		call sweep_disk_$dir_list ((pdir), move_pdir_segs);
      673 		ute.pdir_lvix = proc_lvix;
      674 	     end;
      675 	end;
      676 
      677           dutp = as_data_$dutp;
      678 	do idx = 1 to dutbl.current_size;		/* search the daemon_user_table...	*/
      679 	     utep = addr (dutbl.entry (idx));		/* -> user_table_entry...		*/
      680 	     if ute.active = NOW_HAS_PROCESS & ute.pdir_lvix = lv_idx then do; /* this one must be moved...		*/
      681 		pdir = ">pdd>" || unique_chars_ ((ute.proc_id));
      682 		call sys_log_ (loud, "vacate_pdir_volume:  Processing ^a (^a.^a) on ^a.",
      683 		     pdir, ute.person, ute.project, lve.lvname);
      684 		call select_pdir_vol (pdir_vol_name, proc_lvix, pdir_lvid, code);
      685 		if code ^= 0 then return;
      686 		call hphcs_$set_pdir_sons_lvid (">pdd", unique_chars_ ((ute.proc_id)), pdir_lvid, code);
      687 		if code ^= 0 then do;
      688 		     call sys_log_$error_log (2, code, "Unable to set sons lvid for ^a.", pdir);
      689 		     return;
      690 		end;
      691 		call sweep_disk_$dir_list ((pdir), move_pdir_segs);
      692 		ute.pdir_lvix = proc_lvix;
      693 	     end;
      694 	end;
      695 
      696 	return;
      697 
      698      end find_user_move_pdir;
      699 
      700 move_pdir_segs:
      701      proc (containing_dir, dir, level, entry, branch_ptr, names_ptr);
      702 
      703 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      704 /*										*/
      705 /* Internal procedure to demand segment move all of the segments in the current directory.	*/
      706 /*										*/
      707 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      708 
      709 dcl  containing_dir char (32) aligned parameter;		/* containing directory...		*/
      710 dcl  dir char (32) aligned parameter;			/* directory we're in...		*/
      711 dcl  entry char (32) aligned parameter;			/* entry that we will examine...	*/
      712 dcl  level fixed bin (17) parameter;			/* directory depth...		*/
      713 dcl  branch_ptr ptr parameter;			/* -> star_dir_list_branch...		*/
      714 dcl  names_ptr ptr parameter;				/* -> star_list_names...		*/
      715 
      716 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      717 
      718 
      719 /* START_move_pdir_segs: */
      720 
      721 	star_list_branch_ptr = branch_ptr;
      722 
      723 /* Only interseted in the first branch entry type,
      724*  and the next two statments keep the compiler happy */
      725           star_branch_count = 1;
      726           star_link_count = 0;
      727 
      728 	if star_list_branch.type (star_branch_count) ^= star_SEGMENT then return; /* ignore all but segments...		*/
      729 
      730 	call absolute_pathname_ (rtrim (containing_dir) || ">" || rtrim (dir),
      731 	     pdir_to_move, code);
      732 	if code ^= 0 then do;
      733 	     call sys_log_$error_log (2, code, "^a", rtrim (containing_dir) || ">" || rtrim (dir));
      734 	     return;
      735 	end;
      736 
      737 	call hphcs_$pv_move_file (pdir_to_move, (entry), code);
      738 	if code ^= 0 then call sys_log_$error_log (2, code, "vacate_pdir_volume: Unable to move ^a.",
      739 		rtrim (pdir_to_move) || ">" || rtrim (entry));
      740 
      741 	return;
      742 
      743      end move_pdir_segs;
      744 
      745 select_pdir_vol:
      746      proc (lvol_name, lvol_idx, lvol_id, code);
      747 
      748 dcl  lvol_name char (32) parameter;
      749 dcl  lvol_idx fixed bin (17) parameter;
      750 dcl  lvol_id bit (36) parameter;
      751 dcl  code fixed bin (35) parameter;
      752 
      753 /* go through mounted physical volumes in rotation, using shared_spindle_flip
      754*   to hit shared spindle devices half as often as others, since they use
      755*   two physical devices for a single actuator.  Two passes are necessary,
      756*   to cover the case where all pdir volumes are shared spindle type					*/
      757 
      758 	code = 0;
      759 	do pass_number = 1 to 2;			/* rotate thru all physical volumes..	*/
      760 	     do pvix = cur_pvix + 1 to dt.n_entries, 1 to cur_pvix; /* until we have selected a pdir volume */
      761 		dtep = addr (dt.array (pvix));	/* get ptr to pv entry */
      762 		if dte.device_type > 0 & dte.device_type <= maxdevt
      763 		     & shared_spindle (dte.device_type) /* shared spindle device			*/
      764 		     & shared_spindle_hack		/* and we're optimizing */
      765 		then dte.shared_spindle_flip = ^dte.shared_spindle_flip; /* hit half as often	*/
      766 		else dte.shared_spindle_flip = "1"b;	/* not shared spindle - hit every time		*/
      767 
      768 		if dte.used & dte.storage_system	/* see if it is ok */
      769 		     & dte.shared_spindle_flip
      770 		     & dte.lvx >= 1 & dte.lvx <= dt.n_lv_entries then do; /* be absolutely sure */
      771 		     lvep = addr (dt.lv_array (dte.lvx)); /* get ptr to its lv entry */
      772 		     if lve.used & lve.hv_mounted & lve.public & lve.pdirs_ok & read_allowed_ (ute.process_authorization, lve.min_access_class) &
      773 			write_allowed_ (ute.process_authorization, lve.max_access_class) then do; /* if it is usable for pdirs */
      774 			cur_pvix = pvix;		/* remember index of pv that we stopped on */
      775 			lvol_idx = dte.lvx;
      776 			lvol_name = lve.lvname;
      777 			lvol_id = lve.lvid;
      778 			return;
      779 		     end;				/* end lv selected */
      780 		end;				/* end pv in a pdir volume */
      781 	     end;					/* end rotation thru pvs */
      782 	end;
      783 
      784 	call sys_log_ (2, "^a: Unable to select volume for pdir of ^a.^a", ename, ute.person, ute.project);
      785 	code = error_table_$action_not_performed;
      786 
      787      end select_pdir_vol;
      788 
      789 /* ---------- */
      790 
      791 get_pdd_quota: proc;
      792 
      793 	call gq (">pdd");
      794 	if code ^= 0 then do;
      795 	     call sys_log_ (2, code, ename, "reading quota of >pdd");
      796 	     return;
      797 	end;
      798 
      799 	discrepancy = pddq - quota;			/* positive if there was a pdir creation we did not record */
      800 	dir_discrepancy = pdddir_q - dir_quota;
      801 	if already_init & discrepancy ^= 0 then do;	/* log discrepancy unless we are just initializing */
      802 	     call sys_log_ (0, "^a: ^[un^]expected discrepancy of ^d in >pdd quota: actual = ^d, recorded = ^d",
      803 		ename, pddq_known, discrepancy, quota, pddq);
      804 	     if ^pddq_known then			/* if previous call had ute.pdir_quota = 0, update our records */
      805 		pdq = pdq + discrepancy;
      806 	end;
      807 	if already_init & dir_discrepancy ^= 0 then do;	/* log discrepancy unless we are just initializing */
      808 	     call sys_log_ (0, "^a: ^[un^]expected discrepancy of ^d in >pdd dir_quota: actual = ^d, recorded = ^d",
      809 		ename, pddq_known, dir_discrepancy, dir_quota, pdddir_q);
      810 	     if ^pddq_known then			/* update our records */
      811 		pddir_q = pddir_q + dir_discrepancy;
      812 	end;
      813 
      814 	pddq = quota;
      815 	pdddir_q = dir_quota;
      816 	pddq_known = "1"b;
      817 	just_got_quota = "1"b;			/* for the benefit of set_pdd_quota */
      818 
      819 	if ^already_init then do;			/* if we are initializing */
      820 	     call gq (zzBB);			/* get quota of initializer's pdir */
      821 	     if code ^= 0 then do;
      822 		call sys_log_$error_log (2, code, ename, "reading quota of ^a", zzBB);
      823 		return;
      824 	     end;
      825 	     default_pdq = quota;			/* sneaky way of copying out active_hardcore_data$pdir_quota */
      826 	     default_pddir_q = dir_quota;
      827 	     pdq = quota;				/* initialize sum of all pdir quotas */
      828 	     pddir_q = dir_quota;
      829 	end;
      830 
      831 	return;
      832 
      833      end get_pdd_quota;
      834 
      835 /* ---------- */
      836 
      837 gq:  proc (dir);
      838 
      839 dcl  dir char (*);
      840 
      841 	call hcs_$quota_read (dir, quota, tpp, uptime, slvid, qswitch, qused, code);
      842 	call hcs_$dir_quota_read (dir, dir_quota, tpp, uptime, slvid, qswitch, qused, code);
      843 	return;
      844 
      845      end gq;
      846 
      847 /* ---------- */
      848 
      849 set_pdd_quota: proc;
      850 
      851 	if ^just_got_quota then call get_pdd_quota;	/* might as well look before we change it */
      852 
      853 	if ename = "note_pdir_deletion" then do;
      854 	     quota = max (0,			/* avoid going negative */
      855 		min (HALF_MAXQ,			/* set quota to HALF_MAXQ */
      856 		MAXQ - ute.pdir_quota - SAFETY_MARGIN));/* unless we are about to delete a very large pdir */
      857 	     dir_quota = max (0,			/* avoid going negative */
      858 		min (HALF_MAXQ,			/* set quota to HALF_MAXQ */
      859 		MAXQ - ute.pdir_dir_quota - SAFETY_MARGIN));/* unless we are about to delete a very large pdir */
      860 	end;
      861 	else do;
      862 	     quota = min (MAXQ,			/* avoid overflowing the quota cell */
      863 		max (HALF_MAXQ,			/* set quota to HALF_MAXQ */
      864 		ute.pdir_quota + SAFETY_MARGIN));	/* unless we are about to create a very large pdir */
      865 	     dir_quota = min (MAXQ,			/* avoid overflowing the quota cell */
      866 		max (HALF_MAXQ,			/* set quota to HALF_MAXQ */
      867 		ute.pdir_dir_quota + SAFETY_MARGIN));	/* unless we are about to create a very large pdir */
      868 	end;
      869 	call hphcs_$quota_set (">pdd", quota, code);
      870 	if code ^= 0 then do;
      871 	     call sys_log_$error_log (2, code, ename, "setting >pdd quota to ^d", quota);
      872 	     return;
      873 	end;
      874 	call hphcs_$dir_quota_set (">pdd", dir_quota, code);
      875 	if code ^= 0 then do;
      876 	     call sys_log_$error_log (2, code, ename, "setting >pdd dir_quota to ^d", dir_quota);
      877 	     return;
      878 	end;
      879 
      880 	call sys_log_ (0, "^a: changed >pdd quota from ^d to ^d", ename, pddq, quota);
      881 	pddq = quota;
      882 	call sys_log_ (0, "^a: changed >pdd dir_quota from ^d to ^d", ename, pdddir_q, dir_quota);
      883 	pdddir_q = dir_quota;
      884 
      885 	return;
      886      end set_pdd_quota;
      887 
      888 /* ---------- */
      889 
      890 set_shared_spindle: proc (on_or_off);
      891 
      892 dcl  on_or_off bit (1);
      893 
      894 	call sys_log_ (2, "^a: Shared-spindle optimization changed from ^[on^;off^] to ^[on^;off]",
      895 	     ename, shared_spindle_hack, on_or_off);
      896 	shared_spindle_hack = on_or_off;
      897 
      898 
      899 
      900      end set_shared_spindle;
      901 
      902 
      903 /* ---------- */
      904 
      905 valid_call: proc returns (bit (1) aligned);
      906 
      907 	if ^already_init then do;
      908 	     call sys_log_ (2, "^a: Called before answering service initialization", ename);
      909 	     return (""b);
      910 	end;
      911 
      912 	dtp = static_dtp;
      913 	return ("1"b);
      914 
      915      end valid_call;
      916 
      917  /* BEGIN INCLUDE FILE ... absentee_user_table.incl.pl1 */
  1     2 
  1     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 /*							       */
  1     5 /* The absentee user table is the control data base for the absentee	       */
  1     6 /* facility.  It has a header, with scheduling parameters, then one user     */
  1     7 /* table entry for each logged-in absentee job.			       */
  1     8 /*							       */
  1     9 /* Programs which use this table must also include		       */
  1    10 /* user_table_header.incl.pl1 and user_table_entry.incl.pl1.	       */
  1    11 /*							       */
  1    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    13 
  1    14 
  1    15 /****^  HISTORY COMMENTS:
  1    16*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  1    17*     Replace abs_user_tab.incl.pl1.
  1    18*  2) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  1    19*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  1    20*     Use ut_header common to all user control tables.
  1    21*                                                   END HISTORY COMMENTS */
  1    22 
  1    23 
  1    24 dcl  AUTBL_version_4 fixed bin int static options (constant) init (4);
  1    25 
  1    26 dcl  autp ptr automatic init (null);
  1    27 
  1    28 dcl 1 autbl based (autp) aligned,			/* a per system table to store info on absentee processes */
  1    29     2 header like ut_header,				/* Header common to all user tables. */
  1    30 
  1    31 /* Counter elements */
  1    32     2 n_abs_run fixed bin,				/* actual number of absentee processes current */
  1    33     2 max_abs_users fixed bin,			/* max number of background absentee processes permitted */
  1    34     2 n_background_abs fixed bin,			/* number of absentee processes not from foreground queue */
  1    35     2 n_sec_fg fixed bin,				/* number of secondary foreground absentee jobs */
  1    36     2 idle_units fixed bin,				/* used in adjusting abs_maxu dynamically */
  1    37     2 abs_units fixed bin,				/* part of anstbl.n_units used by background absentees */
  1    38     2 n_abs (4) fixed bin,				/* number of processes from each background queue */
  1    39     2 qres (4) fixed bin,				/* number of slots reserved for each background queue */
  1    40     2 rsc_waiting (-1:4) fixed bin,			/* number of requests waiting for resources, from each queue */
  1    41     2 qerr (-1:4) fixed bin,				/* number of consecutive errors for q (dropped if > QERR_MAX) */
  1    42     2 cpu_limit (4) fixed bin (35),			/* current per-queue cpu time limits */
  1    43 
  1    44 /* absentee user manager values. */
  1    45     2 defer_channel fixed bin (71),			/* IPC for time-defered queue entries */
  1    46     2 absentee_rq_chn fixed bin (71),			/* IPC channel for absentee requests */
  1    47     2 last_queue_searched fixed bin,			/* highest queue looked at by scheduler */
  1    48     2 debugging fixed bin,				/* take asdumps at strategic places */
  1    49     2 control,					/* see also whotab.incl.pl1 */
  1    50       3 mnbz bit (1) unal,				/* must not be zero */
  1    51       3 abs_maxu_auto bit (1) unal,			/* 1 if abs maxu has not been set by operator command */
  1    52       3 abs_maxq_auto bit (1) unal,			/* 1 if abs maxq has not been set by operator command */
  1    53       3 abs_qres_auto bit (1) unal,			/* 1 if abs qres has not been set by operator command */
  1    54       3 abs_cpu_limit_auto bit (1) unal,		/* 1 if abs cpu_limit has not been set by operator command */
  1    55       3 queue_dropped (-1:4) bit (1) unal,		/* 1 if queue has been dropped because of errors */
  1    56       3 abs_up bit (1) unal,				/* 1 if absentee facility is running */
  1    57       3 abs_stopped bit (1) unal,			/* 1 if abs stop command was issued */
  1    58 						/* both 1 if we're waiting for the last jobs to log out */
  1    59       3 aum_ctl bit (1) unal,				/* for AUM to tell AU to start a new sequence */
  1    60       3 lc_list bit (1) unal,				/* for AU to tell AUM that the lc list is non-empty */
  1    61 						/* comments in AU and AUM explain aum_ctl and lc_list */
  1    62       3 control_pad (21) bit (1) unal,			/* fill out rest of word */
  1    63     2 aum_pad fixed bin,
  1    64 
  1    65     2 entry_pad (80) fixed bin,			/*  pad table header to 128 words */
  1    66     2 entry (0 refer (autbl.current_size)) like ute;
  1    67 
  1    68 dcl AUTBL_CONTROL_NAMES (15) char(20) varying int static options(constant) init(
  1    69 	"mnbz",
  1    70 	"abs_maxu_auto",
  1    71 	"abs_maxq_auto",
  1    72 	"abs_qres_auto",
  1    73 	"abs_cpu_limit_auto",
  1    74 	"queue_dropped(-1)",
  1    75 	"queue_dropped( 0)",
  1    76 	"queue_dropped( 1)",
  1    77 	"queue_dropped( 2)",
  1    78 	"queue_dropped( 3)",
  1    79 	"queue_dropped( 4)",
  1    80 	"abs_up",
  1    81 	"abs_stopped",
  1    82 	"aum_ctl",
  1    83 	"lc_list");
  1    84 
  1    85 /* END INCLUDE FILE ... absentee_user_table.incl.pl1 */
      917 
      918  /* BEGIN INCLUDE FILE ... answer_table.incl.pl1 */
  2     2 
  2     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 /*							       */
  2     5 /* The answer table has one entry per "login instance" whether completed or  */
  2     6 /* not.  It is connected to the Channel Definition Table by the pointer      */
  2     7 /* "channel".  The header is used mostly by dialup_.		       */
  2     8 /*							       */
  2     9 /* Programs which use this file must also include user_table_header.incl.pl1 */
  2    10 /*							       */
  2    11 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    12 
  2    13 /****^  HISTORY COMMENTS:
  2    14*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  2    15*     Replace anstbl.incl.pl1.
  2    16*  2) change(85-01-15,Swenson), approve(), audit(), install():
  2    17*     Add anstbl.session_uid_counter.
  2    18*  3) change(85-08-21,Coren), approve(), audit(), install():
  2    19*     Add anstbl.message_update_time and named constants for values of
  2    20*     anstbl.session, and to make all padding explicit.
  2    21*  4) change(85-08-23,Coren), approve(), audit(), install():
  2    22*     Change "entry" to a placeholder so as not to require
  2    23*     user_table_entry.incl.pl1.
  2    24*  5) change(86-06-29,Swenson), approve(87-07-13,MCR7741),
  2    25*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
  2    26*     Added the flag login_server_present which indicates whether a login
  2    27*     server request has been received.  This is used to determine whether
  2    28*     dial_ctl_ should call uc_cleanup_network_dials_ (and thus
  2    29*     hpriv_connection_list_, which only exists with the MNA RPQ software).
  2    30*  6) change(87-04-14,GDixon), approve(87-07-13,MCR7741),
  2    31*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  2    32*      A) Moved constants for ute.pw_flags.mask_ctl into
  2    33*         user_table_entry.incl.pl1.
  2    34*      B) Added common table header to all user tables.
  2    35*                                                   END HISTORY COMMENTS */
  2    36 
  2    37 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    38 /*							       */
  2    39 /* The anstbl structure below is divided into sections.  Each section begins */
  2    40 /* with a comment describing the elements in the section.  Elements are      */
  2    41 /* placed within a section, based upon their function or the programs that   */
  2    42 /* use them.  Each section begins on a double word and is an even number of  */
  2    43 /* words long.						       */
  2    44 /*							       */
  2    45 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    46 
  2    47 
  2    48 
  2    49 /* format: style4 */
  2    50 
  2    51 dcl  ANSTBL_version_4 static options (constant) init (4);	/* version of this declaration */
  2    52 
  2    53 dcl  ansp ptr automatic init (null);
  2    54 
  2    55 dcl  1 anstbl based (ansp) aligned,			/* Structure of answer table */
  2    56        2 header like ut_header,			/* Header common to all user tables. */
  2    57 
  2    58 /* Counter elements. */
  2    59        2 nlin fixed bin,				/* number of active lines */
  2    60        2 mxlin fixed bin,				/* maximum number of active lines */
  2    61        2 n_users fixed bin,				/* number of logged-in users */
  2    62        2 max_users fixed bin,				/* maximum number of users allowed */
  2    63        2 n_units fixed bin,				/* number of logged in units */
  2    64        2 max_units fixed bin,				/* maximum number of units */
  2    65        2 n_sessions fixed bin,			/* number of Multics sessions */
  2    66        2 n_pad fixed bin,
  2    67 
  2    68 /* Name elements. */
  2    69        2 sysdir char (64) unal,			/* name of main system control directory */
  2    70        2 as_tty char (8) unal,			/* name of main answering service device. */
  2    71 
  2    72 /* Login elements. */
  2    73        2 login_word char (8) unal,			/* login word if special_session=1  */
  2    74        2 session char (8) unal,			/* session indicator */
  2    75        2 special_message char (128) unal,		/* message to be printed for special session */
  2    76        2 message_update_time fixed bin (71),		/* time at which special_message was last updated */
  2    77        2 message_lng fixed bin,			/* length of special message */
  2    78        2 login_pad fixed bin,
  2    79 
  2    80 /* Table update elements. */
  2    81        2 lock_count fixed bin,			/* global lock for all system control tables */
  2    82        2 update_pending bit (1) aligned,		/* flag indicating that update is required */
  2    83        2 update_channel fixed binary (71),		/* event channel of update procedure */
  2    84        2 acct_update_chn fixed bin (71) aligned,		/* Timer IPC channel */
  2    85        2 acct_last_update_time fixed bin (71) aligned,	/* Time of last accounting update */
  2    86        2 acct_alarm_fail fixed bin,			/* non-zero if alarm has failed */
  2    87        2 update_pad fixed bin,
  2    88 
  2    89 /* dialup_ data values. */
  2    90        2 current_time fixed bin (71),			/* Time of last transaction */
  2    91        2 processid_index fixed bin (18),		/* unique index for process id generation */
  2    92        2 session_uid_counter fixed bin (35),		/* current session_uid */
  2    93 
  2    94 /* load_ctl_ elements. */
  2    95        2 shift fixed bin,				/* Shift, set by act_ctl_ */
  2    96        2 auto_maxu fixed bin,				/* 0 = manual, 1 = config, 2 = load-level */
  2    97        2 extra_units fixed bin,			/* Total daemon and abs units. */
  2    98 						/* load_ctl_ load leveling desired response range: */
  2    99        2 response_high fixed bin,			/* bad if user response time slower than this */
  2   100        2 response_low fixed bin,			/* bad if user response time faster than this */
  2   101        2 load_ctl_pad fixed bin,
  2   102 
  2   103 /* Login server request server data. */
  2   104        2 ls_request_server_event_channel fixed bin (71),	/* channel for login server requests */
  2   105        2 ls_request_server_process_id bit (36) aligned,	/* process serving login server requests */
  2   106        2 login_server_present bit (1) aligned,		/* On IFF a login server request has been processed */
  2   107 
  2   108        2 entry_pad (28) fixed bin,			/* pad to 128 words */
  2   109        2 entry (0 refer (anstbl.current_size)),		/* user entries */
  2   110          3 contents (UTE_SIZE) fixed bin;
  2   111 
  2   112 /* constants */
  2   113 
  2   114 /* values for anstbl.session */
  2   115 
  2   116 dcl  (AT_NORMAL init ("normal  "),
  2   117      AT_SPECIAL init ("special "),
  2   118      AT_SHUTDOWN init ("shutdown")) char (8) internal static options (constant);
  2   119 
  2   120 dcl  UTE_SIZE fixed bin internal static initial (300);
  2   121 
  2   122 /* END INCLUDE FILE ... answer_table.incl.pl1 */
      918 
      919  /* BEGIN INCLUDE FILE ... as_data_.incl.pl1 ... */
  3     2 
  3     3 /* format: style4 */
  3     4 
  3     5 /* This file must be kept in sync with as_data_.alm */
  3     6 
  3     7 /****^  HISTORY COMMENTS:
  3     8*  1) change(86-09-21,Beattie), approve(86-09-22,MCR7542),
  3     9*     audit(86-10-31,Brunelle), install(86-11-12,MR12.0-1211):
  3    10*     Remove references to the 963 and 029 preaccess commands and remove support
  3    11*     for ARDS, 202_ETX, 2741 and 1050 in system interfaces.
  3    12*  2) change(86-09-25,Swenson), approve(87-07-20,MCR7737),
  3    13*     audit(87-07-20,GDixon), install(87-08-04,MR12.1-1056):
  3    14*     Add references to as_data_ entrypoints added for Login Server.
  3    15*  3) change(87-03-03,Brunelle), approve(87-07-20,MCR7697),
  3    16*     audit(87-07-20,GDixon), install(87-08-04,MR12.1-1056):
  3    17*     Added new user signal field of inacrcvd (14) to handle inactivity response
  3    18*     from user.
  3    19*                                                   END HISTORY COMMENTS */
  3    20 
  3    21 dcl  as_data_$BS char (1) aligned ext static;		/* BACKSPACE character */
  3    22 dcl  as_data_$CR char (1) aligned ext static;		/* CARRIAGE RETURN character */
  3    23 dcl  as_data_$abs_dim char (32) ext static;		/* absentee DIM */
  3    24 dcl  as_data_$acct_update_priority fixed bin ext static;	/* accounting update IPC priority */
  3    25 dcl  as_data_$acsdir char (168) ext static;		/* Access Control Segment directory */
  3    26 dcl  as_data_$ansp ptr ext static;			/* answer_table */
  3    27 dcl  as_data_$as_procid bit (36) aligned ext static;	/* Answering Service process id */
  3    28 dcl  as_data_$as_ring fixed bin (3) ext static;		/* AS operating ring */
  3    29 dcl  as_data_$as_tty char (6);			/* AS master tty channel */
  3    30 dcl  as_data_$asmtp ptr ext static;			/* AS meter table */
  3    31 dcl  as_data_$autp ptr ext static;			/* absentee_user_table */
  3    32 dcl  as_data_$buzzardp ptr ext static;			/* dpg_ list of buteo processes */
  3    33 dcl  as_data_$cdtp ptr ext static;			/* CDT */
  3    34 dcl  as_data_$default_weight fixed bin (35) ext;		/* default user process load control weight */
  3    35 dcl  as_data_$devtabp ptr ext static;			/* device_table */
  3    36 dcl  as_data_$dft_user_ring fixed bin (3) ext static;	/* default user ring */
  3    37 dcl  as_data_$dutp ptr ext static;			/* daemon_user_table */
  3    38 dcl  as_data_$g115_dim char (32) ext static;
  3    39 dcl  as_data_$lct_initialized bit (1) aligned ext static;	/* LCT allocated in ring 0 */
  3    40 dcl  as_data_$lct_size fixed bin ext static;		/* CDT tty channels + spares */
  3    41 dcl  as_data_$max_user_ring fixed bin (3) ext static;	/* maximum user ring */
  3    42 dcl  as_data_$mgtp ptr ext static;			/* master group table */
  3    43 dcl  as_data_$mrd_dim char (32) ext static;		/* daemon's message routing DIM */
  3    44 dcl  as_data_$ntty_dim char (32) ext static;		/* network connection DIM */
  3    45 dcl  as_data_$pdtdir char (168) ext static;		/* PDT directory */
  3    46 dcl  as_data_$pit_ptr ptr ext static;			/* pit_temp_ */
  3    47 dcl  as_data_$rcpdir char (168) ext static;		/* RCP directory */
  3    48 dcl  as_data_$request_priority fixed bin ext static;
  3    49 dcl  as_data_$rs_ptrs (0:9) ptr ext static;		/* rate_structures */
  3    50 dcl  as_data_$rtdtp ptr ext static;			/* RTDT */
  3    51 dcl  as_data_$sat_htp ptr ext static;			/* SAT hash table */
  3    52 dcl  as_data_$satp ptr ext static;			/* SAT */
  3    53 dcl  as_data_$suffix (0:9) char (2) unaligned ext static;
  3    54 dcl  as_data_$sysdir char (168) ext static;		/* system control directory */
  3    55 dcl  as_data_$teens_suffix (10:19) char (2) unaligned ext static;
  3    56 dcl  as_data_$terminet_tabs_string char (144) varying ext static;
  3    57 dcl  as_data_$tty_dim char (32) ext static;		/* standard interactive DIM */
  3    58 dcl  as_data_$update_priority fixed bin ext static;	/* ??? */
  3    59 dcl  as_data_$version char (8) ext static;		/* AS version */
  3    60 dcl  as_data_$whoptr ptr ext static;			/* whotab */
  3    61 
  3    62 dcl  1 as_data_$login_args aligned ext static,		/* control arguments for login */
  3    63        2 n_login_args fixed bin,
  3    64        2 pad fixed bin,
  3    65        2 login_args (55 /* as_data_$login_args.n_login_args */) char (24) unaligned;
  3    66 
  3    67 dcl  1 as_data_$signal_types ext static aligned,		/* IPC process control signals */
  3    68        2 n_signals fixed bin,
  3    69        2 pad fixed bin,
  3    70        2 signals (14 /* as_data_$signal_types.n_signals */) char (8) unaligned;
  3    71 
  3    72 dcl  1 as_data_$system_signal_types ext static aligned,	/* IPC process control signals */
  3    73        2 n_system_signals fixed bin,
  3    74        2 pad fixed bin,
  3    75        2 system_signals (10 /* as_data_$system_signal_types.n_system_signals */) char (8) unaligned;
  3    76 
  3    77 dcl  as_data_$login_words fixed bin ext static aligned,
  3    78 						/* interactive login words */
  3    79      1 as_data_login_words aligned based (addr (as_data_$login_words)),
  3    80        2 n_words fixed bin,
  3    81        2 pad fixed bin,
  3    82        2 words (0 refer (as_data_login_words.n_words)) char (16) unaligned;
  3    83 
  3    84 dcl  as_data_$debug_flag bit (1) aligned external static;
  3    85 dcl  as_data_$ls_request_server_info_ptr ptr external static;
  3    86 dcl  as_data_$ls_message_buffer_cur_lth fixed bin (18) external static;
  3    87 dcl  as_data_$ls_message_buffer_max_lth fixed bin (18) external static;
  3    88 dcl  as_data_$ls_message_buffer_ptr ptr external static;
  3    89 
  3    90 /* END INCLUDE FILE ... as_data_.incl.pl1 ... */
      919 
      920  /* BEGIN INCLUDE FILE ... as_data_definitions_.incl.pl1 ... */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  4     6*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4     7*     Removed ansp, autp and dutp from this include file, adding them to
  4     8*     answer_table.incl.pl1, absentee_user_table.incl.pl1 and
  4     9*     daemon_user_table.incl.pl1.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* This include file requires as_data_.incl.pl1 */
  4    14 
  4    15 /* format: style4 */
  4    16 
  4    17 dcl  as_procid bit (36) aligned defined (as_data_$as_procid);
  4    18 dcl  as_tty char (6) based (addr (as_data_$as_tty));
  4    19 dcl  asmtp ptr defined (as_data_$asmtp);
  4    20 dcl  devtabp ptr defined (as_data_$devtabp);
  4    21 dcl  ip ptr defined (as_data_$rs_ptrs (0));
  4    22 dcl  mgtp ptr defined (as_data_$mgtp);
  4    23 dcl  pdtdir char (168) based (addr (as_data_$pdtdir));
  4    24 dcl  rs_ptrs (0:9) ptr based (addr (as_data_$rs_ptrs (0)));
  4    25 dcl  sat_htp ptr defined (as_data_$sat_htp);
  4    26 dcl  satp ptr defined (as_data_$satp);
  4    27 dcl  scdtp ptr defined (as_data_$cdtp);
  4    28 dcl  sysdir char (168) defined (as_data_$sysdir);
  4    29 dcl  whoptr ptr defined (as_data_$whoptr);
  4    30 
  4    31 /* END INCLUDE FILE ... as_data_definitions_.incl.pl1 ... */
      920 
      921  /* BEGIN INCLUDE FILE ... daemon_user_table.incl.pl1 */
  5     2 
  5     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 /*							       */
  5     5 /* The daemon_user_table has one entry per daemon.  Daemons are logged in by */
  5     6 /* operator command or automatically.  If they do any I/O, it is done via    */
  5     7 /* the message coordinator.					       */
  5     8 /*							       */
  5     9 /* Programs using this include file must also use user_table_header.incl.pl1 */
  5    10 /* and user_table_entry.incl.pl1.				       */
  5    11 /*							       */
  5    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    13 
  5    14 
  5    15 /****^  HISTORY COMMENTS:
  5    16*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  5    17*     Initially coded from dutbl.incl.pl1.
  5    18*  2) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  5    19*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  5    20*      A) Add use of ut_header common to all user control tables.
  5    21*      B) Corrected padding prior to first ute entry.
  5    22*                                                   END HISTORY COMMENTS */
  5    23 
  5    24 
  5    25 dcl  DUTBL_version_4 fixed bin int static init (4);	/* version of this declaration */
  5    26 
  5    27 dcl  dutp ptr automatic init (null);
  5    28 
  5    29 dcl 1 dutbl based (dutp) aligned,			/* Daemon user table */
  5    30     2 header like ut_header,				/* Header common to all user tables. */
  5    31 
  5    32     2 active_count fixed bin,				/* the count of active daemons managed by DUM_ */
  5    33 
  5    34     2 entry_pad (117) fixed bin,			/* pad to 128 words */
  5    35     2 entry (0 refer (dutbl.current_size)) like ute;	/* daemon user entries */
  5    36 
  5    37 /* END INCLUDE FILE ... daemon_user_table.incl.pl1 */
      921 
      922  /* BEGIN INCLUDE FILE ... dialup_values.incl.pl1 */
  6     2 
  6     3 /* format: style4 */
  6     4 
  6     5 /* Values for "cdte.tra_vec" used by dialup_ and others. */
  6     6 
  6     7 /* Modified by T. Casey April 1976 to add WAIT_NEW_PASSWORD
  6     8*   -		in 1977 and 1978 to add WAIT_(GREETING_MSG DELETE_CHANNEL)
  6     9*   -		and in October 1979 to add WAIT_CONNECT_REQUEST
  6    10*   Modified by Robert Coren in May 1981 to add TANDD_ATTACH values and 
  6    11*		WAIT_DISCARD_WAKEUP
  6    12*   Modified by T. Casey, July 1981, for MR9.0, to add WAIT_BEFORE_HANGUP.
  6    13*   Modified by E. N. Kittlitz, July 1982, to add TTY_MASKED.
  6    14**/
  6    15 
  6    16 /****^  HISTORY COMMENTS:
  6    17*  1) change(87-04-20,GDixon), approve(87-07-13,MCR7741),
  6    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  6    19*     Add constant arrays naming cdte.state, cdte.tra_vec and ute.active values.
  6    20*  2) change(87-05-11,GDixon), approve(87-07-13,MCR7741),
  6    21*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  6    22*     Add named constants for instance tags.
  6    23*                                                   END HISTORY COMMENTS */
  6    24 
  6    25 dcl  (WAIT_DIALUP init (1),				/* Channel waiting for dialup. */
  6    26      WAIT_ANSWERBACK initial (2),			/* WRU sent, waiting for reply */
  6    27      WAIT_LOGIN_LINE init (3),			/* Greeting typed, wait for login command. */
  6    28      WAIT_LOGIN_ARGS init (4),			/* Want rest of login line */
  6    29      WAIT_OLD_PASSWORD init (5),			/* "-cpw" was specified. Wait for old password. */
  6    30      WAIT_PASSWORD init (6),				/* Waiting for password. (If "-cpw", repeat of new one.) */
  6    31      WAIT_NEW_PASSWORD init (7),			/* "-cpw" was specified. Wait for new password */
  6    32      WAIT_LOGOUT_SIG init (8),			/* Channel is hooked up. Wait for logout. */
  6    33      WAIT_LOGOUT init (9),				/* A logout has been requested. Wait for process to die */
  6    34      WAIT_LOGOUT_HOLD init (10),			/* As above but don't hang up when it dies. */
  6    35      WAIT_DETACH init (11),				/* As above but ignore channel afterwards. */
  6    36      WAIT_NEW_PROC init (12),				/* As above but make new process and continue. */
  6    37      WAIT_REMOVE init (13),				/* As above but completely expunge channel. */
  6    38      WAIT_FIN_PRIV_ATTACH init (14),			/* When channel dials up, connect it to user */
  6    39      WAIT_DIAL_RELEASE init (15),			/* Waiting for master process to release. */
  6    40      WAIT_DIAL_OUT init (16),				/* Waiting for auto call to complete */
  6    41      WAIT_HANGUP init (17),				/* Wait for the hangup event to occur for a channel */
  6    42      WAIT_SLAVE_REQUEST init (18),			/* Ignore line until someone asks */
  6    43      WAIT_GREETING_MSG init (19),			/* Print greeting message and wait for login line */
  6    44      WAIT_DELETE_CHANNEL init (20),			/* Channel deleted - mark cdte after process is destroyed */
  6    45      WAIT_CONNECT_REQUEST init (21),			/* logged in; awaiting request re disconnected processes */
  6    46      WAIT_TANDD_HANGUP init (22),			/* when channel hangs up, proceed with t & d attachment */
  6    47      WAIT_FIN_TANDD_ATTACH init (23),			/* when channel dials up, finish t & d attachment */
  6    48      WAIT_DISCARD_WAKEUPS init (24),			/* disregard all wakeups on channel */
  6    49      WAIT_BEFORE_HANGUP init (25),			/* allow output to print before hanging up */
  6    50      WAIT_DESTROY_REQUEST init (26),			/* waiting to continue with destroy request after process has destroyed itself */
  6    51      WAIT_NEW_PROC_REQUEST init (27)			/* waiting to continue with new_proc request after process has destroyed itself */
  6    52      ) fixed bin internal static options (constant);
  6    53 
  6    54 dcl  TRA_VEC_VALUES (0:13) char (32) aligned int static options (constant) init
  6    55 						/* names of ute.destroy_flag values */
  6    56 	("", "wait dialup", "wait answerback", "wait login line", /*  0-3  */
  6    57 	"wait login args", "wait old password", "wait password",  /*  4-6  */
  6    58 	"wait new password", "wait logout signal", "wait logout", /*  7-9  */
  6    59 	"wait logout hold", "wait detach", "wait new proc",       /* 10-12 */
  6    60 	"wait remove");				        /*   -13 */
  6    61 
  6    62 /* Values for "cdte.state", typewriter state. */
  6    63 
  6    64 dcl  (TTY_MASKED init (-1),				/* Terminal channel is there, but masked by MCS */
  6    65      TTY_HUNG init (1),				/* Terminal channel is there, but dead. */
  6    66      TTY_KNOWN init (2),				/* Channel being "listened" to, awaiting dialup. */
  6    67      TTY_DIALED init (5)				/* Channel is dialed up. This is normal state. */
  6    68      ) fixed bin internal static options (constant);
  6    69 
  6    70 dcl  STATE_VALUES (-1:5) char (15) aligned int static options (constant) init
  6    71 						/* names of cdte.state values */
  6    72 	("masked", "dead", "hung up", "listening", "", "", "dialed up");
  6    73 
  6    74 /* Values for "cdte.in_use" and "ate.active" */
  6    75 
  6    76 dcl  (NOW_FREE init (0),				/* Entry is empty. */
  6    77      NOW_HUNG_UP init (1),				/* Entry is usable but tty is hung up. */
  6    78      NOW_LISTENING init (2),				/* Entry is waiting for phone call. */
  6    79      NOW_DIALED init (3),				/* Entry is connected but login not complete. */
  6    80      NOW_LOGGED_IN init (4),				/* Entry is logged in but no process. */
  6    81      NOW_HAS_PROCESS init (5),			/* Entry has a valid process. */
  6    82      NOW_DIALING init (6),				/* Entry (auto_call line) is dialing */
  6    83      NOW_DIALED_OUT init (7)				/* Entry (auto_call line) is in use */
  6    84      ) fixed bin internal static options (constant);
  6    85 
  6    86 dcl  ACTIVE_VALUES (0:5) char (18) aligned int static options (constant) init
  6    87 						/* names of ute.active values */
  6    88 	("free", "hung-up", "listening", "dialed", "logged in, no proc", "logged in & proc");
  6    89 
  6    90 
  6    91 /**** Values for ute.tag */
  6    92 
  6    93 dcl (TAG_INTERACTIVE init("a"),
  6    94      TAG_UFT init("f"),
  6    95      TAG_ABSENTEE init("m"),
  6    96      TAG_PROXY init("p"),
  6    97      TAG_DAEMON init("z")
  6    98      ) char(1) int static options(constant);
  6    99 
  6   100 
  6   101 /**** Following are constants used to indicate to the process termination
  6   102*      handler the reason for the process termination.  They are used by
  6   103*      uc_proc_term_handler_, as well as uc_ls_new_proc_request_ and
  6   104*      uc_ls_destroy_request_. */
  6   105 
  6   106 dcl  (
  6   107      PT_FPE initial (1),
  6   108      PT_LOGOUT initial (4),
  6   109      PT_NEW_PROC_AUTH initial (13),
  6   110      PT_HANGUP initial (20),
  6   111      PT_SHUTDOWN initial (21),
  6   112      PT_BUMP initial (22),
  6   113      PT_ALARM initial (23),
  6   114      PT_DETACH initial (24),
  6   115      PT_UNBUMP initial (25),
  6   116      PT_OPERATOR_TERMINATE initial (27),
  6   117      PT_DESTROY_REQUEST initial (30),
  6   118      PT_NEW_PROC_REQUEST initial (31)
  6   119      ) fixed bin (17) internal static options (constant);
  6   120 
  6   121 /**** Values for ute.preempted:
  6   122*  -1  user unbumped after term signal sent
  6   123*   0  user unbumped; ignore alarm___
  6   124*   1  value internally used in load_ctl_
  6   125*   2  user bumped; when alarm___ comes in, send term signal
  6   126*   3  term signal sent; destroy process if termsgnl, alarm___, or cpulimit 
  6   127*      signals come in
  6   128*   4  user bumped; process sick, so destroy without sending term signal
  6   129*   5  trm_ signal sent, termsgnl received; (if still 3, we never got the 
  6   130*      termsgnl).						       */
  6   131 
  6   132 dcl  (
  6   133      PREEMPT_UNBUMP initial (-1),
  6   134      PREEMPT_UNBUMP_IGNORE_ALARM initial (0),
  6   135      PREEMPT_LOAD_CTL initial (1),
  6   136      PREEMPT_BUMPED initial (2),
  6   137      PREEMPT_TERM_SENT initial (3),
  6   138      PREEMPT_BUMPED_NO_TERM initial (4),
  6   139      PREEMPT_TERMSGNL_RECEIVED initial (5)
  6   140      ) fixed bin (17) internal static options(constant);
  6   141 
  6   142 dcl  PREEMPT_VALUES (-1:5) char(28) varying int static options(constant) init(
  6   143 	"unbumped",
  6   144 	"not bumped, ignore alarm___",
  6   145 	"load_ctl_",
  6   146 	"bumped",
  6   147 	"bumped, trm_ sent",
  6   148 	"bumped without trm_",
  6   149 	"bumped, termsgnl received");
  6   150 
  6   151 /* END INCLUDE FILE ... dialup_values.incl.pl1 */
      922 
      923  /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  7     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  7     7*     Add support for subvolumes.
  7     8*                                                   END HISTORY COMMENTS */
  7     9 
  7    10 
  7    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  7    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  7    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  7    14 
  7    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  7    16 
  7    17 dcl  dtp ptr,
  7    18      dtep ptr,
  7    19      lvep ptr;
  7    20 
  7    21      
  7    22 
  7    23 dcl 1 dt based (dtp) aligned,
  7    24 
  7    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  7    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  7    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  7    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  7    29     2 version fixed bin init (1),
  7    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  7    31     2 pad (2) bit (36),
  7    32     2 array (0 refer (dt.max_n_entries)) like dte,
  7    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  7    34 
  7    35 dcl 1 dte based (dtep) aligned,
  7    36     2 drive_name char (8),				/* device name */
  7    37     (2 device_type fixed bin (8),			/* device type */
  7    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  7    39     2 known bit (1),				/* TRUE if label has been read and checked */
  7    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  7    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  7    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  7    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  7    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  7    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  7    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  7    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  7    48     2 is_sub_vol bit (1),
  7    49     2 pad bit (3),
  7    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  7    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  7    52     2 sv_num  fixed bin unal,				/* this sv number */
  7    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  7    54     2 sv_name   char (2) aligned,
  7    55     2 pvid bit (36),				/* physical volume ID */
  7    56     2 pvname char (32);				/* Physical volume name. */
  7    57 
  7    58 dcl 1 lve based (lvep) aligned,
  7    59     2 lvid bit (36),				/* logical volume ID */
  7    60     (2 used bit (1),				/* TRUE if entry used */
  7    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  7    62     2 public bit (1),				/* TRUE for public vol */
  7    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  7    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  7    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  7    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  7    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  7    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  7    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  7    70     2 pad bit (26)) unal,
  7    71     2 lvname char (32),				/* Logical volume name */
  7    72     2 min_access_class bit (72),			/* Security stuff */
  7    73     2 max_access_class bit (72);			/* .. */
  7    74 
  7    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      923 
      924  /* Begin include file ...... fs_dev_types.incl.pl1 */
  8     2 
  8     3 /****^  HISTORY COMMENTS:
  8     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  8     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  8     6*     Add support for FIPS
  8     7*     3380.
  8     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  8     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  8    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  8    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  8    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  8    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  8    14*                                                   END HISTORY COMMENTS */
  8    15 
  8    16 /* Modified 5/19/76 by N. I. Morris */
  8    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  8    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  8    19 /* Modified '82 by BIM for needs_alt_part */
  8    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  8    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  8    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  8    23*   volmap and record stock can be expanded. */
  8    24 
  8    25 /*
  8    26********************************************************************************
  8    27**							        *
  8    28**                           WARNING:                                          *
  8    29**							        *
  8    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  8    31**   type is added.						        *
  8    32**							        *
  8    33**   There are other include files that contain arrays indexed by the device   *
  8    34**   index obtained by references to MODELX or MODELN in this include file.    *
  8    35**   These must be modified when a new device type is added:		        *
  8    36**   disk_pack.incl.pl1					        *
  8    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  8    38**							        *
  8    39********************************************************************************
  8    40**/
  8    41 
  8    42 
  8    43 dcl (maxdevt init (9),				/* maximum legal devt */
  8    44      bulkdevt init (1),				/* bulk store devt */
  8    45      msu0500devt init (2),				/* MSU0500 device type */
  8    46      msu0451devt init (3),				/* MSU0451 device type */
  8    47      msu0450devt init (3),				/* MSU0450 device type */
  8    48      msu0400devt init (4),				/* MSU0400 device type */
  8    49      dsu191devt init (4),				/* DSU191 device type */
  8    50      dsu190devt init (5),				/* DSU190 device type */
  8    51      dsu181devt init (6),				/* DSU181 device type */
  8    52      msu0501devt init (7),				/* MSU0501 device type */
  8    53      fips3380devt init (8),				/* 3380D FIPS device type */
  8    54      fips3381devt init (9)				/* 3380E FIPS device type */
  8    55      ) fixed bin (4) static options (constant);
  8    56 
  8    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  8    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  8    59 
  8    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  8    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  8    62 
  8    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  8    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  8    65 
  8    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  8    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  8    68 
  8    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  8    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  8    71 
  8    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  8    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  8    74 
  8    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  8    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  8    77 
  8    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  8    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  8    80 
  8    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  8    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  8    83 
  8    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  8    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  8    86 
  8    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  8    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  8    89 
  8    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  8    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  8    92 
  8    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  8    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  8    95 
  8    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  8    97      ("abc");
  8    98 
  8    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  8   100      init ("a","b","c");
  8   101 
  8   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  8   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  8   104 
  8   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  8   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  8   107 
  8   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  8   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  8   110 
  8   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  8   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  8   113 
  8   114 
  8   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  8   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  8   117 
  8   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  8   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  8   120 
  8   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  8   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  8   123 
  8   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  8   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  8   126 
  8   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  8   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  8   129 
  8   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  8   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  8   132 
  8   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  8   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  8   135 
  8   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  8   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  8   138 
  8   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  8   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  8   141 
  9     1 /* Begin fs_dev_types_sector.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  9     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  9     7*     Add the sector differance for devices that do 64 word IO and devices that
  9     8*     do 512 word IO.
  9     9*                                                   END HISTORY COMMENTS */
  9    10 
  9    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  9    12*	 need all the data in fs_dev_types. This is also included in
  9    13*	 fs_dev_types.incl.pl1  */
  9    14 
  9    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  9    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  9    17 
  9    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  9    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  9    20 
  9    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  9    22  /* table of # of sectors per record on each device */
  9    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  9    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  9    25 
  9    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  9    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  9    28 	
  9    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  9    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  9    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  9    32 
  9    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  9    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  9    35 
  9    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  9    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  9    38 
  9    39 /* End fs_dev_types_sector.incl.pl1 */
  9    40 
  8   142 
  8   143 
  8   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      924 
      925  /*  BEGIN:   sc_stat_.incl.pl1			  *  *  *  *  *  */
 10     2 
 10     3 
 10     4 /****^  HISTORY COMMENTS:
 10     5*  1) change(87-02-04,GDixon), approve(87-05-25,MCR7690),
 10     6*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 10     7*     Add sc_stat_$vchn_requires_accept in support of DSA virtual channels.
 10     8*  2) change(87-02-04,GDixon), approve(87-05-25,MCR7680),
 10     9*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
 10    10*     Reorganized by type of data to improve readability.
 10    11*                                                   END HISTORY COMMENTS */
 10    12 
 10    13 
 10    14 			      /* ACCESS NAMES		       */
 10    15 dcl (
 10    16  sc_stat_$exec_access_name,	      /* check MC access in an exec request    */
 10    17  sc_stat_$unidentified_access_name  /* check access if no one is logged in.  */
 10    18     ) char(32) ext static;
 10    19 
 10    20 		        /* PATHNAMES			       */
 10    21 dcl (
 10    22  sc_stat_$info_dir,	        /* admin info segs directory		       */
 10    23  sc_stat_$log_dir,	        /* as log segs directory		       */
 10    24  sc_stat_$mc_acs_dir,       /* message coordinator ACS segments (.mcacs) dir */
 10    25  sc_stat_$sysdir	        /* system control directory		       */
 10    26     ) char(168) ext static;
 10    27 
 10    28 		        /* OTHER CHAR STRINGS			       */
 10    29 dcl (
 10    30  sc_stat_$master_channel    /* Master TTY channel.		       */
 10    31     )  char(6) aligned ext static;
 10    32 
 10    33 			       /* LABELS			       */
 10    34 dcl (
 10    35  sc_stat_$admin_listener_exit_label, /* GO here to exit admin mode.  Set to  */
 10    36 			       /*    ssu_$null_label unless 	       */
 10    37 			       /*	   admin_listener is active.	       */
 10    38  sc_stat_$master_abort_label,	       /* GO here after fault that is not      */
 10    39 			       /*    attributable to a particular      */
 10    40 			       /*	   command.		       */
 10    41  sc_stat_$system_shutdown_label      /* GO here to shut down system	       */
 10    42     ) label variable ext static;
 10    43 
 10    44 			 /* POINTERS TO			       */
 10    45 dcl (
 10    46  sc_stat_$admin_log_iocb,	 /* IOCB for admin log		       */
 10    47  sc_stat_$admin_log_write_ptr, /* DATA for log_write_ calls on the admin log */
 10    48  sc_stat_$admin_sci_ptr,	 /* DATA ssu_ for terminal currently executing */
 10    49  sc_stat_$as_log_write_ptr,	 /* DATA for log_write_ calls on as log, used  */
 10    50 			 /*      by sys_log_.		       */
 10    51  sc_stat_$initzer_ttyp,	 /* ENT  mc_ate for initializer terminal       */
 10    52  sc_stat_$master_iocb,	 /* IOCB for "master_i/o"		       */
 10    53  sc_stat_$master_sci_ptr,	 /* DATA ssu_ (permanent) for system control   */
 10    54  sc_stat_$mc_ansp,		 /* HEAD of mc_anstbl		       */
 10    55  sc_stat_$mc_iocb,		 /* IOCB ptr for "mc_i/o"		       */
 10    56  sc_stat_$sv1_iocb,		 /* IOCB ptr for "severity1"		       */
 10    57  sc_stat_$sv2_iocb,		 /* IOCB ptr for "severity2"		       */
 10    58  sc_stat_$sv3_iocb		 /* IOCB ptr for "severity3"		       */
 10    59     ) ptr ext static;
 10    60 
 10    61 			   /* SWITCHES			       */
 10    62 dcl (
 10    63  sc_stat_$Go,		   /* TRUE after answering service is listening*/
 10    64  sc_stat_$Go_typed,		   /* TRUE immediately after 'go' is typed     */
 10    65  sc_stat_$Multics,		   /* TRUE after answering service started     */
 10    66  sc_stat_$Multics_typed,	   /* TRUE immediately after 'mult' is typed   */
 10    67  sc_stat_$Star_typed,	   /* TRUE if 'mult' and 'go' came from 'star' */
 10    68  sc_stat_$admin_listener_switch, /* TRUE if in the admin listener	       */
 10    69  sc_stat_$did_part1,	   /* TRUE if part 1 of system startup ec done */
 10    70  sc_stat_$did_part2,	   /* TRUE if part 2 of system startup ec done */
 10    71  sc_stat_$did_part3,	   /* TRUE if part 3 of system startup ec done */
 10    72  sc_stat_$mc_is_on,		   /* TRUE if message coordinator running      */
 10    73  sc_stat_$no_operator_login,	   /* TRUE if operator login not required, or  */
 10    74 			   /*	 if PNT not yet available.	       */
 10    75  sc_stat_$shutdown_typed,	   /* TRUE if 'shutdown' command in progress.  */
 10    76  sc_stat_$test_mode,	   /* TRUE if in test environment	       */
 10    77  sc_stat_$vchn_requires_accept   /* TRUE if vchn may only be used if accepted*/
 10    78 			   /*      by operator signed on system console*/
 10    79     ) bit(1) aligned ext static;
 10    80 
 10    81 
 10    82 /*  END OF:  sc_stat_.incl.pl1			  *  *  *  *  *  */
      925 
      926  /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
 11     2 
 11     3 /* This include file contains structures for the hcs_$star_,
 11     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
 11     5*
 11     6*   Written 23 October 1978 by Monte Davidoff.
 11     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
 11     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
 11     9**/
 11    10 
 11    11 /* automatic */
 11    12 
 11    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
 11    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
 11    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
 11    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
 11    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
 11    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
 11    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
 11    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
 11    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
 11    22 
 11    23 /* based */
 11    24 
 11    25 /* hcs_$star_ entry structure */
 11    26 
 11    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
 11    28         2 type fixed binary (2) unsigned unaligned,
 11    29 						/* storage system type */
 11    30         2 nnames fixed binary (16) unsigned unaligned,
 11    31 						/* number of names of entry that match star_name */
 11    32         2 nindex fixed binary (18) unsigned unaligned;
 11    33 						/* index of first name in star_names */
 11    34 
 11    35 /* hcs_$star_ name structure */
 11    36 
 11    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
 11    38 
 11    39 /* hcs_$star_list_ branch structure */
 11    40 
 11    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 11    42         2 type fixed binary (2) unsigned unaligned,
 11    43 						/* storage system type */
 11    44         2 nnames fixed binary (16) unsigned unaligned,
 11    45 						/* number of names of entry that match star_name */
 11    46         2 nindex fixed binary (18) unsigned unaligned,
 11    47 						/* index of first name in star_list_names */
 11    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
 11    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
 11    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
 11    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
 11    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
 11    53         2 pad bit (7) unaligned,
 11    54         2 records fixed binary (18) unsigned unaligned;
 11    55 						/* records used by branch */
 11    56 
 11    57 /* hcs_$star_dir_list_ branch structure */
 11    58 
 11    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 11    60         2 type fixed binary (2) unsigned unaligned,
 11    61 						/* storage system type */
 11    62         2 nnames fixed binary (16) unsigned unaligned,
 11    63 						/* number of names of entry that match star_name */
 11    64         2 nindex fixed binary (18) unsigned unaligned,
 11    65 						/* index of first name in star_list_names */
 11    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
 11    67         2 pad bit (36) unaligned,
 11    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
 11    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
 11    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
 11    71         2 bit_count fixed binary (24) unaligned;
 11    72 						/* bit count of the branch */
 11    73 
 11    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
 11    75 
 11    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 11    77         2 type fixed binary (2) unsigned unaligned,
 11    78 						/* storage system type */
 11    79         2 nnames fixed binary (16) unsigned unaligned,
 11    80 						/* number of names of entry that match star_name */
 11    81         2 nindex fixed binary (18) unsigned unaligned,
 11    82 						/* index of first name in star_list_names */
 11    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
 11    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
 11    85         2 pathname_len fixed binary (18) unsigned unaligned,
 11    86 						/* length of the pathname of the link */
 11    87         2 pathname_index fixed binary (18) unsigned unaligned;
 11    88 						/* index of start of pathname in star_list_names */
 11    89 
 11    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
 11    91 
 11    92 declare  star_list_names char (32) based (star_list_names_ptr)
 11    93 	dimension (star_links (star_branch_count + star_link_count).nindex
 11    94 	 + star_links (star_branch_count + star_link_count).nnames
 11    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
 11    96 	   * binary (
 11    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
 11    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
 11    99 
 11   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
 11   101 
 11   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
 11   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
 11   104 
 11   105 /* internal static */
 11   106 
 11   107 /* star_select_sw values */
 11   108 
 11   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
 11   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
 11   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
 11   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
 11   113          fixed binary (3) internal static options (constant) initial (5);
 11   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
 11   115          fixed binary (3) internal static options (constant) initial (7);
 11   116 
 11   117 /* storage system types */
 11   118 
 11   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
 11   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
 11   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
 11   122 
 11   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
      926 
      927  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
 12     2 
 12     3 
 12     4 /****^  HISTORY COMMENTS:
 12     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
 12     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
 12     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
 12     8*     attribute switches.
 12     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
 12    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 12    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
 12    12*         be deleted.
 12    13*      B) Add constants identifying attributes that can be changed by user at
 12    14*         login, etc.
 12    15*                                                   END HISTORY COMMENTS */
 12    16 
 12    17 
 12    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
 12    19 
 12    20 /* format: style4 */
 12    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
 12    22        (2 administrator bit (1),			/* 1  system administrator privileges */
 12    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
 12    24        2 nobump bit (1),				/* 2  user cannot be bumped */
 12    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
 12    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
 12    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
 12    28*						   .  of same project (distinct from "nobump") */
 12    29        2 nolist bit (1),				/* 7  don't list user on "who" */
 12    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
 12    31        2 multip bit (1),				/* 9  user may have several processes */
 12    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
 12    33        2 brief bit (1),				/* 11 no login or logout message */
 12    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
 12    35        2 vhomedir bit (1),				/* 13 user may change homedir */
 12    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
 12    37        2 sb_ok bit (1),				/* 15 user may be standby */
 12    38        2 pm_ok bit (1),				/* 16 user may be primary */
 12    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
 12    40        2 daemon bit (1),				/* 18 user may login as daemon */
 12    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
 12    42        2 no_warning bit (1),				/* 20 no warning message */
 12    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
 12    44*						   .  in PDT: this user has an individual load control group */
 12    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
 12    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
 12    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
 12    48        2 pad bit (12)) unaligned;
 12    49 
 12    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
 12    51     ("none",					/* 0 */
 12    52      "administrator",				/* 1 */
 12    53      "primary_line",				/* 2 */
 12    54      "nobump",					/* 3 */
 12    55      "guaranteed_login",				/* 4 */
 12    56      "anonymous",					/* 5 */
 12    57      "nopreempt",					/* 6 */
 12    58      "nolist",					/* 7 */
 12    59      "dialok",					/* 8 */
 12    60      "multip",					/* 9 */
 12    61      "bumping",					/* 10 */
 12    62      "brief",					/* 11 */
 12    63      "vinitproc",					/* 12 */
 12    64      "vhomedir",					/* 13 */
 12    65      "nostartup",					/* 14 */
 12    66      "no_secondary",				/* 15 */
 12    67      "no_prime",					/* 16 */
 12    68      "no_eo",					/* 17 */
 12    69      "daemon",					/* 18 */
 12    70      "",						/* 19 vdim OBSOLETE */
 12    71      "no_warning",					/* 20 */
 12    72      "igroup",					/* 21 */
 12    73      "save_pdir",					/* 22 */
 12    74      "disconnect_ok",				/* 23 */
 12    75      "save_on_disconnect");				/* 24 */
 12    76 
 12    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
 12    78     ("null",					/* 0 */
 12    79      "admin",					/* 1 */
 12    80      "", "",					/* 2 - 3 */
 12    81      "guar",					/* 4 */
 12    82      "anon",					/* 5 */
 12    83      "", "",					/* 6 - 7 */
 12    84      "dial",					/* 8 */
 12    85      "multi_login",					/* 9 */
 12    86      "preempting",					/* 10 */
 12    87      "",						/* 11 */
 12    88      "v_process_overseer",				/* 12 */
 12    89      "v_home_dir",					/* 13 */
 12    90      "no_start_up",					/* 14 */
 12    91      "no_sec",					/* 15 */
 12    92      "no_primary",					/* 16 */
 12    93      "no_edit_only",				/* 17 */
 12    94      "op_login",					/* 18 */
 12    95      "",						/* 19 */
 12    96      "nowarn",					/* 20 */
 12    97      "", "", "",					/* 21 - 23 */
 12    98      "save");					/* 24 */
 12    99 
 12   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
 12   101      options(constant) init("000000000010000000010000000000000000"b);
 12   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
 12   103 
 12   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
 12   105      options(constant) init("000000000010000000010000000000000000"b);
 12   106     /* PDT value for (brief, no_warning) is default */
 12   107 
 12   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
 12   109      options(constant) init("000100000110010000010000000000000000"b);	
 12   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
 12   111 
 13     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
 13     2 
 13     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 13     4 /*							       */
 13     5 /* This include file describes the attributes of an absentee job.  It is     */
 13     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
 13     7 /* and PIT.incl.pl1.   */
 13     8 /*							       */
 13     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 13    10 
 13    11 /****^  HISTORY COMMENTS:
 13    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
 13    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 13    14*     Separated abs_attributes from the request structure
 13    15*     (abs_message_format.incl.pl1) so that the identical structure could be
 13    16*     used in the ute structure (user_table_entry.incl.pl1).
 13    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
 13    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 13    19*     Added ABS_ATTRIBUTE_NAMES array.
 13    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
 13    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
 13    22*     Added the no_start_up flag. SCP6367
 13    23*                                                   END HISTORY COMMENTS */
 13    24 
 13    25 dcl 1 user_abs_attributes		aligned based,
 13    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
 13    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
 13    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
 13    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
 13    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
 13    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
 13    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
 13    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
 13    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
 13    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
 13    36       2 attributes_pad		bit (26) unaligned;
 13    37 
 13    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
 13    39 	"restartable",
 13    40 	"user_deferred_until_time",
 13    41 	"proxy",
 13    42 	"set_bit_cnt",
 13    43 	"time_in_gmt",
 13    44 	"user_deferred_indefinitely",
 13    45 	"secondary_ok",
 13    46 	"truncate_absout",
 13    47 	"restarted",
 13    48 	"no_start_up");
 13    49 
 13    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
 13    51 
 12   112 
 12   113 
 12   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      927 
      928  /*  BEGIN INCLUDE FILE ... user_table_entry.incl.pl1 */
 14     2 
 14     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14     4 /*							       */
 14     5 /* This include file requires that the user include		       */
 14     6 /* user_attributes.incl.pl1 as well.  It also includes		       */
 14     7 /* abs_attributes.incl.pl1 itself.				       */
 14     8 /*							       */
 14     9 /* This include file must be included to use absentee_user_table.incl.pl1,   */
 14    10 /* answer_table.incl.pl1, and daemon_user_table.incl.pl1.		       */
 14    11 /*							       */
 14    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14    13 
 14    14 /****^  HISTORY COMMENTS:
 14    15*  1) change(81-12-21,Gilcrease), approve(86-03-27,MCR7370),
 14    16*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
 14    17*     This comment for hcom.
 14    18*     81-12-21  E. N. Kittlitz. derived from abs_user_tab.incl.pl1,
 14    19*     anstbl.incl.pl1, and dutbl.incl.pl1.
 14    20*     82-01-02 E. N. Kittlitz. user_attributes.incl.pl1 changes
 14    21*     84-04-04 BIM added privileged_dial_server and dial_server_ring
 14    22*     84-07-12 BIM added min_process_authorization
 14    23*     84-12-31 Keith Loepere added pdir_dir_quota
 14    24*     85-01-16 by E. Swenson to add ute.session_uid
 14    25*  2) change(85-11-16,Swenson), approve(87-07-13,MCR7737),
 14    26*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
 14    27*     Added fields for DSA login server support.
 14    28*  3) change(86-03-27,Gilcrease), approve(86-03-27,MCR7370),
 14    29*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
 14    30*     Add truncate_absout and restarted bit for -truncate absout, SCP6297.
 14    31*  4) change(86-04-09,Herbst), approve(87-07-13,MCR7697),
 14    32*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
 14    33*     Added disconnection_rel_minutes.
 14    34*  5) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
 14    35*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 14    36*     Changed structure under ute.abs_attributes to use like structure in
 14    37*     abs_attributes.incl.pl1.  This allows the same attributes to be used
 14    38*     in abs_message_format.incl.pl1 and pit.incl.pl1 as well as this include
 14    39*     file.
 14    40*  6) change(87-04-14,GDixon), approve(87-07-13,MCR7741),
 14    41*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 14    42*     Move constants for ute.pw_flags.mask_ctl from answer_table.incl.pl1.
 14    43*  7) change(87-04-16,GDixon), approve(87-07-13,MCR7741),
 14    44*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 14    45*      A) Global reorganization to locate things by type of data.
 14    46*      B) Eliminate ute.uflags.logged_in.
 14    47*  8) change(87-05-10,GDixon), approve(87-07-13,MCR7741),
 14    48*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 14    49*      A) Reduced overlength person and project fields to proper length.
 14    50*      B) Adjusted dialed-console section to begin on even word boundary.
 14    51*  9) change(87-05-13,GDixon), approve(87-07-13,MCR7741),
 14    52*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 14    53*     Add ute.line_type.
 14    54* 10) change(87-11-19,Parisek), approve(88-02-11,MCR7849),
 14    55*     audit(88-02-23,Lippard), install(88-07-13,MR12.2-1047):
 14    56*     Added the lowest_ring element. Used the upper half of ute.highest_ring
 14    57*     for the storage.  SCP6367
 14    58*                                                   END HISTORY COMMENTS */
 14    59 
 14    60 /* format: style4 */
 14    61 
 14    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14    63 /*							       */
 14    64 /* Each of the named sections below defines a type of data.  Typing comes    */
 14    65 /* from data associated with the ute entry itself, with the person, with     */
 14    66 /* login argument data, from the main user of the data (eg, dialup_,	       */
 14    67 /* load_ctl_, login server).  Each section begins on a double-word boundary  */
 14    68 /* and is an even number of words long.  The total structure is 300 decimal  */
 14    69 /* words long.						       */
 14    70 /*							       */
 14    71 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14    72 
 14    73 
 14    74 dcl  UTE_version_4 fixed bin internal static options (constant) init (4);
 14    75 
 14    76 dcl  utep pointer automatic init (null);
 14    77 
 14    78 dcl  1 ute based (utep) aligned,			/* individual entry in one of the user control tables */
 14    79 
 14    80 /* Variables which give state of this entry */
 14    81        2 active fixed bin,				/* state of entry. 0=>free. see dialup_values.incl.pl1 */
 14    82        2 process_type fixed bin,			/* 1=interactive, 2=absentee, 3=daemon */
 14    83        2 ute_index fixed bin,				/* index of ute in (anstbl autbl dutbl).entry array */
 14    84        2 next_free fixed bin,				/* points to previous free entry */
 14    85 
 14    86 /* Information user gave about person_id associated with this entry. */
 14    87        2 person char (24) unal,			/* user's name */
 14    88        2 project char (12) unal,			/* project of absentee user */
 14    89        2 tag char (1) unal,				/* instance tag - someday will be generated */
 14    90        2 tag_pad bit (27) unal,
 14    91        2 anonymous fixed bin,				/* 1 if anonymous, otherwise 0 */
 14    92        2 login_flags,				/* flags for login data */
 14    93          3 cpw bit (1) unal,				/* flag for wish to change password */
 14    94          3 generate_pw bit (1) unal,			/* flag meaning -generate_pw (-gpw) was used. */
 14    95          3 special_pw unal,				/* dial or slave */
 14    96 	 4 dial_pw bit (1) unal,			/* true if dial -user */
 14    97 	 4 slave_pw bit (1) unal,			/* true if slave -user */
 14    98          3 cdp bit (1) unal,				/* flag for wish to change default project */
 14    99          3 cda bit (1) unal,				/* flag to change default authorization */
 14   100          3 auth_given bit (1) unal,			/* flag to mean -authorization was used. */
 14   101          3 noprint bit (1) unal,			/* used at logout. inhibits printing. */
 14   102          3 operator bit (1) unaligned,			/* user specified -operator on login command line */
 14   103          3 pw_pad bit (25) unal,			/* spare parts */
 14   104          3 mask_ctl bit (2) unal,			/* bits controlling pw mask. See constants, below */
 14   105 						/* Must remain last in pw_flags so it does not */
 14   106 						/* appear in PW_FLAG_VALUES array below. */
 14   107        2 generated_pw char (8) unal,			/* user must type this as new password */
 14   108        2 old_password char (8) unal,			/* must match user's previous password (value scrambled) */
 14   109        2 process_authorization bit (72),		/* access_authorization of this process */
 14   110 
 14   111 /* Information user gave about process associated with this entry. */
 14   112        2 outer_module char (32) unal,			/* Name of console dim */
 14   113        2 home_dir char (64) unal,			/* initial home directory */
 14   114        2 init_proc char (64) unal,			/* name of login responder */
 14   115        2 ip_len fixed bin (17) unal,			/* length of initproc string */
 14   116        2 ss_len fixed bin (17) unal,			/* length of subsystem string */
 14   117        2 ur_at like user_attributes aligned,		/* bits on means attributes given by user */
 14   118        2 at like user_attributes aligned,		/* bits on means attribute is on */
 14   119        2 initial_ring fixed bin,			/* ring process will be started in */
 14   120        2 arg_count fixed bin,				/* number of arguments to absentee control segment */
 14   121        2 ln_args fixed bin,				/* length of string containing arguments */
 14   122        2 arg_lengths_ptr ptr,				/* pointer to array of argument lengths */
 14   123        2 args_ptr ptr,				/* pointer to arguments to absentee control segment */
 14   124 
 14   125 /* Most of the following information is relevant only to absentee processes */
 14   126        2 input_seg char (168) unal,			/* pathname of absentee control segment */
 14   127        2 output_seg char (168) unal,			/* pathname of absentee output file */
 14   128        2 request_id fixed bin (71),			/* time request was entered - used as uid of request */
 14   129        2 reservation_id fixed bin (71),			/* nonzero if job has a resource reservation */
 14   130        2 message_id bit (72),				/* message segment id assoc with absentee request */
 14   131        2 deferred_time fixed bin (71),			/* time at which absentee process should be created */
 14   132        2 max_cpu_time fixed bin (35),			/* maximum number of seconds this process can run */
 14   133        2 queue fixed bin,				/* -1=daemon;0=interactive or foreground;>0=queue no.
 14   134*						   (but see uflags.adjust_abs_q_no). */
 14   135        2 real_queue fixed bin,			/* real queue number; ute.queue gets fudged sometimes */
 14   136        2 abs_attributes aligned like user_abs_attributes,	/* include abs_attributes.incl.pl1 */
 14   137        2 abs_flags,
 14   138          3 abs_run bit (1) unal,			/* on if job was started by abs run command */
 14   139          3 notify bit (1) unal,			/* on if user wants notification at login and logout */
 14   140          3 abs_flags_pad bit (34) unal,
 14   141        2 abs_group char (8) unal,			/* original group before load_ctl_ moves it to absentee group */
 14   142        2 sender char (32) unal,			/* name of RJE station that job is from */
 14   143        2 proxy_person char (28) unal,			/* name of user who actually entered the request, if proxy */
 14   144        2 proxy_project char (9) unal,
 14   145        2 proxy_project_pad char (3) unal,
 14   146        2 abs_pad fixed bin,
 14   147 
 14   148 /* Information about process actually created */
 14   149        2 proc_id bit (36),				/* process id of absentee process */
 14   150        2 session_uid fixed bin (35),			/* Unique authentication session id */
 14   151        2 process_authorization_range (2) bit (72) aligned,
 14   152        2 audit bit (36),				/* audit flags for user */
 14   153        2 lot_size fixed bin,				/* Size of linkage offset table */
 14   154        2 kst_size fixed bin,				/* Size of process known segment table */
 14   155        2 cls_size fixed bin,				/* Size of process combined linkage */
 14   156        2 sus_channel fixed bin (71),			/* event channel on which suspended process is blocked */
 14   157        2 lowest_ring fixed bin (17) unal,		/* lowest ring permitted */
 14   158        2 highest_ring fixed bin (17) unal,		/* highest ring permitted */
 14   159        2 pdir_lvix fixed bin (17) unal,			/* index in disk table of lv where pdir is */
 14   160        2 pdir_quota fixed bin (17) unal,		/* process directory quota */
 14   161        2 pdir_dir_quota fixed bin (17) unal,		/* process directory quota for dirs */
 14   162        2 pdir_pad fixed bin(17) unal,
 14   163        2 process_pad fixed bin,
 14   164 
 14   165 /* Information about primary terminal associated with this entry */
 14   166        2 tty_name char (32) unal,			/* absentee=>"abs1", etc.  daemon=>"bk", etc. */
 14   167        2 terminal_type char (32) unaligned,		/* terminal type */
 14   168        2 line_type fixed bin,				/* line type */
 14   169        2 tty_id_code char (4) unal,			/* "none" for absentee */
 14   170        2 network_connection_type fixed bin,		/* see net_event_message.incl.pl1 */
 14   171        2 channel ptr unal,				/* points to CDT entry for user, if any */
 14   172 
 14   173 /* Variables useful for dialed terminals */
 14   174        2 ndialed_consoles fixed bin,			/* if master, number of slaves */
 14   175        2 dial_qualifier char (22) unal,			/* first argument to dial command */
 14   176        2 dial_server_ring fixed bin (3) unsigned unaligned, /* dial server intends to attach dialing in channels at this ring. */
 14   177        2 dial_server_flags,
 14   178          3 registered_dial_server bit (1) unal,		/* process is a registered dial server */
 14   179          3 privileged_dial_server bit (1) unal,		/* "1"b -> serves range of AIM classes */
 14   180          3 dial_server_flags_pad bit (13) unal,		/* fill out the word */
 14   181        2 dial_ev_chn fixed bin (71),			/* if master, control event channel */
 14   182 
 14   183 /* Information about usage/accounting.  Device usage meters are in a
 14   184*   separate segment, "devtab" */
 14   185        2 pdtep ptr,					/* ptr to user's pdt entry, where usage meters live */
 14   186        2 cpu_this_process fixed bin (71),		/* cpu used so far this process */
 14   187        2 cpu_usage fixed bin (71),			/* total cpu time used in this session */
 14   188        2 mem_usage fixed bin (71),			/* memory usage for previous processes in session */
 14   189        2 mem_this_process fixed bin (71),		/* memory usage at last update */
 14   190        2 last_update_time fixed bin (71),		/* time of last account update */
 14   191        2 session_cost float bin,			/* dollar cost of session, for printing in logout messages */
 14   192        2 ndevices fixed bin,				/* Count of attached devices */
 14   193        2 device_head fixed bin,			/* Table index of head of device chain */
 14   194        2 device_tail fixed bin,			/* Table index of tail of device chain */
 14   195        2 rs_number fixed bin (6) unsigned unal,		/* rate structure number */
 14   196        2 rs_number_pad bit(30) unal,
 14   197        2 usage_pad fixed bin,
 14   198 
 14   199 /* Information for dialup_ (control variables). */
 14   200        2 event fixed bin (71),			/* event associated with channel or user manager */
 14   201        2 uprojp ptr,				/* ptr to user project sat entry */
 14   202        2 login_time fixed bin (71),			/* time when absentee user approved by lg_ctl_ */
 14   203        2 cant_bump_until fixed bin (71),		/* bump-protection clock */
 14   204        2 recent_fatal_error_time fixed bin (71),		/* time of first error in the suspected loop */
 14   205        2 recent_fatal_error_count fixed bin,		/* counter to detect fatal process error loops */
 14   206        2 failure_reason fixed bin,			/* why login refused 1=lg_ctl, 2=act_ctl, 3=load_ctl */
 14   207        2 count fixed bin,				/* counter for logins and dialups */
 14   208        2 n_processes fixed bin,			/* number of processes created in this session */
 14   209        2 lock_value fixed bin,			/* number of locks set for this entry */
 14   210        2 login_result fixed bin,			/* 0=logged in;1=hopeless,hang him up;2=allow another attempt */
 14   211        2 login_code char (8) unal,			/* login command from LOGIN line */
 14   212        2 preempted fixed bin,				/* if ^= 0 user preempted (never for abs) */
 14   213        2 destroy_flag fixed bin,			/* >8 when awaiting destroy */
 14   214        2 logout_type char (4) unal,			/* type of logout */
 14   215        2 logout_index fixed bin,			/* to save logout handler index while waiting for termsgnl */
 14   216        2 disconnection_rel_minutes fixed bin (17) unal,	/* disconnected this many minutes after login_time */
 14   217        2 next_disconnected_ate_index fixed bin (17) unal,	/* thread of list of user's disconnected processes */
 14   218        2 work_class fixed bin,			/* work class used by priority scheduler */
 14   219        2 group char (8) unal,				/* party group identifier */
 14   220        2 whotabx fixed bin,				/* index of user's entry in whotab */
 14   221 
 14   222        2 uflags,					/* Miscellaneous flags */
 14   223          3 dont_call_init_admin bit (1) unal,		/* Call overseer directly */
 14   224          3 ip_given bit (1) unal,			/* user gave an initproc arg on login line */
 14   225          3 ss_given bit (1) unal,			/* initial_procedure contains a subsystem name */
 14   226          3 lvs_attached bit (1) unal,			/* set and used by the lv_request_ procedure */
 14   227          3 send_initial_string bit (1) unal,		/* initial string should be sent after login line read */
 14   228          3 adjust_abs_q_no bit (1) unal,		/* this is an absentee job; user_profile.queue is NOT true Q # */
 14   229          3 foreground_secondary_ok bit (1) unal,		/* ok to login foreground absentee job as secondary */
 14   230          3 foreground_job bit (1) unal,			/* job was originally from foreground queue */
 14   231          3 sus_sent bit (1) unal,			/* sus_ ips signal has been sent to process */
 14   232          3 suspended bit (1) unal,			/* process has responded to sus_ signal */
 14   233          3 ignore_cpulimit bit (1) unal,		/* process is released, but timer can't be turned off */
 14   234          3 deferral_logged bit (1) unal,		/* abs job deferral has already been logged once */
 14   235          3 save_if_disconnected bit (1) unal,		/* user wants process preserved across hangups */
 14   236          3 disconnected bit (1) unal,			/* process is disconnected from terminal */
 14   237          3 disconnected_list bit (1) unal,		/* this ate is on a list of disconnected processes */
 14   238          3 proc_create_ok bit (1) unal,			/* lg_ctl_ has set the process creation variables */
 14   239          3 activity_can_unbump bit (1) unal,		/* only bump pending is for inactivity */
 14   240          3 fpe_causes_logout bit (1) unal,		/* "1"b means don't try to new_proc after fatal process error */
 14   241          3 user_specified_immediate bit (1) unal,		/* "1"b -> don't wait around for process destruction. */
 14   242          3 uflags_pad bit (17) unal,
 14   243 
 14   244 /* Information used by load_ctl_ for the process */
 14   245        2 user_weight fixed bin,			/* usually 10 - used in load control */
 14   246        2 standby_line fixed bin,			/* 0=user has primary line, 1=standby user */
 14   247        2 bump_grace fixed bin (71),			/* bump grace in microseconds */
 14   248 
 14   249 
 14   250 /* Information for login server */
 14   251        2 login_server_info,
 14   252          3 our_handle bit (72) aligned,			/* how LS refers to us. */
 14   253          3 his_handle bit (72) aligned,			/* how we talk to LS */
 14   254          3 termination_event_channel fixed bin (71),	/* for process termination notifications to the LS */
 14   255          3 response_event_channel fixed bin (71),		/* for other communications with the LS */
 14   256          3 process_id bit (36) aligned,			/* process_id of login server */
 14   257        2 ls_pad (5) fixed bin;			/* pad to 300 decimal words */
 14   258 
 14   259 /* values for ute.process_type */
 14   260 
 14   261 dcl  (PT_INTERACTIVE initial (1),
 14   262      PT_ABSENTEE initial (2),
 14   263      PT_DAEMON initial (3)) fixed bin internal static options (constant);
 14   264 
 14   265 dcl  PROCESS_TYPE_NAMES (0:3) char(12) varying int static options(constant) init(
 14   266 	"INVALID-TYPE",
 14   267 	"interactive",
 14   268 	"absentee",
 14   269 	"daemon");
 14   270 
 14   271 dcl  TABLE_NAMES (0:3) char(20) int static options(constant) init(
 14   272 	"UNKNOWN-TABLE",
 14   273 	"answer_table",
 14   274 	"absentee_user_table",
 14   275 	"daemon_user_table");
 14   276 
 14   277 
 14   278 /* values for ute.pw_flags.mask_ctl  */
 14   279 
 14   280 dcl  (DO_MASK init ("00"b),
 14   281      DONT_MASK init ("01"b),
 14   282      DERIVE_MASK init ("10"b)) bit (2) internal static options (constant);
 14   283 
 14   284 dcl  MASK_CTL_NAMES (0:3) char(12) varying int static options(constant) init(
 14   285 	"do_mask", "dont_mask", "derive_mask", "");
 14   286 
 14   287 
 14   288 /* names for ute.pw_flags */
 14   289 
 14   290 dcl  PW_FLAG_NAMES (9) char (12) varying int static options(constant) init(
 14   291 	"cpw",
 14   292 	"generate_pw",
 14   293 	"dial_pw",
 14   294 	"slave_pw",
 14   295 	"cdp",
 14   296 	"cda",
 14   297 	"auth_given",
 14   298 	"noprint",
 14   299 	"operator");
 14   300 
 14   301 /* names for ute.uflags */
 14   302 
 14   303 dcl  UFLAG_NAMES (19) char (24) varying int static options (constant) init (
 14   304 	"dont_call_init_admin",
 14   305 	"ip_given",
 14   306 	"ss_given",
 14   307 	"lvs_attached",
 14   308 	"send_initial_string",
 14   309 	"adjust_abs_q_no",
 14   310 	"foreground_secondary_ok",
 14   311 	"foreground_job",
 14   312 	"sus_sent",
 14   313 	"suspended",
 14   314 	"ignore_cpulimit",
 14   315 	"deferral_logged",
 14   316 	"save_if_disconnected",
 14   317 	"disconnected",
 14   318 	"disconnected_list",
 14   319 	"proc_create_ok",
 14   320 	"activity_can_unbump",
 14   321 	"fpe_causes_logout",
 14   322 	"user_specified_immediate");
 14   323 
 14   324 /* names for ute.abs_flags */
 14   325 
 14   326 dcl  ABS_FLAG_NAMES (2) char (8) varying int static options (constant) init (
 14   327 	"abs_run",
 14   328 	"notify");
 14   329 
 14   330 /* names of ute.dial_server_flags */
 14   331 
 14   332 dcl  DIAL_SERVER_FLAG_NAMES (2) char (12) varying int static options (constant) init (
 14   333 	"registered",
 14   334 	"privileged");
 14   335 
 14   336 /* values of ute.login_result */
 14   337 
 14   338 dcl  LOGIN_RESULT_VALUES (0:2) char(24) varying int static options(constant) init(
 14   339 	"logged in",
 14   340 	"login failed, hangup",
 14   341 	"login failed, try again");
 14   342 
 14   343 /*  END INCLUDE FILE ... user_table_entry.incl.pl1 */
      928 
      929  /* BEGIN INCLUDE FILE ... user_table_header.incl.pl1 */
 15     2 
 15     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 15     4 /*							       */
 15     5 /* This include file declares the header shared by the answer_table,	       */
 15     6 /* absentee_user_table and daemon_user_table include files.		       */
 15     7 /*							       */
 15     8 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 15     9 
 15    10 /****^  HISTORY COMMENTS:
 15    11*  1) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
 15    12*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 15    13*     Initial coding.
 15    14*                                                   END HISTORY COMMENTS */
 15    15 
 15    16 dcl  1 ut_header			aligned based,	/* header shared by all user control tables. */
 15    17        2 header_version fixed bin,			/* version of the header (3) */
 15    18        2 entry_version fixed bin,			/* version of user table entries */
 15    19        2 user_table_type fixed bin,			/* 1 interactive, 2 absentee, 3 daemon */
 15    20        2 header_length fixed bin,			/* length of the header */
 15    21        2 max_size fixed bin,				/* max number of entries in this table */
 15    22        2 current_size fixed bin,			/* actual size of table (in entries) */
 15    23        2 number_free fixed bin,			/* number of free entries in the table. */
 15    24        2 first_free fixed bin,			/* index of first entry in the free list. */
 15    25        2 as_procid bit (36),				/* process ID of user table manager process */
 15    26        2 ut_header_pad fixed bin;
 15    27 
 15    28 /* END INCLUDE FILE ... user_table_header.incl.pl1 */
      929 
      930 
      931      end pdir_volume_manager_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/12/91  1645.0  pdir_volume_manager_.pl1          >spec>install>1009>pdir_volume_manager_.pl1
917          1    08/06/87  0913.4  absentee_user_table.incl.pl1      >ldd>incl>absentee_user_table.incl.pl1
918          2    08/06/87  0913.0  answer_table.incl.pl1             >ldd>incl>answer_table.incl.pl1
919          3    08/06/87  0913.4  as_data_.incl.pl1                 >ldd>incl>as_data_.incl.pl1
920          4    08/06/87  0913.4  as_data_definitions_.incl.pl1     >ldd>incl>as_data_definitions_.incl.pl1
921          5    08/06/87  0912.9  daemon_user_table.incl.pl1        >ldd>incl>daemon_user_table.incl.pl1
922          6    08/06/87  0913.4  dialup_values.incl.pl1            >ldd>incl>dialup_values.incl.pl1
923          7    07/24/86  2051.9  disk_table.incl.pl1               >ldd>incl>disk_table.incl.pl1
924          8    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>incl>fs_dev_types.incl.pl1
8-142        9    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>incl>fs_dev_types_sector.incl.pl1
925         10    08/06/87  0913.5  sc_stat_.incl.pl1                 >ldd>incl>sc_stat_.incl.pl1
926         11    06/10/82  1045.5  star_structures.incl.pl1          >ldd>incl>star_structures.incl.pl1
927         12    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>incl>user_attributes.incl.pl1
12-112      13    07/14/88  2015.0  user_abs_attributes.incl.pl1      >ldd>incl>user_abs_attributes.incl.pl1
928         14    07/14/88  2015.0  user_table_entry.incl.pl1         >ldd>incl>user_table_entry.incl.pl1
929         15    08/06/87  0913.6  user_table_header.incl.pl1        >ldd>incl>user_table_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HALF_MAXQ                              constant        fixed bin(17,0)          initial dcl 179 ref 854 857 862 865
MAXQ                                   constant        fixed bin(17,0)          initial dcl 180 ref 357 357 854 857 862 865
NOW_HAS_PROCESS                        constant        fixed bin(17,0)          initial dcl 6-76 ref 642 661 680
SAFETY_MARGIN                          constant        fixed bin(17,0)          initial dcl 181 ref 300 300 357 357 854 857 862 865
UTE_SIZE                               constant        fixed bin(17,0)          initial dcl 2-120 ref 641 641
a_atep                                 parameter       pointer                  dcl 174 ref 290 294 349 353
a_code                                 parameter       fixed bin(35,0)          dcl 175 set ref 290 295* 332* 338*
a_lvname                               parameter       char                     packed unaligned dcl 610 ref 608 614
absolute_pathname_              000036 constant        entry                    external dcl 209 ref 730
active                                 based           fixed bin(17,0)          level 2 dcl 14-78 ref 642 661 680
addr                                                   builtin function         dcl 263 ref 570 615 641 660 679 761 771
already_init                    000010 internal static bit(1)                   initial dcl 186 set ref 274* 286* 801 807 819 907
ansp                            000304 automatic       pointer                  initial dcl 2-53 set ref 2-53* 639* 640 641
anstbl                                 based           structure                level 1 dcl 2-55
arg                                    based           char                     packed unaligned dcl 259 set ref 416* 417* 422* 426*
                                                                                  447* 450* 455* 459* 484* 484* 486* 511* 513* 514*
                                                                                  545 546 546 548* 553* 553* 556* 560*
argl                            000255 automatic       fixed bin(17,0)          dcl 246 set ref 410* 416 416 417 417 422 422 426 426
                                                                                  444* 447 447 450 450 455 455 459 459 482* 484 484
                                                                                  484 484 486 486 509* 511 511 513 513 514 514 543*
                                                                                  545 546 546 548 548 553 553 553 553 556 556 560
                                                                                  560
argno                           000256 automatic       fixed bin(17,0)          dcl 246 set ref 481* 482* 508* 509* 542* 543*
argp                            000260 automatic       pointer                  dcl 247 set ref 410* 416 417 422 426 444* 447 450
                                                                                  455 459 482* 484 484 486 509* 511 513 514 543* 545
                                                                                  546 546 548 553 553 556 560
array                    10            based           structure                array level 2 dcl 7-23 set ref 761
as_data_$ansp                   000106 external static pointer                  dcl 3-26 ref 639
as_data_$autp                   000110 external static pointer                  dcl 3-31 ref 658
as_data_$dutp                   000112 external static pointer                  dcl 3-37 ref 677
autbl                                  based           structure                level 1 dcl 1-28
autp                            000302 automatic       pointer                  initial dcl 1-26 set ref 1-26* 658* 659 660
branch_ptr                             parameter       pointer                  dcl 713 ref 700 721
code                                   parameter       fixed bin(35,0)          dcl 751 in procedure "select_pdir_vol" set ref 745
                                                                                  758* 785*
code                            000112 automatic       fixed bin(35,0)          dcl 235 in procedure "pdir_volume_manager_" set ref
                                                                                  296* 330* 331 332 336* 337 338 410* 411 412* 426*
                                                                                  427 444* 445 459* 460 482* 483 500* 501 501* 509*
                                                                                  510 513* 514 514* 543* 544 560* 561 561* 572* 573
                                                                                  646* 647 648* 649 650* 665* 666 667* 668 669* 684*
                                                                                  685 686* 687 688* 730* 732 733* 737* 738 738* 794
                                                                                  795* 821 822* 841* 842* 869* 870 871* 874* 875
                                                                                  876*
containing_dir                         parameter       char(32)                 dcl 709 ref 700 730 733
cu_$arg_count                   000040 constant        entry                    external dcl 210 ref 404 441 472 531
cu_$arg_ptr                     000042 constant        entry                    external dcl 211 ref 410 444 482 509 543
cur_lvix                        000011 internal static fixed bin(17,0)          dcl 187 set ref 278* 335 341* 393*
cur_pvix                        000012 internal static fixed bin(17,0)          dcl 187 set ref 277* 393* 760 760 774*
current_size              5            based           fixed bin(17,0)          level 3 in structure "dutbl" dcl 5-29 in procedure
                                                                                  "pdir_volume_manager_" ref 678
current_size              5            based           fixed bin(17,0)          level 3 in structure "anstbl" dcl 2-55 in procedure
                                                                                  "pdir_volume_manager_" ref 640
current_size              5            based           fixed bin(17,0)          level 3 in structure "autbl" dcl 1-28 in procedure
                                                                                  "pdir_volume_manager_" ref 659
default_pddir_q                 000017 internal static fixed bin(17,0)          dcl 191 set ref 319 320 376 377 826*
default_pdq                     000020 internal static fixed bin(17,0)          dcl 192 set ref 310 311 367 368 825*
device_type               2            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 7-35 ref 762 762
                                                                                  762
dir                                    parameter       char                     packed unaligned dcl 839 in procedure "gq" set ref
                                                                                  837 841* 842*
dir                                    parameter       char(32)                 dcl 710 in procedure "move_pdir_segs" ref 700 730
                                                                                  733
dir_discrepancy                 000262 automatic       fixed bin(17,0)          dcl 248 set ref 390 390* 800* 807 808* 810
dir_quota                       000270 automatic       fixed bin(17,0)          dcl 254 set ref 800 808* 815 826 828 842* 857* 865*
                                                                                  874* 876* 882* 883
discrepancy                     000263 automatic       fixed bin(17,0)          dcl 249 set ref 390 390* 799* 801 802* 804
disk_table_$get_dtp             000044 constant        entry                    external dcl 212 ref 276
disk_table_$set_lv_pdir_bit     000046 constant        entry                    external dcl 213 ref 426 459 500 513
disk_table_$set_vacate_pdirs_bit
                                000050 constant        entry                    external dcl 214 ref 560 572
dt                                     based           structure                level 1 dcl 7-23
dte                                    based           structure                level 1 dcl 7-35
dtep                            000312 automatic       pointer                  dcl 7-17 set ref 761* 762 762 762 762 762 766 768
                                                                                  768 768 768 768 771 775
dtp                             000310 automatic       pointer                  dcl 7-17 set ref 280* 498 499 499 500 501 568 569
                                                                                  569 570 572 573 598 599 599 599 599 613 614 614
                                                                                  615 760 761 768 771 912*
dutbl                                  based           structure                level 1 dcl 5-29
dutp                            000306 automatic       pointer                  initial dcl 5-27 set ref 5-27* 677* 678 679
ename                           000101 automatic       char(32)                 packed unaligned dcl 233 set ref 270* 271* 292* 351*
                                                                                  387* 400* 406* 412* 417* 422* 437* 450* 455* 469*
                                                                                  474* 484* 486* 492* 501* 514* 528* 533* 553* 556*
                                                                                  561* 573* 582* 588* 784* 795* 802* 808* 822* 853
                                                                                  871* 876* 880* 882* 894* 908*
entry                   200            based           structure                array level 2 in structure "autbl" dcl 1-28
                                                                                  in procedure "pdir_volume_manager_" set ref 660
entry                   200            based           structure                array level 2 in structure "anstbl" dcl 2-55
                                                                                  in procedure "pdir_volume_manager_" set ref 641
entry                                  parameter       char(32)                 dcl 711 in procedure "move_pdir_segs" ref 700 737
                                                                                  738
entry                   200            based           structure                array level 2 in structure "dutbl" dcl 5-29
                                                                                  in procedure "pdir_volume_manager_" set ref 679
error_table_$action_not_performed
                                000030 external static fixed bin(35,0)          dcl 203 ref 785
error_table_$badopt             000034 external static fixed bin(35,0)          dcl 205 set ref 548*
error_table_$out_of_sequence    000032 external static fixed bin(35,0)          dcl 204 set ref 271*
hcs_$dir_quota_read             000052 constant        entry                    external dcl 215 ref 842
hcs_$quota_read                 000054 constant        entry                    external dcl 217 ref 841
header                                 based           structure                level 2 in structure "anstbl" dcl 2-55 in procedure
                                                                                  "pdir_volume_manager_"
header                                 based           structure                level 2 in structure "autbl" dcl 1-28 in procedure
                                                                                  "pdir_volume_manager_"
header                                 based           structure                level 2 in structure "dutbl" dcl 5-29 in procedure
                                                                                  "pdir_volume_manager_"
hphcs_$dir_quota_set            000056 constant        entry                    external dcl 219 ref 874
hphcs_$pv_move_file             000062 constant        entry                    external dcl 221 ref 737
hphcs_$quota_set                000060 constant        entry                    external dcl 220 ref 869
hphcs_$set_pdir_sons_lvid       000066 constant        entry                    external dcl 223 ref 648 667 686
hphcs_$set_sons_lvid            000064 constant        entry                    external dcl 222 ref 336
hv_mounted                1(01)        based           bit(1)                   level 2 in structure "lve" packed packed unaligned
                                                                                  dcl 7-58 in procedure "pdir_volume_manager_" ref
                                                                                  421 486 512 772
hv_mounted                             based           bit(1)                   array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 7-23 in procedure
                                                                                  "pdir_volume_manager_" set ref 599
i                               000113 automatic       fixed bin(17,0)          dcl 236 in procedure "pdir_volume_manager_" set ref
                                                                                  498* 499 499 500 501* 568* 569 569 570 571* 572
                                                                                  573*
i                               000356 automatic       fixed bin(17,0)          dcl 611 in procedure "find_lve" set ref 613* 614 614
                                                                                  615*
i                               000345 automatic       fixed bin(17,0)          dcl 595 in procedure "count_pdir_volumes" set ref
                                                                                  598* 599 599 599 599*
idx                             000116 automatic       fixed bin(17,0)          dcl 239 set ref 640* 641* 659* 660* 678* 679*
index                                                  builtin function         dcl 263 ref 545
just_got_quota                  000266 automatic       bit(1)                   initial dcl 252 set ref 252* 817* 851
level                                  parameter       fixed bin(17,0)          dcl 712 ref 700
long_sw                         000267 automatic       bit(1)                   packed unaligned dcl 253 set ref 538*
loud                            000111 automatic       fixed bin(17,0)          dcl 234 set ref 540* 546* 644* 663* 682*
lv_array                               based           structure                array level 2 dcl 7-23 set ref 570 615 771
lv_idx                                 parameter       fixed bin(17,0)          dcl 636 ref 624 642 661 680
lve                                    based           structure                level 1 dcl 7-58
lvep                            000314 automatic       pointer                  dcl 7-17 set ref 421 421 449 486 486 512 512 555
                                                                                  570* 615* 644 663 682 771* 772 772 772 772 772 772
                                                                                  776 777
lvid                                   based           bit(36)                  level 2 dcl 7-58 ref 777
lvname                                 based           char(32)                 array level 3 in structure "dt" dcl 7-23
                                                                                  in procedure "pdir_volume_manager_" set ref 500
                                                                                  501* 572 573* 614
lvname                    2            based           char(32)                 level 2 in structure "lve" dcl 7-58 in procedure
                                                                                  "pdir_volume_manager_" set ref 644* 663* 682* 776
lvol_id                                parameter       bit(36)                  packed unaligned dcl 750 set ref 745 777*
lvol_idx                               parameter       fixed bin(17,0)          dcl 749 set ref 745 775*
lvol_name                              parameter       char(32)                 packed unaligned dcl 748 set ref 745 776*
lvx                       2(23)        based           fixed bin(11,0)          level 2 packed packed unaligned dcl 7-35 ref 768 768
                                                                                  771 775
max                                                    builtin function         dcl 263 ref 854 857 862 865
max_access_class         14            based           bit(72)                  level 2 dcl 7-58 set ref 772*
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 7-23 ref 499 499 500 501 569 569 570 572
                                                                                  573 599 599 599 599 614 614 615 771
maxdevt                                constant        fixed bin(4,0)           initial dcl 8-43 ref 762
min                                                    builtin function         dcl 263 ref 854 857 862 865
min_access_class         12            based           bit(72)                  level 2 dcl 7-58 set ref 772*
more_than_one_pdir_vol          000100 automatic       bit(1)                   packed unaligned dcl 199 set ref 537* 542 557*
n_entries                              based           fixed bin(17,0)          level 2 dcl 7-23 ref 760
n_lv_entries              5            based           fixed bin(17,0)          level 2 dcl 7-23 ref 498 568 598 613 768
n_new_pdir_volumes              000114 automatic       fixed bin(17,0)          dcl 237 set ref 480* 488* 488 491 492 492
n_pdir_volumes                  000013 internal static fixed bin(17,0)          dcl 187 set ref 281* 325 393* 429* 462* 520*
names_ptr                              parameter       pointer                  dcl 714 ref 700
nargs                           000257 automatic       fixed bin(17,0)          dcl 246 set ref 404* 405 441* 442 472* 473 481 492
                                                                                  492 492* 508 531* 532 542
npd                             000021 internal static fixed bin(17,0)          dcl 193 set ref 283* 323* 323 380* 380 390*
null                                                   builtin function         dcl 263 ref 1-26 2-53 5-27 14-76
nvol                            000344 automatic       fixed bin(17,0)          dcl 594 set ref 597* 599* 599 602
on_or_off                              parameter       bit(1)                   packed unaligned dcl 892 set ref 890 894* 896
pass_number                     000264 automatic       fixed bin(17,0)          dcl 250 set ref 759*
pdddir_q                        000022 internal static fixed bin(17,0)          dcl 194 set ref 300 314* 314 319* 319 357 371* 371
                                                                                  376* 376 390* 800 808* 815* 882* 883*
pddir_q                         000024 internal static fixed bin(17,0)          dcl 196 set ref 315* 315 320* 320 372* 372 377* 377
                                                                                  390* 810* 810 828*
pddq                            000023 internal static fixed bin(17,0)          dcl 195 set ref 300 305* 305 310* 310 357 362* 362
                                                                                  367* 367 390* 799 802* 814* 880* 881*
pddq_known                      000026 internal static bit(1)                   initial dcl 198 set ref 298 309* 318* 355 366* 375*
                                                                                  388 802* 804 808* 810 816*
pddq_was_known                  000265 automatic       bit(1)                   dcl 251 set ref 388* 390* 390*
pdir                            000117 automatic       char(168)                dcl 240 set ref 643* 644* 650* 653 662* 663* 669*
                                                                                  672 681* 682* 688* 691
pdir_dir_quota          314            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-78 ref 300
                                                                                  313 314 315 357 370 371 372 857 865
pdir_lvid                       000253 automatic       bit(36)                  packed unaligned dcl 243 set ref 330* 336* 646* 648*
                                                                                  665* 667* 684* 686*
pdir_lvix               313            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-78 set ref
                                                                                  326* 344* 642 654* 661 673* 680 692*
pdir_quota              313(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-78 ref 300
                                                                                  304 305 306 357 361 362 363 854 862
pdir_to_move                    000171 automatic       char(168)                packed unaligned dcl 241 set ref 730* 737* 738
pdir_vol_name                   000243 automatic       char(32)                 packed unaligned dcl 242 set ref 330* 646* 665* 684*
pdirs_ok                  1(07)        based           bit(1)                   level 2 in structure "lve" packed packed unaligned
                                                                                  dcl 7-58 in procedure "pdir_volume_manager_" ref
                                                                                  449 555 772
pdirs_ok                               based           bit(1)                   array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 7-23 in procedure
                                                                                  "pdir_volume_manager_" set ref 499 599
pdq                             000025 internal static fixed bin(17,0)          dcl 197 set ref 306* 306 311* 311 363* 363 368* 368
                                                                                  390* 804* 804 827*
person                    4            based           char(24)                 level 2 packed packed unaligned dcl 14-78 set ref
                                                                                  644* 663* 682* 784*
proc_id                 276            based           bit(36)                  level 2 dcl 14-78 ref 643 648 648 662 667 667 681
                                                                                  686 686
proc_lvix                       000254 automatic       fixed bin(17,0)          dcl 244 set ref 330* 335 341 344 646* 654 665* 673
                                                                                  684* 692
process_authorization
                         24            based           bit(72)                  level 2 dcl 14-78 set ref 772* 772*
project                  12            based           char(12)                 level 2 packed packed unaligned dcl 14-78 set ref
                                                                                  644* 663* 682* 784*
public                                 based           bit(1)                   array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 7-23 in procedure
                                                                                  "pdir_volume_manager_" set ref 599
public                    1(02)        based           bit(1)                   level 2 in structure "lve" packed packed unaligned
                                                                                  dcl 7-58 in procedure "pdir_volume_manager_" ref
                                                                                  421 486 512 772
pvix                            000115 automatic       fixed bin(17,0)          dcl 238 set ref 760* 761 774*
qswitch                         000300 automatic       fixed bin(1,0)           dcl 254 set ref 841* 842*
quota                           000271 automatic       fixed bin(17,0)          dcl 254 set ref 799 802* 814 825 827 841* 854* 862*
                                                                                  869* 871* 880* 881
qused                           000272 automatic       fixed bin(17,0)          dcl 254 set ref 841* 842*
read_allowed_                   000070 constant        entry                    external dcl 224 ref 772
rtrim                                                  builtin function         dcl 263 ref 730 730 733 733 738 738
sc_stat_$Go_typed               000114 external static bit(1)                   dcl 10-62 ref 271
sc_stat_$Multics_typed          000116 external static bit(1)                   dcl 10-62 ref 271
seek_command                    000316 automatic       bit(6)                   initial array packed unaligned dcl 8-84 set ref
                                                                                  8-84* 8-84* 8-84* 8-84* 8-84* 8-84* 8-84* 8-84*
                                                                                  8-84*
shared_spindle                  000000 constant        bit(1)                   initial array packed unaligned dcl 8-78 ref 762
shared_spindle_flip       2(18)        based           bit(1)                   level 2 packed packed unaligned dcl 7-35 set ref
                                                                                  762* 762 766* 768
shared_spindle_hack             000016 internal static bit(1)                   initial dcl 189 set ref 762 894* 896*
slvid                           000277 automatic       bit(36)                  packed unaligned dcl 254 set ref 841* 842*
star_SEGMENT                           constant        fixed bin(2,0)           initial unsigned dcl 11-120 ref 728
star_branch_count               000320 automatic       fixed bin(17,0)          dcl 11-13 set ref 725* 728
star_link_count                 000324 automatic       fixed bin(17,0)          dcl 11-17 set ref 726*
star_list_branch                       based           structure                array level 1 dcl 11-41
star_list_branch_ptr            000322 automatic       pointer                  dcl 11-16 set ref 721* 728
static_dtp                      000014 internal static pointer                  initial dcl 188 set ref 276* 280 912
storage_system            2(11)        based           bit(1)                   level 2 packed packed unaligned dcl 7-35 ref 768
sub_err_                        000072 constant        entry                    external dcl 225 ref 271
sweep_disk_$dir_list            000102 constant        entry                    external dcl 228 ref 653 672 691
sys_log_                        000074 constant        entry                    external dcl 226 ref 390 393 406 417 422 450 455 474
                                                                                  484 486 492 533 553 556 573 644 663 682 784 795
                                                                                  802 808 880 882 894 908
sys_log_$error_log              000076 constant        entry                    external dcl 226 ref 412 501 514 548 561 650 669 688
                                                                                  733 738 822 871 876
tpp                             000274 automatic       fixed bin(71,0)          dcl 254 set ref 841* 842*
type                                   based           fixed bin(2,0)           array level 2 packed packed unsigned unaligned
                                                                                  dcl 11-41 ref 728
unique_chars_                   000100 constant        entry                    external dcl 227 ref 643 648 648 662 667 667 681 686
                                                                                  686
uptime                          000276 automatic       fixed bin(35,0)          dcl 254 set ref 841* 842*
used                                   based           bit(1)                   array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 7-23 in procedure
                                                                                  "pdir_volume_manager_" set ref 499 569 599 614
used                      1            based           bit(1)                   level 2 in structure "lve" packed packed unaligned
                                                                                  dcl 7-58 in procedure "pdir_volume_manager_" ref
                                                                                  772
used                      2(09)        based           bit(1)                   level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 7-35 in procedure "pdir_volume_manager_" ref
                                                                                  768
user_abs_attributes                    based           structure                level 1 dcl 13-25
user_attributes                        based           structure                level 1 dcl 12-21
ut_header                              based           structure                level 1 dcl 15-16
ute                                    based           structure                level 1 dcl 14-78
utep                            000326 automatic       pointer                  initial dcl 14-76 set ref 294* 300 300 304 305 306
                                                                                  313 314 315 326 344 353* 357 357 361 362 363 370
                                                                                  371 372 14-76* 641* 642 642 643 644 644 648 648
                                                                                  654 660* 661 661 662 663 663 667 667 673 679* 680
                                                                                  680 681 682 682 686 686 692 772 772 784 784 854
                                                                                  857 862 865
vacate_pdirs                           based           bit(1)                   array level 3 packed packed unaligned dcl 7-23 set
                                                                                  ref 569
write_allowed_                  000104 constant        entry                    external dcl 229 ref 772
zzBB                            000001 constant        char(20)                 initial packed unaligned dcl 182 set ref 820* 822*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 13-38
ABS_FLAG_NAMES                         internal static varying char(8)          initial array dcl 14-326
ACTIVE_VALUES                          internal static char(18)                 initial array dcl 6-86
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 12-77
ANSTBL_version_4                       internal static fixed bin(17,0)          initial dcl 2-51
AT_NORMAL                              internal static char(8)                  initial packed unaligned dcl 2-116
AT_SHUTDOWN                            internal static char(8)                  initial packed unaligned dcl 2-116
AT_SPECIAL                             internal static char(8)                  initial packed unaligned dcl 2-116
AUTBL_CONTROL_NAMES                    internal static varying char(20)         initial array dcl 1-68
AUTBL_version_4                        internal static fixed bin(17,0)          initial dcl 1-24
DERIVE_MASK                            internal static bit(2)                   initial packed unaligned dcl 14-280
DIAL_SERVER_FLAG_NAMES                 internal static varying char(12)         initial array dcl 14-332
DONT_MASK                              internal static bit(2)                   initial packed unaligned dcl 14-280
DO_MASK                                internal static bit(2)                   initial packed unaligned dcl 14-280
DUTBL_version_4                        internal static fixed bin(17,0)          initial dcl 5-25
LOGIN_RESULT_VALUES                    internal static varying char(24)         initial array dcl 14-338
MASK_CTL_NAMES                         internal static varying char(12)         initial array dcl 14-284
MODEL                                  internal static fixed bin(17,0)          initial array dcl 8-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 8-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 8-60
NOW_DIALED                             internal static fixed bin(17,0)          initial dcl 6-76
NOW_DIALED_OUT                         internal static fixed bin(17,0)          initial dcl 6-76
NOW_DIALING                            internal static fixed bin(17,0)          initial dcl 6-76
NOW_FREE                               internal static fixed bin(17,0)          initial dcl 6-76
NOW_HUNG_UP                            internal static fixed bin(17,0)          initial dcl 6-76
NOW_LISTENING                          internal static fixed bin(17,0)          initial dcl 6-76
NOW_LOGGED_IN                          internal static fixed bin(17,0)          initial dcl 6-76
PREEMPT_BUMPED                         internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_BUMPED_NO_TERM                 internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_LOAD_CTL                       internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_TERMSGNL_RECEIVED              internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_TERM_SENT                      internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_UNBUMP                         internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_UNBUMP_IGNORE_ALARM            internal static fixed bin(17,0)          initial dcl 6-132
PREEMPT_VALUES                         internal static varying char(28)         initial array dcl 6-142
PROCESS_TYPE_NAMES                     internal static varying char(12)         initial array dcl 14-265
PT_ABSENTEE                            internal static fixed bin(17,0)          initial dcl 14-261
PT_ALARM                               internal static fixed bin(17,0)          initial dcl 6-106
PT_BUMP                                internal static fixed bin(17,0)          initial dcl 6-106
PT_DAEMON                              internal static fixed bin(17,0)          initial dcl 14-261
PT_DESTROY_REQUEST                     internal static fixed bin(17,0)          initial dcl 6-106
PT_DETACH                              internal static fixed bin(17,0)          initial dcl 6-106
PT_FPE                                 internal static fixed bin(17,0)          initial dcl 6-106
PT_HANGUP                              internal static fixed bin(17,0)          initial dcl 6-106
PT_INTERACTIVE                         internal static fixed bin(17,0)          initial dcl 14-261
PT_LOGOUT                              internal static fixed bin(17,0)          initial dcl 6-106
PT_NEW_PROC_AUTH                       internal static fixed bin(17,0)          initial dcl 6-106
PT_NEW_PROC_REQUEST                    internal static fixed bin(17,0)          initial dcl 6-106
PT_OPERATOR_TERMINATE                  internal static fixed bin(17,0)          initial dcl 6-106
PT_SHUTDOWN                            internal static fixed bin(17,0)          initial dcl 6-106
PT_UNBUMP                              internal static fixed bin(17,0)          initial dcl 6-106
PW_FLAG_NAMES                          internal static varying char(12)         initial array dcl 14-290
STATE_VALUES                           internal static char(15)                 initial array dcl 6-70
TABLE_NAMES                            internal static char(20)                 initial array packed unaligned dcl 14-271
TAG_ABSENTEE                           internal static char(1)                  initial packed unaligned dcl 6-93
TAG_DAEMON                             internal static char(1)                  initial packed unaligned dcl 6-93
TAG_INTERACTIVE                        internal static char(1)                  initial packed unaligned dcl 6-93
TAG_PROXY                              internal static char(1)                  initial packed unaligned dcl 6-93
TAG_UFT                                internal static char(1)                  initial packed unaligned dcl 6-93
TRA_VEC_VALUES                         internal static char(32)                 initial array dcl 6-54
TTY_DIALED                             internal static fixed bin(17,0)          initial dcl 6-64
TTY_HUNG                               internal static fixed bin(17,0)          initial dcl 6-64
TTY_KNOWN                              internal static fixed bin(17,0)          initial dcl 6-64
TTY_MASKED                             internal static fixed bin(17,0)          initial dcl 6-64
UFLAG_NAMES                            internal static varying char(24)         initial array dcl 14-303
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 12-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 12-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 12-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 12-50
UTE_version_4                          internal static fixed bin(17,0)          initial dcl 14-74
WAIT_ANSWERBACK                        internal static fixed bin(17,0)          initial dcl 6-25
WAIT_BEFORE_HANGUP                     internal static fixed bin(17,0)          initial dcl 6-25
WAIT_CONNECT_REQUEST                   internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DELETE_CHANNEL                    internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DESTROY_REQUEST                   internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DETACH                            internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DIALUP                            internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DIAL_OUT                          internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DIAL_RELEASE                      internal static fixed bin(17,0)          initial dcl 6-25
WAIT_DISCARD_WAKEUPS                   internal static fixed bin(17,0)          initial dcl 6-25
WAIT_FIN_PRIV_ATTACH                   internal static fixed bin(17,0)          initial dcl 6-25
WAIT_FIN_TANDD_ATTACH                  internal static fixed bin(17,0)          initial dcl 6-25
WAIT_GREETING_MSG                      internal static fixed bin(17,0)          initial dcl 6-25
WAIT_HANGUP                            internal static fixed bin(17,0)          initial dcl 6-25
WAIT_LOGIN_ARGS                        internal static fixed bin(17,0)          initial dcl 6-25
WAIT_LOGIN_LINE                        internal static fixed bin(17,0)          initial dcl 6-25
WAIT_LOGOUT                            internal static fixed bin(17,0)          initial dcl 6-25
WAIT_LOGOUT_HOLD                       internal static fixed bin(17,0)          initial dcl 6-25
WAIT_LOGOUT_SIG                        internal static fixed bin(17,0)          initial dcl 6-25
WAIT_NEW_PASSWORD                      internal static fixed bin(17,0)          initial dcl 6-25
WAIT_NEW_PROC                          internal static fixed bin(17,0)          initial dcl 6-25
WAIT_NEW_PROC_REQUEST                  internal static fixed bin(17,0)          initial dcl 6-25
WAIT_OLD_PASSWORD                      internal static fixed bin(17,0)          initial dcl 6-25
WAIT_PASSWORD                          internal static fixed bin(17,0)          initial dcl 6-25
WAIT_REMOVE                            internal static fixed bin(17,0)          initial dcl 6-25
WAIT_SLAVE_REQUEST                     internal static fixed bin(17,0)          initial dcl 6-25
WAIT_TANDD_HANGUP                      internal static fixed bin(17,0)          initial dcl 6-25
as_data_$BS                            external static char(1)                  dcl 3-21
as_data_$CR                            external static char(1)                  dcl 3-22
as_data_$abs_dim                       external static char(32)                 packed unaligned dcl 3-23
as_data_$acct_update_priority          external static fixed bin(17,0)          dcl 3-24
as_data_$acsdir                        external static char(168)                packed unaligned dcl 3-25
as_data_$as_procid                     external static bit(36)                  dcl 3-27
as_data_$as_ring                       external static fixed bin(3,0)           dcl 3-28
as_data_$as_tty                        automatic       char(6)                  packed unaligned dcl 3-29
as_data_$asmtp                         external static pointer                  dcl 3-30
as_data_$buzzardp                      external static pointer                  dcl 3-32
as_data_$cdtp                          external static pointer                  dcl 3-33
as_data_$debug_flag                    external static bit(1)                   dcl 3-84
as_data_$default_weight                external static fixed bin(35,0)          dcl 3-34
as_data_$devtabp                       external static pointer                  dcl 3-35
as_data_$dft_user_ring                 external static fixed bin(3,0)           dcl 3-36
as_data_$g115_dim                      external static char(32)                 packed unaligned dcl 3-38
as_data_$lct_initialized               external static bit(1)                   dcl 3-39
as_data_$lct_size                      external static fixed bin(17,0)          dcl 3-40
as_data_$login_args                    external static structure                level 1 dcl 3-62
as_data_$login_words                   external static fixed bin(17,0)          dcl 3-77
as_data_$ls_message_buffer_cur_lth     external static fixed bin(18,0)          dcl 3-86
as_data_$ls_message_buffer_max_lth     external static fixed bin(18,0)          dcl 3-87
as_data_$ls_message_buffer_ptr         external static pointer                  dcl 3-88
as_data_$ls_request_server_info_ptr    external static pointer                  dcl 3-85
as_data_$max_user_ring                 external static fixed bin(3,0)           dcl 3-41
as_data_$mgtp                          external static pointer                  dcl 3-42
as_data_$mrd_dim                       external static char(32)                 packed unaligned dcl 3-43
as_data_$ntty_dim                      external static char(32)                 packed unaligned dcl 3-44
as_data_$pdtdir                        external static char(168)                packed unaligned dcl 3-45
as_data_$pit_ptr                       external static pointer                  dcl 3-46
as_data_$rcpdir                        external static char(168)                packed unaligned dcl 3-47
as_data_$request_priority              external static fixed bin(17,0)          dcl 3-48
as_data_$rs_ptrs                       external static pointer                  array dcl 3-49
as_data_$rtdtp                         external static pointer                  dcl 3-50
as_data_$sat_htp                       external static pointer                  dcl 3-51
as_data_$satp                          external static pointer                  dcl 3-52
as_data_$signal_types                  external static structure                level 1 dcl 3-67
as_data_$suffix                        external static char(2)                  array packed unaligned dcl 3-53
as_data_$sysdir                        external static char(168)                packed unaligned dcl 3-54
as_data_$system_signal_types           external static structure                level 1 dcl 3-72
as_data_$teens_suffix                  external static char(2)                  array packed unaligned dcl 3-55
as_data_$terminet_tabs_string          external static varying char(144)        dcl 3-56
as_data_$tty_dim                       external static char(32)                 packed unaligned dcl 3-57
as_data_$update_priority               external static fixed bin(17,0)          dcl 3-58
as_data_$version                       external static char(8)                  packed unaligned dcl 3-59
as_data_$whoptr                        external static pointer                  dcl 3-60
as_data_login_words                    based           structure                level 1 dcl 3-77
as_procid                              defined         bit(36)                  dcl 4-17
as_tty                                 based           char(6)                  packed unaligned dcl 4-18
asmtp                                  defined         pointer                  dcl 4-19
bulkdevt                               internal static fixed bin(4,0)           initial dcl 8-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 8-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 8-105
dev_time                               internal static float bin(27)            initial array dcl 8-139
device_names                           internal static char(4)                  initial array dcl 8-66
devtabp                                defined         pointer                  dcl 4-20
dsu181devt                             internal static fixed bin(4,0)           initial dcl 8-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 8-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 8-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 8-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 8-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 8-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 8-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 8-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 8-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 8-124
ip                                     defined         pointer                  dcl 4-21
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 8-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 8-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 8-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 8-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 8-121
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 8-75
mgtp                                   defined         pointer                  dcl 4-22
msu0400devt                            internal static fixed bin(4,0)           initial dcl 8-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 8-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 8-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 8-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 8-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 8-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 8-93
pdtdir                                 based           char(168)                packed unaligned dcl 4-23
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 8-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 8-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 8-90
rs_ptrs                                based           pointer                  array dcl 4-24
sat_htp                                defined         pointer                  dcl 4-25
satp                                   defined         pointer                  dcl 4-26
sc_stat_$Go                            external static bit(1)                   dcl 10-62
sc_stat_$Multics                       external static bit(1)                   dcl 10-62
sc_stat_$Star_typed                    external static bit(1)                   dcl 10-62
sc_stat_$admin_listener_exit_label     external static label variable           dcl 10-34
sc_stat_$admin_listener_switch         external static bit(1)                   dcl 10-62
sc_stat_$admin_log_iocb                external static pointer                  dcl 10-45
sc_stat_$admin_log_write_ptr           external static pointer                  dcl 10-45
sc_stat_$admin_sci_ptr                 external static pointer                  dcl 10-45
sc_stat_$as_log_write_ptr              external static pointer                  dcl 10-45
sc_stat_$did_part1                     external static bit(1)                   dcl 10-62
sc_stat_$did_part2                     external static bit(1)                   dcl 10-62
sc_stat_$did_part3                     external static bit(1)                   dcl 10-62
sc_stat_$exec_access_name              external static char(32)                 packed unaligned dcl 10-15
sc_stat_$info_dir                      external static char(168)                packed unaligned dcl 10-21
sc_stat_$initzer_ttyp                  external static pointer                  dcl 10-45
sc_stat_$log_dir                       external static char(168)                packed unaligned dcl 10-21
sc_stat_$master_abort_label            external static label variable           dcl 10-34
sc_stat_$master_channel                external static char(6)                  dcl 10-29
sc_stat_$master_iocb                   external static pointer                  dcl 10-45
sc_stat_$master_sci_ptr                external static pointer                  dcl 10-45
sc_stat_$mc_acs_dir                    external static char(168)                packed unaligned dcl 10-21
sc_stat_$mc_ansp                       external static pointer                  dcl 10-45
sc_stat_$mc_iocb                       external static pointer                  dcl 10-45
sc_stat_$mc_is_on                      external static bit(1)                   dcl 10-62
sc_stat_$no_operator_login             external static bit(1)                   dcl 10-62
sc_stat_$shutdown_typed                external static bit(1)                   dcl 10-62
sc_stat_$sv1_iocb                      external static pointer                  dcl 10-45
sc_stat_$sv2_iocb                      external static pointer                  dcl 10-45
sc_stat_$sv3_iocb                      external static pointer                  dcl 10-45
sc_stat_$sysdir                        external static char(168)                packed unaligned dcl 10-21
sc_stat_$system_shutdown_label         external static label variable           dcl 10-34
sc_stat_$test_mode                     external static bit(1)                   dcl 10-62
sc_stat_$unidentified_access_name      external static char(32)                 packed unaligned dcl 10-15
sc_stat_$vchn_requires_accept          external static bit(1)                   dcl 10-62
scdtp                                  defined         pointer                  dcl 4-27
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 9-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 9-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 9-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 9-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 9-26
star_ALL_ENTRIES                       internal static fixed bin(2,0)           initial dcl 11-111
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 11-114
star_BRANCHES_ONLY                     internal static fixed bin(2,0)           initial dcl 11-110
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 11-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 11-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 11-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 11-112
star_dir_list_branch                   based           structure                array level 1 dcl 11-59
star_entries                           based           structure                array level 1 dcl 11-27
star_entry_count                       automatic       fixed bin(17,0)          dcl 11-14
star_entry_ptr                         automatic       pointer                  dcl 11-15
star_link_pathname                     based           char                     packed unaligned dcl 11-102
star_links                             based           structure                array level 1 dcl 11-76
star_linkx                             automatic       fixed bin(17,0)          dcl 11-18
star_list_names                        based           char(32)                 array packed unaligned dcl 11-92
star_list_names_ptr                    automatic       pointer                  dcl 11-20
star_names                             based           char(32)                 array packed unaligned dcl 11-37
star_names_ptr                         automatic       pointer                  dcl 11-19
star_select_sw                         automatic       fixed bin(3,0)           dcl 11-21
sysdir                                 defined         char(168)                packed unaligned dcl 4-28
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 8-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 8-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 8-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 9-29
whoptr                                 defined         pointer                  dcl 4-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 9-36

NAMES DECLARED BY EXPLICIT CONTEXT.
add_pdir_volume                 001631 constant        entry                    external dcl 397
add_pdv                         001641 constant        entry                    external dcl 398
count_pdir_volumes              004117 constant        entry                    internal dcl 592 ref 281 429 454 462 520 555
del_pdir_volume                 002157 constant        entry                    external dcl 434
del_pdv                         002167 constant        entry                    external dcl 435
err_log_no_msg                  001741 constant        label                    dcl 412 ref 427 445 460 483 510 544
find_lve                        004216 constant        entry                    internal dcl 608 ref 416 447 484 511 553
find_user_move_pdir             004304 constant        entry                    internal dcl 624 ref 571
get_pdd_quota                   006242 constant        entry                    internal dcl 791 ref 284 298 355 389 851
gq                              006541 constant        entry                    internal dcl 837 ref 793 820
init                            001045 constant        entry                    external dcl 268
move_pdir_segs                  005344 constant        entry                    internal dcl 700 ref 653 653 672 672 691 691
note_pdir_deletion              001351 constant        entry                    external dcl 349
one_arg_wanted                  001671 constant        label                    dcl 406 ref 442
pdir_volume_manager_            001035 constant        entry                    external dcl 15
print_pdq                       001462 constant        entry                    external dcl 385
select_pdir_vol                 005734 constant        entry                    internal dcl 745 ref 330 646 665 684
select_pdir_volume              001145 constant        entry                    external dcl 290
set_pdd_quota                   006665 constant        entry                    internal dcl 849 ref 300 357
set_pdir_volumes                002430 constant        entry                    external dcl 466
set_pdv                         002440 constant        entry                    external dcl 467
set_shared_spindle              007231 constant        entry                    internal dcl 890 ref 583 589
shared_spindle_off              004101 constant        entry                    external dcl 586
shared_spindle_on               004062 constant        entry                    external dcl 580
vac_pdv                         003262 constant        entry                    external dcl 526
vacate_pdir_volume              003252 constant        entry                    external dcl 524
valid_call                      007302 constant        entry                    internal dcl 905 ref 293 352 402 439 470 529
vol_not_found                   002015 constant        label                    dcl 417 ref 447

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10126       10246    7417       10136
Length     11112    7417       120         630     506          20

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pdir_volume_manager_                820 external procedure  is an external procedure.  
count_pdir_volumes                      internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
find_lve                                internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
find_user_move_pdir                     internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
move_pdir_segs                      106 internal procedure  is assigned to an entry variable.  
select_pdir_vol                         internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
get_pdd_quota                           internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
gq                                      internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
set_pdd_quota                           internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
set_shared_spindle                      internal procedure  shares stack frame of external procedure pdir_volume_manager_.  
valid_call                              internal procedure  shares stack frame of external procedure pdir_volume_manager_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 already_init                pdir_volume_manager_
000011 cur_lvix                    pdir_volume_manager_
000012 cur_pvix                    pdir_volume_manager_
000013 n_pdir_volumes              pdir_volume_manager_
000014 static_dtp                  pdir_volume_manager_
000016 shared_spindle_hack         pdir_volume_manager_
000017 default_pddir_q             pdir_volume_manager_
000020 default_pdq                 pdir_volume_manager_
000021 npd                         pdir_volume_manager_
000022 pdddir_q                    pdir_volume_manager_
000023 pddq                        pdir_volume_manager_
000024 pddir_q                     pdir_volume_manager_
000025 pdq                         pdir_volume_manager_
000026 pddq_known                  pdir_volume_manager_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
pdir_volume_manager_     000100 more_than_one_pdir_vol      pdir_volume_manager_
                         000101 ename                       pdir_volume_manager_
                         000111 loud                        pdir_volume_manager_
                         000112 code                        pdir_volume_manager_
                         000113 i                           pdir_volume_manager_
                         000114 n_new_pdir_volumes          pdir_volume_manager_
                         000115 pvix                        pdir_volume_manager_
                         000116 idx                         pdir_volume_manager_
                         000117 pdir                        pdir_volume_manager_
                         000171 pdir_to_move                pdir_volume_manager_
                         000243 pdir_vol_name               pdir_volume_manager_
                         000253 pdir_lvid                   pdir_volume_manager_
                         000254 proc_lvix                   pdir_volume_manager_
                         000255 argl                        pdir_volume_manager_
                         000256 argno                       pdir_volume_manager_
                         000257 nargs                       pdir_volume_manager_
                         000260 argp                        pdir_volume_manager_
                         000262 dir_discrepancy             pdir_volume_manager_
                         000263 discrepancy                 pdir_volume_manager_
                         000264 pass_number                 pdir_volume_manager_
                         000265 pddq_was_known              pdir_volume_manager_
                         000266 just_got_quota              pdir_volume_manager_
                         000267 long_sw                     pdir_volume_manager_
                         000270 dir_quota                   pdir_volume_manager_
                         000271 quota                       pdir_volume_manager_
                         000272 qused                       pdir_volume_manager_
                         000274 tpp                         pdir_volume_manager_
                         000276 uptime                      pdir_volume_manager_
                         000277 slvid                       pdir_volume_manager_
                         000300 qswitch                     pdir_volume_manager_
                         000302 autp                        pdir_volume_manager_
                         000304 ansp                        pdir_volume_manager_
                         000306 dutp                        pdir_volume_manager_
                         000310 dtp                         pdir_volume_manager_
                         000312 dtep                        pdir_volume_manager_
                         000314 lvep                        pdir_volume_manager_
                         000316 seek_command                pdir_volume_manager_
                         000320 star_branch_count           pdir_volume_manager_
                         000322 star_list_branch_ptr        pdir_volume_manager_
                         000324 star_link_count             pdir_volume_manager_
                         000326 utep                        pdir_volume_manager_
                         000344 nvol                        count_pdir_volumes
                         000345 i                           count_pdir_volumes
                         000356 i                           find_lve

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             r_le_a              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
return_mac          shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            cu_$arg_count                 cu_$arg_ptr                   disk_table_$get_dtp
disk_table_$set_lv_pdir_bit   disk_table_$set_vacate_pdirs_bit                            hcs_$dir_quota_read
hcs_$quota_read               hphcs_$dir_quota_set          hphcs_$pv_move_file           hphcs_$quota_set
hphcs_$set_pdir_sons_lvid     hphcs_$set_sons_lvid          read_allowed_                 sub_err_
sweep_disk_$dir_list          sys_log_                      sys_log_$error_log            unique_chars_
write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
as_data_$ansp                 as_data_$autp                 as_data_$dutp
error_table_$action_not_performed                           error_table_$badopt           error_table_$out_of_sequence
sc_stat_$Go_typed             sc_stat_$Multics_typed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    252 000734    1   26 000735    2   53 000737    5   27 000740    8   84 000741   14   76 001030        15 001034
    268 001043       270 001053       271 001056       274 001105       276 001107       277 001115       278 001120
    280 001121       281 001123       283 001131       284 001134       286 001135       287 001140       290 001141
    292 001153       293 001156       294 001163       295 001167       296 001170       298 001171       300 001176
    304 001220       305 001226       306 001231       307 001233       309 001234       310 001236       311 001240
    313 001242       314 001246       315 001250       316 001252       318 001253       319 001254       320 001256
    323 001260       325 001261       326 001263       327 001265       330 001266       331 001270       332 001272
    333 001274       335 001275       336 001301       337 001331       338 001333       339 001335       341 001336
    344 001341       346 001345       349 001346       351 001357       352 001362       353 001367       355 001373
    357 001400       361 001420       362 001426       363 001430       364 001432       366 001433       367 001435
    368 001437       370 001441       371 001445       372 001446       373 001450       375 001451       376 001452
    377 001454       380 001456       382 001460       385 001461       387 001470       388 001473       389 001477
    390 001500       393 001573       394 001627       397 001630       398 001637       400 001647       402 001652
    404 001657       405 001666       406 001671       407 001717       410 001720       411 001737       412 001741
    413 001772       416 001773       417 002015       418 002052       421 002053       422 002060       423 002115
    426 002116       427 002144       429 002146       431 002155       434 002156       435 002165       437 002175
    439 002200       441 002205       442 002214       444 002217       445 002236       447 002240       449 002262
    450 002266       451 002323       454 002324       455 002331       456 002366       459 002367       460 002415
    462 002417       463 002426       466 002427       467 002436       469 002446       470 002451       472 002456
    473 002465       474 002467       475 002515       480 002516       481 002517       482 002525       483 002542
    484 002544       486 002624       488 002667       489 002670       491 002672       492 002674       498 002737
    499 002747       500 003001       501 003033       504 003076       508 003100       509 003107       510 003124
    511 003126       512 003150       513 003155       514 003203       518 003237       520 003241       522 003250
    524 003251       526 003260       528 003270       529 003273       531 003300       532 003307       533 003312
    534 003340       537 003341       538 003343       540 003344       542 003345       543 003355       544 003372
    545 003374       546 003410       548 003423       549 003457       551 003460       553 003461       555 003541
    556 003555       557 003612       558 003613       560 003614       561 003642       566 003676       568 003700
    569 003711       570 003743       571 003747       572 003751       573 004010       576 004056       578 004060
    580 004061       582 004070       583 004073       584 004077       586 004100       588 004107       589 004112
    590 004116       592 004117       597 004121       598 004122       599 004133       601 004210       602 004212
    608 004216       613 004227       614 004237       615 004270       616 004274       618 004277       620 004301
    624 004304       639 004306       640 004312       641 004323       642 004330       643 004340       644 004372
    646 004435       647 004437       648 004442       649 004511       650 004513       651 004545       653 004546
    654 004565       656 004571       658 004573       659 004577       660 004607       661 004613       662 004623
    663 004655       665 004720       666 004722       667 004725       668 004774       669 004776       670 005030
    672 005031       673 005050       675 005054       677 005056       678 005062       679 005073       680 005077
    681 005107       682 005141       684 005204       685 005206       686 005211       687 005260       688 005262
    689 005314       691 005315       692 005334       694 005340       696 005342       700 005343       721 005351
    725 005356       726 005360       728 005361       730 005366       732 005461       733 005465       734 005572
    737 005574       738 005622       741 005732       745 005734       758 005736       759 005737       760 005745
    761 005761       762 005766       766 006017       768 006021       771 006035       772 006045       774 006131
    775 006134       776 006142       777 006146       778 006152       781 006153       782 006174       784 006176
    785 006235       787 006241       791 006242       793 006243       794 006250       795 006252       796 006307
    799 006310       800 006314       801 006317       802 006323       804 006365       807 006373       808 006377
    810 006441       814 006447       815 006451       816 006453       817 006455       819 006456       820 006460
    821 006463       822 006465       823 006526       825 006527       826 006532       827 006534       828 006536
    831 006540       837 006541       841 006552       842 006617       843 006664       849 006665       851 006666
    853 006671       854 006675       857 006714       860 006731       862 006732       865 006746       869 006760
    870 007003       871 007005       872 007046       874 007047       875 007072       876 007074       877 007132
    880 007133       881 007167       882 007172       883 007225       885 007230       890 007231       894 007233
    896 007272       900 007301       905 007302       907 007304       908 007307       909 007334       912 007337
    913 007341


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
