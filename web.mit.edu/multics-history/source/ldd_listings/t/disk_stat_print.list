	COMPILATION LISTING OF SEGMENT disk_stat_print
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/13/88  1023.5 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-10-06,Parisek), approve(88-02-03,MCR7845),
       17*     audit(88-04-18,Lippard), install(88-04-26,MR12.2-1043):
       18*     Implement multi-segment file application for possible >256K disk_stat
       19*     segment.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 /* format: style4 */
       24 disk_stat_print: dsp: proc;
       25 
       26 /*
       27*   Completely rewritten by TAC, April 1976
       28*   Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures.
       29*   Modified June 1982 by E. N. Kittlitz to set rs_number if search_sat_ complains.
       30**/
       31 
       32 /* This procedure prints the disk_stat file that is created by sweep.
       33*   The segment "disk_stat" in the working directory is used, unless a pathname is given.
       34*   Optional control arguments allow the user to specify:
       35*   1 - printing of just the totals figures;
       36*   2 - printing only those directories at or above a specified level,
       37*   -   with the usage figures of the entire subtree below that directory being
       38*   -   included in the figures printed for that directory;
       39*   3 - printing of per-level subtotals each time level decreases;
       40*   4 - printing of a per-logical-volume summary of disk usage, following the totals lines.
       41*
       42*   Usage: dsp -path- -total (-tt) -logical_volume (-lv) -subtotal (-stt) -level (-lev) N
       43*
       44**/
       45 
       46 /* Declarations */
       47 
       48 /* Ext Entries */
       49 
       50 dcl  com_err_ entry options (variable);
       51 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       52 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       53 dcl  cv_$mwvf entry (float bin) returns (char (15));	/* library routines */
       54 dcl  date_time_ entry (fixed bin (71), char (*));
       55 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
       56 dcl  get_wdir_ entry () returns (char (168));
       57 dcl  search_sat_$rs_number entry (char (*), fixed bin, fixed bin (35));
       58 dcl  search_sat_$clean_up entry;
       59 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       60 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
       61 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       62 dcl  hcs_$truncate_seg entry (ptr, fixed bin (18), fixed bin (35));
       63 dcl  ioa_ entry options (variable);
       64 dcl  mdc_$find_lvname entry (bit (36) aligned, char (*) aligned, fixed bin (35));
       65 dcl  msf_manager_$close entry (ptr);
       66 dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
       67 dcl  msf_manager_$open entry (char (*), char (*), ptr, fixed bin (35));
       68 dcl  user_info_$rs_number entry (fixed bin);
       69 dcl  user_info_$rs_name entry (char (*));
       70 dcl  system_info_$rs_name entry (fixed bin, char (*), fixed bin (35));
       71 dcl  system_info_$prices_rs entry (fixed bin,
       72 	(0:7) float bin, (0:7) float bin, (0:7) float bin, (0:7) float bin, float bin, float bin);
       73 dcl  system_info_$max_rs_number entry (fixed bin);
       74 dcl  system_info_$titles entry (char (*), char (*));
       75 
       76 /* Bit */
       77 
       78 dcl  (msf, no_sat, subtot_sw, total_sw, volume_sw) bit (1) aligned init ("0"b);
       79 
       80 /* Fixed bin */
       81 
       82 dcl  ttemp fixed bin (71);				/* clock value */
       83 dcl  (code, bad_lvid_code) fixed bin (35) init (0);
       84 
       85 dcl  (acpx, al, an, cpx, dlev, i, j, k, lvl, nxtlev, ti) fixed bin;
       86 						/* misc counters */
       87 dcl  n_bad_lvids fixed bin init (0);
       88 dcl  (lvix, nlv, root_lvix) fixed bin;			/* indices in lv_totals structure */
       89 dcl  fmt_ix fixed bin init (1);			/* which formats to use */
       90 dcl  maxlev fixed bin init (16);			/* print all levels, by default */
       91 dcl  ROOT fixed bin;				/* level of first dir in disk_stat (normally 0 for root) */
       92 dcl  rs_name char (32);
       93 dcl  rs_number fixed bin;
       94 dcl  rs_count fixed bin;
       95 dcl  last_dent fixed bin;
       96 		  
       97 /* Float bin */
       98 
       99 dcl  dummy (0:7) float bin;
      100 dcl  dummy1 float bin;
      101 dcl  disk_price (0:9) float bin;
      102 
      103 /* Char */
      104 
      105 dcl  path char (168);				/* for printing pathname from disk_stat entry */
      106 dcl  dn char (168) init (get_wdir_ ());			/* both for getting disk stat file and printing its entries */
      107 dcl  (coxx, dpxx) char (64);				/* company and department names, for heading */
      108 dcl  en char (32) init ("disk_stat");
      109 dcl  old_project_entry char (32) init ("");
      110 dcl  (ttmp1, ttmp2) char (24);			/* from-date and to-date for heading */
      111 dcl  errmsg char (64) varying;			/* error info */
      112 
      113 /* Automatic Structure */
      114 
      115 dcl  1 subtot (0:16),
      116        2 (dquota, dused, squota, sused, dvolx, dsix) fixed bin,
      117        2 (dcharge, scharge) float bin;
      118 
      119 dcl  cp_array (0:4) ptr;
      120 		  
      121 
      122 /* Format strings for ioa_ */
      123 
      124 dcl  dir_formats (2) char (36) int static init (
      125 	"^7d ^7d^15a ^7d ^7d^15a ^5d ^s^a",
      126 	"^7d ^7d^15a ^7d ^7d^15a ^5d ^4d ^a");
      127 
      128 dcl  heading_dashes (2) char (99) int static init (
      129 	"------- ------- -------------- ------- ------- -------------- ----- ------------------------^/",
      130 	"------- ------- -------------- ------- ------- -------------- ----- ---- ------------------------^/");
      131 
      132 dcl  heading_words (2) char (72) int static init (
      133 	"^/^2xs-qta^3xs-use^7xs-charge^3xd-qta^3xd-use^7xd-charge^3xlev path",
      134 	"^/^2xs-qta^3xs-use^7xs-charge^3xd-qta^3xd-use^7xd-charge^3xlev lvix path");
      135 
      136 dcl  sub_total_formats (2) char (32) int static init (
      137 	"^7d ^7d^15a ^7d ^7d^15a^7x^a",
      138 	"^7d ^7d^15a ^7d ^7d^15a^12x^a");
      139 
      140 dcl  total_formats (2) char (24) int static init (
      141 	"^/^31x^7d ^7d^15a^7x^a",
      142 	"^/^31x^7d ^7d^15a^12x^a");
      143 
      144 dcl  vol_format char (26) int static init (
      145 	"^31x^7d ^7d^15a ^5x ^4d ^a");
      146 
      147 /* Ptr */
      148 
      149 dcl  (ap, fcbp, lvtp, pdtep, pdtp) ptr;
      150 
      151 /* Based */
      152 
      153 
      154 dcl  bchr char (al) based (ap);
      155 
      156 dcl  1 lv_totals (-1:nlv) aligned based (lvtp),
      157        2 lv_name char (32),
      158        2 lv_tpp float bin,
      159        2 lv_id bit (36),
      160        2 lv_quota fixed bin,
      161        2 lv_used fixed bin;
      162 
      163 /* Builtin */
      164 
      165 dcl  (addr, after, before, hbound, null, substr) builtin;
      166 
      167 /* Ext */
      168 
      169 dcl  (error_table_$badopt, error_table_$bad_arg, error_table_$noentry) ext fixed bin (35);
      170 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      171 
      172 /* Procedure */
      173 
      174 	call system_info_$max_rs_number (rs_count);	/* see if site has multiple rate structures */
      175 
      176 	code = 0;
      177 	sp = null;
      178 	fcbp = null;
      179 
      180 	do an = 1 by 1 while (code = 0);		/* go thru all arguments */
      181 
      182 	     call cu_$arg_ptr (an, ap, al, code);
      183 
      184 	     if code = 0 then do;			/* if there is an argument */
      185 
      186 		if substr (bchr, 1, 1) = "-" then do;	/* control argument */
      187 
      188 		     if bchr = "-tt" | bchr = "-total" then
      189 			total_sw = "1"b;
      190 
      191 		     else if bchr = "-stt" | bchr = "-subtotal" then
      192 			subtot_sw = "1"b;
      193 
      194 		     else if bchr = "-lv" | bchr = "-vol" | bchr = "-volume"
      195 			     | bchr = "-lvol" | bchr = "-logical_volume" then do;
      196 			volume_sw = "1"b;
      197 			fmt_ix = 2;		/* use formats with place for lvix column */
      198 		     end;
      199 
      200 		     else if bchr = "-lev" | bchr = "-level" then do;
      201 			an = an + 1;
      202 			call cu_$arg_ptr (an, ap, al, code);
      203 			if code ^= 0 then do;	/* must be error_table_$noarg */
      204 			     en = "after -level";
      205 			     goto er;
      206 			end;
      207 
      208 			maxlev = cv_dec_check_ (bchr, code);
      209 			if code ^= 0 then do;
      210 			     code = 0;		/* not an error_table_ code */
      211 			     en = "illegal decimal number: " || bchr;
      212 			     goto er;
      213 			end;
      214 
      215 			if maxlev < 0 | maxlev > 16 then do;
      216 			     en = "level must be >= 0 and <= 16";
      217 			     goto er;
      218 			end;
      219 		     end;				/* end -level do group */
      220 
      221 		     else do;			/* unrecognized control arg */
      222 			code = error_table_$badopt;
      223 			en = bchr;
      224 			goto er;
      225 		     end;
      226 
      227 		end;				/* end control arg do group */
      228 
      229 		else if sp = null then do;		/* must be pathname of disk_stat file */
      230 		     call expand_path_ (ap, al, addr (dn), addr (en), code);
      231 		     if code ^= 0 then go to er;
      232 		end;
      233 
      234 		else do;
      235 		     code = error_table_$bad_arg;
      236 		     en = bchr;
      237 		     goto er;
      238 		end;
      239 
      240 	     end;					/* end there-is-an-arg do group */
      241 	end;					/* end arg loop */
      242 
      243 	call msf_manager_$open (dn, en, fcbp, code);
      244 	if code ^= 0 then do;
      245 	     call com_err_ (code, "disk_stat_print", "Cannot obtain MSF control block pointer.");
      246 	     return;
      247 	end;
      248 	acpx, cpx, ti = 0;
      249 cpx_loop: call msf_manager_$get_ptr (fcbp, cpx, "0"b, cp_array (cpx), 0, code);
      250 	if code = 0 then do;
      251 	     cpx = cpx + 1;
      252 	     goto cpx_loop;
      253 	end;
      254 	if cp_array (0) = null () then do;
      255 er:	     call com_err_ (code, "disk_stat_print", en);
      256 	     return;
      257 	end;
      258 
      259 	sp = cp_array (0);
      260 
      261 	do rs_number = 0 to hbound (disk_price, 1);	/* get all the rates */
      262 	     call system_info_$rs_name (rs_number, rs_name, code); /* this here to check for a valid rate */
      263 	     if code ^= 0 then disk_price (rs_number) = disk_price (0); /* assumes default will not give an error */
      264 	     else call system_info_$prices_rs (rs_number, dummy, dummy, dummy, dummy, disk_price (rs_number), dummy1);
      265 	end;
      266 
      267 	if volume_sw then do;			/* initialize for presenting per-logical-volume data */
      268 	     call hcs_$make_seg ("", "lv_totals", "", 1010b, lvtp, code);
      269 	     if lvtp = null then do;
      270 lv_er:		en = "[pd]>lv_totals";
      271 		goto er;
      272 	     end;
      273 
      274 	     call hcs_$truncate_seg (lvtp, 0, code);	/* make sure there is no junk in it */
      275 	     if code ^= 0 then goto lv_er;
      276 
      277 	     lv_totals (-1).lv_name = "Unknown volumes";
      278 						/* slot zero is unused, for convenience of implementation */
      279 	     lv_totals (1).lv_name = "root";		/* reserve slot for rlv, so we will know */
      280 	     root_lvix = 1;				/* where to record directory page use */
      281 	     nlv = 1;
      282 	end;
      283 
      284 	if ^total_sw then do;			/* print heading, unless just printing totals */
      285 	     call system_info_$titles (coxx, dpxx);
      286 	     call ioa_ ("^|^a^/^/^a", coxx, dpxx);
      287 	     ttemp = dtime;
      288 	     call date_time_ (ttemp, ttmp2);
      289 	     ttemp = dreset;
      290 	     call date_time_ (ttemp, ttmp1);
      291 	     call ioa_ ("^/Disk usage for ^a to ^a", ttmp1, ttmp2);
      292 
      293 	     dn = "";				/* initialize for later pathname printing */
      294 	end;					/* end print-heading do group */
      295 
      296 /* print one line heading even if printing totals only */
      297 	call ioa_ (heading_words (fmt_ix));
      298 
      299 	if ^total_sw then				/* if not being terse */
      300 	     call ioa_ (heading_dashes (fmt_ix));
      301 
      302 	ROOT = disk_stat.slev (1);			/* get level of first dir in disk_stat */
      303 	dlev = ROOT - 1;				/* initialize dlev to facilitate detection of
      304*						   decreasing level number, for printing subtotals */
      305 
      306 /* Start main loop */
      307 
      308 	last_dent = dents;
      309 begin:	
      310 	do i = 1 to last_dent + 1;			/* go thru all dirs in disk_stat, plus one more time
      311*						   to print the last line or subtree */
      312 
      313 	     if i = last_dent + 1 then			/* if this is that one more time */
      314 		nxtlev = ROOT;			/* pretend there is another root at the end of disk_stat */
      315 	     else nxtlev = disk_stat.slev (i);		/* else get level of next dir */
      316 print_lev:					/* need to know where to come if MSF */
      317 	     if ^total_sw				/* if we are printing directory lines */
      318 		& i > 1				/* and there is a previous directory */
      319 		& dlev <= maxlev			/* and it is in the range of levels being printed */
      320 		& nxtlev <= maxlev then		/* and next dir is not part of a non-printing subtree under it */
      321 		call print_dir_line (dlev);		/* then print a line for the previous dir now */
      322 
      323 /* If the next dir is not at a higher level number than the previous one,
      324*   this loop gets executed one or more times, to free the subtotal array entry
      325*   in which we want to store the figures for the next dir */
      326 
      327 	     do lvl = dlev by -1 to nxtlev		/* back up thru levels, from last dir's to this one's */
      328 		while (lvl > ROOT);			/* but stop one level sooner if nxtlev=ROOT */
      329 
      330 		call add_up_subtot (lvl - 1, lvl);	/* add inferior subtree's figures to its superior */
      331 
      332 		if lvl - 1 <= maxlev & ^total_sw then do; /* if printing is wanted for level just added to */
      333 		     if lvl - 1 = maxlev		/* if superior is a subtree waiting to be printed */
      334 			& nxtlev <= maxlev then	/* and next dir is not part of it */
      335 			call print_dir_line (lvl - 1);/* print a line for the subtree */
      336 
      337 		     else				/* but if superior is not a subtree waiting to be printed */
      338 			if subtot_sw then		/* and user wants subtotals */
      339 			if nxtlev <= lvl - 1 then	/* and next dir is equal to or superior to the superior */
      340 			     call print_subtot_line (lvl - 1); /* print a subtotal line for the superior */
      341 		end;				/* end printing-wanted-for-level do group */
      342 
      343 	     end;					/* end loop backing up through the levels */
      344 	     if msf then goto next_component;
      345 
      346 /* Now, level nxtlev in the subtot array is free to be stored into */
      347 
      348 	     dlev = nxtlev;				/* now, next dir becomes this dir */
      349 
      350 	     if i <= last_dent then do;		/* if this dir is real, and not the imaginary
      351*						   root at the end of disk_stat, store its figures
      352*						   into the appropriate subtotal array entry */
      353 
      354 		if dlev < 1 | rs_count = 0 then rs_number = 0; /* if ^project dir or site has no rate structures */
      355 		else call set_disk_price_index (i, rs_number); /* find the correct price */
      356 		subtot (dlev).dquota = disk_stat.dqta (i);
      357 		subtot (dlev).squota = disk_stat.sqta (i);
      358 		subtot (dlev).dused = disk_stat.duse (i);
      359 		subtot (dlev).sused = disk_stat.suse (i);
      360 		subtot (dlev).dcharge = disk_stat.dtpp (i) * disk_price (rs_number);
      361 		subtot (dlev).scharge = disk_stat.stpp (i) * disk_price (rs_number);
      362 		subtot (dlev).dsix = i;		/* so we can find pathname of dir where subtree starts */
      363 
      364 		if volume_sw then do;		/* if we are supposed to save per-volume information */
      365 		     do lvix = 1 to nlv		/* look up this directory's logical volume */
      366 			while (lv_totals (lvix).lv_id ^= disk_stat.slvid (i));
      367 		     end;
      368 
      369 		     if lvix = nlv + 1 then do;	/* if this volume is not in our list yet */
      370 			call mdc_$find_lvname (disk_stat.slvid (i), lv_totals (lvix).lv_name, code);
      371 			if code ^= 0 then do;	/* if mdc_ does not recognize the lvid */
      372 			     lvix = -1;		/* use the "Unknown volumes" entry */
      373 			     n_bad_lvids = n_bad_lvids + 1; /* count these, for one error message at end */
      374 			     if bad_lvid_code = 0 then/* remember the code, too */
      375 				bad_lvid_code = code;
      376 			end;
      377 
      378 			else if lv_totals (lvix).lv_name = "root" then /* root logical volume */
      379 			     lvix = 1;		/* slot 1 is reserved for it */
      380 
      381 			else nlv = lvix;		/* otherwise, we have a new logical volume */
      382 
      383 			lv_totals (lvix).lv_id = disk_stat.slvid (i); /* save the lvid */
      384 
      385 		     end;				/* end volume-not-in-list do group */
      386 
      387 /* segment data gets added to the lvid entry */
      388 		     lv_totals (lvix).lv_tpp = lv_totals (lvix).lv_tpp + disk_stat.stpp (i) * disk_price (rs_number);
      389 		     lv_totals (lvix).lv_quota = lv_totals (lvix).lv_quota + disk_stat.sqta (i);
      390 		     lv_totals (lvix).lv_used = lv_totals (lvix).lv_used + disk_stat.suse (i);
      391 
      392 /* but directory data gets added to the rlv's entry */
      393 		     lv_totals (root_lvix).lv_tpp = lv_totals (root_lvix).lv_tpp + disk_stat.dtpp (i) * disk_price (rs_number);
      394 		     lv_totals (root_lvix).lv_quota = lv_totals (root_lvix).lv_quota + disk_stat.dqta (i);
      395 		     lv_totals (root_lvix).lv_used = lv_totals (root_lvix).lv_used + disk_stat.duse (i);
      396 
      397 		     subtot (dlev).dvolx = lvix;	/* remember lvix of dir that starts this subtree */
      398 
      399 		end;				/* end save-per-volume-information do group */
      400 
      401 	     end;					/* end this-is-a-real-dir do group */
      402 	     if (lodh + (i+1) * lode) > sys_info$max_seg_size then do;
      403 		msf = "1"b;
      404 		goto print_lev;
      405 next_component:	msf = "0"b;
      406 		ti = ti + i;
      407 		last_dent = dents - ti;
      408 		acpx = acpx + 1;
      409 		sp = cp_array (acpx);
      410 		goto begin;
      411 	     end;
      412 	end;					/* end main loop thru disk_stat */
      413 
      414 /* Now, print totals and volume summary, if user wants it */
      415 
      416 	if n_bad_lvids > 0 then
      417 	     call com_err_ (bad_lvid_code, "disk_stat_print", "There were ^d directories with unknown lvid's", n_bad_lvids);
      418 
      419 	if ^total_sw then
      420 	     call ioa_ (heading_dashes (fmt_ix));
      421 
      422 	call ioa_ (sub_total_formats (fmt_ix),
      423 	     subtot (ROOT).squota, subtot (ROOT).sused, cv_$mwvf (subtot (ROOT).scharge),
      424 	     subtot (ROOT).dquota, subtot (ROOT).dused, cv_$mwvf (subtot (ROOT).dcharge),
      425 	     "SUBTOTALS");
      426 
      427 	call ioa_ (total_formats (fmt_ix),
      428 	     subtot (ROOT).squota + subtot (ROOT).dquota,
      429 	     subtot (ROOT).sused + subtot (ROOT).dused,
      430 	     cv_$mwvf (subtot (ROOT).scharge + subtot (ROOT).dcharge),
      431 	     "TOTALS (SEGMENTS + DIRECTORIES)");
      432 
      433 	if ^total_sw then call ioa_;			/* skip a line if not being terse */
      434 
      435 	if volume_sw then				/* if user so requested,   */
      436 	     do i = -1 to nlv;			/* print per-logical-volume data */
      437 	     if i >= 1 |				/* if this is a real volume, or */
      438 		lv_totals (i).lv_quota > 0 then	/* the dummy entry has some data in it */
      439 		call ioa_ (vol_format,
      440 		     lv_totals (i).lv_quota, lv_totals (i).lv_used,
      441 		     cv_$mwvf (lv_totals (i).lv_tpp),
      442 		     i, lv_totals (i).lv_name);
      443 	end;
      444 
      445 
      446 finish:	
      447 	if fcbp ^= null then
      448 	     call msf_manager_$close (fcbp);
      449 	if volume_sw then do;			/* clean up temp seg if we had one */
      450 	     call hcs_$truncate_seg (lvtp, 0, code);
      451 	     call hcs_$terminate_noname (lvtp, code);
      452 	end;
      453 	if rs_count > 0 then call search_sat_$clean_up;	/* tidy up */
      454 
      455 	return;
      456 err_finish:
      457 	call com_err_ (0, "disk_stat_print", errmsg);
      458 	goto finish;
      459 
      460 add_up_subtot: proc (l, ll);				/* procedure to add level ll subtotals to level l subtotals */
      461 
      462 dcl  (l, ll) fixed bin;				/* ll is usually l+1, to add, for example,
      463*						   a user's figures to the project's subtotal */
      464 
      465 	subtot (l).dquota = subtot (l).dquota + subtot (ll).dquota;
      466 	subtot (l).dused = subtot (l).dused + subtot (ll).dused;
      467 	subtot (l).squota = subtot (l).squota + subtot (ll).squota;
      468 	subtot (l).sused = subtot (l).sused + subtot (ll).sused;
      469 	subtot (l).dcharge = subtot (l).dcharge + subtot (ll).dcharge;
      470 	subtot (l).scharge = subtot (l).scharge + subtot (ll).scharge;
      471 
      472 /*             subtot(l).dsix is not modified after being set; it lets us find path of dir that begins this subtree */
      473 
      474 	if subtot (l).dvolx ^= subtot (ll).dvolx then	/* if level l and level ll dirs not on same lvol */
      475 	     subtot (l).dvolx = 0;			/* say "more than one volume" */
      476 
      477 	return;
      478 
      479      end add_up_subtot;
      480 
      481 
      482 print_dir_line: proc (l);				/* procedure to print line for single dir or subtree */
      483 
      484 dcl  l fixed bin;
      485 
      486 	path = disk_stat.spth (subtot (l).dsix);	/* get full path of this dir */
      487 
      488 	path = spth (subtot (l).dsix);		/* decide how much of the pathname to print */
      489 	k = 0;
      490 	do j = 2 to 168;				/* find leading components that are same as in previous one */
      491 	     if substr (path, j, 1) = ">" then do;
      492 		if substr (path, 1, j) = substr (dn, 1, j) then k = j;
      493 	     end;
      494 	end;
      495 	substr (path, 1, k) = "";			/* blank out portion of path that is same as previous one */
      496 
      497 	dn = spth (subtot (l).dsix);			/* then save this one's complete pathname,
      498*						   for use in deciding how much of the next pathname to print */
      499 
      500 	call ioa_ (dir_formats (fmt_ix),
      501 	     subtot (l).squota, subtot (l).sused, cv_$mwvf (subtot (l).scharge),
      502 	     subtot (l).dquota, subtot (l).dused, cv_$mwvf (subtot (l).dcharge),
      503 	     l, subtot (l).dvolx, path);
      504 
      505 	return;
      506 
      507      end print_dir_line;
      508 
      509 
      510 print_subtot_line: proc (l);				/* procedure to print subtotal for a subtree */
      511 
      512 dcl  l fixed bin;
      513 
      514 	call ioa_ (heading_dashes (fmt_ix));		/* draw line under dirs to be subtotaled */
      515 	call ioa_ (dir_formats (fmt_ix),
      516 	     subtot (l).squota, subtot (l).sused, cv_$mwvf (subtot (l).scharge),
      517 	     subtot (l).dquota, subtot (l).dused, cv_$mwvf (subtot (l).dcharge),
      518 	     l, subtot (l).dvolx, disk_stat.spth (subtot (l).dsix)); /* print full pathname for subtotals */
      519 	call ioa_ (heading_dashes (fmt_ix));		/* surround subtotal with lines */
      520 	call ioa_;				/* skip one line */
      521 
      522 	return;
      523 
      524      end print_subtot_line;
      525 
      526 set_disk_price_index: proc (i, rs_number);		/* determines the correct rate to use */
      527 
      528 dcl  rs_number fixed bin;
      529 dcl  i fixed bin;
      530 dcl  project_entry char (32);
      531 dcl  path char (168);
      532 dcl  ec fixed bin (35);
      533 
      534 	path = after (disk_stat.spth (i), ">");		/* get rid of root */
      535 	project_entry = before (path, ">");		/* and grab 1st level directory */
      536 	if project_entry ^= "udd" then
      537 	     if project_entry ^= "UDD" then
      538 		if project_entry ^= "user_dir_dir" then do; /* doesn't belong to a project */
      539 		     rs_number = 0;			/* use default */
      540 		     old_project_entry = "";
      541 		     return;
      542 		end;
      543 	path = after (path, ">");
      544 	project_entry = before (path, ">");		/* finally - the project name (one of them) */
      545 	if project_entry = old_project_entry then return; /* avoid some work */
      546 	old_project_entry = project_entry;
      547 	if ^no_sat then call search_sat_$rs_number (project_entry, rs_number, code); /* get rate index */
      548 	if no_sat | code ^= 0 then do;
      549 	     rs_number = 0;				/* assume the worst */
      550 	     if code = error_table_$noentry then
      551 		call com_err_ (code, "disk_stat_print",
      552 		     "Trying to locate project ""^a"" in the sat.  Default rates will be used.",
      553 		     project_entry);
      554 	     else do;
      555 		project_entry = before (project_entry, " ") || ".pdt";
      556 		call hcs_$initiate (">sc1>pdt", project_entry, "", 0, 1, pdtp, ec); /* get the pdt */
      557 		if pdtp ^= null then rs_number = pdt.rs_number;
      558 		else do;				/* last effort is to use the pit.rs_number */
      559 		     call user_info_$rs_number (rs_number);
      560 		     call user_info_$rs_name (rs_name);
      561 		     if no_sat then call com_err_ (0, "disk_stat_print",
      562 			     "Insufficient access for >sc1>pdt>^a.", project_entry);
      563 		     else call com_err_ (ec, "disk_stat_print", "Cannot access the sat or >sc1>pdt>^a.^/Using rate structure ""^a"" defined for this process.",
      564 			     project_entry, rs_name);
      565 		end;
      566 		no_sat = "1"b; ;			/* indicate cannot get the sat */
      567 	     end;
      568 	end;
      569 	return;
      570 
      571      end set_disk_price_index;
      572 
  1     1 /* BEGIN INCLUDE FILE ... disk_stat.incl.pl1 */
  1     2 
  1     3 /* This segment is created by "sweep" and read by "charge_disk" when disk stats are being charged. */
  1     4 /* Modified April 1976 by TAC to add dqta, duse, and dtpp */
  1     5 
  1     6 dcl  sp ptr;					/* pointer to segment */
  1     7 
  1     8 dcl 1 disk_stat based (sp) aligned,			/* structure of segment */
  1     9     2 dents fixed bin,				/* number of entries */
  1    10     2 dpad1 fixed bin,
  1    11     2 dtime fixed bin (71),				/* Time file was generated */
  1    12     2 dreset fixed bin (71),				/* Time of disk reset */
  1    13     2 dpad2 (2) fixed bin,
  1    14     2 dtab (1000),					/* one for each dir with a quota */
  1    15       3 spth char (168),				/* path name */
  1    16       3 sqta fixed bin,				/* segment quota */
  1    17       3 dqta fixed bin,				/* directory quota */
  1    18       3 suse fixed bin,				/* segment pages qued */
  1    19       3 duse fixed bin,				/* directory pages used */
  1    20       3 stpp fixed bin (71),				/* time-page product for segments */
  1    21       3 dtpp fixed bin (71),				/* time-page product for directories */
  1    22       3 slvid bit (36),				/* son's lvid of this dir */
  1    23       3 slev fixed bin;				/* recursion level */
  1    24 
  1    25 dcl  lodh fixed bin init (8),				/* lth of disk_stat head */
  1    26      lode fixed bin init (52);			/* lth of disk_stat entry */
  1    27 
  1    28 /* END INCLUDE FILE ... disk_stat.incl.pl1 */
      573 
      574 
  2     1 /* BEGIN INCLUDE FILE ... pdt.incl.pl1 */
  2     2 /* Requires user_attributes.incl.pl1 */
  2     3 
  2     4 /* Modified 740723 by PG to add AIM info */
  2     5 /* Modified 750604 by T. Casey to add priority scheduler parameters */
  2     6 /* Modified May 1976 by T. Casey to add cutoff warning thresholds and change version to 3 */
  2     7 /* Modified May 1977 by John Gintell to add reqfile, projfile, and SAT to header */
  2     8 /* Modified May 1978 by T. Casey to add pdir_quota to user entry */
  2     9 /* Modified June 1978 by T. Casey to add rel ptr to pdt hash table */
  2    10 /* Modified November 1978 by T. Casey to add max_(fore back)ground, n_(fore back)ground and abs_foreground_cpu_limit */
  2    11 /* Modified October 1979 by T. Casey to add counters for interactive and disconnected processes. */
  2    12 /* Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures (UNCA). */
  2    13 /* Modified May 1980 by R. McDonald to use iod cpu time field for page charging (UNCA) */
  2    14 /* Modified December 1981 by E. N. Kittlitz for user_warn fields */
  2    15 /* Modified January 1982 by E. N. Kittlitz for user_attributes.incl.pl1 changes */
  2    16 /* Modified September 1982 by E. N. Kittlitz for default ring. */
  2    17 /* Modified 1984-07-05 BIM for min authorization, version to 4 */
  2    18 
  2    19 dcl (PDT_version init (4),				/* version of this declaration */
  2    20      PDT_header_lth init (256),			/* length in words of PDT head */
  2    21      PDT_entry_lth init (256),			/* length in words of PDT entry */
  2    22 
  2    23      PDT_project_name_length init (9),			/* proper length of pdt.project_name */
  2    24      PDT_person_id_length init (22)			/* proper length of user.person_id */
  2    25      ) fixed bin internal static options (constant);
  2    26 
  2    27 dcl 1 pdt based (pdtp) aligned,
  2    28 
  3     1 /* BEGIN INCLUDE FILE author.incl.pl1 */
  3     2 
  3     3 /* the "author" items must always be the first ones in the table. The
  3     4*   module which moves the converted table to the System Control process
  3     5*   fills in these data items and assumes them to be at the head of the segment
  3     6*   regardless of the specific table's actual declaration. The variables
  3     7*   "lock" and "last_install_time" used to be "process_id" and "ev_channel"
  3     8*    respectively. For tables installed in multiple processes, these
  3     9*    are to be used to lock out multiple installations. */
  3    10 
  3    11 /*  Lock should be used as a modification lock. Since, in general,
  3    12*    entries may not be moved in system tables, even by installations,
  3    13*    it is sufficient for only installers and programs that change threads
  3    14*    to set or respect the lock. Simply updating data in an entry
  3    15*    requires no such protection.
  3    16*
  3    17*    Last_install_time is used by readers of system tables to detect
  3    18*    installations or other serious modifications. By checking it before
  3    19*    and after copying a block of data, they can be protected against
  3    20*    modifications.
  3    21*
  3    22*    Modules that set the lock should save proc_group_id, and then
  3    23*    put their group id there for the time they hold the lock.
  3    24*    if they do not actually install the, they should restore the group id.
  3    25**/
  3    26 
  3    27     2 author aligned,				/* validation data about table's author */
  3    28       3 proc_group_id char (32),			/* process-group-id  (personid.projectid.tag) */
  3    29       3 lock bit (36),				/* installation lock */
  3    30       3 update_attributes bit (1) unal,			/* update/add/delete attributes */
  3    31       3 update_authorization bit (1) unal,		/* update only authorizations */
  3    32       3 deferral_notified bit (1) unal,			/* installer notified of deferral of installation */
  3    33       3 pad bit (33) unaligned,
  3    34       3 last_install_time fixed bin (71),
  3    35       3 table char (4),				/* name of table, e.g., SAT MGT TTT RTDT PDT etc. */
  3    36       3 w_dir char (64),				/* author's working directory */
  3    37 
  3    38 /* END INCLUDE FILE author.incl.pl1 */
  2    29 
  2    30     2 max_size fixed bin,				/* max number of entries table can grow */
  2    31     2 current_size fixed bin,				/* current size of table (in entries) */
  2    32     2 version fixed bin,				/* table version */
  2    33     2 freep fixed bin,				/* relptr to begin of free chain */
  2    34     2 n_users fixed bin,				/* number of entries actually used */
  2    35     2 project_name char (28),				/* name of project */
  2    36     2 project_dir char (64),				/* treename of project's directory */
  2    37     2 projfile_version fixed bin,
  2    38     2 projentry bit (66*36),
  2    39     2 pad3 (5) bit (36) aligned,
  2    40     2 reqfile_version fixed bin,
  2    41     2 reqentry bit (40*36),
  2    42     2 pad4 (9) fixed bin,
  2    43     2 sat_version fixed bin,
  2    44     2 satentry bit (52*36),				/* everything in sat.project from project.at on */
  2    45     2 pad5 (4) bit (36) aligned,
  2    46     2 date_reqfile_copied fixed bin (71),
  2    47     2 rs_number fixed bin (9) unsigned unaligned,		/* rate structure number, easier than looking in satentry */
  2    48     2 pad2l bit (27) unaligned,
  2    49     2 pad2 (16) fixed bin,				/* make header 256 words long */
  2    50     2 ht_relp fixed bin (18) aligned,			/* if nonzero, pdt has hash table at that loc */
  2    51     2 user (1019) aligned,				/* the project definition table entries */
  2    52       3 pad (256) bit (36) aligned;			/* each entry is 256 words long  */
  2    53 
  2    54 /* The hash table, if there is one, is right after the last user, and is described in hashst.incl.pl1 */
  2    55 
  2    56 
  2    57 
  2    58 dcl 1 user based (pdtep) aligned,			/* declaration of a single PDT entry  */
  2    59     2 state fixed bin,				/* 1 = normal, 2 = deleted 0 = free */
  2    60     2 lock bit (36),				/* update lock */
  2    61     2 person_id char (24) aligned,			/* login name of user */
  2    62     2 now_in fixed bin,				/* count of users logged in on this entry */
  2    63     2 password char (8) aligned,			/* password for anonymous user */
  2    64     2 at like user_attributes aligned,			/* include user_attributes.incl.pl1 */
  2    65     2 initial_procedure char (64) aligned,		/* initproc and subsystem name packed into one string */
  2    66     2 home_dir char (64) aligned,			/* user's default working directory */
  2    67     2 bump_grace fixed bin,				/* number of minutes he is protected */
  2    68     2 high_ring fixed bin,				/* highest ring user may use */
  2    69     2 default_ring fixed bin (17) unal,			/* ring user will start in */
  2    70     2 low_ring fixed bin (17) unal,			/* lowest ring user may use */
  2    71     2 outer_module char (32),				/* outer module used if user is interactive */
  2    72     2 lot_size fixed bin,				/* size of linkage offset table */
  2    73     2 kst_size fixed bin,				/* size of known segment table */
  2    74     2 cls_size fixed bin,				/* size of combined linkage */
  2    75     2 uflags,					/* various flags */
  2    76       3 dont_call_init_admin bit (1) unal,		/* call overseer direct */
  2    77       3 ip_given bit (1) unal,			/* ip_len gives length of initproc packed in initial_procedure */
  2    78       3 ss_given bit (1) unal,			/* subsystem name is packed in initial_procedure */
  2    79       3 flagpad bit (33) unal,
  2    80     2 ip_len fixed bin (17) unal,			/* length of initproc name packed in initial_procedure */
  2    81     2 ss_len fixed bin (17) unal,			/* length of subsystem name packed in initial_procedure */
  2    82     2 dollar_limit float bin,
  2    83     2 dollar_charge float bin,			/* total dollars spent this month */
  2    84     2 shift_limit (0: 7) float bin,
  2    85     2 daton fixed bin (71),				/* date user added to system */
  2    86     2 datof fixed bin (71),				/* date user deleted */
  2    87     2 last_login_time fixed bin (71),			/* time of last login */
  2    88     2 last_login_unit char (4),			/* terminal id last used */
  2    89     2 last_login_type fixed bin (17) unal,		/* terminal type */
  2    90     2 last_login_line_type fixed bin (17) unal,		/* terminal line type */
  2    91     2 time_last_bump fixed bin (71),			/* for bump-wait */
  2    92     2 last_update fixed bin (71),			/* time of last transaction */
  2    93     2 logins fixed bin,				/* number of logins */
  2    94     2 crashes fixed bin,				/* sessions abnormally terminated */
  2    95     2 interactive (0: 7),				/* interactive use, shifts 0-7 */
  2    96       3 charge float bin,				/* total dollar charge this shift */
  2    97       3 xxx fixed bin,
  2    98       3 cpu fixed bin (71),				/* cpu usage in microseconds */
  2    99       3 core fixed bin (71),				/* core demand in page-microseconds */
  2   100       3 connect fixed bin (71),			/* total console time in microseconds */
  2   101       3 io_ops fixed bin (71),			/* total i/o ops on terminal */
  2   102     2 absentee (4),					/* absentee use, queues 1-4 */
  2   103       3 charge float bin,				/* dollar charge this queue */
  2   104       3 jobs fixed bin,				/* number of jobs submitted */
  2   105       3 cpu fixed bin (71),				/* total cpu time in microseconds */
  2   106       3 memory fixed bin (71),			/* total memory demand */
  2   107     2 iod (4),					/* io daemon use, queues 1-4 */
  2   108       3 charge float bin,				/* dollar charge this queue */
  2   109       3 pieces fixed bin,				/* pieces of output requested */
  2   110       3 pad fixed bin (35),
  2   111       3 pages fixed bin (35),				/* number of pages output */
  2   112       3 lines fixed bin (71),				/* total record count of output */
  2   113     2 devices (16) float bin,				/* device charges */
  2   114     2 time_last_reset fixed bin (71),			/* time PDT last updated */
  2   115     2 absolute_limit float bin,			/* Limit, not reset monthly */
  2   116     2 absolute_spent float bin,			/* Spending against this */
  2   117     2 absolute_cutoff fixed bin (71),			/* Spending will be reset on this date */
  2   118     2 absolute_increm fixed bin,			/* .. time increment code. 0 = don't reset */
  2   119     2 pad_was_authorization bit (72) aligned,
  2   120     2 group char (8),				/* group for this user (if at.igroup = "1"b) */
  2   121     2 warn_days fixed bin (17) unaligned,		/* warn user if less than this many days to cutoff */
  2   122     2 warn_pct fixed bin (17) unaligned,		/* warn user if less than this percent of funds left */
  2   123     2 warn_dollars float bin,				/* warn user if less than this amount of funds left */
  2   124     2 n_foreground fixed bin (9) unsigned unaligned,	/* number of foreground and background processes */
  2   125     2 n_background fixed bin (9) unsigned unaligned,	/* that this user has. see limits just below */
  2   126     2 max_foreground fixed bin (9) unsigned unaligned,	/* max simultaneous foreground and */
  2   127     2 max_background fixed bin (9) unsigned unaligned,	/* background processes that this user can have */
  2   128     2 n_interactive fixed bin (9) unsigned unaligned,	/* number of interactive processes that user has */
  2   129     2 n_disconnected fixed bin (9) unsigned unaligned,	/* number of disconnected processes that user has */
  2   130     2 pdtupad1 fixed bin (18) unsigned unaligned,
  2   131     2 user_warn_days fixed bin (17) unaligned,		/* warn user if less than this many days to user cutoff */
  2   132     2 user_warn_pct fixed bin (17) unaligned,		/* warn user if less than this percent of user funds left */
  2   133     2 user_warn_dollars float bin,			/* warn user if less than this amount of user funds left */
  2   134     2 user_authorization (2) bit (72) aligned,		/* range */
  2   135     2 pdtupad (5) fixed bin,
  2   136     2 abs_foreground_cpu_limit fixed bin (17) unaligned,	/* time limit (sec) on foreground absentee jobs */
  2   137     2 pdir_quota fixed bin (17) unaligned,		/* quota to put on user's pdir (0 => use default) */
  2   138     2 chain fixed bin;				/* free chain */
  2   139 
  2   140 /* END INCLUDE FILE ... pdt.incl.pl1 */
      575 
      576 
  4     1 /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
  4     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
  4     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
  4     8*     attribute switches.
  4     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  4    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
  4    12*         be deleted.
  4    13*      B) Add constants identifying attributes that can be changed by user at
  4    14*         login, etc.
  4    15*                                                   END HISTORY COMMENTS */
  4    16 
  4    17 
  4    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
  4    19 
  4    20 /* format: style4 */
  4    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
  4    22        (2 administrator bit (1),			/* 1  system administrator privileges */
  4    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
  4    24        2 nobump bit (1),				/* 2  user cannot be bumped */
  4    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
  4    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
  4    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
  4    28*						   .  of same project (distinct from "nobump") */
  4    29        2 nolist bit (1),				/* 7  don't list user on "who" */
  4    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
  4    31        2 multip bit (1),				/* 9  user may have several processes */
  4    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
  4    33        2 brief bit (1),				/* 11 no login or logout message */
  4    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
  4    35        2 vhomedir bit (1),				/* 13 user may change homedir */
  4    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
  4    37        2 sb_ok bit (1),				/* 15 user may be standby */
  4    38        2 pm_ok bit (1),				/* 16 user may be primary */
  4    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
  4    40        2 daemon bit (1),				/* 18 user may login as daemon */
  4    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
  4    42        2 no_warning bit (1),				/* 20 no warning message */
  4    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
  4    44*						   .  in PDT: this user has an individual load control group */
  4    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
  4    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
  4    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
  4    48        2 pad bit (12)) unaligned;
  4    49 
  4    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  4    51     ("none",					/* 0 */
  4    52      "administrator",				/* 1 */
  4    53      "primary_line",				/* 2 */
  4    54      "nobump",					/* 3 */
  4    55      "guaranteed_login",				/* 4 */
  4    56      "anonymous",					/* 5 */
  4    57      "nopreempt",					/* 6 */
  4    58      "nolist",					/* 7 */
  4    59      "dialok",					/* 8 */
  4    60      "multip",					/* 9 */
  4    61      "bumping",					/* 10 */
  4    62      "brief",					/* 11 */
  4    63      "vinitproc",					/* 12 */
  4    64      "vhomedir",					/* 13 */
  4    65      "nostartup",					/* 14 */
  4    66      "no_secondary",				/* 15 */
  4    67      "no_prime",					/* 16 */
  4    68      "no_eo",					/* 17 */
  4    69      "daemon",					/* 18 */
  4    70      "",						/* 19 vdim OBSOLETE */
  4    71      "no_warning",					/* 20 */
  4    72      "igroup",					/* 21 */
  4    73      "save_pdir",					/* 22 */
  4    74      "disconnect_ok",				/* 23 */
  4    75      "save_on_disconnect");				/* 24 */
  4    76 
  4    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  4    78     ("null",					/* 0 */
  4    79      "admin",					/* 1 */
  4    80      "", "",					/* 2 - 3 */
  4    81      "guar",					/* 4 */
  4    82      "anon",					/* 5 */
  4    83      "", "",					/* 6 - 7 */
  4    84      "dial",					/* 8 */
  4    85      "multi_login",					/* 9 */
  4    86      "preempting",					/* 10 */
  4    87      "",						/* 11 */
  4    88      "v_process_overseer",				/* 12 */
  4    89      "v_home_dir",					/* 13 */
  4    90      "no_start_up",					/* 14 */
  4    91      "no_sec",					/* 15 */
  4    92      "no_primary",					/* 16 */
  4    93      "no_edit_only",				/* 17 */
  4    94      "op_login",					/* 18 */
  4    95      "",						/* 19 */
  4    96      "nowarn",					/* 20 */
  4    97      "", "", "",					/* 21 - 23 */
  4    98      "save");					/* 24 */
  4    99 
  4   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
  4   101      options(constant) init("000000000010000000010000000000000000"b);
  4   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
  4   103 
  4   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
  4   105      options(constant) init("000000000010000000010000000000000000"b);
  4   106     /* PDT value for (brief, no_warning) is default */
  4   107 
  4   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
  4   109      options(constant) init("000100000110010000010000000000000000"b);	
  4   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
  4   111 
  5     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  5     2 
  5     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 /*							       */
  5     5 /* This include file describes the attributes of an absentee job.  It is     */
  5     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
  5     7 /* and PIT.incl.pl1.   */
  5     8 /*							       */
  5     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    10 
  5    11 /****^  HISTORY COMMENTS:
  5    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  5    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  5    14*     Separated abs_attributes from the request structure
  5    15*     (abs_message_format.incl.pl1) so that the identical structure could be
  5    16*     used in the ute structure (user_table_entry.incl.pl1).
  5    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  5    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  5    19*     Added ABS_ATTRIBUTE_NAMES array.
  5    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  5    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  5    22*     Added the no_start_up flag. SCP6367
  5    23*                                                   END HISTORY COMMENTS */
  5    24 
  5    25 dcl 1 user_abs_attributes		aligned based,
  5    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
  5    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
  5    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
  5    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
  5    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
  5    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
  5    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
  5    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
  5    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
  5    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
  5    36       2 attributes_pad		bit (26) unaligned;
  5    37 
  5    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
  5    39 	"restartable",
  5    40 	"user_deferred_until_time",
  5    41 	"proxy",
  5    42 	"set_bit_cnt",
  5    43 	"time_in_gmt",
  5    44 	"user_deferred_indefinitely",
  5    45 	"secondary_ok",
  5    46 	"truncate_absout",
  5    47 	"restarted",
  5    48 	"no_start_up");
  5    49 
  5    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  5    51 
  4   112 
  4   113 
  4   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      577 
      578 
      579      end disk_stat_print;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/13/88  0941.0  disk_stat_print.pl1               >special_ldd>install>MR12.2-1047>disk_stat_print.pl1
573          1    06/22/76  1355.6  disk_stat.incl.pl1                >ldd>include>disk_stat.incl.pl1
575          2    09/13/84  0921.6  pdt.incl.pl1                      >ldd>include>pdt.incl.pl1
2-29         3    04/21/82  1211.8  author.incl.pl1                   >ldd>include>author.incl.pl1
577          4    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
4-112        5    07/13/88  0900.1  user_abs_attributes.incl.pl1      >special_ldd>install>MR12.2-1047>user_abs_attributes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ROOT                            000133 automatic       fixed bin(17,0)          dcl 91 set ref 302* 303 313 327 422 422 422 422 422
                                                                                  422 422 422 427 427 427 427 427 427 427 427
acpx                            000112 automatic       fixed bin(17,0)          dcl 85 set ref 248* 408* 408 409
addr                                                   builtin function         dcl 165 ref 230 230 230 230
after                                                  builtin function         dcl 165 ref 534 543
al                              000113 automatic       fixed bin(17,0)          dcl 85 set ref 182* 186 188 188 191 191 194 194 194
                                                                                  194 194 200 200 202* 208 208 211 223 230* 236
an                              000114 automatic       fixed bin(17,0)          dcl 85 set ref 180* 182* 201* 201 202*
ap                              000656 automatic       pointer                  dcl 149 set ref 182* 186 188 188 191 191 194 194 194
                                                                                  194 194 200 200 202* 208 211 223 230* 236
bad_lvid_code                   000111 automatic       fixed bin(35,0)          initial dcl 83 set ref 83* 374 374* 416*
bchr                                   based           char                     packed unaligned dcl 154 set ref 186 188 188 191 191
                                                                                  194 194 194 194 194 200 200 208* 211 223 236
before                                                 builtin function         dcl 165 ref 535 544 555
code                            000110 automatic       fixed bin(35,0)          initial dcl 83 set ref 83* 176* 180 182* 184 202*
                                                                                  203 208* 209 210* 222* 230* 231 235* 243* 244 245*
                                                                                  249* 250 255* 262* 263 268* 274* 275 370* 371 374
                                                                                  450* 451* 547* 548 550 550*
com_err_                        000224 constant        entry                    external dcl 50 ref 245 255 416 456 550 561 563
coxx                            000316 automatic       char(64)                 packed unaligned dcl 107 set ref 285* 286*
cp_array                        000644 automatic       pointer                  array dcl 119 set ref 249* 254 259 409
cpx                             000115 automatic       fixed bin(17,0)          dcl 85 set ref 248* 249* 249 251* 251
cu_$arg_ptr                     000226 constant        entry                    external dcl 51 ref 182 202
cv_$mwvf                        000232 constant        entry                    external dcl 53 ref 422 422 422 422 427 427 437 437
                                                                                  500 500 500 500 515 515 515 515
cv_dec_check_                   000230 constant        entry                    external dcl 52 ref 208
date_time_                      000234 constant        entry                    external dcl 54 ref 288 290
dcharge                   6     000433 automatic       float bin(27)            array level 2 dcl 115 set ref 360* 422* 422* 427 427
                                                                                  469* 469 469 500* 500* 515* 515*
dents                                  based           fixed bin(17,0)          level 2 dcl 1-8 ref 308 407
dir_formats                     000010 internal static char(36)                 initial array packed unaligned dcl 124 set ref 500*
                                                                                  515*
disk_price                      000160 automatic       float bin(27)            array dcl 101 set ref 261 263* 263 264* 360 361 388
                                                                                  393
disk_stat                              based           structure                level 1 dcl 1-8
dlev                            000116 automatic       fixed bin(17,0)          dcl 85 set ref 303* 316 316* 327 348* 354 356 357
                                                                                  358 359 360 361 362 397
dn                              000244 automatic       char(168)                initial packed unaligned dcl 106 set ref 106* 230
                                                                                  230 243* 293* 492 497*
dpxx                            000336 automatic       char(64)                 packed unaligned dcl 107 set ref 285* 286*
dqta                     63            based           fixed bin(17,0)          array level 3 dcl 1-8 ref 356 394
dquota                          000433 automatic       fixed bin(17,0)          array level 2 dcl 115 set ref 356* 422* 427 465* 465
                                                                                  465 500* 515*
dreset                    4            based           fixed bin(71,0)          level 2 dcl 1-8 ref 289
dsix                      5     000433 automatic       fixed bin(17,0)          array level 2 dcl 115 set ref 362* 486 488 497 515
dtab                     10            based           structure                array level 2 dcl 1-8
dtime                     2            based           fixed bin(71,0)          level 2 dcl 1-8 ref 287
dtpp                     70            based           fixed bin(71,0)          array level 3 dcl 1-8 ref 360 393
dummy                           000147 automatic       float bin(27)            array dcl 99 set ref 264* 264* 264* 264*
dummy1                          000157 automatic       float bin(27)            dcl 100 set ref 264*
duse                     65            based           fixed bin(17,0)          array level 3 dcl 1-8 ref 358 395
dused                     1     000433 automatic       fixed bin(17,0)          array level 2 dcl 115 set ref 358* 422* 427 466* 466
                                                                                  466 500* 515*
dvolx                     4     000433 automatic       fixed bin(17,0)          array level 2 dcl 115 set ref 397* 474 474 474* 500*
                                                                                  515*
ec                              001010 automatic       fixed bin(35,0)          dcl 532 set ref 556* 563*
en                              000356 automatic       char(32)                 initial packed unaligned dcl 108 set ref 108* 204*
                                                                                  211* 216* 223* 230 230 236* 243* 255* 270*
errmsg                          000412 automatic       varying char(64)         dcl 111 set ref 456*
error_table_$bad_arg            000306 external static fixed bin(35,0)          dcl 169 ref 235
error_table_$badopt             000304 external static fixed bin(35,0)          dcl 169 ref 222
error_table_$noentry            000310 external static fixed bin(35,0)          dcl 169 ref 550
expand_path_                    000236 constant        entry                    external dcl 55 ref 230
fcbp                            000660 automatic       pointer                  dcl 149 set ref 178* 243* 249* 446 446*
fmt_ix                          000131 automatic       fixed bin(17,0)          initial dcl 89 set ref 89* 197* 297 299 419 422 427
                                                                                  500 514 515 519
get_wdir_                       000240 constant        entry                    external dcl 56 ref 106
hbound                                                 builtin function         dcl 165 ref 261
hcs_$initiate                   000246 constant        entry                    external dcl 59 ref 556
hcs_$make_seg                   000250 constant        entry                    external dcl 60 ref 268
hcs_$terminate_noname           000252 constant        entry                    external dcl 61 ref 451
hcs_$truncate_seg               000254 constant        entry                    external dcl 62 ref 274 450
heading_dashes                  000032 internal static char(99)                 initial array packed unaligned dcl 128 set ref 299*
                                                                                  419* 514* 519*
heading_words                   000114 internal static char(72)                 initial array packed unaligned dcl 132 set ref 297*
i                               000117 automatic       fixed bin(17,0)          dcl 85 in procedure "dsp" set ref 309* 313 315 316
                                                                                  350 355* 356 357 358 359 360 361 362 365 370 383
                                                                                  388 389 390 393 394 395 402 406* 435* 437 437 437
                                                                                  437 437 437 437* 437*
i                                      parameter       fixed bin(17,0)          dcl 529 in procedure "set_disk_price_index" ref 526
                                                                                  534
ioa_                            000256 constant        entry                    external dcl 63 ref 286 291 297 299 419 422 427 433
                                                                                  437 500 514 515 519 520
j                               000120 automatic       fixed bin(17,0)          dcl 85 set ref 490* 491 492 492 492*
k                               000121 automatic       fixed bin(17,0)          dcl 85 set ref 489* 492* 495
l                                      parameter       fixed bin(17,0)          dcl 512 in procedure "print_subtot_line" set ref 510
                                                                                  515 515 515 515 515 515 515 515 515* 515 515
l                                      parameter       fixed bin(17,0)          dcl 484 in procedure "print_dir_line" set ref 482
                                                                                  486 488 497 500 500 500 500 500 500 500 500 500*
                                                                                  500
l                                      parameter       fixed bin(17,0)          dcl 462 in procedure "add_up_subtot" ref 460 465 465
                                                                                  466 466 467 467 468 468 469 469 470 470 474 474
last_dent                       000146 automatic       fixed bin(17,0)          dcl 95 set ref 308* 309 313 350 407*
ll                                     parameter       fixed bin(17,0)          dcl 462 ref 460 465 466 467 468 469 470 474
lode                            000671 automatic       fixed bin(17,0)          initial dcl 1-25 set ref 402 1-25*
lodh                            000670 automatic       fixed bin(17,0)          initial dcl 1-25 set ref 402 1-25*
lv_id                    11            based           bit(36)                  array level 2 dcl 156 set ref 365 383*
lv_name                                based           char(32)                 array level 2 dcl 156 set ref 277* 279* 370* 378
                                                                                  437*
lv_quota                 12            based           fixed bin(17,0)          array level 2 dcl 156 set ref 389* 389 394* 394 437
                                                                                  437*
lv_totals                              based           structure                array level 1 dcl 156
lv_tpp                   10            based           float bin(27)            array level 2 dcl 156 set ref 388* 388 393* 393 437*
                                                                                  437*
lv_used                  13            based           fixed bin(17,0)          array level 2 dcl 156 set ref 390* 390 395* 395 437*
lvix                            000126 automatic       fixed bin(17,0)          dcl 88 set ref 365* 365* 369 370 372* 378 378* 381
                                                                                  383 388 388 389 389 390 390 397
lvl                             000122 automatic       fixed bin(17,0)          dcl 85 set ref 327* 327* 330 330* 332 333 333 337
                                                                                  337*
lvtp                            000662 automatic       pointer                  dcl 149 set ref 268* 269 274* 277 279 365 370 378
                                                                                  383 388 388 389 389 390 390 393 393 394 394 395
                                                                                  395 437 437 437 437 437 437 450* 451*
maxlev                          000132 automatic       fixed bin(17,0)          initial dcl 90 set ref 90* 208* 215 215 316 316 332
                                                                                  333 333
mdc_$find_lvname                000260 constant        entry                    external dcl 64 ref 370
msf                             000100 automatic       bit(1)                   initial dcl 78 set ref 78* 344 403* 405*
msf_manager_$close              000262 constant        entry                    external dcl 65 ref 446
msf_manager_$get_ptr            000264 constant        entry                    external dcl 66 ref 249
msf_manager_$open               000266 constant        entry                    external dcl 67 ref 243
n_bad_lvids                     000125 automatic       fixed bin(17,0)          initial dcl 87 set ref 87* 373* 373 416 416*
nlv                             000127 automatic       fixed bin(17,0)          dcl 88 set ref 281* 365 369 381* 435
no_sat                          000101 automatic       bit(1)                   initial dcl 78 set ref 78* 547 548 561 566*
null                                                   builtin function         dcl 165 ref 177 178 229 254 269 446 557
nxtlev                          000123 automatic       fixed bin(17,0)          dcl 85 set ref 313* 315* 316 327 333 337 348
old_project_entry               000366 automatic       char(32)                 initial packed unaligned dcl 109 set ref 109* 540*
                                                                                  545 546*
path                            000736 automatic       char(168)                packed unaligned dcl 531 in procedure
                                                                                  "set_disk_price_index" set ref 534* 535 543* 543
                                                                                  544
path                            000172 automatic       char(168)                packed unaligned dcl 105 in procedure "dsp" set ref
                                                                                  486* 488* 491 492 495* 500*
pdt                                    based           structure                level 1 dcl 2-27
pdtp                            000664 automatic       pointer                  dcl 149 set ref 556* 557 557
project_entry                   000726 automatic       char(32)                 packed unaligned dcl 530 set ref 535* 536 536 536
                                                                                  544* 545 546 547* 550* 555* 555 556* 561* 563*
root_lvix                       000130 automatic       fixed bin(17,0)          dcl 88 set ref 280* 393 393 394 394 395 395
rs_count                        000145 automatic       fixed bin(17,0)          dcl 94 set ref 174* 354 453
rs_name                         000134 automatic       char(32)                 packed unaligned dcl 92 set ref 262* 560* 563*
rs_number                              parameter       fixed bin(17,0)          dcl 528 in procedure "set_disk_price_index" set ref
                                                                                  526 539* 547* 549* 557* 559*
rs_number               356            based           fixed bin(9,0)           level 2 in structure "pdt" packed packed unsigned
                                                                                  unaligned dcl 2-27 in procedure "dsp" ref 557
rs_number                       000144 automatic       fixed bin(17,0)          dcl 93 in procedure "dsp" set ref 261* 262* 263 264*
                                                                                  264* 354* 355* 360 361 388 393
scharge                   7     000433 automatic       float bin(27)            array level 2 dcl 115 set ref 361* 422* 422* 427 427
                                                                                  470* 470 470 500* 500* 515* 515*
search_sat_$clean_up            000244 constant        entry                    external dcl 58 ref 453
search_sat_$rs_number           000242 constant        entry                    external dcl 57 ref 547
slev                     73            based           fixed bin(17,0)          array level 3 dcl 1-8 ref 302 315
slvid                    72            based           bit(36)                  array level 3 dcl 1-8 set ref 365 370* 383
sp                              000666 automatic       pointer                  dcl 1-6 set ref 177* 229 259* 287 289 302 308 315
                                                                                  356 357 358 359 360 361 365 370 383 388 389 390
                                                                                  393 394 395 407 409* 486 488 497 515 534
spth                     10            based           char(168)                array level 3 dcl 1-8 set ref 486 488 497 515* 534
sqta                     62            based           fixed bin(17,0)          array level 3 dcl 1-8 ref 357 389
squota                    2     000433 automatic       fixed bin(17,0)          array level 2 dcl 115 set ref 357* 422* 427 467* 467
                                                                                  467 500* 515*
stpp                     66            based           fixed bin(71,0)          array level 3 dcl 1-8 ref 361 388
sub_total_formats               000160 internal static char(32)                 initial array packed unaligned dcl 136 set ref 422*
substr                                                 builtin function         dcl 165 set ref 186 491 492 492 495*
subtot                          000433 automatic       structure                array level 1 unaligned dcl 115
subtot_sw                       000102 automatic       bit(1)                   initial dcl 78 set ref 78* 191* 337
suse                     64            based           fixed bin(17,0)          array level 3 dcl 1-8 ref 359 390
sused                     3     000433 automatic       fixed bin(17,0)          array level 2 dcl 115 set ref 359* 422* 427 468* 468
                                                                                  468 500* 515*
sys_info$max_seg_size           000312 external static fixed bin(35,0)          dcl 170 ref 402
system_info_$max_rs_number      000300 constant        entry                    external dcl 73 ref 174
system_info_$prices_rs          000276 constant        entry                    external dcl 71 ref 264
system_info_$rs_name            000274 constant        entry                    external dcl 70 ref 262
system_info_$titles             000302 constant        entry                    external dcl 74 ref 285
ti                              000124 automatic       fixed bin(17,0)          dcl 85 set ref 248* 406* 406 407
total_formats                   000200 internal static char(24)                 initial array packed unaligned dcl 140 set ref 427*
total_sw                        000103 automatic       bit(1)                   initial dcl 78 set ref 78* 188* 284 299 316 332 419
                                                                                  433
ttemp                           000106 automatic       fixed bin(71,0)          dcl 82 set ref 287* 288* 289* 290*
ttmp1                           000376 automatic       char(24)                 packed unaligned dcl 110 set ref 290* 291*
ttmp2                           000404 automatic       char(24)                 packed unaligned dcl 110 set ref 288* 291*
user_attributes                        based           structure                level 1 dcl 4-21
user_info_$rs_name              000272 constant        entry                    external dcl 69 ref 560
user_info_$rs_number            000270 constant        entry                    external dcl 68 ref 559
vol_format                      000214 internal static char(26)                 initial packed unaligned dcl 144 set ref 437*
volume_sw                       000104 automatic       bit(1)                   initial dcl 78 set ref 78* 196* 267 364 435 449

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 5-38
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 4-77
PDT_entry_lth                          internal static fixed bin(17,0)          initial dcl 2-19
PDT_header_lth                         internal static fixed bin(17,0)          initial dcl 2-19
PDT_person_id_length                   internal static fixed bin(17,0)          initial dcl 2-19
PDT_project_name_length                internal static fixed bin(17,0)          initial dcl 2-19
PDT_version                            internal static fixed bin(17,0)          initial dcl 2-19
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 4-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 4-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 4-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 4-50
pdtep                                  automatic       pointer                  dcl 149
user                                   based           structure                level 1 dcl 2-58
user_abs_attributes                    based           structure                level 1 dcl 5-25

NAMES DECLARED BY EXPLICIT CONTEXT.
add_up_subtot                   002524 constant        entry                    internal dcl 460 ref 330
begin                           001431 constant        label                    dcl 309 ref 410
cpx_loop                        000762 constant        label                    dcl 249 ref 252
disk_stat_print                 000352 constant        entry                    external dcl 24
dsp                             000342 constant        entry                    external dcl 24
er                              001020 constant        label                    dcl 255 ref 205 212 217 224 231 237 271
err_finish                      002473 constant        label                    dcl 456
finish                          002421 constant        label                    dcl 446 ref 458
lv_er                           001201 constant        label                    dcl 270 ref 275
next_component                  002025 constant        label                    dcl 405 ref 344
print_dir_line                  002603 constant        entry                    internal dcl 482 ref 316 333
print_lev                       001455 constant        label                    dcl 316 ref 404
print_subtot_line               002773 constant        entry                    internal dcl 510 ref 337
set_disk_price_index            003160 constant        entry                    internal dcl 526 ref 355

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4202        4516    3660        4212
Length      5070    3660       314         336     322         214

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dsp                                 874 external procedure  is an external procedure.  
add_up_subtot                           internal procedure  shares stack frame of external procedure dsp.  
print_dir_line                          internal procedure  shares stack frame of external procedure dsp.  
print_subtot_line                       internal procedure  shares stack frame of external procedure dsp.  
set_disk_price_index                    internal procedure  shares stack frame of external procedure dsp.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dir_formats                 dsp
000032 heading_dashes              dsp
000114 heading_words               dsp
000160 sub_total_formats           dsp
000200 total_formats               dsp
000214 vol_format                  dsp

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dsp                      000100 msf                         dsp
                         000101 no_sat                      dsp
                         000102 subtot_sw                   dsp
                         000103 total_sw                    dsp
                         000104 volume_sw                   dsp
                         000106 ttemp                       dsp
                         000110 code                        dsp
                         000111 bad_lvid_code               dsp
                         000112 acpx                        dsp
                         000113 al                          dsp
                         000114 an                          dsp
                         000115 cpx                         dsp
                         000116 dlev                        dsp
                         000117 i                           dsp
                         000120 j                           dsp
                         000121 k                           dsp
                         000122 lvl                         dsp
                         000123 nxtlev                      dsp
                         000124 ti                          dsp
                         000125 n_bad_lvids                 dsp
                         000126 lvix                        dsp
                         000127 nlv                         dsp
                         000130 root_lvix                   dsp
                         000131 fmt_ix                      dsp
                         000132 maxlev                      dsp
                         000133 ROOT                        dsp
                         000134 rs_name                     dsp
                         000144 rs_number                   dsp
                         000145 rs_count                    dsp
                         000146 last_dent                   dsp
                         000147 dummy                       dsp
                         000157 dummy1                      dsp
                         000160 disk_price                  dsp
                         000172 path                        dsp
                         000244 dn                          dsp
                         000316 coxx                        dsp
                         000336 dpxx                        dsp
                         000356 en                          dsp
                         000366 old_project_entry           dsp
                         000376 ttmp1                       dsp
                         000404 ttmp2                       dsp
                         000412 errmsg                      dsp
                         000433 subtot                      dsp
                         000644 cp_array                    dsp
                         000656 ap                          dsp
                         000660 fcbp                        dsp
                         000662 lvtp                        dsp
                         000664 pdtp                        dsp
                         000666 sp                          dsp
                         000670 lodh                        dsp
                         000671 lode                        dsp
                         000726 project_entry               set_disk_price_index
                         000736 path                        set_disk_price_index
                         001010 ec                          set_disk_price_index

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_ptr                   cv_$mwvf                      cv_dec_check_
date_time_                    expand_path_                  get_wdir_                     hcs_$initiate
hcs_$make_seg                 hcs_$terminate_noname         hcs_$truncate_seg             ioa_
mdc_$find_lvname              msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
search_sat_$clean_up          search_sat_$rs_number         system_info_$max_rs_number    system_info_$prices_rs
system_info_$rs_name          system_info_$titles           user_info_$rs_name            user_info_$rs_number

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$noentry          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     78 000302        83 000307        87 000311        89 000312        90 000314       106 000316       108 000325
    109 000330    1   25 000333        24 000341       174 000360       176 000367       177 000370       178 000372
    180 000373       182 000400       184 000415       186 000417       188 000424       191 000440       194 000453
    196 000477       197 000501       198 000503       200 000504       201 000514       202 000515       203 000532
    204 000534       205 000537       208 000540       209 000565       210 000567       211 000570       212 000606
    215 000610       216 000614       217 000617       219 000620       222 000621       223 000624       224 000627
    227 000630       229 000631       230 000635       231 000660       232 000662       235 000663       236 000666
    237 000672       241 000673       243 000675       244 000722       245 000724       246 000756       248 000757
    249 000762       250 001010       251 001012       252 001013       254 001014       255 001020       256 001047
    259 001050       261 001052       262 001057       263 001100       264 001106       265 001127       267 001131
    268 001133       269 001175       270 001201       271 001204       274 001205       275 001221       277 001223
    279 001227       280 001232       281 001234       284 001235       285 001241       286 001255       287 001302
    288 001305       289 001322       290 001325       291 001342       293 001365       297 001370       299 001403
    302 001422       303 001425       308 001427       309 001431       313 001441       315 001450       316 001455
    327 001472       330 001503       332 001507       333 001515       337 001531       343 001543       344 001546
    348 001550       350 001552       354 001555       355 001564       356 001566       357 001577       358 001601
    359 001603       360 001605       361 001613       362 001620       364 001622       365 001624       367 001644
    369 001646       370 001652       371 001706       372 001710       373 001712       374 001713       376 001717
    378 001720       381 001732       383 001734       388 001743       389 001762       390 001764       393 001766
    394 001777       395 002001       397 002003       402 002010       403 002022       404 002024       405 002025
    406 002026       407 002030       408 002033       409 002034       410 002040       412 002041       416 002043
    419 002103       422 002124       427 002224       433 002306       435 002315       437 002327       443 002417
    446 002421       449 002434       450 002436       451 002452       453 002463       455 002472       456 002473
    458 002523       460 002524       465 002526       466 002535       467 002544       468 002553       469 002562
    470 002573       474 002576       477 002602       482 002603       486 002605       489 002616       490 002617
    491 002625       492 002631       494 002636       495 002640       497 002644       500 002657       505 002772
    510 002773       514 002775       515 003013       519 003136       520 003152       522 003157       526 003160
    534 003162       535 003212       536 003222       539 003236       540 003237       541 003242       543 003243
    544 003261       545 003271       546 003276       547 003301       548 003325       549 003331       550 003333
    555 003375       556 003417       557 003465       559 003477       560 003507       561 003520       563 003562
    566 003623       569 003625


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
