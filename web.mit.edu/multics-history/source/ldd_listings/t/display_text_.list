	COMPILATION LISTING OF SEGMENT display_text_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1613.7 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* program to display output text produced by pl/1
       12*
       13*   Initial Version: 17 October, 1968
       14*	Modified: 19 August 1972 by BLW
       15*	Modified:	20 February 1973 by RAB for multiple base-regs
       16*	Modified:	3 July 1973 by RAB for EIS	
       17*	Modified:	29 April 1974 by RAB for use with compare_object	
       18*	Modified: 2 May 1977 by SHW for new format operator_names_
       19**/
       20 
       21 display_text_: proc(t_pt,r_pt,delta,number,t_size,onp);
       22 
       23 dcl	t_pt	ptr,	/* points at text base */
       24 	r_pt	ptr,		/* points at relocation base */
       25 	delta	fixed bin,	/* offset of starting position */
       26 	number	fixed bin,	/* number to print */
       27 	t_size	fixed bin,	/* size of text */
       28 	onp	ptr;		/* pointer to appropriate operator name segment */
       29 
       30 dcl	(p,q,line_pt,pt) ptr,
       31 	(i,j,k,m,mop,n,save_k,irand,nrands,ndesc) fixed bin,
       32 	(fract_offset,offset,size,scale) fixed bin(18),
       33 	(ignore_ic_mod,double,eis,eis_desc,need_comma,ext_base,itag,has_ic,decimal) bit(1),
       34 	nl char(1) int static aligned init("
       35 "),
       36 	ht char(1) int static aligned init("	"),	/* tab */
       37 	htht char(2) int static aligned init("		"),	/* two tabs */
       38 	(c,c2) char(1),
       39 	cstring char(12),
       40 	op_code char(5),
       41 	tag char(3),
       42 	line char(256),
       43 	iox_$user_output ptr ext,
       44 	pl1_operator_names_$pl1_operator_names_ ext,
       45 	cobol_operator_names_$cobol_operator_names_ ext,
       46 	pl1_operators_$operator_table fixed bin ext,
       47 	binoct entry(aligned bit(*)) returns (char(12) aligned),
       48 	iox_$put_chars entry (ptr,ptr,fixed bin,fixed bin(35));
       49 
       50 dcl	(abs,addr,addrel,baseptr,divide,fixed,min,mod,null,ptr,rel,string,substr,unspec,rtrim,char,length) builtin;
       51 
  1     1 /* BEGIN INCLUDE FILE operator_names.incl.pl1 77-5-2 SHW */
  1     2 
  1     3 dcl  op_names_pt ptr;
  1     4 
  1     5 dcl 1 operator_names aligned based (op_names_pt),
  1     6     2 first fixed bin (18),				/* offset of first operator in operator segment */
  1     7     2 last fixed bin (18),				/* offset of last operator in operator segment */
  1     8     2 first_special fixed bin (18),			/* offset of first special operator */
  1     9     2 last_special fixed bin (18),			/* offset of last special operator */
  1    10     2 number_special fixed bin,			/* number of special operators */
  1    11 
  1    12     2 names (1 refer (first) : 1 refer (last)),		/* array of pointers to and lengths of names */
  1    13       3 namep bit (18) unal,				/* rel pointer to ACI string for name */
  1    14       3 len fixed bin (17) unal,			/* length of this operator name */
  1    15 
  1    16     2 special (0 refer (number_special)),		/* array of info about special operators */
  1    17       3 offset fixed bin (18),			/* offset of start of code for this operator */
  1    18       3 namep bit (18) unal,				/* rel pointer to ACI string for name */
  1    19       3 len fixed bin (17) unal;			/* length of this operator name */
  1    20 
  1    21 /* END INCLUDE FILE operator_names.incl.pl1 */
       52 
       53 
       54 dcl	1 op_mnemonic_$op_mnemonic(0:1023) ext static aligned,
       55 		2 opcode		char(6) unal,
       56 		2 dtype		fixed bin(2) unal,	/* 0 - desc9a, 1 - descb, 2 - decimal */
       57 		2 num_desc	fixed bin(5) unal,
       58 		2 num_words	fixed bin(8) unal;
       59 
       60 dcl	1 name_pair	aligned based(p),
       61 	2 rel_ptr		unaligned bit(18),		/* ptr to ascii string */
       62 	2 size		unaligned bit(18);		/* size of string */
       63 
       64 dcl	based_string aligned char(size) based(p);
       65 
       66 dcl	digit(0:9) char(1) aligned int static
       67 	init("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");
       68 
       69 dcl	relocation(-1:11) char(1) aligned int static
       70 	init("a", "t", "1", "2", "3", "l", "d", "s", "7", "8", "i", "r", "e");
       71 
       72 dcl	base(0:7) char(4) aligned int static
       73 	init("pr0|","pr1|","pr2|","pr3|","pr4|","pr5|","pr6|","pr7|");
       74 
       75 dcl	modifier(0:63) char(3) aligned int static
       76 	init("n", "au", "qu", "du", "ic", "al", "ql", "dl",
       77 	     "0", "1", "2", "3", "4", "5", "6", "7",
       78 	     "*", "au*", "qu*", "...", "ic*", "al*", "ql*", "...",
       79 	     "0*", "1*", "2*", "3*", "4*", "5*", "6*", "7*",
       80 	     (8)(1)"...",
       81 	     (8)(1)"...",
       82 	     "*n", "*au", "*qu", "...", "*ic", "*al", "*ql", "...",
       83 	     "*0", "*1", "*2", "*3", "*4", "*5", "*6", "*7");
       84 
       85 dcl	word(0:1) bit(36) aligned based(p);
       86 
       87 dcl	1 instruction	based(p) aligned,
       88 	2 base		unaligned bit(3),
       89 	2 offset		unaligned bit(15),
       90 	2 op_code		unaligned bit(10),
       91 	2 unused		unaligned bit(1),
       92 	2 ext_base	unaligned bit(1),
       93 	2 tag		unaligned bit(6);
       94 
       95 dcl	1 half		based(p) aligned,
       96 	2 left		unaligned bit(18),
       97 	2 right		unaligned bit(18);
       98 
       99 dcl	1 rel_tab		based(p) aligned,
      100 	2 dummy_l		unaligned bit(14),
      101 	2 left		unaligned bit(4),
      102 	2 dummy_r		unaligned bit(14),
      103 	2 right		unaligned bit(4);
      104 
      105 dcl	1 mod_factor	aligned,
      106 	2 ext_base	bit(1) unal,
      107 	2 length_in_reg	bit(1) unal,
      108 	2 indirect_descriptor bit(1) unal,
      109 	2 tag		bit(4) unal;
      110 
      111 dcl	mf(3) fixed bin(6) int static init(30,12,3);	/* location of modification factor fields in EIS inst */
      112 
      113 dcl	1 packed_ptr_st based aligned,
      114 	2 packed_ptr	ptr unal;
      115 
      116 dcl	(ebase,len_reg,ic) (3) bit(1) aligned;
      117 dcl	desc_word char(8) varying;
      118 
      119 dcl	desc_op(0:3) char(8) varying int static init("desc9a","descb","desc9fl","desc9ls");
      120 
      121 dcl	eis_modifier(0:15) char(3) aligned int static
      122 	init("n", "au", "qu", "du", "ic", "al", "ql", "...",
      123 	     "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7");
      124 
      125 dcl	bool_word(0:15) char(6) aligned int static varying
      126 	init("clear", "and", "andnot", "move", "", "", "xor", "or",
      127 	     "", "", "", "", "invert", "", "nand","set");
      128 
      129 dcl	1 descriptor	based aligned,	/* EIS descriptor */
      130 	2 address		bit(18) unal,
      131 	2 char		bit(2) unal,
      132 	2 bit		bit(4) unal,
      133 	2 length		bit(12) unal;
      134 
  2     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  2     2 
  2     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  2     4 
  2     5 dcl (	bits_per_char		init(9),
  2     6 	bits_per_half		init(18),
  2     7 	bits_per_word		init(36),
  2     8 	bits_per_two_words		init(72),
  2     9 	bits_per_four_words		init(144),
  2    10 	bits_per_words(2)		init(36,72),
  2    11 	packed_digits_per_char	init(2),
  2    12 	chars_per_word		init(4),
  2    13 	packed_digits_per_word	init(8),
  2    14 
  2    15 	break_even_bits		init(216),
  2    16 	break_even_words		init(6),
  2    17 
  2    18 	label_size		init(4),
  2    19 
  2    20 	convert_size(13:14)		init(9,1),
  2    21 	max_offset(13:14)		init(27,35),
  2    22 	max_short_size(13:14)	init(8,72),
  2    23 
  2    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  2    25 
  2    26 	max_dec_scale		init(32),
  2    27 	min_dec_scale		init(-31),
  2    28 	max_p_xreg		init(18),
  2    29 	max_p_fix_bin_1		init(35),
  2    30 	max_p_flt_bin_1		init(27),
  2    31 	max_p_fix_dec		init(59),
  2    32 	max_length_p		init(24),
  2    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  2    34 
  2    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  2    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  2    37 
  2    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  2    39 
  2    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  2    41 
      135 
      136 
      137 
      138 begin:	p = addrel(t_pt,delta);
      139 	q = addrel(r_pt,delta);
      140 
      141 	line_pt = addr(line);
      142 	eis = "0"b;
      143 	irand = 0;
      144  
      145 	do i = 1 to number;
      146 
      147 	     tag = "   ";
      148 	     substr(line,1,6) = binoct(rel(p));
      149 	     substr(line,7,2) = "  ";
      150 
      151 	     if r_pt = null
      152 	     then do;
      153 		substr(line,9,4) = "  ";
      154 		go to body;
      155 		end;
      156 
      157 	     if q -> rel_tab.dummy_l then k = fixed(q -> rel_tab.left,4);
      158 	     else k = -1;
      159 
      160 	     substr(line,9,1) = relocation(k);
      161 
      162 	     if q -> rel_tab.dummy_r then k = fixed(q -> rel_tab.right,4);
      163 	     else k = -1;
      164 
      165 	     substr(line,10,3) = relocation(k);
      166 
      167 body:	     cstring = binoct(p -> word(0));
      168 
      169 	     if ^ eis
      170 	     then do;
      171 		mop = fixed(p->instruction.op_code,10);
      172 		op_code = opcode(mop);
      173 		end;
      174 	     else do;
      175 		mop = 0;
      176 		end;
      177 
      178 	     if op_code = ".... "
      179 	     then do;
      180 not_ins:		substr(line,13,3) = "   ";
      181 		substr(line,16,5) = substr(cstring,1,5);
      182 		substr(line,21,7) = substr(cstring,6,7);
      183 		k = 28;
      184 		goto prt;
      185 		end;
      186 
      187 	     if num_words(mop) > 1
      188 	     then do;
      189 
      190 		/* EIS */
      191 
      192 		call init_eis;
      193 
      194 		substr(line,13,4) = substr(cstring,1,3);
      195 		substr(line,17,4) = substr(cstring,4,3);
      196 		substr(line,21,4) = substr(cstring,7,3);
      197 		substr(line,25,3) = substr(cstring,10,3);
      198 
      199 		substr(line,28,1) = ht;
      200 		substr(line,29,5) = op_code;
      201 		substr(line,34,1) = ht;
      202 
      203 		k = 35;
      204 
      205 		do j = 1 to ndesc;
      206 		string(mod_factor) = substr(p -> word(0),mf(j),7);
      207 		ebase(j) = mod_factor.ext_base;
      208 		len_reg(j) = mod_factor.length_in_reg;
      209 
      210 		substr(line,k,1) = "(";
      211 		k = k + 1;
      212 		need_comma = "0"b;
      213 
      214 		if ebase(j)
      215 		then do;
      216 		     substr(line,k,2) = "pr";
      217 		     k = k + 2;
      218 		     need_comma = "1"b;
      219 		     end;
      220 
      221 		if len_reg(j)
      222 		then do;
      223 		     if need_comma
      224 		     then do;
      225 			substr(line,k,1) = ",";
      226 			k = k + 1;
      227 			end;
      228 		     substr(line,k,2) = "rl";
      229 		     k = k + 2;
      230 		     need_comma = "1"b;
      231 		     end;
      232 
      233 		if mod_factor.tag
      234 		then do;
      235 		     if need_comma
      236 		     then do;
      237 			substr(line,k,1) = ",";
      238 			k = k + 1;
      239 			end;
      240 		     ic(j) = mod_factor.tag = "0100"b;		/* IC */
      241 		     substr(line,k,2) = eis_modifier(fixed(mod_factor.tag,4));
      242 		     k = k + 2;
      243 		     end;
      244 		else ic(j) = "0"b;
      245 
      246 		substr(line,k,2) = "),";
      247 		k = k + 2;
      248 		end;
      249 
      250 
      251 		if substr(p -> word(0),10,1)
      252 		then do;
      253 		     substr(line,k,12) = "enablefault,";
      254 		     k = k + 12;
      255 		     end;
      256 
      257 		if desc_word = "desc9a"
      258 		then if ndesc < 3
      259 		     then do;
      260 			if substr(op_code,1,2) ^= "sc"
      261 			     then substr(line,k,5) = "fill(";
      262 			     else substr(line,k,5) = "mask(";
      263 			k = k + 5;
      264 			substr(line,k,3) = substr(cstring,1,3);
      265 			k = k + 3;
      266 			substr(line,k,1) = ")";
      267 			k = k + 1;
      268 			end;
      269 		     else k = k - 1;
      270 		else if desc_word = "descb"
      271 		     then do;
      272 			substr(line,k,5) = "fill(";
      273 			k = k + 5;
      274 			substr(line,k,1) = digit(fixed(substr(p -> word(0),1,1),1));
      275 			k = k + 1;
      276 			substr(line,k,1) = ")";
      277 			k = k + 1;
      278 			if op_code ^= "cmpb "
      279 			then do;
      280 			     substr(line,k,6) = ",bool(";
      281 			     k = k + 6;
      282 			     j = fixed(substr(p -> word(0),6,4),4);
      283 			     m = length(bool_word(j));
      284 			     if m > 0
      285 			     then do;
      286 				substr(line,k,m) = bool_word(j);
      287 				k = k + m;
      288 				end;
      289 			     else do;
      290 				substr(line,k,1) = digit(fixed(substr(p -> word(0),6,1),1));
      291 				substr(line,k+1,1) = digit(fixed(substr(p -> word(0),7,3),3));
      292 				k = k + 2;
      293 				end;
      294 			     substr(line,k,1) = ")";
      295 			     k = k + 1;
      296 			     end;
      297 			end;
      298 		     else if substr(p -> word(0),11,1)
      299 			then do;
      300 			     substr(line,k,5) = "round";
      301 			     k = k + 5;
      302 			     end;
      303 			else k = k - 1;
      304 
      305 		irand = 0;
      306 		go to prt;
      307 		end;
      308 
      309 	     double, ignore_ic_mod = "0"b;
      310 
      311 	     eis_desc = eis & desc_word ^= "arg";
      312 	     if eis_desc
      313 	     then do;
      314 		substr(line,13,2) = "  ";
      315 		substr(line,15,6) = substr(cstring,2,5);
      316 		substr(line,21,3) = substr(cstring,7,2);
      317 		substr(line,24,4) = substr(cstring,9,4);
      318 
      319 		substr(line,28,1) = ht;
      320 
      321 		if decimal
      322 		     then desc_word = desc_op(2 + fixed(p -> descriptor.bit,4));
      323 		if irand > 1
      324 		then if op_code = "dtb  " | op_code = "mvne "
      325 		     then desc_word = desc_op(0);
      326 		     else;
      327 		else if op_code = "btd  "
      328 		     then desc_word = desc_op(0);
      329 
      330 		substr(line,29,length(desc_word)) = desc_word;
      331 		k = length(desc_word) + 29;
      332 
      333 		ext_base = ebase(irand);
      334 		itag = len_reg(irand);
      335 		if itag
      336 		     then tag = eis_modifier(fixed(substr(p -> descriptor.length,9,4),4));
      337 		has_ic = ic(irand);
      338 		go to chk_ext;
      339 		end;
      340 
      341 	     if op_code = "rpd  " then goto set;
      342 	     if op_code = "rpt  " then goto set;
      343 
      344 	     if p -> instruction.unused then goto not_ins;
      345 
      346 	     if num_desc(mop) ^= 0
      347 	     then do;
      348 si:		tag = substr(binoct((p -> instruction.tag)),1,2);
      349 		ignore_ic_mod = "1"b;
      350 		goto set;
      351 		end;
      352 
      353 	     if p -> instruction.tag
      354 	     then do;
      355 		tag = modifier(fixed(p -> instruction.tag,6));
      356 		if tag = "..." then goto not_ins;
      357 		end;
      358 
      359 set:	     substr(line,13,2) = "  ";
      360 	     substr(line,15,6) = substr(cstring,2,5);
      361 	     substr(line,21,5) = substr(cstring,7,4);
      362 	     substr(line,26,2) = substr(cstring,11,2);
      363 
      364 	     substr(line,28,1) = ht;
      365 	     k = 29;
      366 
      367 	     substr(line,k,5) = op_code;
      368 
      369 	     c = substr(line,k+3,1);
      370 
      371 	     double = substr(op_code,1,2) = "df" | substr(op_code,3,2) = "aq" | substr(op_code,4,2) = "aq";
      372 
      373 	     ext_base = p -> instruction.ext_base;
      374 	     itag = p -> instruction.tag ^= "000000"b;
      375 	     has_ic = p -> instruction.tag = "000100"b;	/* IC */
      376 
      377 	     k = 34;
      378 chk_ext:
      379 chk_ext1:	     substr(line,k,1) = ht;
      380 	     k = k + 1;
      381 
      382 	     save_k = k;
      383 
      384 	     if ^ eis
      385 	     then if p -> instruction.unused
      386 		then do;
      387 
      388 		     /* have rpd | rpt instruction */
      389 
      390 		     tag = digit(fixed(p -> instruction.tag,6));
      391 		     offset = fixed(substr(p -> half.left,1,8),8);
      392 		     ignore_ic_mod = "1"b;
      393 		     goto sk;
      394 		     end;
      395 
      396 	     if ext_base
      397 	     then do;
      398 		substr(line,k,4) = base(fixed(p -> instruction.base,3));
      399 		offset = fixed(p -> instruction.offset,15);
      400 		if offset > 16384 then offset = offset - 32768;
      401 		k = k+4;
      402 		j = 13;
      403 		end;
      404 	     else do;
      405 		offset = fixed(p -> half.left,18);
      406 
      407 		if offset > 131072
      408 		then do;
      409 		     if tag = "du " then goto sk;
      410 		     if tag = "dl " then goto sk;
      411 		     offset = offset - 262144;	/* 2's comp */
      412 		     end;
      413 
      414 sk:		j = 14;
      415 		end;
      416 
      417 	     substr(line,j,1) = cstring;
      418 
      419 	     call bin2dec(offset);
      420 
      421 	     if eis_desc
      422 	     then do;
      423 		if desc_word = "descb"
      424 		     then fract_offset = fixed(p -> descriptor.char,2) * bits_per_char + fixed(p -> descriptor.bit,4);
      425 		     else fract_offset = fixed(p -> descriptor.char,2);
      426 		if fract_offset ^= 0
      427 		then do;
      428 		     substr(line,k,1) = "(";
      429 		     k = k + 1;
      430 		     call bin2dec(fract_offset);
      431 		     substr(line,k,1) = ")";
      432 		     k = k + 1;
      433 		     end;
      434 		end;
      435 
      436 	     if itag
      437 	     then do;
      438 		substr(line,k,1) = ",";
      439 		substr(line,k+1,3) = tag;
      440 
      441 		k = k + 2;
      442 		if substr(line,k,1) ^= " " then k = k + 1;
      443 		if substr(line,k,1) ^= " " then k = k + 1;
      444 		end;
      445 	     else if eis_desc
      446 		then do;
      447 		     substr(line,k,1) = ",";
      448 		     k = k + 1;
      449 		     if desc_word = "desc9ls"
      450 		     then do;
      451 			call bin2dec(fixed(substr(p -> descriptor.length,7,6),6));
      452 			substr(line,k,1) = ",";
      453 			k = k + 1;
      454 			scale = fixed(substr(p -> descriptor.length,1,6),6);
      455 			if scale >= 32
      456 			     then scale = scale - 64;
      457 			call bin2dec(scale);
      458 			end;
      459 		     else call bin2dec(fixed(p -> descriptor.length,12));
      460 		     end;
      461 
      462 	     if ignore_ic_mod then goto chk_base;
      463 
      464 	     if has_ic
      465 	     then do;
      466 		substr(line,k,2) = htht;
      467 		k = k + 2;
      468 
      469 		pt = addrel(p,offset-irand);
      470 		substr(line,k,6) = binoct(rel(pt));
      471 
      472 		k = k + 6;
      473 
      474 		if substr(op_code,1,1) = "t" then goto prt;
      475 		if fixed(rel(pt),18) > t_size then goto prt;
      476 
      477 		substr(line,k,1) = " ";
      478 		k = k + 1;
      479 
      480 equal:		substr(line,k,2) = "= ";
      481 		substr(line,k+2,12) = binoct(pt -> word(0));
      482 		k = k + 14;
      483 
      484 		if double
      485 		then do;
      486 		     substr(line,k,1) = " ";
      487 		     substr(line,k+1,12) = binoct(pt -> word(1));
      488 		     k = k + 13;
      489 		     end;
      490 
      491 		goto prt;
      492 		end;
      493 
      494 chk_base:	     if onp = null then go to prt;		/* Means don't want to print operator names */
      495 
      496 	     if ^ p -> instruction.ext_base then go to prt;
      497 
      498 	     if p -> instruction.base then go to prt;
      499 
      500 	     if op_code = "xec  "
      501 	     then do;
      502 		pt = addrel(addr(pl1_operators_$operator_table),offset);
      503 		mop = fixed(pt -> instruction.op_code,10);
      504 		if num_words(mop) > 1
      505 		then do;
      506 
      507 		     /* we are executing an EIS instruction in pl1_operators_ */
      508 
      509 		     call init_eis;
      510 
      511 		     do j = 1 to ndesc;
      512 			ebase(j) = "1"b;
      513 			len_reg(j) = ^ decimal;
      514 			ic(j) = "0"b;
      515 			end;
      516 
      517 		     irand = 0;
      518 		     end;
      519 		end;
      520 
      521 	     if itag then goto prt;
      522 
      523 	     if substr(op_code,1,1) ^= "t"
      524 	     then do;
      525 		if offset >= onp -> operator_names.first then goto prt;
      526 		pt = addrel(addr(pl1_operators_$operator_table),offset);
      527 		substr(line,k,2) = htht;
      528 		k = k + 2;
      529 		goto equal;
      530 		end;
      531 
      532 	     op_names_pt = onp;
      533 
      534 	     if offset >= operator_names.first & offset <= operator_names.last
      535 	     then do;
      536 		pt = addr (operator_names.names(offset));
      537 		goto str_info;
      538 		end;
      539 
      540 
      541 	     else if offset >= operator_names.first_special & offset <= operator_names.last_special
      542 	     then do;
      543 		do j = 1 to operator_names.number_special;
      544 		     if operator_names.special(j).offset = offset
      545 		     then do;
      546 			pt = addr(operator_names.special(j).namep);
      547 			goto str_info;
      548 			end;
      549 		     end;
      550 		goto prt;
      551 		end;
      552 
      553 str_info:	     size = fixed(pt -> name_pair.size,18);
      554 	     pt = ptr(pt,pt -> name_pair.rel_ptr);
      555 
      556 	     substr(line,k,2) = htht;
      557 	     k = k + 2;
      558 
      559 	     substr(line,k,size) = pt -> based_string;
      560 	     k = size + k;
      561 
      562 prt:	     substr(line,k,1) = nl;
      563 
      564 	     call iox_$put_chars(iox_$user_output,line_pt,k,(0));
      565 
      566 	     if eis
      567 	     then do;
      568 		irand = irand + 1;
      569 		if irand > nrands
      570 		then do;
      571 		     eis = "0"b;
      572 		     irand = 0;
      573 		     end;
      574 		else if irand > ndesc
      575 		     then op_code, desc_word = "arg";
      576 		end;
      577 
      578 	     p = addrel(p,1);
      579 	     q = addrel(q,1);
      580 	     end;
      581 
      582 	return;
      583 
      584 bin2dec:	     proc(number);
      585 
      586 dcl	     number fixed bin(18);
      587 
      588 	     substr(line,k,length(ltrim(char(number)))) = ltrim(char(number));
      589 	     k = k + length(ltrim(char(number)));
      590 
      591 	     end;
      592 
      593 
      594 init_eis:	     proc;
      595 
      596 	     eis = "1"b;
      597 	     nrands = num_words(mop) - 1;
      598 	     ndesc = num_desc(mop);
      599 	     decimal = dtype(mop) = 2;
      600 	     desc_word = desc_op(dtype(mop));
      601 
      602 	     end;
      603 
      604 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1501.1  display_text_.pl1                 >dumps>old>recomp>display_text_.pl1
52           1    09/14/77  1705.7  operator_names.incl.pl1           >ldd>include>operator_names.incl.pl1
135          2    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 50 ref 141 502 526 536 546
addrel                                                 builtin function         dcl 50 ref 138 139 469 502 526 578 579
base                                   based           bit(3)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 87 in procedure "display_text_" ref 398 498
base                            000217 constant        char(4)                  initial array dcl 72 in procedure "display_text_"
                                                                                  ref 398
based_string                           based           char                     dcl 64 ref 559
binoct                          000014 constant        entry                    external dcl 30 ref 148 167 348 470 481 487
bit                       0(20)        based           bit(4)                   level 2 packed unaligned dcl 129 ref 321 423
bits_per_char                          constant        fixed bin(8,0)           initial dcl 2-5 ref 423
bool_word                       000000 constant        varying char(6)          initial array dcl 125 ref 283 286
c                               000136 automatic       char(1)                  unaligned dcl 30 set ref 369*
char                                                   builtin function         dcl 50 in procedure "display_text_" ref 588 588 589
char                      0(18)        based           bit(2)                   level 2 in structure "descriptor" packed unaligned
                                                                                  dcl 129 in procedure "display_text_" ref 423 425
cstring                         000137 automatic       char(12)                 unaligned dcl 30 set ref 167* 181 182 194 195 196
                                                                                  197 264 315 316 317 360 361 362 417
decimal                         000135 automatic       bit(1)                   unaligned dcl 30 set ref 321 513 599*
delta                                  parameter       fixed bin(17,0)          dcl 23 ref 21 138 139
desc_op                         000100 constant        varying char(8)          initial array dcl 119 ref 321 323 327 600
desc_word                       000262 automatic       varying char(8)          dcl 117 set ref 257 270 311 321* 323* 327* 330 330
                                                                                  331 423 449 574* 600*
descriptor                             based           structure                level 1 dcl 129
digit                           000244 constant        char(1)                  initial array dcl 66 ref 274 290 291 390
double                          000126 automatic       bit(1)                   unaligned dcl 30 set ref 309* 371* 484
dtype                     1(18) 000020 external static fixed bin(2,0)           array level 2 packed unaligned dcl 54 ref 599 600
dummy_l                                based           bit(14)                  level 2 packed unaligned dcl 99 ref 157
dummy_r                   0(18)        based           bit(14)                  level 2 packed unaligned dcl 99 ref 162
ebase                           000251 automatic       bit(1)                   array dcl 116 set ref 207* 214 333 512*
eis                             000127 automatic       bit(1)                   unaligned dcl 30 set ref 142* 169 311 384 566 571*
                                                                                  596*
eis_desc                        000130 automatic       bit(1)                   unaligned dcl 30 set ref 311* 312 421 445
eis_modifier                    000060 constant        char(3)                  initial array dcl 121 ref 241 335
ext_base                  0(29)        based           bit(1)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 87 in procedure "display_text_" ref 373 496
ext_base                        000132 automatic       bit(1)                   unaligned dcl 30 in procedure "display_text_" set
                                                                                  ref 333* 373* 396
ext_base                        000250 automatic       bit(1)                   level 2 in structure "mod_factor" packed unaligned
                                                                                  dcl 105 in procedure "display_text_" set ref 207
first                                  based           fixed bin(18,0)          level 2 dcl 1-5 ref 525 534 536 544 546
first_special             2            based           fixed bin(18,0)          level 2 dcl 1-5 ref 541
fixed                                                  builtin function         dcl 50 ref 157 162 171 241 274 282 290 291 321 335
                                                                                  355 390 391 398 399 405 423 423 425 451 451 454
                                                                                  459 459 475 503 553
fract_offset                    000121 automatic       fixed bin(18,0)          dcl 30 set ref 423* 425* 426 430*
half                                   based           structure                level 1 dcl 95
has_ic                          000134 automatic       bit(1)                   unaligned dcl 30 set ref 337* 375* 464
ht                                     constant        char(1)                  initial dcl 30 ref 199 201 319 364 378
htht                                   constant        char(2)                  initial dcl 30 ref 466 527 556
i                               000110 automatic       fixed bin(17,0)          dcl 30 set ref 145*
ic                              000257 automatic       bit(1)                   array dcl 116 set ref 240* 244* 337 514*
ignore_ic_mod                   000125 automatic       bit(1)                   unaligned dcl 30 set ref 309* 349* 392* 462
instruction                            based           structure                level 1 dcl 87
iox_$put_chars                  000016 constant        entry                    external dcl 30 ref 564
iox_$user_output                000010 external static pointer                  dcl 30 set ref 564*
irand                           000116 automatic       fixed bin(17,0)          dcl 30 set ref 143* 305* 323 333 334 337 469 517*
                                                                                  568* 568 569 572* 574
itag                            000133 automatic       bit(1)                   unaligned dcl 30 set ref 334* 335 374* 436 521
j                               000111 automatic       fixed bin(17,0)          dcl 30 set ref 205* 206 207 208 214 221 240 244*
                                                                                  282* 283 286 402* 414* 417 511* 512 513 514* 543*
                                                                                  544 546*
k                               000112 automatic       fixed bin(17,0)          dcl 30 set ref 157* 158* 160 162* 163* 165 183* 203*
                                                                                  210 211* 211 216 217* 217 225 226* 226 228 229*
                                                                                  229 237 238* 238 241 242* 242 246 247* 247 253
                                                                                  254* 254 260 262 263* 263 264 265* 265 266 267*
                                                                                  267 269* 269 272 273* 273 274 275* 275 276 277*
                                                                                  277 280 281* 281 286 287* 287 290 291 292* 292 294
                                                                                  295* 295 300 301* 301 303* 303 331* 365* 367 369
                                                                                  377* 378 380* 380 382 398 401* 401 428 429* 429
                                                                                  431 432* 432 438 439 441* 441 442 442* 442 443
                                                                                  443* 443 447 448* 448 452 453* 453 466 467* 467
                                                                                  470 472* 472 477 478* 478 480 481 482* 482 486 487
                                                                                  488* 488 527 528* 528 556 557* 557 559 560* 560
                                                                                  562 564* 588 589* 589
last                      1            based           fixed bin(18,0)          level 2 dcl 1-5 ref 534 544 546
last_special              3            based           fixed bin(18,0)          level 2 dcl 1-5 ref 541
left                      0(14)        based           bit(4)                   level 2 in structure "rel_tab" packed unaligned
                                                                                  dcl 99 in procedure "display_text_" ref 157
left                                   based           bit(18)                  level 2 in structure "half" packed unaligned dcl 95
                                                                                  in procedure "display_text_" ref 391 405
len_reg                         000254 automatic       bit(1)                   array dcl 116 set ref 208* 221 334 513*
length                    0(24)        based           bit(12)                  level 2 in structure "descriptor" packed unaligned
                                                                                  dcl 129 in procedure "display_text_" ref 335 451
                                                                                  451 454 459 459
length                                                 builtin function         dcl 50 in procedure "display_text_" ref 283 330 331
                                                                                  588 589
length_in_reg             0(01) 000250 automatic       bit(1)                   level 2 packed unaligned dcl 105 set ref 208
line                            000145 automatic       char(256)                unaligned dcl 30 set ref 141 148* 149* 153* 160*
                                                                                  165* 180* 181* 182* 194* 195* 196* 197* 199* 200*
                                                                                  201* 210* 216* 225* 228* 237* 241* 246* 253* 260*
                                                                                  262* 264* 266* 272* 274* 276* 280* 286* 290* 291*
                                                                                  294* 300* 314* 315* 316* 317* 319* 330* 359* 360*
                                                                                  361* 362* 364* 367* 369 378* 398* 417* 428* 431*
                                                                                  438* 439* 442 443 447* 452* 466* 470* 477* 480*
                                                                                  481* 486* 487* 527* 556* 559* 562* 588*
line_pt                         000104 automatic       pointer                  dcl 30 set ref 141* 564*
m                               000113 automatic       fixed bin(17,0)          dcl 30 set ref 283* 284 286 287
mf                              000114 constant        fixed bin(6,0)           initial array dcl 111 ref 206
mod_factor                      000250 automatic       structure                level 1 dcl 105 set ref 206*
modifier                        000117 constant        char(3)                  initial array dcl 75 ref 355
mop                             000114 automatic       fixed bin(17,0)          dcl 30 set ref 171* 172 175* 187 346 503* 504 597
                                                                                  598 599 600
name_pair                              based           structure                level 1 dcl 60
namep                                  based           bit(18)                  array level 3 packed unaligned dcl 1-5 set ref 546
names                     5            based           structure                array level 2 dcl 1-5 set ref 536
ndesc                           000120 automatic       fixed bin(17,0)          dcl 30 set ref 205 257 511 574 598*
need_comma                      000131 automatic       bit(1)                   unaligned dcl 30 set ref 212* 218* 223 230* 235
nl                                     constant        char(1)                  initial dcl 30 ref 562
nrands                          000117 automatic       fixed bin(17,0)          dcl 30 set ref 569 597*
null                                                   builtin function         dcl 50 ref 151 494
num_desc                  1(21) 000020 external static fixed bin(5,0)           array level 2 packed unaligned dcl 54 ref 346 598
num_words                 1(27) 000020 external static fixed bin(8,0)           array level 2 packed unaligned dcl 54 ref 187 504
                                                                                  597
number                                 parameter       fixed bin(17,0)          dcl 23 in procedure "display_text_" ref 21 145
number                                 parameter       fixed bin(18,0)          dcl 586 in procedure "bin2dec" ref 584 588 588 589
number_special            4            based           fixed bin(17,0)          level 2 dcl 1-5 ref 543
offset                                 based           fixed bin(18,0)          array level 3 in structure "operator_names" dcl 1-5
                                                                                  in procedure "display_text_" ref 544
offset                          000122 automatic       fixed bin(18,0)          dcl 30 in procedure "display_text_" set ref 391*
                                                                                  399* 400 400* 400 405* 407 411* 411 419* 469 502
                                                                                  525 526 534 534 536 541 541 544
offset                    0(03)        based           bit(15)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 87 in procedure "display_text_" ref 399
onp                                    parameter       pointer                  dcl 23 ref 21 494 525 532
op_code                         000142 automatic       char(5)                  unaligned dcl 30 in procedure "display_text_" set
                                                                                  ref 172* 178 200 260 278 323 323 327 341 342 367
                                                                                  371 371 371 474 500 523 574*
op_code                   0(18)        based           bit(10)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 87 in procedure "display_text_" ref 171 503
op_mnemonic_$op_mnemonic        000020 external static structure                array level 1 dcl 54
op_names_pt                     000246 automatic       pointer                  dcl 1-3 set ref 532* 534 534 536 541 541 543 544 546
opcode                          000020 external static char(6)                  array level 2 packed unaligned dcl 54 ref 172
operator_names                         based           structure                level 1 dcl 1-5
p                               000100 automatic       pointer                  dcl 30 set ref 138* 148 148 167 171 206 251 274 282
                                                                                  290 291 298 321 335 344 348 353 355 373 374 375
                                                                                  384 390 391 398 399 405 423 423 425 451 451 454
                                                                                  459 459 469 496 498 578* 578
pl1_operators_$operator_table   000012 external static fixed bin(17,0)          dcl 30 set ref 502 526
pt                              000106 automatic       pointer                  dcl 30 set ref 469* 470 470 475 481 487 502* 503
                                                                                  526* 536* 546* 553 554* 554 554 559
ptr                                                    builtin function         dcl 50 ref 554
q                               000102 automatic       pointer                  dcl 30 set ref 139* 157 157 162 162 579* 579
r_pt                                   parameter       pointer                  dcl 23 ref 21 139 151
rel                                                    builtin function         dcl 50 ref 148 148 470 470 475
rel_ptr                                based           bit(18)                  level 2 packed unaligned dcl 60 ref 554
rel_tab                                based           structure                level 1 dcl 99
relocation                      000227 constant        char(1)                  initial array dcl 69 ref 160 165
right                     0(32)        based           bit(4)                   level 2 packed unaligned dcl 99 ref 162
save_k                          000115 automatic       fixed bin(17,0)          dcl 30 set ref 382*
scale                           000124 automatic       fixed bin(18,0)          dcl 30 set ref 454* 455 455* 455 457*
size                      0(18)        based           bit(18)                  level 2 in structure "name_pair" packed unaligned
                                                                                  dcl 60 in procedure "display_text_" ref 553
size                            000123 automatic       fixed bin(18,0)          dcl 30 in procedure "display_text_" set ref 553* 559
                                                                                  559 560
special                                based           structure                array level 2 dcl 1-5
string                                                 builtin function         dcl 50 set ref 206*
substr                                                 builtin function         dcl 50 set ref 148* 149* 153* 160* 165* 180* 181*
                                                                                  181 182* 182 194* 194 195* 195 196* 196 197* 197
                                                                                  199* 200* 201* 206 210* 216* 225* 228* 237* 241*
                                                                                  246* 251 253* 260 260* 262* 264* 264 266* 272*
                                                                                  274* 274 276* 280* 282 286* 290* 290 291* 291 294*
                                                                                  298 300* 314* 315* 315 316* 316 317* 317 319* 330*
                                                                                  335 348 359* 360* 360 361* 361 362* 362 364* 367*
                                                                                  369 371 371 371 378* 391 398* 417* 428* 431* 438*
                                                                                  439* 442 443 447* 451 451 452* 454 466* 470* 474
                                                                                  477* 480* 481* 486* 487* 523 527* 556* 559* 562*
                                                                                  588*
t_pt                                   parameter       pointer                  dcl 23 ref 21 138
t_size                                 parameter       fixed bin(17,0)          dcl 23 ref 21 475
tag                             000144 automatic       char(3)                  unaligned dcl 30 in procedure "display_text_" set
                                                                                  ref 147* 335* 348* 355* 356 390* 409 410 439
tag                       0(30)        based           bit(6)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 87 in procedure "display_text_" ref 348 353
                                                                                  355 374 375 390
tag                       0(03) 000250 automatic       bit(4)                   level 2 in structure "mod_factor" packed unaligned
                                                                                  dcl 105 in procedure "display_text_" set ref 233
                                                                                  240 241
unused                    0(28)        based           bit(1)                   level 2 packed unaligned dcl 87 ref 344 384
word                                   based           bit(36)                  array dcl 85 set ref 167* 206 251 274 282 290 291
                                                                                  298 481* 487*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abs                                                    builtin function         dcl 50
baseptr                                                builtin function         dcl 50
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 2-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 2-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 2-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 2-5
bits_per_word                          internal static fixed bin(8,0)           initial dcl 2-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 2-5
break_even_bits                        internal static fixed bin(8,0)           initial dcl 2-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 2-5
c2                                     automatic       char(1)                  unaligned dcl 30
chars_per_word                         internal static fixed bin(8,0)           initial dcl 2-5
cobol_operator_names_$cobol_operator_names_
                                       external static fixed bin(17,0)          dcl 30
convert_offset                         internal static fixed bin(8,1)           initial array dcl 2-35
convert_size                           internal static fixed bin(8,0)           initial array dcl 2-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 2-5
divide                                                 builtin function         dcl 50
label_size                             internal static fixed bin(8,0)           initial dcl 2-5
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 2-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 2-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 2-5
max_offset                             internal static fixed bin(8,0)           initial array dcl 2-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 2-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 2-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 2-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 2-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 2-5
min                                                    builtin function         dcl 50
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 2-5
mod                                                    builtin function         dcl 50
n                                      automatic       fixed bin(17,0)          dcl 30
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 2-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 2-5
packed_ptr_st                          based           structure                level 1 dcl 113
pl1_operator_names_$pl1_operator_names_
                                       external static fixed bin(17,0)          dcl 30
rtrim                                                  builtin function         dcl 50
units_per_word                         internal static fixed bin(8,0)           initial array dcl 2-5
unspec                                                 builtin function         dcl 50

NAMES DECLARED BY EXPLICIT CONTEXT.
begin                           000354 constant        label                    dcl 138
bin2dec                         002370 constant        entry                    internal dcl 584 ref 419 430 451 457 459
body                            000472 constant        label                    dcl 167 ref 154
chk_base                        002101 constant        label                    dcl 494 ref 462
chk_ext                         001471 constant        label                    dcl 378 ref 338
chk_ext1                        001471 constant        label                    dcl 378
display_text_                   000347 constant        entry                    external dcl 21
equal                           002017 constant        label                    dcl 480 ref 529
init_eis                        002422 constant        entry                    internal dcl 594 ref 192 509
not_ins                         000540 constant        label                    dcl 180 ref 344 356
prt                             002314 constant        label                    dcl 562 ref 184 306 474 475 491 494 496 498 521 525
                                                                                  550
set                             001373 constant        label                    dcl 359 ref 341 342 350
si                              001333 constant        label                    dcl 348
sk                              001563 constant        label                    dcl 414 ref 393 409 410
str_info                        002267 constant        label                    dcl 553 ref 537 547

NAME DECLARED BY CONTEXT OR IMPLICATION.
ltrim                                                  builtin function         ref 588 588 589

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2610        2632    2512        2620
Length      3052    2512        22         204      75           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
display_text_                       225 external procedure  is an external procedure.  
bin2dec                                 internal procedure  shares stack frame of external procedure display_text_.  
init_eis                                internal procedure  shares stack frame of external procedure display_text_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
display_text_            000100 p                           display_text_
                         000102 q                           display_text_
                         000104 line_pt                     display_text_
                         000106 pt                          display_text_
                         000110 i                           display_text_
                         000111 j                           display_text_
                         000112 k                           display_text_
                         000113 m                           display_text_
                         000114 mop                         display_text_
                         000115 save_k                      display_text_
                         000116 irand                       display_text_
                         000117 nrands                      display_text_
                         000120 ndesc                       display_text_
                         000121 fract_offset                display_text_
                         000122 offset                      display_text_
                         000123 size                        display_text_
                         000124 scale                       display_text_
                         000125 ignore_ic_mod               display_text_
                         000126 double                      display_text_
                         000127 eis                         display_text_
                         000130 eis_desc                    display_text_
                         000131 need_comma                  display_text_
                         000132 ext_base                    display_text_
                         000133 itag                        display_text_
                         000134 has_ic                      display_text_
                         000135 decimal                     display_text_
                         000136 c                           display_text_
                         000137 cstring                     display_text_
                         000142 op_code                     display_text_
                         000144 tag                         display_text_
                         000145 line                        display_text_
                         000246 op_names_pt                 display_text_
                         000250 mod_factor                  display_text_
                         000251 ebase                       display_text_
                         000254 len_reg                     display_text_
                         000257 ic                          display_text_
                         000262 desc_word                   display_text_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
binoct                        iox_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output              op_mnemonic_$op_mnemonic      pl1_operators_$operator_table




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000341       138 000354       139 000362       141 000366       142 000370       143 000371       145 000372
    147 000401       148 000403       149 000426       151 000430       153 000435       154 000437       157 000440
    158 000450       160 000452       162 000454       163 000463       165 000465       167 000472       169 000514
    171 000520       172 000524       173 000533       175 000534       178 000535       180 000540       181 000542
    182 000547       183 000553       184 000555       187 000556       192 000570       194 000571       195 000575
    196 000604       197 000612       199 000615       200 000617       201 000622       203 000624       205 000626
    206 000635       207 000643       208 000647       210 000653       211 000657       212 000660       214 000661
    216 000663       217 000667       218 000671       221 000673       223 000675       225 000677       226 000703
    228 000704       229 000710       230 000712       233 000714       235 000721       237 000723       238 000727
    240 000730       241 000734       242 000743       243 000745       244 000746       246 000747       247 000753
    248 000755       251 000757       253 000762       254 000766       257 000770       260 001000       262 001011
    263 001015       264 001017       265 001023       266 001025       267 001031       268 001032       269 001033
    270 001036       272 001043       273 001047       274 001051       275 001060       276 001061       277 001065
    278 001066       280 001071       281 001075       282 001077       283 001103       284 001107       286 001110
    287 001117       288 001120       290 001121       291 001131       292 001140       294 001142       295 001146
    297 001147       298 001150       300 001153       301 001157       302 001161       303 001162       305 001164
    306 001165       309 001166       311 001170       312 001177       314 001200       315 001202       316 001211
    317 001217       319 001223       321 001225       323 001243       326 001260       327 001261       330 001271
    331 001276       333 001301       334 001304       335 001306       337 001313       338 001315       341 001316
    342 001321       344 001323       346 001326       348 001333       349 001357       350 001361       353 001362
    355 001366       356 001371       359 001373       360 001375       361 001404       362 001412       364 001415
    365 001417       367 001421       369 001424       371 001430       373 001452       374 001456       375 001463
    377 001467       378 001471       380 001475       382 001476       384 001500       390 001505       391 001513
    392 001516       393 001520       396 001521       398 001523       399 001532       400 001536       401 001542
    402 001544       403 001546       405 001547       407 001552       409 001554       410 001557       411 001561
    414 001563       417 001565       419 001570       421 001572       423 001574       425 001614       426 001620
    428 001622       429 001626       430 001627       431 001631       432 001635       436 001636       438 001640
    439 001644       441 001647       442 001651       443 001657       444 001665       445 001666       447 001670
    448 001674       449 001675       451 001702       452 001707       453 001713       454 001714       455 001720
    457 001724       458 001726       459 001727       462 001734       464 001736       466 001740       467 001744
    469 001746       470 001753       472 001776       474 002000       475 002004       477 002012       478 002016
    480 002017       481 002023       482 002044       484 002046       486 002050       487 002054       488 002076
    491 002100       494 002101       496 002106       498 002111       500 002114       502 002117       503 002125
    504 002131       509 002140       511 002141       512 002150       513 002152       514 002155       515 002156
    517 002160       521 002161       523 002163       525 002167       526 002174       527 002201       528 002205
    529 002207       532 002210       534 002214       536 002221       537 002224       541 002225       543 002231
    544 002240       546 002256       547 002263       549 002264       550 002266       553 002267       554 002272
    556 002277       557 002303       559 002305       560 002312       562 002314       564 002320       566 002336
    568 002340       569 002341       571 002344       572 002345       573 002346       574 002347       578 002357
    579 002362       580 002365       582 002367       584 002370       588 002372       589 002420       591 002421
    594 002422       596 002423       597 002425       598 002437       599 002443       600 002451       602 002461


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
