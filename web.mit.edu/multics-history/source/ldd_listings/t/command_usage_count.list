	COMPILATION LISTING OF SEGMENT command_usage_count
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 09/08/83  1429.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       12 	/*									*/
       13 	/* Name: command_usage_count							*/
       14 	/*									*/
       15 	/* Status:								*/
       16 	/* 1) Modified in July, 1983 by G. Dixon - increase number of commands which can be	*/
       17 	/*    monitored from 200 (user_list_size) to max number of usage_list.commands entries	*/
       18 	/*    which will fit in a segment.						*/
       19 	/*									*/
       20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       21 
       22 
       23 command_usage_count:
       24 cuc:
       25      procedure () options (variable);
       26 
       27 dcl  code fixed bin (35),
       28      errsw bit (1),
       29      first fixed bin init (user_list_size),
       30      last_index fixed bin init (0),
       31      me char (19) static init ("command_usage_count"),
       32      message char (80) var,
       33      tempstring char (32) var,
       34      userseg_name char (32);
       35 
       36 dcl  arg char (argl) based (argp),			/* argument from cu_$arg_ptr */
       37      argl fixed bin,
       38      argp ptr;
       39 
       40 dcl  arg_no fixed bin init (1),			/* no. of argument being processed */
       41      nargs fixed bin;				/* no. of arguments */
       42 
       43 dcl  comlist (40) char (32) var,			/* array for command name arguments */
       44      ncom fixed bin init (0);				/* length of the array */
       45 
       46 dcl (i, j, k, list_size, maxj, total) fixed bin;		/* temporaries */
       47 
       48 dcl (usage_list_ptr, segptr, usage_totals_ptr, user_list_ptr) pointer;
       49 
       50 dcl (add,						/* add request given */
       51      all,						/* -all option given */
       52      clear,					/* -clear option given */
       53      delete,					/* delete request given */
       54      header,					/* heading printed */
       55      i_locked_it,					/* control lock needs opened */
       56      print,					/* print request given */
       57      total_only) bit (1) init ("0"b);			/* -total option given */
       58 
  1     1 /* BEGIN INCLUDE FILE ... command_usage.incl.pl1 ... GMP 780812 */
  1     2 
  1     3 /* Modified in July, 1983 by G. Dixon - add usage_list_size variable */
  1     4 
  1     5 dcl 1 usage_list aligned based (usage_list_ptr),		/* control structure for usage counting */
  1     6     2 n_commands fixed binary,			/* number of commands and aliases */
  1     7     2 locked bit (1) aligned,				/* ON => list being edited */
  1     8     2 directory character (168) unaligned,		/* containing dir for .usage segments */
  1     9     2 commands (usage_list_size refer (usage_list.n_commands)),
  1    10       3 name character (32) varying,			/* command/alias name */
  1    11       3 slot fixed binary unaligned,			/* if primary, index of totals;
  1    12*						   if alias, index of primary */
  1    13       3 primary bit (1) unaligned,			/* ON => first command of group */
  1    14       3 count_users bit (1) unaligned;			/* ON => count usage by user */
  1    15 
  1    16 dcl  usage_totals (1) fixed binary (35) based (usage_totals_ptr);
  1    17 						/* usage count for each command group */
  1    18 
  1    19 dcl 1 user_list (user_list_size) aligned based (user_list_ptr),
  1    20     2 name character (32),				/* Person.Project.* */
  1    21     2 count fixed binary (35);			/* count for this user */
  1    22 
  1    23 dcl  usage_list_size fixed binary;
  1    24 dcl  user_list_size fixed binary static options (constant) initial (200);
  1    25 
  1    26 /* END INCLUDE FILE ... command_usage.incl.pl1 */
  1    27 
       59 
       60 
       61 dcl  com_err_ ext entry options (variable),
       62      copy_acl_ ext entry (char (*), char (*), char (*), char (*), bit (1), fixed bin (35)),
       63      cu_$arg_count ext entry (fixed bin),
       64      cu_$arg_ptr ext entry (fixed bin, ptr, fixed bin, fixed bin (35)),
       65      cv_dec_check_ ext entry (char (*), fixed bin (35)) returns (fixed bin (35)),
       66      hcs_$delentry_file ext entry (char (*), char (*), fixed bin (35)),
       67      hcs_$fs_get_path_name ext entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
       68      hcs_$initiate ext entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
       69      hcs_$make_ptr ext entry (ptr, char (*), char (*), ptr, fixed bin (35)),
       70      hcs_$make_seg ext entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
       71      hcs_$terminate_noname ext entry (ptr, fixed bin (35)),
       72      hcs_$truncate_seg ext entry (ptr, fixed bin, fixed bin (35)),
       73      get_temp_segment_ entry (character (*), pointer, fixed binary (35)),
       74      release_temp_segment_ entry (character (*), pointer, fixed binary (35)),
       75      ioa_ entry options (variable);
       76 
       77 dcl (error_table_$badcall,
       78      error_table_$badopt,
       79      error_table_$bad_conversion,
       80      error_table_$bigarg,
       81      error_table_$inconsistent,
       82      error_table_$namedup,
       83      error_table_$noarg,
       84      error_table_$noentry,
       85      error_table_$notalloc,
       86      error_table_$seglock,
       87      error_table_$too_many_names,
       88      error_table_$zero_length_seg) external static fixed bin (35);
       89 
       90 dcl  cleanup condition;
       91 
       92 dcl (addr, fixed, index, length, null, rel, size, substr) builtin;
       93 
       94 /* PROCESS ARGUMENT LIST */
       95 
       96 
       97 	call cu_$arg_count (nargs);
       98 arg_get:	call cu_$arg_ptr (arg_no, argp, argl, code);
       99 	if code ^= 0 then go to err_nomsg;
      100 	if arg_no = 1 then go to key;
      101 
      102 	if substr (arg, 1, 1) = "-" then go to ctl_arg;	/* control argument found */
      103 
      104 	if ncom >= 40 then do;			/* too many command name arguments ? */
      105 	     code = error_table_$too_many_names;
      106 	     go to err_nomsg;
      107 	end;
      108 
      109 	if argl > 32 then do;			/* command name argument too long ? */
      110 	     code = error_table_$bigarg;
      111 	     go to arg_err;
      112 	end;
      113 
      114 	ncom = ncom + 1;
      115 	comlist (ncom) = arg;
      116 	go to arg_loop;
      117 
      118 ctl_arg:	if add | print then				/* for add or print requests only: */
      119 	     if arg = "-tt" | arg = "-total" then do;	/*   check for "-total" option */
      120 	     total_only = "1"b;
      121 	     go to arg_loop;
      122 	end;
      123 
      124 	if delete | print then			/* for delete or print requests only: */
      125 	     if arg = "-a" | arg = "-all" then do;	/*   check for "-all" option */
      126 	     all = "1"b;
      127 	     go to arg_loop;
      128 	end;
      129 
      130 	if print then				/* for print requests only: */
      131 	     if arg = "-ft" | arg = "-first" then do;	/*   check for "-first n" option */
      132 	     arg_no = arg_no + 1;
      133 	     call cu_$arg_ptr (arg_no, argp, argl, code);
      134 	     if code ^= 0 then go to err_nomsg;
      135 	     first = cv_dec_check_ (arg, code);
      136 	     if code ^= 0 then do;
      137 		code = error_table_$bad_conversion;
      138 		go to arg_err;
      139 	     end;
      140 	     go to arg_loop;
      141 	end;
      142 
      143 	if print then				/* for print requests only: */
      144 	     if arg = "-cl" | arg = "-clear" then do;	/*   check for "-clear" option */
      145 	     clear = "1"b;
      146 	     go to arg_loop;
      147 	end;
      148 
      149 	if print then				/* for print requests only: */
      150 	     if arg = "-brief" | arg = "-bf" then do;	/*   check for "-brief" option */
      151 	     header = "1"b;				/* don't print heading */
      152 	     go to arg_loop;
      153 	end;
      154 
      155 	code = error_table_$badopt;			/* unknown control option */
      156 	go to arg_err;
      157 
      158 key:	if arg = "pr" | arg = "print" then do;		/* print request */
      159 	     print = "1"b;
      160 	     go to arg_loop;
      161 	end;
      162 	if arg = "add" then do;			/* add request */
      163 	     add = "1"b;
      164 	     go to arg_loop;
      165 	end;
      166 	if arg = "dl" | arg = "delete" then do;		/* delete request */
      167 	     delete = "1"b;
      168 	     go to arg_loop;
      169 	end;
      170 	code = error_table_$badcall;			/* unknown key argument */
      171 	go to arg_err;
      172 
      173 arg_loop: arg_no = arg_no + 1;
      174 	if arg_no <= nargs then go to arg_get;
      175 
      176 
      177 
      178 /* CHECK ARGUMENT CONSISTENCY */
      179 
      180 
      181 	if all & ncom ^= 0 then do;
      182 	     code = error_table_$inconsistent;
      183 	     message = "-all and " || comlist (1);
      184 	     go to err_msg;
      185 	end;
      186 	if total_only & first ^= user_list_size then do;
      187 	     code = error_table_$inconsistent;
      188 	     message = "-total and -first";
      189 	     go to err_msg;
      190 	end;
      191 
      192 	if ncom = 0 then				/* add request must specify a command name list */
      193 	     if add | (delete & ^all) then do;		/* "-all" is default for print, but not for delete */
      194 	     code = error_table_$noarg;
      195 	     go to err_nomsg;
      196 	end;
      197 
      198 
      199 /* INITIATE LIST AND TOTALS SEGMENTS */
      200 
      201 	call hcs_$make_ptr (null, "command_usage_list_", "", usage_list_ptr, code);
      202 	if code ^= 0 then go to list_err;
      203 
      204 	call hcs_$make_ptr (null, "command_usage_totals_", "", usage_totals_ptr, code);
      205 	if code ^= 0 then go to totals_err;
      206 
      207 
      208 /* SET LOCK FOR MODIFICATION REQUESTS */
      209 
      210 
      211 	if add | delete | clear then do;		/* if any modification of the control or */
      212 	     if ^usage_list.locked then do;		/* usage segments is requested, then set */
      213 		usage_list.locked = "1"b;		/* a lock against other modification requests */
      214 		i_locked_it = "1"b;			/* remember to reset the lock */
      215 
      216 		on cleanup begin;			/* reset lock if aborted */
      217 		     usage_list.locked = "0"b;	/* entrance to this condition proves */
      218 		end;				/* that i set lock */
      219 
      220 	     end;
      221 	     else do;				/* lock is already set */
      222 		code = error_table_$seglock;
      223 		message = "command_usage_list_^/The command list is being edited - try again later.";
      224 		go to err_msg;
      225 	     end;
      226 	end;
      227 
      228 	list_size = usage_list.n_commands;		/* copy command name list size */
      229 
      230 	if add then go to add_com;
      231 
      232 
      233 /* PROCESS PRINT AND DELETE REQUESTS */
      234 
      235 
      236 	if list_size = 0 then do;			/* see if anything is there to process. */
      237 	     code = error_table_$zero_length_seg;
      238 	     message = "command_usage_list_^/The command name list is empty.";
      239 	     go to err_msg;
      240 	end;
      241 	if print & ^total_only then do;		/* get a scratch segment if needed */
      242 	     call get_temp_segment_ ((me), user_list_ptr, code);
      243 	     if user_list_ptr = null () then go to temp_err;
      244 	end;
      245 
      246 /* If we are deleting entries, things get juggled around, so turn off usage
      247*   monitoring for a few milliseconds.  We don't want to set a lock that would
      248*   be waited on by any process executing any command (including one attempting
      249*   to reset that lock).  Losing a few tallies isn't that important. */
      250 
      251 	if delete then usage_list.n_commands = 0;
      252 
      253 	if ncom ^= 0 then go to select;		/* print or delete selected entries */
      254 
      255 	do k = 1 to list_size;			/* print or delete all entries */
      256 	     if commands.primary (k) then call print_or_delete; /* process each command name group */
      257 	end;
      258 	if ^delete then go to print_done;
      259 						/* we just deleted every thing, so */
      260 						/* truncate segments to zero length */
      261 	call hcs_$truncate_seg (usage_list_ptr, 0, code);
      262 	if code ^= 0 then go to list_err;
      263 	call hcs_$truncate_seg (usage_totals_ptr, 0, code);
      264 	if code ^= 0 then go to totals_err;
      265 						/* Note: truncating command_usage_list_ resets the lock */
      266 	return;					/* so just return */
      267 
      268 select:	do j = 1 to ncom;				/* go through list of command name arguments */
      269 	     do k = 1 to list_size;			/* find name in the control list */
      270 		if commands.name (k) = comlist (j) then go to found;
      271 	     end;
      272 	     go to next_com;			/* not there, print error message when done */
      273 found:	     if ^commands.primary (k) then k = commands.slot (k);	/* get the primary entry of the command group */
      274 	     call print_or_delete;			/* process command group */
      275 	     comlist (j) = "";			/* clear argument from list to say we did it */
      276 next_com: end;
      277 
      278 	if delete then do;				/* truncate control segment */
      279 	     call hcs_$truncate_seg (usage_list_ptr, fixed (rel (addr (commands.name (list_size+1)))), code);
      280 	     if code ^= 0 then go to list_err;
      281 	     usage_list.n_commands = list_size;		/* turn monitoring back on */
      282 	end;
      283 	do j = 1 to ncom;				/* check for names not found */
      284 	     if comlist (j) ^= "" then
      285 		call com_err_ (error_table_$noentry, (me), "^a", comlist (j));
      286 	end;
      287 print_done:
      288 	if print & ^total_only then
      289 	     call release_temp_segment_ ((me), user_list_ptr, (0));
      290 
      291 	go to quit;				/* done */
      292 
      293 
      294 /* PROCESS ADD REQUESTS */
      295 
      296 
      297 add_com:	if list_size = 0 then do;			/* initialize */
      298 	     call hcs_$fs_get_path_name (usage_totals_ptr, usage_list.directory, k, "", code);
      299 	     if code ^= 0 then go to totals_err;
      300 	     call hcs_$truncate_seg (usage_totals_ptr, 0, code);
      301 	     if code ^= 0 then go to totals_err;
      302 	end;
      303 
      304 	do k = 1 to list_size;			/* check for duplication of command names */
      305 	     do j = 1 to ncom;
      306 		if commands.name (k) = comlist (j) then do;
      307 		     code = error_table_$namedup;
      308 		     message = comlist (j) || "^/Command name already in table.";
      309 		     go to err_msg;
      310 		end;
      311 	     end;
      312 	     if commands.primary (k) then last_index = commands.slot (k); /* locate last used index in totals list */
      313 	end;
      314 
      315           usage_list_size = ncom + list_size;
      316 	if usage_list_size > 7000 then do;
      317 	     code = error_table_$notalloc;		/* would adding this command group make too many ? */
      318 	     message = "command_usage_list_^/The command name list is full.";
      319 	     go to err_msg;
      320 	end;
      321 
      322 	if ^total_only then do;			/* if creating a user usage segment, */
      323 	     if length (comlist (1)) < 27 then go to add_user_seg; /* check length of the first command name */
      324 	     do j = 2 to ncom;			/* too long - search names for a shorter one */
      325 		if length (comlist (j)) < 27 then do;	/* found one - move to the front of the list */
      326 		     tempstring = comlist (1);
      327 		     comlist (1) = comlist (j);
      328 		     comlist (j) = tempstring;
      329 		     go to add_user_seg;
      330 		end;
      331 	     end;
      332 
      333 	     code = error_table_$bigarg;
      334 	     message = "Some command name must be less than 27 characters long.^/Add request ignored.";
      335 	     go to err_msg;
      336 
      337 add_user_seg:  
      338 	     userseg_name = comlist (1) || ".usage";	/* create segment name */
      339 	     call hcs_$make_seg (usage_list.directory, userseg_name, "", 01011b, user_list_ptr, code);
      340 	     if user_list_ptr = null then go to userseg_err;
      341 	     call copy_acl_ (usage_list.directory, "command_usage_totals_",
      342 	     usage_list.directory, userseg_name, errsw, code);
      343 	     if code ^= 0 then
      344 		if errsw then go to userseg_err;
      345 	     else go to totals_err;
      346 
      347 	     call hcs_$truncate_seg (user_list_ptr, 0, code); /* truncate segment */
      348 	     if code ^= 0 then go to userseg_err;
      349 
      350 	     call hcs_$terminate_noname (user_list_ptr, code); /* done with user segment */
      351 	     if code ^= 0 then go to userseg_err;
      352 
      353 	end;
      354 
      355 	do j = 1 to ncom;
      356 	     commands.name (list_size+j) = comlist (j);	/* copy command name to list entry */
      357 	     commands.primary (list_size+j) = "0"b;		/* say entry is not a primary one */
      358 	     commands.slot (list_size+j) = list_size + 1;	/* make secondaries point to primary entry */
      359 	end;
      360 
      361 	commands.primary (list_size+1) = "1"b;		/* now make the first entry a primary entry */
      362 	commands.slot (list_size+1) = last_index + 1;	/* it's slot element points to the usage totals tally */
      363 	commands.count_users (list_size+1) = ^total_only;	/* says whether a user usage segment exists */
      364 	usage_totals (last_index + 1) = 0;		/* clear usage total tally */
      365 	usage_list.n_commands = list_size + ncom;		/* finally increase size of command name list */
      366 
      367 
      368 
      369 /* EXIT */
      370 
      371 
      372 quit:	if i_locked_it then usage_list.locked = "0"b;	/* if lock set by this process, reset it */
      373 	return;
      374 	
      375 
      376 /* INTERNAL PROCEDURE TO PROCESS A SINGLE PRINT OR DELETE REQUEST */
      377 
      378 
      379 print_or_delete: proc;
      380 dcl  j fixed bin;
      381 
      382 	     if delete then go to delete_com;
      383 
      384 	     if ^header then do;			/* heading needed */
      385 		if total_only then
      386 
      387 		     call ioa_ ("USAGE^-COMMAND^/COUNT^-GROUP^/");
      388 		else
      389 		call ioa_ ("USAGE^-COMMAND^-USER^-USER^/COUNT^-GROUP^-COUNT^-NAME^/");
      390 		header = "1"b;			/* heading now printed */
      391 	     end;
      392 
      393 	     total = usage_totals (commands.slot (k));	/* save usage total */
      394 
      395 	     if clear then				/* reset total if clearing */
      396 		usage_totals (commands.slot (k)) = 0;
      397 
      398 	     if commands.count_users (k) then			/* if a user usage segment exists and */
      399 		if ^total_only | clear then do;	/* we need it, then initiate it */
      400 
      401 		userseg_name = commands.name (k) || ".usage"; /* segment name */
      402 		call hcs_$initiate (usage_list.directory, userseg_name, "", 0, 1, segptr, code);
      403 		if segptr = null () then go to userseg_err;
      404 
      405 		if ^total_only then			/* if printing user counts, copy them to temporary */
      406 		     user_list_ptr -> user_list = segptr -> user_list;
      407 
      408 		if clear then do;			/* reset user counts if clearing */
      409 		     call hcs_$truncate_seg (segptr, 0, code);
      410 		     if code ^= 0 then go to userseg_err;
      411 		end;
      412 
      413 		call hcs_$terminate_noname (segptr, code); /* done with segment */
      414 		if code ^= 0 then go to userseg_err;
      415 
      416 	     end;
      417 
      418 	     call ioa_ ("^5d^-^a", total, commands.name (k));	/* now do the printing */
      419 	     do i = k+1 to list_size while (^commands.primary (i));
      420 		call ioa_ ("^-^a", commands.name (i));	/* print all names in the command group */
      421 	     end;
      422 
      423 	     if ^commands.count_users (k) | total_only then return;
      424 
      425 	     do i = 1 to user_list_size;			/* print the user usage counts */
      426 		maxj = 1;				/* in descending order */
      427 		do j = 1 to user_list_size;		/* find the largest tally */
      428 		     if user_list.count (j) > user_list.count (maxj) then maxj = j;
      429 		end;
      430 
      431 		if user_list.count (maxj) = 0 then go to end_of_print; /* if the largest is zero, then done */
      432 		if i > first then go to end_of_print;	/* check -first n value */
      433 		total = total - user_list.count (maxj);	/* check user counts against total */
      434 
      435 		tempstring = user_list.name (maxj);	/* copy user identifcation */
      436 		j = index (tempstring, "*");		/* form is "person.project.*" */
      437 		if j ^= 0 then			/* we want only "person.project" */
      438 		     tempstring = substr (tempstring, 1, j-2);
      439 		call ioa_ ("^2-^5d^-^a", user_list.count (maxj), tempstring); /* print a line */
      440 		user_list.count (maxj) = 0;		/* clear this entry and repeat */
      441 	     end;
      442 
      443 end_of_print:  if total > 0 then			/* print result of error check */
      444 		call ioa_ ("^2-^5d^-^a", total, "all others");
      445 	     call ioa_ ("");
      446 	     return;
      447 
      448 delete_com:    if commands.count_users (k) then do;		/* is there a user usage segment ? */
      449 		userseg_name = commands.name (k) || ".usage"; /* yes */
      450 		call hcs_$delentry_file (usage_list.directory, userseg_name, code); /* delete it */
      451 		if code ^= 0 then go to userseg_err;
      452 	     end;
      453 	     if all then return;			/* if deleting everything, the following is not needed */
      454 
      455 	     do i = commands.slot (k) to user_list_size;		/* move total tallies past deleted one down by one */
      456 		usage_totals (i) = usage_totals (i+1);
      457 	     end;
      458 
      459 	     do i = k+1 to list_size while (^commands.primary (i)); /* find size of command group we are deleting */
      460 	     end;
      461 	     i = i - k;				/* "i" is now the size */
      462 
      463 	     do j = k to list_size;			/* move command entries past this group down */
      464 		commands.name (j) = commands.name (j+i);
      465 		commands.primary (j) = commands.primary (j+i);
      466 		if commands.primary (j) then commands.slot (j) = commands.slot (j+i) - 1; /* total tally moved down one */
      467 		else commands.slot (j) = commands.slot (j+i) - i;	/* primary entry moved down by i */
      468 		commands.count_users (j) = commands.count_users (j+i);
      469 	     end;
      470 	     list_size = list_size - i;		/* shorten command list length */
      471 	     return;				/* done */
      472 	end print_or_delete;
      473 	
      474 
      475 /* ERROR ROUTINES */
      476 
      477 
      478 arg_err:	call com_err_ (code, (me), arg);		/* never called with lock set */
      479 	return;
      480 
      481 list_err: message = "command_usage_list_";
      482 	go to err_msg;
      483 
      484 totals_err: message = "command_usage_totals_";
      485 	go to err_msg;
      486 
      487 userseg_err: message = userseg_name;
      488 	go to err_msg;
      489 
      490 temp_err: message = "temporay segment";
      491 
      492 err_msg:	if i_locked_it then				/* may be called with lock set */
      493 	     if delete & ^all then usage_list.n_commands = list_size;
      494 	call com_err_ (code, (me), message);
      495 	go to quit;
      496 
      497 err_nomsg: call com_err_ (code, (me));			/* never called with lock set */
      498 	return;
      499 
      500      end command_usage_count;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/08/83  1408.9  command_usage_count.pl1           >special_ldd>on>09/08/83>command_usage_count.pl1
59           1    09/08/83  1408.9  command_usage.incl.pl1            >special_ldd>on>09/08/83>command_usage.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
add                             000750 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 118 163* 192
                                                                                  211 230
addr                                                   builtin function         dcl 92 ref 279 279
all                             000751 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 126* 181 192
                                                                                  453 492
arg                                    based           char                     unaligned dcl 36 set ref 102 115 118 118 124 124 130
                                                                                  130 135* 143 143 149 149 158 158 162 166 166 478*
arg_no                          000156 automatic       fixed bin(17,0)          initial dcl 40 set ref 40* 98* 100 132* 132 133*
                                                                                  173* 173 174
argl                            000152 automatic       fixed bin(17,0)          dcl 36 set ref 98* 102 109 115 118 118 124 124 130
                                                                                  130 133* 135 135 143 143 149 149 158 158 162 166
                                                                                  166 478 478
argp                            000154 automatic       pointer                  dcl 36 set ref 98* 102 115 118 118 124 124 130 130
                                                                                  133* 135 143 143 149 149 158 158 162 166 166 478
cleanup                         000762 stack reference condition                dcl 90 ref 216
clear                           000752 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 145* 211 395
                                                                                  398 408
code                            000100 automatic       fixed bin(35,0)          dcl 27 set ref 98* 99 105* 110* 133* 134 135* 136
                                                                                  137* 155* 170* 182* 187* 194* 201* 202 204* 205
                                                                                  222* 237* 242* 261* 262 263* 264 279* 280 298* 299
                                                                                  300* 301 307* 317* 333* 339* 341* 343 347* 348
                                                                                  350* 351 402* 409* 410 413* 414 450* 451 478* 494*
                                                                                  497*
com_err_                        000010 constant        entry                    external dcl 61 ref 284 478 494 497
comlist                         000160 automatic       varying char(32)         array dcl 43 set ref 115* 183 270 275* 284 284* 306
                                                                                  308 323 325 326 327* 327 328* 337 356
commands                 54            based           structure                array level 2 dcl 1-5
copy_acl_                       000012 constant        entry                    external dcl 61 ref 341
count                    10            based           fixed bin(35,0)          array level 2 dcl 1-19 set ref 428 428 431 433 439*
                                                                                  440*
count_users              65(19)        based           bit(1)                   array level 3 packed unaligned dcl 1-5 set ref 363*
                                                                                  398 423 448 468* 468
cu_$arg_count                   000014 constant        entry                    external dcl 61 ref 97
cu_$arg_ptr                     000016 constant        entry                    external dcl 61 ref 98 133
cv_dec_check_                   000020 constant        entry                    external dcl 61 ref 135
delete                          000753 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 124 167* 192
                                                                                  211 251 258 278 382 492
directory                 2            based           char(168)                level 2 packed unaligned dcl 1-5 set ref 298* 339*
                                                                                  341* 341* 402* 450*
error_table_$bad_conversion     000052 external static fixed bin(35,0)          dcl 77 ref 137
error_table_$badcall            000046 external static fixed bin(35,0)          dcl 77 ref 170
error_table_$badopt             000050 external static fixed bin(35,0)          dcl 77 ref 155
error_table_$bigarg             000054 external static fixed bin(35,0)          dcl 77 ref 110 333
error_table_$inconsistent       000056 external static fixed bin(35,0)          dcl 77 ref 182 187
error_table_$namedup            000060 external static fixed bin(35,0)          dcl 77 ref 307
error_table_$noarg              000062 external static fixed bin(35,0)          dcl 77 ref 194
error_table_$noentry            000064 external static fixed bin(35,0)          dcl 77 set ref 284*
error_table_$notalloc           000066 external static fixed bin(35,0)          dcl 77 ref 317
error_table_$seglock            000070 external static fixed bin(35,0)          dcl 77 ref 222
error_table_$too_many_names     000072 external static fixed bin(35,0)          dcl 77 ref 105
error_table_$zero_length_seg    000074 external static fixed bin(35,0)          dcl 77 ref 237
errsw                           000101 automatic       bit(1)                   unaligned dcl 27 set ref 341* 343
first                           000102 automatic       fixed bin(17,0)          initial dcl 27 set ref 27* 135* 186 432
fixed                                                  builtin function         dcl 92 ref 279 279
get_temp_segment_               000040 constant        entry                    external dcl 61 ref 242
hcs_$delentry_file              000022 constant        entry                    external dcl 61 ref 450
hcs_$fs_get_path_name           000024 constant        entry                    external dcl 61 ref 298
hcs_$initiate                   000026 constant        entry                    external dcl 61 ref 402
hcs_$make_ptr                   000030 constant        entry                    external dcl 61 ref 201 204
hcs_$make_seg                   000032 constant        entry                    external dcl 61 ref 339
hcs_$terminate_noname           000034 constant        entry                    external dcl 61 ref 350 413
hcs_$truncate_seg               000036 constant        entry                    external dcl 61 ref 261 263 279 300 347 409
header                          000754 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 151* 384 390*
i                               000731 automatic       fixed bin(17,0)          dcl 46 set ref 419* 419* 420* 425* 432* 455* 456
                                                                                  456* 459* 459* 461* 461 464 465 466 467 467 468
                                                                                  470
i_locked_it                     000755 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 214* 372 492
index                                                  builtin function         dcl 92 ref 436
ioa_                            000044 constant        entry                    external dcl 61 ref 385 388 418 420 439 443 445
j                               000732 automatic       fixed bin(17,0)          dcl 46 in procedure "cuc" set ref 268* 270 275* 283*
                                                                                  284 284* 305* 306 308* 324* 325 327 328* 355* 356
                                                                                  356 357 358*
j                               001006 automatic       fixed bin(17,0)          dcl 380 in procedure "print_or_delete" set ref 427*
                                                                                  428 428* 436* 437 437 463* 464 464 465 465 466 466
                                                                                  466 467 467 468 468*
k                               000733 automatic       fixed bin(17,0)          dcl 46 set ref 255* 256* 269* 270* 273 273* 273 298*
                                                                                  304* 306 312 312* 393 395 398 401 418 419 423 448
                                                                                  449 455 459 461 463
last_index                      000103 automatic       fixed bin(17,0)          initial dcl 27 set ref 27* 312* 362 364
length                                                 builtin function         dcl 92 ref 323 325
list_size                       000734 automatic       fixed bin(17,0)          dcl 46 set ref 228* 236 255 269 279 279 281 297 304
                                                                                  315 356 357 358 358 361 362 363 365 419 459 463
                                                                                  470* 470 492
locked                    1            based           bit(1)                   level 2 dcl 1-5 set ref 212 213* 217* 372*
maxj                            000735 automatic       fixed bin(17,0)          dcl 46 set ref 426* 428 428* 431 433 435 439 440
me                              000000 constant        char(19)                 initial unaligned dcl 27 ref 242 284 287 478 494 497
message                         000104 automatic       varying char(80)         dcl 27 set ref 183* 188* 223* 238* 308* 318* 334*
                                                                                  481* 484* 487* 490* 494*
n_commands                             based           fixed bin(17,0)          level 2 dcl 1-5 set ref 228 251* 281* 365* 492*
name                                   based           char(32)                 array level 2 in structure "user_list" dcl 1-19
                                                                                  in procedure "cuc" set ref 435
name                     54            based           varying char(32)         array level 3 in structure "usage_list" dcl 1-5
                                                                                  in procedure "cuc" set ref 270 279 279 306 356*
                                                                                  401 418* 420* 449 464* 464
nargs                           000157 automatic       fixed bin(17,0)          dcl 40 set ref 97* 174
ncom                            000730 automatic       fixed bin(17,0)          initial dcl 43 set ref 43* 104 114* 114 115 181 192
                                                                                  253 268 283 305 315 324 355 365
null                                                   builtin function         dcl 92 ref 201 201 204 204 243 340 403
primary                  65(18)        based           bit(1)                   array level 3 packed unaligned dcl 1-5 set ref 256
                                                                                  273 312 357* 361* 419 459 465* 465 466
print                           000756 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 118 124 130 143
                                                                                  149 159* 241 287
rel                                                    builtin function         dcl 92 ref 279 279
release_temp_segment_           000042 constant        entry                    external dcl 61 ref 287
segptr                          000742 automatic       pointer                  dcl 48 set ref 402* 403 405 409* 413*
slot                     65            based           fixed bin(17,0)          array level 3 packed unaligned dcl 1-5 set ref 273
                                                                                  312 358* 362* 393 395 455 466* 466 467* 467
substr                                                 builtin function         dcl 92 ref 102 437
tempstring                      000131 automatic       varying char(32)         dcl 27 set ref 326* 328 435* 436 437* 437 439*
total                           000736 automatic       fixed bin(17,0)          dcl 46 set ref 393* 418* 433* 433 443 443*
total_only                      000757 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 120* 186 241
                                                                                  287 322 363 385 398 405 423
usage_list                             based           structure                level 1 dcl 1-5
usage_list_ptr                  000740 automatic       pointer                  dcl 48 set ref 201* 212 213 217 228 251 256 261* 270
                                                                                  273 273 279* 279 279 281 298 306 312 312 339 341
                                                                                  341 356 357 358 361 362 363 365 372 393 395 398
                                                                                  401 402 418 419 420 423 448 449 450 455 459 464
                                                                                  464 465 465 466 466 466 467 467 468 468 492
usage_list_size                 000760 automatic       fixed bin(17,0)          dcl 1-23 set ref 315* 316
usage_totals                           based           fixed bin(35,0)          array dcl 1-16 set ref 364* 393 395* 456* 456
usage_totals_ptr                000744 automatic       pointer                  dcl 48 set ref 204* 263* 298* 300* 364 393 395 456
                                                                                  456
user_list                              based           structure                array level 1 dcl 1-19 set ref 405* 405
user_list_ptr                   000746 automatic       pointer                  dcl 48 set ref 242* 243 287* 339* 340 347* 350* 405
                                                                                  428 428 431 433 435 439 440
user_list_size                         constant        fixed bin(17,0)          initial dcl 1-24 ref 27 186 405 425 427 455
userseg_name                    000142 automatic       char(32)                 unaligned dcl 27 set ref 337* 339* 341* 401* 402*
                                                                                  449* 450* 487

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
size                                                   builtin function         dcl 92

NAMES DECLARED BY EXPLICIT CONTEXT.
add_com                         001465 constant        label                    dcl 297 ref 230
add_user_seg                    001742 constant        label                    dcl 337 ref 323 329
arg_err                         002221 constant        label                    dcl 478 ref 111 138 156 171
arg_get                         000330 constant        label                    dcl 98 ref 174
arg_loop                        000645 constant        label                    dcl 173 ref 116 121 127 140 146 152 160 164 168
command_usage_count             000313 constant        entry                    external dcl 23
ctl_arg                         000413 constant        label                    dcl 118 ref 102
cuc                             000303 constant        entry                    external dcl 23
delete_com                      003127 constant        label                    dcl 448 ref 382
end_of_print                    003062 constant        label                    dcl 443 ref 431 432
err_msg                         002302 constant        label                    dcl 492 ref 184 189 224 239 309 319 335 482 485 488
err_nomsg                       002342 constant        label                    dcl 497 ref 99 106 134 195
found                           001302 constant        label                    dcl 273 ref 270
key                             000602 constant        label                    dcl 158 ref 100
list_err                        002253 constant        label                    dcl 481 ref 202 262 280
next_com                        001317 constant        label                    dcl 276 ref 272
print_done                      001430 constant        label                    dcl 287 ref 258
print_or_delete                 002366 constant        entry                    internal dcl 379 ref 256 274
quit                            002214 constant        label                    dcl 372 ref 291 495
select                          001242 constant        label                    dcl 268 ref 253
temp_err                        002275 constant        label                    dcl 490 ref 243
totals_err                      002261 constant        label                    dcl 484 set ref 205 264 299 301 345
userseg_err                     002267 constant        label                    dcl 487 ref 340 343 348 351 403 410 414 451

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3660        3756    3337        3670
Length      4232    3337        76         240     320           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cuc                                 670 external procedure  is an external procedure.  
on unit on line 216                  64 on unit               
print_or_delete                         internal procedure  shares stack frame of external procedure cuc.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cuc                      000100 code                        cuc
                         000101 errsw                       cuc
                         000102 first                       cuc
                         000103 last_index                  cuc
                         000104 message                     cuc
                         000131 tempstring                  cuc
                         000142 userseg_name                cuc
                         000152 argl                        cuc
                         000154 argp                        cuc
                         000156 arg_no                      cuc
                         000157 nargs                       cuc
                         000160 comlist                     cuc
                         000730 ncom                        cuc
                         000731 i                           cuc
                         000732 j                           cuc
                         000733 k                           cuc
                         000734 list_size                   cuc
                         000735 maxj                        cuc
                         000736 total                       cuc
                         000740 usage_list_ptr              cuc
                         000742 segptr                      cuc
                         000744 usage_totals_ptr            cuc
                         000746 user_list_ptr               cuc
                         000750 add                         cuc
                         000751 all                         cuc
                         000752 clear                       cuc
                         000753 delete                      cuc
                         000754 header                      cuc
                         000755 i_locked_it                 cuc
                         000756 print                       cuc
                         000757 total_only                  cuc
                         000760 usage_list_size             cuc
                         001006 j                           print_or_delete

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              enable              shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      copy_acl_                     cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 get_temp_segment_             hcs_$delentry_file            hcs_$fs_get_path_name
hcs_$initiate                 hcs_$make_ptr                 hcs_$make_seg                 hcs_$terminate_noname
hcs_$truncate_seg             ioa_                          release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$badcall          error_table_$badopt           error_table_$bigarg
error_table_$inconsistent     error_table_$namedup          error_table_$noarg            error_table_$noentry
error_table_$notalloc         error_table_$seglock          error_table_$too_many_names   error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000262        40 000265        43 000267        50 000270        23 000302        97 000321        98 000330
     99 000345       100 000347       102 000352       104 000357       105 000362       106 000365       109 000366
    110 000371       111 000374       114 000375       115 000376       116 000412       118 000413       120 000430
    121 000432       124 000433       126 000450       127 000452       130 000453       132 000466       133 000467
    134 000504       135 000506       136 000533       137 000535       138 000540       140 000541       143 000542
    145 000555       146 000557       149 000560       151 000573       152 000575       155 000576       156 000601
    158 000602       159 000614       160 000616       162 000617       163 000623       164 000625       166 000626
    167 000636       168 000640       170 000641       171 000644       173 000645       174 000646       181 000651
    182 000655       183 000660       184 000701       186 000703       187 000710       188 000713       189 000720
    192 000721       194 000731       195 000734       201 000735       202 000772       204 000774       205 001031
    211 001033       212 001041       213 001044       214 001046       216 001047       217 001063       218 001066
    220 001067       222 001070       223 001073       224 001100       228 001101       230 001103       236 001105
    237 001107       238 001112       239 001117       241 001120       242 001124       243 001153       251 001157
    253 001162       255 001164       256 001173       257 001201       258 001203       261 001205       262 001221
    263 001223       264 001237       266 001241       268 001242       269 001251       270 001261       271 001277
    272 001301       273 001302       274 001313       275 001314       276 001317       278 001321       279 001323
    280 001346       281 001350       283 001352       284 001361       286 001426       287 001430       291 001464
    297 001465       298 001467       299 001521       300 001523       301 001537       304 001541       305 001551
    306 001561       307 001577       308 001602       309 001624       311 001626       312 001630       313 001642
    315 001644       316 001647       317 001651       318 001654       319 001661       322 001662       323 001664
    324 001667       325 001677       326 001704       327 001711       328 001720       329 001726       331 001727
    333 001731       334 001734       335 001741       337 001742       339 001760       340 002021       341 002025
    343 002065       345 002072       347 002073       348 002107       350 002111       351 002122       355 002124
    356 002133       357 002151       358 002153       359 002160       361 002162       362 002170       363 002201
    364 002207       365 002211       372 002214       373 002220       478 002221       479 002252       481 002253
    482 002260       484 002261       485 002266       487 002267       488 002274       490 002275       492 002302
    494 002312       495 002341       497 002342       498 002365       379 002366       382 002367       384 002371
    385 002373       388 002412       390 002426       393 002430       395 002437       398 002445       401 002457
    402 002477       403 002544       405 002550       408 002561       409 002563       410 002577       413 002601
    414 002612       418 002614       419 002644       420 002662       421 002704       423 002706       425 002717
    426 002727       427 002731       428 002741       429 002754       431 002756       432 002764       433 002767
    435 002776       436 003004       437 003016       439 003024       440 003054       441 003060       443 003062
    445 003115       446 003126       448 003127       449 003135       450 003155       451 003177       453 003201
    455 003204       456 003217       457 003223       459 003225       460 003242       461 003244       463 003246
    464 003255       465 003273       466 003277       467 003313       468 003321       469 003325       470 003327
    471 003331


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
