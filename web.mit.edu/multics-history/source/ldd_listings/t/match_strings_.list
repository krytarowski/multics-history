	COMPILATION LISTING OF SEGMENT match_strings_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/03/85  0811.9 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style2 */
        7 match_strings_:
        8      procedure ();
        9 
       10 /* *	MATCH_STRINGS_
       11*   *
       12*   *	This is a general-purpose utility procedure for matching a string
       13*   *	against some set of previously supplied -match or -exclude strings.
       14*   *	It detects regular expressions automatically by the surrounding slash
       15*   *	delimiters and handles them by calling search_file_.
       16*   *
       17*   *	Created for new print_sys_log, 84-06-10, W. Olin Sibert
       18*   *	Modified 1984-10-24 BIM for $print, fixed end processing.
       19*   *      Modified 1984-11-30 BIM for indent in $print.
       20*   *	Modified 1985-05-01 Steve Herbst to initialize match_info.string_info (i) to zero.
       21**/
       22 
       23 	declare P_IOCB_ptr		 pointer;
       24 	declare P_indent		 fixed bin;
       25 	declare P_match_info_ptr	 pointer parameter;
       26 	declare P_match_string	 char (*) parameter;
       27 	declare P_match_sw		 bit (1) aligned parameter;
       28 	declare P_tested_string	 char (*) parameter;
       29 	declare P_title		 char (*) parameter;
       30 
       31 	declare match_info_ptr	 pointer;
       32 	declare match_info_max_strings fixed bin;
       33 	declare match_info_area	 area based (match_info.area_ptr);
       34 
       35 	declare match_string_ptr	 pointer;
       36 	declare match_string_lth	 fixed bin (21);
       37 	declare match_string	 char (match_string_lth) based (match_string_ptr);
       38 
       39 	declare 1 match_info	 aligned based (match_info_ptr),
       40 		2 header		 aligned,
       41 		  3 area_ptr	 pointer,
       42 		  3 max_strings	 fixed bin,
       43 		  3 n_strings	 fixed bin,
       44 		2 string_info	 (match_info_max_strings refer (match_info.max_strings)),
       45 		  3 string_ptr	 pointer unaligned,
       46 		  3 string_lth	 fixed bin (21),
       47 		  3 flags		 aligned,
       48 		    4 exclude_sw	 bit (1) unaligned,
       49 		    4 begin_sw	 bit (1) unaligned,
       50 		    4 end_sw	 bit (1) unaligned,
       51 		    4 regexp_sw	 bit (1) unaligned,
       52 		    4 pad		 bit (32) unaligned,
       53 		2 end		 fixed bin;
       54 
       55 	declare tested_string_ptr	 pointer;
       56 	declare tested_string_lth	 fixed bin (21);
       57 	declare tested_string	 char (tested_string_lth) based (tested_string_ptr);
       58 
       59 	declare get_system_free_area_	 entry () returns (pointer);
       60 	declare ioa_$ioa_switch	 entry () options (variable);
       61 
       62 
       63 	declare DEFAULT_SIZE	 fixed bin internal static options (constant) init (10);
       64 	declare REGEXP_CHARS	 char (3) internal static options (constant) init ("\.*");
       65 	declare REGEXP_SLASH	 char (1) internal static options (constant) init ("/");
       66 	declare BEGIN_CHAR		 char (1) internal static options (constant) init ("^");
       67 	declare END_CHAR		 char (1) internal static options (constant) init ("$");
       68 
       69 	declare (addcharno, addr, index, length, null, substr, unspec, verify)
       70 				 builtin;
       71 
       72 /**/
       73 
       74 match_strings_$test:
       75      entry (P_match_info_ptr, P_tested_string) returns (bit (1) aligned);
       76 
       77 	match_info_ptr = P_match_info_ptr;
       78 	tested_string_ptr = addr (P_tested_string);
       79 	tested_string_lth = length (P_tested_string);
       80 
       81 	if (match_info_ptr = null ())
       82 	then return ("1"b);
       83 	if (match_info.n_strings = 0)
       84 	then return ("1"b);
       85 
       86 	return (do_match ());
       87 
       88 
       89 
       90 match_strings_$add:
       91      entry (P_match_info_ptr, P_match_sw, P_match_string);
       92 
       93 	match_info_ptr = P_match_info_ptr;
       94 	match_string_ptr = addr (P_match_string);
       95 	match_string_lth = length (P_match_string);
       96 
       97 	call add_string (P_match_sw, "0"b);
       98 
       99 	P_match_info_ptr = match_info_ptr;		/* In case it changed */
      100 	return;
      101 
      102 match_strings_$add_literal:				/* force exact match of test without regexp's */
      103      entry (P_match_info_ptr, P_match_sw, P_match_string);
      104 
      105 	match_info_ptr = P_match_info_ptr;
      106 	match_string_ptr = addr (P_match_string);
      107 	match_string_lth = length (P_match_string);
      108 
      109 	call add_string (P_match_sw, "1"b);
      110 
      111 	P_match_info_ptr = match_info_ptr;		/* In case it changed */
      112 	return;
      113 
      114 
      115 match_strings_$free:
      116      entry (P_match_info_ptr);
      117 
      118 	match_info_ptr = P_match_info_ptr;
      119 	P_match_info_ptr = null ();
      120 
      121 	call free_match_info ();
      122 
      123 	return;
      124 
      125 match_strings_$print:
      126      entry (P_IOCB_ptr, P_indent, P_title, P_match_info_ptr);
      127 
      128 	match_info_ptr = P_match_info_ptr;
      129 	if match_info_ptr = null ()
      130 	then return;
      131 
      132 	call print_strings;
      133 	return;
      134 
      135 /**/
      136 
      137 do_match:
      138      procedure () returns (bit (1) aligned);
      139 
      140 	declare match_idx		 fixed bin;
      141 	declare match_result	 bit (1) aligned;
      142 	declare final_result	 bit (1) aligned;
      143 
      144 
      145 /* If the first argument was -exclude, then the result is ALL strings except
      146*   those excluded.	Contrariwise, if the first argument was -match, then the
      147*   result is NO strings except those matching.  So, we start out by setting
      148*   the final result to the first exclude_sw value. */
      149 
      150 	final_result = match_info.exclude_sw (1);
      151 
      152 /* Version 2 selector:  Consider each match string in turn.	 If the string
      153*   followed -match, and the message matches it, then set the result to true.
      154*   If the string followed -exclude, and the message matches it, then set the
      155*   result to false.	 Otherwise, leave the result alone.
      156*
      157*   This is simpler than version 1, which was simply ridiculous. Gary Dixon
      158*   has a more complicated version that I don't understand how to implement
      159*   or describe, but which may be better (New_Log_primitives [0146]).
      160**/
      161 
      162 	do match_idx = 1 to match_info.n_strings;
      163 	     match_result = try_match ();
      164 
      165 	     if match_result
      166 	     then if match_info.exclude_sw (match_idx)
      167 		then final_result = "0"b;
      168 		else final_result = "1"b;
      169 	end;
      170 
      171 	return (final_result);
      172 
      173 /**/
      174 
      175 try_match:
      176      procedure () returns (bit (1) aligned);
      177 
      178 	declare match_string_ptr	 pointer;
      179 	declare match_string_lth	 fixed bin (21);
      180 	declare match_string	 char (match_string_lth) based (match_string_ptr);
      181 
      182 /* This procedure applies tests according to the various flags in the match_info
      183*   structure. It returns immediately when it knows it has a match failure, but
      184*   otherwise falls through to the end where it indicates success. It is then
      185*   the caller's job to interpret the exclude_sw properly. */
      186 
      187 
      188 	match_string_ptr = match_info.string_ptr (match_idx);
      189 	match_string_lth = match_info.string_lth (match_idx);
      190 
      191 	if match_info.regexp_sw (match_idx)
      192 	then return (try_regexp_match ());
      193 
      194 	if (match_info.begin_sw (match_idx)) & (match_info.end_sw (match_idx))
      195 	then do;
      196 		if (match_string_lth ^= tested_string_lth)
      197 		then return ("0"b);
      198 		if (match_string ^= tested_string)
      199 		then return ("0"b);
      200 		return ("1"b);
      201 	     end;
      202 
      203 	if (match_info.begin_sw (match_idx))
      204 	then do;
      205 		if (match_string_lth > tested_string_lth)
      206 		then return ("0"b);
      207 		if (substr (tested_string, 1, match_string_lth) ^= match_string)
      208 		then return ("0"b);
      209 		if ^match_info.end_sw (match_idx)
      210 		then return ("1"b);			/* passes all available tests */
      211 	     end;
      212 
      213 	if (match_info.end_sw (match_idx))
      214 	then do;
      215 		if (match_string_lth > tested_string_lth)
      216 		then return ("0"b);
      217 		if (substr (tested_string, (tested_string_lth - match_string_lth + 1)) ^= match_string)
      218 		then return ("0"b);
      219 		return ("1"b);			/* begin tested, end passes */
      220 	     end;
      221 
      222 /**** Here iff there is no ^ or $ or difficult regexp */
      223 
      224 	if (match_string_lth > tested_string_lth)
      225 	then return ("0"b);
      226 
      227 	if (index (tested_string, match_string) = 0)
      228 	then return ("0"b);
      229 
      230 	return ("1"b);
      231 
      232 try_regexp_match:
      233      procedure returns (bit (1) aligned);
      234 
      235 	declare search_file_$silent	 entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21),
      236 				 fixed binary (21), fixed binary (21), fixed binary (21), fixed binary (35));
      237 	declare sf_code		 fixed bin (35);
      238 	declare must_fake_NL	 bit (1) aligned;
      239 
      240 	must_fake_NL = "0"b;
      241 	if substr (match_string, match_string_lth, 1) = END_CHAR
      242 	then if match_string_lth < 3
      243 	     then must_fake_NL = "1"b;
      244 	     else if substr (match_string, match_string_lth - 2, 3) ^= "\c$"
      245 	     then must_fake_NL = "1"b;
      246 
      247 	if ^must_fake_NL
      248 	then call search_file_$silent (match_string_ptr, 1, match_string_lth, addr (tested_string), 1,
      249 		tested_string_lth, (0), (0), sf_code);
      250 	else begin;
      251 		declare longer_tested_string	 char (tested_string_lth + 1);
      252 		longer_tested_string = tested_string || byte (10);
      253 		call search_file_$silent (match_string_ptr, 1, match_string_lth, addr (longer_tested_string), 1,
      254 		     tested_string_lth + 1, (0), (0), sf_code);
      255 	     end;
      256 	return (sf_code = 0);
      257      end try_regexp_match;
      258      end try_match;
      259 
      260      end do_match;
      261 
      262 /**/
      263 
      264 add_string:
      265      procedure (P_match_sw, P_literal_sw);
      266 
      267 
      268 	declare P_match_sw		 bit (1) aligned parameter;
      269 	declare P_literal_sw	 bit (1) aligned parameter;
      270 	declare new_idx		 fixed bin;
      271 	declare new_string_ptr	 pointer;
      272 	declare new_string_lth	 fixed bin (21);
      273 	declare new_string		 char (new_string_lth) based (new_string_ptr);
      274 
      275 
      276 	if (match_info_ptr = null ())
      277 	then call reallocate_match_info (DEFAULT_SIZE);
      278 
      279 	else if (match_info.n_strings >= match_info.max_strings)
      280 	then call reallocate_match_info (match_info.n_strings + DEFAULT_SIZE);
      281 
      282 	new_idx = match_info.n_strings + 1;		/* Use the next entry */
      283 	unspec (match_info.flags (new_idx)) = "0"b;
      284 	match_info.exclude_sw (new_idx) = ^P_match_sw;
      285 
      286 
      287 /* For string matching, there are three flags:
      288*
      289*   1) regexp_sw -- when this is set, search_file_ is called for this string
      290*   each message. Regular expressions are signalled by slashes surrounding
      291*   the string. Since search_file_ is rather expensive, however, the string
      292*   is examined to see whether it is a trivial regular expression, involving
      293*   only the begin ("^") or end ("$") character, in which case, regexp_sw
      294*   is turned off, and one or both of the following two are turned on:
      295*   2) begin_sw -- when set, indicates that the message must begin with this
      296*   string to match.
      297*   3) end_sw -- when set, indicates that the message must end with this string
      298*   to match.
      299*
      300*   Testing for these conditions is the purpose of the set of tests below. If
      301*   the string is a regular expression, its start and length are adjusted to
      302*   remove the slashes; similarly, if it is determined to be one of the two
      303*   trivial cases, the leading/trailing regexp character must be removed.
      304*   Note that detection of the trivial cases does not include cases where the
      305*   only regexp characters are escaped with backslash-C; this didn't seem
      306*   worth it, and, in fact, any string containing backslashes is considered
      307*   non-trivial. */
      308 
      309 
      310 	if ^P_literal_sw
      311 	then if (length (match_string) > 2)
      312 	     then /* See explanation above for details of this code */
      313 		if (substr (match_string, 1, 1) = REGEXP_SLASH)
      314 		then if (substr (match_string, length (match_string), 1) = REGEXP_SLASH)
      315 		     then do;
      316 			     match_string_ptr = addcharno (match_string_ptr, 1);
      317 			     match_string_lth = match_string_lth - 2;
      318 			     if (search (match_string, REGEXP_CHARS) = 0)
      319 			     then do;		/* trivial regexp */
      320 				     if (length (match_string) > 1)
      321 				     then if (substr (match_string, 1, 1) = BEGIN_CHAR)
      322 					then do;
      323 						match_info.begin_sw (new_idx) = "1"b;
      324 						match_string_lth = match_string_lth - 1;
      325 						match_string_ptr = addcharno (match_string_ptr, 1);
      326 					     end;
      327 
      328 				     if (length (match_string) > 2)
      329 				     then if (substr (match_string, length (match_string), 1) = END_CHAR)
      330 					then do;
      331 						match_info.end_sw (new_idx) = "1"b;
      332 						match_string_lth = match_string_lth - 1;
      333 					     end;
      334 				end;		/* Of trivial regexp case */
      335 			     else do;		/* non-trivial! */
      336 				     match_info.regexp_sw (new_idx) = "1"b;
      337 
      338 				     if (length (match_string) > 2)
      339 				     then /* Test for trimming a trailing "$" */
      340 					if (substr (match_string, length (match_string) - 1, 1) = END_CHAR)
      341 					then match_string_lth = match_string_lth - 1;
      342 				end;		/* of hard regexp case */
      343 			end;			/* Of regexp case */
      344 
      345 	new_string_lth = match_string_lth;		/* Now, allocate a copy for later use in matching */
      346 	allocate new_string in (match_info_area) set (new_string_ptr);
      347 
      348 	new_string = match_string;			/* Copy from our (adjusted) caller's string */
      349 
      350 	match_info.string_ptr (new_idx) = new_string_ptr;
      351 	match_info.string_lth (new_idx) = new_string_lth;
      352 	if P_literal_sw
      353 	then match_info.begin_sw (new_idx), match_info.end_sw (new_idx) = "1"b;
      354 	match_info.n_strings = new_idx;		/* Adjust the count to include this one */
      355 
      356 	return;
      357      end add_string;
      358 
      359 /**/
      360 
      361 reallocate_match_info:
      362      procedure (P_size);
      363 
      364 	declare P_size		 fixed bin parameter;
      365 
      366 	declare nmi_ptr		 pointer;
      367 	declare old_size		 fixed bin;
      368 	declare nmi_idx		 fixed bin;
      369 	declare system_area_ptr	 pointer;
      370 	declare system_area		 area based (system_area_ptr);
      371 
      372 
      373 	match_info_max_strings = P_size;
      374 	system_area_ptr = get_system_free_area_ ();
      375 
      376 	if (match_info_ptr = null ())
      377 	then old_size = 0;
      378 	else old_size = match_info.n_strings;
      379 
      380 	allocate match_info in (system_area) set (nmi_ptr);
      381 
      382 	if (match_info_ptr ^= null ())
      383 	then nmi_ptr -> match_info.header = match_info.header;
      384 	else unspec (nmi_ptr -> match_info) = ""b;
      385 
      386 	nmi_ptr -> match_info.max_strings = match_info_max_strings;
      387 	nmi_ptr -> match_info.area_ptr = system_area_ptr;
      388 
      389 	do nmi_idx = 1 to old_size;
      390 	     nmi_ptr -> match_info.string_info (nmi_idx) = match_info.string_info (nmi_idx);
      391 	end;
      392 
      393 	do nmi_idx = (old_size + 1) to nmi_ptr -> match_info.max_strings;
      394 	     unspec (nmi_ptr -> match_info.string_info (nmi_idx)) = "0"b;
      395 	     nmi_ptr -> match_info.string_ptr (nmi_idx) = null ();
      396 	end;
      397 
      398 	if (match_info_ptr ^= null ())
      399 	then free match_info in (system_area);
      400 
      401 	match_info_ptr = nmi_ptr;
      402 	return;
      403      end reallocate_match_info;
      404 
      405 /**/
      406 
      407 free_match_info:
      408      procedure ();
      409 
      410 	declare mi_idx		 fixed bin;
      411 
      412 
      413 	if (match_info_ptr = null ())
      414 	then return;
      415 
      416 	do mi_idx = 1 to match_info.n_strings;
      417 	     match_string_ptr = match_info.string_ptr (mi_idx);
      418 	     match_string_lth = match_info.string_lth (mi_idx);
      419 	     free match_string in (match_info_area);
      420 	end;
      421 
      422 	free match_info in (match_info_area);
      423 	match_info_ptr = null ();
      424 
      425 	return;
      426      end free_match_info;
      427 
      428 print_strings:
      429      procedure;
      430 
      431 	declare sx		 fixed bin;
      432 	declare 1 csi		 aligned like match_info.string_info based (csip);
      433 	declare csip		 pointer;
      434 	declare cstring		 char (csi.string_lth) based (csi.string_ptr);
      435 
      436 	if match_info.header.n_strings = 0
      437 	then return;
      438 	call ioa_$ioa_switch (P_IOCB_ptr, "^vx^a match and exclude strings:", P_indent, P_title);
      439 	do sx = 1 to match_info.n_strings;
      440 	     csip = addr (match_info.string_info (sx));
      441 	     call ioa_$ioa_switch (P_IOCB_ptr, "^vx  ^[match  ^;exclude^] ^[/^]^[^^^]^a^[$^]^[/^]", P_indent,
      442 		^csi.flags.exclude_sw, csi.flags.regexp_sw | csi.flags.begin_sw | csi.flags.end_sw,
      443 		csi.flags.begin_sw, cstring, csi.flags.end_sw,
      444 		csi.flags.regexp_sw | csi.flags.begin_sw | csi.flags.end_sw);
      445 	end;
      446 	return;
      447      end print_strings;
      448 
      449      end match_strings_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/03/85  0807.2  match_strings_.pl1                >special_ldd>online>sys_log.pbf-05/03/85>match_strings_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BEGIN_CHAR                      002105 constant        char(1)                  initial unaligned dcl 66 ref 320
DEFAULT_SIZE                           constant        fixed bin(17,0)          initial dcl 63 set ref 276* 279
END_CHAR                        002104 constant        char(1)                  initial unaligned dcl 67 ref 241 328 338
P_IOCB_ptr                             parameter       pointer                  dcl 23 set ref 125 438* 441*
P_indent                               parameter       fixed bin(17,0)          dcl 24 set ref 125 438* 441*
P_literal_sw                           parameter       bit(1)                   dcl 269 ref 264 310 352
P_match_info_ptr                       parameter       pointer                  dcl 25 set ref 74 77 90 93 99* 102 105 111* 115 118
                                                                                  119* 125 128
P_match_string                         parameter       char                     unaligned dcl 26 set ref 90 94 95 102 106 107
P_match_sw                             parameter       bit(1)                   dcl 27 in procedure "match_strings_" set ref 90 97*
                                                                                  102 109*
P_match_sw                             parameter       bit(1)                   dcl 268 in procedure "add_string" ref 264 284
P_size                                 parameter       fixed bin(17,0)          dcl 364 ref 361 373
P_tested_string                        parameter       char                     unaligned dcl 28 set ref 74 78 79
P_title                                parameter       char                     unaligned dcl 29 set ref 125 438*
REGEXP_CHARS                    000000 constant        char(3)                  initial unaligned dcl 64 ref 318
REGEXP_SLASH                    002106 constant        char(1)                  initial unaligned dcl 65 ref 310 310
addcharno                                              builtin function         dcl 69 ref 316 325
addr                                                   builtin function         dcl 69 ref 78 94 106 247 247 253 253 440
area_ptr                               based           pointer                  level 3 dcl 39 set ref 346 387* 419 422
begin_sw                  6(01)        based           bit(1)                   array level 4 in structure "match_info" packed
                                                                                  unaligned dcl 39 in procedure "match_strings_" set
                                                                                  ref 194 203 323* 352*
begin_sw                  2(01)        based           bit(1)                   level 3 in structure "csi" packed unaligned dcl 432
                                                                                  in procedure "print_strings" set ref 441 441* 441
csi                                    based           structure                level 1 dcl 432
csip                            000224 automatic       pointer                  dcl 433 set ref 440* 441 441 441 441 441 441 441 441
                                                                                  441 441 441 441
cstring                                based           char                     unaligned dcl 434 set ref 441*
end_sw                    2(02)        based           bit(1)                   level 3 in structure "csi" packed unaligned dcl 432
                                                                                  in procedure "print_strings" set ref 441 441* 441
end_sw                    6(02)        based           bit(1)                   array level 4 in structure "match_info" packed
                                                                                  unaligned dcl 39 in procedure "match_strings_" set
                                                                                  ref 194 209 213 331* 352*
exclude_sw                2            based           bit(1)                   level 3 in structure "csi" packed unaligned dcl 432
                                                                                  in procedure "print_strings" ref 441
exclude_sw                6            based           bit(1)                   array level 4 in structure "match_info" packed
                                                                                  unaligned dcl 39 in procedure "match_strings_" set
                                                                                  ref 150 165 284*
final_result                    000126 automatic       bit(1)                   dcl 142 set ref 150* 165* 168* 171
flags                     6            based           structure                array level 3 in structure "match_info" dcl 39
                                                                                  in procedure "match_strings_" set ref 283*
flags                     2            based           structure                level 2 in structure "csi" dcl 432 in procedure
                                                                                  "print_strings"
get_system_free_area_           000010 constant        entry                    external dcl 59 ref 374
header                                 based           structure                level 2 dcl 39 set ref 382* 382
index                                                  builtin function         dcl 69 ref 227
ioa_$ioa_switch                 000012 constant        entry                    external dcl 60 ref 438 441
length                                                 builtin function         dcl 69 ref 79 95 107 310 310 320 328 328 338 338
longer_tested_string            000100 automatic       char                     unaligned dcl 251 set ref 252* 253 253
match_idx                       000124 automatic       fixed bin(17,0)          dcl 140 set ref 162* 165* 188 189 191 194 194 203
                                                                                  209 213
match_info                             based           structure                level 1 dcl 39 set ref 380 384* 398 422
match_info_area                        based           area(1024)               dcl 33 ref 346 419 422
match_info_max_strings          000102 automatic       fixed bin(17,0)          dcl 32 set ref 373* 380 380 386
match_info_ptr                  000100 automatic       pointer                  dcl 31 set ref 77* 81 83 93* 99 105* 111 118* 128*
                                                                                  129 150 162 165 188 189 191 194 194 203 209 213
                                                                                  276 279 279 279 282 283 284 323 331 336 346 350
                                                                                  351 352 352 354 376 378 382 382 390 398 398 401*
                                                                                  413 416 417 418 419 422 422 423* 436 439 440
match_result                    000125 automatic       bit(1)                   dcl 141 set ref 163* 165
match_string                           based           char                     unaligned dcl 180 in procedure "try_match" ref 198
                                                                                  207 217 227 241 244
match_string                           based           char                     unaligned dcl 37 in procedure "match_strings_" ref
                                                                                  310 310 310 310 318 320 320 328 328 328 338 338
                                                                                  338 348 419
match_string_lth                000140 automatic       fixed bin(21,0)          dcl 179 in procedure "try_match" set ref 189* 196
                                                                                  198 205 207 207 215 217 217 224 227 241 241 241
                                                                                  244 244 247* 253*
match_string_lth                000106 automatic       fixed bin(21,0)          dcl 36 in procedure "match_strings_" set ref 95*
                                                                                  107* 310 310 310 310 317* 317 318 320 320 324* 324
                                                                                  328 328 328 332* 332 338 338 338 338* 338 345 348
                                                                                  418* 419 419
match_string_ptr                000136 automatic       pointer                  dcl 178 in procedure "try_match" set ref 188* 198
                                                                                  207 217 227 241 244 247* 253*
match_string_ptr                000104 automatic       pointer                  dcl 35 in procedure "match_strings_" set ref 94*
                                                                                  106* 310 310 310 310 316* 316 318 320 320 325* 325
                                                                                  328 328 328 338 338 338 348 417* 419
max_strings               2            based           fixed bin(17,0)          level 3 dcl 39 set ref 279 380* 384 386* 393 398 422
mi_idx                          000212 automatic       fixed bin(17,0)          dcl 410 set ref 416* 417 418*
must_fake_NL                    000151 automatic       bit(1)                   dcl 238 set ref 240* 241* 244* 247
n_strings                 3            based           fixed bin(17,0)          level 3 dcl 39 set ref 83 162 279 279 282 354* 378
                                                                                  416 436 439
new_idx                         000160 automatic       fixed bin(17,0)          dcl 270 set ref 282* 283 284 323 331 336 350 351 352
                                                                                  352 354
new_string                             based           char                     unaligned dcl 273 set ref 346 348*
new_string_lth                  000164 automatic       fixed bin(21,0)          dcl 272 set ref 345* 346 346 348 351
new_string_ptr                  000162 automatic       pointer                  dcl 271 set ref 346* 348 350
nmi_idx                         000177 automatic       fixed bin(17,0)          dcl 368 set ref 389* 390 390* 393* 394 395*
nmi_ptr                         000174 automatic       pointer                  dcl 366 set ref 380* 382 384 386 387 390 393 394 395
                                                                                  401
null                                                   builtin function         dcl 69 ref 81 119 129 276 376 382 395 398 413 423
old_size                        000176 automatic       fixed bin(17,0)          dcl 367 set ref 376* 378* 389 393
regexp_sw                 2(03)        based           bit(1)                   level 3 in structure "csi" packed unaligned dcl 432
                                                                                  in procedure "print_strings" ref 441 441
regexp_sw                 6(03)        based           bit(1)                   array level 4 in structure "match_info" packed
                                                                                  unaligned dcl 39 in procedure "match_strings_" set
                                                                                  ref 191 336*
search_file_$silent             000014 constant        entry                    external dcl 235 ref 247 253
sf_code                         000150 automatic       fixed bin(35,0)          dcl 237 set ref 247* 253* 256
string_info               4            based           structure                array level 2 dcl 39 set ref 390* 390 394* 440
string_lth                1            based           fixed bin(21,0)          level 2 in structure "csi" dcl 432 in procedure
                                                                                  "print_strings" ref 441 441
string_lth                5            based           fixed bin(21,0)          array level 3 in structure "match_info" dcl 39
                                                                                  in procedure "match_strings_" set ref 189 351* 418
string_ptr                             based           pointer                  level 2 in structure "csi" packed unaligned dcl 432
                                                                                  in procedure "print_strings" ref 441
string_ptr                4            based           pointer                  array level 3 in structure "match_info" packed
                                                                                  unaligned dcl 39 in procedure "match_strings_" set
                                                                                  ref 188 350* 395* 417
substr                                                 builtin function         dcl 69 ref 207 217 241 244 310 310 320 328 338
sx                              000222 automatic       fixed bin(17,0)          dcl 431 set ref 439* 440*
system_area                            based           area(1024)               dcl 370 ref 380 398
system_area_ptr                 000200 automatic       pointer                  dcl 369 set ref 374* 380 387 398
tested_string                          based           char                     unaligned dcl 57 set ref 198 207 217 227 247 247 252
tested_string_lth               000112 automatic       fixed bin(21,0)          dcl 56 set ref 79* 196 198 205 207 215 217 217 224
                                                                                  227 247 247 247* 251 252 253
tested_string_ptr               000110 automatic       pointer                  dcl 55 set ref 78* 198 207 217 227 247 247 252
unspec                                                 builtin function         dcl 69 set ref 283* 384* 394*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
verify                                                 builtin function         dcl 69

NAMES DECLARED BY EXPLICIT CONTEXT.
add_string                      001060 constant        entry                    internal dcl 264 ref 97 109
do_match                        000427 constant        entry                    internal dcl 137 ref 86
free_match_info                 001436 constant        entry                    internal dcl 407 ref 121
match_strings_                  000052 constant        entry                    external dcl 7
match_strings_$add              000172 constant        entry                    external dcl 90
match_strings_$add_literal      000247 constant        entry                    external dcl 102
match_strings_$free             000325 constant        entry                    external dcl 115
match_strings_$print            000361 constant        entry                    external dcl 125
match_strings_$test             000066 constant        entry                    external dcl 74
print_strings                   001503 constant        entry                    internal dcl 428 ref 132
reallocate_match_info           001264 constant        entry                    internal dcl 361 ref 276 279
try_match                       000476 constant        entry                    internal dcl 175 ref 163
try_regexp_match                000663 constant        entry                    internal dcl 232 ref 191

NAMES DECLARED BY CONTEXT OR IMPLICATION.
byte                                                   builtin function         ref 252
search                                                 builtin function         ref 318

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2272        2310    2107        2302
Length      2504    2107        16         157     163           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
match_strings_                      286 external procedure  is an external procedure.  
do_match                                internal procedure  shares stack frame of external procedure match_strings_.  
try_match                               internal procedure  shares stack frame of external procedure match_strings_.  
try_regexp_match                        internal procedure  shares stack frame of external procedure match_strings_.  
begin block on line 250              96 begin block         uses auto adjustable storage.  
add_string                              internal procedure  shares stack frame of external procedure match_strings_.  
reallocate_match_info                   internal procedure  shares stack frame of external procedure match_strings_.  
free_match_info                         internal procedure  shares stack frame of external procedure match_strings_.  
print_strings                           internal procedure  shares stack frame of external procedure match_strings_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 250  000100 longer_tested_string        begin block on line 250
match_strings_           000100 match_info_ptr              match_strings_
                         000102 match_info_max_strings      match_strings_
                         000104 match_string_ptr            match_strings_
                         000106 match_string_lth            match_strings_
                         000110 tested_string_ptr           match_strings_
                         000112 tested_string_lth           match_strings_
                         000124 match_idx                   do_match
                         000125 match_result                do_match
                         000126 final_result                do_match
                         000136 match_string_ptr            try_match
                         000140 match_string_lth            try_match
                         000150 sf_code                     try_regexp_match
                         000151 must_fake_NL                try_regexp_match
                         000160 new_idx                     add_string
                         000162 new_string_ptr              add_string
                         000164 new_string_lth              add_string
                         000174 nmi_ptr                     reallocate_match_info
                         000176 old_size                    reallocate_match_info
                         000177 nmi_idx                     reallocate_match_info
                         000200 system_area_ptr             reallocate_match_info
                         000212 mi_idx                      free_match_info
                         000222 sx                          print_strings
                         000224 csip                        print_strings

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            enter_begin         leave_begin         call_ext_out_desc   call_ext_out
return              alloc_auto_adj      signal              shorten_stack       ext_entry           ext_entry_desc
set_cs_eis          index_cs_eis        alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_system_free_area_         ioa_$ioa_switch               search_file_$silent

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000051        74 000061        77 000105        78 000110        79 000113        81 000115        83 000132
     86 000145        90 000166        93 000212        94 000215        95 000220        97 000222        99 000234
    100 000236       102 000245       105 000267       106 000272       107 000275       109 000277       111 000311
    112 000313       115 000322       118 000337       119 000342       121 000344       123 000345       125 000354
    128 000401       129 000404       132 000417       133 000420       137 000427       150 000431       162 000435
    163 000445       165 000453       168 000466       169 000470       171 000472       175 000476       188 000500
    189 000505       191 000511       194 000530       196 000543       198 000550       200 000560       203 000563
    205 000565       207 000572       209 000601       213 000606       215 000610       217 000615       219 000635
    224 000640       227 000645       230 000657       232 000663       240 000665       241 000666       244 000702
    247 000710       250 000751       251 000754       252 000765       253 001010       255 001052       256 001053
    264 001060       276 001062       279 001071       282 001101       283 001105       284 001107       310 001117
    316 001137       317 001142       318 001144       320 001157       323 001166       324 001170       325 001172
    328 001175       331 001204       332 001206       334 001210       336 001211       338 001213       345 001224
    346 001226       348 001236       350 001244       351 001247       352 001251       354 001261       356 001263
    361 001264       373 001266       374 001270       376 001277       378 001305       380 001310       382 001321
    384 001333       386 001344       387 001346       389 001350       390 001357       391 001371       393 001373
    394 001405       395 001413       396 001417       398 001421       401 001433       402 001435       407 001436
    413 001437       416 001444       417 001455       418 001461       419 001464       420 001470       422 001472
    423 001500       425 001502       428 001503       436 001504       438 001510       439 001542       440 001553
    441 001557       445 001667       446 001671


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
