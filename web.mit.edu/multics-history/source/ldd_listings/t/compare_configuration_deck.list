	COMPILATION LISTING OF SEGMENT compare_configuration_deck
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/09/85  1123.1 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 compare_configuration_deck:
        7      procedure () options (variable);
        8 
        9 /* *	Utility command to compare running config deck with saved copy, print
       10*   *	out differences.
       11*   *
       12*   *	Created: 02/17/80, W. Olin Sibert, from print_configuration_deck.
       13*   *	Modified: 02/01/84, Keith Loepere for -label, also to allow
       14*   *	   comparison of two decks, neither the config_deck. */
       15 
       16 	dcl     (argno, nargs)	 fixed bin;
       17 	dcl     (al, rsl)		 fixed bin (21);
       18 	dcl     (ap, rsp)		 pointer;
       19 	dcl     arg		 char (al) based (ap);
       20 	dcl     rs		 char (rsl) varying based (rsp);
       21 	dcl     code		 fixed bin (35);
       22 	dcl     whoami		 char (32);
       23 	dcl     (idx, jdx)		 fixed bin;
       24 	dcl     brief_sw		 bit (1) aligned;
       25 	dcl     af_sw		 bit (1) aligned;
       26 	dcl     label_output	 bit (1) aligned;
       27 
       28 	dcl     (old_dname, new_dname) char (168);	/* also pathname for messages */
       29 	dcl     (old_ename, new_ename) char (32);
       30 	dcl     (old_dp, new_dp)	 pointer;
       31 	dcl     (old_bc, new_bc)	 fixed bin (24);
       32 	dcl     (old_recs, new_recs)	 fixed bin;
       33 	dcl     (old_max_recs, new_max_recs) fixed bin;
       34 	dcl     card_str		 char (256) varying;
       35 
       36 /* The limit of 32 on the size of the changed_cards array is part of the heuristics
       37*   used to decide whether the decks are "completely different". It is 32 because
       38*   that is a convenient number, rather than from some sort of sacred principle. */
       39 
       40 	dcl     n_changed		 fixed bin;
       41 	dcl     1 changed_cards	 (32) aligned,	/* indices of changed cards */
       42 		2 old		 fixed bin,
       43 		2 new		 fixed bin;
       44 
       45 	dcl     n_old_mem_cards	 fixed bin;
       46 	dcl     n_new_mem_cards	 fixed bin;
       47 
       48 	dcl     1 mem_cards		 (16) aligned,	/* should never be more than 16 memories, right? */
       49 		2 old_idx		 fixed bin,
       50 		2 old_port	 fixed bin (35),
       51 		2 new_idx		 fixed bin,
       52 		2 new_port	 fixed bin (35);
       53 
       54 	dcl     decks_different	 bit (1) aligned;
       55 	dcl     mem_cards_different	 bit (1) aligned;
       56 	dcl     n_added		 fixed bin;
       57 	dcl     n_deleted		 fixed bin;
       58 
       59 	dcl     added		 bit (1024) aligned;/* bits indicating which cards were added, deleted, changed */
       60 	dcl     deleted		 bit (1024) aligned;/* note that this puts a limit of 1024 cards in a config deck. */
       61 
       62 	dcl     complain		 entry variable options (variable);
       63 
       64 	dcl     active_fnc_err_	 entry options (variable);
       65 	dcl     com_err_		 entry options (variable);
       66 	dcl     config_deck_parse_$binary_to_ascii entry (ptr, char (256) var);
       67 	dcl     cu_$af_return_arg	 entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
       68 	dcl     cu_$arg_ptr		 entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
       69 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
       70 	dcl     initiate_file_	 entry (char (*), char (*), bit (*), pointer, fixed binary (24), fixed binary (35));
       71 	dcl     ioa_		 entry options (variable);
       72 	dcl     ioa_$rsnnl		 entry options (variable);
       73 	dcl     pathname_		 entry (char (*), char (*)) returns (char (168));
       74      	dcl     terminate_file_	 entry (ptr, fixed bin (24), bit (*), fixed bin (35));
       75 
       76 	dcl     (error_table_$noarg,
       77 	        error_table_$badopt)	 fixed bin (35) external static;
       78 
       79 /* The CARD_OPERANDS list defines all the cards which have several operands to
       80*   be included in the comparison before deciding whether the cards are "changed",
       81*   or deleted and added. */
       82 
       83 	dcl     1 CARD_OPERANDS	 (9) aligned internal static options (constant),
       84 		2 name		 char (4) aligned init
       85 				 ("cpu ", "iom ", "mem ", "chnl", "mpc ", "prph", "part", "udsk", "parm"),
       86 		2 count		 fixed bin init
       87 				 (1, 1, 1, 1, 2, 1, 1, 1, 1);
       88 
       89 	dcl     cleanup		 condition;
       90 
       91 	dcl     (addr, char, copy, divide, hbound, null, rtrim, substr, unspec) builtin;
       92 
       93 /*  */
       94 
       95 	whoami = "compare_configuration_deck";
       96 	old_dp = null ();
       97 	new_dp = null ();
       98 
       99 	on condition (cleanup) call clean_things_up ();
      100 
      101 	call cu_$af_return_arg (nargs, rsp, rsl, code);
      102 
      103 	if code ^= 0 then do;			/* assume it's a command */
      104 		complain = com_err_;
      105 		af_sw = "0"b;
      106 	     end;
      107 
      108 	else do;					/* otherwise, it's an AF */
      109 		complain = active_fnc_err_;
      110 		af_sw = "1"b;
      111 		rs = "";
      112 	     end;
      113 
      114 	brief_sw = "0"b;
      115 	label_output = "0"b;
      116 
      117 	do argno = 1 to nargs;
      118 	     call cu_$arg_ptr (argno, ap, al, (0));
      119 
      120 	     if char (arg, 1) ^= "-" then do;		/* a pathname, perhaps? */
      121 		     if new_dp ^= null () then do;	/* but at most two, thanks */
      122 			     call complain (0, whoami, "At most two pathnames for config decks may be supplied. ^a", arg);
      123 			     goto MAIN_RETURN;
      124 			end;
      125 
      126 		     if old_dp = null () then do;
      127 			     call expand_pathname_ (arg, old_dname, old_ename, code);
      128 			     if code ^= 0 then do;
      129 				     call complain (code, whoami, "^a", arg);
      130 				     goto MAIN_RETURN;
      131 				end;
      132 
      133 			     call initiate_file_ (old_dname, old_ename, R_ACCESS, old_dp, old_bc, code);
      134 			     if old_dp = null () then do;
      135 				     call complain (code, whoami, "^a", pathname_ (old_dname, old_ename));
      136 				     goto MAIN_RETURN;
      137 				end;
      138 			end;
      139 		     else do;			/* must be second (new) deck */
      140 			     call expand_pathname_ (arg, new_dname, new_ename, code);
      141 			     if code ^= 0 then do;
      142 				     call complain (code, whoami, "^a", arg);
      143 				     goto MAIN_RETURN;
      144 				end;
      145 
      146 			     call initiate_file_ (new_dname, new_ename, R_ACCESS, new_dp, new_bc, code);
      147 			     if new_dp = null () then do;
      148 				     call complain (code, whoami, "^a", pathname_ (new_dname, new_ename));
      149 				     goto MAIN_RETURN;
      150 				end;
      151 			end;
      152 		end;
      153 
      154 	     else if arg = "-brief" | arg = "-bf" then brief_sw = "1"b;
      155 	     else if arg = "-long" | arg = "-lg" then brief_sw = "0"b;
      156 	     else if arg = "-label" | arg = "-lbl" then label_output = "1"b;
      157 	     else if arg = "-no_label" | arg = "-nlbl" then label_output = "0"b;
      158 
      159 	     else do;
      160 		     call complain (error_table_$badopt, whoami, "^a", arg);
      161 		     goto MAIN_RETURN;
      162 		end;
      163 	end;					/* of argument loop */
      164 
      165 /*  */
      166 
      167 	config_n_cards, config_max_cards = 1;		/* eliminate compiler warning */
      168 
      169 	if old_dp = null () then do;
      170 		call complain (error_table_$noarg, whoami, "^/^5xUsage:^3x^a pathname_of_old_deck {pathname_of_new_deck} {-brief}", whoami);
      171 		goto MAIN_RETURN;
      172 	     end;
      173 
      174 	if new_dp = null () then do;			/* use system copy as new */
      175 		new_dname = ">sl1";
      176 		new_ename = "config_deck";
      177 		call initiate_file_ (new_dname, new_ename, R_ACCESS, new_dp, new_bc, code);
      178 		if new_dp = null () then do;
      179 			call com_err_ (code, whoami, "Unable to initiate >sl1>config_deck");
      180 			goto MAIN_RETURN;
      181 		     end;
      182 	     end;
      183 
      184 	old_dname = pathname_ (old_dname, old_ename);
      185 	new_dname = pathname_ (new_dname, new_ename);
      186 
      187 	old_max_recs = divide (old_bc, (36 * 16), 17, 0); /* count the cards in each deck */
      188 	new_max_recs = divide (new_bc, (36 * 16), 17, 0);
      189 
      190 	call count_cards (new_dp, new_max_recs, new_recs);
      191 	if new_recs < 0 then do;
      192 		call complain (0, whoami, "Config deck ^a appears misformatted.", new_dname);
      193 		goto MAIN_RETURN;
      194 	     end;
      195 
      196 	call count_cards (old_dp, old_max_recs, old_recs);
      197 	if old_recs < 0 then do;
      198 		call complain (0, whoami, "Config deck ^a appears misformatted.", old_dname);
      199 		goto MAIN_RETURN;
      200 	     end;
      201 
      202 
      203 	call compare_decks ();
      204 
      205 	if decks_different then do;			/* sorry, too different */
      206 		if af_sw then do;			/* just return false */
      207 			rs = "false";
      208 			goto MAIN_RETURN;
      209 		     end;
      210 
      211 		call ioa_ ("Config deck^[s differ substantially.^; ^a differs substantially from ^a.^]",
      212 		     brief_sw, new_dname, old_dname);
      213 
      214 		if brief_sw then goto MAIN_RETURN;	/* don't bother printing them */
      215 
      216 		call ioa_ ("Config deck 2 (^a):^/", new_dname);
      217 
      218 		call print_deck (new_dp, new_recs, 3);
      219 
      220 		call ioa_ ("^/Config deck 1 (^a):^/", old_dname);
      221 
      222 		call print_deck (old_dp, old_recs, 3);
      223 
      224 		call ioa_ ("");
      225 		goto MAIN_RETURN;
      226 	     end;
      227 
      228 	if (n_added = 0) & (n_deleted = 0) & (n_changed = 0) & (^mem_cards_different) then do;
      229 		if af_sw then do;
      230 			rs = "true";
      231 			goto MAIN_RETURN;
      232 		     end;
      233 
      234 		if ^brief_sw then /* no differences, report that fact, perhaps */
      235 		     call ioa_ ("Decks are identical.^/");
      236 		goto MAIN_RETURN;
      237 	     end;
      238 
      239 	if af_sw then do;				/* there are some differences... */
      240 		rs = "false";
      241 		goto MAIN_RETURN;
      242 	     end;
      243 
      244 	if n_added > 0 then do;
      245 		if ^brief_sw then
      246 		     call ioa_ ("^/Cards added in deck 2:");
      247 
      248 		do idx = 1 to new_recs;
      249 		     if substr (added, idx, 1) = "1"b then do;
      250 			     cardp = addr (new_dp -> config_deck.cards (idx));
      251 			     call get_card_str ();
      252 			     if brief_sw then
      253 				call ioa_ ("New:^2x^a", card_str);
      254 			     else call ioa_ ("^2x^a", card_str);
      255 			end;
      256 		end;
      257 	     end;					/* of processing for added cards */
      258 
      259 	if n_deleted > 0 then do;
      260 		if ^brief_sw then
      261 		     call ioa_ ("^/Cards deleted from deck 2:");
      262 
      263 		do idx = 1 to new_recs;
      264 		     if substr (deleted, idx, 1) = "1"b then do;
      265 			     cardp = addr (old_dp -> config_deck.cards (idx));
      266 			     call get_card_str ();
      267 			     if brief_sw then
      268 				call ioa_ ("Old:^2x^a", card_str);
      269 			     else call ioa_ ("^2x^a", card_str);
      270 			end;
      271 		end;
      272 	     end;					/* of processing for deleted cards */
      273 
      274 	if n_changed > 0 then do;
      275 		if ^brief_sw then
      276 		     call ioa_ ("^/Changed cards:");
      277 
      278 		do idx = 1 to n_changed;
      279 		     jdx = changed_cards.old (idx);
      280 		     cardp = addr (old_dp -> config_deck.cards (jdx));
      281 		     call get_card_str ();
      282 		     call ioa_ ("Was:^2x^a", card_str); /* format is the same here, brief or not */
      283 
      284 		     jdx = changed_cards.new (idx);
      285 		     cardp = addr (new_dp -> config_deck.cards (jdx));
      286 		     call get_card_str ();
      287 		     call ioa_ ("^6x^a", card_str);
      288 		end;
      289 	     end;					/* of processing for changed cards */
      290 
      291 	if mem_cards_different then do;		/* MEM cards are reorganized between the two decks, */
      292 		if ^brief_sw then /* so print all the MEM cards */
      293 		     call ioa_ ("^/MEM cards are reordered:");
      294 
      295 		do idx = 1 to n_old_mem_cards;
      296 		     cardp = addr (old_dp -> config_deck.cards (mem_cards.old_idx (idx)));
      297 		     call get_card_str ();
      298 		     call ioa_ ("^[Was:^2x^;^6x^]^a", (idx = 1), card_str);
      299 		end;
      300 
      301 		do idx = 1 to n_new_mem_cards;
      302 		     cardp = addr (new_dp -> config_deck.cards (mem_cards.new_idx (idx)));
      303 		     call get_card_str ();
      304 		     call ioa_ ("^[Now:^2x^;^6x^]^a", (idx = 1), card_str);
      305 		end;
      306 	     end;
      307 
      308 MAIN_RETURN:
      309 	call clean_things_up ();
      310 
      311 	return;
      312 
      313 /*  */
      314 
      315 count_cards: proc (P_dp, P_max_recs, P_recs);
      316 
      317 /* *	This procedure counts the cards in a config deck, and decides whether the
      318*   *	deck is properly formatted. */
      319 
      320 	dcl     (P_dp		 pointer,
      321 	        P_max_recs		 fixed bin,
      322 	        P_recs		 fixed bin) parameter;
      323 
      324 	dcl     idx		 fixed bin;
      325 	dcl     done		 bit (1) aligned;
      326 	dcl     count		 fixed bin;
      327 	dcl     cp		 pointer;
      328 
      329 	count = 0;
      330 	done = "0"b;
      331 
      332 	do idx = 1 to P_max_recs while (^done);		/* check format */
      333 	     cp = addr (P_dp -> config_deck.cards (idx));
      334 	     if cp -> config_card.word = FREE_CARD_WORD then done = "1"b; /* found the end */
      335 	     else count = count + 1;			/* record count */
      336 	end;
      337 
      338 	if ^done then /* indicate error */
      339 	     P_recs = -1;
      340 	else P_recs = count;			/* otherwise, return count */
      341 
      342 	return;
      343      end count_cards;
      344 
      345 /*  */
      346 
      347 get_card_str: proc ();
      348 
      349 	dcl     idx		 fixed bin;
      350 	dcl     type		 bit (2) aligned;
      351 	dcl     char_field		 char (4);
      352 	dcl     numeric_field	 fixed bin (35);
      353 	dcl     temp_str		 char (16) varying;
      354 
      355 	if label_output then call config_deck_parse_$binary_to_ascii (cardp, card_str);
      356 	else do;
      357 		card_str = config_card.word;		/* initialize output string */
      358 
      359 		do idx = 1 to config_card.n_fields;	/* look at all words of the card */
      360 		     type = config_card.field_type (idx); /* get the type for the current word */
      361 		     unspec (numeric_field) = unspec (config_card.data_field (idx));
      362 
      363 		     if type = CONFIG_OCTAL_TYPE then /* octal number */
      364 			call ioa_$rsnnl ("^o", temp_str, (0), numeric_field);
      365 
      366 		     else if type = CONFIG_SINGLE_CHAR_TYPE then /* letter, probably */
      367 			if numeric_field > 8 | numeric_field < 1 then /* apparently not? */
      368 			     call ioa_$rsnnl ("^o", temp_str, (0), numeric_field);
      369 			else temp_str = substr ("abcdefgh", numeric_field, 1);
      370 
      371 		     else if type = CONFIG_STRING_TYPE then do; /* string */
      372 			     unspec (char_field) = unspec (config_card.data_field (idx));
      373 			     temp_str = char_field;
      374 			end;
      375 
      376 		     else if type = CONFIG_DECIMAL_TYPE then /* decimal number */
      377 			call ioa_$rsnnl ("^d.", temp_str, (0), numeric_field);
      378 
      379 		     card_str = card_str || "  ";
      380 		     card_str = card_str || temp_str;
      381 		end;				/* of loop through card fields */
      382 	     end;
      383 
      384 	return;
      385      end get_card_str;
      386 
      387 /*  */
      388 
      389 compare_decks: proc ();
      390 
      391 /* *	This procedure compares the two decks, after deciding whether the
      392*   *	MEM cards should be compared directly or listed in their entirity. */
      393 
      394 	dcl     (old_idx, new_idx, idx, jdx) fixed bin;
      395 	dcl     (ocp, ncp)		 pointer;
      396 
      397 /* First, we look through each deck to find all the MEM cards. This is done so that it is possible to
      398*   detect whether the cards have been rearranged, and thus whether they should be listed. The object
      399*   of this is to only print all the mem cards if their order is interestingly different; that is, to
      400*   not print them if the only change is the turning on/off of a single memory. If there are a different
      401*   number of MEM cards in the two decks, they are de-facto assumed to have been rearranged. */
      402 
      403 	n_old_mem_cards = 0;
      404 	n_new_mem_cards = 0;
      405 
      406 	do old_idx = 1 to old_recs;			/* now, locate all the mem cards in the old deck */
      407 	     ocp = addr (old_dp -> config_deck.cards (old_idx));
      408 
      409 	     if ocp -> config_card.word = MEM_CARD_WORD then do; /* special-case MEM cards to detect reordering */
      410 		     if n_old_mem_cards >= hbound (mem_cards, 1) then
      411 			goto DECKS_DIFFERENT;
      412 
      413 		     n_old_mem_cards = n_old_mem_cards + 1;
      414 
      415 		     mem_cards (n_old_mem_cards).old_idx = old_idx; /* record info about this card */
      416 		     mem_cards (n_old_mem_cards).old_port = ocp -> mem_card.tag;
      417 		end;
      418 	end;
      419 
      420 	do new_idx = 1 to new_recs;			/* and look in the new deck, too */
      421 	     ncp = addr (new_dp -> config_deck.cards (new_idx));
      422 
      423 	     if ncp -> config_card.word = MEM_CARD_WORD then do; /* special-case MEM cards to detect reordering */
      424 		     if n_new_mem_cards >= hbound (mem_cards, 1) then
      425 			goto DECKS_DIFFERENT;
      426 
      427 		     n_new_mem_cards = n_new_mem_cards + 1;
      428 
      429 		     mem_cards (n_new_mem_cards).new_idx = new_idx; /* record info about this card */
      430 		     mem_cards (n_new_mem_cards).new_port = ncp -> mem_card.tag;
      431 		end;
      432 	end;
      433 
      434 	mem_cards_different = "0"b;
      435 
      436 	if n_old_mem_cards ^= n_new_mem_cards then /* if different counts, one has been added/deleted, so we want */
      437 	     mem_cards_different = "1"b;		/* to print out all of both sets of mem cards */
      438 
      439 	else do;					/* otherwise, look through and see if the order is the same */
      440 		do idx = 1 to n_old_mem_cards while (^mem_cards_different); /* and set the bit if it isn't */
      441 		     if mem_cards.old_port (idx) ^= mem_cards.new_port (idx) then
      442 			mem_cards_different = "1"b;
      443 		end;
      444 	     end;
      445 
      446 /* Now, run through the two decks and compare individual cards, ignoring MEM cards if
      447*   they have been determined above to be different. */
      448 
      449 	n_changed = 0;
      450 	n_added = new_recs;
      451 	n_deleted = 0;
      452 
      453 	substr (added, 1, new_recs) = copy ("1"b, new_recs); /* assume all have been added to start out with */
      454 	substr (deleted, 1, old_recs) = copy ("0"b, old_recs); /* and that none have been deleted */
      455 	decks_different = "0"b;
      456 
      457 	do old_idx = 1 to old_recs;			/* look through all cards in the original deck */
      458 	     ocp = addr (old_dp -> config_deck.cards (old_idx));
      459 
      460 	     if ocp -> config_card.word = MEM_CARD_WORD then /* special-case MEM cards if necessary */
      461 		if mem_cards_different then
      462 		     goto NEXT_OLD_CARD;
      463 
      464 	     do new_idx = 1 to new_recs;		/* compare against new cards */
      465 		if substr (added, new_idx, 1) = "0"b then /* we've already hit this one, and gotten */
      466 		     goto NEXT_NEW_CARD;		/* something from it, so don't compare again */
      467 
      468 		ncp = addr (new_dp -> config_deck.cards (new_idx));
      469 
      470 		if ncp -> config_card.word = MEM_CARD_WORD then /* ignore MEM cards, if necessary */
      471 		     if mem_cards_different then
      472 			goto NEXT_NEW_CARD;		/* and consider the next new card for comparison */
      473 
      474 		if unspec (ocp -> config_card) = unspec (ncp -> config_card) then /* identical cards */
      475 		     goto IDENTICAL;
      476 
      477 		if ocp -> config_card.word ^= ncp -> config_card.word then /* see if they're similar */
      478 		     goto DIFFERENT;
      479 
      480 /* This loop tests to see whether the cards require any similar operands. Examples of this would be
      481*   MEM cards, PRPH cards, etc. If the card name is not found in our list of cards, it is assumed to
      482*   not need any similar operands, and thus be "changed" as long as the names are the same. */
      483 
      484 		do idx = 1 to hbound (CARD_OPERANDS, 1);/* names are the same, see if we need similar operands, too */
      485 		     if ocp -> config_card.word = CARD_OPERANDS.name (idx) then do; /* we know this card */
      486 			     do jdx = 1 to CARD_OPERANDS.count (idx); /* see if the required operands are the same */
      487 				if ocp -> config_card.data_field (jdx) ^= ncp -> config_card.data_field (jdx) then
      488 				     goto DIFFERENT;/* words are different */
      489 
      490 				if ocp -> config_card.field_type (jdx) ^= ncp -> config_card.field_type (jdx) then
      491 				     goto DIFFERENT;/* types are different */
      492 			     end;			/* of comparing required same operands */
      493 
      494 			     goto CHANGED;		/* the cards are similar */
      495 			end;			/* of checking operands for similarity */
      496 		end;				/* of loop looking for cards which need similar operands */
      497 						/* just fall through if not found */
      498 
      499 CHANGED:		if n_changed >= hbound (changed_cards, 1) then /* too many different cards. */
      500 		     goto DECKS_DIFFERENT;		/* decks are probably completely different */
      501 
      502 		n_changed = n_changed + 1;		/* record the card indices */
      503 		changed_cards.old (n_changed) = old_idx;
      504 		changed_cards.new (n_changed) = new_idx;
      505 
      506 		substr (added, new_idx, 1) = "0"b;	/* record that we've gotten something from this card */
      507 		n_added = n_added - 1;		/* update the count of added cards */
      508 		goto NEXT_OLD_CARD;			/* and get the next old card */
      509 
      510 IDENTICAL:	substr (added, new_idx, 1) = "0"b;	/* the cards are identical, so flag it as seen, and continue */
      511 		n_added = n_added - 1;		/* with the next new card */
      512 		goto NEXT_OLD_CARD;
      513 
      514 DIFFERENT:	goto NEXT_NEW_CARD;			/* if cards are different, do nothing and try the next card */
      515 
      516 NEXT_NEW_CARD: end;					/* of loop through new cards */
      517 
      518 	     substr (deleted, old_idx, 1) = "1"b;	/* if we fall out, there was no comprable card, so the old */
      519 	     n_deleted = n_deleted + 1;		/* card has been deleted */
      520 
      521 NEXT_OLD_CARD: end;					/* of loop through old cards */
      522 
      523 	if mem_cards_different then do;		/* take the MEM cards out of the "added" list */
      524 		do new_idx = 1 to new_recs;
      525 		     ncp = addr (new_dp -> config_deck.cards (new_idx));
      526 
      527 		     if ncp -> config_card.word = MEM_CARD_WORD then do;
      528 			     substr (added, new_idx, 1) = "0"b;
      529 			     n_added = n_added - 1;
      530 			end;
      531 		end;				/* of loop through cards */
      532 	     end;
      533 
      534 	if (n_added + n_deleted) > hbound (changed_cards, 1) then /* if too many, the decks are different */
      535 	     goto DECKS_DIFFERENT;
      536 
      537 	decks_different = "0"b;			/* minor differences, if at all */
      538 
      539 	return;					/* normal return */
      540 
      541 
      542 DECKS_DIFFERENT:					/* come here if the decks appear completely different */
      543 	decks_different = "1"b;
      544 	return;
      545 
      546      end compare_decks;
      547 
      548 /*  */
      549 
      550 print_deck: proc (P_dp, P_recs, P_indent);
      551 
      552 /* *	This procedure prints a config deck */
      553 
      554 	dcl     (P_dp		 pointer,
      555 	        P_recs		 fixed bin,
      556 	        P_indent		 fixed bin) parameter;
      557 
      558 	dcl     idx		 fixed bin;
      559 
      560 	do idx = 1 to P_recs;
      561 	     cardp = addr (P_dp -> config_deck.cards (idx));
      562 	     call get_card_str ();
      563 	     call ioa_ ("^vx^a", P_indent, card_str);
      564 	end;
      565 
      566 	return;
      567      end print_deck;
      568 
      569 /*  */
      570 
      571 clean_things_up: proc ();
      572 
      573 	if old_dp ^= null () then
      574 	     call terminate_file_ (old_dp, 0, TERM_FILE_TERM, (0));
      575 
      576 	if new_dp ^= null () then
      577 	     call terminate_file_ (new_dp, 0, TERM_FILE_TERM, (0));
      578 
      579 	return;
      580      end clean_things_up;
      581  /* BEGIN INCLUDE FILE ... config_deck.incl.pl1 ... 11/13/80, W. Olin Sibert */
  1     2 
  1     3 dcl (configp, cardp) pointer;
  1     4 dcl  config_n_cards fixed bin;			/* Number of cards used in config */
  1     5 dcl  config_max_cards fixed bin;			/* Max number of cards in config */
  1     6 
  1     7 dcl  config_deck$ fixed bin external static;
  1     8 
  1     9 dcl 1 config_deck aligned based (configp),
  1    10     2 cards (config_n_cards) aligned like config_card,
  1    11     2 pad_cards (config_max_cards - config_n_cards) aligned like config_card;
  1    12 
  1    13 dcl 1 config_card aligned based (cardp),
  1    14     2 word char (4) aligned,
  1    15     2 data_field (14) bit (36) aligned,
  1    16     2 type_word aligned like config_card_type_word;
  1    17 
  1    18 dcl 1 config_card_type_word aligned based,
  1    19     2 field_type (14) bit (2) unaligned,
  1    20     2 pad1 bit (4) unaligned,
  1    21     2 n_fields fixed bin (4) unsigned unaligned;
  1    22 
  1    23 dcl (CONFIG_DECIMAL_TYPE	init ("11"b),
  1    24      CONFIG_OCTAL_TYPE	init ("00"b),
  1    25      CONFIG_SINGLE_CHAR_TYPE	init ("01"b),
  1    26      CONFIG_STRING_TYPE	init ("10"b)) bit (2) aligned static options (constant);
  1    27 
  1    28 dcl  ZERO_CARD_WORD char (4) aligned internal static options (constant) init ("    ");
  1    29 dcl  FREE_CARD_WORD char (4) aligned internal static options (constant) init ("ÿÿÿÿ");
  1    30 
  1    31 dcl  VALID_CARD_WORD_CHARACTERS char (38) internal static options (constant) init
  1    32     ("abcdefghijklmnopqrstuvwxyz0123456789_.");		/* lowercase letters, digits, period and underscore */
  1    33 
  1    34 dcl  EMPTY_FIELD bit (36) aligned internal static options (constant) init ("777777777777"b3);
  1    35 
  1    36 /* END INCLUDE FILE config_deck.incl.pl1 */
      581 
      582  /* BEGIN INCLUDE FILE ... config_mem_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  2     2 
  2     3 dcl  mem_cardp pointer;				/* pointer to MEM card */
  2     4 
  2     5 dcl 1 mem_card aligned based (mem_cardp),		/* MEM card declaration */
  2     6     2 word char (4),				/* "mem" */
  2     7     2 tag fixed bin (3),				/* One more than module port to which controller is attached */
  2     8     2 size fixed bin (18),				/* Number of pages in memory controller */
  2     9     2 state char (4),				/* State: "on" or "off" */
  2    10 
  2    11     2 pad (11) bit (36) aligned,			/* Pad to 15 fields */
  2    12 
  2    13     2 type_word aligned,
  2    14       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  2    15       3 pad1 bit (4) unaligned,
  2    16       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  2    17 
  2    18 dcl  MEM_CARD_WORD char (4) aligned internal static options (constant) init ("mem");
  2    19 
  2    20 /* END INCLUDE FILE ... config_mem_card.incl.pl1 */
      582 
      583  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      583 
      584  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  4     2 /* format: style2,^inddcls,idind32 */
  4     3 
  4     4 declare 1 terminate_file_switches	based,
  4     5 	2 truncate		bit (1) unaligned,
  4     6 	2 set_bc			bit (1) unaligned,
  4     7 	2 terminate		bit (1) unaligned,
  4     8 	2 force_write		bit (1) unaligned,
  4     9 	2 delete			bit (1) unaligned;
  4    10 
  4    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  4    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  4    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  4    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  4    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  4    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  4    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  4    18 
  4    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      584 
      585      end compare_configuration_deck;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/08/85  1133.8  compare_configuration_deck.pl1    >spec>on>41-15>compare_configuration_deck.pl1
581          1    05/08/81  1853.6  config_deck.incl.pl1              >ldd>include>config_deck.incl.pl1
582          2    05/08/81  1853.6  config_mem_card.incl.pl1          >ldd>include>config_mem_card.incl.pl1
583          3    04/09/85  1109.7  access_mode_values.incl.pl1       >spec>on>41-15>access_mode_values.incl.pl1
584          4    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CARD_OPERANDS                   000000 constant        structure                array level 1 dcl 83 ref 484
CONFIG_DECIMAL_TYPE                    constant        bit(2)                   initial dcl 1-23 ref 376
CONFIG_OCTAL_TYPE                      constant        bit(2)                   initial dcl 1-23 ref 363
CONFIG_SINGLE_CHAR_TYPE                constant        bit(2)                   initial dcl 1-23 ref 366
CONFIG_STRING_TYPE                     constant        bit(2)                   initial dcl 1-23 ref 371
FREE_CARD_WORD                  003564 constant        char(4)                  initial dcl 1-29 ref 334
MEM_CARD_WORD                   000023 constant        char(4)                  initial dcl 2-18 ref 409 423 460 470 527
P_dp                                   parameter       pointer                  dcl 554 in procedure "print_deck" ref 550 561
P_dp                                   parameter       pointer                  dcl 320 in procedure "count_cards" ref 315 333
P_indent                               parameter       fixed bin(17,0)          dcl 554 set ref 550 563*
P_max_recs                             parameter       fixed bin(17,0)          dcl 320 ref 315 332
P_recs                                 parameter       fixed bin(17,0)          dcl 554 in procedure "print_deck" ref 550 560
P_recs                                 parameter       fixed bin(17,0)          dcl 320 in procedure "count_cards" set ref 315 338*
                                                                                  340*
R_ACCESS                        000070 constant        bit(3)                   initial unaligned dcl 3-11 set ref 133* 146* 177*
TERM_FILE_TERM                  000022 constant        bit(3)                   initial unaligned dcl 4-14 set ref 573* 576*
active_fnc_err_                 000010 constant        entry                    external dcl 64 ref 109
added                           000614 automatic       bit(1024)                dcl 59 set ref 249 453* 465 506* 510* 528*
addr                                                   builtin function         dcl 91 ref 250 265 280 285 296 302 333 407 421 458
                                                                                  468 525 561
af_sw                           000124 automatic       bit(1)                   dcl 25 set ref 105* 110* 206 229 239
al                              000102 automatic       fixed bin(21,0)          dcl 17 set ref 118* 120 122 122 127 127 129 129 140
                                                                                  140 142 142 154 154 155 155 156 156 157 157 160
                                                                                  160
ap                              000104 automatic       pointer                  dcl 18 set ref 118* 120 122 127 129 140 142 154 154
                                                                                  155 155 156 156 157 157 160
arg                                    based           char                     unaligned dcl 19 set ref 120 122* 127* 129* 140*
                                                                                  142* 154 154 155 155 156 156 157 157 160*
argno                           000100 automatic       fixed bin(17,0)          dcl 16 set ref 117* 118*
brief_sw                        000123 automatic       bit(1)                   dcl 24 set ref 114* 154* 155* 211* 214 234 245 252
                                                                                  260 267 275 292
card_str                        000304 automatic       varying char(256)        dcl 34 set ref 252* 254* 267* 269* 282* 287* 298*
                                                                                  304* 355* 357* 379* 379 380* 380 563*
cardp                           000720 automatic       pointer                  dcl 1-3 set ref 250* 265* 280* 285* 296* 302* 355*
                                                                                  357 359 360 361 372 561*
cards                                  based           structure                array level 2 dcl 1-9 set ref 250 265 280 285 296
                                                                                  302 333 407 421 458 468 525 561
changed_cards                   000406 automatic       structure                array level 1 dcl 41 set ref 499 534
char                                                   builtin function         dcl 91 ref 120
char_field                      000760 automatic       char(4)                  unaligned dcl 351 set ref 372* 373
cleanup                         000712 stack reference condition                dcl 89 ref 99
code                            000110 automatic       fixed bin(35,0)          dcl 21 set ref 101* 103 127* 128 129* 133* 135* 140*
                                                                                  141 142* 146* 148* 177* 179*
com_err_                        000012 constant        entry                    external dcl 65 ref 104 179
complain                        000706 automatic       entry variable           dcl 62 set ref 104* 109* 122 129 135 142 148 160 170
                                                                                  192 198
config_card                            based           structure                level 1 dcl 1-13 ref 474 474
config_card_type_word                  based           structure                level 1 dcl 1-18
config_deck                            based           structure                level 1 dcl 1-9
config_deck_parse_$binary_to_ascii
                                000014 constant        entry                    external dcl 66 ref 355
config_max_cards                000723 automatic       fixed bin(17,0)          dcl 1-5 set ref 167*
config_n_cards                  000722 automatic       fixed bin(17,0)          dcl 1-4 set ref 167*
copy                                                   builtin function         dcl 91 ref 453 454
count                     1     000000 constant        fixed bin(17,0)          initial array level 2 in structure "CARD_OPERANDS"
                                                                                  dcl 83 in procedure "compare_configuration_deck"
                                                                                  ref 486
count                           000742 automatic       fixed bin(17,0)          dcl 326 in procedure "count_cards" set ref 329* 335*
                                                                                  335 340
cp                              000744 automatic       pointer                  dcl 327 set ref 333* 334
cu_$af_return_arg               000016 constant        entry                    external dcl 67 ref 101
cu_$arg_ptr                     000020 constant        entry                    external dcl 68 ref 118
data_field                1            based           bit(36)                  array level 2 dcl 1-13 ref 361 372 487 487
decks_different                 000610 automatic       bit(1)                   dcl 54 set ref 205 455* 537* 542*
deleted                         000651 automatic       bit(1024)                dcl 60 set ref 264 454* 518*
divide                                                 builtin function         dcl 91 ref 187 188
done                            000741 automatic       bit(1)                   dcl 325 set ref 330* 332 334* 338
error_table_$badopt             000040 external static fixed bin(35,0)          dcl 76 set ref 160*
error_table_$noarg              000036 external static fixed bin(35,0)          dcl 76 set ref 170*
expand_pathname_                000022 constant        entry                    external dcl 69 ref 127 140
field_type               17            based           bit(2)                   array level 3 packed unaligned dcl 1-13 ref 360 490
                                                                                  490
hbound                                                 builtin function         dcl 91 ref 410 424 484 499 534
idx                             001030 automatic       fixed bin(17,0)          dcl 558 in procedure "print_deck" set ref 560* 561*
idx                             000121 automatic       fixed bin(17,0)          dcl 23 in procedure "compare_configuration_deck" set
                                                                                  ref 248* 249 250* 263* 264 265* 278* 279 284* 295*
                                                                                  296 298* 301* 302 304*
idx                             001004 automatic       fixed bin(17,0)          dcl 394 in procedure "compare_decks" set ref 440*
                                                                                  441 441* 484* 485 486*
idx                             000756 automatic       fixed bin(17,0)          dcl 349 in procedure "get_card_str" set ref 359* 360
                                                                                  361 372*
idx                             000740 automatic       fixed bin(17,0)          dcl 324 in procedure "count_cards" set ref 332* 333*
initiate_file_                  000024 constant        entry                    external dcl 70 ref 133 146 177
ioa_                            000026 constant        entry                    external dcl 71 ref 211 216 220 224 234 245 252 254
                                                                                  260 267 269 275 282 287 292 298 304 563
ioa_$rsnnl                      000030 constant        entry                    external dcl 72 ref 363 366 376
jdx                             001005 automatic       fixed bin(17,0)          dcl 394 in procedure "compare_decks" set ref 486*
                                                                                  487 487 490 490*
jdx                             000122 automatic       fixed bin(17,0)          dcl 23 in procedure "compare_configuration_deck" set
                                                                                  ref 279* 280 284* 285
label_output                    000125 automatic       bit(1)                   dcl 26 set ref 115* 156* 157* 355
mem_card                               based           structure                level 1 dcl 2-5
mem_cards                       000510 automatic       structure                array level 1 dcl 48 set ref 410 424
mem_cards_different             000611 automatic       bit(1)                   dcl 55 set ref 228 291 434* 436* 440 441* 460 470
                                                                                  523
n_added                         000612 automatic       fixed bin(17,0)          dcl 56 set ref 228 244 450* 507* 507 511* 511 529*
                                                                                  529 534
n_changed                       000405 automatic       fixed bin(17,0)          dcl 40 set ref 228 274 278 449* 499 502* 502 503 504
n_deleted                       000613 automatic       fixed bin(17,0)          dcl 57 set ref 228 259 451* 519* 519 534
n_fields                 17(32)        based           fixed bin(4,0)           level 3 packed unsigned unaligned dcl 1-13 ref 359
n_new_mem_cards                 000507 automatic       fixed bin(17,0)          dcl 46 set ref 301 404* 424 427* 427 429 430 436
n_old_mem_cards                 000506 automatic       fixed bin(17,0)          dcl 45 set ref 295 403* 410 413* 413 415 416 436 440
name                            000000 constant        char(4)                  initial array level 2 dcl 83 ref 485
nargs                           000101 automatic       fixed bin(17,0)          dcl 16 set ref 101* 117
ncp                             001010 automatic       pointer                  dcl 395 set ref 421* 423 430 468* 470 474 477 487
                                                                                  490 525* 527
new                       1     000406 automatic       fixed bin(17,0)          array level 2 dcl 41 set ref 284 504*
new_bc                          000277 automatic       fixed bin(24,0)          dcl 31 set ref 146* 177* 188
new_dname                       000200 automatic       char(168)                unaligned dcl 28 set ref 140* 146* 148* 148* 175*
                                                                                  177* 185* 185* 192* 211* 216*
new_dp                          000274 automatic       pointer                  dcl 30 set ref 97* 121 146* 147 174 177* 178 190*
                                                                                  218* 250 285 302 421 468 525 576 576*
new_ename                       000262 automatic       char(32)                 unaligned dcl 29 set ref 140* 146* 148* 148* 176*
                                                                                  177* 185*
new_idx                         001003 automatic       fixed bin(17,0)          dcl 394 in procedure "compare_decks" set ref 420*
                                                                                  421 429* 464* 465 468 504 506 510* 524* 525 528*
new_idx                   2     000510 automatic       fixed bin(17,0)          array level 2 in structure "mem_cards" dcl 48
                                                                                  in procedure "compare_configuration_deck" set ref
                                                                                  302 429*
new_max_recs                    000303 automatic       fixed bin(17,0)          dcl 33 set ref 188* 190*
new_port                  3     000510 automatic       fixed bin(35,0)          array level 2 dcl 48 set ref 430* 441
new_recs                        000301 automatic       fixed bin(17,0)          dcl 32 set ref 190* 191 218* 248 263 420 450 453 453
                                                                                  464 524
null                                                   builtin function         dcl 91 ref 96 97 121 126 134 147 169 174 178 573 576
numeric_field                   000761 automatic       fixed bin(35,0)          dcl 352 set ref 361* 363* 366 366 366* 369 376*
ocp                             001006 automatic       pointer                  dcl 395 set ref 407* 409 416 458* 460 474 477 485
                                                                                  487 490
old                             000406 automatic       fixed bin(17,0)          array level 2 dcl 41 set ref 279 503*
old_bc                          000276 automatic       fixed bin(24,0)          dcl 31 set ref 133* 187
old_dname                       000126 automatic       char(168)                unaligned dcl 28 set ref 127* 133* 135* 135* 184*
                                                                                  184* 198* 211* 220*
old_dp                          000272 automatic       pointer                  dcl 30 set ref 96* 126 133* 134 169 196* 222* 265
                                                                                  280 296 407 458 573 573*
old_ename                       000252 automatic       char(32)                 unaligned dcl 29 set ref 127* 133* 135* 135* 184*
old_idx                         000510 automatic       fixed bin(17,0)          array level 2 in structure "mem_cards" dcl 48
                                                                                  in procedure "compare_configuration_deck" set ref
                                                                                  296 415*
old_idx                         001002 automatic       fixed bin(17,0)          dcl 394 in procedure "compare_decks" set ref 406*
                                                                                  407 415* 457* 458 503 518*
old_max_recs                    000302 automatic       fixed bin(17,0)          dcl 33 set ref 187* 196*
old_port                  1     000510 automatic       fixed bin(35,0)          array level 2 dcl 48 set ref 416* 441
old_recs                        000300 automatic       fixed bin(17,0)          dcl 32 set ref 196* 197 222* 406 454 454 457
pathname_                       000032 constant        entry                    external dcl 73 ref 135 135 148 148 184 185
rs                                     based           varying char             dcl 20 set ref 111* 207* 230* 240*
rsl                             000103 automatic       fixed bin(21,0)          dcl 17 set ref 101* 111 207 230 240
rsp                             000106 automatic       pointer                  dcl 18 set ref 101* 111 207 230 240
substr                                                 builtin function         dcl 91 set ref 249 264 369 453* 454* 465 506* 510*
                                                                                  518* 528*
tag                       1            based           fixed bin(3,0)           level 2 dcl 2-5 ref 416 430
temp_str                        000762 automatic       varying char(16)         dcl 353 set ref 363* 366* 369* 373* 376* 380
terminate_file_                 000034 constant        entry                    external dcl 74 ref 573 576
type                            000757 automatic       bit(2)                   dcl 350 set ref 360* 363 366 371 376
type_word                17            based           structure                level 2 dcl 1-13
unspec                                                 builtin function         dcl 91 set ref 361* 361 372* 372 474 474
whoami                          000111 automatic       char(32)                 unaligned dcl 22 set ref 95* 122* 129* 135* 142*
                                                                                  148* 160* 170* 170* 179* 192* 198*
word                                   based           char(4)                  level 2 dcl 1-13 ref 334 357 409 423 460 470 477 477
                                                                                  485 527

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 3-33
EMPTY_FIELD                            internal static bit(36)                  initial dcl 1-34
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 3-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 3-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 3-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 3-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 4-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 4-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 4-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 4-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 4-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 4-15
VALID_CARD_WORD_CHARACTERS             internal static char(38)                 initial unaligned dcl 1-31
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
ZERO_CARD_WORD                         internal static char(4)                  initial dcl 1-28
config_deck$                           external static fixed bin(17,0)          dcl 1-7
configp                                automatic       pointer                  dcl 1-3
mem_cardp                              automatic       pointer                  dcl 2-3
rtrim                                                  builtin function         dcl 91
terminate_file_switches                based           structure                level 1 packed unaligned dcl 4-4

NAMES DECLARED BY EXPLICIT CONTEXT.
CHANGED                         003250 constant        label                    dcl 499 ref 494
DECKS_DIFFERENT                 003350 constant        label                    dcl 542 ref 410 424 499 534
DIFFERENT                       003300 constant        label                    dcl 514 ref 477 487 490
IDENTICAL                       003271 constant        label                    dcl 510 ref 474
MAIN_RETURN                     002460 constant        label                    dcl 308 ref 123 130 136 143 149 161 171 180 193 199
                                                                                  208 214 225 231 236 241
NEXT_NEW_CARD                   003301 constant        label                    dcl 516 ref 465 470 514
NEXT_OLD_CARD                   003310 constant        label                    dcl 521 ref 460 508 512
clean_things_up                 003424 constant        entry                    internal dcl 571 ref 99 308
compare_configuration_deck      000341 constant        entry                    external dcl 6
compare_decks                   002774 constant        entry                    internal dcl 389 ref 203
count_cards                     002465 constant        entry                    internal dcl 315 ref 190 196
get_card_str                    002534 constant        entry                    internal dcl 347 ref 251 266 281 286 297 303 562
print_deck                      003353 constant        entry                    internal dcl 550 ref 218 222

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3766        4030    3566        3776
Length      4334    3566        42         270     177           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
compare_configuration_deck          700 external procedure  is an external procedure.  
on unit on line 99                   64 on unit               
count_cards                             internal procedure  shares stack frame of external procedure compare_configuration_deck.  
get_card_str                            internal procedure  shares stack frame of external procedure compare_configuration_deck.  
compare_decks                           internal procedure  shares stack frame of external procedure compare_configuration_deck.  
print_deck                              internal procedure  shares stack frame of external procedure compare_configuration_deck.  
clean_things_up                      84 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
compare_configuration_deck
                         000100 argno                       compare_configuration_deck
                         000101 nargs                       compare_configuration_deck
                         000102 al                          compare_configuration_deck
                         000103 rsl                         compare_configuration_deck
                         000104 ap                          compare_configuration_deck
                         000106 rsp                         compare_configuration_deck
                         000110 code                        compare_configuration_deck
                         000111 whoami                      compare_configuration_deck
                         000121 idx                         compare_configuration_deck
                         000122 jdx                         compare_configuration_deck
                         000123 brief_sw                    compare_configuration_deck
                         000124 af_sw                       compare_configuration_deck
                         000125 label_output                compare_configuration_deck
                         000126 old_dname                   compare_configuration_deck
                         000200 new_dname                   compare_configuration_deck
                         000252 old_ename                   compare_configuration_deck
                         000262 new_ename                   compare_configuration_deck
                         000272 old_dp                      compare_configuration_deck
                         000274 new_dp                      compare_configuration_deck
                         000276 old_bc                      compare_configuration_deck
                         000277 new_bc                      compare_configuration_deck
                         000300 old_recs                    compare_configuration_deck
                         000301 new_recs                    compare_configuration_deck
                         000302 old_max_recs                compare_configuration_deck
                         000303 new_max_recs                compare_configuration_deck
                         000304 card_str                    compare_configuration_deck
                         000405 n_changed                   compare_configuration_deck
                         000406 changed_cards               compare_configuration_deck
                         000506 n_old_mem_cards             compare_configuration_deck
                         000507 n_new_mem_cards             compare_configuration_deck
                         000510 mem_cards                   compare_configuration_deck
                         000610 decks_different             compare_configuration_deck
                         000611 mem_cards_different         compare_configuration_deck
                         000612 n_added                     compare_configuration_deck
                         000613 n_deleted                   compare_configuration_deck
                         000614 added                       compare_configuration_deck
                         000651 deleted                     compare_configuration_deck
                         000706 complain                    compare_configuration_deck
                         000720 cardp                       compare_configuration_deck
                         000722 config_n_cards              compare_configuration_deck
                         000723 config_max_cards            compare_configuration_deck
                         000740 idx                         count_cards
                         000741 done                        count_cards
                         000742 count                       count_cards
                         000744 cp                          count_cards
                         000756 idx                         get_card_str
                         000757 type                        get_card_str
                         000760 char_field                  get_card_str
                         000761 numeric_field               get_card_str
                         000762 temp_str                    get_card_str
                         001002 old_idx                     compare_decks
                         001003 new_idx                     compare_decks
                         001004 idx                         compare_decks
                         001005 jdx                         compare_decks
                         001006 ocp                         compare_decks
                         001010 ncp                         compare_decks
                         001030 idx                         print_deck

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_var_desc       call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              enable              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      config_deck_parse_$binary_to_ascii
cu_$af_return_arg             cu_$arg_ptr                   expand_pathname_              initiate_file_
ioa_                          ioa_$rsnnl                    pathname_                     terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000340        95 000346        96 000351        97 000353        99 000354       101 000376       103 000413
    104 000415       105 000422       106 000423       109 000424       110 000431       111 000433       114 000434
    115 000435       117 000436       118 000445       120 000463       121 000474       122 000500       123 000533
    126 000534       127 000540       128 000570       129 000572       130 000623       133 000624       134 000661
    135 000665       136 000733       138 000734       140 000735       141 000765       142 000767       143 001020
    146 001021       147 001056       148 001062       149 001130       152 001131       154 001132       155 001146
    156 001160       157 001173       160 001205       161 001236       163 001237       167 001241       169 001244
    170 001250       171 001277       174 001300       175 001304       176 001307       177 001312       178 001347
    179 001353       180 001377       184 001400       185 001420       187 001440       188 001443       190 001446
    191 001450       192 001452       193 001502       196 001503       197 001505       198 001507       199 001537
    203 001540       205 001541       206 001543       207 001545       208 001556       211 001557       214 001606
    216 001611       218 001631       220 001635       222 001655       224 001661       225 001672       228 001673
    229 001703       230 001705       231 001716       234 001717       236 001736       239 001737       240 001741
    241 001752       244 001753       245 001755       248 001774       249 002003       250 002007       251 002013
    252 002014       254 002041       256 002060       259 002062       260 002064       263 002103       264 002113
    265 002117       266 002123       267 002124       269 002152       271 002171       274 002173       275 002175
    278 002217       279 002227       280 002232       281 002236       282 002237       284 002260       285 002264
    286 002270       287 002271       288 002310       291 002312       292 002314       295 002333       296 002343
    297 002351       298 002352       299 002405       301 002407       302 002417       303 002425       304 002426
    305 002456       308 002460       311 002464       315 002465       329 002467       330 002470       332 002471
    333 002503       334 002511       335 002517       336 002520       338 002522       340 002530       342 002533
    347 002534       355 002535       357 002551       359 002555       360 002567       361 002575       363 002600
    366 002633       369 002673       371 002702       372 002704       373 002706       374 002712       376 002713
    379 002745       380 002757       381 002771       384 002773       389 002774       403 002775       404 002776
    406 002777       407 003007       409 003013       410 003016       413 003021       415 003022       416 003027
    418 003031       420 003033       421 003043       423 003047       424 003052       427 003055       429 003056
    430 003063       432 003065       434 003067       436 003070       440 003076       441 003107       443 003116
    449 003120       450 003121       451 003123       453 003124       454 003127       455 003133       457 003134
    458 003143       460 003147       464 003154       465 003163       468 003167       470 003173       474 003200
    477 003205       484 003210       485 003215       486 003222       487 003231       490 003234       492 003243
    494 003245       496 003246       499 003250       502 003253       503 003254       504 003261       506 003263
    507 003266       508 003270       510 003271       511 003275       512 003277       514 003300       516 003301
    518 003303       519 003307       521 003310       523 003312       524 003314       525 003323       527 003327
    528 003332       529 003336       531 003340       534 003342       537 003346       539 003347       542 003350
    544 003352       550 003353       560 003355       561 003365       562 003373       563 003374       564 003420
    566 003422       571 003423       573 003431       576 003464       579 003520


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
