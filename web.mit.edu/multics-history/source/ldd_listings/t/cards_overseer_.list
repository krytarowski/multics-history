	COMPILATION LISTING OF SEGMENT cards_overseer_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/27/85  1133.0 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* format: style2 */
       11 
       12 cards_overseer_:
       13      procedure options (separate_static);
       14 
       15 /* This is an overseer for the SysDaemon process whose sole responsibility is to read
       16*   card decks for users. All it does is attach the card reader and call the read_cards_
       17*   subroutine. Its principal reason for existence is to prevent the card daemon from
       18*   being used at command level.
       19**/
       20 /* Modified February, 1975 by S. Vestal for security fix */
       21 /* Modified August, 1975 by J. C. Whitmore for new card dim interface */
       22 /* Modified April, 1976 by J. C. Whitmore to resetread after a quit */
       23 /* Modified January, 1978 by DRV to fix bug in cleanup of test entry */
       24 /* Modified January 1978 by J. C. Whitmore to request station id and use iox_ for input */
       25 /* Modified 1984-08-17 by E. Swenson for version 2 PNTs. */
       26 
       27 	dcl     com_err_		 entry options (variable);
       28 	dcl     condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char (*), ptr, ptr);
       29 	dcl     continue_to_signal_	 entry (fixed bin (35));
       30 	dcl     cu_$arg_count	 entry () returns (fixed bin);
       31 	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin);
       32 	dcl     debug		 entry;
       33 	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
       34 	dcl     get_at_entry_	 entry (char (*), char (*), char (*), char (*), fixed bin (35));
       35 	dcl     read_password_	 entry (char (*), char (*));
       36 	dcl     ioa_$ioa_stream	 entry options (variable);
       37 	dcl     ioa_$ioa_stream_nnl	 entry options (variable);
       38 	dcl     ioa_		 entry options (variable);
       39 	dcl     ios_$attach		 entry (char (*) aligned, char (*), char (*), char (*), bit (72) aligned);
       40 	dcl     (
       41 	        ios_$setsize,
       42 	        ios_$getsize
       43 	        )			 entry (char (*) aligned, fixed bin, bit (72) aligned);
       44 	dcl     ios_$detach		 entry (char (*) aligned, char (*), char (*), bit (72) aligned);
       45 	dcl     ios_$resetread	 entry (char (*), bit (72) aligned);
       46 	dcl     iox_$user_input	 ext ptr;
       47 	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
       48 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
       49 	dcl     logout		 entry;
       50 	dcl     new_proc		 entry;
       51 	dcl     pool_manager_$init	 entry (char (*) aligned, fixed bin, bit (36) aligned, fixed bin (35));
       52 	dcl     pool_manager_$clean_pool
       53 				 entry (char (*) aligned, fixed bin, fixed bin, fixed bin (35));
       54 	dcl     read_cards_		 entry (char (*) aligned, ptr, char (*), bit (1) aligned, fixed bin (35));
       55 	dcl     read_cards_$set_station
       56 				 entry (char (*), fixed bin (35));
       57 	dcl     scramble_		 entry (char (8)) returns (char (8));
       58 	dcl     standard_default_handler_
       59 				 entry (ptr, char (*), ptr, ptr, bit (1) aligned);
       60 	dcl     validate_card_input_$station
       61 				 entry (char (*), char (*), char (*), fixed bin (35));
       62 
       63 	dcl     (any_other, cput, alrm, finish, cleanup, resume)
       64 				 condition;
       65 
       66 	dcl     (addr, null, ltrim, substr)
       67 				 builtin;
       68 
       69 	dcl     answer		 char (80);
       70 	dcl     age		 fixed bin;
       71 	dcl     a_card_dim		 char (*);
       72 	dcl     a_card_device	 char (*);
       73 	dcl     card_device		 char (32) init ("rdra");
       74 	dcl     card_dim		 char (32) init ("crz");
       75 	dcl     code		 fixed bin (35);
       76 	dcl     dev		 char (32);
       77 	dcl     dim		 char (32);
       78 	dcl     stream_name		 char (32) aligned;
       79 	dcl     iocbp		 ptr;
       80 	dcl     i			 fixed bin;
       81 	dcl     ig		 char (4);
       82 	dcl     nchar		 fixed bin;
       83 	dcl     password		 char (32);
       84 	dcl     station		 char (32);
       85 	dcl     status		 bit (72) aligned;
       86 	dcl     error_msg		 char (132);	/* for message from validate_card_input_ */
       87 	dcl     root_dir		 char (168) aligned init ("System_Card_Pool");
       88 						/*  dir into which we look for card_pool_root */
       89 	dcl     temp_password	 char (8);	/* temporary for password manipulation */
       90 	dcl     test_sw		 bit (1) aligned int static init ("0"b);
       91 						/*  =1 if testing */
       92 	dcl     user_mode		 bit (36) aligned int static init ("100"b || (33)"0"b) options (constant);
       93 
       94 	dcl     quit_flag		 bit (1) int static init ("0"b);
       95 	dcl     recursion_flag	 fixed bin int static init (0);
       96 	dcl     resume_label	 label int static;
       97 
       98 	dcl     error_table_$ionmat	 ext static fixed bin (35);
       99 
      100 	dcl     1 stat		 aligned based (addr (status)),
      101 		2 word1		 fixed bin (35),
      102 		2 iocode		 fixed bin (35);
      103 
      104 	dcl     1 stream_info	 aligned like card_stream_info;
      105 						/* allocate the structure for read_cards_ */
      106 
  1     1 /* BEGIN INCLUDE FILE ... card_stream_info.incl.pl1 */
  1     2 
  1     3 /* This is the info structure passed to read_cards_ which defines the data streams
  1     4*   used to interpret user card decks according to the Multics card input facility. */
  1     5 
  1     6 dcl  stream_info_ptr ptr;
  1     7 
  1     8 dcl 1 card_stream_info aligned based (stream_info_ptr),
  1     9     2 control_stream char (32),			/* stream used for control card reading */
  1    10     2 n_streams fixed bin,				/* number of data streams active in the list */
  1    11     2 data_streams (5),				/* array of streams for different card formats */
  1    12       3 format char (12),				/* name of the stream format (e.g. mcc, raw) */
  1    13       3 name char (32),				/* name of the stream as attached */
  1    14       3 el_size fixed bin;				/* element size for the stream */
  1    15 
  1    16 /* END INCLUDE FILE ... card_stream_info.incl.pl1 */
      107 
      108 
      109 /*  Normal entry point  */
      110 
      111 	go to start;
      112 
      113 /*  test entry point  */
      114 
      115 test:
      116      entry (a_root_dir, a_card_dim, a_card_device);
      117 
      118 	dcl     a_root_dir		 char (*);	/*  input arg for system storage location */
      119 
      120 	if cu_$arg_count () ^= 3
      121 	then do;					/* must have 3 args for this entry */
      122 		call ioa_ (
      123 		     "cards_overseer_:  USAGE:  cards_overseer_$test  card_pool_root_dir  card_dim  card_device");
      124 		return;
      125 	     end;
      126 	test_sw = "1"b;				/*  testing in progress */
      127 	root_dir = a_root_dir;			/*  copy the root */
      128 	card_dim = a_card_dim;
      129 	card_device = a_card_device;
      130 
      131 start:
      132 	stream_info.n_streams = 0;			/* no streams defined yet */
      133 	stream_info.name (*) = "undefined";
      134 	stream_info.format (*) = "";
      135 	stream_info.control_stream = "undefined";
      136 
      137 /* set up a condition wall - we will handle all conditions */
      138 
      139 	on cleanup call clean_up;
      140 
      141 	on any_other call cards_handler;		/* for all other conditions */
      142 
      143 	resume_label = no_attach;
      144 	quit_flag = "0"b;
      145 
      146 /* if using message coordinator, attach error_output stuff */
      147 
      148 	call get_at_entry_ ("user_i/o", dim, dev, ig, code);
      149 	if dim = "mrd_"
      150 	then do;
      151 		call ios_$attach ("error_i/o", "mrd_", dev, "", status);
      152 		call ios_$attach ("error_output", "syn", "error_i/o", "", status);
      153 	     end;
      154 
      155 	iocbp = iox_$user_input;
      156 
      157 re_init:
      158 	call ios_$attach ("card_in_stream", card_dim, card_device, "", status);
      159 	if stat.word1 ^= 0				/* oh well */
      160 	then if stat.word1 ^= error_table_$ionmat	/* let it ride if already attached */
      161 	     then do;
      162 		     call com_err_ (stat.word1, "cards_overseer_", "^/Could not attach card reader on channel ^a.",
      163 			card_device);
      164 		     call ioa_ ("Card Daemon: Enter new device channel or type ""quit"".");
      165 		     answer = "";			/* clear junk */
      166 		     call iox_$get_line (iocbp, addr (answer), 80, nchar, code);
      167 		     if code ^= 0
      168 		     then go to no_attach;
      169 		     card_device = substr (answer, 1, nchar - 1);
      170 						/* assume a new channel */
      171 		     if card_device ^= "quit"
      172 		     then go to re_init;		/* try the new channel */
      173 
      174 no_attach:
      175 		     call ioa_ ("Card Input Daemon cannot run.");
      176 		     go to exit;
      177 		end;
      178 
      179 	if test_sw
      180 	then call ios_$setsize ("card_in_stream", 972, status);
      181 
      182 	stream_info.control_stream = "mcc_card_input_";	/* we use this to read control cards */
      183 	stream_info.n_streams = 4;			/* we will support 4 input formats */
      184 
      185 	stream_info.format (1) = "mcc";		/* first describe the MCC format stream */
      186 	stream_info.name (1) = "mcc_card_input_";	/* this is also the control stream */
      187 
      188 	stream_info.format (2) = "viipunch";		/* next we have the 7 punch format */
      189 	stream_info.name (2) = "viipunch_card_input_";
      190 
      191 	stream_info.format (3) = "raw";		/* next is the raw card format */
      192 	stream_info.name (3) = "raw_card_input_";
      193 
      194 	stream_info.format (4) = "rmcc";		/* last is rmcc for compatability with remote input */
      195 	stream_info.name (4) = "mcc_card_input_";	/* this is the same as mcc format */
      196 
      197 /*	now attach the format dims as we said above */
      198 
      199 	stream_name = "mcc_card_input_";		/* use a dummy variable for use in error msg */
      200 
      201 	call ios_$attach (stream_name, "mcc_", "card_in_stream", "", status);
      202 	if stat.word1 ^= 0
      203 	then if stat.word1 ^= error_table_$ionmat
      204 	     then do;				/* if attached, assume it is ok */
      205 attach_err:
      206 		     call com_err_ (stat.word1, "cards_overseer_", "^/Unable to attach ^a stream.", stream_name);
      207 		     go to exit;			/* at this point we quit  */
      208 		end;
      209 
      210 	stream_name = "viipunch_card_input_";
      211 
      212 	call ios_$attach (stream_name, "viipunch_", "card_in_stream", "", status);
      213 	if stat.word1 ^= 0
      214 	then if stat.word1 ^= error_table_$ionmat
      215 	     then go to attach_err;			/* if attached, assume it is ok */
      216 
      217 	stream_name = "raw_card_input_";
      218 
      219 	call ios_$attach (stream_name, "raw_", "card_in_stream", "", status);
      220 	if stat.word1 ^= 0
      221 	then if stat.word1 ^= error_table_$ionmat
      222 	     then go to attach_err;			/* if attached, assume it is ok */
      223 
      224 	do i = 1 to stream_info.n_streams;		/* get the element size for each format stream */
      225 	     call ios_$getsize (stream_info.name (i), stream_info.el_size (i), status);
      226 	     if stat.word1 ^= 0
      227 	     then do;
      228 		     call com_err_ (stat.word1, "cards_overseer_", "^/Unable to get element size for ^a stream.",
      229 			stream_info.name (i));
      230 		     go to no_attach;		/* give the bad news message */
      231 		end;
      232 	end;
      233 
      234 	call pool_manager_$init (root_dir, 10, user_mode, code);
      235 	if code ^= 0
      236 	then do;
      237 		call com_err_ (code, "cards_overseer_", "^/Could not initialize pool.");
      238 		go to exit;
      239 	     end;
      240 
      241 /* ask the operator for the reader station and validate its password */
      242 
      243 	do i = 1 to 5;				/* try five times at most */
      244 	     station, password = "";			/* clear any junk */
      245 	     call ioa_ ("Card Daemon: enter Station_id");
      246 	     call iox_$get_line (iocbp, addr (station), 80, nchar, code);
      247 	     if code ^= 0
      248 	     then go to no_attach;
      249 	     station = substr (station, 1, nchar - 1);
      250 	     call read_password_ ("Enter station password:", password);
      251 
      252 	     if password ^= ""
      253 	     then do;
      254 		     temp_password = password;
      255 		     password = scramble_ (temp_password);
      256 		     temp_password = "";
      257 		end;
      258 
      259 	     call validate_card_input_$station (station, password, error_msg, code);
      260 	     if code = 0
      261 	     then go to set_station;			/* all was well */
      262 
      263 	     call ioa_ ("***:  ^a", error_msg);
      264 	end;
      265 	call ioa_ ("Card Daemon cannot run.");
      266 	go to exit;				/* that's all folks */
      267 
      268 set_station:
      269 	call read_cards_$set_station (station, code);	/* pass on the good station name */
      270 	call iox_$control (iocbp, "quit_enable", null, code);
      271 	resume_label = ask;				/* we are ready to come to command level after errors */
      272 
      273 ask:
      274 	recursion_flag = 0;				/* we are at the base stack frame */
      275 	quit_flag = "0"b;
      276 
      277 	call command_level;				/*  ask the operator what he wants to do */
      278 
      279 	call ios_$resetread ("card_in_stream", status);	/* throw out any previous cards */
      280 	if stat.word1 ^= 0
      281 	then do;
      282 		call com_err_ (stat.word1, "cards_overseer_",
      283 		     "^/Invalid resetread to card dim.  Card Daemon cannot run.");
      284 		go to exit;
      285 	     end;
      286 
      287 	call read_cards_ (root_dir, addr (stream_info), "user_output", test_sw, code);
      288 	if code ^= 0
      289 	then call com_err_ (code, "cards_overseer_");
      290 
      291 	go to ask;				/* what do we do next? */
      292 
      293 
      294 
      295 /* all done, detach reader and log out */
      296 
      297 exit:
      298 	call clean_up;				/* detach the streams */
      299 
      300 	if test_sw
      301 	then return;
      302 	else call logout;
      303 
      304 
      305 /* ============================================================================================== */
      306 
      307 
      308 clean_up:
      309      proc;
      310 
      311 	dcl     status		 bit (72) aligned;	/* use some local variables */
      312 	dcl     i			 fixed bin;
      313 
      314 	do i = 1 to stream_info.n_streams;		/* detach the format streams */
      315 
      316 	     call ios_$detach (stream_info.name (i), "", "", status);
      317 
      318 	end;
      319 
      320 	call ios_$detach ("card_in_stream", "", "", status);
      321 
      322      end clean_up;
      323 
      324 command_level:
      325      proc;
      326 
      327 /*  This is the procedure that implements card daemon commands */
      328 
      329 get_line:
      330 	call ioa_ ("Card Daemon: Command?");
      331 
      332 read_again:
      333 	answer = "";
      334 	call iox_$get_line (iocbp, addr (answer), 80, nchar, code);
      335 	if code ^= 0
      336 	then go to no_attach;
      337 
      338 	answer = substr (answer, 1, nchar - 1);
      339 	answer = ltrim (answer);
      340 
      341 	if answer = ""
      342 	then go to read_again;
      343 
      344 	if answer = "."
      345 	then go to get_line;
      346 
      347 	if answer = "start"				/* only valid after a quit */
      348 	then if quit_flag
      349 	     then return;
      350 	     else go to only_after_quit;
      351 
      352 	if answer = "read_cards"
      353 	then /* not valid after a quit */
      354 	     if ^quit_flag
      355 	     then return;
      356 	     else do;
      357 		     call ioa_ ("The read_cards command is not valid while processing cards. Use start.");
      358 		     go to get_line;
      359 		end;
      360 
      361 	if answer = "reinit"
      362 	then do;
      363 		call clean_up;
      364 		quit_flag = "0"b;
      365 		go to re_init;
      366 	     end;
      367 
      368 	if answer = "logout"
      369 	then go to exit;
      370 
      371 	if answer = "abort"
      372 	then if quit_flag
      373 	     then do;
      374 		     quit_flag = "0"b;
      375 		     go to resume_label;
      376 		end;
      377 	     else go to only_after_quit;
      378 
      379 	if test_sw
      380 	then if answer = "return"
      381 	     then go to exit;
      382 
      383 	     else if answer = "debug"
      384 	     then do;
      385 		     call ioa_ ("calling debug");
      386 		     call debug;
      387 		     go to get_line;
      388 		end;
      389 
      390 	if answer = "clean_pool"
      391 	then do;					/* time for garbage collection */
      392 		call ioa_ ("Enter retention time in days (or 0 to abort):");
      393 		answer = "";
      394 		call iox_$get_line (iocbp, addr (answer), 80, nchar, code);
      395 		if code ^= 0
      396 		then go to no_attach;
      397 
      398 		answer = substr (answer, 1, nchar - 1);
      399 		age = cv_dec_check_ ((answer), code);
      400 		if code ^= 0
      401 		then do;
      402 			call ioa_ (
      403 			     "The allowed age of segments to remain in the pool must be a decimal number of days.");
      404 			go to get_line;
      405 		     end;
      406 
      407 		if age = 0
      408 		then go to get_line;
      409 		if age < 1
      410 		then do;
      411 			call ioa_ ("The retention time cannot be less than 1 day.");
      412 			go to get_line;
      413 		     end;
      414 
      415 		call pool_manager_$clean_pool (root_dir, age, 1, code);
      416 						/* allow 1 page grace quota */
      417 		if code ^= 0
      418 		then call com_err_ (code, "cards_overseer_");
      419 		go to get_line;
      420 	     end;
      421 
      422 	if answer = "help"
      423 	then do;
      424 		call ioa_ ("^/** Card Daemon Commands **^/");
      425 		call ioa_ ("read_cards   - begin read operations");
      426 		call ioa_ ("start        - continue after a quit");
      427 		call ioa_ ("logout       - log out the Card Daemon");
      428 		call ioa_ ("clean_pool   - garbage collect the card pool");
      429 		call ioa_ ("reinit       - re-attach the card reader");
      430 		call ioa_ ("abort        - halt current reading after a quit");
      431 
      432 		if test_sw
      433 		then do;
      434 			call ioa_ ("return");
      435 			call ioa_ ("debug");
      436 		     end;
      437 		go to get_line;
      438 	     end;
      439 
      440 	call ioa_ ("Illegal command: ^a", answer);
      441 
      442 	go to get_line;
      443 
      444 only_after_quit:
      445 	call ioa_ ("The ^a command is only valid during interrupted card reading.", answer);
      446 
      447 	go to get_line;
      448 
      449      end command_level;
      450 
      451 cards_handler:
      452      proc;
      453 
      454 /* Unclaimed signal handler. Will print default_error_handler-type message and ask if more
      455*   *  cards are to be read */
      456 
      457 	dcl     mcptr		 ptr;
      458 	dcl     condition		 char (32);
      459 	dcl     coptr		 ptr;
      460 	dcl     info_ptr		 ptr;
      461 	dcl     1 cond_info		 aligned,
  2     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  2     2*	   coded by M. Weaver 12 July 1973 */
  2     3 
  2     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  2     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  2     6 	  2 condition_name char(32) var,		/* name of condition */
  2     7 	  2 infoptr ptr,				/* ptr to software info structure */
  2     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  2     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  2    10 	  2 flags aligned,
  2    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  2    12 	    3 pad1 bit(35) unal,
  2    13 	  2 pad_word bit(36) aligned,
  2    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  2    15 	  2 pad (4) bit(36) aligned;
  2    16 
  2    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      462 
      463 
      464 	dcl     code		 fixed bin (35);
      465 
      466 
      467 	cond_info.version = 1;			/* set the version number for the subr */
      468 
      469 	call find_condition_info_ (null, addr (cond_info), code);
      470 
      471 	condition = cond_info.condition_name;
      472 	mcptr = cond_info.mcptr;
      473 	coptr = cond_info.wcptr;
      474 	info_ptr = cond_info.infoptr;
      475 
      476 	if condition = "mme2"
      477 	then if test_sw
      478 	     then do;
      479 		     call continue_to_signal_ (code);
      480 		     return;
      481 		end;
      482 
      483 	if condition = "finish"
      484 	then do;					/* now for the system conditions */
      485 call_sdh:
      486 		call standard_default_handler_ (mcptr, condition, coptr, infoptr, "0"b);
      487 		return;
      488 	     end;
      489 
      490 	if condition = "cput"
      491 	then go to call_sdh;
      492 	if condition = "alrm"
      493 	then go to call_sdh;
      494 
      495 	if condition = "command_question"
      496 	then return;
      497 	if condition = "command_error"
      498 	then return;
      499 
      500 	on cleanup quit_flag = "0"b;			/* be sure this gets reset */
      501 
      502 	if condition = "card_command_level"
      503 	then do;					/* we want to go to command level */
      504 		quit_flag = "1"b;			/* this allows different commands */
      505 		call ioa_ ("Use the ""clean_pool"" and ""start"" commands to continue.");
      506 		call command_level;
      507 		quit_flag = "0"b;			/* reset what we did */
      508 		return;
      509 	     end;
      510 
      511 	if condition = "quit"
      512 	then do;					/* we'll handle quits ourselves, else big trouble */
      513 
      514 		call ios_$resetread ("user_i/o", status);
      515 						/* clear any input junk */
      516 
      517 		if quit_flag
      518 		then do;				/* avoid multiple quits */
      519 			call ioa_$ioa_stream ("error_output", "QUIT still in progress.");
      520 			call iox_$control (iocbp, "start", null, code);
      521 			return;
      522 		     end;
      523 		call ioa_ ("QUIT");
      524 		quit_flag = "1"b;
      525 
      526 		call command_level;			/* see what operator wants */
      527 
      528 		quit_flag = "0"b;			/* we are done */
      529 		call iox_$control (iocbp, "start", null, code);
      530 		return;
      531 	     end;
      532 
      533 	on resume go to return_label;
      534 
      535 	if recursion_flag ^= 0
      536 	then do;					/* compound unclaimed signals, can't handle */
      537 		call com_err_ (0, "cards_handler",
      538 		     "Condition ^a signalled while handling unclaimed signal. Process terminated.", condition);
      539 		if test_sw
      540 		then do;
      541 			call ioa_ ("Calling debug");
      542 			call debug;
      543 			return;
      544 		     end;
      545 
      546 		call new_proc;
      547 	     end;
      548 
      549 	recursion_flag = 1;
      550 
      551 	call ioa_ ("Cards handler: condition ^a intercepted.", condition);
      552 
      553 	call condition_interpreter_ (null, null, 0, 3, mcptr, condition, coptr, info_ptr);
      554 
      555 /* if we got a message, print it out */
      556 
      557 	if test_sw
      558 	then do;
      559 		call ioa_ ("Calling debug");
      560 		call debug;
      561 	     end;
      562 
      563 	go to resume_label;
      564 
      565 return_label:
      566 	recursion_flag = 0;				/* reset the flag and ... */
      567 	return;					/* then do a clean return */
      568 
      569      end cards_handler;
      570 
      571      end cards_overseer_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/27/85  1132.0  cards_overseer_.pl1               >spec>on>7.ds>cards_overseer_.pl1
107          1    09/09/75  1333.7  card_stream_info.incl.pl1         >ldd>include>card_stream_info.incl.pl1
462          2    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_card_device                          parameter       char                     unaligned dcl 72 ref 115 129
a_card_dim                             parameter       char                     unaligned dcl 71 ref 115 128
a_root_dir                             parameter       char                     unaligned dcl 118 ref 115 127
addr                                                   builtin function         dcl 66 ref 159 159 162 166 166 202 202 205 213 213
                                                                                  220 220 226 228 246 246 280 282 287 287 334 334
                                                                                  394 394 469 469
age                             000140 automatic       fixed bin(17,0)          dcl 70 set ref 399* 407 409 415*
answer                          000114 automatic       char(80)                 unaligned dcl 69 set ref 165* 166 166 169 332* 334
                                                                                  334 338* 338 339* 339 341 344 347 352 361 368 371
                                                                                  379 383 390 393* 394 394 398* 398 399 422 440*
                                                                                  444*
any_other                       000100 stack reference condition                dcl 63 ref 141
card_device                     000141 automatic       char(32)                 initial unaligned dcl 73 set ref 73* 129* 157* 162*
                                                                                  169* 171
card_dim                        000151 automatic       char(32)                 initial unaligned dcl 74 set ref 74* 128* 157*
card_stream_info                       based           structure                level 1 dcl 1-8
cleanup                         000106 stack reference condition                dcl 63 ref 139 500
code                            000150 automatic       fixed bin(35,0)          dcl 464 in procedure "cards_handler" set ref 469*
                                                                                  479* 520* 529*
code                            000161 automatic       fixed bin(35,0)          dcl 75 in procedure "cards_overseer_" set ref 148*
                                                                                  166* 167 234* 235 237* 246* 247 259* 260 268* 270*
                                                                                  287* 288 288* 334* 335 394* 395 399* 400 415* 417
                                                                                  417*
com_err_                        000010 constant        entry                    external dcl 27 ref 162 205 228 237 282 288 417 537
cond_info                       000116 automatic       structure                level 1 dcl 461 set ref 469 469
condition                       000102 automatic       char(32)                 unaligned dcl 458 set ref 471* 476 483 485* 490 492
                                                                                  495 497 502 511 537* 551* 553*
condition_interpreter_          000012 constant        entry                    external dcl 28 ref 553
condition_name            3     000116 automatic       varying char(32)         level 2 dcl 461 set ref 471
continue_to_signal_             000014 constant        entry                    external dcl 29 ref 479
control_stream                  000360 automatic       char(32)                 level 2 dcl 104 set ref 135* 182*
coptr                           000112 automatic       pointer                  dcl 459 set ref 473* 485* 553*
cu_$arg_count                   000016 constant        entry                    external dcl 30 ref 120
cv_dec_check_                   000020 constant        entry                    external dcl 31 ref 399
data_streams             11     000360 automatic       structure                array level 2 dcl 104
debug                           000022 constant        entry                    external dcl 32 ref 386 542 560
dev                             000162 automatic       char(32)                 unaligned dcl 76 set ref 148* 151*
dim                             000172 automatic       char(32)                 unaligned dcl 77 set ref 148* 149
el_size                  24     000360 automatic       fixed bin(17,0)          array level 3 dcl 104 set ref 225*
error_msg                       000242 automatic       char(132)                unaligned dcl 86 set ref 259* 263*
error_table_$ionmat             000100 external static fixed bin(35,0)          dcl 98 ref 159 202 213 220
find_condition_info_            000024 constant        entry                    external dcl 33 ref 469
format                   11     000360 automatic       char(12)                 array level 3 dcl 104 set ref 134* 185* 188* 191*
                                                                                  194*
get_at_entry_                   000026 constant        entry                    external dcl 34 ref 148
i                               000214 automatic       fixed bin(17,0)          dcl 80 in procedure "cards_overseer_" set ref 224*
                                                                                  225 225 228* 243*
i                               000102 automatic       fixed bin(17,0)          dcl 312 in procedure "clean_up" set ref 314* 316*
ig                              000215 automatic       char(4)                  unaligned dcl 81 set ref 148*
info_ptr                        000114 automatic       pointer                  dcl 460 set ref 474* 553*
infoptr                  14     000116 automatic       pointer                  level 2 dcl 461 set ref 474 485*
ioa_                            000034 constant        entry                    external dcl 38 ref 122 164 174 245 263 265 329 357
                                                                                  385 392 402 411 424 425 426 427 428 429 430 434
                                                                                  435 440 444 505 523 541 551 559
ioa_$ioa_stream                 000032 constant        entry                    external dcl 36 ref 519
iocbp                           000212 automatic       pointer                  dcl 79 set ref 155* 166* 246* 270* 334* 394* 520*
                                                                                  529*
ios_$attach                     000036 constant        entry                    external dcl 39 ref 151 152 157 201 212 219
ios_$detach                     000044 constant        entry                    external dcl 44 ref 316 320
ios_$getsize                    000042 constant        entry                    external dcl 40 ref 225
ios_$resetread                  000046 constant        entry                    external dcl 45 ref 279 514
ios_$setsize                    000040 constant        entry                    external dcl 40 ref 179
iox_$control                    000054 constant        entry                    external dcl 48 ref 270 520 529
iox_$get_line                   000052 constant        entry                    external dcl 47 ref 166 246 334 394
iox_$user_input                 000050 external static pointer                  dcl 46 ref 155
logout                          000056 constant        entry                    external dcl 49 ref 302
ltrim                                                  builtin function         dcl 66 ref 339
mcptr                           000116 automatic       pointer                  level 2 in structure "cond_info" dcl 461
                                                                                  in procedure "cards_handler" set ref 472
mcptr                           000100 automatic       pointer                  dcl 457 in procedure "cards_handler" set ref 472*
                                                                                  485* 553*
n_streams                10     000360 automatic       fixed bin(17,0)          level 2 dcl 104 set ref 131* 183* 224 314
name                     14     000360 automatic       char(32)                 array level 3 dcl 104 set ref 133* 186* 189* 192*
                                                                                  195* 225* 228* 316*
nchar                           000216 automatic       fixed bin(17,0)          dcl 82 set ref 166* 169 246* 249 334* 338 394* 398
new_proc                        000060 constant        entry                    external dcl 50 ref 546
null                                                   builtin function         dcl 66 ref 270 270 469 469 520 520 529 529 553 553
                                                                                  553 553
password                        000217 automatic       char(32)                 unaligned dcl 83 set ref 244* 250* 252 254 255* 259*
pool_manager_$clean_pool        000064 constant        entry                    external dcl 52 ref 415
pool_manager_$init              000062 constant        entry                    external dcl 51 ref 234
quit_flag                       000001 internal static bit(1)                   initial unaligned dcl 94 set ref 144* 275* 347 352
                                                                                  364* 371 374* 500* 504* 507* 517 524* 528*
read_cards_                     000066 constant        entry                    external dcl 54 ref 287
read_cards_$set_station         000070 constant        entry                    external dcl 55 ref 268
read_password_                  000030 constant        entry                    external dcl 35 ref 250
recursion_flag                  000002 internal static fixed bin(17,0)          initial dcl 95 set ref 273* 535 549* 565*
resume                          000000 stack reference condition                dcl 63 ref 533
resume_label                    000004 internal static label variable           dcl 96 set ref 143* 271* 375 563
root_dir                        000303 automatic       char(168)                initial dcl 87 set ref 87* 127* 234* 287* 415*
scramble_                       000072 constant        entry                    external dcl 57 ref 255
standard_default_handler_       000074 constant        entry                    external dcl 58 ref 485
stat                                   based           structure                level 1 dcl 100
station                         000227 automatic       char(32)                 unaligned dcl 84 set ref 244* 246 246 249* 249 259*
                                                                                  268*
status                          000100 automatic       bit(72)                  dcl 311 in procedure "clean_up" set ref 316* 320*
status                          000240 automatic       bit(72)                  dcl 85 in procedure "cards_overseer_" set ref 151*
                                                                                  152* 157* 159 159 162 179* 201* 202 202 205 212*
                                                                                  213 213 219* 220 220 225* 226 228 279* 280 282
                                                                                  514*
stream_info                     000360 automatic       structure                level 1 dcl 104 set ref 287 287
stream_name                     000202 automatic       char(32)                 dcl 78 set ref 199* 201* 205* 210* 212* 217* 219*
substr                                                 builtin function         dcl 66 ref 169 249 338 398
temp_password                   000356 automatic       char(8)                  unaligned dcl 89 set ref 254* 255* 256*
test_sw                         000000 internal static bit(1)                   initial dcl 90 set ref 126* 179 287* 300 379 432 476
                                                                                  539 557
user_mode                       000067 constant        bit(36)                  initial dcl 92 set ref 234*
validate_card_input_$station    000076 constant        entry                    external dcl 60 ref 259
version                   2     000116 automatic       fixed bin(17,0)          level 2 dcl 461 set ref 467*
wcptr                    16     000116 automatic       pointer                  level 2 dcl 461 set ref 473
word1                                  based           fixed bin(35,0)          level 2 dcl 100 set ref 159 159 162* 202 202 205*
                                                                                  213 213 220 220 226 228* 280 282*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
alrm                            000000 stack reference condition                dcl 63
cput                            000000 stack reference condition                dcl 63
finish                          000000 stack reference condition                dcl 63
ioa_$ioa_stream_nnl             000000 constant        entry                    external dcl 37
stream_info_ptr                        automatic       pointer                  dcl 1-6

NAMES DECLARED BY EXPLICIT CONTEXT.
ask                             002562 constant        label                    dcl 273 ref 271 291
attach_err                      001716 constant        label                    dcl 205 ref 213 220
call_sdh                        004077 constant        label                    dcl 485 ref 490 492
cards_handler                   004014 constant        entry                    internal dcl 451 ref 141
cards_overseer_                 000772 constant        entry                    external dcl 12
clean_up                        002760 constant        entry                    internal dcl 308 ref 139 297 363
command_level                   003061 constant        entry                    internal dcl 324 ref 277 506 526
exit                            002741 constant        label                    dcl 297 ref 176 207 238 266 284 368 379
get_line                        003066 constant        label                    dcl 329 ref 344 358 387 404 407 412 419 437 442 447
no_attach                       001536 constant        label                    dcl 174 ref 143 167 230 247 335 395
only_after_quit                 003772 constant        label                    dcl 444 ref 347 371
re_init                         001357 constant        label                    dcl 157 ref 171 365
read_again                      003105 constant        label                    dcl 332 ref 341
return_label                    004656 constant        label                    dcl 565 ref 533
set_station                     002506 constant        label                    dcl 268 ref 260
start                           001105 constant        label                    dcl 131 ref 111
test                            001005 constant        entry                    external dcl 115

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5276        5410    4662        5400
Length      5742    4662       102         316     413          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cards_overseer_                     370 external procedure  is an external procedure.  
on unit on line 139                  64 on unit               
on unit on line 141                  64 on unit               
clean_up                            106 internal procedure  is called by several nonquick procedures.  
command_level                       151 internal procedure  is called by several nonquick procedures.  
cards_handler                       216 internal procedure  enables or reverts conditions.  
on unit on line 500                  64 on unit               
on unit on line 533                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000000 test_sw                     cards_overseer_
000001 quit_flag                   cards_overseer_
000002 recursion_flag              cards_overseer_
000004 resume_label                cards_overseer_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cards_handler            000100 mcptr                       cards_handler
                         000102 condition                   cards_handler
                         000112 coptr                       cards_handler
                         000114 info_ptr                    cards_handler
                         000116 cond_info                   cards_handler
                         000150 code                        cards_handler
cards_overseer_          000114 answer                      cards_overseer_
                         000140 age                         cards_overseer_
                         000141 card_device                 cards_overseer_
                         000151 card_dim                    cards_overseer_
                         000161 code                        cards_overseer_
                         000162 dev                         cards_overseer_
                         000172 dim                         cards_overseer_
                         000202 stream_name                 cards_overseer_
                         000212 iocbp                       cards_overseer_
                         000214 i                           cards_overseer_
                         000215 ig                          cards_overseer_
                         000216 nchar                       cards_overseer_
                         000217 password                    cards_overseer_
                         000227 station                     cards_overseer_
                         000240 status                      cards_overseer_
                         000242 error_msg                   cards_overseer_
                         000303 root_dir                    cards_overseer_
                         000356 temp_password               cards_overseer_
                         000360 stream_info                 cards_overseer_
clean_up                 000100 status                      clean_up
                         000102 i                           clean_up

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              tra_ext
tra_label_var       enable              ss_ext_entry        ss_ext_entry_desc   ss_int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      condition_interpreter_        continue_to_signal_           cu_$arg_count
cv_dec_check_                 debug                         find_condition_info_          get_at_entry_
ioa_                          ioa_$ioa_stream               ios_$attach                   ios_$detach
ios_$getsize                  ios_$resetread                ios_$setsize                  iox_$control
iox_$get_line                 logout                        new_proc                      pool_manager_$clean_pool
pool_manager_$init            read_cards_                   read_cards_$set_station       read_password_
scramble_                     standard_default_handler_     validate_card_input_$station

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ionmat           iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     73 000756        74 000761        87 000764        12 000771       111 001000       115 001001       120 001033
    122 001045       124 001061       126 001062       127 001065       128 001073       129 001100       131 001105
    133 001106       134 001122       135 001136       139 001141       141 001163       143 001205       144 001211
    148 001212       149 001244       151 001250       152 001307       155 001353       157 001357       159 001415
    162 001424       164 001461       165 001475       166 001500       167 001523       169 001525       171 001532
    174 001536       176 001552       179 001553       182 001610       183 001613       185 001615       186 001620
    188 001623       189 001626       191 001631       192 001634       194 001637       195 001642       199 001645
    201 001650       202 001711       205 001716       207 001754       210 001755       212 001760       213 002023
    217 002030       219 002033       220 002074       224 002101       225 002111       226 002133       228 002137
    230 002177       232 002200       234 002202       235 002231       237 002233       238 002265       243 002266
    244 002273       245 002301       246 002315       247 002340       249 002342       250 002347       252 002372
    254 002376       255 002401       256 002415       259 002417       260 002443       263 002445       264 002464
    265 002466       266 002505       268 002506       270 002523       271 002556       273 002562       275 002564
    277 002565       279 002571       280 002614       282 002620       284 002652       287 002653       288 002713
    291 002740       297 002741       300 002745       302 002751       571 002756       308 002757       314 002765
    316 002775       318 003023       320 003025       322 003057       324 003060       329 003066       332 003105
    334 003111       335 003134       338 003142       339 003150       341 003165       344 003171       347 003175
    352 003205       357 003214       358 003230       361 003231       363 003235       364 003242       365 003244
    368 003247       371 003256       374 003266       375 003267       379 003271       383 003304       385 003311
    386 003330       387 003335       390 003336       392 003342       393 003356       394 003362       395 003405
    398 003413       399 003421       400 003445       402 003450       404 003464       407 003465       409 003467
    411 003471       412 003505       415 003506       417 003534       419 003562       422 003563       424 003567
    425 003603       426 003617       427 003633       428 003647       429 003663       430 003677       432 003713
    434 003717       435 003732       437 003745       440 003746       442 003771       444 003772       447 004012
    451 004013       467 004021       469 004023       471 004041       472 004045       473 004047       474 004051
    476 004053       479 004063       480 004072       483 004073       485 004077       487 004130       490 004131
    492 004135       495 004141       497 004145       500 004151       502 004170       504 004174       505 004177
    506 004213       507 004220       508 004222       511 004223       514 004227       517 004247       519 004252
    520 004302       521 004333       523 004334       524 004347       526 004352       528 004357       529 004361
    530 004412       533 004413       535 004432       537 004435       539 004474       541 004500       542 004517
    543 004524       546 004525       549 004532       551 004535       553 004555       557 004623       559 004627
    560 004646       563 004653       565 004656       567 004660


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
