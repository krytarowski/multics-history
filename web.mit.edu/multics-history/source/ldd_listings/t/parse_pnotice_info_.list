	COMPILATION LISTING OF SEGMENT parse_pnotice_info_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/17/86  1453.8 mst Mon
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  parse_pnotice_info_.rd          	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  03/17/86  1453.8 mst Mon                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
       14*   *                                                         *
       15*   *********************************************************** */
       16 
       17 
       18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       19 	/*									*/
       20 	/* parse_pnotice_info_:  A routine to parse >tools>psp_info_ for display_psp and	*/
       21 	/* generate_pnotice commands.							*/
       22 	/*									*/
       23 	/* 0) Created 04/14/81 by R. Holmstedt						*/
       24 	/* 1) Modified 10/15/84 by G. Dixon - use search rules to find psp_info_.		*/
       25 	/*									*/
       26 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       27 
       28 /*  open set of reductions for software ids  */
       29 
       30 /*++
       31*BEGIN	/<no-token>		/ERROR (1) /RETURN   \  
       32*
       33*
       34*in_parm  /Define : <validate_MI> ;      /LEX (2) MI_prod LEX (2)   /in_parm \
       35*
       36*3       /product : <any-token> ;        /LEX (2) prod_name LEX (2)  /in_parm \
       37*
       38*4       /titles : <quoted-string> ;     /LEX (2) prod_title LEX (2) /in_parm \
       39*
       40*5       /STI : <validate_STI> ;         /LEX (2) prod_STI LEX (2)   /in_parm \
       41*
       42*
       43*6       /use : <any-token> ;            /LEX (2) prod_USE LEX (2)   /in_parm \
       44*
       45*7       /source_C :                     /LEX (2) [obj_sw = "0"b] PUSH(in_parm)      /names   \
       46*
       47*8       /object_C :                     /LEX (2) [obj_sw = "1"b] PUSH(in_parm)      /names   \
       48*
       49*9       /x_path : <check_path> ;        /LEX (2) prod_path("xecute") LEX (2)  /in_parm \
       50*10      /x_path : <any-token> ;	/LEX (2) ERROR (2) NEXT_STMT/in_parm \
       51*
       52*11      /source_path : <check_path> ;   /LEX (2) prod_path("source") LEX (2)  /in_parm \
       53*12      /source_path : <any-token> ;	/LEX (2) ERROR (2) NEXT_STMT/in_parm \
       54*
       55*13      /object_path : <check_path> ;	/LEX (2) prod_path("object") LEX (2)  /in_parm \
       56*14      /object_path : <any-token> ;	/LEX (2) ERROR (2) NEXT_STMT/in_parm \
       57*
       58*
       59*15      / End;	   	           / LEX (2)	       / finish \
       60*16       /<any-token>                    /ERROR(4)  NEXT_STMT      /in_parm \
       61*17       /<no-token>                     /ERROR (3)	       /RETURN \
       62*
       63*
       64*finish
       65*18	/ <any-token>		 / ERROR (5)               / RETURN \
       66*19	/ <no-token>	           /		       / RETURN \
       67*
       68*names    / <any-token>                   /prod_C LEX PUSH(names)   /punct    \
       69*21       / ;                             /ERROR(2) LEX             /STACK_POP\
       70*22       / ,                             / LEX                     /names    \
       71*23       / <any-token>                   /ERROR(2) LEX PUSH(names) /punct    \
       72*24       / <no-token>                    /ERROR(3)                 /RETURN   \
       73*
       74*punct    /;                               / LEX POP                /STACK_POP\
       75*26       /,                               / LEX                    /STACK_POP\
       76*27       / <any-token>                    / ERROR(2) NEXT_STMT POP /STACK_POP\
       77*28       / <no-token >                    / ERROR(2)               /RETURN   \
       78*
       79*++*/
       80 
       81 
       82 
       83 /*   close set of reductions    */
       84 
       85 
       86 
       87 
       88 
       89 
       90 parse_pnotice_info_: procedure (input_ptr, code);
       91 
       92 dcl (APstmt, APtoken) ptr init (null ());
       93 dcl  LEGAL char (80)aligned init ("    0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'_-^` ");
       94 dcl (LEXDLM, LEXCTL) char (128) varying internal static;
       95 dcl (BREAKS, IGBREAKS) char (128) varying internal static;
       96 dcl Ccode fixed bin (35);
       97 dcl STI char(12);
       98 dcl bit_ch fixed bin (24);
       99 dcl bc fixed bin (21);
      100 dcl code fixed bin (35);
      101 dcl count_S fixed bin;
      102 dcl count_O fixed bin;
      103 dcl cf_ptr ptr;
      104 dcl dirname char(168);
      105 dcl 01 error_control_table (6) internal static options (constant),
      106        02 severity fixed bin (17) unaligned init ((6) 2),
      107        02 Soutput_stmt bit (1) unaligned init ((6) (1) "1"b),
      108        02 message char (80) varying init (
      109 /* ERROR 1*/ "The psp_info_ segment contains no statments.",
      110 /* ERROR 2*/ "The psp_info_ segment contains an incorrect line.",
      111 /* ERROR 3*/ "The psp_info_ segment does not contain an End statment.",
      112 /* ERROR 4*/ "The line containing the keyword ""^a"" is incorrect.",
      113 /* ERROR 5*/ "Text follows the End statment.",
      114 /* ERROR 6*/ "The STI ""^a"" is incorrect, only uppercase letters or numbers are valid."),
      115        02 brief_message char (4) varying init ((6) (1) " ");
      116 
      117 dcl expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
      118 dcl entryname char (32);
      119 dcl  first bit (1) init ("1"b) int static;
      120 dcl hcs_$status_mins entry (ptr, fixed bin(2), fixed bin(24), fixed bin(35));
      121 dcl i fixed bin;
      122 dcl ii fixed bin init (0);
      123 dcl input_ptr ptr;			/* passed in from a call	       */
      124 dcl lex_error_ entry options (variable);
      125 dcl lex_string_$init_lex_delims entry (char(*), char(*), char(*), char(*),
      126 	char(*), bit(*), char(*) var, char(*) var, char(*) var, char(*) var);
      127 
      128 dcl lex_string_$lex  entry (ptr, fixed bin(21), fixed bin(21), ptr, bit(*),
      129 	char(*), char(*), char(*), char(*), char(*), char(*) var,
      130 	char(*) var, char(*) var, char(*) var, ptr, ptr, fixed bin(35));
      131 dcl name char(19) init ("");
      132 dcl obj_sw bit (1);
      133 dcl pathname char (168);
      134 dcl proc_ptr  ptr;
      135 dcl 01 product_init aligned int static options (constant),
      136        02 num(1),
      137           03 MI char (7) init (""),
      138           03 prod_name char(20) init (""),
      139           03 prod_title char (80) init (""),
      140           03 prod_STI char (12) init (""),
      141           03 source_C(10) char (24) init ((10) (1) ""),
      142           03 object_C(10) char (24) init ((10) (1) ""),
      143 	   03 x_path,
      144 	      04 dirname char(168) init (""),
      145 	      04 entryname char(32) init (""),
      146 	   03 source_path,
      147 	      04 dirname char(168) init (""),
      148 	      04 entryname char(32) init (""),
      149 	   03 object_path,
      150 	      04 dirname char(168) init (""),
      151 	      04 entryname char(32) init (""),
      152           03 prod_use(10) char (7) init ((10) (1)"");
      153 dcl  psp_info_$ fixed bin(35) ext static;
      154 dcl  translator_temp_$get_segment entry (char(*), ptr, fixed bin(35));
      155 dcl  translator_temp_$release_all_segments entry (ptr, fixed bin(35));
      156 
      157 
      158 dcl  error_table_$translation_failed fixed bin (35) ext static;
      159 
      160 dcl (addr, collate, dimension, divide, length, null, substr, verify) builtin;
      161 
      162 
      163 
  1     1 /***********      Start of software_pnotice_info_.incl.pl1           *********/
  1     2 /* This file contains the structure used by the software information tools   */
  1     3 /*  -Written by R. Holmstedt 04/18/81				       */
  1     4 	
  1     5 
  1     6 dcl 01 product aligned based (SI_ptr),	/* each PSP will have a entry	       */
  1     7 	02 prod_number fixed bin,	/* product count		       */
  1     8 	02 num (0 refer (product.prod_number)),
  1     9 	   03 MI char(7),		/* marketing number of this product  */
  1    10 	   03 prod_name char(20),	/* generic name of the product       */
  1    11 	   03 prod_title char(80),	/* long explaination of the product  */
  1    12 	   03 prod_STI char(12),	/* software technical identifier     */
  1    13              03 source_C (10) char(24),   /* products copyright for source   */
  1    14              03 object_C (10) char(24),   /* products copyright for object   */
  1    15 	   03 x_path,
  1    16 	      04 dirname char(168),
  1    17 	      04 entryname char(32),
  1    18 	   03 source_path,
  1    19 	      04 dirname char(168),
  1    20 	      04 entryname char(32),
  1    21 	   03 object_path,
  1    22 	      04 dirname char(168),
  1    23 	      04 entryname char(32),
  1    24              03 prod_use(10) char(7);    /* market number of many products
  1    25*                                            that make up this one MI         */
  1    26 	 dcl SI_ptr ptr;
  1    27 	
  1    28 /***********      End   of software_pnotice_info_.incl.pl1           *********/
      164 
      165 
      166 	   
      167 /* START			       */
      168 	name = "parse_pnotice_info_";        /* set command name */
      169 	cf_ptr = null;
      170 	proc_ptr = null;
      171 
      172 	call translator_temp_$get_segment (name, proc_ptr, code);
      173 				/* area for lex_string_	       */
      174 	if  code ^= 0 then goto fini;
      175 	
      176 	SI_ptr = input_ptr;		/* work area for info structure      */
      177 
      178 	product.prod_number = 0;	/* init the structure count	       */
      179 	
      180 
      181 	cf_ptr = addr(psp_info_$);
      182 	call hcs_$status_mins (cf_ptr, 0, bit_ch, code);
      183 
      184 	bc = divide (bit_ch + 8, 9, 24, 0);
      185 	if first then do;
      186 	     BREAKS = substr (collate (), 1, 8) || substr (collate (), 10, 24) || "()*,:;^";
      187 	     IGBREAKS = substr (collate (), 1, 8) || substr (collate (), 10, 24);
      188 
      189 	     call lex_string_$init_lex_delims ("""", """", "/*", "*/", ";", "10"b, BREAKS, IGBREAKS, LEXDLM, LEXCTL);
      190 	     first = "0"b;
      191 
      192 	end;
      193 
      194 
      195 	call lex_string_$lex
      196           (cf_ptr, bc, 0, proc_ptr, "100"b, """", """", "/*", "*/", ";", BREAKS, IGBREAKS, LEXDLM, LEXCTL, APstmt, APtoken, code);
      197 	Pthis_token = APtoken;
      198 
      199 	call SEMANTIC_ANALYSIS ();
      200 
      201 	if MERROR_SEVERITY > 1 then do;
      202 
      203 	     if code = 0 then code =  error_table_$translation_failed;
      204 	     goto fini;
      205 	end;
      206 
      207 
      208 fini:	if proc_ptr ^= null then
      209 	     call translator_temp_$release_all_segments ( proc_ptr, Ccode);
      210 	 proc_ptr = null;
      211 	 cf_ptr = null;
      212 	 SI_ptr = null;
      213 	return;
      214 	
      215 
      216 /*\014 */
      217 MI_prod: proc;
      218 
      219 
      220 	     product.prod_number = product.prod_number + 1;	/* fill up the structure   */
      221 	     product.num(product.prod_number) = product_init.num(1);
      222 				/* clean it up before using	       */
      223 
      224 	     product.num(product.prod_number).MI = token_value;
      225 
      226 	     ii = 0;		/* init the Use field count	       */
      227 	     count_O = 0;		/*init the count of object for prod_C*/
      228 	     count_S = 0;		/*init the count of source for prod_C*/
      229 
      230 	     return;
      231 	end MI_prod;
      232 
      233 prod_name: proc;
      234 
      235 
      236 	     product.num(product.prod_number).prod_name = token_value;
      237 
      238 	     return;
      239 	end prod_name;
      240 
      241 
      242 check_path: proc returns (bit (1));
      243 
      244 dcl  R bit (1);
      245 dcl expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
      246 dcl dirname char(168);
      247 dcl entryname char (32);
      248 dcl pathname char (168);
      249 	  
      250 	  pathname = token_value;
      251 	  call expand_pathname_ (pathname, dirname, entryname, code);
      252 	  if code = 0 then R = "1"b;
      253 	  else R = "0"b;
      254 	  return (R);
      255        end check_path;
      256        
      257 
      258 prod_title: proc;
      259 	     product.num(product.prod_number).prod_title = token_value;
      260 
      261 	     return;
      262 	end prod_title;
      263 
      264 
      265 prod_USE: proc;
      266 
      267 				/* set ii to 0 in MI_prod procedure  */
      268 	ii = ii + 1;		/* count the number of MIs  used*/
      269 	product.num(product.prod_number).prod_use(ii) = token_value;
      270 
      271 	return;
      272 	end prod_USE;
      273 
      274 validate_MI:
      275 	proc returns (bit (1));
      276 	
      277 	dcl alph char(26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      278 	dcl numbers char (10) init static options (constant) init ("1234567890");
      279 	dcl MI_check char (7);
      280 
      281 	if length(token_value) ^= 7 then return ("0"b);
      282 
      283 	MI_check = token_value;
      284 	if verify (substr(MI_check,1,3), alph) ^= 0 then return ("0"b);
      285 
      286 	if verify(substr(MI_check,4,4), numbers) ^= 0 then return ("0"b);
      287 	return ("1"b);
      288      end validate_MI;
      289      
      290 	 
      291 validate_STI: proc  returns (bit (1));
      292 
      293 	    dcl parse_pnotice_info_$validate_sti entry (char(12)) returns (bit(1));
      294 
      295 	    STI = token_value;
      296 	    if parse_pnotice_info_$validate_sti (STI) then return ("1"b);
      297 	    else return ("0"b);
      298 	    
      299 
      300          end validate_STI;
      301 
      302 prod_STI:	    proc;
      303 	    
      304 	    product.num(product.prod_number).prod_STI = token_value;
      305 	    return;
      306 	    end prod_STI;
      307 	         
      308 
      309 prod_C: proc;
      310         
      311         if obj_sw then do;
      312 	   count_O = count_O + 1;
      313 	   product.num(product.prod_number).object_C(count_O) = token_value;
      314         end;
      315         else do;
      316 	   count_S = count_S + 1;
      317 	   product.num(product.prod_number).source_C(count_S) = token_value;
      318         end;
      319 	     return;
      320 	end prod_C;
      321 
      322 prod_path: proc (type);
      323 
      324 dcl type char (6);
      325 	 
      326 	  
      327 	  pathname = token_value;
      328 	  call expand_pathname_ (pathname, dirname, entryname, code);
      329 	  if code ^= 0 then do;
      330 	       call statement_error (2, token_value, "");
      331 	       return;
      332 	  end;
      333 	  
      334 	  if type = "source" then do;
      335 	     product.num(product.prod_number).source_path.dirname = dirname;
      336 	     product.num(product.prod_number).source_path.entryname = entryname;
      337 	end;
      338 	else if type = "object" then do;
      339 	     product.num(product.prod_number).object_path.dirname = dirname;
      340 	     product.num(product.prod_number).object_path.entryname = entryname;
      341 	end;
      342 	else if type = "xecute" then do;
      343 	     product.num(product.prod_number).x_path.dirname = dirname;
      344 	     product.num(product.prod_number).x_path.entryname = entryname;
      345 	end;
      346 	     return;
      347 	end prod_path;
      348 
      349 
      350 statement_error: proc (error_num, parm1, parm2);
      351 
      352 dcl  error_num fixed bin;
      353 dcl  parm1 char (*);
      354 dcl  parm2 char (*);
      355 dcl (stmt_ptr, token_ptr) ptr init (null);
      356 
      357 	     stmt_ptr = token.Pstmt;
      358 	     token_ptr = Pthis_token;
      359 
      360 	     call lex_error_ (error_num, SERROR_PRINTED (error_num), (error_control_table.severity (error_num)),
      361 		MERROR_SEVERITY, stmt_ptr, token_ptr, SERROR_CONTROL,
      362 		(error_control_table.message (error_num)), (error_control_table.brief_message (error_num)),
      363 		parm1, parm2);
      364 
      365 	     return;
      366 
      367 	end statement_error;
      368 
      369 validate_sti: entry (entered_value) returns (bit (1));
      370 
      371 	dcl R bit (1);
      372 	dcl entered_value char(12);
      373 	dcl valid_numeric char(36) int static options (constant)  init("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
      374 
      375 	    R = "1"b;
      376 
      377 	    do i = 1 to 12;
      378 	         if verify (substr(entered_value,i,1),valid_numeric) ^= 0 then R = "0"b;
      379 				/* only uppercase and numbers valid  */
      380 	    end;
      381 
      382 
      383 	    if verify (substr(entered_value,2,1),"1234") ^= 0 then R = "0"b;
      384 				/* only 4 numbers are valid	       */
      385 
      386 	    return (R);		/* good return		       */
      387 
      388 
      389 
      390      dcl	TRACING			bit(1) aligned int static init("0"b);
      391 
      392 
  2     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     4 	/*							*/
  2     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  2     6 	/*							*/
  2     7 	/*      This include segment is used by compilers generated by the	*/
  2     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  2     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  2    10 	/* compares a chain of input tokens with token requirements		*/
  2    11 	/* specified in reductions.  This include segment declares the 	*/
  2    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  2    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  2    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  2    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  2    16 	/*							*/
  2    17 	/* S__t_a_t_u_s							*/
  2    18 	/*							*/
  2    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  2    20 	/*							*/
  2    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    22 
  2    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  2    24 
  3     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  3     2 	
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     4 	/*							*/
  3     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  3     6 	/*							*/
  3     7 	/*      This include segment defines the structure of the token	*/
  3     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  3     9 	/* by the lex_string_ program.				*/
  3    10 	/*							*/
  3    11 	/* Status:						*/
  3    12 	/*							*/
  3    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  3    14 	/*							*/
  3    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3    16 	
  3    17 	
  3    18 	
  3    19 	
  3    20      dcl	
  3    21 	1 comment			aligned based (Pcomment),
  3    22 						/* descriptor for a comment.			*/
  3    23 	  2 group1		unaligned,
  3    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  3    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  3    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  3    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  3    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  3    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  3    30 	  2 group2		unaligned,
  3    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  3    32 	    3 S,					/* switches:				*/
  3    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  3    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  3    35 	      4 pad		bit(16),
  3    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  3    37 						/* body of comment.				*/
  3    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  3    39 	
  3    40      dcl	
  3    41 	1 stmt			aligned based (Pstmt),
  3    42 						/* descriptor for a statement.		*/
  3    43 	  2 group1		unaligned,
  3    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  3    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  3    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  3    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  3    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  3    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  3    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  3    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  3    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  3    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  3    54 	  2 group2		unaligned,
  3    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  3    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  3    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  3    58 						/* (the number includes this stmt.)		*/
  3    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  3    60 	    3 S,					/* switches:				*/
  3    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  3    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  3    63 	      4 pad		bit(34),
  3    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  3    65 						/* text of the statement.			*/
  3    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  3    67 	
  3    68      dcl	
  3    69 	1 token			aligned based (Ptoken),
  3    70 						/* descriptor for a token.			*/
  3    71 	  2 group1		unaligned,
  3    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  3    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  3    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  3    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  3    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  3    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  3    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  3    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  3    80 	  2 group2		unaligned,
  3    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  3    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  3    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  3    84 	    3 S,					/* switches:				*/
  3    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  3    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  3    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  3    88 						/* string (as doubled quotes on input.)		*/
  3    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  3    90 						/* string has been lexed into a token.		*/
  3    91 	      4 pad2		bit(32),
  3    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  3    93 						/* value of the token.			*/
  3    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  3    95 
  3    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  2    25 
  2    26 
  2    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    28 
  2    29 
  2    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  2    31 						/* semantics of the tokens in the input list.	*/
  2    32 
  2    33      dcl						/*	automatic variables			*/
  2    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  2    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  2    36 						/* compared to.				*/
  2    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  2    38 						/* compared to.				*/
  2    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  2    40 						/* with reduction tokens are being compared to.	*/
  2    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  2    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  2    43 	CODE			fixed bin(35),	/* an error code.				*/
  2    44 	I			fixed bin,	/* a do-group index.			*/
  2    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  2    46 						/* number character string.			*/
  2    47 
  2    48      dcl						/*	based variables			*/
  2    49 	1 RED			aligned based (PRED),
  2    50 						/* descriptor for reduction tokens are being 	*/
  2    51 						/* compared to.				*/
  2    52 	  2 TOKEN_REQD		unaligned,
  2    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  2    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  2    55 						/* with this reduction.			*/
  2    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  2    57 						/* a token requirement descriptor.		*/
  2    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  2    59 						/*  -1 = relative token requirement function;	*/
  2    60 						/*       TYPE = index of the particular token	*/
  2    61 						/*	      function in the token_fcn array.	*/
  2    62 						/*   0 = built-in token requirement function;	*/
  2    63 						/*       TYPE = as defined below.		*/
  2    64 						/*  >0 = absolute token requirement:		*/
  2    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  2    66 						/*       TYPE = length(TOKEN_REQD);		*/
  2    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  2    68 						/*   1 = compile test to see if input token 	*/
  2    69 						/*       chain is exhausted (<no-token>).	*/
  2    70 						/*   2 = compile test for any token value	*/
  2    71 						/*       (<any-token>).			*/
  2    72 						/*   3 = compile test for a PL/I identifier	*/
  2    73 						/*       (<name>) of 32 or fewer characters.	*/
  2    74 						/*   4 = compile test for token which is a	*/
  2    75 						/*       <decimal-integer>.			*/
  2    76 						/*   5 = compile test for token which is a single	*/
  2    77 						/*       backspace character (<BS>).		*/
  2    78 						/*   6 = compile test for a token which is a	*/
  2    79 						/*       <quoted-string>.			*/
  2    80 
  2    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  2    82 						/* overlay for an absolute token requirement	*/
  2    83 						/* descriptor.				*/
  2    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  2    85 						/* absolute token string assoc w/ descriptor.	*/
  2    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  2    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  2    88 						/* absolute token string which token is reqd	*/
  2    89 						/* to match in order for tokens which are	*/
  2    90 						/* "current" on the list to match the reduction.	*/
  2    91 
  2    92      dcl						/*	builtin functions			*/
  2    93          (addr, max, null, search, substr, verify)
  2    94 				builtin;
  2    95 
  2    96      dcl						/*	entries				*/
  2    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  2    98 
  2    99      dcl						/*	static variables			*/
  2   100 	BACKSPACE			char(1) aligned int static init ("");
  2   101 
  2   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
      393 
      394 
      395      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
      396      dcl	STACK (10)   		fixed bin,	/* reduction label stack.			*/
      397 	STACK_DEPTH		fixed bin init (0);	/* index into STACK.			*/
      398 
      399 
      400      dcl	1 REDUCTION (28)		unaligned based (addr (REDUCTIONS)),
      401 						/* object reductions.			*/
      402 	  2 TOKEN_REQD,
      403 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
      404 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
      405 
      406 	REDUCTIONS  (56)		fixed bin(17) unaligned internal static options(constant) initial (
      407 	         1,     1,	/*     1/  <no-token>                                                           */
      408 	         2,     5,	/*     2/  Define : <validate_MI> ;                                             */
      409 	         6,     9,	/*     3/  product : <any-token> ;                                              */
      410 	        10,    13,	/*     4/  titles : <quoted-string> ;                                           */
      411 	        14,    17,	/*     5/  STI : <validate_STI> ;                                               */
      412 	        18,    21,	/*     6/  use : <any-token> ;                                                  */
      413 	        22,    23,	/*     7/  source_C :                                                           */
      414 	        24,    25,	/*     8/  object_C :                                                           */
      415 	        26,    29,	/*     9/  x_path : <check_path> ;                                              */
      416 	        30,    33,	/*    10/  x_path : <any-token> ;                                               */
      417 	        34,    37,	/*    11/  source_path : <check_path> ;                                         */
      418 	        38,    41,	/*    12/  source_path : <any-token> ;                                          */
      419 	        42,    45,	/*    13/  object_path : <check_path> ;                                         */
      420 	        46,    49,	/*    14/  object_path : <any-token> ;                                          */
      421 	        50,    51,	/*    15/  End ;                                                                */
      422 	         8,     8,	/*    16/  <any-token>                                                          */
      423 	         1,     1,	/*    17/  <no-token>                                                           */
      424 	         8,     8,	/*    18/  <any-token>                                                          */
      425 	         1,     1,	/*    19/  <no-token>                                                           */
      426 	         8,     8,	/*    20/  <any-token>                                                          */
      427 	         5,     5,	/*    21/  ;                                                                    */
      428 	        52,    52,	/*    22/  ,                                                                    */
      429 	         8,     8,	/*    23/  <any-token>                                                          */
      430 	         1,     1,	/*    24/  <no-token>                                                           */
      431 	         5,     5,	/*    25/  ;                                                                    */
      432 	        52,    52,	/*    26/  ,                                                                    */
      433 	         8,     8,	/*    27/  <any-token>                                                          */
      434 	         1,     1);	/*    28/  <no-token>                                                           */
      435 
      436      dcl	1 TOKEN_REQUIREMENT (52)	unaligned based (addr (TOKEN_REQUIREMENTS)),
      437 						/* object token requirements.			*/
      438 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
      439 						/*  -1 = relative token requirement function;	*/
      440 						/*       TYPE = index of the particular token	*/
      441 						/*	      function in the token_fcn array.	*/
      442 						/*   0 = built-in token requirement function;	*/
      443 						/*       TYPE = as defined below.		*/
      444 						/*  >0 = absolute token requirement:		*/
      445 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
      446 						/*       TYPE = length(TOKEN_REQD);		*/
      447 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
      448 						/* function:				*/
      449 						/*   1 = compile test to see if input token 	*/
      450 						/*       chain is exhausted (<no-token>).	*/
      451 						/*   2 = compile test for any token value	*/
      452 						/*       (<any-token>).			*/
      453 						/*   3 = compile test for a PL/I identifier	*/
      454 						/*       (<name>) of 32 or fewer characters.	*/
      455 						/*   4 = compile test for token which is a	*/
      456 						/*       <decimal-integer>.			*/
      457 						/*   5 = compile test for token which is a single	*/
      458 						/*       backspace character (<BS>).		*/
      459 						/*   6 = compile test for a token which is a	*/
      460 						/*       <quoted-string>.			*/
      461 
      462 	TOKEN_REQUIREMENTS  (104)	fixed bin(17) unaligned internal static options(constant) initial (
      463 	         0,    1,       1,    6,       7,    1,      -1,    1,       8,    1,       9,    7,       7,    1,   
      464 	         0,    2,       8,    1,      16,    6,       7,    1,       0,    6,       8,    1,      22,    3,   
      465 	         7,    1,      -1,    2,       8,    1,      25,    3,       7,    1,       0,    2,       8,    1,   
      466 	        28,    8,       7,    1,      36,    8,       7,    1,      44,    6,       7,    1,      -1,    3,   
      467 	         8,    1,      44,    6,       7,    1,       0,    2,       8,    1,      50,   11,       7,    1,   
      468 	        -1,    3,       8,    1,      50,   11,       7,    1,       0,    2,       8,    1,      61,   11,   
      469 	         7,    1,      -1,    3,       8,    1,      61,   11,       7,    1,       0,    2,       8,    1,   
      470 	        72,    3,       8,    1,      75,    1);
      471 
      472 
      473      dcl	TOKEN_STRINGS		char(75) aligned based (addr (TOKEN_STRING_ARRAYS)),
      474 						/* object token values.			*/
      475 	TOKEN_STRING_ARRAYS (1)	char(100) aligned internal static options(constant) initial (
      476 	     "Define:;producttitlesSTIusesource_Cobject_Cx_pathsource_pathobject_pathEnd,");
      477 
      478 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  4     6*     old history comments:
  4     7*      0) Created: April, 1974 by G. C. Dixon
  4     8*      1) Modified: Feb, 1975  by G. C. Dixon
  4     9*         a) support for Version 2.0 of reduction_compiler.
  4    10*      2) Modified: Feb, 1981  by G. C. Dixon
  4    11*         a) support for Version  2.2 of reduction_compiler
  4    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  4    13*                        reductions command.
  4    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  4    15*     install(86-03-17,MR12.0-1032):
  4    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  4    17*     implemented to avoid references through a null pointer.  The two
  4    18*     accepted uses are:
  4    19*     
  4    20*        / <no-token>               / ... / ... \
  4    21*                    A
  4    22*                    |
  4    23*           Pthis_token (points to top of push down stack)
  4    24*     
  4    25*     which checks to see if the push down stack is totally exhausted (ie,
  4    26*     Ptoken = null); and:
  4    27*     
  4    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  4    29*                           A
  4    30*                           |
  4    31*                 Pthis_token (points to top of push down stack)
  4    32*     
  4    33*     which checks to see whether SPECN is topmost on the push down stack
  4    34*     AND is the final token in the input list.
  4    35*                                                   END HISTORY COMMENTS */
  4    36 
  4    37 
  4    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    39 	/*									*/
  4    40 	/* NAME:  rdc_end_.incl.pl1							*/
  4    41 	/*									*/
  4    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  4    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  4    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  4    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  4    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  4    47 	/*									*/
  4    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    49 
  4    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  4    51 						/*   options(constant) because it is never set.	*/
  4    52 	NRED = 1;
  4    53 	go to RD_TEST_REDUCTION;
  4    54 
  4    55 RD_NEXT_REDUCTION:
  4    56 	NRED = NRED + 1;
  4    57 
  4    58 RD_TEST_REDUCTION:
  4    59 	PRED = addr(REDUCTION(NRED));
  4    60 	Ptoken = Pthis_token;
  4    61 
  4    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  4    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  4    64 	     if Ptoken = null then do;
  4    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  4    66 		     if TOKEN_REQD.TYPE = 1 then
  4    67 			go to RD_TEST_TOKEN(1);
  4    68 		go to RD_NEXT_REDUCTION;
  4    69 		end;
  4    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  4    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  4    72 
  4    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  4    74 						/* In push-down-language, there are 2 		*/
  4    75 						/*   interpretations of <no-token>.		*/
  4    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  4    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  4    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  4    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  4    80 			   RED.TOKEN_REQD.IFIRST = I &
  4    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  4    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  4    83 						/*  and is SPECN the final input token?"	*/
  4    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  4    85 						/* down language mode for <no-token>.		*/
  4    86 		else if Ptoken = null then
  4    87 		     go to RD_MATCH_NO_TOKEN;
  4    88 		go to RD_NEXT_REDUCTION;
  4    89 
  4    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  4    91 
  4    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  4    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  4    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  4    95 		     > 0 then
  4    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  4    97 			= 0 then
  4    98 			     go to RD_MATCH;
  4    99 		go to RD_NEXT_REDUCTION;
  4   100 
  4   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  4   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  4   103 		     go to RD_MATCH;
  4   104 		if token.S.quoted_string then
  4   105 		     go to RD_NEXT_REDUCTION;
  4   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  4   107 		if CODE = 0 then do;
  4   108 		     token.Nvalue = NUMBER;
  4   109 		     go to RD_MATCH;
  4   110 		     end;
  4   111 		go to RD_NEXT_REDUCTION;
  4   112 
  4   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  4   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  4   115 			go to RD_MATCH;
  4   116 		go to RD_NEXT_REDUCTION;
  4   117 
  4   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  4   119 		     go to RD_MATCH;
  4   120 		go to RD_NEXT_REDUCTION;
  4   121 		end;
  4   122 
  4   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  4   124 		if token.S.quoted_string then
  4   125 		     go to RD_NEXT_REDUCTION;
  4   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  4   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  4   128 		if token_value = TOKEN_REQD_VALUE then
  4   129 		     go to RD_MATCH;
  4   130 		go to RD_NEXT_REDUCTION;
  4   131 		end;
  4   132 
  4   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      478 
      479 
      480 	     else do;				/* relative syntax function.			*/
      481 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
      482 
      483 RD_TOKEN_FCN(1):	STOKEN_FCN = validate_MI();
      484 		go to RD_TEST_RESULT;
      485 RD_TOKEN_FCN(2):	STOKEN_FCN = validate_STI();
      486 		go to RD_TEST_RESULT;
      487 RD_TOKEN_FCN(3):	STOKEN_FCN = check_path();
      488 		go to RD_TEST_RESULT;
      489 
      490 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
      491 		else go to RD_NEXT_REDUCTION;
      492 		end;
      493 
      494 RD_MATCH:      Ptoken = token.Pnext;
      495 RD_MATCH_NO_TOKEN:
      496 	     end;
      497 	Ptoken = Pthis_token;
      498 	go to RD_ACTION(NRED);
      499 
      500 		/* START OF:	rdc_stack_fcns_.incl.pl1	  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     4 	/*							*/
  5     5 	/* N__a_m_e:  rdc_stack_fcns_.incl.pl1				*/
  5     6 	/*							*/
  5     7 	/*      This include segment is used by compilers generated by the	*/
  5     8 	/* reduction_compiler.  It includes code for manipulating the 	*/
  5     9 	/* reduction label stack.					*/
  5    10 	/*							*/
  5    11 	/* S__t_a_t_u_s							*/
  5    12 	/*							*/
  5    13 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  5    14 	/*							*/
  5    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    16 
  5    17 RD_STACK:	if STACK_DEPTH > 0 then do;
  5    18 	     NRED = STACK (STACK_DEPTH);
  5    19 	     go to RD_TEST_REDUCTION;
  5    20 	     end;
  5    21 	else
  5    22 	     go to RD_NEXT_REDUCTION;
  5    23 
  5    24 RD_STACK_POP:
  5    25 	if STACK_DEPTH > 0 then do;
  5    26 	     NRED = STACK (STACK_DEPTH);
  5    27 	     STACK_DEPTH = max (STACK_DEPTH-1, 0);
  5    28 	     go to RD_TEST_REDUCTION;
  5    29 	     end;
  5    30 	else
  5    31 	     go to RD_NEXT_REDUCTION;
  5    32 
  5    33 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    34 
  5    35 
  5    36 PUSH:	procedure (N);				/* invoked to push reduction number 'N' onto	*/
  5    37 						/* the reduction stack.			*/
  5    38      dcl	N			fixed bin;
  5    39 
  5    40      dcl (addr, dimension, length, null)
  5    41 				builtin;
  5    42 
  5    43      dcl	cu_$cl			entry,
  5    44 	iox_$put_chars		entry (ptr, ptr, fixed bin, fixed bin(35)),
  5    45 	iox_$error_output		ptr ext static,
  5    46 	lex_error_		entry options(variable);
  5    47 
  5    48      dcl	brief_error		char(4) varying initial ("") int static,
  5    49 	long_error		char(234) varying int static init(
  5    50 "An internal stack (the reduction stack) has overflowed.
  5    51 The translation has failed.  Contact translator maintenance
  5    52 personnel for assistance.
  5    53      Processing reduction: ^d
  5    54      Reduction being stacked: ^d
  5    55      Maximum stack depth: ^d"),
  5    56 	non_restart_error		char(33) int static init ("Translation cannot be restarted.
  5    57 ");
  5    58 
  5    59 	if STACK_DEPTH >= dimension (STACK, 1) then do;
  5    60 	     call lex_error_ (0, "0"b, 4, 0, null, null, "11"b, long_error, brief_error, NRED, N,
  5    61 			  dimension(STACK,1));
  5    62 get_to_cl:     call cu_$cl();
  5    63 	     call iox_$put_chars (iox_$error_output, addr(non_restart_error), length(non_restart_error), 0);
  5    64 	     go to get_to_cl;
  5    65 	     end;					/* stack overflow is a non-recoverable error.	*/
  5    66 	else
  5    67 	     STACK_DEPTH = STACK_DEPTH + 1;
  5    68 	STACK (STACK_DEPTH) = N;
  5    69 
  5    70 	end PUSH;
  5    71 
  5    72 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    73 
  5    74 	/* END OF:	rdc_stack_fcns_.incl.pl1	  *  *  *  *  *  *  */
      500 
      501 
      502 
      503 RD_ACTION(1):					/* /					*/
      504 	call 					     ERROR ( 1 );
      505 	return;					/* / RETURN	\			*/
      506 
      507 RD_ACTION(2):					/* /					*/
      508 	call 					     LEX ( 2 );
      509 	call					     MI_prod();
      510 	call 					     LEX ( 2 );
      511 	NRED = 2;
      512 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      513 
      514 RD_ACTION(3):					/* /					*/
      515 	call 					     LEX ( 2 );
      516 	call					     prod_name();
      517 	call 					     LEX ( 2 );
      518 	NRED = 2;
      519 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      520 
      521 RD_ACTION(4):					/* /					*/
      522 	call 					     LEX ( 2 );
      523 	call					     prod_title();
      524 	call 					     LEX ( 2 );
      525 	NRED = 2;
      526 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      527 
      528 RD_ACTION(5):					/* /					*/
      529 	call 					     LEX ( 2 );
      530 	call					     prod_STI();
      531 	call 					     LEX ( 2 );
      532 	NRED = 2;
      533 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      534 
      535 RD_ACTION(6):					/* /					*/
      536 	call 					     LEX ( 2 );
      537 	call					     prod_USE();
      538 	call 					     LEX ( 2 );
      539 	NRED = 2;
      540 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      541 
      542 RD_ACTION(7):					/* /					*/
      543 	call 					     LEX ( 2 );
      544 						     obj_sw = "0"b;
      545 	call PUSH(2);				/*   PUSH(in_parm)                                */
      546 	NRED = 20;
      547 	go to RD_TEST_REDUCTION;			/* / names \                           		*/
      548 
      549 RD_ACTION(8):					/* /					*/
      550 	call 					     LEX ( 2 );
      551 						     obj_sw = "1"b;
      552 	call PUSH(2);				/*   PUSH(in_parm)                                */
      553 	NRED = 20;
      554 	go to RD_TEST_REDUCTION;			/* / names \                           		*/
      555 
      556 RD_ACTION(9):					/* /					*/
      557 	call 					     LEX ( 2 );
      558 	call 					     prod_path ( "xecute" );
      559 	call 					     LEX ( 2 );
      560 	NRED = 2;
      561 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      562 
      563 RD_ACTION(10):					/* /					*/
      564 	call 					     LEX ( 2 );
      565 	call 					     ERROR ( 2 );
      566 	call					     NEXT_STMT();
      567 	NRED = 2;
      568 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      569 
      570 RD_ACTION(11):					/* /					*/
      571 	call 					     LEX ( 2 );
      572 	call 					     prod_path ( "source" );
      573 	call 					     LEX ( 2 );
      574 	NRED = 2;
      575 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      576 
      577 RD_ACTION(12):					/* /					*/
      578 	call 					     LEX ( 2 );
      579 	call 					     ERROR ( 2 );
      580 	call					     NEXT_STMT();
      581 	NRED = 2;
      582 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      583 
      584 RD_ACTION(13):					/* /					*/
      585 	call 					     LEX ( 2 );
      586 	call 					     prod_path ( "object" );
      587 	call 					     LEX ( 2 );
      588 	NRED = 2;
      589 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      590 
      591 RD_ACTION(14):					/* /					*/
      592 	call 					     LEX ( 2 );
      593 	call 					     ERROR ( 2 );
      594 	call					     NEXT_STMT();
      595 	NRED = 2;
      596 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      597 
      598 RD_ACTION(15):					/* /					*/
      599 	call 					     LEX ( 2 );
      600 	NRED = 18;
      601 	go to RD_TEST_REDUCTION;			/* / finish \                          		*/
      602 
      603 RD_ACTION(16):					/* /					*/
      604 	call 					     ERROR ( 4 );
      605 	call					     NEXT_STMT();
      606 	NRED = 2;
      607 	go to RD_TEST_REDUCTION;			/* / in_parm \                         		*/
      608 
      609 RD_ACTION(17):					/* /					*/
      610 	call 					     ERROR ( 3 );
      611 	return;					/* / RETURN	\			*/
      612 
      613 RD_ACTION(18):					/* /					*/
      614 	call 					     ERROR ( 5 );
      615 	return;					/* / RETURN	\			*/
      616 
      617 RD_ACTION(19):					/* /					*/
      618 	return;					/* / RETURN	\			*/
      619 
      620 RD_ACTION(20):					/* /					*/
      621 	call					     prod_C();
      622 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      623 	call PUSH(20);				/*   PUSH(names)                                  */
      624 	NRED = 25;
      625 	go to RD_TEST_REDUCTION;			/* / punct \                           		*/
      626 
      627 RD_ACTION(21):					/* /					*/
      628 	call 					     ERROR ( 2 );
      629 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      630 	go to RD_STACK_POP;				/* / STACK_POP	\			*/
      631 
      632 RD_ACTION(22):					/* /					*/
      633 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      634 	NRED = 20;
      635 	go to RD_TEST_REDUCTION;			/* / names \                           		*/
      636 
      637 RD_ACTION(23):					/* /					*/
      638 	call 					     ERROR ( 2 );
      639 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      640 	call PUSH(20);				/*   PUSH(names)                                  */
      641 	NRED = 25;
      642 	go to RD_TEST_REDUCTION;			/* / punct \                           		*/
      643 
      644 RD_ACTION(24):					/* /					*/
      645 	call 					     ERROR ( 3 );
      646 	return;					/* / RETURN	\			*/
      647 
      648 RD_ACTION(25):					/* /					*/
      649 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      650 	STACK_DEPTH = max(STACK_DEPTH-1,0);		/*   POP					*/
      651 	go to RD_STACK_POP;				/* / STACK_POP	\			*/
      652 
      653 RD_ACTION(26):					/* /					*/
      654 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      655 	go to RD_STACK_POP;				/* / STACK_POP	\			*/
      656 
      657 RD_ACTION(27):					/* /					*/
      658 	call 					     ERROR ( 2 );
      659 	call					     NEXT_STMT();
      660 	STACK_DEPTH = max(STACK_DEPTH-1,0);		/*   POP					*/
      661 	go to RD_STACK_POP;				/* / STACK_POP	\			*/
      662 
      663 RD_ACTION(28):					/* /					*/
      664 	call 					     ERROR ( 2 );
      665 	return;					/* / RETURN	\			*/
      666 
      667 
      668 	end SEMANTIC_ANALYSIS;
      669 
      670 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      671 
      672      dcl	SPDL			bit(1) aligned init ("0"b);
      673 						/* off: This compiler parses a non-PUSH DOWN	*/
      674 						/*      LANGUAGE.				*/
      675 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 	/*									*/
  6     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  6     6 	/*									*/
  6     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  6     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  6     9 	/* "current" token, Pthis_token.						*/
  6    10 	/*									*/
  6    11 	/* E__n_t_r_y:  LEX								*/
  6    12 	/*									*/
  6    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  6    14 	/* _n is its positive (or negative) input argument.				*/
  6    15 	/*									*/
  6    16 	/* U__s_a_g_e									*/
  6    17 	/*									*/
  6    18 	/*      call LEX(n);							*/
  6    19 	/*									*/
  6    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  6    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  6    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  6    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  6    24 	/*									*/
  6    25 	/* S__t_a_t_u_s									*/
  6    26 	/*									*/
  6    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  6    28 	/*									*/
  6    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    30 
  6    31 LEX:	procedure (n);
  6    32 
  6    33      dcl	n			fixed bin,
  6    34 	i			fixed bin;
  6    35 
  6    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  6    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  6    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  6    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  6    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  6    41 		end;
  6    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  6    43 						/*   running off end of token list.		*/
  6    44 	     end;
  6    45 	else					/* new "current" token precedes present one.	*/
  6    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  6    47 		Ptoken = token.Plast;
  6    48 		end;
  6    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  6    50 
  6    51 	end LEX;
  6    52 
  6    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      675 
      676 
      677 		/* START OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3      dcl	MERROR_SEVERITY		fixed bin init (0),	/* Severity of highest-severity error.		*/
  7     4 	SERROR_CONTROL		bit(2) init ("00"b),/* Global switches control error message format.	*/
  7     5 	SERROR_PRINTED (dimension (error_control_table,1))
  7     6 				bit(1) unaligned init ((dimension (error_control_table,1))(1)"0"b),
  7     7 						/* Array bit is on if corresponding error message	*/
  7     8 						/* in error_control_table has already been printed*/
  7     9 	MIN_PRINT_SEVERITY		fixed bin init (0), /* Mimimum severity message that will be printed	*/
  7    10 	PRINT_SEVERITY_CONTROL	bit(2) init ("11"b);/* Action if severity < MIN_PRINT_SEVERITY	*/
  7    11 
  7    12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    13 	/*									*/
  7    14 	/* N__a_m_e:  rdc_error_.incl.pl1							*/
  7    15 	/*									*/
  7    16 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  7    17 	/* It defines a procedure which the compilers can use to print error messages.  	*/
  7    18 	/*									*/
  7    19 	/* E__n_t_r_y:  ERROR								*/
  7    20 	/*									*/
  7    21 	/*      Given an error number, this procedure prints a corresponding error message.	*/
  7    22 	/* The message is stored in a compiler-defined error_control_table, along with an integer	*/
  7    23 	/* which specifies the severity level of the error, and a switch which specifies whether	*/
  7    24 	/* the source statement in which the error occurred (if any) should be printed after the	*/
  7    25 	/* error message.  The printing of the error message may be supressed for all messages	*/
  7    26 	/* having a severity less than a specified (MIN_PRINT_SEVERITY) value.  The ERROR	*/
  7    27 	/*  procedure calls the lex_error_ subroutine to perform the formatting and printing of	*/
  7    28 	/*  the error message.							*/
  7    29 	/*									*/
  7    30 	/* U__s_a_g_e									*/
  7    31 	/*									*/
  7    32 	/*      call ERROR (error_number);						*/
  7    33 	/*									*/
  7    34 	/* 1) error_number	is the index of one of the structures in the error_control_table	*/
  7    35 	/*		which defines the error message to be printed.			*/
  7    36 	/*									*/
  7    37 	/* N__o_t_e_s									*/
  7    38 	/*									*/
  7    39 	/*      The format of the error_control_table is shown below.			*/
  7    40 	/*									*/
  7    41 	/*   dcl	1 error_control_table (2)	aligned internal static,			*/
  7    42 	/*	  2 severity		fixed bin(17) unaligned init (2,3),		*/
  7    43 	/*	  2 Soutput_stmt		bit(1) unaligned initial ("0"b,"1"b),		*/
  7    44 	/*	  2 message		char(252) varying initial (			*/
  7    45 	/*		"The reduction source segment does not contain any reductions.",	*/
  7    46 	/*		"Reduction label  '^a'  is invalid."),				*/
  7    47 	/*	  2 brief_message		char(100) varying initial (			*/
  7    48 	/*		"", "'^a'");						*/
  7    49 	/*									*/
  7    50 	/* error_control_table is an array of structures, with one array element per error.	*/
  7    51 	/* Each structure contains: a severity level for the error; a switch which specifies	*/
  7    52 	/* whether the source statement being processed should be output after the error message;	*/
  7    53 	/* the long form of the error message text;  and the brief form of the error message text.*/
  7    54 	/* The dimension of the error_control_table array of structures, and the lengths of	*/
  7    55 	/* message (long message) and brief_message (brief message), are compiler-defined.	*/
  7    56 	/* structures and the lengths of the message and brief_message are compiler-defined.	*/
  7    57 	/* The only requirement is that the messages be 256 characters or less in length.	*/
  7    58 	/* (Remember that the longest character string which can be used in an initial attribute	*/
  7    59 	/* is 254 characters in length.)						*/
  7    60 	/*									*/
  7    61 	/*      The severity number causes the error message to be preceded by a herald which	*/
  7    62 	/* includes one of the following prefixes:					*/
  7    63 	/*									*/
  7    64 	/*       _s_e_v  _p_r_e_f_i_x 		  _e_x_p_l_a_n_a_t_i_o_n				*/
  7    65 	/*	0 = COMMENT		- this is a comment.			*/
  7    66 	/*	1 = WARNING		- a possible error has been detected.  The	*/
  7    67 	/*				  compiler will still generate an object segment.	*/
  7    68 	/*	2 = ERROR			- a probable error has been detected.  The	*/
  7    69 	/*				  compiler will still generate an object segment.	*/
  7    70 	/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
  7    71 	/*				  that no object segment will be generated.	*/
  7    72 	/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
  7    73 	/*				  the compiler or translator.  No object segment	*/
  7    74 	/*				  will be generated.			*/
  7    75 	/*									*/
  7    76 	/* Full error messages are of the form:						*/
  7    77 	/*									*/
  7    78 	/*	_p_r_e_f_i_x _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n OF LINE _m		*/
  7    79 	/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
  7    80 	/*	SOURCE:								*/
  7    81 	/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
  7    82 	/*									*/
  7    83 	/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
  7    84 	/* If the source statement has been printed in a previous error message, it is omitted.	*/
  7    85 	/*									*/
  7    86 	/*      The reduction compiler declares a bit string, SERROR_CONTROL, which controls the	*/
  7    87 	/* text of an error message.  The compiler may set this bit string, as shown below.	*/
  7    88 	/*									*/
  7    89 	/*   SERROR_CONTROL		_m_e_a_n_i_n_g						*/
  7    90 	/*	"00"b		the first time a particular error occurs, the long message	*/
  7    91 	/*			is printed; the brief message is used in subsequent	*/
  7    92 	/*			occurrences of that error.				*/
  7    93 	/*        "10"b or "11"b	the long error message is always used.			*/
  7    94 	/*	"01"b		the brief error message is always used.			*/
  7    95 	/* The initial value of SERROR_CONTROL is "00"b.					*/
  7    96 	/*									*/
  7    97 	/*      The reduction_compiler creates a declaration for SERROR_PRINTED, an array	*/
  7    98 	/* of switches (one per error).  The switch corresponding to a particular error is	*/
  7    99 	/* turned on whenever the error message is printed.  This allows lex_error_ to detect	*/
  7   100 	/* subsequent occurrences of that same error.					*/
  7   101 	/*									*/
  7   102 	/*      The reduction_compiler creates MERROR_SEVERITY, a fixed bin(17) integer		*/
  7   103 	/* in which the severity of the highest-severity error encountered is maintained.	*/
  7   104 	/* The compiler may reference this integer.					*/
  7   105 	/*									*/
  7   106 	/*      The reduction_compiler creates MIN_PRINT_SEVERITY, a fixed bin (17) integer	*/
  7   107 	/* which controls the printing of error messages by the ERROR procedure.		*/
  7   108 	/* Errors having a severity less than MIN_PRINT_SEVERITY will not cause lex_error_ to be	*/
  7   109 	/* and no error will be printed.  The behaviour of the ERROR procedure for such errors	*/
  7   110 	/* is controlled by the value of PRINT_SEVERITY_CONTROL, described below.		*/
  7   111 	/* The compiler may set the value of MIN_PRINT_SEVERITY; its initial value is 0.	*/
  7   112 
  7   113 	/*									*/
  7   114 	/*      The reduction_compiler declares a bit string, PRINT_SEVERITY_CONTROL, which 	*/
  7   115 	/* controls the updating of MERROR_SEVERITY and SERROR_PRINTED when the severity of an	*/
  7   116 	/* error is less than MIN_PRINT_SEVERITY.  In such cases, the lex_error_ procedure is not	*/
  7   117 	/* invoked, and the ERROR procedure must update these values as though lex_error_ were	*/
  7   118 	/* called.  The compiler may set this bit string, as shown below.			*/
  7   119 	/*									*/
  7   120 	/* PRINT_SEVERITY_CONTROL	_m_e_a_n_i_n_g						*/
  7   121 	/*	"00"b		update neither SERROR_PRINTED nor MERROR_SEVERITY.	*/
  7   122 	/*	"01"b		update SERROR_PRINTED to reflect the error.		*/
  7   123 	/*	"10"b		update MERROR_SEVERITY to reflect the error severity.	*/
  7   124 	/*	"11"b		update SERROR_PRINTED and MERROR_SEVERITY appropriately.	*/
  7   125 	/*The initial value of PRINT_SEVERITY_CONTROL is "11"b.				*/
  7   126 	/*									*/
  7   127 	/*      The ERROR procedure is simple to use, but it does limit the flexibility of the	*/
  7   128 	/* error message.  A compiler action routine can output more flexible error messages	*/
  7   129 	/* by calling lex_error_ directly.  See lex_error_ documentation for more details.	*/
  7   130 	/*									*/
  7   131 	/* S__t_a_t_u_s									*/
  7   132 	/*									*/
  7   133 	/* 0) Created:  April, 1974 by G. C. Dixon					*/
  7   134 	/* 1) Modified: April, 1982 by E. N. Kittlitz.  Added MIN_PRINT_SEVERITY, 		*/
  7   135 	/*		PRINT_SEVERITY_CONTROL.					*/
  7   136 	/*									*/
  7   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7   138 
  7   139 ERROR:	procedure (Nerror);
  7   140 
  7   141      dcl	Nerror			fixed bin;	/* Number of the error which was detected. (In)	*/
  7   142 
  7   143      dcl	Pstmt			ptr,
  7   144 	1 erring_token		aligned based (Perring_token) like token,
  7   145 	Perring_token		ptr,
  7   146 	erring_token_value		char(erring_token.Lvalue) based (erring_token.Pvalue);
  7   147 
  7   148      dcl 	(max, null)		builtin;
  7   149 
  7   150      dcl	lex_error_		entry options (variable);
  7   151 
  7   152 
  7   153 	if error_control_table.severity(Nerror) < MIN_PRINT_SEVERITY then do; /* don't print		*/
  7   154 	     if PRINT_SEVERITY_CONTROL & "1"b then	/* update MERROR_SEVERITY			*/
  7   155 		MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table.severity(Nerror));
  7   156 	     if PRINT_SEVERITY_CONTROL & "01"b then	/* update SERROR_PRINTED			*/
  7   157 		SERROR_PRINTED(Nerror) = "1"b;
  7   158 	     return;
  7   159 	end;
  7   160 	Perring_token = Pthis_token;			/* address the current erring_token.		*/
  7   161 	if error_control_table.Soutput_stmt(Nerror) then
  7   162 	     if Perring_token = null then
  7   163 		Pstmt = null;
  7   164 	     else
  7   165 		Pstmt = erring_token.Pstmt;		/* address the statement descriptor.		*/
  7   166 	else
  7   167 	     Pstmt = null;
  7   168 	if Perring_token = null then
  7   169 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  7   170 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  7   171 		(error_control_table.brief_message(Nerror)));
  7   172 	else
  7   173 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  7   174 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  7   175 		(error_control_table.brief_message(Nerror)), erring_token_value, erring_token_value, erring_token_value);
  7   176 
  7   177 	end ERROR;
  7   178 
  7   179 	/* END OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      677 
      678 
      679 		/* START OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     4 	/*							*/
  8     5 	/* N__a_m_e:  rdc_next_stmt_.incl.pl1				*/
  8     6 	/*							*/
  8     7 	/*      This include segment is used by compilers generated by the	*/
  8     8 	/* reduction_compiler.  It includes a procedure which shifts the	*/
  8     9 	/* compilation process to the next source statement.		*/
  8    10 	/*							*/
  8    11 	/* S__t_a_t_u_s							*/
  8    12 	/*							*/
  8    13 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  8    14 	/*							*/
  8    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8    16 
  8    17 
  8    18 NEXT_STMT:	procedure;			/* invoked to begin parsing the next statement of	*/
  8    19 						/* the input tokens.			*/
  8    20 
  8    21      dcl	null			builtin,
  8    22 	Ssearching		bit(1) aligned;
  8    23 
  8    24 	Ptoken = Pthis_token;			/* make sure these pointers are the same.	*/
  8    25 	Pstmt = token.Pstmt;			/* address "current" statement's descriptor.	*/
  8    26 	Ssearching = "1"b;				/* start scanning forward for next statement.	*/
  8    27 	do while (Ssearching & token.Pnext ^= null);
  8    28 	     Ptoken = token.Pnext;
  8    29 	     if token.Pstmt = Pstmt then;
  8    30 	     else Ssearching = "0"b;
  8    31 	     end;
  8    32 	if token.Pstmt = Pstmt then			/* if there is no next statement, and		*/
  8    33 	     if SPDL then				/*   in PUSH DOWN LANGUAGE mode, can't run off	*/
  8    34 		Ptoken = Ptoken;			/*   end of input list.			*/
  8    35 	     else Ptoken, Pthis_token = null;		/*   otherwise, input list exhausted.		*/
  8    36 	else Pthis_token = Ptoken;			/* normally, next statement exists and Ptoken	*/
  8    37 						/*   points to its 1st _n_o_n-__d_e_l_e_t_e_d token.	*/
  8    38 
  8    39 	end NEXT_STMT;
  8    40 
  8    41 	/* END OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
      679 
      680 
      681 	end parse_pnotice_info_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/17/86  1453.8  parse_pnotice_info_.pl1           >spec>install>1032>parse_pnotice_info_.pl1
164          1    03/27/82  0435.8  software_pnotice_info_.incl.pl1   >ldd>include>software_pnotice_info_.incl.pl1
393          2    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
2-25         3    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
478          4    03/17/86  1404.9  rdc_end_.incl.pl1                 >spec>install>1032>rdc_end_.incl.pl1
500          5    04/18/75  1242.4  rdc_stack_fcns_.incl.pl1          >ldd>include>rdc_stack_fcns_.incl.pl1
675          6    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
677          7    08/15/83  1511.7  rdc_error_.incl.pl1               >ldd>include>rdc_error_.incl.pl1
679          8    04/18/75  1242.4  rdc_next_stmt_.incl.pl1           >ldd>include>rdc_next_stmt_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APstmt                          000100 automatic       pointer                  initial dcl 92 set ref 92* 195*
APtoken                         000102 automatic       pointer                  initial dcl 92 set ref 92* 195* 197
BACKSPACE                       005441 constant        char(1)                  initial dcl 2-99 ref 4-113
BREAKS                          000112 internal static varying char(128)        dcl 95 set ref 186* 189* 195*
CODE                            000625 automatic       fixed bin(35,0)          dcl 2-33 set ref 4-106* 4-107
Ccode                           000130 automatic       fixed bin(35,0)          dcl 96 set ref 208*
DIRECTION                       000630 automatic       fixed bin(17,0)          initial dcl 395 set ref 4-62 395*
FORM                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 2-48 ref 4-65 4-70
                                                                                  4-123
I                               000626 automatic       fixed bin(17,0)          dcl 2-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  4-62* 4-63 4-79*
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  unaligned dcl 2-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 4-126
IFIRST                                 based           fixed bin(17,0)          level 3 packed unaligned dcl 2-48 ref 4-62 4-73 4-79
                                                                                  4-79
IGBREAKS                        000153 internal static varying char(128)        dcl 95 set ref 187* 189* 195*
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 2-48 ref 4-62 4-73 4-79
L                         0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-48 ref 4-127
LEGAL                           000104 automatic       char(80)                 initial dcl 93 set ref 93*
LEXCTL                          000051 internal static varying char(128)        dcl 94 set ref 189* 195*
LEXDLM                          000010 internal static varying char(128)        dcl 94 set ref 189* 195*
LTOKEN_REQD_VALUE               000614 automatic       fixed bin(18,0)          dcl 2-33 set ref 4-127* 4-128
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "token" dcl 3-68 in procedure
                                                                                  "parse_pnotice_info_" ref 224 236 250 259 269 281
                                                                                  283 295 304 313 317 327 330 330 4-92 4-92 4-92
                                                                                  4-92 4-106 4-106 4-113 4-113 4-128
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "erring_token" dcl 7-143
                                                                                  in procedure "ERROR" ref 7-172 7-172 7-172 7-172
                                                                                  7-172 7-172
MERROR_SEVERITY                 000323 automatic       fixed bin(17,0)          initial dcl 7-3 set ref 201 7-3* 360* 7-154* 7-154
                                                                                  7-168* 7-172*
MI                        1            based           char(7)                  array level 3 dcl 1-6 set ref 224*
MIN_PRINT_SEVERITY              000325 automatic       fixed bin(17,0)          initial dcl 7-3 set ref 7-3* 7-153
MI_check                        000542 automatic       char(7)                  unaligned dcl 279 set ref 283* 284 286
N                                      parameter       fixed bin(17,0)          dcl 5-38 set ref 5-36 5-60* 5-68
NRED                            000615 automatic       fixed bin(17,0)          dcl 2-33 set ref 4-52* 4-55* 4-55 4-58 498 5-18*
                                                                                  5-26* 511* 518* 525* 532* 539* 546* 553* 560* 567*
                                                                                  574* 581* 588* 595* 600* 606* 624* 634* 641* 5-60*
NUMBER                          000627 automatic       fixed bin(35,0)          dcl 2-33 set ref 4-106* 4-108
Nerror                                 parameter       fixed bin(17,0)          dcl 7-141 set ref 7-139 7-153 7-154 7-156 7-161
                                                                                  7-168* 7-168 7-168 7-168 7-168 7-172* 7-172 7-172
                                                                                  7-172 7-172
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 3-68 set ref 4-101
                                                                                  4-108*
PRED                            000616 automatic       pointer                  dcl 2-33 set ref 4-58* 4-62 4-62 4-73 4-73 4-79 4-79
                                                                                  4-79
PRINT_SEVERITY_CONTROL          000326 automatic       bit(2)                   initial unaligned dcl 7-3 set ref 7-3* 7-154 7-156
PTOKEN_REQD                     000620 automatic       pointer                  dcl 2-33 set ref 4-63* 4-65 4-65 4-70 4-71 4-123
                                                                                  4-126 4-127 481
PTOKEN_REQD_VALUE               000622 automatic       pointer                  dcl 2-33 set ref 4-126* 4-128
Perring_token                   000720 automatic       pointer                  dcl 7-143 set ref 7-160* 7-161 7-164 7-168 7-168*
                                                                                  7-172* 7-172 7-172 7-172 7-172 7-172 7-172 7-172
                                                                                  7-172 7-172
Plast                     2            based           pointer                  level 2 packed unaligned dcl 3-68 ref 6-45 6-47
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 3-68 ref 4-79 494 622
                                                                                  629 632 639 648 653 6-39 6-40 8-27 8-28
Pstmt                           000716 automatic       pointer                  dcl 7-143 in procedure "ERROR" set ref 7-161* 7-164*
                                                                                  7-166* 7-168* 7-172*
Pstmt                     5            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 3-68 in procedure "parse_pnotice_info_" ref
                                                                                  357 8-25 8-29 8-32
Pstmt                     5            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 7-143 in procedure "ERROR" ref 7-164
Pstmt                           000316 automatic       pointer                  dcl 3-40 in procedure "parse_pnotice_info_" set ref
                                                                                  8-25* 8-29 8-32
Pthis_token                     000314 automatic       pointer                  dcl 2-23 set ref 197* 358 4-60 497 622 622* 629 629*
                                                                                  632 632* 639 639* 648 648* 653 653* 6-36 6-49*
                                                                                  7-160 8-24 8-35* 8-36*
Ptoken                          000320 automatic       pointer                  dcl 3-68 set ref 224 224 236 236 250 250 259 259 269
                                                                                  269 281 281 283 283 295 295 304 304 313 313 317
                                                                                  317 327 327 330 330 330 357 4-60* 4-64 4-73 4-79
                                                                                  4-86 4-92 4-92 4-92 4-92 4-92 4-92 4-92 4-101
                                                                                  4-104 4-106 4-106 4-106 4-108 4-113 4-113 4-113
                                                                                  4-113 4-118 4-124 4-128 4-128 494* 494 497* 622*
                                                                                  629* 632* 639* 648* 653* 6-36* 6-37 6-39 6-40*
                                                                                  6-40 6-42* 6-45 6-47* 6-47 6-49 8-24* 8-25 8-27
                                                                                  8-28* 8-28 8-29 8-32 8-32* 8-32 8-35* 8-36
Pvalue                    3            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 7-143 in procedure "ERROR" ref 7-172 7-172
                                                                                  7-172
Pvalue                    3            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 3-68 in procedure "parse_pnotice_info_" ref
                                                                                  224 236 250 259 269 281 283 295 304 313 317 327
                                                                                  330 4-92 4-92 4-106 4-113 4-128
R                               000362 automatic       bit(1)                   unaligned dcl 244 in procedure "check_path" set ref
                                                                                  252* 253* 254
R                               000312 automatic       bit(1)                   unaligned dcl 371 in procedure "parse_pnotice_info_"
                                                                                  set ref 375* 378* 383* 386
RED                                    based           structure                level 1 dcl 2-48
REDUCTION                              based           structure                array level 1 packed unaligned dcl 400 set ref 4-58
REDUCTIONS                      001102 constant        fixed bin(17,0)          initial array unaligned dcl 400 set ref 4-58
S                        11            based           structure                level 3 packed unaligned dcl 3-68
SERROR_CONTROL                  000324 automatic       bit(2)                   initial unaligned dcl 7-3 set ref 7-3* 360* 7-168*
                                                                                  7-172*
SERROR_PRINTED                  000325 automatic       bit(1)                   initial array unaligned dcl 7-3 set ref 7-3* 360*
                                                                                  7-156* 7-168* 7-172*
SI_ptr                          000310 automatic       pointer                  dcl 1-26 set ref 176* 178 212* 220 220 221 221 224
                                                                                  224 236 236 259 259 269 269 304 304 313 313 317
                                                                                  317 335 335 336 336 339 339 340 340 343 343 344
                                                                                  344
SPDL                            000322 automatic       bit(1)                   initial dcl 672 set ref 672* 4-73 6-42 8-32
STACK                           000631 automatic       fixed bin(17,0)          array dcl 396 set ref 5-18 5-26 5-59 5-60 5-60 5-68*
STACK_DEPTH                     000643 automatic       fixed bin(17,0)          initial dcl 396 set ref 5-17 5-18 5-24 5-26 5-27*
                                                                                  5-27 396* 650* 650 660* 660 5-59 5-66* 5-66 5-68
STI                             000131 automatic       char(12)                 unaligned dcl 97 set ref 295* 296*
STOKEN_FCN                      000624 automatic       bit(1)                   dcl 2-33 set ref 483* 485* 487* 490
Soutput_stmt              0(18) 000000 constant        bit(1)                   initial array level 2 packed unaligned dcl 105 ref
                                                                                  7-161
Ssearching                      000730 automatic       bit(1)                   dcl 8-21 set ref 8-26* 8-27 8-30*
TOKEN_REQD                             based           structure                level 1 dcl 2-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed unaligned dcl 2-48
                                                                                  in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 2-48
TOKEN_REQD_VALUE                       based           char                     unaligned dcl 2-48 ref 4-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed unaligned dcl 436 set ref 4-63
TOKEN_REQUIREMENTS              001016 constant        fixed bin(17,0)          initial array unaligned dcl 436 set ref 4-63
TOKEN_STRINGS                          based           char(75)                 dcl 473 set ref 4-126
TOKEN_STRING_ARRAYS             000765 constant        char(100)                initial array dcl 473 set ref 4-126
TRACING                         000215 internal static bit(1)                   initial dcl 390 set ref 4-50* 4-50
TYPE                      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-48 ref 4-65 4-71 481
addr                                                   builtin function         dcl 5-40 in procedure "PUSH" ref 5-63 5-63
addr                                                   builtin function         dcl 2-92 in procedure "SEMANTIC_ANALYSIS" ref 4-58
                                                                                  4-58 4-63 4-63 4-126 4-126
addr                                                   builtin function         dcl 160 in procedure "parse_pnotice_info_" ref 181
alph                            001141 constant        char(26)                 initial unaligned dcl 277 ref 284
bc                              000135 automatic       fixed bin(21,0)          dcl 99 set ref 184* 195*
bit_ch                          000134 automatic       fixed bin(24,0)          dcl 98 set ref 182* 184
brief_error                     000216 internal static varying char(4)          initial dcl 5-48 set ref 5-60*
brief_message            26     000000 constant        varying char(4)          initial array level 2 dcl 105 ref 360 7-168 7-172
cf_ptr                          000140 automatic       pointer                  dcl 103 set ref 169* 181* 182* 195* 211*
code                                   parameter       fixed bin(35,0)          dcl 100 set ref 90 172* 174 182* 195* 203 203* 251*
                                                                                  252 328* 329
collate                                                builtin function         dcl 160 ref 186 186 187 187
count_O                         000137 automatic       fixed bin(17,0)          dcl 102 set ref 227* 312* 312 313
count_S                         000136 automatic       fixed bin(17,0)          dcl 101 set ref 228* 316* 316 317
cu_$cl                          000356 constant        entry                    external dcl 5-43 ref 5-62
cv_dec_check_                   000354 constant        entry                    external dcl 2-96 ref 4-106
dimension                                              builtin function         dcl 160 in procedure "parse_pnotice_info_" ref 7-3
                                                                                  7-3
dimension                                              builtin function         dcl 5-40 in procedure "PUSH" ref 5-59 5-60 5-60
dirname                 373            based           char(168)                array level 4 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 339*
dirname                 311            based           char(168)                array level 4 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 335*
dirname                 227            based           char(168)                array level 4 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 343*
dirname                         000363 automatic       char(168)                unaligned dcl 246 in procedure "check_path" set ref
                                                                                  251*
dirname                         000142 automatic       char(168)                unaligned dcl 104 in procedure "parse_pnotice_info_"
                                                                                  set ref 328* 335 339 343
divide                                                 builtin function         dcl 160 ref 184
entered_value                          parameter       char(12)                 unaligned dcl 372 ref 369 378 383
entryname               445            based           char(32)                 array level 4 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 340*
entryname                       000435 automatic       char(32)                 unaligned dcl 247 in procedure "check_path" set ref
                                                                                  251*
entryname               301            based           char(32)                 array level 4 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 344*
entryname                       000214 automatic       char(32)                 unaligned dcl 118 in procedure "parse_pnotice_info_"
                                                                                  set ref 328* 336 340 344
entryname               363            based           char(32)                 array level 4 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 336*
erring_token                           based           structure                level 1 dcl 7-143
erring_token_value                     based           char                     unaligned dcl 7-143 set ref 7-172* 7-172* 7-172*
error_control_table             000000 constant        structure                array level 1 unaligned dcl 105 ref 7-3 7-3
error_num                              parameter       fixed bin(17,0)          dcl 352 set ref 350 360* 360 360 360 360
error_table_$translation_failed 000346 external static fixed bin(35,0)          dcl 158 ref 203
expand_pathname_                000326 constant        entry                    external dcl 117 in procedure "parse_pnotice_info_"
                                                                                  ref 328
expand_pathname_                000350 constant        entry                    external dcl 245 in procedure "check_path" ref 251
first                           000214 internal static bit(1)                   initial unaligned dcl 119 set ref 185 190*
group2                    7            based           structure                level 2 packed unaligned dcl 3-68
hcs_$status_mins                000330 constant        entry                    external dcl 120 ref 182
i                               000704 automatic       fixed bin(17,0)          dcl 6-33 in procedure "LEX" set ref 6-39* 6-42 6-45*
i                               000224 automatic       fixed bin(17,0)          dcl 121 in procedure "parse_pnotice_info_" set ref
                                                                                  377* 378*
ii                              000225 automatic       fixed bin(17,0)          initial dcl 122 set ref 122* 226* 268* 268 269
input_ptr                              parameter       pointer                  dcl 123 ref 90 176
iox_$error_output               000362 external static pointer                  dcl 5-43 set ref 5-63*
iox_$put_chars                  000360 constant        entry                    external dcl 5-43 ref 5-63
length                                                 builtin function         dcl 5-40 in procedure "PUSH" ref 5-63 5-63
length                                                 builtin function         dcl 160 in procedure "parse_pnotice_info_" ref 281
lex_error_                      000364 constant        entry                    external dcl 5-43 in procedure "PUSH" ref 5-60
lex_error_                      000332 constant        entry                    external dcl 124 in procedure "parse_pnotice_info_"
                                                                                  ref 360
lex_error_                      000366 constant        entry                    external dcl 7-150 in procedure "ERROR" ref 7-168
                                                                                  7-172
lex_string_$init_lex_delims     000334 constant        entry                    external dcl 125 ref 189
lex_string_$lex                 000336 constant        entry                    external dcl 128 ref 195
long_error                      000220 internal static varying char(234)        initial dcl 5-48 set ref 5-60*
max                                                    builtin function         dcl 7-148 in procedure "ERROR" ref 7-154
max                                                    builtin function         dcl 2-92 in procedure "SEMANTIC_ANALYSIS" ref 5-27
                                                                                  650 660
message                   1     000000 constant        varying char(80)         initial array level 2 dcl 105 ref 360 7-168 7-172
n                                      parameter       fixed bin(17,0)          dcl 6-33 ref 6-31 6-38 6-39 6-42 6-45
name                            000226 automatic       char(19)                 initial unaligned dcl 131 set ref 131* 168* 172*
non_restart_error               000314 internal static char(33)                 initial unaligned dcl 5-48 set ref 5-63 5-63 5-63
                                                                                  5-63
null                                                   builtin function         dcl 2-92 in procedure "SEMANTIC_ANALYSIS" ref 4-64
                                                                                  4-73 4-79 4-86
null                                                   builtin function         dcl 8-21 in procedure "NEXT_STMT" ref 8-27 8-35
null                                                   builtin function         dcl 5-40 in procedure "PUSH" ref 5-60 5-60 5-60 5-60
null                                                   builtin function         dcl 160 in procedure "parse_pnotice_info_" ref 92 92
                                                                                  169 170 208 210 211 212 355 355 6-37 6-39 6-42
                                                                                  6-45
null                                                   builtin function         dcl 7-148 in procedure "ERROR" ref 7-161 7-161 7-166
                                                                                  7-168
num                             000220 constant        structure                array level 2 in structure "product_init" dcl 135
                                                                                  in procedure "parse_pnotice_info_" ref 221
num                       1            based           structure                array level 2 in structure "product" dcl 1-6
                                                                                  in procedure "parse_pnotice_info_" set ref 221*
numbers                         001136 constant        char(10)                 initial unaligned dcl 278 ref 286
obj_sw                          000233 automatic       bit(1)                   unaligned dcl 132 set ref 311 544* 551*
object_C                133            based           char(24)                 array level 3 dcl 1-6 set ref 313*
object_path             373            based           structure                array level 3 dcl 1-6
parm1                                  parameter       char                     unaligned dcl 353 set ref 350 360*
parm2                                  parameter       char                     unaligned dcl 354 set ref 350 360*
parse_pnotice_info_$validate_sti
                                000352 constant        entry                    external dcl 293 ref 296
pathname                        000445 automatic       char(168)                unaligned dcl 248 in procedure "check_path" set ref
                                                                                  250* 251*
pathname                        000234 automatic       char(168)                unaligned dcl 133 in procedure "parse_pnotice_info_"
                                                                                  set ref 327* 328*
proc_ptr                        000306 automatic       pointer                  dcl 134 set ref 170* 172* 195* 208 208* 210*
prod_STI                 34            based           char(12)                 array level 3 dcl 1-6 set ref 304*
prod_name                 3            based           char(20)                 array level 3 dcl 1-6 set ref 236*
prod_number                            based           fixed bin(17,0)          level 2 dcl 1-6 set ref 178* 220* 220 221 224 236
                                                                                  259 269 304 313 317 335 336 339 340 343 344
prod_title               10            based           char(80)                 array level 3 dcl 1-6 set ref 259*
prod_use                455            based           char(7)                  array level 3 dcl 1-6 set ref 269*
product                                based           structure                level 1 dcl 1-6
product_init                    000220 constant        structure                level 1 dcl 135
psp_info_$                      000340 external static fixed bin(35,0)          dcl 153 set ref 181
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 3-68 ref 4-92 4-104
                                                                                  4-113 4-118 4-124
search                                                 builtin function         dcl 2-92 ref 4-92
severity                        000000 constant        fixed bin(17,0)          initial array level 2 packed unaligned dcl 105 ref
                                                                                  360 7-153 7-154 7-168 7-172
source_C                 37            based           char(24)                 array level 3 dcl 1-6 set ref 317*
source_path             311            based           structure                array level 3 dcl 1-6
stmt_ptr                        000602 automatic       pointer                  initial dcl 355 set ref 355* 357* 360*
substr                                                 builtin function         dcl 160 in procedure "parse_pnotice_info_" ref 186
                                                                                  186 187 187 284 286 378 383
substr                                                 builtin function         dcl 2-92 in procedure "SEMANTIC_ANALYSIS" ref 4-92
                                                                                  4-126
token                                  based           structure                level 1 dcl 3-68
token_ptr                       000604 automatic       pointer                  initial dcl 355 set ref 355* 358* 360*
token_value                            based           char                     unaligned dcl 3-68 set ref 224 236 250 259 269 281
                                                                                  283 295 304 313 317 327 330* 4-92 4-92 4-106*
                                                                                  4-113 4-128
translator_temp_$get_segment    000342 constant        entry                    external dcl 154 ref 172
translator_temp_$release_all_segments
                                000344 constant        entry                    external dcl 155 ref 208
type                                   parameter       char(6)                  unaligned dcl 324 ref 322 334 338 342
valid_numeric                   001150 constant        char(36)                 initial unaligned dcl 373 ref 378
verify                                                 builtin function         dcl 160 in procedure "parse_pnotice_info_" ref 284
                                                                                  286 378 383
verify                                                 builtin function         dcl 2-92 in procedure "SEMANTIC_ANALYSIS" ref 4-92
x_path                  227            based           structure                array level 3 dcl 1-6

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Pcomment                               automatic       pointer                  dcl 3-20
comment                                based           structure                level 1 dcl 3-20
comment_value                          based           char                     unaligned dcl 3-20
stmt                                   based           structure                level 1 dcl 3-40
stmt_value                             based           char                     unaligned dcl 3-40

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           004251 constant        entry                    internal dcl 7-139 ref 503 565 579 593 603 609 613
                                                                                  627 637 644 657 663
LEX                             004164 constant        entry                    internal dcl 6-31 ref 507 510 514 517 521 524 528
                                                                                  531 535 538 542 549 556 559 563 570 573 577 584
                                                                                  587 591 598
MI_prod                         002116 constant        entry                    internal dcl 217 ref 509
NEXT_STMT                       004562 constant        entry                    internal dcl 8-18 ref 566 580 594 605 659
PUSH                            004023 constant        entry                    internal dcl 5-36 ref 545 552 623 640
RD_ACTION                       000731 constant        label                    array(28) dcl 503 ref 498
RD_MATCH                        003346 constant        label                    dcl 494 ref 4-90 4-92 4-101 4-109 4-113 4-118 4-128
                                                                                  490
RD_MATCH_NO_TOKEN               003351 constant        label                    dcl 495 ref 4-73 4-79 4-86
RD_NEXT_REDUCTION               003035 constant        label                    dcl 4-55 ref 4-68 4-84 4-88 4-99 4-104 4-111 4-116
                                                                                  4-120 4-124 4-130 491 5-17 5-24
RD_STACK                        003360 constant        label                    dcl 5-17
RD_STACK_POP                    003365 constant        label                    dcl 5-24 ref 630 651 655 661
RD_TEST_REDUCTION               003036 constant        label                    dcl 4-58 ref 4-53 5-19 5-28 512 519 526 533 540 547
                                                                                  554 561 568 575 582 589 596 601 607 625 635 642
RD_TEST_RESULT                  003344 constant        label                    dcl 490 ref 484 486 488
RD_TEST_TOKEN                   000720 constant        label                    array(6) dcl 4-73 ref 4-65 4-71
RD_TOKEN_FCN                    000726 constant        label                    array(3) dcl 483 ref 481
SEMANTIC_ANALYSIS               003024 constant        entry                    internal dcl 2-30 ref 199
check_path                      002162 constant        entry                    internal dcl 242 ref 487
fini                            002000 constant        label                    dcl 208 ref 174 204
get_to_cl                       004127 constant        label                    dcl 5-62 ref 5-64
parse_pnotice_info_             001437 constant        entry                    external dcl 90
prod_C                          002436 constant        entry                    internal dcl 309 ref 620
prod_STI                        002421 constant        entry                    internal dcl 302 ref 530
prod_USE                        002252 constant        entry                    internal dcl 265 ref 537
prod_name                       002145 constant        entry                    internal dcl 233 ref 516
prod_path                       002503 constant        entry                    internal dcl 322 ref 558 572 586
prod_title                      002235 constant        entry                    internal dcl 258 ref 523
statement_error                 002657 constant        entry                    internal dcl 350 ref 330
validate_MI                     002275 constant        entry                    internal dcl 274 ref 483
validate_STI                    002360 constant        entry                    internal dcl 291 ref 485
validate_sti                    002034 constant        entry                    external dcl 369

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5660        6250    5442        5670
Length      6644    5442       370         357     216         316

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
parse_pnotice_info_                 932 external procedure  is an external procedure.  
MI_prod                                 internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
prod_name                               internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
check_path                              internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
prod_title                              internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
prod_USE                                internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
validate_MI                             internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
validate_STI                            internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
prod_STI                                internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
prod_C                                  internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
prod_path                               internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
statement_error                         internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
PUSH                                    internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
LEX                                     internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
ERROR                                   internal procedure  shares stack frame of external procedure parse_pnotice_info_.  
NEXT_STMT                               internal procedure  shares stack frame of external procedure parse_pnotice_info_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 LEXDLM                      parse_pnotice_info_
000051 LEXCTL                      parse_pnotice_info_
000112 BREAKS                      parse_pnotice_info_
000153 IGBREAKS                    parse_pnotice_info_
000214 first                       parse_pnotice_info_
000215 TRACING                     parse_pnotice_info_
000216 brief_error                 PUSH
000220 long_error                  PUSH
000314 non_restart_error           PUSH

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
parse_pnotice_info_      000100 APstmt                      parse_pnotice_info_
                         000102 APtoken                     parse_pnotice_info_
                         000104 LEGAL                       parse_pnotice_info_
                         000130 Ccode                       parse_pnotice_info_
                         000131 STI                         parse_pnotice_info_
                         000134 bit_ch                      parse_pnotice_info_
                         000135 bc                          parse_pnotice_info_
                         000136 count_S                     parse_pnotice_info_
                         000137 count_O                     parse_pnotice_info_
                         000140 cf_ptr                      parse_pnotice_info_
                         000142 dirname                     parse_pnotice_info_
                         000214 entryname                   parse_pnotice_info_
                         000224 i                           parse_pnotice_info_
                         000225 ii                          parse_pnotice_info_
                         000226 name                        parse_pnotice_info_
                         000233 obj_sw                      parse_pnotice_info_
                         000234 pathname                    parse_pnotice_info_
                         000306 proc_ptr                    parse_pnotice_info_
                         000310 SI_ptr                      parse_pnotice_info_
                         000312 R                           parse_pnotice_info_
                         000314 Pthis_token                 parse_pnotice_info_
                         000316 Pstmt                       parse_pnotice_info_
                         000320 Ptoken                      parse_pnotice_info_
                         000322 SPDL                        parse_pnotice_info_
                         000323 MERROR_SEVERITY             parse_pnotice_info_
                         000324 SERROR_CONTROL              parse_pnotice_info_
                         000325 MIN_PRINT_SEVERITY          parse_pnotice_info_
                         000325 SERROR_PRINTED              parse_pnotice_info_
                         000326 PRINT_SEVERITY_CONTROL      parse_pnotice_info_
                         000362 R                           check_path
                         000363 dirname                     check_path
                         000435 entryname                   check_path
                         000445 pathname                    check_path
                         000542 MI_check                    validate_MI
                         000602 stmt_ptr                    statement_error
                         000604 token_ptr                   statement_error
                         000614 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000615 NRED                        SEMANTIC_ANALYSIS
                         000616 PRED                        SEMANTIC_ANALYSIS
                         000620 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         000622 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000624 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         000625 CODE                        SEMANTIC_ANALYSIS
                         000626 I                           SEMANTIC_ANALYSIS
                         000627 NUMBER                      SEMANTIC_ANALYSIS
                         000630 DIRECTION                   SEMANTIC_ANALYSIS
                         000631 STACK                       SEMANTIC_ANALYSIS
                         000643 STACK_DEPTH                 SEMANTIC_ANALYSIS
                         000704 i                           LEX
                         000716 Pstmt                       ERROR
                         000720 Perring_token               ERROR
                         000730 Ssearching                  NEXT_STMT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            unpk_to_pk          call_ext_out_desc   call_ext_out        return              alloc_auto_adj
signal              shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$cl                        cv_dec_check_                 expand_pathname_              expand_pathname_
hcs_$status_mins              iox_$put_chars                lex_error_                    lex_error_
lex_error_                    lex_string_$init_lex_delims   lex_string_$lex
parse_pnotice_info_$validate_sti                            translator_temp_$get_segment
translator_temp_$release_all_segments

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$translation_failed                             iox_$error_output             psp_info_$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     92 001362        93 001365       122 001370       131 001371       672 001374    7    3 001375       360 001427
     90 001433       168 001447       169 001452       170 001454       172 001455       174 001477       176 001502
    178 001505       181 001506       182 001511       184 001526       185 001532       186 001535       187 001557
    189 001565       190 001646       195 001650       197 001763       199 001765       201 001766       203 001771
    204 001777       208 002000       210 002015       211 002017       212 002020       213 002021       369 002030
    375 002043       377 002045       378 002053       380 002066       383 002070       386 002103       217 002116
    220 002117       221 002120       224 002127       226 002141       227 002142       228 002143       230 002144
    233 002145       236 002146       238 002161       242 002162       250 002164       251 002173       252 002220
    253 002226       254 002227       258 002235       259 002236       261 002251       265 002252       268 002253
    269 002254       271 002274       274 002275       281 002277       283 002310       284 002315       286 002334
    287 002353       291 002360       295 002362       296 002371       297 002413       302 002421       304 002422
    305 002435       309 002436       311 002437       312 002441       313 002442       314 002461       316 002462
    317 002463       319 002502       322 002503       327 002505       328 002514       329 002541       330 002544
    331 002573       334 002574       335 002604       336 002613       337 002620       338 002621       339 002623
    340 002632       341 002637       342 002640       343 002642       344 002651       346 002656       350 002657
    355 002675       357 002700       358 002703       360 002705       365 003022    2   30 003024       395 003025
    396 003027    4   50 003030    4   52 003033    4   53 003034    4   55 003035    4   58 003036    4   60 003041
 4   62 003043    4   63 003066    4   64 003071    4   65 003075    4   68 003105    4   70 003106    4   71 003112
 4   73 003114    4   79 003133    4   84 003144    4   86 003145    4   88 003151    4   90 003152    4   92 003153
 4   99 003207    4  101 003210    4  104 003213    4  106 003216    4  107 003242    4  108 003244    4  109 003247
 4  111 003250    4  113 003251    4  116 003265    4  118 003266    4  120 003272    4  123 003273    4  124 003274
 4  126 003300    4  127 003305    4  128 003311    4  130 003317       481 003320       483 003322       484 003327
    485 003330       486 003335       487 003336       488 003343       490 003344       491 003345       494 003346
    495 003351       497 003354       498 003356    5   17 003360    5   18 003362    5   19 003364    5   24 003365
 5   26 003367    5   27 003371    5   28 003377       503 003400       505 003404       507 003405       509 003411
    510 003412       511 003416       512 003420       514 003421       516 003425       517 003426       518 003432
    519 003434       521 003435       523 003441       524 003442       525 003446       526 003450       528 003451
    530 003455       531 003456       532 003462       533 003464       535 003465       537 003471       538 003472
    539 003476       540 003500       542 003501       544 003505       545 003506       546 003512       547 003514
    549 003515       551 003521       552 003523       553 003527       554 003531       556 003532       558 003536
    559 003542       560 003546       561 003550       563 003551       565 003555       566 003561       567 003562
    568 003564       570 003565       572 003571       573 003575       574 003601       575 003603       577 003604
    579 003610       580 003614       581 003615       582 003617       584 003620       586 003624       587 003630
    588 003634       589 003636       591 003637       593 003643       594 003647       595 003650       596 003652
    598 003653       600 003657       601 003661       603 003662       605 003666       606 003667       607 003671
    609 003672       611 003676       613 003677       615 003703       617 003704       620 003705       622 003706
    623 003712       624 003716       625 003720       627 003721       629 003725       630 003731       632 003732
    634 003735       635 003737       637 003740       639 003744       640 003750       641 003754       642 003756
    644 003757       646 003763       648 003764       650 003767       651 003775       653 003776       655 004001
    657 004002       659 004006       660 004007       661 004015       663 004016       665 004022    5   36 004023
 5   59 004025    5   60 004030    5   62 004127    5   63 004134    5   64 004156    5   66 004157    5   68 004160
 5   70 004163    6   31 004164    6   36 004166    6   37 004170    6   38 004175    6   39 004177    6   40 004211
 6   41 004213    6   42 004215    6   44 004225    6   45 004226    6   47 004241    6   48 004243    6   49 004246
 6   51 004250    7  139 004251    7  153 004253    7  154 004263    7  156 004272    7  158 004301    7  160 004302
 7  161 004304    7  164 004317    7  166 004323    7  168 004325    7  172 004431    7  177 004560    8   18 004562
 8   24 004563    8   25 004565    8   26 004570    8   27 004572    8   28 004600    8   29 004602    8   30 004607
 8   31 004610    8   32 004611    8   35 004622    8   36 004626    8   39 004627


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
