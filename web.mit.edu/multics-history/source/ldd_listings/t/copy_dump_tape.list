	COMPILATION LISTING OF SEGMENT copy_dump_tape
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/16/87  1330.0 mst Thu
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(87-01-05,GDixon), approve(87-04-15,MCR7617),
        9*     audit(87-06-22,RBarstad), install(87-07-15,MR12.1-1040):
       10*     Completely rewritten, combining copy and compare functions into a single
       11*     command.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 copy_dump_tape:
       15 	proc options(variable);
       16 	
       17     dcl	ME			char(17),		/* command called*/
       18 	abort_sw			bit(1),		/* on: -abort    */
       19 	code			fixed bin(35),
       20 	1 compared		aligned like copied,/* count compares*/
       21 	1 copied			aligned,		/* count copied  */
       22 	  2 segs			fixed bin,	/*  entries      */
       23 	  2 msfs			fixed bin,	/*  msfs	       */
       24 	1 cpbf			aligned like inbf,	/* copy record   */
       25 	1 cphe			aligned like inhe based (cpbf.hp),
       26 	1 cphe_name		aligned like inhe_name based (cpbf.hp),
       27 	1 cplast			aligned like inlast,/* last rec read */
       28 						/*  from copy    */
       29 						/*  tape.	       */
       30 	1 inbf			aligned,		/* input record  */
       31 	  2 blrh,					/*  backup dump  */
       32 	    3 zz1			char(32),		/*   record head */
       33 	    3 english		char(56),
       34 	    3 zz2			char(32),
       35 	    3 sizes,
       36 	      4 hl		fixed bin(21),
       37 	      4 segl		fixed bin(21),
       38 	  2 hp			ptr,		/*  header ptr   */
       39 	  2 segp			ptr,		/*  segment ptr  */
       40 	1 inhe			aligned like h based (inbf.hp),
       41 						/*  header       */
       42 	1 inhe_name		aligned based (inbf.hp),
       43 	  2 dname			char(168) varying,
       44 	  2 ename			char(32) varying,
       45 	1 inlast			aligned,		/* last seg read */
       46 	  2 path			unal,		/*  from in tape.*/
       47 	    3 dir			char (168),
       48 	    3 ent			char (32),
       49 	  2 sizes,
       50 	    3 he			fixed bin(35),
       51 	    3 seg			fixed bin(35),
       52 	1 input			aligned,		/* input medium  */
       53 	  2 header		like in_out.header,
       54 	  2 vol (20)		like in_out.vol,	/*  tape names   */
       55 	1 map			aligned,		/* map file      */
       56 	  2 header		like in_out.header,
       57 	1 map_prev		aligned,		/* map file      */
       58 	  2 header		like in_out.header,
       59 	1 mbf			aligned like inbf based(addr(inbf)),
       60 						/* master record */
       61 	1 mhe			aligned like h based (mbf.hp),
       62 						/*  header       */
       63 	1 mhe_name		aligned like inhe_name based (mbf.hp),
       64 	1 mlast			aligned like inlast,/* last record   */
       65 						/*  read from    */
       66 						/*  master tape. */
       67 	maximize_devices_sw		bit(1),		/* on: -maxdv    */
       68 	operation_now		fixed bin,	/* cur function  */
       69 	operation_wanted		fixed bin,	/* wanted fcn    */
       70 	1 output			aligned,		/* output medium */
       71 	  2 header		like in_out.header,
       72 	  2 vol (20)		like in_out.vol,	/*  tape names   */
       73 	1 select			aligned,		/* copy selected */
       74 	  2 header		like in_out.header, /*  files only   */
       75 	  2 listp			ptr,		/*  path list    */
       76 	  2 select_sw		bit(1),		/*  on: -select  */
       77 						/*   without opt,*/
       78 						/*   -select used*/
       79 						/*  by compare ep*/
       80 	state			fixed bin,	/* result of     */
       81 						/*  read_seg fcn */
       82 	trace			fixed bin;	/* -trace XXX    */
       83 
       84     dcl	1 in_out			aligned based (in_outp),
       85 	  2 header,
       86 	    3 name		char(8) varying,	/* log file name */
       87 	    3 iocbp		ptr,		/* IOCB ptr      */
       88 	    3 target_iocbp		ptr,
       89 	    3 mode		fixed bin,	/* opening mode  */
       90 	    3 recx		fixed bin,	/* cur rec       */
       91 	    3 vfile,				/* input file    */
       92 	      4 path		char(168) unal,
       93 	      4 expath		char(168) unal,
       94 	      4 charpos		fixed bin(35),	/* pos of last   */
       95 						/*  char read    */
       96 	    3 tape,				/* input tapes.  */
       97 	      4 voln		fixed bin,	/*  total	       */
       98 	      4 volx		fixed bin,	/*  current      */
       99 	      4 track		fixed bin,	/*  track	       */
      100 	      4 density		fixed bin,	/*  density      */
      101 	  2 vol (20),
      102 	    3 name		char(32),		/*  vol names    */
      103 	    3 device		char(32),		/*  device used  */
      104 	in_outp			ptr,		/* ptr to input  */
      105 						/*  or output    */
      106 	severity			fixed bin based (severityp),
      107 	severityp			ptr;
      108 
      109     dcl  (addr, bin, char, clock, dim, divide, hbound, index,
      110 	lbound, length, ltrim, max, maxlength, min, mod, null, ptr, rtrim,
      111 	search, string, substr, unspec, verify)
      112 				builtin;
      113 
      114     dcl	cleanup			condition;
      115 
      116     dcl	absolute_pathname_		entry (char(*), char(*), fixed bin(35)),
      117 	absolute_pathname_$add_suffix	entry (char(*), char(*), char(*), fixed bin(35)),
      118  	backup_map_$beginning_line	entry (fixed bin(52), ptr, fixed bin),
      119 	backup_map_$detail_line2	entry (char(32) aligned, fixed bin(9),
      120 				     char(10) aligned, fixed bin(52),
      121 				     fixed bin(52), fixed bin(52),
      122 				     fixed bin(52), fixed bin(52)),
      123 	backup_map_$detach_for_cdt	entry (fixed bin(35)),
      124 	backup_map_$directory_line	entry (ptr, fixed bin),
      125 	backup_map_$heading_line	entry,
      126 	backup_map_$init_for_cdt	entry (char(128) var),
      127 	backup_map_$name_line	entry (ptr, fixed bin),
      128 	backup_map_$tapes		entry (ptr, fixed bin),
      129 	backup_map_$terminal_line	entry (fixed bin(52), fixed bin),
      130 	backup_util$idline		entry (char(*), char(*), ptr,
      131 				     fixed bin),
      132 	convert_ipc_code_		entry options(variable),
      133 	cu_$arg_list_ptr		entry returns(ptr),
      134 	date_time_$format		entry (char(*), fixed bin(71),
      135 				     char(*), char(*))
      136 				     returns(char(250) var),
      137 	get_line_length_$switch	entry (ptr, fixed bin(35)) returns(fixed bin),
      138 	get_shortest_path_		entry (char(*)) returns(char(168)),
      139 	ioa_			entry() options(variable),
      140 	iox_$attach_name		entry (char(*), ptr, char(*), ptr,
      141 				     fixed bin(35)),
      142 	iox_$attach_ptr		entry (ptr, char(*), ptr,
      143 				     fixed bin(35)),
      144 	iox_$close		entry (ptr, fixed bin(35)),
      145 	iox_$control		entry (ptr, char(*), ptr,
      146 				     fixed bin(35)),
      147 	iox_$destroy_iocb		entry (ptr, fixed bin(35)),
      148 	iox_$detach_iocb		entry (ptr, fixed bin(35)),
      149 	iox_$find_iocb		entry (char(*), ptr, fixed bin(35)),
      150 	iox_$get_chars		entry (ptr, ptr, fixed bin(21),
      151 				     fixed bin(21), fixed bin(35)),
      152 	iox_$get_line		entry (ptr, ptr, fixed bin(21),
      153 				     fixed bin(21), fixed bin(35)),
      154 	iox_$modes		entry (ptr, char(*), char(*),
      155 				     fixed bin(35)),
      156 	iox_$move_attach		entry (ptr, ptr, fixed bin(35)),
      157 	iox_$open			entry (ptr, fixed bin, bit(1) aligned,
      158 				     fixed bin(35)),
      159 	iox_$position		entry (ptr, fixed bin, fixed bin(35),
      160 				     fixed bin(35)),
      161 	iox_$put_chars		entry (ptr, ptr, fixed bin(21),
      162 				     fixed bin(35)),
      163 	ipc_$block		entry (ptr, ptr, fixed bin(35)),
      164 	ipc_$create_ev_chn		entry (fixed bin(71), fixed bin(35)),
      165 	ipc_$delete_ev_chn		entry (fixed bin(71), fixed bin(35)),
      166 	pathname_			entry (char(*), char(*))
      167 				     returns(char(168)),
      168 	rcp_$assign_device		entry (char (*), ptr, fixed bin (71),
      169 				     char (*), bit (36) aligned,
      170 				     fixed bin (35)),
      171 	rcp_$check_assign		entry (bit (36) aligned, ptr, char (*),
      172 				     fixed bin, fixed bin (35)),
      173 	rcp_$copy_list		entry (ptr, fixed bin (21),
      174 				     fixed bin (35)),
      175 	rcp_$unassign		entry (bit (36) aligned, bit (*),
      176 				     char (*), fixed bin (35)),
      177 	ssu_$get_invocation_count	entry (ptr, fixed bin, fixed bin),
      178 	ssu_$get_temp_segment	entry (ptr, char(*), ptr),
      179 	unique_chars_		entry (bit(*)) returns(char(15));
      180 
      181     dcl	BLOCK_SIZE		fixed bin int static options(constant) init(256),
      182 	BLRH_DELIMITER		char(32) int static options(constant)
      183 				init(
      184 				  " z z z z z z z z z z z z z z z z"),
      185 	BLRH_ENGLISH		char(56) int static options(constant)
      186 				init("This is the beginning of a backup logical record."),
      187          (DESTROY			init(1),
      188           KEEP			init(2)) fixed bin int static options(constant),
      189          (FALSE			init("0"b),
      190 	TRUE			init("1"b)) bit(1) int static options(constant),
      191 	FOR_MOVE_ATTACH		fixed bin int static options(constant) init(-1),
      192          (REJECTS			init(-1),
      193 	OFF			init(0),
      194 	COPY			init(1),
      195 	COMPARE			init(2),
      196 	COPY_AND_COMPARE		init(3)) fixed bin int static options(constant),
      197          (OK			init(0),
      198 	READ_AGAIN		init(1),
      199 	NOMORE			init(2)) fixed bin int static options(constant),
      200 	compare_dump_tape_severity_	fixed bin ext static init (0),
      201 	copy_dump_tape_map_		char(168) varying ext static init(""),
      202 	copy_dump_tape_severity_	fixed bin ext static init (0),
      203 	copy_dump_tape_tapes	char(300) varying ext static init(""),
      204          (error_table_$bad_opt,
      205 	error_table_$device_end,
      206 	error_table_$end_of_info,
      207 	error_table_$inconsistent,
      208 	error_table_$noarg,
      209 	error_table_$not_detached,
      210 	error_table_$resource_reserved,
      211 	error_table_$resource_unavailable,
      212 	error_table_$too_many_names,
      213 	error_table_$wrong_no_of_args)
      214 				fixed bin(35) ext static;
      215 
      216 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      217 
      218 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      219 /*							       */
      220 /* ENTRY POINT IDENTIFICATION:				       */
      221 /* 1) Identify command entrypoint.				       */
      222 /* 2) Set operation code.					       */
      223 /* 3) Identify command severity variable.			       */
      224 /*							       */
      225 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      226 
      227 	ME = "copy_dump_tape";
      228 	operation_wanted = COPY;
      229 	severityp = addr(copy_dump_tape_severity_);
      230 	copy_dump_tape_tapes = "";
      231 	copy_dump_tape_map_ = "";
      232 	go to COPY_COMPARE;
      233 	
      234 compare_dump_tape:
      235 	entry options(variable);
      236 	
      237 	ME = "compare_dump_tape";
      238 	operation_wanted = COMPARE;
      239 	severityp = addr(compare_dump_tape_severity_);
      240 	go to COPY_COMPARE;
      241 
      242 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      243 /*							       */
      244 /* INVOCATION TYPE AND ARGUMENTS:				       */
      245 /* 1) Set severity variable to indicate success.			       */
      246 /* 2) Initialize variables used in cleanup handler, and establish handler.   */
      247 /* 3) Create standalone ssu_ invocation for argument processing.	       */
      248 /* 4) Initialize argument handling routines.			       */
      249 /* 5) Process input arguments, reporting any errors as they are encountered. */
      250 /*							       */
      251 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      252 
      253 COPY_COMPARE:
      254 	severity = 0;
      255 	sci_ptr = null;
      256 	call initialize_args();
      257 	on cleanup call cleanup_invocation();
      258 	call ssu_$standalone_invocation (sci_ptr, ME, "1.0",
      259 	   cu_$arg_list_ptr(), exit_proc, code);
      260 	call check_invocation_type (ALLOW_COMMAND);
      261 	call process_args();
      262 
      263 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      264 /*							       */
      265 /* PROCESSING:						       */
      266 /* 1) If -select was given, process the select file to build a select tree.  */
      267 /* 2) If -map was given, open the map file.			       */
      268 /* 3) If tapes are being used for input or output, survey tape drives	       */
      269 /*    assigned to the process.				       */
      270 /* 4) If copying, attach input/output files, do the copying, detach	       */
      271 /*    input/output files.  If output was to tape, report which tapes were    */
      272 /*    actually written on.					       */
      273 /* 5) If comparing, attach master/copy files, do the comparing, detach       */
      274 /*    input/output files.					       */
      275 /* 6) If copying and comparing, report discrepancy between number of segs    */
      276 /*    copied vs number compared.				       */
      277 /* 7) If -trace, report any -select pathnames that were not matched.	       */
      278 /*							       */
      279 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      280 
      281 	if select.vfile.path ^= "" then do;
      282 	   call ioa_ ("");
      283 	   call attach (addr(select), Stream_input);
      284 	   call skip_seg$init();
      285 	   call ssu_$print_message (sci_ptr, 0,
      286 	      "^a: ^d select lines processed.", hhmmm(), select.recx);
      287 	   call detach (addr(select), DESTROY);
      288 	   end;
      289 
      290 	if map.vfile.path ^= "" then do;
      291 	   call ioa_ ("");
      292 	   call attach (addr(map), Stream_output);
      293 	   copy_dump_tape_map_ = map.vfile.expath;
      294 	   end;
      295 
      296 	if input.tape.voln > 0 | output.tape.voln > 0 then
      297 	   call tape_drive$survey();
      298 
      299 	if mod (operation_wanted, 2) = COPY then do;
      300 	   operation_now = COPY;
      301 	   call header("BEGIN COPYING", input, output);
      302 	   call attach (addr(input), Stream_input);
      303 	   call attach (addr(output), Stream_output);
      304 	   call map_seg$init (output);
      305 	   call copy_segs();
      306 	   if output.tape.voln > 0 then do;
      307 	      output.tape.voln = output.tape.volx;
      308 	      call ioa_ ("");
      309 	      call ssu_$print_message (sci_ptr, 0,
      310 	         "NOTE: Files were copied onto ^d ^a tape^[s^]:^v( ^a^)^/",
      311 	         output.tape.voln, output.header.name, output.tape.voln>1,
      312 	         output.tape.voln, output.vol.name);
      313 	      copy_dump_tape_tapes = output.vol(1).name;
      314 	      do output.tape.volx = 2 to output.tape.voln;
      315 	         copy_dump_tape_tapes = copy_dump_tape_tapes || " ";
      316 	         copy_dump_tape_tapes = copy_dump_tape_tapes ||
      317 		  output.vol(output.tape.volx).name;
      318 	         end;
      319 	      end;
      320 	   end;
      321 
      322 	if operation_wanted >= COMPARE then do;
      323 	   operation_now = COMPARE;
      324 	   call header ("BEGIN COMPARING", input, output);
      325 	   call attach (addr(input), Stream_input);
      326 	   call attach (addr(output), Stream_input);
      327 	   call compare_segs();
      328 	   end;
      329 
      330 	if operation_wanted = COPY_AND_COMPARE then do;
      331 	   operation_now = COPY_AND_COMPARE;
      332 	   if copied.segs ^= compared.segs |
      333 	      copied.msfs ^= compared.msfs then do;
      334 	      severity = max(severity, 3);
      335 	      call ioa_ ("");
      336 	      call error (sci_ptr, -1,
      337 	         "^a: FATAL ERROR: Copy/Compare Count Discrepancy.
      338 Copied:    ^5d segment^[s,^;, ^] ^5d msf^[s^]
      339 Compared:  ^5d segment^[s,^;, ^] ^5d msf^[s^]",
      340 	         hhmmm(),
      341 	         copied.segs, copied.segs^=1, copied.msfs, copied.msfs^=1, 
      342 	         compared.segs, compared.segs^=1, compared.msfs, compared.msfs^=1);
      343 	      end;
      344 	   end;
      345 
      346 	call skip_seg$term();
      347 
      348 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      349 /*							       */
      350 /* REVOCATION AND EXIT:					       */
      351 /*   This point is reached when normal processing completes successfully,    */
      352 /* or when the error$fatal routine is called to abnormally end processing.   */
      353 /*							       */
      354 /* 1) Report status of all processing.				       */
      355 /* 2) Cleanup the standalone invocation.			       */
      356 /* 3) Return to command processor.				       */
      357 /*							       */
      358 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      359 
      360 EXIT:	call ioa_ ("");
      361 	call ssu_$print_message (sci_ptr, 0,
      362 "^a: ^[Copy^;Compare^;Copy and compare^] ^" ||
      363 "[completed successfully.^;
      364 ^;completed successfully,
      365   except for unmatched lines in select file (severity 2 error).
      366 ^;failed due to 
      367   comparison errors (severity 3 error).
      368 ^;failed due to 
      369   fatal error (severity 4 error).^]^2/", 
      370 	   hhmmm(), operation_wanted, severity+1);
      371 	call cleanup_invocation();
      372 	return;
      373 
      374 exit_proc:
      375 	proc;
      376 	severity = max(severity, 4);
      377 	go to EXIT;
      378 	end exit_proc;
      379 
      380 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      381 
      382 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      383 /*							       */
      384 /* ATTACH to TAPE or STORAGE SYSTEM FILE:			       */
      385 /* 1) Name and get pointer to I/O switch.			       */
      386 /* 2) Attach and open switch.  Tapes are attached by mount_next_tape_vol.    */
      387 /* 3) Report the attachment.					       */
      388 /*							       */
      389 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      390 
      391 attach:	proc (iop, mode);
      392 
      393     dcl	iop			ptr,
      394 	1 io			aligned like input based(iop),
      395 	mode			fixed bin;
      396     dcl	atd			char(300) varying,
      397 	code			fixed bin(35),
      398 	count			fixed bin,
      399 	io_switch_name		char(32);
      400 
      401 	io.mode = mode;
      402 	io.recx = 0;
      403 	call ssu_$get_invocation_count (sci_ptr, count, 0);
      404 	io_switch_name = rtrim(ME) || "." || ltrim(char(count)) ||
      405 	   "." || io.header.name;
      406 	if mode = FOR_MOVE_ATTACH then
      407 	   call iox_$find_iocb (io_switch_name, io.target_iocbp, code);
      408 	else
      409 	   call iox_$find_iocb (io_switch_name, io.iocbp, code);
      410 
      411 	if io.vfile.path ^= "" then do;
      412 	   atd = "vfile_ " || rtrim(io.vfile.expath);
      413 	   if mode = Stream_input then
      414 	      atd = atd || " -old";
      415 	   call iox_$attach_ptr (io.iocbp, (atd), null, code);
      416 	   call error$fatal (sci_ptr, code,
      417 	      "^/FATAL ERROR: Attaching ^a file ^a.", io.header.name,
      418 	      io.vfile.expath);
      419 	   call iox_$open (io.iocbp, mode, ""b, code);
      420 	   call error$fatal (sci_ptr, code,
      421 	      "^/FATAL ERROR: Opening ^a file ^a for ^a.", io.header.name,
      422 	      io.vfile.expath, iox_modes(mode));
      423 	   call ssu_$print_message (sci_ptr, 0,
      424 	      "^a: Attached ^a for ^a to file:^/  ^a.^[^/  (^a)^]",
      425 	      hhmmm(), io.header.name, iox_modes(mode),
      426 	      io.vfile.expath, trace ^= OFF, atd);
      427 	   io.vfile.charpos = 0;
      428 	   end;
      429 	else if io.tape.voln > 0 then do;
      430 	   io.tape.volx = 0;
      431 	   if mount_next_tape_vol (io) then;
      432 	   else
      433 	      call error$fatal (sci_ptr, -1,
      434 	         "FATAL ERROR: Unable to attach^[ first^] ^a tape ^a.",
      435 	         io.tape.voln>1, io.header.name, io.vol(1).name);
      436 	   end;
      437 	end attach;
      438 
      439 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      440 
      441 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      442 /*							       */
      443 /* ARGUMENT PROCESSING:					       */
      444 /* Declare variables and subroutines needed for argument processing.	       */
      445 /*							       */
      446 /* CHECK INVOCATION TYPE:					       */
      447 /* 1) Initialize error handling subroutines.			       */
      448 /* 2) Determine whether invoked as command or af.			       */
      449 /* 3) Is this type of invocation allowed?			       */
      450 /* 4) Initialize af return argument, and index of current argument.	       */
      451 /*							       */
      452 /* SEE OTHER ARGUMENT PROCESSING PROGRAMS:			       */
      453 /*   get_arg, get_ctl_arg, get_opt, get_num_opt			       */
      454 /*							       */
      455 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      456 
      457     dcl	af_sw			bit(1) aligned,	/* on: active fnc*/
      458 	arg			char(argl) based(argp),
      459 	argl			fixed bin(21),	/* current arg   */
      460 	argp			ptr,
      461 	argn			fixed bin,	/* arg count     */
      462 	argx			fixed bin,	/* arg index     */
      463 	num_opt			fixed bin,	/* numeric option*/
      464 	opt			char(optl) based(optp),
      465 	optl			fixed bin(21),	/* current option*/
      466 	optp			ptr,
      467 	ret			char(retl) varying based(retp),
      468 	retl			fixed bin(21),	/* af return val */
      469 	retp			ptr,
      470 	sci_ptr			ptr;		/* ssu_ info ptr */
      471 
      472     dcl	ssu_$abort_subsystem	entry() options(variable),
      473 	ssu_$arg_ptr		entry (ptr, fixed bin, ptr, fixed bin(21)),
      474 	ssu_$destroy_invocation	entry (ptr),
      475 	ssu_$print_message		entry() options(variable),
      476 	ssu_$return_arg		entry (ptr, fixed bin, bit(1) aligned, ptr, fixed bin(21)),
      477        	ssu_$standalone_invocation	entry (ptr, char(*), char(*), ptr,
      478 				     entry, fixed bin(35));
      479 
      480     dcl  (ALLOW_COMMAND		init(1),
      481           ALLOW_AF			init(2),
      482 	ALLOW_COMMAND_AF		init(3)) fixed bin int static options(constant);
      483 
      484 check_invocation_type:
      485 	proc (allowed);
      486 
      487     dcl	allowed			fixed bin;
      488     dcl  (error_table_$active_function,
      489 	error_table_$not_act_fnc)	fixed bin(35) ext static;
      490 
      491 	call error$init();
      492 	call ssu_$return_arg (sci_ptr, argn, af_sw, retp, retl);
      493 	if allowed = ALLOW_COMMAND & af_sw then
      494 	   call error$fatal (sci_ptr, error_table_$active_function);
      495 	else if allowed = ALLOW_AF & ^af_sw then
      496 	   call error$fatal (sci_ptr, error_table_$not_act_fnc);
      497 	else if allowed = ALLOW_COMMAND_AF then;
      498 	if af_sw then
      499 	   ret = "";
      500 	argx = 0;
      501 	end check_invocation_type;
      502 
      503 
      504 
      505 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      506 /*							       */
      507 /* CLEANUP:						       */
      508 /* 1) Close attachment (via syn_) of map switch used by backup_map_ subrs.   */
      509 /* 2) Unassign any reserved tape drives we assigned to the process.	       */
      510 /* 3) Silently close/detach all opened I/O switches.		       */
      511 /* 4) Destroy the ssu_ invocation (releasing temp segs obtained thru ssu_).  */
      512 /*							       */
      513 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      514 
      515 cleanup_invocation:
      516        	proc;
      517 
      518 	call map_seg$term();
      519 	call tape_drive$term();
      520 
      521 	call detach (addr(input),    DESTROY);
      522 	call detach (addr(output),   DESTROY);
      523 	call detach (addr(map),      DESTROY);
      524 	call detach (addr(select),   DESTROY);
      525 
      526 	if sci_ptr ^= null then
      527 	   call ssu_$destroy_invocation (sci_ptr);
      528 	end cleanup_invocation;
      529 
      530 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      531 
      532 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      533 /*							       */
      534 /* COMPARE A SEGMENT FROM MASTER with SEGMENT FROM COPY MEDIUM:	       */
      535 /* 1) Initialize error detect remembering switch.  If any comparisons fail,  */
      536 /*    report the error, and let the error routine remember that one	       */
      537 /*    occurred.						       */
      538 /* 2) Compare pathnames of the two segments from backup logical record       */
      539 /*    headers.						       */
      540 /* 3) Compare length of backup logical record headers.		       */
      541 /* 4) Compare header words.					       */
      542 /* 5) Compare segment lengths.				       */
      543 /* 6) Compare segment words.					       */
      544 /*							       */
      545 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      546 
      547 compare_seg:
      548        	proc (bf1, bf2, segx) returns (bit(1));
      549 
      550     dcl   1 (bf1, bf2)		aligned like inbf,
      551 	segx			fixed bin;
      552 
      553     dcl	first_disagreement		fixed bin(18),
      554 	words_disagreeing		fixed bin(18),
      555 	wordx			fixed bin(18);
      556 
      557     dcl	1 he1			aligned like h based (bf1.hp),
      558 	1 he2			aligned like h based (bf2.hp),
      559 	1 he1_name		aligned like inhe_name based (bf1.hp),
      560 	1 he2_name		aligned like inhe_name based (bf2.hp),
      561 	he1_words (bf1.hl)		fixed bin(35) based (bf1.hp),
      562 	he2_words (bf2.hl)		fixed bin(35) based (bf2.hp),
      563 	seg1_words (bf1.segl)	fixed bin(35) based (bf1.segp),
      564 	seg2_words (bf2.segl)	fixed bin(35) based (bf2.segp);
      565 
      566 	call error$init();
      567 	if he1_name.dname ^= he2_name.dname |
      568 	   he1_name.ename ^= he2_name.ename then
      569 	   call error (sci_ptr, -1,
      570 	      "^a: Segment ^d -- Pathname Discrepancy.
      571   Master: ^a
      572   Copy:   ^a", hhmmm(), segx,
      573 	      rtrim(pathname_((he1.dname), (he1.ename)), " >"),
      574 	      rtrim(pathname_((he2.dname), (he2.ename)), " >"));
      575 	else if dim(he1_words,1) ^= dim(he2_words,1) then
      576 	   call error (sci_ptr, -1,
      577 	      "^a: Segment ^d -- Record Header Length Discrepancy.
      578   Master: ^5d words for ^a 
      579   Copy:   ^5d words for ^a", hhmmm(), segx,
      580 	      dim(he1_words,1), rtrim(pathname_((he1.dname), (he1.ename)), " >"),
      581 	      dim(he2_words,1), rtrim(pathname_((he2.dname), (he2.ename)), " >"));
      582 
      583 	else if unspec(he1_words) ^= unspec(he2_words) then do;
      584 	   words_disagreeing = 0;
      585 	   first_disagreement = 0;
      586 	   do wordx = lbound(he1_words,1) to hbound(he1_words,1);
      587 	      if he1_words(wordx) ^= he2_words(wordx) then do;
      588 	         words_disagreeing = words_disagreeing + 1;
      589 	         if words_disagreeing = 1 then
      590 		  first_disagreement = wordx;
      591 	         end;
      592 	      end;
      593 	   call error (sci_ptr, -1,
      594 	      "^a: Segment ^d -- Record Header Discrepancy, ^d word^[s^].
      595 --FIRST DISCREPANCY--
      596   Master: word(^d) = ^w, for ^a 
      597   Copy:   word(^d) = ^w, for ^a", hhmmm(), segx,
      598 	      words_disagreeing^=1, words_disagreeing,
      599 	      first_disagreement, he1_words(first_disagreement),
      600 	      rtrim(pathname_((he1.dname), (he1.ename)), " >"),
      601 	      first_disagreement, he2_words(first_disagreement),
      602 	      rtrim(pathname_((he2.dname), (he2.ename)), " >"));
      603 	   end;
      604 	else if dim(seg1_words,1) ^= dim(seg2_words,1) then
      605 	   call error (sci_ptr, -1,
      606 	      "^a: Segment ^d -- Segment Length Discrepancy.
      607   Master: ^5d words for ^a 
      608   Copy:   ^5d words for ^a", hhmmm(), segx,
      609 	      dim(seg1_words,1), rtrim(pathname_((he1.dname), (he1.ename)), " >"),
      610 	      dim(seg2_words,1), rtrim(pathname_((he2.dname), (he2.ename)), " >"));
      611 	else if unspec(seg1_words) ^= unspec(seg2_words) then do;
      612 	   words_disagreeing = 0;
      613 	   first_disagreement = 0;
      614 	   do wordx = lbound(seg1_words,1) to hbound(seg1_words,1);
      615 	      if seg1_words(wordx) ^= seg2_words(wordx) then do;
      616 	         words_disagreeing = words_disagreeing + 1;
      617 	         if words_disagreeing = 1 then
      618 		  first_disagreement = wordx;
      619 	         end;
      620 	      end;
      621 	   call error (sci_ptr, -1,
      622 	      "^a: Segment ^d -- Segment Contents Discrepancy, ^d word^[s^].
      623 --FIRST DISCREPANCY--
      624   Master: word(^d) = ^w, for ^a 
      625   Copy:   word(^d) = ^w, for ^a", hhmmm(), segx,
      626 	      words_disagreeing^=1, words_disagreeing,
      627 	      first_disagreement, seg1_words(first_disagreement),
      628 	      rtrim(pathname_((he1.dname), (he1.ename)), " >"),
      629 	      first_disagreement, seg2_words(first_disagreement),
      630 	      rtrim(pathname_((he2.dname), (he2.ename)), " >"));
      631 	   end;
      632 	if error$occurred() then do;
      633 	   severity = max(severity, 3);
      634 	   return (FALSE);
      635 	   end;
      636 	else
      637 	   return (TRUE);
      638 
      639 	end compare_seg;
      640 
      641 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      642 
      643 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      644 /*							       */
      645 /* COMPARE ALL SEGMENTS ON COPY with SEGMENTS ON MASTER:		       */
      646 /* 1) Get temp segments to hold dir entry header, and entry contents	       */
      647 /*    (segment) from master and copy tapes.			       */
      648 /* 2) Initialize variables for "last entry read".  This is needed since a    */
      649 /*    backup tape can end with a complete segment while backup_dump thinks   */
      650 /*    the segment was incomplete.  Therefore, it rewrites the segment at     */
      651 /*    the beginning of the next tape.  Such duplicate entries are ignored    */
      652 /*    via the "last entry read" variables.			       */
      653 /* 3) Read master and copy segs in a loop until input is exhausted.	       */
      654 /*    Reading occurs in two steps: first read the header; then read the      */
      655 /*    segment contents if header says this segment participates in the       */
      656 /*    comparison.  Some master segments may be omitted from comparison,      */
      657 /*    because they aren't selected by the -select file.		       */
      658 /* 4) If master entry wasn't selected, then skip it.		       */
      659 /* 5) If master selected, compare the two segs.  Count segs comparing equal. */
      660 /* 6) Report how many entries and msfs were successfully compared.	       */
      661 /*							       */
      662 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      663 
      664 compare_segs:
      665        	proc ();
      666 
      667     dcl  (compare_continues, need_copy, need_master)
      668 				bit(1),
      669          (error_count, extra_masters)	fixed bin,
      670 	MAX_ERRORS		fixed bin int static options(constant) init(20);
      671 
      672 	if mbf.hp = null then
      673 	   call ssu_$get_temp_segment (sci_ptr, "master header", mbf.hp);
      674 	if mbf.segp = null then
      675 	   call ssu_$get_temp_segment (sci_ptr, "master segment", mbf.segp);
      676 	call ssu_$get_temp_segment (sci_ptr, "copy header", cpbf.hp);
      677 	call ssu_$get_temp_segment (sci_ptr, "copy segment", cpbf.segp);
      678 
      679 	mlast.path = "";
      680 	mlast.sizes = 0;
      681 	cplast.path = "";
      682 	cplast.sizes = 0;
      683 
      684 	error_count, extra_masters = 0;
      685 	compare_continues = TRUE;
      686 	need_master = TRUE;
      687 	need_copy = TRUE;
      688 	do while (compare_continues);
      689 	   if need_copy then do;
      690 READ_COPY:      if read_seg$header(cpbf, cplast, output) then do;
      691 	         state = read_seg$contents (cpbf, cplast, output);
      692 	         if state = READ_AGAIN then go to READ_COPY;
      693 	         else if state = OK then
      694 		  need_copy = FALSE;
      695 	         end;
      696 	      end;
      697 
      698 	   if need_master then do;
      699 	      if read_seg$header(mbf, mlast, input) then
      700 	         need_master = FALSE;
      701 	      end;
      702 
      703 	   if need_master & need_copy then		/* When input    */
      704 	      compare_continues = FALSE;		/* ends from     */
      705 						/* both, compare */
      706 						/* is done.      */
      707 
      708 	   else if need_master then do;		/* copy has seg  */
      709 						/*  not on master*/
      710 	      compared.segs = compared.segs + 1;
      711 	      if (cphe.record_type = sec_dir |
      712 	         cphe.record_type = ndc_directory) &
      713 	         cphe.bitcnt > 0 then
      714 	         compared.msfs = compared.msfs + 1;
      715 	      call error (sci_ptr, -1,
      716 "^a: Segment ^d -- 
      717   Copy contains segment not on master media.
      718   Copy:  ^a",      hhmmm(), compared.segs,
      719 	         rtrim(pathname_((cphe.dname), (cphe.ename))," >"));
      720 	      error_count = error_count + 1;
      721 	      if abort_sw then
      722 	         compare_continues = FALSE;
      723 	      else if error_count > MAX_ERRORS then
      724 	         compare_continues = FALSE;
      725 	      else
      726 	         need_copy = TRUE;
      727 	      end;
      728 
      729 	   else if skip_seg (mbf, cpbf, need_copy) then do;
      730 	      state = read_seg$skip_contents(mbf, mlast, input);
      731 	      need_master = TRUE;			/* master seg    */
      732 	      end;				/*  not selected */
      733 
      734 	   else if need_copy then do;			/* master has seg*/
      735 						/*  not on copy  */
      736 	      state = read_seg$skip_contents (mbf, mlast, input);
      737 	      need_master = state = NOMORE;
      738 	      if ^need_master then do;
      739 	         extra_masters = extra_masters + 1;
      740 	         call error (sci_ptr, -1,
      741 "^a: Segment ^d -- 
      742   Master contains segment not on copy media.
      743   Master:  ^a",	  hhmmm(), compared.segs+extra_masters,
      744 		  rtrim(pathname_((mhe.dname),(mhe.ename))," >"));
      745 	         error_count = error_count + 1;
      746 	         if abort_sw then
      747 		  compare_continues = FALSE;
      748 	         else if error_count > MAX_ERRORS then
      749 		  compare_continues = FALSE;
      750 	         else
      751 		  need_master = TRUE;
      752 	         end;
      753 	      end;
      754 
      755 	   else do;				/* read rest of  */
      756 						/*  master       */
      757 	      state = read_seg$contents(mbf, mlast, input);
      758 	      if state ^= OK then			/* master seg    */
      759 	         need_master = TRUE;			/*  incomplete.  */
      760 	      else do;				/* compare segs  */
      761 	         if compare_seg(mbf, cpbf, compared.segs+1) then do;
      762 		  compared.segs = compared.segs + 1;
      763 		  if (mhe.record_type = sec_dir |
      764 		      mhe.record_type = ndc_directory) &
      765 		      mhe.bitcnt > 0 then
      766 		     compared.msfs = compared.msfs + 1;
      767 		  need_master, need_copy = TRUE;
      768 		  end;
      769 	         else do;
      770 		  error_count = error_count + 1;
      771 		  if abort_sw then
      772 		     compare_continues = FALSE;
      773 		  else if error_count > MAX_ERRORS then
      774 		     compare_continues = FALSE;
      775 		  else if mhe_name.dname <= cphe_name.dname &
      776 			mhe_name.ename <= cphe_name.ename then
      777 		     need_master = TRUE;
      778 		  else
      779 		     need_copy = TRUE;
      780 		  end;
      781 	         end;
      782 	      end;
      783 	   end;
      784 
      785 	call detach (addr(input), KEEP);
      786 	call detach (addr(output), KEEP);
      787 
      788 	call ioa_ ("");
      789 	call ssu_$print_message (sci_ptr, 0,
      790 	   "^a: Compared ^d entr^[ies^;s^], including ^d multisegment file^[s^].^[
      791 ^d comparison error^[ was^;s were^] found.^]^/",
      792 	   hhmmm(), compared.segs, compared.segs^=1,
      793 	   compared.msfs, compared.msfs^=1,
      794 	   error_count>0, error_count, error_count=1);
      795 	if error_count > 0 then
      796 	   severity = max(severity,3);
      797 	return;
      798 
      799 	end compare_segs;
      800 
      801 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      802 
      803 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      804 /*							       */
      805 /* COPYING ENTRIES:						       */
      806 /* 1) Get temp segments to hold dir entry header, and entry contents	       */
      807 /*    (segment).						       */
      808 /* 2) Initialize variables for last entry read.			       */
      809 /* 3) Initialize map file.					       */
      810 /* 4) Read segs in a loop until input is exhausted.		       */
      811 /* 5) If entry just read is same as last entry, then skip it.  This can      */
      812 /*    occur if an entry just fits on the end of one tape, but was rewritten  */
      813 /*    at the beginning of the next tape.			       */
      814 /* 6) If not same as last entry, then write it onto the output.  Put segment */
      815 /*    into the map.  Count number of segs actually copied.		       */
      816 /* 7) Report how many entries and msfs were copied.		       */
      817 /*							       */
      818 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      819 
      820 
      821 copy_segs:
      822        	proc ();
      823 
      824 	call ssu_$get_temp_segment (sci_ptr, "input header", inbf.hp);
      825 	call ssu_$get_temp_segment (sci_ptr, "input segment", inbf.segp);
      826 
      827 	inlast.path = "";
      828 	inlast.sizes = 0;
      829 
      830 	state = READ_AGAIN;
      831 	do while (read_seg$header(inbf, inlast, input) & state^=NOMORE);
      832 	   if skip_seg (inbf, inbf, FALSE) then
      833 	      state = read_seg$skip_contents(inbf, inlast, input);
      834 	   else do;
      835 	      state = read_seg$contents(inbf, inlast, input);
      836 	      if state = READ_AGAIN then;
      837 	      else if state = NOMORE then;
      838 	      else do;
      839 	         if write_seg(inbf, output) then do;
      840 		  call map_seg  (inbf);
      841 		  copied.segs = copied.segs + 1;
      842 		  if (inhe.record_type = sec_dir |
      843 		      inhe.record_type = ndc_directory) &
      844 		      inhe.bitcnt > 0 then
      845 		     copied.msfs = copied.msfs + 1;
      846 		  end;
      847 	         else do;
      848 		  call error$fatal (sci_ptr, -1,
      849 		     "^a: FATAL ERROR: Too few output tapes to hold all copied files.",
      850 		     hhmmm());
      851 		  end;
      852 	         end;
      853 	      end;
      854 	   end;
      855 
      856 	call detach (addr(input), KEEP);
      857 	call detach (addr(output), KEEP);
      858 
      859 	call ioa_("");
      860 	call ssu_$print_message (sci_ptr, 0,
      861 	   "^a: Copied ^d entr^[ies^;y^], including ^d multisegment file^[s^].^/",
      862 	   hhmmm(), copied.segs, copied.segs^=1,
      863 	   copied.msfs, copied.msfs^=1);
      864 
      865 	end copy_segs;
      866 
      867 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      868 
      869 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      870 /*							       */
      871 /* CLOSE/DETACH I/O SWITCHES:					       */
      872 /* 1) Check if switch was even found (or if already destroyed).	       */
      873 /* 2) If switch was used used for iox_$move_attach, move back the original   */
      874 /*    attachment.						       */
      875 /* 3) Otherwise, close an opened switch; detach an attached switch.	       */
      876 /* 4) If disposition = DESTROY, then destroy the I/O switch.	       */
      877 /*							       */
      878 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      879 
      880 detach:	proc (iop, disp);
      881 
      882     dcl	iop			ptr,
      883 	disp			fixed bin;
      884 
      885     dcl	1 io			aligned based (iop),
      886 	  2 header		like in_out.header,
      887 	  2 vol (0 refer (io.header.voln))
      888 				like in_out.vol;
      889 
      890 	if io.iocbp = null then;
      891 
      892 	else if io.mode = FOR_MOVE_ATTACH then do;
      893 	   call iox_$detach_iocb (io.iocbp, code);
      894 	   call iox_$move_attach (io.target_iocbp, io.iocbp, code);
      895 	   call iox_$destroy_iocb (io.target_iocbp, code);
      896 	   io.iocbp = null;
      897 	   end;
      898 
      899 	else do;
      900 	   if io.iocbp -> iocb.open_descrip_ptr ^= null then do;
      901 	      if io.vfile.path ^= "" then do;
      902 	         call iox_$close (io.iocbp, code);
      903 	         call error (sci_ptr, code,
      904 		  "^/Closing ^a file: ^a", io.header.name,
      905 		  io.vfile.expath);
      906 	         end;
      907 	      else do;
      908 	         call iox_$close (io.iocbp, code);
      909 	         call error (sci_ptr, code,
      910 		  "^/^a: Closing ^a tape: ^a", hhmmm(), io.header.name,
      911 		  io.vol(io.tape.volx).name);
      912 	         end;
      913 	      end;
      914 
      915 	   if io.iocbp -> iocb.attach_descrip_ptr ^= null then do;
      916 	      if io.vfile.path ^= "" then do;
      917 	         call iox_$detach_iocb (io.iocbp, code);
      918 	         call error (sci_ptr, code,
      919 		  "^/Detaching ^a file: ^a", io.header.name,
      920 		  io.vfile.expath);
      921 	         end;
      922 	      else do;
      923 	         call iox_$detach_iocb (io.iocbp, code);
      924 	         call error (sci_ptr, code,
      925 		  "^/^a: Detaching ^a tape: ^a", hhmmm(), io.header.name,
      926 		  io.vol(io.tape.volx).name);
      927 	         if disp = KEEP then
      928 		  call ssu_$print_message (sci_ptr, 0,
      929 		     "^a: Dismounted ^a tape: ^a", hhmmm(), io.header.name,
      930 		     io.vol(io.tape.volx).name);
      931 	         end;
      932 	      end;
      933 	   end;
      934 
      935 	if io.iocbp ^= null then
      936 	if disp = DESTROY then do;
      937 	   call iox_$destroy_iocb (io.iocbp, code);
      938 	   io.iocbp = null;
      939 	   end;
      940 
      941 	end detach;
      942 
      943 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      944 
      945 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      946 /*							       */
      947 /* ERROR REPORTING ROUTINES:					       */
      948 /* 1) Nonfatal errors set a switch, which can be tested via error_occurred   */
      949 /*    function.						       */
      950 /* 2) Fatal errors abort the subsystem by calling the exit_proc, which       */
      951 /*    branches to the EXIT label to exit the command.		       */
      952 /*							       */
      953 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      954 
      955     dcl	error_occurred_sw		bit(1);
      956 
      957 error: 	proc options (variable);
      958 
      959     dcl	code			fixed bin(35) based (codep),
      960 	codep			ptr;
      961 
      962     dcl	cu_$arg_list_ptr		entry returns(ptr),
      963 	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21),
      964 				     fixed bin(35)),
      965 	cu_$generate_call		entry (entry, ptr);
      966 
      967     dcl	CODE_ARG			fixed bin int static options(constant) init(2),
      968          (FALSE			init("0"b),
      969 	TRUE			init("1"b)) bit(1) int static options(constant);
      970 
      971 	call cu_$arg_ptr (CODE_ARG, codep, 0, 0);
      972 	if code = 0 then return;
      973 	if code = -1 then code = 0;
      974 	error_occurred_sw = TRUE;
      975 	call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr());
      976 	return;
      977 
      978 error$init:
      979 	entry;
      980 
      981 	error_occurred_sw = FALSE;
      982 	return;
      983 	
      984 
      985 error$occurred:
      986 	entry returns (bit(1));
      987 
      988 	return (error_occurred_sw);
      989 	
      990 
      991 error$fatal:
      992 	entry options(variable);
      993 	
      994 	call cu_$arg_ptr (CODE_ARG, codep, 0, 0);
      995 	if code = 0 then return;
      996 	if code = -1 then code = 0;
      997 	error_occurred_sw = TRUE;
      998 	call ioa_ ("");
      999 	call cu_$generate_call (ssu_$abort_subsystem, cu_$arg_list_ptr());
     1000 	end error;
     1001 
     1002 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1003 
     1004 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1005 /*							       */
     1006 /* ARGUMENT GETTING FUNCTIONS:				       */
     1007 /*  get_arg: 	Get next argument.				       */
     1008 /*  get_arg_count:	Get number of arguments.			       */
     1009 /*  get_ctl_arg:	Get next argument, which must be a control argument.     */
     1010 /*							       */
     1011 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1012 
     1013 get_arg:	proc returns (bit(1));
     1014 
     1015     dcl  (FALSE			init("0"b),
     1016 	TRUE			init("1"b)) bit(1) int static options(constant);
     1017 
     1018 	if argx < argn then do;
     1019 	   argx = argx + 1;
     1020 	   call ssu_$arg_ptr (sci_ptr, argx, argp, argl);
     1021 	   return (TRUE);
     1022 	   end;
     1023 	else
     1024 	   return (FALSE);
     1025 	end get_arg;
     1026 
     1027 
     1028 get_arg_count:
     1029        	proc returns (fixed bin);
     1030 	return (argn);
     1031 	end get_arg_count;
     1032        
     1033 
     1034 get_ctl_arg:
     1035        	proc returns (bit(1));
     1036 
     1037     dcl	index			builtin;
     1038 
     1039     dcl  (FALSE			init("0"b),
     1040 	TRUE			init("1"b)) bit(1) int static options(constant),
     1041 	error_table_$bad_arg	fixed bin(35) ext static;
     1042 
     1043 	if get_arg() then
     1044 	   if index(arg, "-") = 1 then
     1045 	      return (TRUE);
     1046 	   else
     1047 	      call error$fatal (sci_ptr, error_table_$bad_arg,
     1048 	      "^a.^/A control argument was expected.", arg);
     1049 	return (FALSE);
     1050 	end get_ctl_arg;
     1051 
     1052 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1053 
     1054 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1055 /*							       */
     1056 /* EXTRACT FINAL ENTRYNAME from pathname			       */
     1057 /*							       */
     1058 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1059 
     1060 get_entry:
     1061        	proc (path) returns (char(32));
     1062 
     1063     dcl	path			char(168);
     1064 	
     1065     dcl	code			fixed bin(35),
     1066 	dir			char(168),
     1067 	ent			char(32);
     1068 
     1069     dcl	expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35));
     1070 
     1071 	call expand_pathname_ (path, dir, ent, code);
     1072 	return (ent);
     1073 	end get_entry;
     1074 
     1075 
     1076 
     1077 
     1078 
     1079 
     1080 
     1081 
     1082 
     1083 
     1084 
     1085 
     1086 
     1087 
     1088 
     1089 
     1090 
     1091 
     1092 
     1093 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1094 /*							       */
     1095 /* CONTROL ARG OPERAND GETTING FUNCTIONS:			       */
     1096 /*  get_num_opt:  Gets next arg, treats it as an integer operand, checks     */
     1097 /*	        that its value is valid.			       */
     1098 /*  get_opt:      Gets next arg.				       */
     1099 /*							       */
     1100 /* Both allow the caller to specify whether the operand is required (an      */
     1101 /* opt_desc is provided) or optional (opt_desc="").		       */
     1102 /*							       */
     1103 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1104 
     1105 get_num_opt:
     1106 	proc (arg_name, opt_desc, default_value, allowed_values)
     1107 	returns (bit(1));
     1108 
     1109     dcl	arg_name			char(*),
     1110 	opt_desc			char(*),
     1111 	default_value		fixed bin,
     1112 	allowed_values (*)		fixed bin;
     1113 
     1114     dcl	valx			fixed bin;
     1115 
     1116     dcl  (convert, dim, hbound, lbound)	builtin;
     1117 
     1118     dcl  (FALSE			init("0"b),
     1119 	TRUE			init("1"b)) bit(1) int static options(constant),
     1120          (error_table_$bad_arg,
     1121 	error_table_$noarg)		fixed bin(35) ext static;
     1122 
     1123 	if argx < argn then do;
     1124 	   argx = argx + 1;
     1125 	   call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
     1126 	   if verify (opt, "0123456789") > 0 then go to BAD_OPT;
     1127 	   num_opt = convert (num_opt, opt);
     1128 	   do valx = lbound(allowed_values,1)
     1129 	          to hbound(allowed_values,1)
     1130 	       while (num_opt ^= allowed_values(valx));
     1131 	      end;
     1132 	   if valx <= hbound(allowed_values,1) then
     1133 	      return (TRUE);
     1134 	   else do;
     1135 BAD_OPT:	      call error (sci_ptr, error_table_$bad_arg,
     1136 	         "^a ^a
     1137 ^a must be followed by a^[n^] ^a.^[
     1138 Default value is:^- ^d^;^s^]^[
     1139 Allowed ^[value is^;values are^]:^-^( ^d^)^]",
     1140 	         arg_name, opt, arg_name,
     1141 	         vowel(opt_desc), opt_desc, 
     1142 	         default_value ^= -1, default_value,
     1143 	       ^(dim(allowed_values,1)=1 & default_value=allowed_values(1)),
     1144 	         dim(allowed_values,1)=1, allowed_values);
     1145 	      return (FALSE);
     1146 	      end;
     1147 	   end;
     1148 	else if opt_desc ^= "" then do;
     1149 	   call error (sci_ptr, error_table_$noarg,
     1150 	      "^/^a must be followed by a^[n^] ^a.^[
     1151 Default value is:^- ^d^;^s^]^[
     1152 Allowed ^[value is^;values are^]:^-^( ^d^)^]", arg_name,
     1153 	      vowel(opt_desc), opt_desc,
     1154 	      default_value ^= -1, default_value,
     1155 	      ^(dim(allowed_values,1)=1 & default_value=allowed_values(1)),
     1156 	      dim(allowed_values,1)=1, allowed_values);
     1157 	   return (FALSE);
     1158 	   end;
     1159 	end get_num_opt;
     1160 
     1161 get_opt:	proc (arg_name, opt_desc) returns (bit(1));
     1162 
     1163     dcl	arg_name			char(*),
     1164 	opt_desc			char(*);
     1165 
     1166     dcl  (FALSE			init("0"b),
     1167 	TRUE			init("1"b)) bit(1) int static options(constant),
     1168 	error_table_$noarg		fixed bin(35) ext static;
     1169 
     1170 	if argx < argn then do;
     1171 	   argx = argx + 1;
     1172 	   call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
     1173 	   if index(opt, "-") = 1 then do;		/* options cannot*/
     1174 	      argx = argx - 1;			/*  look like    */
     1175 	      go to NO_OPT;				/*  control args */
     1176 	      end;
     1177 	   else
     1178 	      return (TRUE);
     1179 	   end;
     1180 	else
     1181 NO_OPT:	   if opt_desc ^= "" then do;
     1182 	      call error (sci_ptr, error_table_$noarg,
     1183 	         "^/^a must be followed by a^[n^] ^a.", arg_name,
     1184 	         vowel(opt_desc), opt_desc);
     1185 	      return (FALSE);
     1186 	      end;
     1187 	return (FALSE);
     1188 	end get_opt;
     1189 
     1190 
     1191 vowel: 	proc (str) returns (bit(1));			/* does opt_desc */
     1192 						/* begin with a  */
     1193 						/* vowel?	       */
     1194 
     1195     dcl	str			char(*),
     1196          (FALSE			init("0"b),
     1197 	TRUE			init("1"b)) bit(1) int static options(constant);
     1198 
     1199 	if search ("aeiouAEIOU", substr(str,1,1)) > 0 then
     1200 	   return (TRUE);
     1201 	else
     1202 	   return (FALSE);
     1203 	end vowel;
     1204 
     1205 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1206 
     1207 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1208 /*							       */
     1209 /* MAJOR OPERATION HEADER:					       */
     1210 /* Pretty-print a header describing:				       */
     1211 /* 1) the name of the operation about to begin;			       */
     1212 /* 2) the input media;					       */
     1213 /* 3) the output media.					       */
     1214 /*							       */
     1215 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1216 
     1217 header:	proc (op, in, out);
     1218 
     1219     dcl	op			char(*),
     1220 	1 in			aligned like input,
     1221 	1 out			aligned like output;
     1222 
     1223     dcl  (from, to)			char(32) varying,
     1224 	indent			fixed bin;
     1225 
     1226     dcl	SP			char(1) int static options(constant) init(" ");
     1227 
     1228 	call ioa_ ("");
     1229 	call ssu_$print_message (sci_ptr, 0,
     1230 	   "^a: ^a...", hhmmm(), op);
     1231 
     1232 	call label (from, "from", in);
     1233 	call label (to,   "to",  out);
     1234 	indent = max (length(from), length(to)) + length(SP);
     1235 	call medium (from, indent, in);
     1236 	call medium (to,   indent, out);
     1237 	return;
     1238 
     1239 
     1240 label:	proc (lab, name, out);			/* compute value */
     1241 						/* of media label*/
     1242 
     1243     dcl	lab			char(32) varying,
     1244 	name			char(*),
     1245 	1 out			aligned like output;
     1246 
     1247 	lab = "  ";
     1248 	lab = lab || name;
     1249 	lab = lab || " ";
     1250 	lab = lab || out.header.name;
     1251 	if out.vfile.path ^= "" then 
     1252 	   lab = lab || " file:";
     1253 	else if out.tape.voln = -1 then
     1254 	   lab = lab || " sink:";
     1255 	else if out.tape.voln ^= 1 then
     1256 	   lab = lab || " tapes:";
     1257 	else
     1258 	   lab = lab || " tape:";
     1259 
     1260 	end label;
     1261 
     1262 
     1263 medium:	proc (lab, indent, out);			/* print medium  */
     1264 						/* label & value */
     1265 
     1266     dcl	lab			char(32) varying,
     1267 	indent			fixed bin,
     1268 	1 out			aligned like output;
     1269 	
     1270     dcl	code			fixed bin(35),
     1271 	len			fixed bin,
     1272 	maxlen			fixed bin,
     1273 	printed			fixed bin,
     1274 	x			fixed bin;
     1275 
     1276 	if out.vfile.path ^= "" then
     1277 	   call ioa_ ("^a^vt ^a", lab, indent, out.vfile.expath);
     1278 	else if out.tape.voln = -1 then
     1279 	   call ioa_ ("^a^vt ^a", lab, indent, "discard");
     1280 	else if out.tape.voln > 0 then do;
     1281 	   len = indent-1;
     1282 	   maxlen = get_line_length_$switch (null, code);
     1283 	   if code ^= 0 then maxlen = 79;
     1284 	   printed = 0;
     1285 	   do x = 1 to out.tape.voln;
     1286 	      if len + length(SP) + length(out.vol(x).name) > maxlen then do;
     1287 	         call ioa_ ("^a^vt^vs^v( ^a^)",
     1288 		  lab, indent, printed, x-1-printed, out.vol(*).name);
     1289 	         printed = x-1;
     1290 	         lab = "";
     1291 	         end;
     1292 	      end;
     1293 	   call ioa_ ("^a^vt^vs^v( ^a^)",
     1294 	      lab, indent, printed, x-1-printed, out.vol(*).name);
     1295 	   end;
     1296 	end medium;
     1297 	end header;
     1298 
     1299 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1300 
     1301 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1302 /*							       */
     1303 /* CURRENT TIME: in form of ^Hd^99v.9MH (ie, HHMM.M).		       */
     1304 /*							       */
     1305 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1306 
     1307 hhmmm: 	proc returns (char(6) varying);
     1308 
     1309     dcl	1 time_form		aligned,
     1310 	  2 hhmm			char(4) unal,
     1311 	  2 ss			pic "99" unal,
     1312 	result			char(6) varying;
     1313 
     1314     dcl	time			builtin;
     1315 
     1316 	string(time_form) = substr(time(),1,length(string(time_form)));
     1317 	result = time_form.hhmm;
     1318 	result = result || ".";
     1319 	result = result || ltrim(char(divide(time_form.ss, 6, 1, 0)));
     1320 	return (result);
     1321 
     1322 	end hhmmm;
     1323 
     1324 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1325 
     1326 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1327 /*							       */
     1328 /* INITIALIZATION.						       */
     1329 /* 1) Initialize variables holding argument values.		       */
     1330 /* 2) Initialize other program data variables.			       */
     1331 /*							       */
     1332 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1333 
     1334 initialize_args:
     1335 	proc;
     1336 
     1337     dcl	UNSET			char(1) int static options(constant) init("~"),
     1338 	UNSPECIFIED		ptr int static options(constant) init(null);
     1339 
     1340 	in_outp = UNSPECIFIED;
     1341 
     1342 	if operation_wanted = COMPARE then
     1343 	   input.header.name = "master";
     1344 	else
     1345 	   input.header.name = "input";
     1346 	input.iocbp = null;
     1347 	input.target_iocbp = null;
     1348 	input.mode = 0;
     1349 	input.recx = 0;
     1350 	input.vfile.path, input.vfile.expath = ""; input.vfile.charpos = 0;
     1351 	input.tape.voln,  input.tape.volx = 0;
     1352 	input.tape.track, input.tape.density = 0;
     1353 	input.vol(*) = "";
     1354 
     1355 	output = input;
     1356 	if operation_wanted = COMPARE then
     1357 	   output.header.name = "copy";
     1358 	else
     1359 	   output.header.name = "output";
     1360 
     1361 	select = output, by name;
     1362 	select.name = "select";
     1363 	select.listp = null;
     1364 	select.select_sw = FALSE;
     1365 
     1366 	map = output, by name;
     1367 	map.name = "map";
     1368 	map.vfile.path = UNSET;
     1369 
     1370 	map_prev = map;
     1371 	map_prev.name = "map_prev";
     1372 
     1373 	abort_sw = FALSE;
     1374 	maximize_devices_sw = FALSE;
     1375 	trace = OFF;
     1376 
     1377 	inbf.blrh.zz1, inbf.blrh.zz2 = BLRH_DELIMITER;
     1378 	inbf.blrh.english = BLRH_ENGLISH;
     1379 	inbf.blrh.hl, inbf.blrh.segl = 0;
     1380 	inbf.hp, inbf.segp = null;
     1381 	cpbf = inbf;
     1382 
     1383 	copied, compared = 0;
     1384 
     1385 	pp = addr(pp);				/* Used in an    */
     1386 						/* include file  */
     1387 	call tape_drive$init();
     1388 	
     1389 	end initialize_args;
     1390 
     1391 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1392 
     1393 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1394 /*							       */
     1395 /* ADD A MAP ENTRY for a segment.				       */
     1396 /*							       */
     1397 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1398 
     1399     dcl	map_last_dir		char(168);
     1400 
     1401 map_seg:	proc (bf);
     1402 
     1403     dcl	1 bf			aligned like inbf,
     1404 	bp			ptr,
     1405 	1 b			aligned like br based(bp),
     1406 	1 he			aligned like h based (bf.hp),
     1407 	nn			fixed bin,
     1408 	np			ptr,
     1409 	nx			fixed bin,
     1410 	1 n (nn)			aligned based (np),
     1411 	  2 l			fixed bin(17) uns unal,
     1412 	  2 pad			bit(19) unal,
     1413 	  2 string		char(32) unal,
     1414 	1 seg			aligned,
     1415 	  2 type			char(10),
     1416 	  2 blocks		fixed bin(9),
     1417 	  2(dtem, dtd, dtu, dtcm)	fixed bin(52);
     1418 
     1419     dcl	TYPE_STRING (0:20)		char(10) aligned int static options(constant) init (
     1420 	  "link", "segment", "directory", "directory",
     1421 	  (15)*,  "segment", "directory");
     1422 
     1423     dcl	sys_info$page_size		fixed bin external static,
     1424 	sys_info$seg_size_256K	fixed bin external static;
     1425 
     1426 	if map.vfile.path = "" then
     1427 	   return;
     1428 
     1429 	if map_last_dir ^= he.dname then do;
     1430 	   map_last_dir  = he.dname;
     1431 	   call backup_map_$directory_line (addr(he.dname), he.dlen);
     1432 	   end;
     1433 
     1434 	seg.type = TYPE_STRING (he.record_type);
     1435 	bp = ptr (addr(he), he.bp);
     1436 	seg.blocks = min (bin (bp -> br (1).cl, 9),
     1437 	   divide (sys_info$seg_size_256K + sys_info$page_size - 1,
     1438 	   sys_info$page_size, 17, 0));
     1439 	seg.dtem = bin (b.dtbm, 52, 0); seg.dtd  = bin (b.dtd,  52, 0);
     1440 	seg.dtu  = bin (b.dtu,  52, 0); seg.dtcm = bin (b.dtm,  52, 0);
     1441 
     1442 	call backup_map_$detail_line2 (he.ename, seg.blocks, seg.type,
     1443 	   clock(), seg.dtem, seg.dtd, seg.dtu, seg.dtcm);
     1444 
     1445 	np = ptr (addr(he), b.namerp);  nn = bin (b.nnames, 17);
     1446 	if he.record_type ^= ndc_directory_list then 
     1447 	do nx = 2 to nn;
     1448 	   call backup_map_$name_line (addr(n.string(nx)), (n.l(nx)));
     1449 	   end;
     1450 
     1451 	end map_seg;
     1452 
     1453 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1454 
     1455 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1456 /*							       */
     1457 /* BACKUP MAP INITIALIZATION:					       */
     1458 /* 1) Return if -map not given.				       */
     1459 /* 2) The backup_map_ subr does all its output on the map I/O switch, so     */
     1460 /*    attach it as a synonym for the switch our map file is attached thru.   */
     1461 /* 3) Put description of output medium in map header line, along with	       */
     1462 /*    current date, and name of -select file.			       */
     1463 /*							       */
     1464 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1465 
     1466        
     1467 
     1468 map_seg$init:
     1469        	proc (out);
     1470 
     1471     dcl	1 out			aligned like output;
     1472 
     1473     dcl	date_time_string		char(40) varying,
     1474 	map_header		char(300) varying,
     1475 	map_line			char(300),
     1476 	out_header		char(128) varying;
     1477 
     1478 	if map.vfile.path = "" then
     1479 	   return;
     1480 
     1481 	call iox_$attach_name ("map", map_prev.iocbp,
     1482 	   "syn_ " || map.iocbp -> iocb.name, null, code);
     1483 	if code = error_table_$not_detached then do;
     1484 	   call attach (addr(map_prev), FOR_MOVE_ATTACH);
     1485 	   call iox_$move_attach (map_prev.iocbp, map_prev.target_iocbp,
     1486 	      code);
     1487 	   call error$fatal (sci_ptr, code,
     1488 	      "^/FATAL ERROR: Moving attachment of map switch.");
     1489 	   call iox_$attach_name ("map", map_prev.iocbp,
     1490 	      "syn_ " || map.iocbp -> iocb.name, null, code);
     1491 	   end;
     1492 	call error$fatal (sci_ptr, code,
     1493 	   "^/FATAL ERROR: Attaching map switch as synonym for ^a.",
     1494 	   map.iocbp -> iocb.name);
     1495 
     1496 	if out.vfile.path ^= "" then
     1497 	   out_header = "File: " || get_entry (out.vfile.path);
     1498 	else if out.tape.voln > 1 then
     1499 	   out_header = "Tape: " || out.vol(1).name;
     1500 	else
     1501 	   out_header = "discard sink";
     1502 	call backup_map_$init_for_cdt (out_header);
     1503 
     1504 	date_time_string = date_time_$format ("date_time", clock(), "", "");
     1505 	call backup_util$idline (map.vfile.expath,
     1506 	   (date_time_string), addr(map_line), length(map_line));
     1507 
     1508 	map_line = out_header;
     1509 	call backup_map_$tapes (addr(map_line), length(rtrim(map_line)));
     1510 
     1511 	map_header = rtrim(ME);
     1512 	map_header = map_header || " version 1.0";
     1513 	if select.vfile.path ^= "" then do;
     1514 	   map_header = map_header || " -select ";
     1515 	   map_header = map_header || select.vfile.expath;
     1516 	   end;
     1517 	map_line = map_header;
     1518 	call backup_map_$beginning_line (clock(), addr(map_line),
     1519 	   length(map_line));
     1520 
     1521 	map_last_dir = "";
     1522 	end map_seg$init;
     1523 
     1524 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1525 
     1526 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1527 /*							       */
     1528 /* BACKUP MAP NEW OUTPUT TAPE:				       */
     1529 /* 1) Change name of output tape in the map.			       */
     1530 /* 2) Repeat directory name at top of new map page.		       */
     1531 /*							       */
     1532 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1533 
     1534        
     1535 
     1536 map_seg$new_tape:
     1537 	proc (out);
     1538 
     1539     dcl	1 out			aligned like output;
     1540 
     1541     dcl	map_line			char(300);
     1542 
     1543 	if map.vfile.path = "" then
     1544 	   return;
     1545 
     1546 	if out.tape.voln > 0 then do;
     1547 	   map_line = "Tape: " || out.vol(out.tape.volx).name;
     1548 	   call backup_map_$tapes (addr(map_line), length(rtrim(map_line)));
     1549 	   end;
     1550 	call backup_map_$heading_line();
     1551 	map_last_dir = "";
     1552 
     1553 	end map_seg$new_tape;
     1554 	
     1555 
     1556 
     1557 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1558 /*							       */
     1559 /* BACKUP MAP TERMINATION:					       */
     1560 /* 1) Detach synonym for map switch.				       */
     1561 /* 2) Close the map file.					       */
     1562 /*							       */
     1563 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1564 
     1565 map_seg$term:
     1566 	proc;
     1567 
     1568     dcl	code			fixed bin(35);
     1569 
     1570 	if map.vfile.path = "" then;
     1571 	else do;
     1572 	   if map_prev.iocbp ^= null then do;
     1573 	      call backup_map_$terminal_line (clock(), 0);
     1574 	      call backup_map_$detach_for_cdt (code);
     1575 	      call detach (addr(map_prev), DESTROY);
     1576 	      call detach (addr(map), DESTROY);
     1577 	      end;
     1578 	   end;
     1579 	end map_seg$term;
     1580 
     1581 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1582 
     1583 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1584 /*							       */
     1585 /* MOUNT NEXT TAPE:						       */
     1586 /* 1) Detach current input or output tape.			       */
     1587 /* 2) If no more tapes exist, return FALSE.			       */
     1588 /* 3) Otherwise, select drive on which to mount tape (if -maxdv given).      */
     1589 /* 4) Attach and open the tape, via tape_mult_.  For stream_output	       */
     1590 /*    openings, set mode to asynchronous.  This means we must do an	       */
     1591 /*    error_count operation after every backup logical record, to ensure     */
     1592 /*    that it gets completely written to tape.			       */
     1593 /* 5) Report time to tape mount to the user.			       */
     1594 /* 6) Find out for sure (from RCP) which tape drive the tape was mounted on  */
     1595 /*    (if -maxdv given).					       */
     1596 /*							       */
     1597 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1598 
     1599 mount_next_tape_vol:
     1600        	proc (io) returns (bit(1));
     1601 
     1602     dcl	1 io			aligned like input;
     1603 
     1604     dcl	atd			char(256) varying,
     1605 	code			fixed bin(35);
     1606 
     1607 	if io.iocbp -> iocb.open_descrip_ptr ^= null then 
     1608 	   call detach (addr(io), KEEP);
     1609 
     1610 	if io.tape.volx >= io.tape.voln then
     1611 	   return (FALSE);
     1612 
     1613 	io.tape.volx = io.tape.volx + 1;
     1614 	if io.vol(io.tape.volx).device ^= "" then
     1615 	   call tape_drive$select_another_device (io);
     1616 	else
     1617 	   call tape_drive$select_a_device (io);
     1618 
     1619 	atd = "tape_mult_ " || rtrim(io.vol(io.tape.volx).name);
     1620 	if io.mode = Stream_output | 
     1621 	   (^maximize_devices_sw &
     1622 	    io.header.name = "output" &
     1623 	    operation_wanted = COPY_AND_COMPARE) then
     1624 	   atd = atd || " -write";
     1625 	if io.vol(io.tape.volx).device ^= "" then do;
     1626 	   atd = atd || " -device ";
     1627 	   atd = atd || rtrim(io.vol(io.tape.volx).device);
     1628 	   end;
     1629 	atd = atd || " -density ";
     1630 	atd = atd || ltrim(char(io.tape.density));
     1631 	atd = atd || " -track ";
     1632 	atd = atd || ltrim(char(io.tape.track));
     1633 	atd = atd || " -error_tally";
     1634 
     1635 	call ssu_$print_message (sci_ptr, 0,
     1636 	   "^a: Mounting ^a tape ^a^[ on ^a^;^s^].^[^/  (^a)^]",
     1637 	   hhmmm(), io.header.name, io.vol(io.tape.volx).name,
     1638 	   io.vol(io.tape.volx).device ^= "", io.vol(io.tape.volx).device,
     1639 	   trace ^= OFF, atd);
     1640 	call iox_$attach_ptr (io.iocbp, (atd), null, code);
     1641 	call error$fatal (sci_ptr, code,
     1642 	   "^/^a: FATAL ERROR: Attaching ^a tape ^a for ^[reading^;writing^].",
     1643 	   hhmmm(), io.header.name, io.vol(io.tape.volx).name,
     1644 	   io.mode=Stream_input);
     1645 	call iox_$open (io.iocbp, io.mode, ""b, code);
     1646 	call error$fatal (sci_ptr, code,
     1647 	   "^/^a: FATAL ERROR: Opening ^a tape ^a for ^[reading^;writing^].",
     1648 	   hhmmm(), io.header.name, io.vol(io.tape.volx).name,
     1649 	   io.mode=Stream_input);
     1650 	if io.mode = Stream_output then do;
     1651 	   call iox_$modes (io.iocbp, "async", "", code);
     1652 	   call error$fatal (sci_ptr, code,
     1653 	      "^/^a: FATAL ERROR: Setting aync mode on ^a tape: ^a",
     1654 	      hhmmm(), io.header.name, io.vol(io.tape.volx).name);
     1655 	   end;
     1656 	call tape_drive$find_device (io.vol(io.tape.volx));
     1657 	call ssu_$print_message (sci_ptr, 0,
     1658 	   "^a: Finished mounting ^a tape: ^a",
     1659 	   hhmmm(), io.header.name, io.vol(io.tape.volx).name);
     1660 	return (TRUE);
     1661 
     1662 	end mount_next_tape_vol;
     1663 
     1664 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1665 
     1666 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1667 /*							       */
     1668 /* PROCESS ARGUMENTS					       */
     1669 /* 1) Match argument to ctl_arg name and operands.		       */
     1670 /* 2) Validate that proper input and output media are specified.	       */
     1671 /* 3) Complete specification of map pathname if -map is given.	       */
     1672 /*							       */
     1673 /* NOTE: Several control arguments affect either input or output media,      */
     1674 /*       depending upon whether -input_XXX or -output_XXX control arg was    */
     1675 /*       most recently given.  in_outp records this choice.		       */
     1676 /*							       */
     1677 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1678 
     1679 process_args:
     1680 	proc;
     1681 
     1682     dcl	UNSET			char(1) int static options(constant) init("~"),
     1683 	UNSPECIFIED		ptr int static options(constant) init(null),
     1684 	VAL_7_9 (2)		fixed bin int static options(constant) init(7, 9),
     1685 	VAL_8_16_62 (3)		fixed bin int static options(constant) init(800, 1600, 6250);
     1686 
     1687     dcl	opt_desc			char(32);
     1688 
     1689 	if get_arg_count() = 0 then
     1690 	   call error$fatal (sci_ptr, error_table_$wrong_no_of_args,
     1691   	      "^/Usage:  ^a INPUT_SPEC OUTPUT_SPEC^[ {-compare}^] {-control_args}",
     1692 	      ME, operation_wanted = COPY);
     1693 
     1694 CTL_ARG_LOOP:
     1695 	do while (get_ctl_arg ());
     1696 	   if arg = "-input_volume" | arg = "-ivol" then do;
     1697 	      in_outp = addr(input);
     1698 SET_REEL:	      in_out.tape.voln = 0;
     1699 	      in_out.vol(*) = "";
     1700 	      input.tape.track = 9;
     1701 	      input.tape.density = 1600;
     1702 	      in_out.vfile.path = "";
     1703 	      opt_desc = in_out.header.name || " tape volume name";
     1704 	      if get_opt (arg, opt_desc) then do;
     1705 	         in_out.tape.voln = 1;
     1706 	         in_out.vol(1).name = opt;
     1707 	         end;
     1708 	      do while (get_opt ("", ""));
     1709 	         if in_out.tape.voln >= hbound(in_out.vol,1) then
     1710 		  call error (sci_ptr, error_table_$too_many_names,
     1711 		     "^a ^a.^/Only ^d names may be given.", arg, opt,
     1712 		     hbound(in_out.vol,1));
     1713 	         else do;
     1714 		  in_out.tape.voln = in_out.tape.voln + 1;
     1715 		  in_out.vol(in_out.tape.voln).name = opt;
     1716 		  end;
     1717 	         end;
     1718 	      end;
     1719 
     1720 	   else if arg = "-input_file" | arg = "-if" then do;
     1721 	      in_outp = addr(input);
     1722 SET_PATH:	      in_out.tape.voln = 0;
     1723 	      in_out.vol(*) = "";
     1724 	      in_out.tape.track, in_out.tape.density = 0;
     1725 	      in_out.vfile.path = "";
     1726 	      opt_desc = in_out.header.name || " file pathname";
     1727 	      if get_opt (arg, opt_desc) then do;
     1728 	         if in_out_selected() then do;
     1729 		  in_out.vfile.path = opt;
     1730 		  call absolute_pathname_ (in_out.vfile.path,
     1731 		     in_out.vfile.expath, code);
     1732 		  call error (sci_ptr, code, "^a ^a", arg, opt);
     1733 		  if code = 0 then
     1734 		     in_out.vfile.expath = get_shortest_path_ (in_out.vfile.expath);
     1735 		  end;
     1736 	         end;
     1737 	      end;
     1738 
     1739 	   else if arg = "-output_volume" | arg = "-ovol" then do;
     1740 	      in_outp = addr(output);
     1741 	      go to SET_REEL;
     1742 	      end;
     1743 	   else if arg = "-output_file" | arg = "-of" then do;
     1744 	      in_outp = addr(output);
     1745 	      go to SET_PATH;
     1746 	      end;
     1747 	   else if (arg = "-output_discard" | arg = "-od") &
     1748 		  mod(operation_wanted,2) = COPY then do;
     1749 	      in_outp = addr(output);
     1750 	      in_out.tape.voln = -1;
     1751 	      in_out.vol(*) = "";
     1752 	      in_out.tape.track, in_out.tape.density = 0;
     1753 	      in_out.vfile.path = "";
     1754 	      end;
     1755 
     1756 	   else if (arg = "-master_volume" | arg = "-mvol") &
     1757 		 operation_wanted = COMPARE then do;
     1758 	      in_outp = addr(input);
     1759 	      go to SET_REEL;
     1760 	      end;
     1761 	   else if (arg = "-copy_volume" | arg = "-cvol") &
     1762 		 operation_wanted = COMPARE then do;
     1763 	      in_outp = addr(output);
     1764 	      go to SET_REEL;
     1765 	      end;
     1766 
     1767 	   else if arg = "-track" | arg = "-tk" then do;
     1768 	      if get_num_opt (arg, "tape track specification", 9, VAL_7_9) then do;
     1769 	         if in_out_selected() then
     1770 		  in_out.tape.track = num_opt;
     1771 	         end;
     1772 	      end;
     1773 	   else if arg = "-density" | arg = "-den" then do;
     1774 	      if get_num_opt (arg, "tape density specification", 1600, VAL_8_16_62) then do;
     1775 	         if in_out_selected() then 
     1776 		  in_out.tape.density = num_opt;
     1777 	         end;
     1778 	      end;
     1779 
     1780 	   else if arg = "-abort" then
     1781 	      abort_sw = TRUE;
     1782 	   else if arg = "-no_abort" | arg = "-nabort" then
     1783 	      abort_sw = FALSE;
     1784 
     1785 	   else if arg = "-trace" then do;
     1786 	      if get_opt ("", "") then do;
     1787 	         if opt = "rejects" | opt = "reject" | opt = "rej" then
     1788 		  trace = REJECTS;
     1789 	         else if opt = "off" then
     1790 		  trace = OFF;
     1791 	         else if opt = "copy" | opt = "cp" then
     1792 		  trace = COPY;
     1793 	         else if opt = "compare" | opt = "cmp" then
     1794 		  trace = COMPARE;
     1795 	         else if opt = "all" | opt = "a" then
     1796 		  trace = COPY_AND_COMPARE;
     1797 	         else
     1798 		  call error (sci_ptr, error_table_$bad_opt,
     1799 		     "^a ^a^/Allowed trace types are:
     1800   off
     1801   rejects, rej
     1802   copy, cp
     1803   compare, cmp
     1804   all, a", arg, opt);
     1805 	         end;
     1806 	      else if operation_wanted = COMPARE then
     1807 	         trace = COMPARE;
     1808 	      else 
     1809 	         trace = COPY;
     1810 	      end;
     1811 	   else if arg = "-no_trace" | arg = "-ntrace" then
     1812 	      trace = OFF;
     1813 
     1814 	   else if arg = "-maximize_devices" | arg = "-maxdv" then
     1815 	      maximize_devices_sw = TRUE;
     1816 	   else if arg = "-no_maximize_devices" | arg = "nmaxdv" then
     1817 	      maximize_devices_sw = FALSE;
     1818 
     1819 	   else if arg = "-select" | arg = "-slct" then do;
     1820 	      opt_desc = select.header.name || " file pathname";
     1821 	      if operation_wanted = COMPARE then	/* -select path  */
     1822 						/* optional for  */
     1823 						/* old compare ep*/
     1824 	         if get_opt ("", "") then go to SET_SELECT;
     1825 	         else select.select_sw = TRUE;
     1826 	      else if get_opt (arg, opt_desc) then do;
     1827 SET_SELECT:        select.vfile.path = opt;
     1828 	         call absolute_pathname_ (select.vfile.path,
     1829 		  select.vfile.expath, code);
     1830 	         call error (sci_ptr, code, "^a ^a", arg, opt);
     1831 	         if code = 0 then
     1832 		  select.vfile.expath = get_shortest_path_ (select.vfile.expath);
     1833 	         end;
     1834 	      end;
     1835 	   else if arg = "-no_select" | arg = "-nslct" then do;
     1836 	      select.vfile.path = "";
     1837 	      select.select_sw = FALSE;
     1838 	      end;
     1839 
     1840 	   else if (arg = "-compare" | arg = "-cmp") &
     1841 		 mod(operation_wanted,2) = COPY then
     1842 	      operation_wanted = COPY_AND_COMPARE;
     1843 	   else if (arg = "-no_compare" | arg = "-ncmp") &
     1844 		 mod(operation_wanted,2) = COPY then
     1845 	      operation_wanted = COPY;
     1846 
     1847 	   else if arg = "-map" & mod(operation_wanted,2) = COPY then do;
     1848 	      map.vfile.path = "";			/* Use default   */
     1849 						/*  map path     */
     1850 	      if get_opt ("", "") then do;		/* optional path */
     1851 	         map.vfile.path = opt;
     1852 	         call absolute_pathname_$add_suffix (map.vfile.path, "map",
     1853 		  map.vfile.expath, code);
     1854 	         call error (sci_ptr, code, "^a ^a", arg, opt);
     1855 	         if code = 0 then
     1856 		  map.vfile.expath = get_shortest_path_ (map.vfile.expath);
     1857 	         end;
     1858 	      end;
     1859 	   else if (arg = "-no_map" | arg = "-nmap") &
     1860 		 mod(operation_wanted,2) = COPY then do;
     1861 	      map.vfile.path = UNSET;
     1862 	      end;
     1863 	   else
     1864 	      call error (sci_ptr, error_table_$bad_opt, "^a", arg);
     1865 	   end CTL_ARG_LOOP;
     1866 
     1867 	if error$occurred() then			/* stop now if   */
     1868 	   call error$fatal (sci_ptr, -1);		/* ctl arg errs  */
     1869 
     1870 	if input.tape.voln = 0 & input.vfile.path = "" then
     1871 	   call error$fatal (sci_ptr, error_table_$noarg,
     1872 	      " An input specification must be
     1873 given by -input_volume or -input_file control arguments.");
     1874 	if output.tape.voln = 0 & output.vfile.path = "" then
     1875 	   call error$fatal (sci_ptr, error_table_$noarg,
     1876 	      " An output specification must be
     1877 given by -output_volume, -output_file or -output_discard control arguments.");
     1878 
     1879 	if input.tape.density  = 0 then input.tape.density  = 1600;
     1880 	if input.tape.track    = 0 then input.tape.track    = 9;
     1881 	if output.tape.density = 0 then output.tape.density = 1600;
     1882 	if output.tape.track   = 0 then output.tape.track   = 9;
     1883 
     1884 	if output.tape.voln = -1 &
     1885 	   operation_wanted = COPY_AND_COMPARE then
     1886 	   call error$fatal (sci_ptr, error_table_$inconsistent,
     1887 	      "^/-compare is inconsistent with -output_discard.");
     1888 
     1889 	if map.vfile.path = UNSET then
     1890 	   map.vfile.path = "";
     1891 	else if map.vfile.path = "" then do;
     1892 	   if output.vfile.path ^= "" then
     1893 	      map.vfile.path = get_entry(output.vfile.path);
     1894 	   else if output.tape.voln > 0 then
     1895 	      map.vfile.path = output.vol(1).name;
     1896 	   else if select.vfile.path ^= "" then 
     1897 	      map.vfile.path = get_entry (select.vfile.path);
     1898 	   else
     1899 	      map.vfile.path = unique_chars_(""b);
     1900 	   call absolute_pathname_$add_suffix (map.vfile.path, "map",
     1901 	      map.vfile.expath, code);
     1902 	   call error$fatal (sci_ptr, code,
     1903 	      "Adding map suffix to -output_file or -output_volume name ^a.",
     1904 	      map.vfile.path);
     1905 	   map.vfile.expath = get_shortest_path_ (map.vfile.expath);
     1906 	   end;
     1907 	return;
     1908 
     1909 
     1910 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1911 /*							       */
     1912 /* ARG CONSISTENCY CHECKER:					       */
     1913 /* 1) Check for -input_XXX or -output_XXX having been specified, prior to    */
     1914 /*    receiving -track or -density.				       */
     1915 /* 2) If neither -input_XXX nor -output_XXX was given, diagnose error.       */
     1916 /* 3) Otherwise return TRUE to caller.				       */
     1917 /*							       */
     1918 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1919 
     1920 in_out_selected:
     1921 	proc returns (bit(1));
     1922 
     1923 	if in_outp = UNSPECIFIED then do;
     1924 	   call error (sci_ptr, error_table_$inconsistent,
     1925 	      "^/^a must follow -input_volume, -input_file, -output_volume, -output_file, or^/-output_discard.", arg);
     1926 	   return (FALSE);
     1927 	   end;
     1928 	return (TRUE);
     1929 
     1930 	end in_out_selected;
     1931 
     1932 	end process_args;
     1933 
     1934 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1935 
     1936 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1937 /*							       */
     1938 /* READ LINE FROM FILE:					       */
     1939 /* 1) Read line from -select file.  Remove trailing NL.		       */
     1940 /*							       */
     1941 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1942 
     1943 
     1944     dcl	line			char(300) varying;
     1945 
     1946 read_line:
     1947        	proc (inp) returns (bit(1));
     1948 
     1949     dcl	inp			ptr,
     1950 	1 in			aligned like select based(inp);
     1951 
     1952     dcl	code			fixed bin(35);
     1953 
     1954     dcl	1 line_buffer		aligned based(addr(line)),
     1955 	  2 l			fixed bin(21),
     1956 	  2 data			char(300);
     1957 
     1958     dcl	HT_SP			char(2) int static options(constant) init("	 "),
     1959 	NL			char(1) int static options(constant) init("
     1960 ");
     1961 
     1962 RE_READ:	call iox_$get_line (in.iocbp, addr(line_buffer.data),
     1963 	   length(line_buffer.data), line_buffer.l, code);
     1964 	if code = 0 then do;			/* remove NL     */
     1965 	   in.recx = in.recx + 1;
     1966 	   line = substr (line, 1, length(line) - length(NL));
     1967 	   line = ltrim(line, HT_SP);
     1968 	   line = rtrim(line, HT_SP);
     1969 	   if line = "" then go to RE_READ;		/* blank line    */
     1970 	   return (TRUE);
     1971 	   end;
     1972 	else if code = error_table_$end_of_info then do;
     1973 	   line = "";
     1974 	   return (FALSE);
     1975 	   end;
     1976 	else
     1977 	   call error$fatal (sci_ptr, code,
     1978 	      "^/FATAL ERROR: Reading line ^d from ^a file ^a.", in.recx,
     1979 	      in.name, in.vfile.expath);
     1980 
     1981 	end read_line;
     1982 
     1983 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1984 
     1985 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1986 /*							       */
     1987 /* READ BACKUP LOGICAL RECORD HEADER:				       */
     1988 /*   Read the header and segment attributes of next segment from input       */
     1989 /* medium.  If it is a segment we are interested in, then we will read       */
     1990 /* segment contents later; otherwise, we will iox_$position (skip) over the  */
     1991 /* segment contents.					       */
     1992 /*							       */
     1993 /* 1) Decide whether input is from vfile_ or tape.		       */
     1994 /* 2) If from vfile_, read size fields from backup logical record header     */
     1995 /*    (blrh), followed by the attributes of the segment.		       */
     1996 /* 3) If from tape, read backup logical record header itself from tape,      */
     1997 /*    followed by the attributes of the segment.  If current tape is	       */
     1998 /*    exhausted, mount next tape and try reading blrh again.	       */
     1999 /* 4) Return TRUE if another header exists, FALSE if input is exhausted.     */
     2000 /*							       */
     2001 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2002 
     2003 read_seg$header:
     2004 	proc (bf, last, in) returns(bit(1));
     2005 
     2006     dcl	1 bf			aligned like inbf,
     2007 	1 he			aligned like h based (bf.hp),
     2008 	1 last			aligned like inlast,
     2009 	1 in			aligned like input;
     2010 
     2011     dcl   1 blrh			aligned like inbf.blrh based,
     2012 	1 blrh_sizes		aligned like inbf.blrh.sizes based,
     2013 	readl			fixed bin(21),
     2014 	readneed			fixed bin(21);
     2015 
     2016     dcl	size			builtin;
     2017 
     2018 	if in.vfile.path ^= "" then do;		/* read from file*/
     2019 	   call iox_$get_chars (in.iocbp, addr(bf.blrh.sizes),
     2020 	      size(blrh_sizes) * CHARS_PER_WORD, readl, code);
     2021 	   if code = 0 &
     2022 	      readl = size(blrh_sizes) * CHARS_PER_WORD then do;
     2023 	      in.vfile.charpos = in.vfile.charpos + readl;
     2024 	      bf.blrh.zz1, bf.blrh.zz2 = BLRH_DELIMITER;
     2025 	      bf.blrh.english = BLRH_ENGLISH;
     2026 	      call iox_$get_chars (in.iocbp, addr(he),
     2027 	         bf.blrh.hl * CHARS_PER_WORD, readl, code);
     2028 	      if code = 0 &
     2029 	         readl = bf.blrh.hl * CHARS_PER_WORD then do;
     2030 	         in.vfile.charpos = in.vfile.charpos + readl;
     2031 	         return (TRUE);
     2032 	         end;
     2033 	      end;
     2034 	   if code = error_table_$end_of_info then
     2035 	      return (FALSE);
     2036 	   else
     2037 	      call error$fatal (sci_ptr, code,
     2038 	         "^/^a: FATAL ERROR: Reading header of record ^d of ^a file:^/  ^a.",
     2039 	         hhmmm(), in.recx+1, in.header.name, in.vfile.expath);
     2040 	   end;
     2041 
     2042 	else if in.iocbp -> iocb.open_descrip_ptr = null then
     2043 	   return (FALSE);				/* all input     */
     2044 						/* tapes 	       */
     2045 						/* exhausted     */
     2046 
     2047 	else do;					/* read from tape*/
     2048 REREAD:	   call iox_$get_chars (in.iocbp, addr(bf.blrh),
     2049 	      size(blrh) * CHARS_PER_WORD, readl, code);
     2050 	   if code = 0 &
     2051 	      readl = size(blrh) * CHARS_PER_WORD then do;
     2052 	      if bf.blrh.zz1 ^= BLRH_DELIMITER |
     2053 	         bf.blrh.zz2 ^= BLRH_DELIMITER |
     2054 	         bf.blrh.english ^= BLRH_ENGLISH then
     2055 	         call error$fatal (sci_ptr, -1,
     2056 	         "^a: FATAL ERROR: Reading header of record ^d of ^a file:^/  ^a.
     2057 Record did not begin with a proper backup logical record header.
     2058 Header.zz1:     ^a
     2059 Header.english: ^a
     2060 Header.zz2:     ^a",
     2061 	         hhmmm(), in.recx, in.header.name, in.vol(in.tape.volx).name,
     2062 	         bf.blrh.zz1, bf.blrh.english, bf.blrh.zz2);
     2063 
     2064 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2065 /*							       */
     2066 /* blrh + he, and seg are written in 256-word blocks, so we must round up    */
     2067 /* the amount we read to the next 256-word boundary.  At this point,	       */
     2068 /* blrh-words have already been read.				       */
     2069 /*							       */
     2070 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2071 
     2072 	      readneed = bf.blrh.hl + size(blrh) + BLOCK_SIZE - 1;
     2073 	      readneed = readneed - mod(readneed, BLOCK_SIZE) - size(blrh);
     2074 	      call iox_$get_chars (in.iocbp, addr(he),
     2075 	         readneed * CHARS_PER_WORD, readl, code);
     2076 	      if code = 0 &
     2077 	         readl = readneed * CHARS_PER_WORD then do;
     2078 	         if last.dir ^= "" &
     2079 		  last.path.dir = he.dname   &
     2080 		  last.path.ent = he.ename   &
     2081 		  last.sizes.he = bf.blrh.hl &
     2082 		  last.sizes.seg= bf.blrh.segl then do;
     2083 		  call ssu_$print_message (sci_ptr, 0,
     2084 		     "^a: Skipping duplicate ^a segment:^/  ^a",
     2085 		     hhmmm(), in.header.name,
     2086 		     rtrim(pathname_(last.path.dir, last.path.ent), " >"));
     2087 		  readneed = bf.blrh.segl + BLOCK_SIZE - 1;
     2088 		  readneed = readneed - mod(readneed, BLOCK_SIZE);
     2089 		  call iox_$position (in.iocbp, 3,
     2090 		     readneed * CHARS_PER_WORD, code);
     2091 		  if code = 0 then 
     2092 		     go to REREAD;
     2093 		  end;
     2094 	         return (TRUE);
     2095 	         end;
     2096 	      end;
     2097 	   if code = error_table_$end_of_info then do;
     2098 	      if mount_next_tape_vol (in) then
     2099 	         go to REREAD;
     2100 	      else
     2101 	         return (FALSE);
     2102 	      end;
     2103 	   else
     2104 	      call error$fatal (sci_ptr, code,
     2105 	         "^/^a: FATAL ERROR: Reading header of record ^d of ^a tape: ^a.",
     2106 	         hhmmm(), in.recx+1, in.header.name,
     2107 	         in.vol(in.tape.volx).name);
     2108 	   end;
     2109 
     2110 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2111 /*							       */
     2112 /* READ SEGMENT CONTENTS:					       */
     2113 /* 1) If input from vfile, read segment contents based upon sizes from blrh. */
     2114 /* 2) If input from tape, read segment contents based upon sizes from blrh.  */
     2115 /*    Record pathname of segment as the last one which was read completely   */
     2116 /*    from tape.						       */
     2117 /* 3) In either case, there are three possible outcomes: reading segment     */
     2118 /*    contents was successful (OK); input was exhausted (NOMORE); segment    */
     2119 /*    contents was incomplete on this tape, need to read header from next    */
     2120 /*    tape (READ_AGAIN).					       */
     2121 /*							       */
     2122 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2123 
     2124 read_seg$contents:
     2125 	entry (bf, last, in) returns (fixed bin);
     2126 
     2127 	if in.vfile.path ^= "" then do;		/* read from file*/
     2128 	   if bf.blrh.segl > 0 then do;
     2129 	      call iox_$get_chars (in.iocbp, bf.segp,
     2130 	         bf.blrh.segl * CHARS_PER_WORD, readl, code);
     2131 	      if code = 0 &
     2132 	         readl = bf.blrh.segl * CHARS_PER_WORD then do;
     2133 	         in.vfile.charpos = in.vfile.charpos + readl;
     2134 	         in.recx = in.recx + 1;
     2135 	         return (OK);
     2136 	         end;
     2137 	      end;
     2138 	   else do;
     2139 	      in.recx = in.recx + 1;
     2140 	      return (OK);
     2141 	      end;
     2142 	   if code = error_table_$end_of_info then
     2143 	      return (NOMORE);
     2144 	   else
     2145 	      call error$fatal (sci_ptr, code,
     2146 	         "^/^a: FATAL ERROR: Reading contents of record ^d of ^a file:^/  ^a.",
     2147 	         hhmmm(), in.recx+1, in.header.name, in.vfile.expath);
     2148 	   end;
     2149 	else do;					/* read from tape*/
     2150 	   if bf.blrh.segl > 0 then do;
     2151 	      readneed = bf.blrh.segl + BLOCK_SIZE - 1;
     2152 	      readneed = readneed - mod(readneed, BLOCK_SIZE);
     2153 	      call iox_$get_chars (in.iocbp, bf.segp,
     2154 	         readneed * CHARS_PER_WORD, readl, code);
     2155 	      if code = 0 &
     2156 	         readl = readneed * CHARS_PER_WORD then do;
     2157 SETREAD:	         in.recx = in.recx + 1;
     2158 	         last.path.dir = he.dname;
     2159 	         last.path.ent = he.ename;
     2160 	         last.sizes.he = bf.blrh.hl;
     2161 	         last.sizes.seg= bf.blrh.segl;
     2162 	         return (OK);
     2163 	         end;
     2164 	      end;
     2165 	   else go to SETREAD;
     2166 
     2167 	   if code = error_table_$end_of_info then do;
     2168 	      if mount_next_tape_vol (in) then
     2169 	         return (READ_AGAIN);
     2170 	      else
     2171 	         return (NOMORE);
     2172 	      end;
     2173 	   else
     2174 	      call error$fatal (sci_ptr, code,
     2175 	         "^/^a: FATAL ERROR: Reading contents of record ^d of ^a tape: ^a",
     2176 	         hhmmm(), in.recx+1, in.header.name,
     2177 	         in.vol(in.tape.volx).name);
     2178 	   end;
     2179 
     2180 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2181 /*							       */
     2182 /* SKIP SEGMENT CONTENTS:					       */
     2183 /* 1) If input from vfile, skip segment contents based upon sizes from blrh. */
     2184 /* 2) If input from tape, skip segment contents based upon sizes from blrh.  */
     2185 /*    Record pathname of segment as the last one which was read completely   */
     2186 /*    from tape.						       */
     2187 /* 3) In either case, there are three possible outcomes: skipping segment    */
     2188 /*    contents was successful (OK); input was exhausted (NOMORE); segment    */
     2189 /*    contents was incomplete on this tape, need to read header from next    */
     2190 /*    tape (READ_AGAIN).					       */
     2191 /*							       */
     2192 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2193 
     2194 read_seg$skip_contents:
     2195 	entry (bf, last, in) returns (fixed bin);
     2196 
     2197 	if in.vfile.path ^= "" then do;		/* read from file*/
     2198 	   if bf.blrh.segl > 0 then do;
     2199 	      readl = bf.blrh.segl * CHARS_PER_WORD;
     2200 	      call iox_$position (in.iocbp, 2, in.vfile.charpos + readl,
     2201 	         code);
     2202 	      if code = 0 then do;
     2203 	         in.vfile.charpos = in.vfile.charpos + readl;
     2204 	         in.recx = in.recx + 1;
     2205 	         return (OK);
     2206 	         end;
     2207 	      end;
     2208 	   else do;
     2209 	      in.recx = in.recx + 1;
     2210 	      return (OK);
     2211 	      end;
     2212 	   if code = error_table_$end_of_info then
     2213 	      return (NOMORE);
     2214 	   else
     2215 	      call error$fatal (sci_ptr, code,
     2216 	         "^/^a: FATAL ERROR: Skipping contents of record ^d of ^a file:^/  ^a",
     2217 	         hhmmm(), in.recx+1, in.header.name, in.vfile.expath);
     2218 	   end;
     2219 	else do;					/* read from tape*/
     2220 	   if bf.blrh.segl > 0 then do;
     2221 	      readneed = bf.blrh.segl + BLOCK_SIZE - 1;
     2222 	      readneed = readneed - mod(readneed, BLOCK_SIZE);
     2223 	      call iox_$position (in.iocbp, 3, 
     2224 	         readneed * CHARS_PER_WORD, code);
     2225 	      if code = 0 then do;
     2226 SETSKIP:	         in.recx = in.recx + 1;
     2227 	         last.path.dir = he.dname;
     2228 	         last.path.ent = he.ename;
     2229 	         last.sizes.he = bf.blrh.hl;
     2230 	         last.sizes.seg= bf.blrh.segl;
     2231 	         return (OK);
     2232 	         end;
     2233 	      end;
     2234 	   else go to SETSKIP;
     2235 
     2236 	   if code = error_table_$end_of_info then do;
     2237 	      if mount_next_tape_vol (in) then
     2238 	         return (READ_AGAIN);
     2239 	      else
     2240 	         return (NOMORE);
     2241 	      end;
     2242 	   else
     2243 	      call error$fatal (sci_ptr, code,
     2244 	         "^/^a: FATAL ERROR: Skipping contents of record ^d of ^a tape: ^a",
     2245 	         hhmmm(), in.recx+1, in.header.name,
     2246 	         in.vol(in.tape.volx).name);
     2247 	   end;
     2248 
     2249 	end read_seg$header;
     2250 
     2251 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     2252 
     2253 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2254 /*							       */
     2255 /* PERFORM -select SELECTIONS:				       */
     2256 /*   skip_seg chooses which records from the master tape should be selected  */
     2257 /* for copying onto copy tape, or for comparision with contents of copy      */
     2258 /* tape.							       */
     2259 /*							       */
     2260 /* SELECT INITIALIZATION:					       */
     2261 /* 1) Get temp segment to hold -select data.			       */
     2262 /* 2) Read lines from -select file, and add them to -select data list.       */
     2263 /*							       */
     2264 /* PARSE SELECT LINES:					       */
     2265 /* 1) Lines beginning with ^ identify entries NOT to be selected.	       */
     2266 /* 2) Lines ending with >** identify entire subtrees to be selected or       */
     2267 /*    rejected.						       */
     2268 /*							       */
     2269 /* SELECT TERMINATION:					       */
     2270 /* 1) Report lines in -select data which were not matched by entries on the  */
     2271 /*    master tape.						       */
     2272 /*							       */
     2273 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2274 
     2275 skip_seg$init:
     2276        	proc;
     2277 
     2278     dcl	1 list			aligned based (select.listp),
     2279 	  2 n			fixed bin,
     2280 	  2 x			fixed bin,
     2281 	  2 e (0 refer (list.n)),
     2282 	    3 path		char(168) varying,
     2283 	    3 type		fixed bin(17) unal,
     2284 	    3 dont_select		fixed bin(1) uns unal,
     2285 	    3 subtree		bit(1) unal,
     2286 	    3 matched		bit(1) unal,
     2287 	    3 added_as_msf		bit(1) unal,
     2288 	    3 pad1		bit(14) unal;
     2289 
     2290     dcl  (UNKNOWN			init(-1),
     2291 	LINK			init(0),
     2292 	SEG			init(1),
     2293 	DIR			init(2),
     2294 	MSF			init(3)) fixed bin int static options(constant),
     2295 	TYPE_NAME (-1:3)		char(7) varying int static options(constant) init(
     2296 				"UNKNOWN", "LINK", "SEG", "DIR",
     2297 				"MSF");
     2298 
     2299 	call ssu_$get_temp_segment (sci_ptr, "select_paths", select.listp);
     2300 	list.n, list.x = 0;
     2301 	do while (read_line(addr(select)));
     2302 	   call add_to_select_list (line, UNKNOWN, FALSE, FALSE);
     2303 	   end;
     2304 	return;
     2305 
     2306 add_to_select_list:
     2307 	proc (line, type, matched, added_as_msf);
     2308 
     2309     dcl	line			char(*) varying,
     2310 	type			fixed bin,
     2311 	matched			bit(1),
     2312 	added_as_msf		bit(1);
     2313 
     2314     dcl	1 en			aligned like list.e;
     2315 
     2316 	list.n = list.n + 1;
     2317 	if substr (line, 1, length("^")) = "^" then do;
     2318 	   en.path = substr (line, 2);
     2319 	   en.dont_select = 1;
     2320 	   end;
     2321 	else do;
     2322 	   en.path = line;
     2323 	   en.dont_select = 0;
     2324 	   end;
     2325 	en.type = type;
     2326 	en.matched = matched;
     2327 	en.added_as_msf = added_as_msf;
     2328 	en.pad1 = ""b;
     2329 	en.subtree = FALSE;
     2330 	if length (en.path) >= length (">**") then
     2331 	if substr(en.path, length(en.path)-length(">**")+1,
     2332 				     length(">**")) = ">**" then do;
     2333 	   en.path = substr(en.path, 1,  length(en.path)-length(">**"));
     2334 	   en.subtree = TRUE;
     2335 	   end;
     2336 	list.e(list.n) = en;
     2337 	end add_to_select_list;
     2338 
     2339 
     2340 skip_seg$term:
     2341        	entry;
     2342 	
     2343     dcl	header_needed		bit(1);
     2344 
     2345 	if select.vfile.path = "" then
     2346 	   return;
     2347 	header_needed = TRUE;
     2348 	do list.x = lbound(list.e,1) to hbound(list.e,1);
     2349 	   if ^list.e(list.x).matched then do;
     2350 	      if header_needed then do;
     2351 	         call ioa_ ("");
     2352 	         call error (sci_ptr, -1, "^a: Unmatched Select Entries:",
     2353 		  hhmmm());
     2354 	         header_needed = FALSE;
     2355 	         end;
     2356 	      call ioa_ ("^[^^^; ^]^a^[>**^]",
     2357 	         list.e(list.x).dont_select=1, list.e(list.x).path,
     2358 	         list.e(list.x).subtree);
     2359 	      severity = 2;
     2360 	      end;
     2361 	   end;
     2362 	return;
     2363 	
     2364 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2365 /*							       */
     2366 /* MATCH SEGS AGAINST -select FILE SPECS:			       */
     2367 /* There are several cases of selection, which are dealt with separately.    */
     2368 /*  1) -select was not specified				       */
     2369 /*       =>  all master segs are matched.			       */
     2370 /*  2) compare_dump_tape -select was given without a SELECT_PATH (an	       */
     2371 /*     obsolete feature implemented for compatibility sake)		       */
     2372 /*       =>  master seg whose path matches copy seg path is "selected";      */
     2373 /*	   other master segs are not matched.			       */
     2374 /*  3) copy_dump_tape -select SELECT_PATH			       */
     2375 /*     compare_dump_tape -select SELECT_PATH			       */
     2376 /*       =>  use specs in SELECT_PATH to determine match status of master    */
     2377 /*	   segs.						       */
     2378 /*							       */
     2379 /* Type 3 selection will be explained below, since it is somewhat complex.   */
     2380 /* If -trace XXX is given, then selected or rejected master seg paths are    */
     2381 /* printed.  The first set of code below sets up that tracing.	       */
     2382 /*							       */
     2383 /* The following selection results are possible:			       */
     2384 /*  SELECTED: master seg path exactly matches path in -select file.	       */
     2385 /*  SELECTED_SUBTREE: master seg path is in the subtree below one of the     */
     2386 /*    paths in the -select file, and subtree selection was specified for     */
     2387 /*    that path.						       */
     2388 /*  SUPERIOR_DIR: master seg is an entry superior in the hierarchy tree to   */
     2389 /*    one of the paths in the -select file.			       */
     2390 /*  REJECTED: master seg path exactly matches a ^path in -select file.       */
     2391 /*  REJECTED_SUBTREE: master seg path is in the subtree below one of the     */
     2392 /*    ^paths in the -select file, subtree selection was specified, and the   */
     2393 /*    master seg did not match a later path in the -select file.  NOTE:      */
     2394 /*    order of paths in -select file is important; they should be sorted by  */
     2395 /*    pathname.						       */
     2396 /*  REJECTED_SUPERIOR_DIR: master seg is an entry superior in the hierarchy  */
     2397 /*    tree to one of the ^paths in the -select file and the master seg did   */
     2398 /*    not match a later path in the -select file.			       */
     2399 /*  UNMATCHED: master seg did not fit one of the criteria above.	       */
     2400 /*							       */
     2401 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2402 
     2403 
     2404     dcl  (UNMATCHED			init(0),
     2405 	SUPERIOR_DIR		init(1),
     2406 	REJECTED_SUPERIOR_DIR	init(2),
     2407 	SELECTED			init(3),
     2408 	REJECTED			init(4),
     2409 	SELECTED_SUBTREE		init(5),
     2410 	REJECTED_SUBTREE		init(6)) fixed bin int static options(constant),
     2411 	STATE_NAME (0:6)		char(16) varying int static options(constant) init(
     2412 				"unmatched",
     2413 				"superior dir",
     2414 				"rejected sup dir",
     2415 				"selected",
     2416 				"rejected",
     2417 				"selected subtree",
     2418 				"rejected subtree");
     2419 
     2420 skip_seg: entry (mbf, cpbf, need_copy) returns(bit(1));
     2421 
     2422     dcl	1 mbf			aligned like inbf,
     2423 	1 cpbf			aligned like inbf,
     2424 	need_copy			bit(1);
     2425 
     2426     dcl	1 seg			aligned,
     2427 	  2 path			char(168) varying,
     2428 	  2 type			fixed bin,
     2429 	  2 state			fixed bin;
     2430 
     2431     dcl	1 cphe_name		aligned like inhe_name based (cpbf.hp),
     2432 	1 mhe			aligned like h based (mbf.hp),
     2433 	1 mhe_name		aligned like inhe_name based (mbf.hp);
     2434 
     2435 	if select.vfile.path ^= "" | 
     2436 	   trace = REJECTS |
     2437 	   trace = operation_now | 
     2438 	   trace = COPY_AND_COMPARE then do;
     2439 	   seg.path = rtrim(pathname_ ((mhe.dname), (mhe.ename)), " >");
     2440 	   if mhe.record_type = LINK then
     2441 	      seg.type = LINK;
     2442 	   else if mhe.record_type = sec_seg |
     2443 		 mhe.record_type = ndc_segment then
     2444 	      seg.type = SEG;
     2445 	   else if mhe.record_type = ndc_directory |
     2446 		 mhe.record_type = ndc_directory_list |
     2447 		 mhe.record_type = sec_dir then
     2448 	      seg.type = DIR;
     2449 	   if seg.type = DIR & mhe.bitcnt > 0 then
     2450 	      seg.type = MSF;
     2451 	   end;
     2452 
     2453 	seg.state = UNMATCHED;			/* assume master */
     2454 						/*  seg unmatched*/
     2455 
     2456 	if select.vfile.path = "" then		/* not selecting */
     2457 	   state = SELECTED;			/*  skip nothing */
     2458 
     2459 	else if select.select_sw then do;		/* -select given */
     2460 						/* without path  */
     2461 	   if need_copy then			/* copy media    */
     2462 	      state = UNMATCHED;			/*  exhausted?   */
     2463 	   else 
     2464 	   if mbf.blrh.hl    = cpbf.blrh.hl &		/* see if two    */
     2465 	      mbf.blrh.segl  = cpbf.blrh.segl &		/*  segs are the */
     2466 	      mhe_name.dname = cphe_name.dname &	/*  same.	       */
     2467 	      mhe_name.ename = cphe_name.ename then
     2468 	      state = SELECTED;
     2469 	   end;
     2470 
     2471 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2472 /*							       */
     2473 /* TYPE 3 SELECTION:					       */
     2474 /* 1) Loop through each -select file pathname specification, comparing it    */
     2475 /*    with the master seg path.				       */
     2476 /* 2) Check master seg path as superior to select file path, equal to it,    */
     2477 /*    or inferior to it.  If any test is true, then apply any ^path criteria */
     2478 /*    for that select file path.				       */
     2479 /* 3) For equal paths, assign the type of the master seg (LINK, SEG, DIR,    */
     2480 /*    MSF) to the select path entry.  If the type = DIR, mark the select     */
     2481 /*    path for subtree selection, since dir select paths are really dir      */
     2482 /*    subtree select paths.					       */
     2483 /* 4) For an MSF in a selected directory which does not have subtree	       */
     2484 /*    specified (now an impossibility because of (3), but I'll leave this    */
     2485 /*    code in anyway), add the MSF dir to the selection list so its	       */
     2486 /*    components will be properly copied.			       */
     2487 /*							       */
     2488 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2489 
     2490 	else do;
     2491 	   do list.x = lbound(list.e,1) to hbound(list.e,1);
     2492 	      if length(seg.path) < length(list.e(list.x).path) &
     2493 	         seg.path = 
     2494 	            substr(list.e(list.x).path,1,
     2495 	                   min(length(list.e(list.x).path),
     2496 		             length(seg.path))) &
     2497 	         seg.type = DIR then
     2498 	         seg.state = SUPERIOR_DIR + list.e(list.x).dont_select;
     2499 	      else if list.e(list.x).path = seg.path then do;
     2500 	         seg.state = SELECTED + list.e(list.x).dont_select;
     2501 	         list.e(list.x).matched = TRUE;
     2502 	         if list.e(list.x).type = UNKNOWN then
     2503 		  list.e(list.x).type = seg.type;
     2504 	         else if list.e(list.x).type = MSF &
     2505 		       mhe.record_type = ndc_directory_list then;
     2506 	         else if list.e(list.x).type ^= seg.type then
     2507 		  call error$fatal (sci_ptr, -1,
     2508 		     "^a: FATAL ERROR: Type Mismatch Discrepancy.
     2509    Path:  ^a
     2510    Master:^23tType ^a
     2511    Select Item(^d):^23tType ^a^[, added as an MSF^].",
     2512 		     hhmmm(), seg.path, TYPE_NAME(seg.type),
     2513 		     list.x, TYPE_NAME(list.e(list.x).type),
     2514 		     list.e(list.x).added_as_msf);
     2515 	         if list.e(list.x).type = DIR then
     2516 		  list.e(list.x).subtree = TRUE;
     2517 	         end;
     2518 	      else if list.e(list.x).path = mhe_name.dname &
     2519 		   (list.e(list.x).type = DIR |
     2520 		    list.e(list.x).type = MSF) &
     2521 		    seg.type ^= DIR then do;
     2522 	         seg.state = SELECTED + list.e(list.x).dont_select;	      
     2523 	         if list.e(list.x).type = DIR &		/* Add MSF to    */
     2524 		 ^list.e(list.x).subtree &		/* list to be    */
     2525 		  list.e(list.x).dont_select=0 &	/* sure all comps*/
     2526 		  seg.type = MSF then		/* get copied.   */
     2527 		  call add_to_select_list (seg.path, MSF, TRUE, TRUE);
     2528 	         end;
     2529 
     2530 
     2531 	      else if length(seg.path) > length(list.e(list.x).path) then
     2532 		 if list.e(list.x).path = 
     2533 		       substr(seg.path,1,length(list.e(list.x).path)) &
     2534 		    list.e(list.x).type = DIR &
     2535 		    list.e(list.x).subtree then
     2536 	         seg.state = SELECTED_SUBTREE + list.e(list.x).dont_select;
     2537 	      end;
     2538 	   end;
     2539 
     2540 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2541 /* 
     2542*/* TRACE SELECTIONS:
     2543*/* Trace the selection mechanism, listing either selected entries, rejected  */
     2544 /* entries or all entries.  The trace entry includes the selection result    */
     2545 /* (one of the STATE_NAME values).				       */
     2546 /*							       */
     2547 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2548 
     2549 	if trace = operation_now then do;
     2550 	   if seg.state = UNMATCHED |
     2551 	      seg.state = REJECTED |
     2552 	      seg.state = REJECTED_SUPERIOR_DIR |
     2553 	      seg.state = REJECTED_SUBTREE then;
     2554 	   else
     2555 	      call ioa_ (" ^va ^[^va^2s^;^2s^va^] ^a",
     2556 	      maxlength(STATE_NAME(1)),  STATE_NAME(seg.state),
     2557 	      seg.type = MSF,
     2558 	      maxlength(RECORD_TYPE(1)), TYPE_NAME(seg.type),
     2559 	      maxlength(RECORD_TYPE(1)), RECORD_TYPE(mhe.record_type),
     2560 	      get_shortest_path_((seg.path)));
     2561 	   end;
     2562 	else if trace = REJECTS then do;
     2563 	   if seg.state = UNMATCHED |
     2564 	      seg.state = REJECTED |
     2565 	      seg.state = REJECTED_SUPERIOR_DIR |
     2566 	      seg.state = REJECTED_SUBTREE then
     2567 	      call ioa_ (" ^va ^[^va^2s^;^2s^va^] ^a",
     2568 	         maxlength(STATE_NAME(1)),  STATE_NAME(seg.state),
     2569 	         seg.type = MSF,
     2570 	         maxlength(RECORD_TYPE(1)), TYPE_NAME(seg.type),
     2571 	         maxlength(RECORD_TYPE(1)), RECORD_TYPE(mhe.record_type),
     2572 	         get_shortest_path_((seg.path)));
     2573 	   end;
     2574 	else if trace = COPY_AND_COMPARE then do;
     2575 	   call ioa_ (" ^va ^[^va^2s^;^2s^va^] ^a",
     2576 	      maxlength(STATE_NAME(1)),  STATE_NAME(seg.state),
     2577 	      seg.type = MSF,
     2578 	      maxlength(RECORD_TYPE(1)), TYPE_NAME(seg.type),
     2579 	      maxlength(RECORD_TYPE(1)), RECORD_TYPE(mhe.record_type),
     2580 	      get_shortest_path_((seg.path)));
     2581 	   end;
     2582 
     2583 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2584 /*							       */
     2585 /* RETURN SELECTION RESULT as a TRUE/FALSE value.			       */
     2586 /*							       */
     2587 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2588 
     2589 	if seg.state = REJECTED_SUPERIOR_DIR | seg.state = REJECTED  |
     2590 	   seg.state = REJECTED_SUBTREE      | seg.state = UNMATCHED   then
     2591 	   return (TRUE);
     2592 	else
     2593 	   return (FALSE);
     2594 
     2595 	end skip_seg$init;
     2596 
     2597 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     2598 
     2599 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2600 /*							       */
     2601 /* TAPE DRIVE MAXIMIZATION:					       */
     2602 /*   -maximize_devices (-maxdv) has two goals: to ensure that all devices    */
     2603 /* available to the process get used equally during a copy/compare	       */
     2604 /* operation; and to ensure that a tape written (copied) on one drive is     */
     2605 /* read (compared) on a different drive.  This involves several operations,  */
     2606 /* that will be described below.				       */
     2607 /*							       */
     2608 /*   The tape_drives structure is the central database for these	       */
     2609 /* operations.  It includes the number of drives reserved/assigned to the    */
     2610 /* process, a round-robin device selector, and event channel for device      */
     2611 /* operations, and for each device: device name, volume name last mounted    */
     2612 /* on the device, track and density specs, assignment rcp_id and a flag      */
     2613 /* indicating whether copy_dump_tape assigned a reserved device to the       */
     2614 /* process.						       */
     2615 /*							       */
     2616 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2617 
     2618        
     2619 
     2620     dcl	1 tape_drives		aligned,
     2621 	  2 count			fixed bin,	/* no devices    */
     2622 	  2 dvx			fixed bin,	/* cur device    */
     2623 	  2 event_wait_list		like event_wait_channel,
     2624 	  2 device (6),
     2625 	    3 name		char(32),
     2626 	    3 vol			char(32),
     2627 	    3 track		fixed bin,
     2628 	    3 density		bit(36),
     2629 	    3 rcp_id		bit(36),
     2630 	    3 assigned_by_us	bit(1) aligned;
     2631 
     2632 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2633 /*							       */
     2634 /* ASSIGN RESERVED TAPE DRIVE:				       */
     2635 /*   This is called to assign a tape drive already reserved to the process.  */
     2636 /*							       */
     2637 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2638 
     2639 
     2640 tape_drive$assign:
     2641        	proc (dx);
     2642 
     2643     dcl	dx			fixed bin;
     2644 
     2645     dcl	code			fixed bin(35),
     2646 	1 ev_info			aligned like event_wait_info,
     2647 	statex			fixed bin,
     2648 	1 ti			aligned like tape_info;
     2649 
     2650 	tape_drives.device(dx).assigned_by_us = FALSE;
     2651 
     2652 	ti.version_num = tape_info_version_3;
     2653 	ti.usage_time = 0;
     2654 	ti.wait_time = 0;
     2655 	ti.system_flag = FALSE;
     2656 	ti.device_name =
     2657 	   substr(tape_drives.device(dx).name,1,length(ti.device_name));
     2658 	ti.model = 0;
     2659 	ti.tracks = 0;
     2660 	ti.density = ""b;
     2661 	ti.speed = ""b;
     2662 	ti.unused_qualifier = ""b;
     2663 	ti.volume_name = "";
     2664 	ti.write_flag = FALSE;
     2665 	ti.position_index = 0;
     2666 	ti.volume_type = 0;
     2667 	ti.volume_density = 0;
     2668 	ti.opr_auth = FALSE;
     2669 
     2670 	call rcp_$assign_device (DEVICE_TYPE(TAPE_DRIVE_DTYPEX), addr(ti),
     2671 	   tape_drives.event_wait_list.channel_id(1), "",
     2672 	   tape_drives.device(dx).rcp_id, code);
     2673 	if code = error_table_$resource_unavailable |
     2674 	   code = error_table_$resource_reserved then;
     2675 	else
     2676 	   call error (sci_ptr, code,
     2677 	      "^/^a: Assigning tape drive ^a.", hhmmm(),
     2678 	      tape_drives.device(dx).name);
     2679 
     2680 ASSIGN_CHECK:
     2681 	call rcp_$check_assign (tape_drives.device(dx).rcp_id,
     2682 	   addr(ti), "", statex, code);
     2683 	go to ASSIGN(statex);
     2684 	
     2685 ASSIGN(0):
     2686 	tape_drives.device(dx).assigned_by_us = TRUE;
     2687 	return;
     2688 	
     2689 ASSIGN(1):
     2690 	call ipc_$block (addr(tape_drives.event_wait_list),
     2691 	   addr(ev_info), code);
     2692 	if code ^= 0 then do;
     2693 	   call convert_ipc_code_ (code);
     2694 	   call error$fatal (sci_ptr, code,
     2695 	      "While blocking for tape_drive$assign.");
     2696 	   end;
     2697 	go to ASSIGN_CHECK;
     2698 	
     2699 ASSIGN(2):					/* long wait.    */
     2700 	return;
     2701 
     2702 ASSIGN(3):					/* fatal error   */
     2703 	call error (sci_ptr, code,
     2704 	   "^/^a: Assigning tape drive ^a.", hhmmm(),
     2705 	   tape_drives.device(dx).name);
     2706 	return;
     2707 
     2708 	end tape_drive$assign;
     2709 
     2710 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     2711 
     2712 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2713 /*							       */
     2714 /* VOLUME MOUNTED ON TAPE DRIVE:				       */
     2715 /*   This finds out which device a given tape volume was actually mounted    */
     2716 /* upon.  Prior to availability of "tape_mult_ VOL -device DEV", there was   */
     2717 /* no way to tell RCP which device to mount the tape on.  Even with the -dv  */
     2718 /* attach arg, there is no absolute assurance.  So this procedure surveys    */
     2719 /* RCP data to find out which device it was actually mounted on.	       */
     2720 /*							       */
     2721 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2722 
     2723 
     2724 tape_drive$find_device:
     2725        	proc (vol);
     2726 
     2727     dcl	1 vol			aligned like in_out.vol;
     2728 
     2729     dcl	code			fixed bin(35),
     2730          (da, dx)			fixed bin;
     2731 
     2732 	vol.device = "";
     2733 	if tape_drives.count = 0 then return;
     2734 	call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
     2735 	do da = 1 to rli.head.num_attach while (vol.device="");
     2736 	   attach_ptr = addr(rli.attaches(da));
     2737 	   if attach.dtypex = TAPE_DRIVE_DTYPEX then
     2738 	   if vol.name =   attach.volume_name then do;
     2739 	      vol.device = attach.device_name;
     2740 	      do dx = 1 to tape_drives.count 
     2741 	         while (tape_drives.device(dx).name ^= attach.device_name);
     2742 	         end;
     2743 	      if dx <= tape_drives.count then
     2744 	         tape_drives.device(dx).vol = vol.name;
     2745 	      end;
     2746 	   end;
     2747 	return;
     2748 
     2749 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2750 /*							       */
     2751 /* SELECT A TAPE DRIVE:					       */
     2752 /*   This procedure selects a drive on which to mount a given volume.  If    */
     2753 /* the volume was mounted before during copying, then		       */
     2754 /* $select_another_device is called to select a different device during      */
     2755 /* comparing.  Otherwise, $select_a_device is called to select a device on   */
     2756 /* a round-robin basis.					       */
     2757 /*							       */
     2758 /* Selection is done by:					       */
     2759 /* 1) Surveying attached devices to see which devices are already occupied   */
     2760 /*    for mounts.						       */
     2761 /* 2) Scanning the remaining devices (round-robin) to find one with	       */
     2762 /*    compatible track/density attributes.			       */
     2763 /*							       */
     2764 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2765 
     2766 
     2767 tape_drive$select_another_device:
     2768 	entry (io);
     2769 
     2770     dcl	1 io			aligned like input;
     2771 
     2772     dcl	densityx			fixed bin,
     2773 	selected_dx		fixed bin,
     2774 	unwanted_device		char(32);
     2775 
     2776 	unwanted_device = io.vol(io.tape.volx).device;
     2777 	go to SELECT_JOIN;
     2778 	
     2779 tape_drive$select_a_device:
     2780 	entry (io);
     2781 
     2782 	unwanted_device = "~";
     2783 	go to SELECT_JOIN;
     2784 	
     2785 SELECT_JOIN:
     2786 	if tape_drives.count = 0 then return;
     2787 	call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
     2788 
     2789 	tape_drives.device(*).vol = "";
     2790 	do da = 1 to rli.head.num_attach;
     2791 	   attach_ptr = addr(rli.attaches(da));
     2792 	   if attach.dtypex = TAPE_DRIVE_DTYPEX then do;
     2793 	      do dx = 1 to tape_drives.count 
     2794 	         while (tape_drives.device(dx).name ^= attach.device_name);
     2795 	         end;
     2796 	      if dx <= tape_drives.count then
     2797 	         tape_drives.device(dx).vol = attach.volume_name;
     2798 	      end;
     2799 	   end;
     2800 	
     2801 	if io.tape.density = 800 then
     2802 	   densityx = 3;
     2803 	else if io.tape.density = 1600 then
     2804 	   densityx = 4;
     2805 	else if io.tape.density = 6250 then
     2806 	   densityx = 5;
     2807 	else densityx = 4;
     2808 
     2809 	tape_drives.dvx = mod(tape_drives.dvx+1, tape_drives.count);
     2810 						/* start point   */
     2811 	
     2812 	selected_dx = 0;
     2813 	do dx = tape_drives.dvx+1 to tape_drives.count
     2814 	          while (selected_dx = 0),
     2815 	        1 to tape_drives.dvx
     2816 	          while (selected_dx = 0);
     2817 	   if tape_drives.device(dx).name = unwanted_device |
     2818 	      tape_drives.device(dx).vol ^= "" |
     2819 	      tape_drives.device(dx).track ^= io.tape.track |
     2820 	      ^substr(tape_drives.device(dx).density, densityx, 1) then;
     2821 	   else selected_dx = dx;
     2822 	   end;
     2823 
     2824 	if selected_dx ^= 0 then 
     2825 	   io.vol(io.tape.volx).device =
     2826 	      tape_drives.device(selected_dx).name;
     2827 	return;
     2828 	
     2829 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2830 /*							       */
     2831 /* SURVEY TAPE DRIVES:					       */
     2832 /*  This procedure finds out which drives are reserved or assigned to the    */
     2833 /*  process.						       */
     2834 /* 1) Those just reserved to the process get assigned to it, so	       */
     2835 /*    their track/density attributes become known (the attributes are not    */
     2836 /*    listed in the device_resvs structure).			       */
     2837 /* 2) Then all assigned devices are recorded in the tape_drives structure.   */
     2838 /* 3) Finally, the user is told which devices are available for use.	       */
     2839 /*							       */
     2840 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2841 
     2842 
     2843 tape_drive$survey:
     2844 	entry;
     2845 
     2846 	if ^maximize_devices_sw then return;
     2847 
     2848 	tape_drives.count = 0;
     2849 	tape_drives.dvx = -1;
     2850 	tape_drives.device.name = "";
     2851 	tape_drives.device.vol = "";
     2852 	tape_drives.device.track = 0;
     2853 	tape_drives.device.density = ""b;
     2854 	tape_drives.device.rcp_id = ""b;
     2855 	tape_drives.device.assigned_by_us = FALSE;
     2856 
     2857 	call ipc_$create_ev_chn (tape_drives.event_wait_list.channel_id(1), code);
     2858 	call error$fatal (sci_ptr, code, "Creating an event wait channel.");
     2859 	tape_drives.event_wait_list.n_channels = 1;
     2860 
     2861 	call ssu_$get_temp_segment (sci_ptr, "tape survey", rli_ptr);
     2862 	rli.head.version_num = rli_version_4;
     2863 	call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
     2864 	call error (sci_ptr, code, "Getting tape survey data.");
     2865 	if code ^= 0 then return;
     2866 
     2867 	do da = 1 to rli.head.num_device_resv;
     2868 	   device_resv_ptr = addr(rli.device_resvs(da));
     2869 	   if substr(device_resv.device_name,1,length("tap")) = "tap" then do;
     2870 	      if tape_drives.count < hbound(tape_drives.device,1) then do;
     2871 	         tape_drives.count, dx = tape_drives.count + 1;
     2872 	         tape_drives.device(dx).name = device_resv.device_name;
     2873 	         end;
     2874 	      end;
     2875 	   end;
     2876 
     2877 	if tape_drives.count > 0 then do;		/* assign resv   */
     2878 	   do dx = 1 to tape_drives.count;		/*  devs to get  */
     2879 						/*  attributes   */
     2880 	      do da = 1 to rli.head.num_dassign
     2881 	        while (rli.dassigns(da).device_name ^= 
     2882 		     tape_drives.device(dx).name);
     2883 	         end;
     2884 	      if da > rli.head.num_dassign then		/* not already   */
     2885 	         call tape_drive$assign (dx);		/*  assigned?    */
     2886 	      end;				/*  I'll do it.  */
     2887 	   call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
     2888 	   end;					/* new rcp info  */
     2889 
     2890 	do da = 1 to rli.head.num_dassign;		/* fill in       */
     2891 	   dassign_ptr = addr(rli.dassigns(da));	/*  tape_drives  */
     2892 	   if dassign.dtypex = TAPE_DRIVE_DTYPEX then do; /*  for assigned */
     2893 	      do dx = 1 to tape_drives.count		/*  drives.      */
     2894 	        while (tape_drives.device(dx).name ^= dassign.device_name);
     2895 	         end;
     2896 	      if dx >  tape_drives.count &
     2897 	         dx <= hbound(tape_drives.device,1) then
     2898 	         tape_drives.count = dx;
     2899 	      if tape_drives.count >= dx then do;
     2900 	         tape_drives.device(dx).name = dassign.device_name;
     2901 	         tape_drives.device(dx).track = dassign.qualifiers(1);
     2902 	         tape_drives.device(dx).density =
     2903 		  unspec(dassign.qualifiers(2));
     2904 	         end;
     2905 	      end;
     2906 	   end;
     2907 
     2908 	call ioa_("");
     2909 	if tape_drives.count > 0 then
     2910 	   call ssu_$print_message (sci_ptr, 0,
     2911 	      "^a: ^d tape drive^[s^] assigned to process:^/ ^v( ^a^)",
     2912 	      hhmmm(), tape_drives.count, tape_drives.count^=1,
     2913 	      tape_drives.count, tape_drives.device.name);
     2914 	else
     2915 	   call error (sci_ptr, -1,
     2916 	      "No tape drives are currently assigned to or reserved for
     2917 the process.  The -maximize_devices operation will not occur.");
     2918 	return;
     2919 
  1     1 /*	Begin  include file ... rcp_list_info.incl.pl1
  1     2*   *
  1     3*   *	Created on 01/29/75 by Bill Silver.
  1     4*   *	Changed on 04/02/76 by Bill Silver to add lv entries.
  1     5*   *	Modified on 12/09/78 by Michael R. Jordan to add reservation information (version 3).
  1     6*   *	Modified 8/81 by M.R. Jordan to expand reservation information (version 4).
  1     7*   *	This include file defines arrays of entries that contain information
  1     8*   *	about the resources that a process has assigned and attached.
  1     9**/
  1    10 dcl  rli_ptr ptr;					/* Pointer to base of RCP list structure. */
  1    11 dcl  dassign_ptr ptr;				/* Pointer to a device assignment entry. */
  1    12 dcl  attach_ptr ptr;				/* Pointer to an attachment entry. */
  1    13 dcl  lv_ptr ptr;					/* Pointer to an lv entry. */
  1    14 dcl  device_resv_ptr ptr;				/* Pointer to a device reservation entry. */
  1    15 dcl  vol_resv_ptr ptr;				/* Pointer to a volume reservation entry. */
  1    16 
  1    17 dcl  rli_version_4 fixed bin internal static init (4);
  1    18 
  1    19 dcl 1 rli based (rli_ptr) aligned,			/* Base of RCP list structure. */
  1    20     2 head like rli_header,				/* header of structure. */
  1    21     2 dassigns (0 refer (rli.head.num_dassign))
  1    22      like dassign,					/* An array of device assignment entries. */
  1    23     2 attaches (0 refer (rli.head.num_attach))
  1    24      like attach,					/* An array of attachment entries. */
  1    25     2 lvs (0 refer (rli.head.num_lv))
  1    26      like lv,					/* An array of lv attachment entries. */
  1    27     2 device_resvs (0 refer (rli.head.num_device_resv))
  1    28      like device_resv,
  1    29     2 vol_resvs (0 refer (rli.head.num_vol_resv))
  1    30      like vol_resv,
  1    31     2 end bit (36);					/* Dummy used to reference end of structure. */
  1    32 
  1    33 dcl 1 rli_header based aligned,			/* Header of RCP list info structure. */
  1    34     2 version_num fixed bin,				/* Current version number.  Now = 1. */
  1    35     2 num_lv fixed bin,				/* Number of lv attachment entries. */
  1    36     2 num_dassign fixed bin,				/* Number of device assignment entries. */
  1    37     2 num_attach fixed bin,				/* Number of attachment entries. */
  1    38     2 num_device_resv fixed bin,			/* Number of devices reserved. */
  1    39     2 num_vol_resv fixed bin;				/* Number of volumes reserved. */
  1    40 
  1    41 dcl 1 dassign based (dassign_ptr) aligned,		/* Structure of a device assignment entry. */
  1    42     2 device_name char (8),				/* Device name. */
  1    43     2 dtypex fixed bin,				/* Device type index. */
  1    44     2 model fixed bin,				/* Device model number. */
  1    45     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  1    46     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  1    47     2 state_time fixed bin (71),			/* Time assignment put into current state. */
  1    48     2 state fixed bin,				/* Current state of assignment. */
  1    49     2 level fixed bin,				/* Current validation level. */
  1    50     2 disposition bit (36),				/* Disposition of assignment. */
  1    51     2 flags,
  1    52      (3 attached bit (1)) unaligned,			/* ON => device is attached. */
  1    53     2 rcp_id bit (36),				/* RCP ID for this assignment. */
  1    54     2 usage_time fixed bin,				/* Number of minutes device may be assigned. */
  1    55     2 wait_time fixed bin;				/* Number of minutes user must wait for assignment. */
  1    56 
  1    57 dcl 1 attach based (attach_ptr) aligned,		/* Structure of an attachment entry. */
  1    58     2 device_name char (8),				/* Name of attached device. */
  1    59     2 volume_name char (32),				/* Name of attached volume. */
  1    60     2 dtypex fixed bin,				/* Device type index. */
  1    61     2 state_time fixed bin (71),			/* Time attachment put into current state. */
  1    62     2 state fixed bin,				/* Current state of this attachment. */
  1    63     2 level fixed bin,				/* Current validation level. */
  1    64     2 flags,					/* Info flags. */
  1    65      (3 priv bit (1),				/* ON => attached with privilege. */
  1    66       3 writing bit (1)) unal,			/* ON => attached for writing. */
  1    67     2 rcp_id bit (36),				/* RCP ID for this attachment. */
  1    68     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  1    69     2 timeout_max fixed bin (52),			/* Max IOI time-out interval. */
  1    70     2 ioi_index fixed bin,				/* Index used to communicate with IOI. */
  1    71     2 usage_time fixed bin,				/* Number of minutes device may be attached. */
  1    72     2 wait_time fixed bin;				/* Number of minutes user must wait for attachment. */
  1    73 
  1    74 dcl 1 lv based (lv_ptr) aligned,			/* Structure of an LV entry. */
  1    75     2 volume_name char (32),				/* Logical volume name. */
  1    76     2 state_time fixed bin (71),			/* Time lv attached for process. */
  1    77     2 rcp_id bit (36);				/* RCP ID for this lv attachment. */
  1    78 
  1    79 dcl 1 device_resv based (device_resv_ptr) aligned,	/* Structure of a device reservation. */
  1    80     2 reservation_id fixed bin (71),
  1    81     2 reserved_by char (32),
  1    82     2 dtypex fixed bin,
  1    83     2 device_name char (8);
  1    84 
  1    85 dcl 1 vol_resv based (vol_resv_ptr) aligned,		/* Structure of a volume reservation. */
  1    86     2 reservation_id fixed bin (71),
  1    87     2 reserved_by char (32),
  1    88     2 vtypex fixed bin,
  1    89     2 volume_name char (32);
  1    90 
  1    91 /*	End of include file ... rcp_list_info.incl.pl1	*/
     2920 
     2921 
     2922 	end tape_drive$find_device;
     2923 
     2924 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     2925 
     2926 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2927 /*							       */
     2928 /* TAPE DRIVE INITIALIZATION:					       */
     2929 /*   Initialize the tape_drives structure.			       */
     2930 /*							       */
     2931 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2932 
     2933 tape_drive$init:
     2934 	proc;
     2935 
     2936 	tape_drives.count = 0;
     2937 	tape_drives.dvx = -1;
     2938 	tape_drives.event_wait_list.channel_id = -1;
     2939 	tape_drives.device(*).name, tape_drives.device(*).vol = "";
     2940 	tape_drives.device(*).track = 0;
     2941 	tape_drives.device(*).density, tape_drives.device(*).rcp_id,
     2942 	   tape_drives.device(*).assigned_by_us = ""b;
     2943 
     2944 	end tape_drive$init;
     2945 
     2946 
     2947 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2948 /*							       */
     2949 /* TAPE DRIVE TERMINATION:					       */
     2950 /* 1) Unassigned reserved devices assigned by us.			       */
     2951 /* 2) Delete the event channel used for RCP operations.		       */
     2952 /*							       */
     2953 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2954 
     2955 
     2956 tape_drive$term:
     2957 	proc;
     2958 
     2959     dcl	code			fixed bin(35),
     2960 	dx			fixed bin;
     2961 
     2962 	do dx = 1 to tape_drives.count;
     2963 	   if tape_drives.device(dx).assigned_by_us then
     2964 	      call tape_drive$unassign (dx);
     2965 	   end;
     2966 
     2967 	if tape_drives.event_wait_list.channel_id(1) ^= -1 then
     2968 	   call ipc_$delete_ev_chn (tape_drives.event_wait_list.channel_id(1), code);
     2969 	end tape_drive$term;
     2970 
     2971 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     2972 
     2973 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2974 /*							       */
     2975 /* TAPE DRIVE UNASSIGN:					       */
     2976 /*   Unassign a tape drive assigned by copy_dump_tape.		       */
     2977 /*							       */
     2978 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2979 
     2980 
     2981 tape_drive$unassign:
     2982        	proc (dx);
     2983 
     2984     dcl	dx			fixed bin;
     2985     dcl	code			fixed bin(35);
     2986 
     2987 	call rcp_$unassign (tape_drives.device(dx).rcp_id, ""b, "", code);
     2988 	call error (sci_ptr, code,
     2989 	   "^/^a: Unassigning tape drive ^a.", hhmmm(),
     2990 	   tape_drives.device(dx).name);
     2991 	tape_drives.device(dx).assigned_by_us = FALSE;
     2992 
     2993 	end tape_drive$unassign;
     2994 
     2995 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     2996 
     2997 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     2998 /*							       */
     2999 /* WRITE BACKUP LOGICAL RECORD HEADER and SEGMENT:		       */
     3000 /* 1) Decide whether output is to vfile_ or tape.			       */
     3001 /* 2) If to vfile, write out blrh sizes, the segment attributes in the       */
     3002 /*    remainder of blrh, and the segment contents.		       */
     3003 /* 3) If to tape, write out the blrh with segment attributes, and the	       */
     3004 /*    segment contents.  The blrh and contents must each be written as a     */
     3005 /*    group of 256 word blocks, so that blrh's begin on a 256-char tape      */
     3006 /*    record boundary.  After brlh/contents are written, do an error_count   */
     3007 /*    control request to synchronize output, forcing any unwritten tape      */
     3008 /*    buffers onto tape to ensure the segment actually gets written to       */
     3009 /*    tape.						       */
     3010 /* 4) When end-of-volume is found on one output tape, switch to the next     */
     3011 /*    tape and rewrite entire blrh/contents on new tape.		       */
     3012 /* 5) Both types return TRUE if the segment is successfully written, FALSE   */
     3013 /*    if it isn't.						       */
     3014 /*							       */
     3015 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     3016 
     3017 write_seg:	proc (bf, out) returns(bit(1));
     3018 
     3019     dcl	1 bf			aligned like inbf,
     3020 	1 he			aligned like h based (bf.hp),
     3021 	1 out			aligned like output;
     3022 
     3023     dcl	count			fixed bin(21);
     3024 
     3025     dcl   1 blrh			aligned like inbf.blrh based,
     3026 	1 blrh_sizes		aligned like inbf.blrh.sizes based,
     3027 	writel			fixed bin(21);
     3028 
     3029     dcl   size			builtin;
     3030 
     3031 	if out.vfile.path ^= "" then do;		/* write file    */
     3032 	   call iox_$put_chars (out.iocbp, addr(bf.blrh.sizes),
     3033 	      size(blrh_sizes) * CHARS_PER_WORD, code);
     3034 	   if code = 0 then do;
     3035 	      call iox_$put_chars (out.iocbp, addr(he),
     3036 	         bf.blrh.hl * CHARS_PER_WORD, code);
     3037 	      if code = 0 then do;
     3038 	         if bf.blrh.segl > 0 then do;
     3039 		  call iox_$put_chars (out.iocbp, bf.segp,
     3040 		     bf.blrh.segl * CHARS_PER_WORD, code);
     3041 		  if code = 0 then do;
     3042 		     out.recx = out.recx + 1;
     3043 		     return (TRUE);
     3044 		     end;
     3045 		  end;
     3046 	         else do;
     3047 		  out.recx = out.recx + 1;
     3048 		  return (TRUE);
     3049 		  end;
     3050 	         end;
     3051 	      end;
     3052 
     3053 	   if code = error_table_$end_of_info then
     3054 	      return (FALSE);
     3055 	   else
     3056 	      call error$fatal (sci_ptr, code,
     3057 	         "^/^a: FATAL ERROR: Writing ^a file ^a, record ^d.",
     3058 	         hhmmm(), out.header.name, out.vfile.expath, out.recx+1);
     3059 	   end;
     3060 
     3061 	else if out.tape.voln > 0 then do;		/* write tape    */
     3062 REWRITE:	   call iox_$put_chars (out.iocbp, addr(bf.blrh),
     3063 	      size(blrh) * CHARS_PER_WORD, code);
     3064 	   if code = 0 then do;
     3065 
     3066 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     3067 /*							       */
     3068 /* blrh + he, and seg are written in 256-word blocks, so we must round up    */
     3069 /* the amount we write to the next 256-word boundary.  At this point,	       */
     3070 /* blrh-words have already been written.			       */
     3071 /*							       */
     3072 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     3073 
     3074 	      writel = bf.blrh.hl + size(blrh) + BLOCK_SIZE - 1;
     3075 	      writel = writel - mod(writel, BLOCK_SIZE) - size(blrh);
     3076 	      call iox_$put_chars (out.iocbp, addr(he),
     3077 	         writel * CHARS_PER_WORD, code);
     3078 	      if code = 0 then do;
     3079 	         if bf.blrh.segl > 0 then do;
     3080 		  writel = bf.blrh.segl + BLOCK_SIZE - 1;
     3081 		  writel = writel - mod(writel, BLOCK_SIZE);
     3082 		  call iox_$put_chars (out.iocbp, bf.segp,
     3083 		     writel * CHARS_PER_WORD, code);
     3084 		  end;
     3085 	         end;
     3086 	      end;
     3087 	   if code = 0 then do;
     3088 	      call iox_$control (out.iocbp, "error_count", addr(count),
     3089 	         code);
     3090 	      if code = 0 then do;
     3091 	         out.recx = out.recx + 1;
     3092 	         return (TRUE);
     3093 	         end;
     3094 	      end;
     3095 	   if code = error_table_$end_of_info | 
     3096 	      code = error_table_$device_end  then do;
     3097 	      if mount_next_tape_vol (out) then do;
     3098 	         call map_seg$new_tape (out);
     3099 	         go to REWRITE;
     3100 	         end;
     3101 	      else
     3102 	         return (FALSE);
     3103 	      end;
     3104 	   else
     3105 	      call error$fatal (sci_ptr, code,
     3106 	         "^/^a: FATAL ERROR: Writing ^a tape ^a, record ^d.",
     3107 	         hhmmm(), out.header.name,
     3108 	         out.vol(out.tape.volx).name, out.recx+1);
     3109 	   end;
     3110 
     3111 	else do;					/* discard out   */
     3112 	   out.recx = out.recx + 1;
     3113 	   return (TRUE);
     3114 	   end;
     3115 	end write_seg;
     3116 
     3117 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     3118 
  2     1 /* include backup_dir_list */
  2     2 /* Created by R H Campbell. */
  2     3 /* Modified 15 June 1970, R H Campbell, 30 March l971, R A Tilden. */
  2     4 /* Last modified by Kobziar 2/10/75 to add access_class */
  2     5 /* Last modified by Greenberg 11/4/76 for vtoc_error bit */
  2     6 dcl 1 br (1000) based aligned,			/* branch array returned by list_dir */
  2     7     2 (vtoc_error bit (1),				/* Vtoc error on this entry */
  2     8      pad1 bit (1), uid bit (70),
  2     9      pad2 bit (20), dtu bit (52),
  2    10      pad3 bit (20), dtm bit (52),
  2    11      pad4 bit (20), dtd bit (52),
  2    12      pad5 bit (20), dtbm bit (52),
  2    13      access_class bit (72),
  2    14      dirsw bit (1), optionsw bit (2), bc bit (24), consistsw bit (2), mode bit (5), usage bit (2),
  2    15      usagect bit (17), nomore bit (1), (cl, ml) bit (9),
  2    16      acct bit (36),
  2    17     (hlim, llim) bit (17),
  2    18      multiple_class bit (1), pad7 bit (1),
  2    19     (rb1, rb2, rb3) bit (6), pad8 bit (18),
  2    20     (pad9, namerp) bit (18),
  2    21      ix bit (18), dump_me bit (1), nnames bit (17)) unaligned;  /* ix is pointer to i'th (sorted) entry. */
  2    22 
  2    23 dcl  nnames fixed bin;				/* Number of elements in name array. */
  2    24 
  2    25 dcl 1 name (1000 /* nnames */) based aligned,
  2    26     2 size bit (17),
  2    27     2 string character (32);
  2    28 
  2    29 dcl 1 lk (1) based aligned,				/* link array returned by list_dir */
  2    30     2 (pad1 bit (2), uid bit (70),
  2    31      pad2 bit (20), dtu bit (52),
  2    32      pad3 bit (20), dtm bit (52),
  2    33      pad4 bit (20), dtd bit (52),
  2    34     (pathnamerp, namerp) bit (18),
  2    35      ix bit (18), dump_me bit (1), nnames bit (17)) unaligned;  /* ix is pointer to i'th (sorted) entry. */
  2    36 
  2    37 dcl 1 path based (pp) aligned, 			/* path name structure from list_dir (one per link) */
  2    38     2 size bit (17),
  2    39     2 author character(32),				/* author of link, and */
  2    40     2 name character (168);				/* path name. */
  2    41 
  2    42 dcl 1 old_path based (pp) aligned,			/* path name as it existed prior to inclusion of author */
  2    43     2 size bit (17),
  2    44     2 name character (168);
  2    45 						/* end backup_dir_list */
     3119 
     3120  
     3121     dcl	pp			ptr;
     3122 
  3     1 
  3     2 /* Begin include file ... backup_preamble_header.incl.pl1 */
  3     3 /* Modified 1/29/73 by N. I. Morris */
  3     4 /* Modified 7/15/74 by R. E. Mullen */
  3     5 /* Modified 10/10/74 by A. Kobziar */
  3     6 
  3     7 dcl 1 h based aligned,				/* backup preamble (segment header) */
  3     8 
  3     9     2 dlen fixed binary,
  3    10     2 dname character (168),
  3    11     2 elen fixed binary,
  3    12     2 ename character (32),
  3    13     2 bitcnt fixed binary (24),
  3    14     2 record_type fixed binary,			/* Logical record type. */
  3    15     2 dtd fixed binary (52),				/* Date and time dump occurred. */
  3    16     2 dumper_id character (32),			/* Identification of dumper procedure. */
  3    17 
  3    18     2 bp bit (18),					/* Pointer to branches. */
  3    19     2 bc fixed binary,				/* Branch count. */
  3    20     2 lp bit (18),					/* Pointer to links. */
  3    21     2 lc fixed binary,				/* Link count. */
  3    22     2 aclp bit (18),				/* Pointer to ACL or CACL */
  3    23     2 aclc fixed binary,				/* ACL count. */
  3    24     2 actind bit (18),				/* File activity indicator */
  3    25     2 actime bit (36),				/* File activity time */
  3    26 
  3    27     2 quota fixed binary,				/* Record quota for directory_list record. */
  3    28     2 trp fixed binary (35),				/* Time-record product .. */
  3    29     2 tlu fixed binary (35),				/* Time last updated .. */
  3    30     2 inf_acct fixed binary,				/* Inferior account switch .. */
  3    31     2 term_acct fixed binary (1),			/* Terminal account switch .. */
  3    32     2 pad1 (3),					/* To even out area to 0 mod 8 */
  3    33 
  3    34     2 max_length fixed bin (18),			/* Max. length of segment */
  3    35     2 switches unal,
  3    36       3 safety_sw bit (1) unal,			/* Segment safety switch */
  3    37       3 entrypt_sw bit (1) unal,			/* "1"b -> call limiter enabled */
  3    38       3 security_oosw bit(1) unal,			/* security out-of-service */
  3    39       3 audit_flag bit(1) unal,			/* flag for seg reference auditing */
  3    40       3 multiple_class bit (1) unal,			/* system segment: access class may be higher than parent's */
  3    41       3 pad2 bit(2) unal,				/* =pad2 in dir_entry */
  3    42       3 master_dir bit (1) unal,			/* "1"b => was master dir */
  3    43       3 tpd bit (1) unal,				/* TRUE => never put on paging device */
  3    44       3 sw_pad bit (13) unal,				/* padding in this structure */
  3    45     2 entrypt_bound bit (14) unal,			/* Call limiter. */
  3    46     2 access_class bit(72),				/* access class of entry */
  3    47     2 spad bit(36),					/* last word of dir entry */
  3    48     2 status_version fixed bin,			/* version of status_for_backup struct */
  3    49     2 nss_info_relp bit (18) aligned,			/* NONZERO => NSS INFO */
  3    50     2 dq_info_relp bit (18) aligned,				/* NONZERO => DIRQUOTA INFO */
  3    51 
  3    52     2 inaclp (0:7) bit (18),				/* Pointer to initial ACL for each ring. */
  3    53     2 inaclc (0:7) fixed bin,				/* Initial ACL count for each ring. */
  3    54     2 dir_inaclp (0:7) bit (18),			/* Directory initial ACL pointer for each ring. */
  3    55     2 dir_inaclc (0:7) fixed bin,			/* Directory initial ACL count for each ring. */
  3    56 
  3    57     2 bitcount_author char (32),			/* last modifier of the bit count */
  3    58 
  3    59     2 list_area /* area */ (65408);			/* Area for list_dir and readacl. */
  3    60 
  3    61 dcl  author char (32) aligned based;			/* Author of entry */
  3    62 						/* N. B.  Author is an overlay starting at h.quota */
  3    63 
  3    64 /* End of include file ... backup_preamble_header.incl.pl1 */
  3    65 
     3123 
     3124 
  4     1 /*  BEGIN:   backup_record_types.incl.pl1		  *  *  *  *  *  */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(87-01-05,GDixon), approve(87-04-15,MCR7617),
  4     6*     audit(87-06-22,RBarstad), install(87-07-15,MR12.1-1040):
  4     7*     Converted internal static variables to named constants.  Renamed
  4     8*     record_type array to RECORD_TYPE, to avoid naming conflict with
  4     9*     backup_preamble_header.incl.pl1's h.record_type variable.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Created June 1970, R H Campbell. */
  4    14 /* Modified 1/16/73 by N. I. Morris	*/
  4    15 /* Modified 7/17/75 by R. Bratt */
  4    16 /* Modified 11/04/83 by G. Dixon - better comments */
  4    17 
  4    18 dcl  ndc_segment fixed binary int static options(constant) initial (1);
  4    19 						/* Record of segment with NDC attributes */
  4    20 dcl  ndc_directory fixed binary int static options(constant) initial (2);
  4    21 						/* Record of directory with NDC attributes */
  4    22 dcl  ndc_directory_list fixed binary int static options(constant) initial (3);
  4    23 						/* Record of directory list with initial ACL */
  4    24 dcl  sec_seg fixed binary int static options(constant) initial(19);
  4    25 						/* Seg with security & call_limiter */
  4    26 dcl  sec_dir fixed binary int static options(constant) initial(20);
  4    27 						/* Dir with security & call_limiter */
  4    28 
  4    29 dcl  RECORD_TYPE (0: 20) character (10) aligned		/* Name of the record types. */
  4    30      int static options(constant)
  4    31      initial (*, "NDC seg", "NDC dir", "NDC dirlst", *, *, *, *,
  4    32 	    *, *, *, *, *, *, *, *,
  4    33 	    *, *, *, "SEG", "DIR");
  4    34 
  4    35 /* The following is an excerpt from a backup map showing the relationship
  4    36*   between entries in the backup map and the named constants given above.
  4    37*   I don't know under what conditions the ndc_seg and ndc_dir named constants
  4    38*   are ever used.  (G. Dixon)
  4    39*
  4    40*			        Map Excerpt
  4    41*   		 ---------------------------------------------
  4    42*Named Constant       ENTRY NAME                   BLOCKS REC_TYPE  
  4    43*
  4    44*sec_dir		 >library_dir_dir>system_library_unbundled
  4    45*		  object			     0 directory 
  4    46*			 o
  4    47*sec_dir		  source			     0 directory
  4    48*		           s
  4    49*
  4    50*ndc_directory_list	 >library_dir_dir>system_library_unbundled>object
  4    51*				               0 directory 
  4    52*sec_seg		  bound_gcos_tss_.1.archive	   104 segment   
  4    53*
  4    54*
  4    55*ndc_directory_list   >library_dir_dir>system_library_unbundled>source
  4    56*				               0 directory
  4    57*sec_seg               bound_gcos_tss_.1.s.archive	   134 segment
  4    58*
  4    59*
  4    60*						          */
  4    61 
  4    62 
  4    63 /*  END OF:  backup_record_types.incl.pl1		  *  *  *  *  *  */
     3125 
     3126 
  5     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
  5     2 
  5     3 /* ipc_$block wait list with one channel
  5     4*
  5     5*   Written 9-May-79 by M. N. Davidoff.
  5     6**/
  5     7 
  5     8      declare 1 event_wait_channel   aligned,
  5     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
  5    10 	     2 pad	      bit (36),
  5    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
  5    12 
  5    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
     3127 
     3128 
  6     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
  6     2 
  6     3 /* T. Casey, May 1978 */
  6     4 
  6     5 dcl  event_wait_info_ptr ptr;
  6     6 
  6     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
  6     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
  6     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
  6    10     2 sender bit (36),				/* process id of sender */
  6    11     2 origin,
  6    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
  6    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
  6    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
  6    15 
  6    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
     3129 
     3130 
  7     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  7     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  7     3*      version number to IOX2. */
  7     4 /* format: style2 */
  7     5 
  7     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  7     7 	     2 version	      character (4) aligned,	/* IOX2 */
  7     8 	     2 name	      char (32),		/* I/O name of this block. */
  7     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  7    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  7    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  7    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  7    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  7    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  7    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  7    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  7    17 						/* open(p,mode,not_used,s) */
  7    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  7    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  7    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  7    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    24 						/* put_chars(p,bufptr,buflen,s) */
  7    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  7    26 						/* modes(p,newmode,oldmode,s) */
  7    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  7    28 						/* position(p,u1,u2,s) */
  7    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  7    30 						/* control(p,order,infptr,s) */
  7    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  7    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    34 						/* write_record(p,bufptr,buflen,s) */
  7    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  7    36 						/* rewrite_record(p,bufptr,buflen,s) */
  7    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  7    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    39 						/* seek_key(p,key,len,s) */
  7    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    41 						/* read_key(p,key,len,s) */
  7    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  7    43 						/* read_length(p,len,s) */
  7    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  7    45 						/* open_file(p,mode,desc,not_used,s) */
  7    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  7    47 						/* close_file(p,desc,s) */
  7    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  7    49 						/* detach(p,desc,s) */
  7    50 
  7    51      declare iox_$iocb_version_sentinel
  7    52 			      character (4) aligned external static;
  7    53 
  7    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     3131 
     3132 
  8     1 /* Begin include file ..... iox_modes.incl.pl1 */
  8     2 
  8     3 /* Written by C. D. Tavares, 03/17/75 */
  8     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  8     5 
  8     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  8     7     ("stream_input", "stream_output", "stream_input_output",
  8     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  8     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  8    10      "direct_input", "direct_output", "direct_update");
  8    11 
  8    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  8    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  8    14 
  8    15 dcl (Stream_input initial (1),
  8    16      Stream_output initial (2),
  8    17      Stream_input_output initial (3),
  8    18      Sequential_input initial (4),
  8    19      Sequential_output initial (5),
  8    20      Sequential_input_output initial (6),
  8    21      Sequential_update initial (7),
  8    22      Keyed_sequential_input initial (8),
  8    23      Keyed_sequential_output initial (9),
  8    24      Keyed_sequential_update initial (10),
  8    25      Direct_input initial (11),
  8    26      Direct_output initial (12),
  8    27      Direct_update initial (13)) fixed bin int static options (constant);
  8    28 
  8    29 /* End include file ..... iox_modes.incl.pl1 */
     3133 
     3134 
  9     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  9     2*   *
  9     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  9     4*   *
  9     5*   *	This include file defines the official RCP resource types.
  9     6*   *	The array of names is indexed by the corresponding device type.
  9     7*   *      MOD by RAF for MCA
  9     8**/
  9     9 
  9    10 
  9    11 
  9    12 /****^  HISTORY COMMENTS:
  9    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  9    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  9    15*     Support of MCA.
  9    16*                                                   END HISTORY COMMENTS */
  9    17 
  9    18 dcl  DEVICE_TYPE (8) char (32)
  9    19 	internal static options (constant)
  9    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  9    21 
  9    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  9    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  9    24 
  9    25 dcl  VOLUME_TYPE (8) char (32)
  9    26 	internal static options (constant)
  9    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  9    28 
  9    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  9    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  9    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  9    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  9    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  9    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  9    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  9    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  9    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  9    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  9    39 
  9    40 
  9    41 /*	End include file ... rcp_resource_types.incl.pl1 */
     3135 
     3136 
 10     1 /*	Begin  include file rcp_tape_info.incl.pl1
 10     2*   *
 10     3*   *	Created on 12/16/74 by Bill Silver.
 10     4*   *	Modified on 11/17/78 by Michael R. Jordan to add speed qualifier.
 10     5*   *	Modified on 09/30/82 by J. A. Bush for version 3 structure info
 10     6*   *	This include file defines the RCP device info structure for tapes.
 10     7**/
 10     8 /* format: style4 */
 10     9 
 10    10 dcl  tape_info_ptr ptr;				/* Pointer to tape device info structure. */
 10    11 
 10    12 dcl  tape_info_version_2 fixed bin internal static options (constant) init (2);
 10    13 dcl  tape_info_version_3 fixed bin internal static options (constant) init (3);
 10    14 
 10    15 dcl  1 tape_info based (tape_info_ptr) aligned,		/* RCP device info structure for tapes. */
 10    16        2 version_num fixed bin,			/* Version number of this structure. */
 10    17        2 usage_time fixed bin,			/* Number of minutes drive will/may be used. */
 10    18        2 wait_time fixed bin,				/* Number of minutes user will/must wait. */
 10    19        2 system_flag bit (1),				/* ON => user wants to be a system process. */
 10    20        2 device_name char (8),			/* Tape drive name. */
 10    21        2 model fixed bin,				/* Tape drive model number. */
 10    22        2 tracks fixed bin,				/* Track type, 7 or 9. */
 10    23        2 density bit (36),				/* Density capability: 200, 556, 800, 1600, 6250. */
 10    24        2 speed bit (36),				/* Speed: 75, 125, 200. */
 10    25        2 unused_qualifier bit (36),			/* Unused qualifier (must be "0"b). */
 10    26        2 volume_name char (32),			/* Tape reel name. */
 10    27        2 write_flag bit (1),				/* ON => writing on tape reel. */
 10    28        2 position_index fixed bin (35),			/* Counter used to determine tape reel position. */
 10    29 
 10    30 /* Limit of version 2 structure, info below returned if version 3 or greater */
 10    31 
 10    32        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decodes */
 10    33        2 volume_density fixed bin,			/* 1 - 5 = 200, 556, 800, 1600, or 6250 BPI */
 10    34        2 opr_auth bit (1);				/* "1"b => Operator Authentication was required */
 10    35 
 10    36 /*	End of include file ... rcp_tape_info.incl.pl1	*/
     3137 
     3138 
 11     1 /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
 11     2 
 11     3 /****^  HISTORY COMMENTS:
 11     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
 11     5*     install(86-11-21,MR12.0-1223):
 11     6*     created.
 11     7*                                                   END HISTORY COMMENTS */
 11     8 
 11     9 /* format: off */
 11    10 
 11    11 /* ************************************************************************ */
 11    12 /*							      */
 11    13 /* Function: Provides constants for commonly used Multics system values.    */
 11    14 /*							      */
 11    15 /* Usage: These values are available for use in place of "magic" numbers    */
 11    16 /*        (unexplained numbers) in programming applications.	      */
 11    17 /*							      */
 11    18 /* Definitions:						      */
 11    19 /*							      */
 11    20 /*   PER             bit     character/byte     word     page     segment   */
 11    21 /*		 					      */
 11    22 /*   bits              1            9             36     36864    9400320   */
 11    23 /*   characters/bytes	      1	           4      4096    1044480   */
 11    24 /*   words				 1      1024     261120   */
 11    25 /*   pages				           1        255   */
 11    26 /*   segments						  1   */
 11    27 /*							      */
 11    28 /*  The base values for a bit, char, word and page are determined by the    */
 11    29 /*  Multics hardware implementation.  The other values are calculated from  */
 11    30 /*  their relation to one another as shown in the matrix above.	      */
 11    31 /*							      */
 11    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
 11    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
 11    34 /*		  = 9 * 4					      */
 11    35 /*		  = 36					      */
 11    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
 11    37 /*		  = 9 * 4 * 1024				      */
 11    38 /*		  = 36864					      */
 11    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
 11    40 /*		    PAGES_PER_SEGMENT			      */
 11    41 /*		  = 9 * 4 * 1024 * 255			      */
 11    42 /*		  = 9400320				      */
 11    43 /*							      */
 11    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
 11    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
 11    46 /*		  = 4 * 1024				      */
 11    47 /*		  = 4096					      */
 11    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
 11    49 /*		  = 4 * 1024 * 255				      */
 11    50 /*		  = 1044480				      */
 11    51 /*							      */
 11    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
 11    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
 11    54 /*		  = 1024 * 255				      */
 11    55 /*		  = 261120				      */
 11    56 /*							      */
 11    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
 11    58 /*							      */
 11    59 /* ************************************************************************ */
 11    60 
 11    61        declare BITS_PER_CHAR		fixed bin (4) internal static
 11    62 				options (constant) initial (9);
 11    63 
 11    64        declare BITS_PER_WORD		fixed bin (6) internal static
 11    65 				options (constant) initial (36);
 11    66 
 11    67        declare BITS_PER_PAGE		fixed bin (16) internal static
 11    68 				options (constant) initial (36864);
 11    69 
 11    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
 11    71 				options (constant) initial (9400320);
 11    72 
 11    73        declare CHARS_PER_WORD		fixed bin (3) internal static
 11    74 				options (constant) initial (4);
 11    75 
 11    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
 11    77 				options (constant) initial (4096);
 11    78 
 11    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
 11    80 				options (constant) initial (1044480);
 11    81 
 11    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
 11    83 
 11    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
 11    85 				options (constant) initial (1024);
 11    86 
 11    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
 11    88 
 11    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
 11    90 				options (constant) initial (261120);
 11    91 
 11    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
 11    93 				options (constant) initial (255);
 11    94 
 11    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
 11    96 
     3139 
     3140 
     3141 	end copy_dump_tape;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/15/87  1558.3  copy_dump_tape.pl1                >special_ldd>install>MR12.1-1040>copy_dump_tape.pl1
2920         1    03/19/82  1647.0  rcp_list_info.incl.pl1            >ldd>include>rcp_list_info.incl.pl1
3119         2    12/07/76  1740.3  backup_dir_list.incl.pl1          >ldd>include>backup_dir_list.incl.pl1
3123         3    04/29/76  1058.2  backup_preamble_header.incl.pl1   >ldd>include>backup_preamble_header.incl.pl1
3125         4    07/15/87  1546.5  backup_record_types.incl.pl1      >spec>install>1040>backup_record_types.incl.pl1
3127         5    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
3129         6    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
3131         7    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
3133         8    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
3135         9    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
3137        10    04/05/83  0853.0  rcp_tape_info.incl.pl1            >ldd>include>rcp_tape_info.incl.pl1
3139        11    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALLOW_AF                               constant        fixed bin(17,0)          initial dcl 480 ref 495
ALLOW_COMMAND                          constant        fixed bin(17,0)          initial dcl 480 set ref 260* 493
ALLOW_COMMAND_AF                       constant        fixed bin(17,0)          initial dcl 480 ref 497
BLOCK_SIZE                      031523 constant        fixed bin(17,0)          initial dcl 181 ref 2072 2073 2087 2088 2151 2152
                                                                                  2221 2222 3074 3075 3080 3081
BLRH_DELIMITER                  000534 constant        char(32)                 initial unaligned dcl 181 ref 1377 2024 2052 2052
BLRH_ENGLISH                    000516 constant        char(56)                 initial unaligned dcl 181 ref 1378 2025 2052
CHARS_PER_WORD                         constant        fixed bin(3,0)           initial dcl 11-73 ref 2019 2021 2026 2028 2048 2050
                                                                                  2074 2076 2089 2129 2131 2153 2155 2199 2223 3032
                                                                                  3035 3039 3062 3076 3082
CODE_ARG                        000715 constant        fixed bin(17,0)          initial dcl 967 set ref 971* 994*
COMPARE                                constant        fixed bin(17,0)          initial dcl 181 ref 238 322 323 1342 1356 1756 1761
                                                                                  1793 1806 1806 1821
COPY                                   constant        fixed bin(17,0)          initial dcl 181 ref 228 299 300 1689 1747 1791 1808
                                                                                  1840 1843 1843 1847 1859
COPY_AND_COMPARE                       constant        fixed bin(17,0)          initial dcl 181 ref 330 331 1620 1795 1840 1884 2435
                                                                                  2574
DESTROY                         000726 constant        fixed bin(17,0)          initial dcl 181 set ref 287* 521* 522* 523* 524* 935
                                                                                  1575* 1576*
DEVICE_TYPE                     000201 constant        char(32)                 initial array unaligned dcl 9-18 set ref 2670*
DIR                                    constant        fixed bin(17,0)          initial dcl 2290 ref 2445 2449 2492 2515 2518 2518
                                                                                  2523 2531
FALSE                                  constant        bit(1)                   initial unaligned dcl 181 in procedure
                                                                                  "copy_dump_tape" set ref 634 693 699 703 721 723
                                                                                  746 748 771 773 832* 1364 1373 1374 1610 1782 1816
                                                                                  1837 1926 1974 2034 2042 2100 2302* 2302* 2329
                                                                                  2354 2592 2650 2655 2664 2668 2855 2991 3053 3101
FALSE                                  constant        bit(1)                   initial unaligned dcl 1195 in procedure "vowel" ref
                                                                                  1201
FALSE                                  constant        bit(1)                   initial unaligned dcl 1039 in procedure
                                                                                  "get_ctl_arg" ref 1049
FALSE                                  constant        bit(1)                   initial unaligned dcl 967 in procedure "error" ref
                                                                                  981
FALSE                                  constant        bit(1)                   initial unaligned dcl 1118 in procedure
                                                                                  "get_num_opt" ref 1145 1157
FALSE                                  constant        bit(1)                   initial unaligned dcl 1015 in procedure "get_arg"
                                                                                  ref 1023
FALSE                                  constant        bit(1)                   initial unaligned dcl 1166 in procedure "get_opt"
                                                                                  ref 1185 1187
FOR_MOVE_ATTACH                 000676 constant        fixed bin(17,0)          initial dcl 181 set ref 406 892 1484*
HT_SP                                  constant        char(2)                  initial unaligned dcl 1958 ref 1967 1968
KEEP                            000715 constant        fixed bin(17,0)          initial dcl 181 set ref 785* 786* 856* 857* 927
                                                                                  1607*
LINK                                   constant        fixed bin(17,0)          initial dcl 2290 ref 2440 2440
MAX_ERRORS                             constant        fixed bin(17,0)          initial dcl 667 ref 723 748 773
ME                              000100 automatic       char(17)                 unaligned dcl 17 set ref 227* 237* 258* 404 1511
                                                                                  1689*
MSF                                    constant        fixed bin(17,0)          initial dcl 2290 set ref 2449 2504 2518 2523 2523*
                                                                                  2554 2563 2575
NL                                     constant        char(1)                  initial unaligned dcl 1958 ref 1966
NOMORE                                 constant        fixed bin(17,0)          initial dcl 181 ref 737 831 837 2142 2170 2212 2239
OFF                                    constant        fixed bin(17,0)          initial dcl 181 ref 423 1375 1635 1789 1811
OK                                     constant        fixed bin(17,0)          initial dcl 181 ref 693 758 2135 2140 2162 2205 2210
                                                                                  2231
READ_AGAIN                             constant        fixed bin(17,0)          initial dcl 181 ref 692 830 836 2168 2237
RECORD_TYPE                     000417 constant        char(10)                 initial array dcl 4-29 set ref 2554 2554 2554 2554
                                                                                  2554* 2563 2563 2563 2563 2563* 2575 2575 2575
                                                                                  2575 2575*
REJECTED                               constant        fixed bin(17,0)          initial dcl 2404 ref 2550 2563 2589
REJECTED_SUBTREE                       constant        fixed bin(17,0)          initial dcl 2404 ref 2550 2563 2589
REJECTED_SUPERIOR_DIR                  constant        fixed bin(17,0)          initial dcl 2404 ref 2550 2563 2589
REJECTS                         000676 constant        fixed bin(17,0)          initial dcl 181 ref 1787 2435 2562
SEG                                    constant        fixed bin(17,0)          initial dcl 2290 ref 2442
SELECTED                               constant        fixed bin(17,0)          initial dcl 2404 ref 2456 2463 2500 2522
SELECTED_SUBTREE                       constant        fixed bin(17,0)          initial dcl 2404 ref 2531
SP                                     constant        char(1)                  initial unaligned dcl 1226 ref 1234 1286
STATE_NAME                      000004 constant        varying char(16)         initial array dcl 2404 set ref 2554 2554 2554* 2563
                                                                                  2563 2563* 2575 2575 2575*
SUPERIOR_DIR                           constant        fixed bin(17,0)          initial dcl 2404 ref 2492
Stream_input                           constant        fixed bin(17,0)          initial dcl 8-15 set ref 283* 302* 325* 326* 413
                                                                                  1641 1646
Stream_output                          constant        fixed bin(17,0)          initial dcl 8-15 set ref 292* 303* 1620 1650
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 9-29 ref 2670 2737 2792 2892
TRUE                                   constant        bit(1)                   initial unaligned dcl 181 in procedure
                                                                                  "copy_dump_tape" set ref 636 685 686 687 725 731
                                                                                  750 758 767 775 778 1660 1780 1814 1825 1928 1970
                                                                                  2031 2094 2334 2347 2501 2515 2523* 2523* 2589
                                                                                  2685 3043 3048 3092 3113
TRUE                                   constant        bit(1)                   initial unaligned dcl 967 in procedure "error" ref
                                                                                  974 997
TRUE                                   constant        bit(1)                   initial unaligned dcl 1195 in procedure "vowel" ref
                                                                                  1199
TRUE                                   constant        bit(1)                   initial unaligned dcl 1118 in procedure
                                                                                  "get_num_opt" ref 1132
TRUE                                   constant        bit(1)                   initial unaligned dcl 1039 in procedure
                                                                                  "get_ctl_arg" ref 1043
TRUE                                   constant        bit(1)                   initial unaligned dcl 1015 in procedure "get_arg"
                                                                                  ref 1021
TRUE                                   constant        bit(1)                   initial unaligned dcl 1166 in procedure "get_opt"
                                                                                  ref 1177
TYPE_NAME                       000047 constant        varying char(7)          initial array dcl 2290 set ref 2506* 2506* 2554*
                                                                                  2563* 2575*
TYPE_STRING                     000076 constant        char(10)                 initial array dcl 1419 ref 1434
UNKNOWN                         000676 constant        fixed bin(17,0)          initial dcl 2290 set ref 2302* 2502
UNMATCHED                              constant        fixed bin(17,0)          initial dcl 2404 ref 2453 2461 2550 2563 2589
UNSET                           031522 constant        char(1)                  initial unaligned dcl 1337 in procedure
                                                                                  "initialize_args" ref 1368
UNSET                           031522 constant        char(1)                  initial unaligned dcl 1682 in procedure
                                                                                  "process_args" ref 1861 1889
UNSPECIFIED                     000074 constant        pointer                  initial dcl 1682 in procedure "process_args" ref
                                                                                  1923
UNSPECIFIED                     000176 constant        pointer                  initial dcl 1337 in procedure "initialize_args" ref
                                                                                  1340
VAL_7_9                         000072 constant        fixed bin(17,0)          initial array dcl 1682 set ref 1768*
VAL_8_16_62                     000066 constant        fixed bin(17,0)          initial array dcl 1682 set ref 1774*
WORDS_PER_SEGMENT               000200 constant        fixed bin(21,0)          initial dcl 11-89 set ref 2734* 2787* 2863* 2887*
abort_sw                        000105 automatic       bit(1)                   unaligned dcl 17 set ref 721 746 771 1373* 1780*
                                                                                  1782*
absolute_pathname_              000012 constant        entry                    external dcl 116 ref 1730 1828
absolute_pathname_$add_suffix   000014 constant        entry                    external dcl 116 ref 1852 1900
added_as_msf                           parameter       bit(1)                   unaligned dcl 2309 in procedure "add_to_select_list"
                                                                                  ref 2306 2327
added_as_msf             55(21)        based           bit(1)                   array level 3 in structure "list" packed unaligned
                                                                                  dcl 2278 in procedure "skip_seg$init" set ref
                                                                                  2506*
added_as_msf             53(21) 004704 automatic       bit(1)                   level 2 in structure "en" packed unaligned dcl 2314
                                                                                  in procedure "add_to_select_list" set ref 2327*
addr                                                   builtin function         dcl 109 ref 229 239 283 283 287 287 292 292 302 302
                                                                                  303 303 325 325 326 326 521 521 522 522 523 523
                                                                                  524 524 672 672 674 674 699 729 730 736 740 740
                                                                                  740 740 757 761 763 763 763 775 775 785 785 786
                                                                                  786 856 856 857 857 1385 1431 1431 1435 1445 1448
                                                                                  1448 1484 1484 1505 1505 1509 1509 1518 1518 1548
                                                                                  1548 1575 1575 1576 1576 1607 1607 1697 1721 1740
                                                                                  1744 1749 1758 1763 1962 1962 1962 1962 1962 1962
                                                                                  1962 2019 2019 2026 2026 2048 2048 2074 2074 2301
                                                                                  2301 2670 2670 2680 2680 2689 2689 2689 2689 2736
                                                                                  2791 2868 2891 3032 3032 3035 3035 3062 3062 3076
                                                                                  3076 3088 3088
af_sw                           002666 automatic       bit(1)                   dcl 457 set ref 492* 493 495 498
allowed                                parameter       fixed bin(17,0)          dcl 487 ref 484 493 495 497
allowed_values                         parameter       fixed bin(17,0)          array dcl 1109 set ref 1105 1128 1128 1128 1132 1135
                                                                                  1135 1135 1135* 1149 1149 1149 1149*
arg                                    based           char                     unaligned dcl 457 set ref 1043 1046* 1696 1696 1704*
                                                                                  1709* 1720 1720 1727* 1732* 1739 1739 1743 1743
                                                                                  1747 1747 1756 1756 1761 1761 1767 1767 1768* 1773
                                                                                  1773 1774* 1780 1782 1782 1785 1797* 1811 1811
                                                                                  1814 1814 1816 1816 1819 1819 1826* 1830* 1835
                                                                                  1835 1840 1840 1843 1843 1847 1854* 1859 1859
                                                                                  1863* 1924*
arg_name                               parameter       char                     unaligned dcl 1163 in procedure "get_opt" set ref
                                                                                  1161 1182*
arg_name                               parameter       char                     unaligned dcl 1109 in procedure "get_num_opt" set
                                                                                  ref 1105 1135* 1135* 1149*
argl                            002667 automatic       fixed bin(21,0)          dcl 457 set ref 1020* 1043 1046 1046 1696 1696 1704
                                                                                  1704 1709 1709 1720 1720 1727 1727 1732 1732 1739
                                                                                  1739 1743 1743 1747 1747 1756 1756 1761 1761 1767
                                                                                  1767 1768 1768 1773 1773 1774 1774 1780 1782 1782
                                                                                  1785 1797 1797 1811 1811 1814 1814 1816 1816 1819
                                                                                  1819 1826 1826 1830 1830 1835 1835 1840 1840 1843
                                                                                  1843 1847 1854 1854 1859 1859 1863 1863 1924 1924
argn                            002672 automatic       fixed bin(17,0)          dcl 457 set ref 492* 1018 1030 1123 1170
argp                            002670 automatic       pointer                  dcl 457 set ref 1020* 1043 1046 1696 1696 1704 1709
                                                                                  1720 1720 1727 1732 1739 1739 1743 1743 1747 1747
                                                                                  1756 1756 1761 1761 1767 1767 1768 1773 1773 1774
                                                                                  1780 1782 1782 1785 1797 1811 1811 1814 1814 1816
                                                                                  1816 1819 1819 1826 1830 1835 1835 1840 1840 1843
                                                                                  1843 1847 1854 1859 1859 1863 1924
argx                            002673 automatic       fixed bin(17,0)          dcl 457 set ref 500* 1018 1019* 1019 1020* 1123
                                                                                  1124* 1124 1125* 1170 1171* 1171 1172* 1174* 1174
assigned_by_us           31     003076 automatic       bit(1)                   array level 3 dcl 2620 set ref 2650* 2685* 2855*
                                                                                  2941* 2963 2991*
atd                             003312 automatic       varying char(300)        dcl 396 in procedure "attach" set ref 412* 413* 413
                                                                                  415 423*
atd                             004426 automatic       varying char(256)        dcl 1604 in procedure "mount_next_tape_vol" set ref
                                                                                  1619* 1620* 1620 1626* 1626 1627* 1627 1629* 1629
                                                                                  1630* 1630 1631* 1631 1632* 1632 1633* 1633 1635*
                                                                                  1640
attach                                 based           structure                level 1 dcl 1-57
attach_descrip_ptr       14            based           pointer                  level 2 dcl 7-6 ref 915
attach_ptr                      005060 automatic       pointer                  dcl 1-12 set ref 2736* 2737 2737 2739 2740 2791*
                                                                                  2792 2793 2796
attaches                               based           structure                array level 2 dcl 1-19 set ref 2736 2791
b                                      based           structure                level 1 dcl 1403
backup_map_$beginning_line      000016 constant        entry                    external dcl 116 ref 1518
backup_map_$detach_for_cdt      000022 constant        entry                    external dcl 116 ref 1574
backup_map_$detail_line2        000020 constant        entry                    external dcl 116 ref 1442
backup_map_$directory_line      000024 constant        entry                    external dcl 116 ref 1431
backup_map_$heading_line        000026 constant        entry                    external dcl 116 ref 1550
backup_map_$init_for_cdt        000030 constant        entry                    external dcl 116 ref 1502
backup_map_$name_line           000032 constant        entry                    external dcl 116 ref 1448
backup_map_$tapes               000034 constant        entry                    external dcl 116 ref 1509 1548
backup_map_$terminal_line       000036 constant        entry                    external dcl 116 ref 1573
backup_util$idline              000040 constant        entry                    external dcl 116 ref 1505
bf                                     parameter       structure                level 1 dcl 2006 in procedure "read_seg$header" set
                                                                                  ref 2003 2124 2194
bf                                     parameter       structure                level 1 dcl 3019 in procedure "write_seg" set ref
                                                                                  3017
bf                                     parameter       structure                level 1 dcl 1403 in procedure "map_seg" ref 1401
bf1                                    parameter       structure                level 1 dcl 550 ref 547
bf2                                    parameter       structure                level 1 dcl 550 ref 547
bin                                                    builtin function         dcl 109 ref 1436 1439 1439 1440 1440 1445
bitcnt                   64            based           fixed bin(24,0)          level 2 in structure "mhe" dcl 2431 in procedure
                                                                                  "skip_seg$init" ref 2449
bitcnt                   64            based           fixed bin(24,0)          level 2 in structure "mhe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 763
bitcnt                   64            based           fixed bin(24,0)          level 2 in structure "cphe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 711
bitcnt                   64            based           fixed bin(24,0)          level 2 in structure "inhe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 842
blocks                    3     003746 automatic       fixed bin(9,0)           level 2 dcl 1403 set ref 1436* 1442*
blrh                                   based           structure                level 2 in structure "mbf" dcl 17 in procedure
                                                                                  "copy_dump_tape"
blrh                                   based           structure                level 1 dcl 3025 in procedure "write_seg" ref 3062
                                                                                  3074 3075
blrh                                   parameter       structure                level 2 in structure "mbf" dcl 2422 in procedure
                                                                                  "skip_seg$init"
blrh                            000244 automatic       structure                level 2 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape"
blrh                                   parameter       structure                level 2 in structure "bf1" dcl 550 in procedure
                                                                                  "compare_seg"
blrh                                   parameter       structure                level 2 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2048 2048
blrh                                   parameter       structure                level 2 in structure "bf" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3062 3062
blrh                                   parameter       structure                level 2 in structure "cpbf" dcl 2422 in procedure
                                                                                  "skip_seg$init"
blrh                                   parameter       structure                level 2 in structure "bf" dcl 1403 in procedure
                                                                                  "map_seg"
blrh                            000114 automatic       structure                level 2 in structure "cpbf" dcl 17 in procedure
                                                                                  "copy_dump_tape"
blrh                                   based           structure                level 1 dcl 2011 in procedure "read_seg$header" ref
                                                                                  2048 2050 2072 2073
blrh                                   parameter       structure                level 2 in structure "bf2" dcl 550 in procedure
                                                                                  "compare_seg"
blrh_sizes                             based           structure                level 1 dcl 3025 in procedure "write_seg" ref 3032
blrh_sizes                             based           structure                level 1 dcl 2011 in procedure "read_seg$header" ref
                                                                                  2019 2021
bp                              003736 automatic       pointer                  dcl 1403 in procedure "map_seg" set ref 1435* 1436
                                                                                  1439 1439 1440 1440 1445 1445
bp                      100            based           bit(18)                  level 2 in structure "he" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1435
br                                     based           structure                array level 1 dcl 2-6
channel_id                4     003076 automatic       fixed bin(71,0)          array level 3 dcl 2620 set ref 2670* 2857* 2938*
                                                                                  2967 2967*
char                                                   builtin function         dcl 109 ref 404 1319 1630 1632
charpos                 136     000374 automatic       fixed bin(35,0)          level 4 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1350*
charpos                 136            based           fixed bin(35,0)          level 4 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 427*
charpos                 136            parameter       fixed bin(35,0)          level 4 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2023* 2023 2030* 2030
                                                                                  2133* 2133 2200 2203* 2203
cl                       15(18)        based           bit(9)                   array level 2 packed unaligned dcl 2-6 ref 1436
cleanup                         002660 stack reference condition                dcl 114 ref 257
clock                                                  builtin function         dcl 109 ref 1442 1442 1504 1504 1518 1518 1573 1573
code                            004527 automatic       fixed bin(35,0)          dcl 1604 in procedure "mount_next_tape_vol" set ref
                                                                                  1640* 1641* 1645* 1646* 1651* 1652*
code                            000130 automatic       fixed bin(35,0)          dcl 2985 in procedure "tape_drive$unassign" set ref
                                                                                  2987* 2988*
code                            000106 automatic       fixed bin(35,0)          dcl 17 in procedure "copy_dump_tape" set ref 258*
                                                                                  893* 894* 895* 902* 903* 908* 909* 917* 918* 923*
                                                                                  924* 937* 1481* 1483 1485* 1487* 1489* 1492* 1730*
                                                                                  1732* 1733 1828* 1830* 1831 1852* 1854* 1855 1900*
                                                                                  1902* 2019* 2021 2026* 2028 2034 2036* 2048* 2050
                                                                                  2074* 2076 2089* 2091 2097 2103* 2129* 2131 2142
                                                                                  2144* 2153* 2155 2167 2173* 2200* 2202 2212 2214*
                                                                                  2223* 2225 2236 2242* 3032* 3034 3035* 3037 3039*
                                                                                  3041 3053 3055* 3062* 3064 3076* 3078 3082* 3087
                                                                                  3088* 3090 3095 3095 3104*
code                            004564 automatic       fixed bin(35,0)          dcl 1952 in procedure "read_line" set ref 1962* 1964
                                                                                  1972 1976*
code                            000116 automatic       fixed bin(35,0)          dcl 2959 in procedure "tape_drive$term" set ref
                                                                                  2967*
code                                   based           fixed bin(35,0)          dcl 959 in procedure "error" set ref 972 973 973*
                                                                                  995 996 996*
code                            003426 automatic       fixed bin(35,0)          dcl 396 in procedure "attach" set ref 406* 408* 415*
                                                                                  416* 419* 420*
code                            005036 automatic       fixed bin(35,0)          dcl 2729 in procedure "tape_drive$find_device" set
                                                                                  ref 2734* 2787* 2857* 2858* 2863* 2864* 2865 2887*
code                            004766 automatic       fixed bin(35,0)          dcl 2645 in procedure "tape_drive$assign" set ref
                                                                                  2670* 2673 2673 2675* 2680* 2689* 2692 2693* 2694*
                                                                                  2702*
code                            000106 automatic       fixed bin(35,0)          dcl 1568 in procedure "map_seg$term" set ref 1574*
code                            003712 automatic       fixed bin(35,0)          dcl 1270 in procedure "medium" set ref 1282* 1283
code                            003534 automatic       fixed bin(35,0)          dcl 1065 in procedure "get_entry" set ref 1071*
codep                           000100 automatic       pointer                  dcl 959 set ref 971* 972 973 973 994* 995 996 996
compare_continues               003470 automatic       bit(1)                   unaligned dcl 667 set ref 685* 688 703* 721* 723*
                                                                                  746* 748* 771* 773*
compare_dump_tape_severity_     000140 external static fixed bin(17,0)          initial dcl 181 set ref 239
compared                        000110 automatic       structure                level 1 dcl 17 set ref 1383*
convert                                                builtin function         dcl 1116 ref 1127
convert_ipc_code_               000042 constant        entry                    external dcl 116 ref 2693
copied                          000112 automatic       structure                level 1 dcl 17 set ref 1383*
copy_dump_tape_map_             000142 external static varying char(168)        initial dcl 181 set ref 231* 293*
copy_dump_tape_severity_        000144 external static fixed bin(17,0)          initial dcl 181 set ref 229
copy_dump_tape_tapes            000146 external static varying char(300)        initial dcl 181 set ref 230* 313* 315* 315 316* 316
count                           005122 automatic       fixed bin(21,0)          dcl 3023 in procedure "write_seg" set ref 3088 3088
count                           003076 automatic       fixed bin(17,0)          level 2 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2733 2740
                                                                                  2743 2785 2793 2796 2809 2813 2848* 2870 2871
                                                                                  2871* 2877 2878 2893 2896 2896* 2899 2909 2909*
                                                                                  2909 2909* 2936* 2962
count                           003427 automatic       fixed bin(17,0)          dcl 396 in procedure "attach" set ref 403* 404
cpbf                                   parameter       structure                level 1 dcl 2422 in procedure "skip_seg$init" ref
                                                                                  2420
cpbf                            000114 automatic       structure                level 1 dcl 17 in procedure "copy_dump_tape" set ref
                                                                                  690* 691* 729* 761* 1381*
cphe                                   based           structure                level 1 dcl 17
cphe_name                              based           structure                level 1 dcl 17 in procedure "copy_dump_tape"
cphe_name                              based           structure                level 1 dcl 2431 in procedure "skip_seg$init"
cplast                          000160 automatic       structure                level 1 dcl 17 set ref 690* 691*
cu_$arg_list_ptr                000044 constant        entry                    external dcl 116 in procedure "copy_dump_tape" ref
                                                                                  258 258
cu_$arg_list_ptr                000214 constant        entry                    external dcl 962 in procedure "error" ref 975 975
                                                                                  999 999
cu_$arg_ptr                     000216 constant        entry                    external dcl 962 ref 971 994
cu_$generate_call               000220 constant        entry                    external dcl 962 ref 975 999
da                              005037 automatic       fixed bin(17,0)          dcl 2729 set ref 2735* 2736* 2790* 2791* 2867* 2868*
                                                                                  2880* 2880* 2884 2890* 2891*
dassign                                based           structure                level 1 dcl 1-41
dassign_ptr                     005056 automatic       pointer                  dcl 1-11 set ref 2891* 2892 2893 2900 2901 2902
dassigns                  6            based           structure                array level 2 dcl 1-19 set ref 2891
data                      1            based           char(300)                level 2 dcl 1954 set ref 1962 1962 1962 1962
date_time_$format               000046 constant        entry                    external dcl 116 ref 1504
date_time_string                003772 automatic       varying char(40)         dcl 1473 set ref 1504* 1505
default_value                          parameter       fixed bin(17,0)          dcl 1109 set ref 1105 1135 1135* 1135 1149 1149*
                                                                                  1149
density                 142     001636 automatic       fixed bin(17,0)          level 4 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1881 1881*
density                 142     000374 automatic       fixed bin(17,0)          level 4 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1352* 1701* 1879 1879*
density                  27     003076 automatic       bit(36)                  array level 3 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2817 2853*
                                                                                  2902* 2941*
density                 142            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 2770 in procedure
                                                                                  "tape_drive$find_device" ref 2801 2803 2805
density                 142            based           fixed bin(17,0)          level 4 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape" set ref 1724* 1752* 1775*
density                 142            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1630
density                  10     005000 automatic       bit(36)                  level 2 in structure "ti" dcl 2645 in procedure
                                                                                  "tape_drive$assign" set ref 2660*
densityx                        005041 automatic       fixed bin(17,0)          dcl 2772 set ref 2801* 2803* 2805* 2807* 2817
device                   10            parameter       char(32)                 level 2 in structure "vol" dcl 2727 in procedure
                                                                                  "tape_drive$find_device" set ref 2732* 2735 2739*
device                  153            parameter       char(32)                 array level 3 in structure "io" dcl 1602
                                                                                  in procedure "mount_next_tape_vol" set ref 1614
                                                                                  1625 1627 1635 1635*
device                  153            parameter       char(32)                 array level 3 in structure "io" dcl 2770
                                                                                  in procedure "tape_drive$find_device" set ref 2776
                                                                                  2824*
device                    6     003076 automatic       structure                array level 2 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2870 2896
device_name                            based           char(8)                  level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "tape_drive$find_device" ref 2893 2900
device_name               4     005000 automatic       char(8)                  level 2 in structure "ti" dcl 2645 in procedure
                                                                                  "tape_drive$assign" set ref 2656* 2656
device_name              13            based           char(8)                  level 2 in structure "device_resv" dcl 1-79
                                                                                  in procedure "tape_drive$find_device" ref 2869
                                                                                  2872
device_name                            based           char(8)                  level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "tape_drive$find_device" ref 2739 2740 2793
device_name               6            based           char(8)                  array level 3 in structure "rli" dcl 1-19
                                                                                  in procedure "tape_drive$find_device" set ref 2880
device_resv                            based           structure                level 1 dcl 1-79
device_resv_ptr                 005062 automatic       pointer                  dcl 1-14 set ref 2868* 2869 2872
device_resvs                           based           structure                array level 2 dcl 1-19 set ref 2868
dim                                                    builtin function         dcl 1116 in procedure "get_num_opt" ref 1135 1135
                                                                                  1149 1149
dim                                                    builtin function         dcl 109 in procedure "copy_dump_tape" ref 575 575
                                                                                  575 575 575 575 604 604 604 604 604 604
dir                                    parameter       char(168)                level 3 in structure "last" packed unaligned
                                                                                  dcl 2006 in procedure "read_seg$header" set ref
                                                                                  2078 2078 2083* 2083* 2158* 2227*
dir                             003535 automatic       char(168)                unaligned dcl 1065 in procedure "get_entry" set ref
                                                                                  1071*
disp                                   parameter       fixed bin(17,0)          dcl 882 ref 880 927 935
divide                                                 builtin function         dcl 109 ref 1319 1436
dlen                                   based           fixed bin(17,0)          level 2 dcl 1403 set ref 1431*
dname                                  based           varying char(168)        level 2 in structure "mhe_name" dcl 2431
                                                                                  in procedure "skip_seg$init" ref 2463 2518
dname                     1            based           char(168)                level 2 in structure "mhe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 740 740
dname                                  based           varying char(168)        level 2 in structure "mhe_name" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 775
dname                     1            based           char(168)                level 2 in structure "he1" dcl 557 in procedure
                                                                                  "compare_seg" ref 567 567 575 575 593 593 604 604
                                                                                  621 621
dname                                  based           varying char(168)        level 2 in structure "cphe_name" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 775
dname                     1            based           char(168)                level 2 in structure "he" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2078 2158 2227
dname                     1            based           char(168)                level 2 in structure "he2" dcl 557 in procedure
                                                                                  "compare_seg" ref 567 567 575 575 593 593 604 604
                                                                                  621 621
dname                     1            based           char(168)                level 2 in structure "mhe" dcl 2431 in procedure
                                                                                  "skip_seg$init" ref 2439
dname                     1            based           char(168)                level 2 in structure "cphe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 715 715
dname                                  based           varying char(168)        level 2 in structure "he2_name" dcl 557 in procedure
                                                                                  "compare_seg" ref 567
dname                                  based           varying char(168)        level 2 in structure "cphe_name" dcl 2431
                                                                                  in procedure "skip_seg$init" ref 2463
dname                     1            based           char(168)                level 2 in structure "he" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1429 1430 1431 1431
dname                                  based           varying char(168)        level 2 in structure "he1_name" dcl 557 in procedure
                                                                                  "compare_seg" ref 567
dont_select              53(18) 004704 automatic       fixed bin(1,0)           level 2 in structure "en" packed unsigned unaligned
                                                                                  dcl 2314 in procedure "add_to_select_list" set ref
                                                                                  2319* 2323*
dont_select              55(18)        based           fixed bin(1,0)           array level 3 in structure "list" packed unsigned
                                                                                  unaligned dcl 2278 in procedure "skip_seg$init"
                                                                                  set ref 2356 2492 2500 2522 2523 2531
dtbm                     10(20)        based           bit(52)                  level 2 packed unaligned dcl 1403 ref 1439
dtcm                     12     003746 automatic       fixed bin(52,0)          level 2 dcl 1403 set ref 1440* 1442*
dtd                       6     003746 automatic       fixed bin(52,0)          level 2 in structure "seg" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1439* 1442*
dtd                       6(20)        based           bit(52)                  level 2 in structure "b" packed unaligned dcl 1403
                                                                                  in procedure "map_seg" ref 1439
dtem                      4     003746 automatic       fixed bin(52,0)          level 2 dcl 1403 set ref 1439* 1442*
dtm                       4(20)        based           bit(52)                  level 2 packed unaligned dcl 1403 ref 1440
dtu                       2(20)        based           bit(52)                  level 2 in structure "b" packed unaligned dcl 1403
                                                                                  in procedure "map_seg" ref 1440
dtu                      10     003746 automatic       fixed bin(52,0)          level 2 in structure "seg" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1440* 1442*
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "tape_drive$find_device" ref 2737 2792
dtypex                    2            based           fixed bin(17,0)          level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "tape_drive$find_device" ref 2892
dvx                       1     003076 automatic       fixed bin(17,0)          level 2 dcl 2620 set ref 2809* 2809 2813 2813 2849*
                                                                                  2937*
dx                                     parameter       fixed bin(17,0)          dcl 2984 in procedure "tape_drive$unassign" ref 2981
                                                                                  2987 2988 2991
dx                                     parameter       fixed bin(17,0)          dcl 2643 in procedure "tape_drive$assign" ref 2640
                                                                                  2650 2656 2670 2675 2680 2685 2702
dx                              005040 automatic       fixed bin(17,0)          dcl 2729 in procedure "tape_drive$find_device" set
                                                                                  ref 2740* 2740* 2743 2743 2793* 2793* 2796 2796
                                                                                  2813* 2817 2817 2817 2817 2821* 2871* 2872 2878*
                                                                                  2880 2884* 2893* 2893* 2896 2896 2896 2899 2900
                                                                                  2901 2902
dx                              000117 automatic       fixed bin(17,0)          dcl 2959 in procedure "tape_drive$term" set ref
                                                                                  2962* 2963 2963*
e                         2            based           structure                array level 2 dcl 2278 set ref 2336* 2348 2348 2491
                                                                                  2491
en                              004704 automatic       structure                level 1 dcl 2314 set ref 2336
ename                    53            based           varying char(32)         level 2 in structure "mhe_name" dcl 2431
                                                                                  in procedure "skip_seg$init" ref 2463
ename                    53            based           varying char(32)         level 2 in structure "cphe_name" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 775
ename                    54            based           char(32)                 level 2 in structure "mhe" dcl 2431 in procedure
                                                                                  "skip_seg$init" ref 2439
ename                    54            based           char(32)                 level 2 in structure "he2" dcl 557 in procedure
                                                                                  "compare_seg" ref 567 567 575 575 593 593 604 604
                                                                                  621 621
ename                    53            based           varying char(32)         level 2 in structure "he1_name" dcl 557 in procedure
                                                                                  "compare_seg" ref 567
ename                    54            based           char(32)                 level 2 in structure "he1" dcl 557 in procedure
                                                                                  "compare_seg" ref 567 567 575 575 593 593 604 604
                                                                                  621 621
ename                    54            based           char(32)                 level 2 in structure "he" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2078 2159 2228
ename                    54            based           char(32)                 level 2 in structure "he" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1442*
ename                    53            based           varying char(32)         level 2 in structure "cphe_name" dcl 2431
                                                                                  in procedure "skip_seg$init" ref 2463
ename                    53            based           varying char(32)         level 2 in structure "he2_name" dcl 557 in procedure
                                                                                  "compare_seg" ref 567
ename                    54            based           char(32)                 level 2 in structure "cphe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 715 715
ename                    53            based           varying char(32)         level 2 in structure "mhe_name" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 775
ename                    54            based           char(32)                 level 2 in structure "mhe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 740 740
english                  10     000244 automatic       char(56)                 level 3 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1378*
english                  10            parameter       char(56)                 level 3 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2025* 2052 2052*
ent                             003607 automatic       char(32)                 unaligned dcl 1065 in procedure "get_entry" set ref
                                                                                  1071* 1072
ent                      52            parameter       char(32)                 level 3 in structure "last" packed unaligned
                                                                                  dcl 2006 in procedure "read_seg$header" set ref
                                                                                  2078 2083* 2083* 2159* 2228*
error_count                     003473 automatic       fixed bin(17,0)          dcl 667 set ref 684* 720* 720 723 745* 745 748 770*
                                                                                  770 773 789 789* 789 795
error_occurred_sw               002706 automatic       bit(1)                   unaligned dcl 955 set ref 974* 981* 988 997*
error_table_$active_function    000210 external static fixed bin(35,0)          dcl 488 set ref 493*
error_table_$bad_arg            000226 external static fixed bin(35,0)          dcl 1118 in procedure "get_num_opt" set ref 1135*
error_table_$bad_arg            000222 external static fixed bin(35,0)          dcl 1039 in procedure "get_ctl_arg" set ref 1046*
error_table_$bad_opt            000150 external static fixed bin(35,0)          dcl 181 set ref 1797* 1863*
error_table_$device_end         000152 external static fixed bin(35,0)          dcl 181 ref 3095
error_table_$end_of_info        000154 external static fixed bin(35,0)          dcl 181 ref 1972 2034 2097 2142 2167 2212 2236 3053
                                                                                  3095
error_table_$inconsistent       000156 external static fixed bin(35,0)          dcl 181 set ref 1884* 1924*
error_table_$noarg              000230 external static fixed bin(35,0)          dcl 1118 in procedure "get_num_opt" set ref 1149*
error_table_$noarg              000160 external static fixed bin(35,0)          dcl 181 in procedure "copy_dump_tape" set ref 1870*
                                                                                  1874*
error_table_$noarg              000232 external static fixed bin(35,0)          dcl 1166 in procedure "get_opt" set ref 1182*
error_table_$not_act_fnc        000212 external static fixed bin(35,0)          dcl 488 set ref 495*
error_table_$not_detached       000162 external static fixed bin(35,0)          dcl 181 ref 1483
error_table_$resource_reserved  000164 external static fixed bin(35,0)          dcl 181 ref 2673
error_table_$resource_unavailable
                                000166 external static fixed bin(35,0)          dcl 181 ref 2673
error_table_$too_many_names     000170 external static fixed bin(35,0)          dcl 181 set ref 1709*
error_table_$wrong_no_of_args   000172 external static fixed bin(35,0)          dcl 181 set ref 1689*
ev_info                         004770 automatic       structure                level 1 dcl 2645 set ref 2689 2689
event_wait_channel              003276 automatic       structure                level 1 dcl 5-8
event_wait_info                        based           structure                level 1 dcl 6-7
event_wait_list           2     003076 automatic       structure                level 2 dcl 2620 set ref 2689 2689
expand_pathname_                000224 constant        entry                    external dcl 1069 ref 1071
expath                   64            parameter       char(168)                level 4 in structure "out" packed unaligned dcl 1266
                                                                                  in procedure "medium" set ref 1276*
expath                   64            parameter       char(168)                level 4 in structure "out" packed unaligned dcl 3019
                                                                                  in procedure "write_seg" set ref 3055*
expath                   64            based           char(168)                level 4 in structure "io" packed unaligned dcl 393
                                                                                  in procedure "attach" set ref 412 416* 420* 423*
expath                   64     001240 automatic       char(168)                level 4 in structure "map" packed unaligned dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 293 1505*
                                                                                  1852* 1855* 1855* 1900* 1905* 1905*
expath                   64            based           char(168)                level 4 in structure "in" packed unaligned dcl 1949
                                                                                  in procedure "read_line" set ref 1976*
expath                   64            based           char(168)                level 4 in structure "in_out" packed unaligned
                                                                                  dcl 84 in procedure "copy_dump_tape" set ref 1730*
                                                                                  1733* 1733*
expath                   64     000374 automatic       char(168)                level 4 in structure "input" packed unaligned dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 1350*
expath                   64            parameter       char(168)                level 4 in structure "in" packed unaligned dcl 2006
                                                                                  in procedure "read_seg$header" set ref 2036* 2144*
                                                                                  2214*
expath                   64     002502 automatic       char(168)                level 4 in structure "select" packed unaligned
                                                                                  dcl 17 in procedure "copy_dump_tape" set ref 1515
                                                                                  1828* 1831* 1831*
expath                   64            based           char(168)                level 4 in structure "io" packed unaligned dcl 885
                                                                                  in procedure "detach" set ref 903* 918*
extra_masters                   003474 automatic       fixed bin(17,0)          dcl 667 set ref 684* 739* 739 740
first_disagreement              003454 automatic       fixed bin(18,0)          dcl 553 set ref 585* 589* 593* 593 593* 593 613*
                                                                                  617* 621* 621 621* 621
from                            003652 automatic       varying char(32)         dcl 1223 set ref 1232* 1234 1235*
get_line_length_$switch         000050 constant        entry                    external dcl 116 ref 1282
get_shortest_path_              000052 constant        entry                    external dcl 116 ref 1733 1831 1855 1905 2554 2554
                                                                                  2563 2563 2575 2575
h                                      based           structure                level 1 dcl 3-7
hbound                                                 builtin function         dcl 109 in procedure "copy_dump_tape" ref 586 614
                                                                                  1709 1709 1709 2348 2491 2870 2896
hbound                                                 builtin function         dcl 1116 in procedure "get_num_opt" ref 1128 1132
he                                     based           structure                level 1 dcl 2006 in procedure "read_seg$header" set
                                                                                  ref 2026 2026 2074 2074
he                       62            parameter       fixed bin(35,0)          level 3 in structure "last" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2078 2160* 2229*
he                                     based           structure                level 1 dcl 3019 in procedure "write_seg" set ref
                                                                                  3035 3035 3076 3076
he                                     based           structure                level 1 dcl 1403 in procedure "map_seg" set ref 1435
                                                                                  1445
he1                                    based           structure                level 1 dcl 557
he1_name                               based           structure                level 1 dcl 557
he1_words                              based           fixed bin(35,0)          array dcl 557 set ref 575 575 575 583 586 586 587
                                                                                  593*
he2                                    based           structure                level 1 dcl 557
he2_name                               based           structure                level 1 dcl 557
he2_words                              based           fixed bin(35,0)          array dcl 557 set ref 575 575 575 583 587 593*
head                                   based           structure                level 2 dcl 1-19
header                                 parameter       structure                level 2 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header"
header                                 parameter       structure                level 2 in structure "out" dcl 1243 in procedure
                                                                                  "label"
header                          001240 automatic       structure                level 2 in structure "map" dcl 17 in procedure
                                                                                  "copy_dump_tape"
header                                 based           structure                level 2 in structure "io" dcl 393 in procedure
                                                                                  "attach"
header                          001404 automatic       structure                level 2 in structure "map_prev" dcl 17 in procedure
                                                                                  "copy_dump_tape"
header                          001636 automatic       structure                level 2 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape"
header                                 parameter       structure                level 2 in structure "out" dcl 1266 in procedure
                                                                                  "medium"
header                          002502 automatic       structure                level 2 in structure "select" dcl 17 in procedure
                                                                                  "copy_dump_tape"
header                                 parameter       structure                level 2 in structure "io" dcl 2770 in procedure
                                                                                  "tape_drive$find_device"
header                                 parameter       structure                level 2 in structure "out" dcl 1471 in procedure
                                                                                  "map_seg$init"
header                                 parameter       structure                level 2 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol"
header                                 based           structure                level 2 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape"
header                                 parameter       structure                level 2 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg"
header                                 parameter       structure                level 2 in structure "out" dcl 1539 in procedure
                                                                                  "map_seg$new_tape"
header                                 based           structure                level 2 in structure "io" dcl 885 in procedure
                                                                                  "detach"
header                                 based           structure                level 2 in structure "in" dcl 1949 in procedure
                                                                                  "read_line"
header                          000374 automatic       structure                level 2 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape"
header_needed                   004606 automatic       bit(1)                   unaligned dcl 2343 set ref 2347* 2350 2354*
hhmm                            000100 automatic       char(4)                  level 2 packed unaligned dcl 1309 set ref 1317
hl                       36            parameter       fixed bin(21,0)          level 4 in structure "cpbf" dcl 2422 in procedure
                                                                                  "skip_seg$init" ref 2463
hl                       36            parameter       fixed bin(21,0)          level 4 in structure "bf1" dcl 550 in procedure
                                                                                  "compare_seg" ref 575 575 575 583 586
hl                       36            parameter       fixed bin(21,0)          level 4 in structure "mbf" dcl 2422 in procedure
                                                                                  "skip_seg$init" ref 2463
hl                       36            parameter       fixed bin(21,0)          level 4 in structure "bf" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3035 3074
hl                       36     000244 automatic       fixed bin(21,0)          level 4 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1379*
hl                       36            parameter       fixed bin(21,0)          level 4 in structure "bf2" dcl 550 in procedure
                                                                                  "compare_seg" ref 575 575 575 583
hl                       36            parameter       fixed bin(21,0)          level 4 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2026 2028 2072 2078 2160
                                                                                  2229
hp                       40            parameter       pointer                  level 2 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" ref 2026 2026 2074 2074 2078
                                                                                  2078 2158 2159 2227 2228
hp                       40            parameter       pointer                  level 2 in structure "bf" dcl 1403 in procedure
                                                                                  "map_seg" ref 1429 1430 1431 1431 1431 1434 1435
                                                                                  1435 1442 1445 1446
hp                       40            parameter       pointer                  level 2 in structure "cpbf" dcl 2422 in procedure
                                                                                  "skip_seg$init" ref 2463 2463
hp                       40            parameter       pointer                  level 2 in structure "bf2" dcl 550 in procedure
                                                                                  "compare_seg" ref 567 567 567 567 567 567 575 575
                                                                                  575 575 575 575 575 583 587 593 593 593 593 593
                                                                                  604 604 604 604 621 621 621 621
hp                       40     000244 automatic       pointer                  level 2 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 824* 842 842 842 1380*
hp                       40            parameter       pointer                  level 2 in structure "bf1" dcl 550 in procedure
                                                                                  "compare_seg" ref 567 567 567 567 567 567 575 575
                                                                                  575 575 575 575 575 583 586 586 587 593 593 593
                                                                                  593 593 604 604 604 604 621 621 621 621
hp                       40            parameter       pointer                  level 2 in structure "bf" dcl 3019 in procedure
                                                                                  "write_seg" ref 3035 3035 3076 3076
hp                       40            based           pointer                  level 2 in structure "mbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 672 672* 740 740 740 740
                                                                                  763 763 763 775 775
hp                       40     000114 automatic       pointer                  level 2 in structure "cpbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 676* 711 711 711 715 715
                                                                                  715 715 775 775
hp                       40            parameter       pointer                  level 2 in structure "mbf" dcl 2422 in procedure
                                                                                  "skip_seg$init" ref 2439 2439 2440 2442 2442 2445
                                                                                  2445 2445 2449 2463 2463 2504 2518 2554 2563 2575
in                                     parameter       structure                level 1 dcl 2006 in procedure "read_seg$header" set
                                                                                  ref 2003 2098* 2124 2168* 2194 2237*
in                                     parameter       structure                level 1 dcl 1219 in procedure "header" set ref 1217
                                                                                  1232* 1235*
in                                     based           structure                level 1 dcl 1949 in procedure "read_line"
in_out                                 based           structure                level 1 dcl 84
in_outp                         002654 automatic       pointer                  dcl 84 set ref 1340* 1697* 1698 1699 1702 1703 1705
                                                                                  1706 1709 1709 1709 1709 1714 1714 1715 1715 1721*
                                                                                  1722 1723 1724 1724 1725 1726 1729 1730 1730 1733
                                                                                  1733 1740* 1744* 1749* 1750 1751 1752 1752 1753
                                                                                  1758* 1763* 1769 1775 1923
inbf                            000244 automatic       structure                level 1 dcl 17 set ref 672 672 674 674 699 729 730
                                                                                  736 740 740 740 740 757 761 763 763 763 775 775
                                                                                  831* 832* 832* 832* 835* 839* 840* 1381
indent                          003674 automatic       fixed bin(17,0)          dcl 1223 in procedure "header" set ref 1234* 1235*
                                                                                  1236*
indent                                 parameter       fixed bin(17,0)          dcl 1266 in procedure "medium" set ref 1263 1276*
                                                                                  1278* 1281 1287* 1293*
index                                                  builtin function         dcl 1037 in procedure "get_ctl_arg" ref 1043
index                                                  builtin function         dcl 109 in procedure "copy_dump_tape" ref 1173
inhe                                   based           structure                level 1 dcl 17
inhe_name                              based           structure                level 1 dcl 17
inlast                          000310 automatic       structure                level 1 dcl 17 set ref 831* 832* 835*
inp                                    parameter       pointer                  dcl 1949 ref 1946 1962 1965 1965 1976 1976 1976
input                           000374 automatic       structure                level 1 dcl 17 set ref 301* 302 302 324* 325 325 521
                                                                                  521 699* 730* 736* 757* 785 785 831* 832* 835* 856
                                                                                  856 1355 1697 1721 1758
io                                     based           structure                level 1 dcl 885 in procedure "detach"
io                                     parameter       structure                level 1 dcl 1602 in procedure "mount_next_tape_vol"
                                                                                  set ref 1599 1607 1607 1614* 1616*
io                                     parameter       structure                level 1 dcl 2770 in procedure
                                                                                  "tape_drive$find_device" set ref 2767 2779
io                                     based           structure                level 1 dcl 393 in procedure "attach" set ref 431*
io_switch_name                  003430 automatic       char(32)                 unaligned dcl 396 set ref 404* 406* 408*
ioa_                            000054 constant        entry                    external dcl 116 ref 282 291 308 335 360 788 859 998
                                                                                  1228 1276 1278 1287 1293 2351 2356 2554 2563 2575
                                                                                  2908
iocb                                   based           structure                level 1 dcl 7-6
iocbp                     4            based           pointer                  level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach" set ref 890 893* 894* 896* 900 902* 908*
                                                                                  915 917* 923* 935 937* 938*
iocbp                     4            parameter       pointer                  level 3 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1607 1640* 1645*
                                                                                  1651*
iocbp                     4            parameter       pointer                  level 3 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3032* 3035* 3039* 3062* 3076*
                                                                                  3082* 3088*
iocbp                     4            based           pointer                  level 3 in structure "in" dcl 1949 in procedure
                                                                                  "read_line" set ref 1962*
iocbp                     4            based           pointer                  level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 408* 415* 419*
iocbp                     4     000374 automatic       pointer                  level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1346*
iocbp                     4     001240 automatic       pointer                  level 3 in structure "map" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1481 1489 1492
iocbp                     4            parameter       pointer                  level 3 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2019* 2026* 2042 2048*
                                                                                  2074* 2089* 2129* 2153* 2200* 2223*
iocbp                     4     001404 automatic       pointer                  level 3 in structure "map_prev" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1481* 1485* 1489* 1572
iop                                    parameter       pointer                  dcl 882 in procedure "detach" ref 880 890 892 893
                                                                                  894 894 895 896 900 901 902 903 903 908 909 909
                                                                                  909 915 916 917 918 918 923 924 924 924 927 927
                                                                                  927 935 937 938
iop                                    parameter       pointer                  dcl 393 in procedure "attach" ref 391 401 402 404
                                                                                  406 408 411 412 415 416 416 419 420 420 423 423
                                                                                  427 429 430 431 432 432 432
iox_$attach_name                000056 constant        entry                    external dcl 116 ref 1481 1489
iox_$attach_ptr                 000060 constant        entry                    external dcl 116 ref 415 1640
iox_$close                      000062 constant        entry                    external dcl 116 ref 902 908
iox_$control                    000064 constant        entry                    external dcl 116 ref 3088
iox_$destroy_iocb               000066 constant        entry                    external dcl 116 ref 895 937
iox_$detach_iocb                000070 constant        entry                    external dcl 116 ref 893 917 923
iox_$find_iocb                  000072 constant        entry                    external dcl 116 ref 406 408
iox_$get_chars                  000074 constant        entry                    external dcl 116 ref 2019 2026 2048 2074 2129 2153
iox_$get_line                   000076 constant        entry                    external dcl 116 ref 1962
iox_$modes                      000100 constant        entry                    external dcl 116 ref 1651
iox_$move_attach                000102 constant        entry                    external dcl 116 ref 894 1485
iox_$open                       000104 constant        entry                    external dcl 116 ref 419 1645
iox_$position                   000106 constant        entry                    external dcl 116 ref 2089 2200 2223
iox_$put_chars                  000110 constant        entry                    external dcl 116 ref 3032 3035 3039 3062 3076 3082
iox_modes                       000301 constant        char(24)                 initial array dcl 8-6 set ref 420* 423*
ipc_$block                      000112 constant        entry                    external dcl 116 ref 2689
ipc_$create_ev_chn              000114 constant        entry                    external dcl 116 ref 2857
ipc_$delete_ev_chn              000116 constant        entry                    external dcl 116 ref 2967
l                                      based           fixed bin(17,0)          array level 2 in structure "n" packed unsigned
                                                                                  unaligned dcl 1403 in procedure "map_seg" ref 1448
l                                      based           fixed bin(21,0)          level 2 in structure "line_buffer" dcl 1954
                                                                                  in procedure "read_line" set ref 1962*
lab                                    parameter       varying char(32)         dcl 1266 in procedure "medium" set ref 1263 1276*
                                                                                  1278* 1287* 1290* 1293*
lab                                    parameter       varying char(32)         dcl 1243 in procedure "label" set ref 1240 1247*
                                                                                  1248* 1248 1249* 1249 1250* 1250 1251* 1251 1253*
                                                                                  1253 1255* 1255 1257* 1257
last                                   parameter       structure                level 1 dcl 2006 set ref 2003 2124 2194
lbound                                                 builtin function         dcl 1116 in procedure "get_num_opt" ref 1128
lbound                                                 builtin function         dcl 109 in procedure "copy_dump_tape" ref 586 614
                                                                                  2348 2491
len                             003713 automatic       fixed bin(17,0)          dcl 1270 set ref 1281* 1286
length                                                 builtin function         dcl 109 ref 1234 1234 1234 1286 1286 1316 1505 1505
                                                                                  1509 1509 1518 1518 1548 1548 1962 1962 1966 1966
                                                                                  2317 2330 2330 2330 2330 2330 2333 2333 2492 2492
                                                                                  2492 2492 2531 2531 2531 2656 2869
line                                   parameter       varying char             dcl 2309 in procedure "add_to_select_list" ref 2306
                                                                                  2317 2318 2322
line                            002761 automatic       varying char(300)        dcl 1944 in procedure "copy_dump_tape" set ref 1962
                                                                                  1962 1962 1962 1962 1966* 1966 1966 1967* 1967
                                                                                  1968* 1968 1969 1973* 2302*
line_buffer                            based           structure                level 1 dcl 1954
list                                   based           structure                level 1 dcl 2278
listp                   144     002502 automatic       pointer                  level 2 dcl 17 set ref 1363* 2299* 2300 2300 2316
                                                                                  2316 2336 2336 2348 2348 2348 2349 2349 2356 2356
                                                                                  2356 2356 2356 2356 2491 2491 2491 2492 2492 2492
                                                                                  2492 2492 2492 2492 2492 2499 2499 2500 2500 2501
                                                                                  2501 2502 2502 2502 2502 2504 2504 2506 2506 2506
                                                                                  2506 2506 2506 2506 2515 2515 2515 2515 2518 2518
                                                                                  2518 2518 2518 2518 2522 2522 2523 2523 2523 2523
                                                                                  2523 2523 2531 2531 2531 2531 2531 2531 2531 2531
                                                                                  2531 2531 2531 2531
ltrim                                                  builtin function         dcl 109 ref 404 1319 1630 1632 1967
lv                                     based           structure                level 1 dcl 1-74
map                             001240 automatic       structure                level 1 dcl 17 set ref 292 292 523 523 1366* 1370
                                                                                  1576 1576
map_header                      004005 automatic       varying char(300)        dcl 1473 set ref 1511* 1512* 1512 1514* 1514 1515*
                                                                                  1515 1517
map_last_dir                    002707 automatic       char(168)                unaligned dcl 1399 set ref 1429 1430* 1521* 1551*
map_line                        004304 automatic       char(300)                unaligned dcl 1541 in procedure "map_seg$new_tape"
                                                                                  set ref 1547* 1548 1548 1548 1548
map_line                        004121 automatic       char(300)                unaligned dcl 1473 in procedure "map_seg$init" set
                                                                                  ref 1505 1505 1505 1505 1508* 1509 1509 1509 1509
                                                                                  1517* 1518 1518 1518 1518
map_prev                        001404 automatic       structure                level 1 dcl 17 set ref 1370* 1484 1484 1575 1575
matched                                parameter       bit(1)                   unaligned dcl 2309 in procedure "add_to_select_list"
                                                                                  ref 2306 2326
matched                  55(20)        based           bit(1)                   array level 3 in structure "list" packed unaligned
                                                                                  dcl 2278 in procedure "skip_seg$init" set ref 2349
                                                                                  2501*
matched                  53(20) 004704 automatic       bit(1)                   level 2 in structure "en" packed unaligned dcl 2314
                                                                                  in procedure "add_to_select_list" set ref 2326*
max                                                    builtin function         dcl 109 ref 334 376 633 795 1234
maximize_devices_sw             001633 automatic       bit(1)                   unaligned dcl 17 set ref 1374* 1620 1814* 1816* 2846
maxlen                          003714 automatic       fixed bin(17,0)          dcl 1270 set ref 1282* 1283* 1286
maxlength                                              builtin function         dcl 109 ref 2554 2554 2554 2554 2554 2554 2563 2563
                                                                                  2563 2563 2563 2563 2575 2575 2575 2575 2575 2575
mbf                                    parameter       structure                level 1 dcl 2422 in procedure "skip_seg$init" ref
                                                                                  2420
mbf                                    based           structure                level 1 dcl 17 in procedure "copy_dump_tape" set ref
                                                                                  699* 729* 730* 736* 757* 761*
mhe                                    based           structure                level 1 dcl 2431 in procedure "skip_seg$init"
mhe                                    based           structure                level 1 dcl 17 in procedure "copy_dump_tape"
mhe_name                               based           structure                level 1 dcl 17 in procedure "copy_dump_tape"
mhe_name                               based           structure                level 1 dcl 2431 in procedure "skip_seg$init"
min                                                    builtin function         dcl 109 ref 1436 2492
mlast                           001547 automatic       structure                level 1 dcl 17 set ref 699* 730* 736* 757*
mod                                                    builtin function         dcl 109 ref 299 1747 1840 1843 1847 1859 2073 2088
                                                                                  2152 2222 2809 3075 3081
mode                                   parameter       fixed bin(17,0)          dcl 393 in procedure "attach" set ref 391 401 406
                                                                                  413 419* 420 423
mode                     10            based           fixed bin(17,0)          level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach" ref 892
mode                     10            based           fixed bin(17,0)          level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 401*
mode                     10            parameter       fixed bin(17,0)          level 3 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1620 1641 1645* 1646
                                                                                  1650
mode                     10     000374 automatic       fixed bin(17,0)          level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1348*
model                     6     005000 automatic       fixed bin(17,0)          level 2 dcl 2645 set ref 2658*
msfs                      1     000110 automatic       fixed bin(17,0)          level 2 in structure "compared" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 332 336* 336 711* 711
                                                                                  763* 763 789* 789
msfs                      1     000112 automatic       fixed bin(17,0)          level 2 in structure "copied" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 332 336* 336 842* 842
                                                                                  860* 860
n                                      based           fixed bin(17,0)          level 2 in structure "list" dcl 2278 in procedure
                                                                                  "skip_seg$init" set ref 2300* 2316* 2316 2336 2348
                                                                                  2491
n                                      based           structure                array level 1 dcl 1403 in procedure "map_seg"
n_channels                      003276 automatic       fixed bin(17,0)          initial level 2 in structure "event_wait_channel"
                                                                                  dcl 5-8 in procedure "copy_dump_tape" set ref 5-8*
n_channels                2     003076 automatic       fixed bin(17,0)          initial level 3 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2620* 2859*
name                    143            based           char(32)                 array level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 432*
name                                   parameter       char(32)                 level 2 in structure "vol" dcl 2727 in procedure
                                                                                  "tape_drive$find_device" ref 2737 2743
name                            002502 automatic       varying char(8)          level 3 in structure "select" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1362* 1820
name                    143            based           char(32)                 array level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach" set ref 909* 924* 927*
name                    143            parameter       char(32)                 array level 3 in structure "io" dcl 1602
                                                                                  in procedure "mount_next_tape_vol" set ref 1619
                                                                                  1635* 1641* 1646* 1652* 1657*
name                    143            parameter       char(32)                 array level 3 in structure "out" dcl 1471
                                                                                  in procedure "map_seg$init" ref 1498
name                    143     001636 automatic       char(32)                 array level 3 in structure "output" dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 309* 313 316
                                                                                  1894
name                                   based           varying char(8)          level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 404 416* 420* 423* 432*
name                    143            parameter       char(32)                 array level 3 in structure "out" dcl 1539
                                                                                  in procedure "map_seg$new_tape" ref 1547
name                                   parameter       varying char(8)          level 3 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3055* 3104*
name                                   based           varying char(8)          level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach" set ref 903* 909* 918* 924* 927*
name                    143            parameter       char(32)                 array level 3 in structure "in" dcl 2006
                                                                                  in procedure "read_seg$header" set ref 2052* 2103*
                                                                                  2173* 2242*
name                            001404 automatic       varying char(8)          level 3 in structure "map_prev" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1371*
name                      1            based           char(32)                 level 2 in structure "iocb" dcl 7-6 in procedure
                                                                                  "copy_dump_tape" set ref 1481 1489 1492*
name                            001636 automatic       varying char(8)          level 3 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 309* 1356* 1358*
name                                   parameter       varying char(8)          level 3 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1620 1635* 1641*
                                                                                  1646* 1652* 1657*
name                    143            parameter       char(32)                 array level 3 in structure "out" dcl 1266
                                                                                  in procedure "medium" set ref 1286 1287* 1293*
name                                   parameter       varying char(8)          level 3 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2036* 2052* 2083* 2103*
                                                                                  2144* 2173* 2214* 2242*
name                    143            based           char(32)                 array level 3 in structure "in_out" dcl 84
                                                                                  in procedure "copy_dump_tape" set ref 1706* 1715*
name                                   based           varying char(8)          level 3 in structure "in" dcl 1949 in procedure
                                                                                  "read_line" set ref 1976*
name                                   parameter       varying char(8)          level 3 in structure "out" dcl 1243 in procedure
                                                                                  "label" ref 1250
name                                   parameter       char                     unaligned dcl 1243 in procedure "label" ref 1240
                                                                                  1248
name                                   based           varying char(8)          level 3 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape" ref 1703 1726
name                    143            parameter       char(32)                 array level 3 in structure "out" dcl 3019
                                                                                  in procedure "write_seg" set ref 3104*
name                            000374 automatic       varying char(8)          level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1342* 1344*
name                            001240 automatic       varying char(8)          level 3 in structure "map" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1367*
name                      6     003076 automatic       char(32)                 array level 3 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2656 2675*
                                                                                  2702* 2740 2793 2817 2824 2850* 2872* 2880 2893
                                                                                  2900* 2909* 2939* 2988*
namerp                   21(18)        based           bit(18)                  level 2 packed unaligned dcl 1403 ref 1445
ndc_directory                          constant        fixed bin(17,0)          initial dcl 4-20 ref 711 763 842 2445
ndc_directory_list                     constant        fixed bin(17,0)          initial dcl 4-22 ref 1446 2445 2504
ndc_segment                            constant        fixed bin(17,0)          initial dcl 4-18 ref 2442
need_copy                              parameter       bit(1)                   unaligned dcl 2422 in procedure "skip_seg$init" ref
                                                                                  2420 2461
need_copy                       003471 automatic       bit(1)                   unaligned dcl 667 in procedure "compare_segs" set
                                                                                  ref 687* 689 693* 703 725* 729* 734 767* 778*
need_master                     003472 automatic       bit(1)                   unaligned dcl 667 set ref 686* 698 699* 703 708 731*
                                                                                  737* 738 750* 758* 767* 775*
nn                              003740 automatic       fixed bin(17,0)          dcl 1403 set ref 1445* 1446
nnames                   22(19)        based           bit(17)                  level 2 packed unaligned dcl 1403 ref 1445
np                              003742 automatic       pointer                  dcl 1403 set ref 1445* 1448 1448 1448
null                                                   builtin function         dcl 109 ref 255 415 415 526 672 674 890 896 900 915
                                                                                  935 938 1282 1282 1346 1347 1363 1380 1481 1481
                                                                                  1489 1489 1572 1607 1640 1640 2042
num_attach                3            based           fixed bin(17,0)          level 3 dcl 1-19 ref 2735 2790 2868
num_dassign               2            based           fixed bin(17,0)          level 3 dcl 1-19 ref 2736 2791 2868 2880 2884 2890
num_device_resv           4            based           fixed bin(17,0)          level 3 dcl 1-19 ref 2867
num_lv                    1            based           fixed bin(17,0)          level 3 dcl 1-19 ref 2868
num_opt                         002674 automatic       fixed bin(17,0)          dcl 457 set ref 1127* 1127 1128 1769 1775
nx                              003744 automatic       fixed bin(17,0)          dcl 1403 set ref 1446* 1448 1448 1448*
op                                     parameter       char                     unaligned dcl 1219 set ref 1217 1229*
open_descrip_ptr         20            based           pointer                  level 2 dcl 7-6 ref 900 1607 2042
operation_now                   001634 automatic       fixed bin(17,0)          dcl 17 set ref 300* 323* 331* 2435 2549
operation_wanted                001635 automatic       fixed bin(17,0)          dcl 17 set ref 228* 238* 299 322 330 361* 1342 1356
                                                                                  1620 1689 1747 1756 1761 1806 1821 1840 1840* 1843
                                                                                  1843* 1847 1859 1884
opr_auth                 27     005000 automatic       bit(1)                   level 2 dcl 2645 set ref 2668*
opt                                    based           char                     unaligned dcl 457 set ref 1126 1127 1135* 1173 1706
                                                                                  1709* 1715 1729 1732* 1787 1787 1787 1789 1791
                                                                                  1791 1793 1793 1795 1795 1797* 1827 1830* 1851
                                                                                  1854*
opt_desc                        004536 automatic       char(32)                 unaligned dcl 1687 in procedure "process_args" set
                                                                                  ref 1703* 1704* 1726* 1727* 1820* 1826*
opt_desc                               parameter       char                     unaligned dcl 1163 in procedure "get_opt" set ref
                                                                                  1161 1180 1182* 1182* 1182*
opt_desc                               parameter       char                     unaligned dcl 1109 in procedure "get_num_opt" set
                                                                                  ref 1105 1135* 1135* 1135* 1148 1149* 1149* 1149*
optl                            002675 automatic       fixed bin(21,0)          dcl 457 set ref 1125* 1126 1127 1135 1135 1172* 1173
                                                                                  1706 1709 1709 1715 1729 1732 1732 1787 1787 1787
                                                                                  1789 1791 1791 1793 1793 1795 1795 1797 1797 1827
                                                                                  1830 1830 1851 1854 1854
optp                            002676 automatic       pointer                  dcl 457 set ref 1125* 1126 1127 1135 1172* 1173 1706
                                                                                  1709 1715 1729 1732 1787 1787 1787 1789 1791 1791
                                                                                  1793 1793 1795 1795 1797 1827 1830 1851 1854
out                                    parameter       structure                level 1 dcl 3019 in procedure "write_seg" set ref
                                                                                  3017 3097* 3098*
out                                    parameter       structure                level 1 dcl 1539 in procedure "map_seg$new_tape" ref
                                                                                  1536
out                                    parameter       structure                level 1 dcl 1266 in procedure "medium" set ref 1263
out                                    parameter       structure                level 1 dcl 1219 in procedure "header" set ref 1217
                                                                                  1233* 1236*
out                                    parameter       structure                level 1 dcl 1243 in procedure "label" ref 1240
out                                    parameter       structure                level 1 dcl 1471 in procedure "map_seg$init" set ref
                                                                                  1468
out_header                      004234 automatic       varying char(128)        dcl 1473 set ref 1496* 1498* 1500* 1502* 1508
output                          001636 automatic       structure                level 1 dcl 17 set ref 301* 303 303 304* 324* 326
                                                                                  326 522 522 690* 691* 786 786 839* 857 857 1355*
                                                                                  1361 1366 1740 1744 1749 1763
pad1                     53(22) 004704 automatic       bit(14)                  level 2 packed unaligned dcl 2314 set ref 2328*
path                     12            parameter       char(168)                level 4 in structure "out" packed unaligned dcl 1266
                                                                                  in procedure "medium" ref 1276
path                      2            based           varying char(168)        array level 3 in structure "list" dcl 2278
                                                                                  in procedure "skip_seg$init" set ref 2356* 2492
                                                                                  2492 2492 2499 2518 2531 2531 2531
path                     12     000374 automatic       char(168)                level 4 in structure "input" packed unaligned dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 1350* 1870
path                     12            based           char(168)                level 4 in structure "in_out" packed unaligned
                                                                                  dcl 84 in procedure "copy_dump_tape" set ref 1702*
                                                                                  1725* 1729* 1730* 1753*
path                            000160 automatic       structure                level 2 in structure "cplast" packed unaligned
                                                                                  dcl 17 in procedure "copy_dump_tape" set ref 681*
path                     12            parameter       char(168)                level 4 in structure "out" packed unaligned dcl 1471
                                                                                  in procedure "map_seg$init" set ref 1496 1496*
path                            001547 automatic       structure                level 2 in structure "mlast" packed unaligned dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 679*
path                            000310 automatic       structure                level 2 in structure "inlast" packed unaligned
                                                                                  dcl 17 in procedure "copy_dump_tape" set ref 827*
path                            004704 automatic       varying char(168)        level 2 in structure "en" dcl 2314 in procedure
                                                                                  "add_to_select_list" set ref 2318* 2322* 2330 2330
                                                                                  2330 2333* 2333 2333
path                     12            based           char(168)                level 4 in structure "io" packed unaligned dcl 393
                                                                                  in procedure "attach" set ref 411
path                     12            parameter       char(168)                level 4 in structure "out" packed unaligned dcl 1243
                                                                                  in procedure "label" ref 1251
path                     12     002502 automatic       char(168)                level 4 in structure "select" packed unaligned
                                                                                  dcl 17 in procedure "copy_dump_tape" set ref 281
                                                                                  1513 1827* 1828* 1836* 1896 1896* 2345 2435 2456
path                     12            parameter       char(168)                level 4 in structure "in" packed unaligned dcl 2006
                                                                                  in procedure "read_seg$header" set ref 2018 2127
                                                                                  2197
path                     12            based           char(168)                level 4 in structure "io" packed unaligned dcl 885
                                                                                  in procedure "detach" ref 901 916
path                     12            parameter       char(168)                level 4 in structure "out" packed unaligned dcl 3019
                                                                                  in procedure "write_seg" set ref 3031
path                                   parameter       structure                level 2 in structure "last" packed unaligned
                                                                                  dcl 2006 in procedure "read_seg$header"
path                            004607 automatic       varying char(168)        level 2 in structure "seg" dcl 2426 in procedure
                                                                                  "skip_seg$init" set ref 2439* 2492 2492 2492 2499
                                                                                  2506* 2523* 2531 2531 2554 2554 2563 2563 2575
                                                                                  2575
path                                   parameter       char(168)                unaligned dcl 1063 in procedure "get_entry" set ref
                                                                                  1060 1071*
path                     12     001636 automatic       char(168)                level 4 in structure "output" packed unaligned
                                                                                  dcl 17 in procedure "copy_dump_tape" set ref 1874
                                                                                  1892 1892*
path                     12     001240 automatic       char(168)                level 4 in structure "map" packed unaligned dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 290 1368*
                                                                                  1426 1478 1543 1570 1848* 1851* 1852* 1861* 1889
                                                                                  1889* 1891 1892* 1894* 1896* 1898* 1900* 1902*
pathname_                       000120 constant        entry                    external dcl 116 ref 567 567 567 567 575 575 575 575
                                                                                  593 593 593 593 604 604 604 604 621 621 621 621
                                                                                  715 715 740 740 2083 2083 2439
position_index           24     005000 automatic       fixed bin(35,0)          level 2 dcl 2645 set ref 2665*
pp                              003274 automatic       pointer                  dcl 3121 set ref 1385* 1385
printed                         003715 automatic       fixed bin(17,0)          dcl 1270 set ref 1284* 1287* 1287 1289* 1293* 1293
ptr                                                    builtin function         dcl 109 ref 1435 1445
qualifiers                5            based           fixed bin(35,0)          array level 2 dcl 1-41 ref 2901 2902
rcp_$assign_device              000122 constant        entry                    external dcl 116 ref 2670
rcp_$check_assign               000124 constant        entry                    external dcl 116 ref 2680
rcp_$copy_list                  000126 constant        entry                    external dcl 116 ref 2734 2787 2863 2887
rcp_$unassign                   000130 constant        entry                    external dcl 116 ref 2987
rcp_id                   30     003076 automatic       bit(36)                  array level 3 dcl 2620 set ref 2670* 2680* 2854*
                                                                                  2941* 2987*
readl                           004574 automatic       fixed bin(21,0)          dcl 2011 set ref 2019* 2021 2023 2026* 2028 2030
                                                                                  2048* 2050 2074* 2076 2129* 2131 2133 2153* 2155
                                                                                  2199* 2200 2203
readneed                        004575 automatic       fixed bin(21,0)          dcl 2011 set ref 2072* 2073* 2073 2073 2074 2076
                                                                                  2087* 2088* 2088 2088 2089 2151* 2152* 2152 2152
                                                                                  2153 2155 2221* 2222* 2222 2222 2223
record_type              65            based           fixed bin(17,0)          level 2 in structure "mhe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 763 763
record_type              65            based           fixed bin(17,0)          level 2 in structure "inhe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 842 842
record_type              65            based           fixed bin(17,0)          level 2 in structure "cphe" dcl 17 in procedure
                                                                                  "copy_dump_tape" ref 711 711
record_type              65            based           fixed bin(17,0)          level 2 in structure "mhe" dcl 2431 in procedure
                                                                                  "skip_seg$init" ref 2440 2442 2442 2445 2445 2445
                                                                                  2504 2554 2563 2575
record_type              65            based           fixed bin(17,0)          level 2 in structure "he" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1434 1446
recx                     11     000374 automatic       fixed bin(17,0)          level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1349*
recx                     11            parameter       fixed bin(17,0)          level 3 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2036 2052* 2103 2134*
                                                                                  2134 2139* 2139 2144 2157* 2157 2173 2204* 2204
                                                                                  2209* 2209 2214 2226* 2226 2242
recx                     11            based           fixed bin(17,0)          level 3 in structure "in" dcl 1949 in procedure
                                                                                  "read_line" set ref 1965* 1965 1976*
recx                     11            based           fixed bin(17,0)          level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 402*
recx                     11     002502 automatic       fixed bin(17,0)          level 3 in structure "select" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 285*
recx                     11            parameter       fixed bin(17,0)          level 3 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3042* 3042 3047* 3047 3055
                                                                                  3091* 3091 3104 3112* 3112
result                          000102 automatic       varying char(6)          dcl 1309 set ref 1317* 1318* 1318 1319* 1319 1320
ret                                    based           varying char             dcl 457 set ref 498*
retl                            002700 automatic       fixed bin(21,0)          dcl 457 set ref 492* 498
retp                            002702 automatic       pointer                  dcl 457 set ref 492* 498
rli                                    based           structure                level 1 dcl 1-19
rli_header                             based           structure                level 1 dcl 1-33
rli_ptr                         005054 automatic       pointer                  dcl 1-10 set ref 2734* 2735 2736 2787* 2790 2791
                                                                                  2861* 2862 2863* 2867 2868 2880 2880 2884 2887*
                                                                                  2890 2891
rli_version_4                          constant        fixed bin(17,0)          initial dcl 1-17 ref 2862
rtrim                                                  builtin function         dcl 109 ref 404 412 567 567 567 567 575 575 575 575
                                                                                  593 593 593 593 604 604 604 604 621 621 621 621
                                                                                  715 715 740 740 1509 1509 1511 1548 1548 1619 1627
                                                                                  1968 2083 2083 2439
sci_ptr                         002704 automatic       pointer                  dcl 457 set ref 255* 258* 285* 309* 336* 361* 403*
                                                                                  416* 420* 423* 432* 492* 493* 495* 526 526* 567*
                                                                                  575* 593* 604* 621* 672* 674* 676* 677* 715* 740*
                                                                                  789* 824* 825* 848* 860* 903* 909* 918* 924* 927*
                                                                                  1020* 1046* 1125* 1135* 1149* 1172* 1182* 1229*
                                                                                  1487* 1492* 1635* 1641* 1646* 1652* 1657* 1689*
                                                                                  1709* 1732* 1797* 1830* 1854* 1863* 1867* 1870*
                                                                                  1874* 1884* 1902* 1924* 1976* 2036* 2052* 2083*
                                                                                  2103* 2144* 2173* 2214* 2242* 2299* 2352* 2506*
                                                                                  2675* 2694* 2702* 2858* 2861* 2864* 2909* 2914*
                                                                                  2988* 3055* 3104*
search                                                 builtin function         dcl 109 ref 1199
sec_dir                                constant        fixed bin(17,0)          initial dcl 4-26 ref 711 763 842 2445
sec_seg                                constant        fixed bin(17,0)          initial dcl 4-24 ref 2442
seg                             004607 automatic       structure                level 1 dcl 2426 in procedure "skip_seg$init"
seg                             003746 automatic       structure                level 1 dcl 1403 in procedure "map_seg"
seg                      63            parameter       fixed bin(35,0)          level 3 in structure "last" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2078 2161* 2230*
seg1_words                             based           fixed bin(35,0)          array dcl 557 set ref 604 604 604 611 614 614 615
                                                                                  621*
seg2_words                             based           fixed bin(35,0)          array dcl 557 set ref 604 604 604 611 615 621*
segl                     37     000244 automatic       fixed bin(21,0)          level 4 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1379*
segl                     37            parameter       fixed bin(21,0)          level 4 in structure "bf1" dcl 550 in procedure
                                                                                  "compare_seg" ref 604 604 604 611 614
segl                     37            parameter       fixed bin(21,0)          level 4 in structure "mbf" dcl 2422 in procedure
                                                                                  "skip_seg$init" ref 2463
segl                     37            parameter       fixed bin(21,0)          level 4 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2078 2087 2128 2129 2131
                                                                                  2150 2151 2161 2198 2199 2220 2221 2230
segl                     37            parameter       fixed bin(21,0)          level 4 in structure "cpbf" dcl 2422 in procedure
                                                                                  "skip_seg$init" ref 2463
segl                     37            parameter       fixed bin(21,0)          level 4 in structure "bf2" dcl 550 in procedure
                                                                                  "compare_seg" ref 604 604 604 611
segl                     37            parameter       fixed bin(21,0)          level 4 in structure "bf" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3038 3039 3079 3080
segp                     42     000114 automatic       pointer                  level 2 in structure "cpbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 677*
segp                     42     000244 automatic       pointer                  level 2 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 825* 1380*
segp                     42            parameter       pointer                  level 2 in structure "bf2" dcl 550 in procedure
                                                                                  "compare_seg" ref 604 604 604 611 615 621
segp                     42            based           pointer                  level 2 in structure "mbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 674 674*
segp                     42            parameter       pointer                  level 2 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2129* 2153*
segp                     42            parameter       pointer                  level 2 in structure "bf" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3039* 3082*
segp                     42            parameter       pointer                  level 2 in structure "bf1" dcl 550 in procedure
                                                                                  "compare_seg" ref 604 604 604 611 614 614 615 621
segs                            000112 automatic       fixed bin(17,0)          level 2 in structure "copied" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 332 336* 336 841* 841
                                                                                  860* 860
segs                            000110 automatic       fixed bin(17,0)          level 2 in structure "compared" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 332 336* 336 710* 710
                                                                                  715* 740 761 762* 762 789* 789
segx                                   parameter       fixed bin(17,0)          dcl 550 set ref 547 567* 575* 593* 604* 621*
select                          002502 automatic       structure                level 1 dcl 17 set ref 283 283 287 287 524 524 1361*
                                                                                  2301 2301
select_sw               146     002502 automatic       bit(1)                   level 2 dcl 17 set ref 1364* 1825* 1837* 2459
selected_dx                     005042 automatic       fixed bin(17,0)          dcl 2772 set ref 2812* 2813 2821* 2822 2824 2824
severity                               based           fixed bin(17,0)          dcl 84 set ref 253* 334* 334 361 376* 376 633* 633
                                                                                  795* 795 2359*
severityp                       002656 automatic       pointer                  dcl 84 set ref 229* 239* 253 334 334 361 376 376 633
                                                                                  633 795 795 2359
size                                                   builtin function         dcl 2016 in procedure "read_seg$header" ref 2019
                                                                                  2021 2048 2050 2072 2073
size                                                   builtin function         dcl 3029 in procedure "write_seg" ref 3032 3062 3074
                                                                                  3075
sizes                    62     000160 automatic       structure                level 2 in structure "cplast" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 682*
sizes                    36     000114 automatic       structure                level 3 in structure "cpbf" dcl 17 in procedure
                                                                                  "copy_dump_tape"
sizes                    36            parameter       structure                level 3 in structure "bf" dcl 1403 in procedure
                                                                                  "map_seg"
sizes                    36     000244 automatic       structure                level 3 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape"
sizes                    62     001547 automatic       structure                level 2 in structure "mlast" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 680*
sizes                    36            parameter       structure                level 3 in structure "bf" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3032 3032
sizes                    36            parameter       structure                level 3 in structure "mbf" dcl 2422 in procedure
                                                                                  "skip_seg$init"
sizes                    36            parameter       structure                level 3 in structure "cpbf" dcl 2422 in procedure
                                                                                  "skip_seg$init"
sizes                    36            based           structure                level 3 in structure "mbf" dcl 17 in procedure
                                                                                  "copy_dump_tape"
sizes                    62            parameter       structure                level 2 in structure "last" dcl 2006 in procedure
                                                                                  "read_seg$header"
sizes                    62     000310 automatic       structure                level 2 in structure "inlast" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 828*
sizes                    36            parameter       structure                level 3 in structure "bf1" dcl 550 in procedure
                                                                                  "compare_seg"
sizes                    36            based           structure                level 2 in structure "blrh" dcl 2011 in procedure
                                                                                  "read_seg$header"
sizes                    36            based           structure                level 2 in structure "blrh" dcl 3025 in procedure
                                                                                  "write_seg"
sizes                    36            parameter       structure                level 3 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2019 2019
sizes                    36            parameter       structure                level 3 in structure "bf2" dcl 550 in procedure
                                                                                  "compare_seg"
speed                    11     005000 automatic       bit(36)                  level 2 dcl 2645 set ref 2661*
ss                        1     000100 automatic       picture(2)               level 2 packed unaligned dcl 1309 set ref 1319
ssu_$abort_subsystem            000174 constant        entry                    external dcl 472 ref 999 999
ssu_$arg_ptr                    000176 constant        entry                    external dcl 472 ref 1020 1125 1172
ssu_$destroy_invocation         000200 constant        entry                    external dcl 472 ref 526
ssu_$get_invocation_count       000132 constant        entry                    external dcl 116 ref 403
ssu_$get_temp_segment           000134 constant        entry                    external dcl 116 ref 672 674 676 677 824 825 2299
                                                                                  2861
ssu_$print_message              000202 constant        entry                    external dcl 472 ref 285 309 361 423 789 860 927 975
                                                                                  975 1229 1635 1657 2083 2909
ssu_$return_arg                 000204 constant        entry                    external dcl 472 ref 492
ssu_$standalone_invocation      000206 constant        entry                    external dcl 472 ref 258
state                    54     004607 automatic       fixed bin(17,0)          level 2 in structure "seg" dcl 2426 in procedure
                                                                                  "skip_seg$init" set ref 2453* 2456* 2461* 2463*
                                                                                  2492* 2500* 2522* 2531* 2550 2550 2550 2550 2554
                                                                                  2563 2563 2563 2563 2563 2575 2589 2589 2589 2589
state                           002651 automatic       fixed bin(17,0)          dcl 17 in procedure "copy_dump_tape" set ref 691*
                                                                                  692 693 730* 736* 737 757* 758 830* 831 832* 835*
                                                                                  836 837
statex                          004777 automatic       fixed bin(17,0)          dcl 2645 set ref 2680* 2683
str                                    parameter       char                     unaligned dcl 1195 ref 1191 1199
string                                                 builtin function         dcl 109 in procedure "copy_dump_tape" set ref 1316*
                                                                                  1316
string                    1            based           char(32)                 array level 2 in structure "n" packed unaligned
                                                                                  dcl 1403 in procedure "map_seg" set ref 1448 1448
substr                                                 builtin function         dcl 109 ref 1199 1316 1966 2317 2318 2330 2333 2492
                                                                                  2531 2656 2817 2869
subtree                  55(19)        based           bit(1)                   array level 3 in structure "list" packed unaligned
                                                                                  dcl 2278 in procedure "skip_seg$init" set ref
                                                                                  2356* 2515* 2523 2531
subtree                  53(19) 004704 automatic       bit(1)                   level 2 in structure "en" packed unaligned dcl 2314
                                                                                  in procedure "add_to_select_list" set ref 2329*
                                                                                  2334*
sys_info$page_size              000234 external static fixed bin(17,0)          dcl 1423 ref 1436 1436
sys_info$seg_size_256K          000236 external static fixed bin(17,0)          dcl 1423 ref 1436
system_flag               3     005000 automatic       bit(1)                   level 2 dcl 2645 set ref 2655*
tape                    137            based           structure                level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach"
tape                    137            parameter       structure                level 3 in structure "out" dcl 1471 in procedure
                                                                                  "map_seg$init"
tape                    137     001636 automatic       structure                level 3 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape"
tape                    137            parameter       structure                level 3 in structure "out" dcl 1266 in procedure
                                                                                  "medium"
tape                    137            parameter       structure                level 3 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol"
tape                    137            parameter       structure                level 3 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg"
tape                    137            based           structure                level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach"
tape                    137     000374 automatic       structure                level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape"
tape                    137            based           structure                level 3 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape"
tape                    137            parameter       structure                level 3 in structure "out" dcl 1243 in procedure
                                                                                  "label"
tape                    137            parameter       structure                level 3 in structure "out" dcl 1539 in procedure
                                                                                  "map_seg$new_tape"
tape                    137            parameter       structure                level 3 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header"
tape                    137            parameter       structure                level 3 in structure "io" dcl 2770 in procedure
                                                                                  "tape_drive$find_device"
tape_drives                     003076 automatic       structure                level 1 dcl 2620
tape_info                              based           structure                level 1 dcl 10-15
tape_info_version_3                    constant        fixed bin(17,0)          initial dcl 10-13 ref 2652
target_iocbp              6     000374 automatic       pointer                  level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1347*
target_iocbp              6     001404 automatic       pointer                  level 3 in structure "map_prev" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1485*
target_iocbp              6            based           pointer                  level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach" set ref 894* 895*
target_iocbp              6            based           pointer                  level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 406*
ti                              005000 automatic       structure                level 1 dcl 2645 set ref 2670 2670 2680 2680
time                                                   builtin function         dcl 1314 ref 1316
time_form                       000100 automatic       structure                level 1 dcl 1309 set ref 1316* 1316
to                              003663 automatic       varying char(32)         dcl 1223 set ref 1233* 1234 1236*
trace                           002652 automatic       fixed bin(17,0)          dcl 17 set ref 423 1375* 1635 1787* 1789* 1791*
                                                                                  1793* 1795* 1806* 1808* 1811* 2435 2435 2435 2549
                                                                                  2562 2574
track                    26     003076 automatic       fixed bin(17,0)          array level 3 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2817 2852*
                                                                                  2901* 2940*
track                   141            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 2770 in procedure
                                                                                  "tape_drive$find_device" ref 2817
track                   141            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1632
track                   141     000374 automatic       fixed bin(17,0)          level 4 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1352* 1700* 1880 1880*
track                   141            based           fixed bin(17,0)          level 4 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape" set ref 1724* 1752* 1769*
track                   141     001636 automatic       fixed bin(17,0)          level 4 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1882 1882*
tracks                    7     005000 automatic       fixed bin(17,0)          level 2 dcl 2645 set ref 2659*
type                            003746 automatic       char(10)                 level 2 in structure "seg" dcl 1403 in procedure
                                                                                  "map_seg" set ref 1434* 1442*
type                     55            based           fixed bin(17,0)          array level 3 in structure "list" packed unaligned
                                                                                  dcl 2278 in procedure "skip_seg$init" set ref 2502
                                                                                  2502* 2504 2506 2506 2515 2518 2518 2523 2531
type                     53     004704 automatic       fixed bin(17,0)          level 2 in structure "en" packed unaligned dcl 2314
                                                                                  in procedure "add_to_select_list" set ref 2325*
type                     53     004607 automatic       fixed bin(17,0)          level 2 in structure "seg" dcl 2426 in procedure
                                                                                  "skip_seg$init" set ref 2440* 2442* 2445* 2449
                                                                                  2449* 2492 2502 2506 2506 2518 2523 2554 2554 2563
                                                                                  2563 2575 2575
type                                   parameter       fixed bin(17,0)          dcl 2309 in procedure "add_to_select_list" ref 2306
                                                                                  2325
unique_chars_                   000136 constant        entry                    external dcl 116 ref 1898
unspec                                                 builtin function         dcl 109 ref 583 583 611 611 2902
unused_qualifier         12     005000 automatic       bit(36)                  level 2 dcl 2645 set ref 2662*
unwanted_device                 005043 automatic       char(32)                 unaligned dcl 2772 set ref 2776* 2782* 2817
usage_time                1     005000 automatic       fixed bin(17,0)          level 2 dcl 2645 set ref 2653*
valx                            003626 automatic       fixed bin(17,0)          dcl 1114 set ref 1128* 1128* 1132
verify                                                 builtin function         dcl 109 ref 1126
version_num                     005000 automatic       fixed bin(17,0)          level 2 in structure "ti" dcl 2645 in procedure
                                                                                  "tape_drive$assign" set ref 2652*
version_num                            based           fixed bin(17,0)          level 3 in structure "rli" dcl 1-19 in procedure
                                                                                  "tape_drive$find_device" set ref 2862*
vfile                    12     001240 automatic       structure                level 3 in structure "map" dcl 17 in procedure
                                                                                  "copy_dump_tape"
vfile                    12            based           structure                level 3 in structure "in" dcl 1949 in procedure
                                                                                  "read_line"
vfile                    12     001636 automatic       structure                level 3 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape"
vfile                    12            parameter       structure                level 3 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg"
vfile                    12     002502 automatic       structure                level 3 in structure "select" dcl 17 in procedure
                                                                                  "copy_dump_tape"
vfile                    12            parameter       structure                level 3 in structure "out" dcl 1471 in procedure
                                                                                  "map_seg$init"
vfile                    12            based           structure                level 3 in structure "io" dcl 885 in procedure
                                                                                  "detach"
vfile                    12            based           structure                level 3 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape"
vfile                    12            parameter       structure                level 3 in structure "out" dcl 1266 in procedure
                                                                                  "medium"
vfile                    12            parameter       structure                level 3 in structure "out" dcl 1243 in procedure
                                                                                  "label"
vfile                    12     000374 automatic       structure                level 3 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape"
vfile                    12            parameter       structure                level 3 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header"
vfile                    12            based           structure                level 3 in structure "io" dcl 393 in procedure
                                                                                  "attach"
vol                     143            parameter       structure                array level 2 in structure "out" dcl 1266
                                                                                  in procedure "medium"
vol                     143     000374 automatic       structure                array level 2 in structure "input" dcl 17
                                                                                  in procedure "copy_dump_tape" set ref 1353*
vol                     143            parameter       structure                array level 2 in structure "in" dcl 2006
                                                                                  in procedure "read_seg$header"
vol                     143            based           structure                array level 2 in structure "in_out" dcl 84
                                                                                  in procedure "copy_dump_tape" set ref 1699* 1709
                                                                                  1709 1709 1723* 1751*
vol                      16     003076 automatic       char(32)                 array level 3 in structure "tape_drives" dcl 2620
                                                                                  in procedure "copy_dump_tape" set ref 2743* 2789*
                                                                                  2796* 2817 2851* 2939*
vol                     143            parameter       structure                array level 2 in structure "out" dcl 1539
                                                                                  in procedure "map_seg$new_tape"
vol                     143            parameter       structure                array level 2 in structure "io" dcl 1602
                                                                                  in procedure "mount_next_tape_vol" set ref 1656*
vol                     143            parameter       structure                array level 2 in structure "out" dcl 3019
                                                                                  in procedure "write_seg"
vol                     143            parameter       structure                array level 2 in structure "io" dcl 2770
                                                                                  in procedure "tape_drive$find_device"
vol                                    parameter       structure                level 1 dcl 2727 in procedure
                                                                                  "tape_drive$find_device" set ref 2724
vol                     143            based           structure                array level 2 in structure "io" dcl 393 in procedure
                                                                                  "attach"
vol                     143     001636 automatic       structure                array level 2 in structure "output" dcl 17
                                                                                  in procedure "copy_dump_tape"
vol                     143            parameter       structure                array level 2 in structure "out" dcl 1471
                                                                                  in procedure "map_seg$init"
vol                     143            based           structure                array level 2 in structure "io" dcl 885 in procedure
                                                                                  "detach"
vol_resv                               based           structure                level 1 dcl 1-85
voln                    137     001636 automatic       fixed bin(17,0)          level 4 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 296 306 307* 309* 309
                                                                                  309* 314 1874 1884 1894
voln                    137     000374 automatic       fixed bin(17,0)          level 4 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 296 1351* 1870
voln                    137            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3061
voln                    137            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1610
voln                    137            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 1266 in procedure
                                                                                  "medium" ref 1278 1280 1285
voln                    137            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 1471 in procedure
                                                                                  "map_seg$init" ref 1498
voln                    137            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 1539 in procedure
                                                                                  "map_seg$new_tape" ref 1546
voln                    137            based           fixed bin(17,0)          level 4 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 429 432
voln                    137            based           fixed bin(17,0)          level 4 in structure "in_out" dcl 84 in procedure
                                                                                  "copy_dump_tape" set ref 1698* 1705* 1709 1714*
                                                                                  1714 1715 1722* 1750*
voln                    137            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 1243 in procedure
                                                                                  "label" ref 1253 1255
volume_density           26     005000 automatic       fixed bin(17,0)          level 2 dcl 2645 set ref 2667*
volume_name              13     005000 automatic       char(32)                 level 2 in structure "ti" dcl 2645 in procedure
                                                                                  "tape_drive$assign" set ref 2663*
volume_name               2            based           char(32)                 level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "tape_drive$find_device" ref 2737 2796
volume_type              25     005000 automatic       fixed bin(17,0)          level 2 dcl 2645 set ref 2666*
volx                    140            based           fixed bin(17,0)          level 4 in structure "io" dcl 393 in procedure
                                                                                  "attach" set ref 430*
volx                    140     001636 automatic       fixed bin(17,0)          level 4 in structure "output" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 307 314* 316*
volx                    140            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 1539 in procedure
                                                                                  "map_seg$new_tape" ref 1547
volx                    140            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 1602 in procedure
                                                                                  "mount_next_tape_vol" set ref 1610 1613* 1613 1614
                                                                                  1619 1625 1627 1635 1635 1635 1641 1646 1652 1656
                                                                                  1657
volx                    140            parameter       fixed bin(17,0)          level 4 in structure "in" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2052 2103 2173 2242
volx                    140     000374 automatic       fixed bin(17,0)          level 4 in structure "input" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1351*
volx                    140            parameter       fixed bin(17,0)          level 4 in structure "out" dcl 3019 in procedure
                                                                                  "write_seg" set ref 3104
volx                    140            parameter       fixed bin(17,0)          level 4 in structure "io" dcl 2770 in procedure
                                                                                  "tape_drive$find_device" ref 2776 2824
volx                    140            based           fixed bin(17,0)          level 4 in structure "io" dcl 885 in procedure
                                                                                  "detach" ref 909 924 927
wait_time                 2     005000 automatic       fixed bin(17,0)          level 2 dcl 2645 set ref 2654*
words_disagreeing               003455 automatic       fixed bin(18,0)          dcl 553 set ref 584* 588* 588 589 593 593* 612* 616*
                                                                                  616 617 621 621*
wordx                           003456 automatic       fixed bin(18,0)          dcl 553 set ref 586* 587 587 589* 614* 615 615 617*
write_flag               23     005000 automatic       bit(1)                   level 2 dcl 2645 set ref 2664*
writel                          005123 automatic       fixed bin(21,0)          dcl 3025 set ref 3074* 3075* 3075 3075 3076 3080*
                                                                                  3081* 3081 3081 3082
x                               003716 automatic       fixed bin(17,0)          dcl 1270 in procedure "medium" set ref 1285* 1286
                                                                                  1287 1289* 1293
x                         1            based           fixed bin(17,0)          level 2 in structure "list" dcl 2278 in procedure
                                                                                  "skip_seg$init" set ref 2300* 2348* 2349 2356 2356
                                                                                  2356* 2491* 2492 2492 2492 2492 2499 2500 2501
                                                                                  2502 2502 2504 2506 2506* 2506 2506 2515 2515 2518
                                                                                  2518 2518 2522 2523 2523 2523 2531 2531 2531 2531
                                                                                  2531 2531*
zz1                                    parameter       char(32)                 level 3 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2024* 2052 2052*
zz1                             000244 automatic       char(32)                 level 3 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1377*
zz2                      26     000244 automatic       char(32)                 level 3 in structure "inbf" dcl 17 in procedure
                                                                                  "copy_dump_tape" set ref 1377*
zz2                      26            parameter       char(32)                 level 3 in structure "bf" dcl 2006 in procedure
                                                                                  "read_seg$header" set ref 2024* 2052 2052*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 11-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 11-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 11-70
BITS_PER_WORD                          internal static fixed bin(6,0)           initial dcl 11-64
CHARS_PER_PAGE                         internal static fixed bin(13,0)          initial dcl 11-76
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 11-79
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 9-31
DISK_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 9-30
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 9-38
Direct_input                           internal static fixed bin(17,0)          initial dcl 8-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 8-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 8-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 8-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 8-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 8-15
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 9-36
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 9-22
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 11-92
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 9-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 9-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 9-34
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 9-35
Sequential_input                       internal static fixed bin(17,0)          initial dcl 8-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 8-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 8-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 8-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 8-15
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 9-37
VOLUME_TYPE                            internal static char(32)                 initial array unaligned dcl 9-25
WORDS_PER_PAGE                         internal static fixed bin(11,0)          initial dcl 11-84
author                                 based           char(32)                 dcl 3-61
event_wait_info_ptr                    automatic       pointer                  dcl 6-5
iox_$iocb_version_sentinel             external static char(4)                  dcl 7-51
lk                                     based           structure                array level 1 dcl 2-29
lv_ptr                                 automatic       pointer                  dcl 1-13
name                                   based           structure                array level 1 dcl 2-25
nnames                                 automatic       fixed bin(17,0)          dcl 2-23
old_path                               based           structure                level 1 dcl 2-42
path                                   based           structure                level 1 dcl 2-37
short_iox_modes                        internal static char(4)                  initial array dcl 8-12
tape_info_ptr                          automatic       pointer                  dcl 10-10
tape_info_version_2                    internal static fixed bin(17,0)          initial dcl 10-12
vol_resv_ptr                           automatic       pointer                  dcl 1-15

NAMES DECLARED BY EXPLICIT CONTEXT.
ASSIGN                          000000 constant        label                    array(0:3) dcl 2685 ref 2683
ASSIGN_CHECK                    025645 constant        label                    dcl 2680 ref 2697
BAD_OPT                         012417 constant        label                    dcl 1135 ref 1126
COPY_COMPARE                    003614 constant        label                    dcl 253 set ref 232 240
CTL_ARG_LOOP                    016727 constant        label                    dcl 1694
EXIT                            004432 constant        label                    dcl 360 ref 377
NO_OPT                          013036 constant        label                    dcl 1180 ref 1175
READ_COPY                       007567 constant        label                    dcl 690 ref 692
REREAD                          021714 constant        label                    dcl 2048 ref 2091 2098
REWRITE                         030007 constant        label                    dcl 3062 ref 3099
RE_READ                         021243 constant        label                    dcl 1962 ref 1969
SELECT_JOIN                     026204 constant        label                    dcl 2785 ref 2777 2783
SETREAD                         022740 constant        label                    dcl 2157 ref 2150
SETSKIP                         023416 constant        label                    dcl 2226 ref 2220
SET_PATH                        017174 constant        label                    dcl 1722 ref 1745
SET_REEL                        016751 constant        label                    dcl 1698 ref 1741 1759 1764
SET_SELECT                      020247 constant        label                    dcl 1827 ref 1821
add_to_select_list              025353 constant        entry                    internal dcl 2306 ref 2302 2523
attach                          004544 constant        entry                    internal dcl 391 ref 283 292 302 303 325 326 1484
check_invocation_type           005403 constant        entry                    internal dcl 484 ref 260
cleanup_invocation              005511 constant        entry                    internal dcl 515 ref 257 371
compare_dump_tape               003575 constant        entry                    external dcl 234
compare_seg                     005615 constant        entry                    internal dcl 547 ref 761
compare_segs                    007402 constant        entry                    internal dcl 664 ref 327
copy_dump_tape                  003553 constant        entry                    external dcl 14
copy_segs                       010531 constant        entry                    internal dcl 821 ref 305
detach                          011055 constant        entry                    internal dcl 880 ref 287 521 522 523 524 785 786 856
                                                                                  857 1575 1576 1607
error                           011622 constant        entry                    internal dcl 957 ref 336 567 575 593 604 621 715 740
                                                                                  903 909 918 924 1135 1149 1182 1709 1732 1797 1830
                                                                                  1854 1863 1924 2352 2675 2702 2864 2914 2988
error$fatal                     011767 constant        entry                    internal dcl 991 ref 416 420 432 493 495 848 1046
                                                                                  1487 1492 1641 1646 1652 1689 1867 1870 1874 1884
                                                                                  1902 1976 2036 2052 2103 2144 2173 2214 2242 2506
                                                                                  2694 2858 3055 3104
error$init                      011722 constant        entry                    internal dcl 978 ref 491 566
error$occurred                  011743 constant        entry                    internal dcl 985 ref 632 1867
exit_proc                       004526 constant        entry                    internal dcl 374 ref 258 258
get_arg                         012100 constant        entry                    internal dcl 1013 ref 1043
get_arg_count                   012136 constant        entry                    internal dcl 1028 ref 1689
get_ctl_arg                     012143 constant        entry                    internal dcl 1034 ref 1694
get_entry                       012235 constant        entry                    internal dcl 1060 ref 1496 1892 1896
get_num_opt                     012271 constant        entry                    internal dcl 1105 ref 1768 1774
get_opt                         012752 constant        entry                    internal dcl 1161 ref 1704 1708 1727 1786 1821 1826
                                                                                  1850
header                          013171 constant        entry                    internal dcl 1217 ref 301 324
hhmmm                           014017 constant        entry                    internal dcl 1307 ref 285 336 361 423 567 575 593
                                                                                  604 621 715 740 789 848 860 909 924 927 1229 1635
                                                                                  1641 1646 1652 1657 2036 2052 2083 2103 2144 2173
                                                                                  2214 2242 2352 2506 2675 2702 2909 2988 3055 3104
in_out_selected                 021165 constant        entry                    internal dcl 1920 ref 1728 1769 1775
initialize_args                 014121 constant        entry                    internal dcl 1334 ref 256
label                           013365 constant        entry                    internal dcl 1240 ref 1232 1233
map_seg                         014403 constant        entry                    internal dcl 1401 ref 840
map_seg$init                    014620 constant        entry                    internal dcl 1468 ref 304
map_seg$new_tape                015401 constant        entry                    internal dcl 1536 ref 3098
map_seg$term                    015471 constant        entry                    internal dcl 1565 ref 518
medium                          013526 constant        entry                    internal dcl 1263 ref 1235 1236
mount_next_tape_vol             015560 constant        entry                    internal dcl 1599 ref 431 2098 2168 2237 3097
process_args                    016662 constant        entry                    internal dcl 1679 ref 261
read_line                       021241 constant        entry                    internal dcl 1946 ref 2301
read_seg$contents               022457 constant        entry                    internal dcl 2124 ref 691 757 835
read_seg$header                 021437 constant        entry                    internal dcl 2003 ref 690 699 831
read_seg$skip_contents          023142 constant        entry                    internal dcl 2194 ref 730 736 832
skip_seg                        024104 constant        entry                    internal dcl 2420 ref 729 832
skip_seg$init                   023624 constant        entry                    internal dcl 2275 ref 284
skip_seg$term                   023700 constant        entry                    internal dcl 2340 ref 346
tape_drive$assign               025473 constant        entry                    internal dcl 2640 ref 2884
tape_drive$find_device          026037 constant        entry                    internal dcl 2724 ref 1656
tape_drive$init                 027273 constant        entry                    internal dcl 2933 ref 1387
tape_drive$select_a_device      026176 constant        entry                    internal dcl 2779 ref 1616
tape_drive$select_another_device
                                026163 constant        entry                    internal dcl 2767 ref 1614
tape_drive$survey               026467 constant        entry                    internal dcl 2843 ref 296
tape_drive$term                 027414 constant        entry                    internal dcl 2956 ref 519
tape_drive$unassign             027455 constant        entry                    internal dcl 2981 ref 2963
vowel                           013137 constant        entry                    internal dcl 1191 ref 1135 1135 1149 1149 1182 1182
write_seg                       027564 constant        entry                    internal dcl 3017 ref 839

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     33066       33326   31534       33076
Length     34244   31534       240         701    1331           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
copy_dump_tape                     4938 external procedure  is an external procedure.  
on unit on line 257                  64 on unit               
exit_proc                            64 internal procedure  is assigned to an entry variable.  
attach                                  internal procedure  shares stack frame of external procedure copy_dump_tape.  
check_invocation_type                   internal procedure  shares stack frame of external procedure copy_dump_tape.  
cleanup_invocation                  178 internal procedure  is called by several nonquick procedures.  
compare_seg                             internal procedure  shares stack frame of external procedure copy_dump_tape.  
compare_segs                            internal procedure  shares stack frame of external procedure copy_dump_tape.  
copy_segs                               internal procedure  shares stack frame of external procedure copy_dump_tape.  
detach                              132 internal procedure  is called by several nonquick procedures.  
error                                92 internal procedure  is called during a stack extension, and is declared options(variable).  
get_arg                                 internal procedure  shares stack frame of external procedure copy_dump_tape.  
get_arg_count                           internal procedure  shares stack frame of external procedure copy_dump_tape.  
get_ctl_arg                             internal procedure  shares stack frame of external procedure copy_dump_tape.  
get_entry                               internal procedure  shares stack frame of external procedure copy_dump_tape.  
get_num_opt                             internal procedure  shares stack frame of external procedure copy_dump_tape.  
get_opt                                 internal procedure  shares stack frame of external procedure copy_dump_tape.  
vowel                                   internal procedure  shares stack frame of external procedure copy_dump_tape.  
header                                  internal procedure  shares stack frame of external procedure copy_dump_tape.  
label                                   internal procedure  shares stack frame of external procedure copy_dump_tape.  
medium                                  internal procedure  shares stack frame of external procedure copy_dump_tape.  
hhmmm                                79 internal procedure  is called by several nonquick procedures.  
initialize_args                         internal procedure  shares stack frame of external procedure copy_dump_tape.  
map_seg                                 internal procedure  shares stack frame of external procedure copy_dump_tape.  
map_seg$init                            internal procedure  shares stack frame of external procedure copy_dump_tape.  
map_seg$new_tape                        internal procedure  shares stack frame of external procedure copy_dump_tape.  
map_seg$term                            internal procedure  shares stack frame of internal procedure cleanup_invocation.  
mount_next_tape_vol                     internal procedure  shares stack frame of external procedure copy_dump_tape.  
process_args                            internal procedure  shares stack frame of external procedure copy_dump_tape.  
in_out_selected                         internal procedure  shares stack frame of external procedure copy_dump_tape.  
read_line                               internal procedure  shares stack frame of external procedure copy_dump_tape.  
read_seg$header                         internal procedure  shares stack frame of external procedure copy_dump_tape.  
skip_seg$init                           internal procedure  shares stack frame of external procedure copy_dump_tape.  
add_to_select_list                      internal procedure  shares stack frame of external procedure copy_dump_tape.  
tape_drive$assign                       internal procedure  shares stack frame of external procedure copy_dump_tape.  
tape_drive$find_device                  internal procedure  shares stack frame of external procedure copy_dump_tape.  
tape_drive$init                         internal procedure  shares stack frame of external procedure copy_dump_tape.  
tape_drive$term                         internal procedure  shares stack frame of internal procedure cleanup_invocation.  
tape_drive$unassign                     internal procedure  shares stack frame of internal procedure cleanup_invocation.  
write_seg                               internal procedure  shares stack frame of external procedure copy_dump_tape.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleanup_invocation       000106 code                        map_seg$term
                         000116 code                        tape_drive$term
                         000117 dx                          tape_drive$term
                         000130 code                        tape_drive$unassign
copy_dump_tape           000100 ME                          copy_dump_tape
                         000105 abort_sw                    copy_dump_tape
                         000106 code                        copy_dump_tape
                         000110 compared                    copy_dump_tape
                         000112 copied                      copy_dump_tape
                         000114 cpbf                        copy_dump_tape
                         000160 cplast                      copy_dump_tape
                         000244 inbf                        copy_dump_tape
                         000310 inlast                      copy_dump_tape
                         000374 input                       copy_dump_tape
                         001240 map                         copy_dump_tape
                         001404 map_prev                    copy_dump_tape
                         001547 mlast                       copy_dump_tape
                         001633 maximize_devices_sw         copy_dump_tape
                         001634 operation_now               copy_dump_tape
                         001635 operation_wanted            copy_dump_tape
                         001636 output                      copy_dump_tape
                         002502 select                      copy_dump_tape
                         002651 state                       copy_dump_tape
                         002652 trace                       copy_dump_tape
                         002654 in_outp                     copy_dump_tape
                         002656 severityp                   copy_dump_tape
                         002666 af_sw                       copy_dump_tape
                         002667 argl                        copy_dump_tape
                         002670 argp                        copy_dump_tape
                         002672 argn                        copy_dump_tape
                         002673 argx                        copy_dump_tape
                         002674 num_opt                     copy_dump_tape
                         002675 optl                        copy_dump_tape
                         002676 optp                        copy_dump_tape
                         002700 retl                        copy_dump_tape
                         002702 retp                        copy_dump_tape
                         002704 sci_ptr                     copy_dump_tape
                         002706 error_occurred_sw           copy_dump_tape
                         002707 map_last_dir                copy_dump_tape
                         002761 line                        copy_dump_tape
                         003076 tape_drives                 copy_dump_tape
                         003274 pp                          copy_dump_tape
                         003276 event_wait_channel          copy_dump_tape
                         003312 atd                         attach
                         003426 code                        attach
                         003427 count                       attach
                         003430 io_switch_name              attach
                         003454 first_disagreement          compare_seg
                         003455 words_disagreeing           compare_seg
                         003456 wordx                       compare_seg
                         003470 compare_continues           compare_segs
                         003471 need_copy                   compare_segs
                         003472 need_master                 compare_segs
                         003473 error_count                 compare_segs
                         003474 extra_masters               compare_segs
                         003534 code                        get_entry
                         003535 dir                         get_entry
                         003607 ent                         get_entry
                         003626 valx                        get_num_opt
                         003652 from                        header
                         003663 to                          header
                         003674 indent                      header
                         003712 code                        medium
                         003713 len                         medium
                         003714 maxlen                      medium
                         003715 printed                     medium
                         003716 x                           medium
                         003736 bp                          map_seg
                         003740 nn                          map_seg
                         003742 np                          map_seg
                         003744 nx                          map_seg
                         003746 seg                         map_seg
                         003772 date_time_string            map_seg$init
                         004005 map_header                  map_seg$init
                         004121 map_line                    map_seg$init
                         004234 out_header                  map_seg$init
                         004304 map_line                    map_seg$new_tape
                         004426 atd                         mount_next_tape_vol
                         004527 code                        mount_next_tape_vol
                         004536 opt_desc                    process_args
                         004564 code                        read_line
                         004574 readl                       read_seg$header
                         004575 readneed                    read_seg$header
                         004606 header_needed               skip_seg$init
                         004607 seg                         skip_seg$init
                         004704 en                          add_to_select_list
                         004766 code                        tape_drive$assign
                         004770 ev_info                     tape_drive$assign
                         004777 statex                      tape_drive$assign
                         005000 ti                          tape_drive$assign
                         005036 code                        tape_drive$find_device
                         005037 da                          tape_drive$find_device
                         005040 dx                          tape_drive$find_device
                         005041 densityx                    tape_drive$find_device
                         005042 selected_dx                 tape_drive$find_device
                         005043 unwanted_device             tape_drive$find_device
                         005054 rli_ptr                     tape_drive$find_device
                         005056 dassign_ptr                 tape_drive$find_device
                         005060 attach_ptr                  tape_drive$find_device
                         005062 device_resv_ptr             tape_drive$find_device
                         005122 count                       write_seg
                         005123 writel                      write_seg
error                    000100 codep                       error
hhmmm                    000100 time_form                   hhmmm
                         000102 result                      hhmmm

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac
tra_ext_1           mdfx1               signal_op           enable_op           shorten_stack       ext_entry
int_entry           search_eis          any_to_any_truncate_unpack_picture      clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            absolute_pathname_$add_suffix backup_map_$beginning_line    backup_map_$detach_for_cdt
backup_map_$detail_line2      backup_map_$directory_line    backup_map_$heading_line      backup_map_$init_for_cdt
backup_map_$name_line         backup_map_$tapes             backup_map_$terminal_line     backup_util$idline
convert_ipc_code_             cu_$arg_list_ptr              cu_$arg_list_ptr              cu_$arg_ptr
cu_$generate_call             date_time_$format             expand_pathname_              get_line_length_$switch
get_shortest_path_            ioa_                          iox_$attach_name              iox_$attach_ptr
iox_$close                    iox_$control                  iox_$destroy_iocb             iox_$detach_iocb
iox_$find_iocb                iox_$get_chars                iox_$get_line                 iox_$modes
iox_$move_attach              iox_$open                     iox_$position                 iox_$put_chars
ipc_$block                    ipc_$create_ev_chn            ipc_$delete_ev_chn            pathname_
pl1_time_                     rcp_$assign_device            rcp_$check_assign             rcp_$copy_list
rcp_$unassign                 ssu_$abort_subsystem          ssu_$arg_ptr                  ssu_$destroy_invocation
ssu_$get_invocation_count     ssu_$get_temp_segment         ssu_$print_message            ssu_$return_arg
ssu_$standalone_invocation    unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
compare_dump_tape_severity_   copy_dump_tape_map_           copy_dump_tape_severity_      copy_dump_tape_tapes
error_table_$active_function  error_table_$bad_arg          error_table_$bad_arg          error_table_$bad_opt
error_table_$device_end       error_table_$end_of_info      error_table_$inconsistent     error_table_$noarg
error_table_$noarg            error_table_$noarg            error_table_$not_act_fnc      error_table_$not_detached
error_table_$resource_reserved                              error_table_$resource_unavailable
error_table_$too_many_names   error_table_$wrong_no_of_args sys_info$page_size            sys_info$seg_size_256K




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   2620 003545    5    8 003547        14 003552       227 003561       228 003564       229 003566       230 003571
    231 003572       232 003573       234 003574       237 003603       238 003606       239 003610       240 003613
    253 003614       255 003615       256 003617       257 003620       258 003642       260 003712       261 003714
    281 003715       282 003721       283 003732       284 003736       285 003737       287 004002       290 004014
    291 004020       292 004031       293 004035       296 004044       299 004051       300 004056       301 004060
    302 004067       303 004073       304 004077       305 004101       306 004102       307 004104       308 004106
    309 004117       313 004173       314 004202       315 004211       316 004222       318 004240       322 004242
    323 004245       324 004247       325 004256       326 004262       327 004266       330 004267       331 004272
    332 004274       334 004302       335 004307       336 004320       346 004431       360 004432       361 004443
    371 004520       372 004524       374 004525       376 004533       377 004541       391 004544       401 004546
    402 004552       403 004553       404 004567       406 004677       408 004726       411 004750       412 004757
    413 005011       415 005027       416 005065       419 005124       420 005146       423 005212       427 005306
    428 005312       429 005313       430 005315       431 005316       432 005332       437 005402       484 005403
    491 005405       492 005411       493 005430       495 005455       497 005500       498 005502       500 005506
    501 005507       515 005510       518 005516       519 005517       521 005520       522 005534       523 005550
    524 005564       526 005600       528 005614       547 005615       566 005617       567 005623       575 006044
    583 006271       584 006306       585 006307       586 006310       587 006321       588 006332       589 006333
    592 006340       593 006342       603 006605       604 006607       611 007032       612 007050       613 007051
    614 007052       615 007063       616 007074       617 007075       620 007102       621 007104       631 007347
    632 007350       633 007361       634 007366       636 007374       664 007402       672 007403       674 007433
    676 007463       677 007507       679 007534       680 007542       681 007544       682 007552       684 007554
    685 007556       686 007560       687 007561       688 007562       689 007564       690 007567       691 007574
    692 007576       693 007601       698 007605       699 007607       703 007627       708 007636       710 007640
    711 007641       715 007652       720 007772       721 007774       723 010000       725 010005       727 010007
    729 010010       730 010027       731 010043       732 010045       734 010046       736 010051       737 010065
    738 010071       739 010072       740 010073       745 010217       746 010221       748 010225       750 010232
    753 010234       757 010235       758 010251       761 010256       762 010300       763 010301       767 010312
    768 010317       770 010320       771 010321       773 010325       775 010332       778 010355       783 010357
    785 010360       786 010372       788 010404       789 010415       795 010521       797 010530       821 010531
    824 010532       825 010556       827 010602       828 010610       830 010612       831 010614       832 010626
    835 010636       836 010640       837 010644       839 010647       840 010654       841 010656       842 010657
    846 010670       848 010671       854 010730       856 010731       857 010743       859 010755       860 010766
    865 011053       880 011054       890 011062       892 011072       893 011075       894 011106       895 011125
    896 011142       897 011147       900 011150       901 011155       902 011161       903 011172       906 011232
    908 011233       909 011244       915 011323       916 011333       917 011337       918 011351       921 011411
    923 011412       924 011424       927 011503       935 011567       937 011601       938 011613       941 011620
    957 011621       971 011631       972 011647       973 011660       974 011663       975 011666       976 011712
    978 011721       981 011731       982 011733       985 011742       988 011751       991 011766       994 011776
    995 012015       996 012026       997 012031       998 012034       999 012045      1000 012071      1013 012100
   1018 012102      1019 012105      1020 012106      1021 012123      1023 012131      1028 012136      1030 012140
   1034 012143      1043 012145      1046 012174      1049 012227      1060 012235      1071 012237      1072 012263
   1105 012271      1123 012307      1124 012312      1125 012313      1126 012330      1127 012344      1128 012354
   1131 012402      1132 012404      1135 012417      1145 012567      1148 012575      1149 012604      1157 012740
   1159 012746      1161 012752      1170 012770      1171 012773      1172 012774      1173 013011      1174 013025
   1175 013027      1177 013030      1180 013036      1182 013045      1185 013124      1187 013132      1191 013137
   1199 013150      1201 013164      1217 013171      1228 013202      1229 013213      1232 013262      1233 013305
   1234 013330      1235 013336      1236 013351      1237 013364      1240 013365      1247 013376      1248 013404
   1249 013417      1250 013426      1251 013441      1253 013460      1255 013476      1257 013513      1260 013525
   1263 013526      1276 013530      1278 013566      1280 013624      1281 013626      1282 013631      1283 013646
   1284 013652      1285 013653      1286 013665      1287 013671      1289 013737      1290 013742      1292 013745
   1293 013747      1296 014015      1307 014016      1316 014024      1317 014035      1318 014041      1319 014050
   1320 014111      1334 014121      1340 014122      1342 014124      1344 014135      1346 014142      1347 014144
   1348 014145      1349 014146      1350 014147      1350 014155      1351 014156      1352 014160      1353 014162
   1355 014202      1356 014205      1358 014215      1361 014222      1362 014257      1363 014264      1364 014266
   1366 014267      1367 014324      1368 014330      1370 014333      1371 014336      1373 014343      1374 014344
   1375 014345      1377 014347      1378 014360      1379 014363      1380 014365      1381 014370      1383 014373
   1385 014377      1387 014401      1389 014402      1401 014403      1426 014405      1429 014412      1430 014420
   1431 014423      1434 014436      1435 014451      1436 014456      1439 014473      1439 014477      1440 014503
   1440 014507      1442 014513      1445 014543      1445 014554      1446 014557      1448 014574      1449 014615
   1451 014617      1468 014620      1478 014622      1481 014627      1483 014672      1484 014676      1485 014702
   1487 014715      1489 014740      1492 015003      1496 015033      1498 015066      1500 015107      1502 015115
   1504 015124      1505 015173      1508 015234      1509 015241      1511 015266      1512 015306      1513 015320
   1514 015324      1515 015336      1517 015350      1518 015354      1521 015375      1522 015400      1536 015401
   1543 015403      1546 015410      1547 015413      1548 015432      1550 015460      1551 015465      1553 015470
   1565 015471      1570 015472      1572 015500      1573 015504      1574 015520      1575 015527      1576 015543
   1579 015557      1599 015560      1607 015562      1610 015602      1613 015614      1614 015615      1616 015633
   1619 015641      1620 015705      1625 015736      1626 015744      1627 015756      1629 016002      1630 016014
   1631 016050      1632 016062      1633 016116      1635 016130      1640 016233      1641 016274      1645 016357
   1646 016400      1650 016462      1651 016467      1652 016516      1656 016567      1657 016601      1660 016654
   1679 016662      1689 016663      1694 016727      1696 016735      1697 016747      1698 016751      1699 016753
   1700 016776      1701 017000      1702 017002      1703 017006      1704 017024      1705 017053      1706 017056
   1708 017063      1709 017072      1714 017147      1715 017150      1717 017160      1718 017161      1720 017162
   1721 017172      1722 017174      1723 017176      1724 017220      1725 017223      1726 017226      1727 017244
   1728 017273      1729 017300      1730 017306      1732 017326      1733 017366      1737 017405      1739 017406
   1740 017416      1741 017420      1743 017421      1744 017431      1745 017433      1747 017434      1749 017454
   1750 017456      1751 017460      1752 017502      1753 017505      1754 017510      1756 017511      1758 017527
   1759 017531      1761 017532      1763 017545      1764 017547      1767 017550      1768 017560      1769 017622
   1772 017632      1773 017633      1774 017643      1775 017705      1778 017715      1780 017716      1782 017725
   1785 017737      1786 017743      1787 017751      1789 017772      1791 020001      1793 020014      1795 020027
   1797 020042      1805 020104      1806 020105      1808 020113      1810 020115      1811 020116      1814 020131
   1816 020144      1819 020156      1820 020166      1821 020204      1825 020216      1826 020221      1827 020247
   1828 020254      1830 020274      1831 020334      1834 020351      1835 020352      1836 020362      1837 020365
   1838 020366      1840 020367      1843 020404      1847 020421      1848 020427      1850 020432      1851 020440
   1852 020445      1854 020473      1855 020533      1858 020550      1859 020551      1861 020563      1862 020566
   1863 020567      1865 020620      1867 020621      1870 020650      1874 020702      1879 020734      1880 020740
   1881 020744      1882 020750      1884 020754      1889 021006      1891 021016      1892 021022      1894 021034
   1896 021042      1898 021054      1900 021074      1902 021122      1905 021151      1907 021164      1920 021165
   1923 021167      1924 021173      1926 021226      1928 021234      1946 021241      1962 021243      1964 021271
   1965 021273      1966 021277      1967 021305      1968 021327      1969 021345      1970 021352      1972 021357
   1973 021362      1974 021363      1976 021371      1981 021433      2003 021437      2018 021443      2019 021450
   2021 021474      2023 021501      2024 021507      2025 021521      2026 021524      2028 021550      2030 021560
   2031 021565      2034 021600      2036 021617      2040 021675      2042 021676      2048 021714      2050 021741
   2052 021746      2072 022060      2073 022065      2074 022074      2076 022120      2078 022126      2083 022154
   2087 022266      2088 022274      2089 022301      2091 022324      2094 022326      2097 022343      2098 022347
   2100 022363      2103 022376      2124 022456      2127 022462      2128 022470      2129 022473      2131 022514
   2133 022524      2134 022531      2135 022532      2137 022551      2139 022552      2140 022553      2142 022572
   2144 022617      2148 022675      2150 022676      2151 022701      2152 022703      2153 022710      2155 022732
   2157 022740      2158 022743      2159 022751      2160 022754      2161 022756      2162 022760      2167 022777
   2168 023003      2170 023040      2173 023061      2194 023141      2197 023145      2198 023153      2199 023156
   2200 023160      2202 023203      2203 023205      2204 023213      2205 023214      2207 023233      2209 023234
   2210 023235      2212 023254      2214 023301      2218 023357      2220 023360      2221 023363      2222 023365
   2223 023372      2225 023414      2226 023416      2227 023421      2228 023427      2229 023432      2230 023434
   2231 023436      2236 023455      2237 023460      2239 023515      2242 023536      2249 023616      2275 023624
   2299 023627      2300 023653      2301 023656      2302 023665      2303 023670      2304 023671      2340 023700
   2345 023703      2347 023716      2348 023720      2349 023734      2350 023742      2351 023744      2352 023755
   2354 024014      2356 024015      2359 024070      2361 024072      2362 024075      2420 024104      2435 024107
   2439 024122      2440 024174      2442 024204      2445 024213      2449 024223      2453 024232      2456 024234
   2459 024243      2461 024245      2463 024254      2469 024304      2491 024305      2492 024320      2499 024356
   2500 024365      2501 024372      2502 024374      2504 024406      2506 024417      2515 024523      2517 024536
   2518 024537      2522 024565      2523 024574      2528 024613      2531 024614      2537 024642      2549 024645
   2550 024650      2554 024661      2561 025011      2562 025013      2563 025015      2573 025155      2574 025157
   2575 025161      2581 025311      2589 025312      2592 025337      2306 025353      2316 025364      2317 025365
   2318 025372      2319 025404      2320 025410      2322 025411      2323 025422      2325 025426      2326 025431
   2327 025435      2328 025441      2329 025443      2330 025445      2333 025454      2334 025461      2336 025463
   2337 025472      2640 025473      2650 025475      2652 025500      2653 025502      2654 025503      2655 025504
   2656 025505      2658 025512      2659 025513      2660 025514      2661 025515      2662 025516      2663 025517
   2664 025522      2665 025523      2666 025524      2667 025525      2668 025526      2670 025527      2673 025572
   2675 025601      2680 025645      2683 025703      2685 025705      2687 025712      2689 025713      2692 025732
   2693 025734      2694 025745      2697 025770      2699 025771      2702 025772      2706 026036      2724 026037
   2732 026041      2733 026045      2734 026050      2735 026063      2736 026101      2737 026114      2739 026123
   2740 026126      2742 026144      2743 026146      2746 026160      2747 026162      2767 026163      2776 026165
   2777 026175      2779 026176      2782 026200      2783 026203      2785 026204      2787 026207      2789 026222
   2790 026236      2791 026247      2792 026262      2793 026265      2795 026304      2796 026306      2799 026317
   2801 026321      2803 026331      2805 026336      2807 026343      2809 026345      2812 026352      2813 026353
   2817 026367      2821 026424      2822 026426      2824 026450      2827 026466      2843 026467      2846 026470
   2848 026473      2849 026474      2850 026476      2851 026512      2852 026526      2853 026537      2854 026551
   2855 026563      2857 026575      2858 026606      2859 026631      2861 026633      2862 026660      2863 026662
   2864 026675      2865 026720      2867 026723      2868 026733      2869 026762      2870 026766      2871 026771
   2872 026774      2875 027001      2877 027003      2878 027005      2880 027013      2883 027036      2884 027040
   2886 027046      2887 027050      2890 027063      2891 027073      2892 027077      2893 027102      2895 027120
   2896 027122      2899 027130      2900 027132      2901 027140      2902 027143      2906 027145      2908 027147
   2909 027160      2914 027245      2918 027272      2933 027273      2936 027274      2937 027275      2938 027277
   2939 027313      2940 027344      2941 027355      2944 027413      2956 027414      2962 027415      2963 027425
   2965 027433      2967 027435      2969 027454      2981 027455      2987 027457      2988 027507      2991 027556
   2993 027563      3017 027564      3031 027566      3032 027573      3034 027615      3035 027617      3037 027644
   3038 027646      3039 027652      3041 027672      3042 027674      3043 027677      3045 027704      3047 027705
   3048 027707      3053 027714      3055 027726      3059 030004      3061 030005      3062 030007      3064 030032
   3074 030034      3075 030041      3076 030050      3078 030072      3079 030074      3080 030100      3081 030102
   3082 030107      3087 030130      3088 030132      3090 030167      3091 030171      3092 030174      3095 030201
   3097 030206      3098 030222      3099 030231      3101 030232      3104 030240      3109 030321      3112 030322
   3113 030323      3115 030330


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
