	COMPILATION LISTING OF SEGMENT hcom
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/12/86  1531.2 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-09-03,LJAdams), approve(85-11-06,MCR7278),
        9*     audit(86-02-19,Gilcrease), install(86-02-19,MR12.0-1021):
       10*     This is the driver program for the history
       11*     comment programs that provide tracking of software changes and ensure that
       12*     the format and placement of software change notices are standard.
       13*  2) change(86-04-17,LJAdams), approve(86-04-17,MCR7386),
       14*     audit(86-05-19,Gilcrease), install(86-06-05,MR12.0-1071):
       15*     When using an active function, if there is an invalid argument given set
       16*     return string to false.  If there was an invalid argument do not take
       17*     operand of argument as a comment spec for ADD, CHECK, or INSTALL.
       18*  3) change(86-05-05,LJAdams), approve(86-05-05,MCR7386),
       19*     audit(86-05-19,Gilcrease), install(86-06-05,MR12.0-1071):
       20*     Added ability to fill or not fill comments using the -fill or -no_fill
       21*     arguments.
       22*  4) change(86-09-02,LJAdams), approve(86-09-02,MCR7526),
       23*     audit(86-11-05,GDixon), install(86-11-12,MR12.0-1213):
       24*     Reformatted error messages to be consistent.
       25*     
       26*     hcom get with no fields specified was not returning all fields available.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 history_comment:
       30 hcom:
       31      proc;
       32 
       33 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       34 /*									*/
       35 /* This command is used to insert history_comments into source_programs.        	*/
       36 /* The command uses the pnotice_language_info_ database (created by CDS) to obtain        */
       37 /* information on the source language segment.			          	*/
       38 /*									*/
       39 /* Status:								*/
       40 /* 0) Created	   June 1985 by LJ Adams					*/
       41 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       42 
       43 
       44 /*  A U T O M A T I C  */
       45 	dcl     code		 fixed bin (35),
       46 	        control		 fixed bin,
       47 	        current_date	 char (8),
       48 	        error_msg		 char (100) varying,
       49 	        (i, j)		 fixed bin (24),
       50 	        operation		 fixed bin,	/* used to indicate if operation has been set	*/
       51 	        Sactive_function_err	 bit (1),
       52 	        Sfill_arg		 bit (1),
       53 	        user_name		 char (24),
       54 	        valid		 bit (1) init ("0"b);
       55 
       56 
       57 /*  E X T E R N A L   E N T R I E S  */
       58 	dcl     cu_$generate_call	 entry (entry, ptr),
       59 	        cv_entry_		 entry (char (*), ptr, fixed bin (35)) returns (entry),
       60 	        date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var),
       61 	        get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35)),
       62 	        hcom_cfix_validate_	 entry (char (*) var, char (*) var, char (*) var, bit (1), char (*) var, char (*) var, char (100) var),
       63 	        hcom_default_validate_ entry (char (*) var, char (*) var, char (*) var, bit (1), char (*) var, char (*) var, char (100) var),
       64 	        hcom_site_validate_	 entry options (variable),
       65 	        hcom_process_path_	 entry (ptr),
       66 	        ioa_		 entry () options (variable),
       67 	        release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35)),
       68 	        requote_string_	 entry (char (*)) returns (char (*)),
       69 	        user_info_		 entry (char (*), char (*), char (*));
       70 
       71 /*  I N T E R N A L   S T A T I C  */
       72 	dcl     FALSE		 bit (1) int static options (constant) init ("0"b),
       73 	        NL		 char (1) int static options (constant) init ("
       74 "),
       75 	        TRUE		 bit (1) int static options (constant) init ("1"b);
       76 
       77 	dcl     ctl		 (9, 2) char (20) var int static options (constant) init (
       78 				 "-summary", "-sm", /* control args that take an operand.		*/
       79 				 "-approve", "-apv",
       80 				 "-install", "-in",
       81 				 "-validate", "-vdt",
       82 				 "-critical_fix", "-cfix",
       83 				 "-fill", "-fi",
       84 				 "-no_fill", "-nfi",
       85 				 "-original", "-orig",
       86 				 "-field_names", "-fn");
       87 
       88 /*  E X T E R N A L   S T A T I C  */
       89 	dcl     (error_table_$active_function,
       90 	        error_table_$bad_arg,
       91 	        error_table_$badopt,
       92 	        error_table_$bigarg,
       93 	        error_table_$improper_data_format,
       94 	        error_table_$inconsistent,
       95 	        error_table_$noarg)	 fixed bin (35) ext static;
       96 
       97 /*  B U I L T I N  */
       98 	dcl     (addr, after, before, clock, codeptr, convert, hbound, index, lbound,
       99 	        length, maxlength, null, rtrim, string, substr, verify)
      100 				 builtin;
      101 
      102 /*  C O N D I T I O N S  */
      103 	dcl     (cleanup,
      104 	        linkage_error)	 condition;
      105 
      106 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      107 
      108 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      109 /*									*/
      110 /* 1) Initialize error routine and argument structure.				*/
      111 /* 2) Find out how we were invoked (command/af).					*/
      112 /* 3) Determine what operation is being performed.				*/
      113 /*									*/
      114 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      115 
      116 	Pd = addr (auto_hcom_data);
      117 	call check_error$init ();
      118 	call init$args;
      119 	call get_invocation_type (d.Saf);
      120 
      121 	do while (get_arg () & d.ag.op.name = NOTSET);	/* get operation value     */
      122 	     if index (arg, "-") = 1 then do;		/* control args that take  */
      123 		     control = NOTSET;		/*   an operand	       */
      124 		     do j = lbound (ctl, 2) to hbound (ctl, 2) while (control = NOTSET);
      125 			do i = lbound (ctl, 1) to hbound (ctl, 1) while (control = NOTSET);
      126 			     if arg = ctl (i, j) then control = i;
      127 			     if i = hbound (ctl, 1) then /* -fn takes multiple ops  */
      128 				if check_arg$field_name () then ;
      129 				else /* other control args take */
      130 				     if get_arg () then ; /*  exactly one operand.   */
      131 			end;
      132 		     end;				/* diagnose bad control    */
      133 		end;				/*  args later.	       */
      134 	     else do;
      135 		     do j = lbound (oper, 2) to hbound (oper, 2) while (d.ag.op.name = NOTSET);
      136 			do i = lbound (oper, 1) to hbound (oper, 1) while (d.ag.op.name = NOTSET);
      137 			     if arg = oper (i, j) then d.ag.op.name = i;
      138 			end;
      139 		     end;
      140 		     if d.ag.op.name = NOTSET then
      141 			call check_error$fatal (error_table_$bad_arg, CALLER, "^3x^a is not a valid operation.^/^3xSyntax: ^[[^]hcom operation path {-control_args}^[]^]
      142 ^3xOperation: ^a^6(, ^a^),^/^3x^a^(, ^a^)", arg, d.Saf, d.Saf, oper (*, 1));
      143 		end;
      144 	end;
      145 	if d.ag.op.name = NOTSET then
      146 	     call check_error$fatal (error_table_$noarg, CALLER, "^3xAn operation must be given.^/^3xSyntax:    ^[[^]hcom operation path {-control_args}^[]^]
      147 ^3xOperation: ^a^6(, ^a^),^/^3x^a^(, ^a^)", d.Saf, d.Saf, oper (*, 1));
      148 
      149 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      150 /*									*/
      151 /* 1) Set argument defaults based upon the operation.				*/
      152 /* 2) Check active function (af) invocations to be sure the specified operation is	*/
      153 /*    allowed as an active function.  Set default af return value.			*/
      154 /*									*/
      155 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      156 
      157 	if d.ag.op.name = ADD then
      158 	     d.ag.input.select.sm, d.ag.input.select.apv = INPUTxxx;
      159 
      160 	if d.ag.op.name = CHECK then /* set defaults				*/
      161 	     d.ag.ctl.errors = ^d.Saf;
      162 	else if d.ag.op.name = INSTALL then do;
      163 		d.ag.input.select.in = INPUTxxx;
      164 		d.ag.ctl.errors = ^d.Saf;
      165 	     end;
      166 
      167 	if d.Saf then do;				/* active function				*/
      168 		if d.ag.op.name = CHECK | d.ag.op.name = EXISTS |
      169 		     d.ag.op.name = INSTALL | d.ag.op.name = COMPARE then
      170 						/* set default return value			*/
      171 		     call set_return_arg ("true");
      172 		else if d.ag.op.name = GET then ;
      173 		else call check_error$fatal (error_table_$active_function, CALLER, "^/^3x^a is not a valid active function operation.",
      174 			oper (d.ag.op.name, 1));	/* diagnose operations which don't work as AF	*/
      175 	     end;
      176 	else do;					/* Some commands hold their true/false result	*/
      177 		if d.ag.op.name = EXISTS then /* in an hcom-provided pseudo-return value.	*/
      178 		     call set_return_arg ("true");	/* This result is then printed when all segs 	*/
      179 	     end;					/* are processed.				*/
      180 
      181 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      182 /*									*/
      183 /* 1) Scan arguments, and store control arg and operand values in the d.ag substructure.	*/
      184 /*    a) since each control arg is accepted for several operations, control argument	*/
      185 /*       matching and operand processing is done in a series of check_arg functions.	*/
      186 /*       These functions return TRUE if the control arg was accepted, and FALSE		*/
      187 /*       otherwise.  If TRUE and the control arg requires operands, then the check_arg	*/
      188 /*       function has already processed the operands.				*/
      189 /*    b) Noncontrol arguments are positional in order of appearance in the argument	*/
      190 /*       list.  First comes the operation name, then the source pathname.  All remaining	*/
      191 /*       noncontrol args are part of the comment specifier string.			*/
      192 /*									*/
      193 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      194 
      195 	call reprocess_args (1);			/* Rescan the entire argument list.		*/
      196 	operation = NOTSET;				/* Even though we know what the operation is, we	*/
      197 						/*   must skip over the operation name in the	*/
      198 						/*   arg list.  The operation variable determines */
      199 						/*   whether or not we have already seen this name*/
      200 
      201 	do while (get_arg ());
      202 	     if index (arg, "-") = 1 then do;		/* process control args			*/
      203 		     go to OP_CTL_ARGS (d.ag.op.name);
      204 
      205 OP_CTL_ARGS (1):					/* ADD					*/
      206 		     if check_arg$summary () then ;
      207 		     else if check_arg$apv () then ;
      208 		     else if check_arg$cfix () then ;
      209 		     else if check_arg$install () then ;
      210 		     else if check_arg$vdt () then ;
      211 		     else if check_arg$fill () then ;
      212 		     else call check_arg$ERROR;
      213 		     goto END_OP_CTL_ARGS;
      214 
      215 OP_CTL_ARGS (2):					/* ADD_FIELD				*/
      216 		     if check_arg$apv () then ;
      217 		     else if check_arg$cfix () then ;
      218 		     else if check_arg$audit () then ;
      219 		     else if check_arg$install () then ;
      220 		     else if check_arg$vdt () then ;
      221 		     else if check_arg$orig () then ;
      222 		     else call check_arg$ERROR;
      223 		     goto END_OP_CTL_ARGS;
      224 
      225 OP_CTL_ARGS (3):					/* CHECK					*/
      226 		     if check_arg$orig () then ;
      227 		     else if check_arg$error () then ;
      228 		     else if check_arg$vdt () then ;
      229 		     else call check_arg$ERROR;
      230 		     goto END_OP_CTL_ARGS;
      231 
      232 OP_CTL_ARGS (4):					/* COMPARE				*/
      233 		     if check_arg$orig () then ;
      234 		     else if check_arg$vdt () then ;
      235 		     else call check_arg$ERROR;
      236 		     goto END_OP_CTL_ARGS;
      237 
      238 OP_CTL_ARGS (5):					/* DISPLAY				*/
      239 		     if check_arg$orig () then ;
      240 		     else if check_arg$vdt () then ;
      241 		     else call check_arg$ERROR;
      242 		     goto END_OP_CTL_ARGS;
      243 
      244 OP_CTL_ARGS (6):					/* EXISTS					*/
      245 		     if check_arg$orig () then ;
      246 		     else if check_arg$vdt () then ;
      247 		     else call check_arg$ERROR;
      248 		     goto END_OP_CTL_ARGS;
      249 
      250 OP_CTL_ARGS (7):					/* FORMAT					*/
      251 		     if check_arg$orig () then ;
      252 		     else if check_arg$rnb () then ;
      253 		     else if check_arg$vdt () then ;
      254 		     else if check_arg$fill () then ;
      255 		     else call check_arg$ERROR;
      256 		     goto END_OP_CTL_ARGS;
      257 
      258 OP_CTL_ARGS (8):					/* GET					*/
      259 		     if check_arg$orig () then ;
      260 		     else if check_arg$field_name () then ;
      261 		     else if check_arg$vdt () then ;
      262 		     else call check_arg$ERROR;
      263 		     goto END_OP_CTL_ARGS;
      264 
      265 OP_CTL_ARGS (9):					/* INSTALL				*/
      266 		     if check_arg$orig () then ;
      267 		     else if check_arg$error () then ;
      268 		     else if check_arg$apv () then ;
      269 		     else if check_arg$cfix () then ;
      270 		     else if check_arg$install_required () then ;
      271 		     else if check_arg$vdt () then ;
      272 		     else call check_arg$ERROR;
      273 		     goto END_OP_CTL_ARGS;
      274 
      275 OP_CTL_ARGS (10):					/* REPLACE_FIELD				*/
      276 		     if check_arg$orig () then ;
      277 		     else if check_arg$no_summary () then ;
      278 		     else if check_arg$apv () then ;
      279 		     else if check_arg$cfix () then ;
      280 		     else if check_arg$audit () then ;
      281 		     else if check_arg$install () then ;
      282 		     else if check_arg$vdt () then ;
      283 		     else if check_arg$fill () then ;
      284 		     else call check_arg$ERROR;
      285 		     goto END_OP_CTL_ARGS;
      286 
      287 END_OP_CTL_ARGS:
      288 		end;
      289 
      290 	     else if operation = NOTSET then /* First positional arg is operation keyword.	*/
      291 		operation = d.ag.op.name;
      292 
      293 	     else if operation ^= NOTSET & d.ag.source.path = "" then
      294 		d.ag.source.path = arg;		/* Second positional arg is the path name.        */
      295 
      296 	     else if operation ^= NOTSET & d.ag.source.path ^= "" then do;
      297 		     if d.ag.op.name = ADD | d.ag.op.name = CHECK | /* Third positional arg is a comment spec	*/
      298 			d.ag.op.name = INSTALL then do;
      299 			     if Sactive_function_err then
      300 				;
      301 			     else do;
      302 				     call set_return_arg ("false");
      303 				     call check_error (error_table_$bad_arg, CALLER, "^3x^a^/^3xA comment specifier is not valid for the ^a operation.",
      304 					arg, oper (d.ag.op.name, 1));
      305 				end;
      306 			end;
      307 		     else
      308 			call get_com_spec ();
      309 		end;
      310 	end;					/* get_arg				*/
      311 
      312 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      313 /*									*/
      314 /* 1) Diagnose command when no source pathname is given.				*/
      315 /* 2) Diagnose use of old/new/diff com_spec when -original not given.			*/
      316 /* 3) Set operation type (modify source vs no-modify) based upon operation name.	*/
      317 /* 4) Based upon type of operation, set default control argument values for unset	*/
      318 /*    control arguments, for cases where defaults depend upon what related control args	*/
      319 /*    WERE given by the user.							*/
      320 /*									*/
      321 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      322 
      323 	if d.ag.source.path = "" then /* missing pathname				*/
      324 	     call check_error (error_table_$noarg, CALLER, "^/^3xPathname of a source program must be given.");
      325 
      326 	if d.orig.path = "" then
      327 	     if d.com_spec.selected.old | d.com_spec.selected.new | d.ag.op.name = COMPARE then
      328 		call check_error (error_table_$inconsistent, CALLER, "^3x-original must be given with the old or new comment specifier, or the compare operation.");
      329 
      330 	if d.ag.op.name = ADD | d.ag.op.name = ADD_FIELD | /* set MODIFY operations			*/
      331 	     d.ag.op.name = FORMAT | d.ag.op.name = INSTALL |
      332 	     d.ag.op.name = REPLACE_FIELD then
      333 	     d.ag.op.type = MODIFY;
      334 	else
      335 	     d.ag.op.type = NO_MODIFY;
      336 
      337 	if d.ag.op.name = ADD then do;		/* set default input control args		*/
      338 		if d.ag.input.select.sm = NOxxx then
      339 		     d.ag.input.select.sm = INPUTxxx;	/*   summary field is required for ADD op.	*/
      340 	     end;
      341 	else if d.ag.op.name = ADD_FIELD then do;
      342 		if d.ag.input.select.sm = NOxxx & d.ag.input.select.apv = NOxxx &
      343 		     d.ag.input.select.aud = NOxxx & d.ag.input.select.in = NOxxx then
      344 		     d.ag.input.select.apv = INPUTxxx;
      345 	     end;
      346 	else if d.ag.op.name = GET then
      347 	     if string (d.ag.output) = FALSE then do i = 1 to hbound (d.field_array, 1);
      348 						/* if GET op and no flds specified return all flds*/
      349 		     substr (string (d.ag.output), i, 1) = TRUE;
      350 		     d.field_array (i) = i;
      351 		end;
      352 	     else if d.ag.op.name = REPLACE_FIELD then do;
      353 		     if d.ag.input.select.sm = NOxxx & d.ag.input.select.apv = NOxxx &
      354 			d.ag.input.select.aud = NOxxx & d.ag.input.select.in = NOxxx then
      355 			call check_error (error_table_$noarg, CALLER, "^/^3xField input control arguments are required for the replace_field operation.");
      356 		     if Sfill_arg then
      357 			if d.ag.input.select.sm = INPUTxxx |
      358 			     d.ag.input.select.sm = OPERANDxxx then ;
      359 			else
      360 			     call check_error (error_table_$bad_arg, CALLER, "^/^3xThe -fill/-no_fill arg can only be used if -sm or -ism is also specified.");
      361 		end;
      362 
      363 	if string (d.com_spec.selected) = FALSE & /* set default com_spec			*/
      364 	     d.com_spec.Nrange = 0 then do;		/* values.				*/
      365 		if d.ag.op.name = ADD_FIELD then do;
      366 			d.com_spec.selected.unaud = (d.ag.input.select.aud >= OPERANDxxx);
      367 			d.com_spec.selected.unapv = (d.ag.input.select.apv >= OPERANDxxx);
      368 			d.com_spec.selected.unin = (d.ag.input.select.in >= OPERANDxxx);
      369 			d.com_spec.selected.aud = (d.ag.input.select.aud = CLEARxxx);
      370 			d.com_spec.selected.apv = (d.ag.input.select.apv = CLEARxxx);
      371 			d.com_spec.selected.in = (d.ag.input.select.in = CLEARxxx);
      372 		     end;
      373 		else if d.ag.op.name = CHECK then do;
      374 			if d.ag.orig.path ^= "" then
      375 			     d.com_spec.selected.new = TRUE;
      376 			else
      377 			     d.com_spec.selected.icpt = TRUE;
      378 		     end;
      379 		else if d.ag.op.name = DISPLAY then do;
      380 			if d.ag.orig.path ^= "" then
      381 			     d.com_spec.selected.new = TRUE;
      382 			else
      383 			     d.com_spec.selected.all = TRUE;
      384 		     end;
      385 		else if d.ag.op.name = EXISTS | d.ag.op.name = FORMAT |
      386 		     d.ag.op.name = INSTALL then
      387 		     d.com_spec.selected.all = TRUE;
      388 		else if d.ag.op.name = GET | d.ag.op.name = REPLACE_FIELD then
      389 		     call check_error (error_table_$noarg, CALLER, "^/^3xComment specifiers are required for the ^a operation.",
      390 			oper (d.ag.op.name, 1));
      391 	     end;
      392 
      393 	if d.ag.input.value.approve_value ^= "" then do;	/* validate the approve value if given		*/
      394 		valid = FALSE;
      395 		if d.Scfix then do;
      396 						/* critical fix				*/
      397 			call hcom_cfix_validate_ ((CALLER), APPROVAL_FIELD_NAME, d.ag.input.value.approve_value, valid,
      398 			     d.ag.input.value.approve_value, "", error_msg);
      399 			if ^valid then
      400 			     call check_error (-1, CALLER, "^3xInvalid approve value:  ^a^/^3x^a", d.ag.input.value.approve_value, error_msg);
      401 		     end;
      402 		else do;
      403 			call d.ag.vdt ((CALLER), APPROVAL_FIELD_NAME, d.ag.input.value.approve_value, valid,
      404 			     d.ag.input.value.approve_value, "", error_msg);
      405 			if ^valid & error_msg = "" then do; /* user answered no to mcr question		*/
      406 				Serror_has_occurred = TRUE;
      407 				goto FATAL_ERROR;
      408 			     end;
      409 			else if ^valid then
      410 			     call check_error (-1, CALLER, "^3xInvalid approve value:  ^a^/^3x^a", d.ag.input.value.approve_value, error_msg);
      411 		     end;
      412 	     end;
      413 	if d.ag.input.value.install_id ^= "" then do;	/* validate the install id if given		*/
      414 		valid = FALSE;
      415 		if d.Scfix then
      416 		     call hcom_cfix_validate_ ((CALLER), INSTALL_FIELD_NAME, d.ag.input.value.install_id, valid,
      417 			d.ag.input.value.install_id, "", error_msg);
      418 		else
      419 		     call d.ag.vdt ((CALLER), INSTALL_FIELD_NAME, d.ag.input.value.install_id, valid, d.ag.input.value.install_id, "", error_msg);
      420 		if ^valid then
      421 		     call check_error (-1, CALLER, "^3xInvalid install id:  ^a^/^3x^a", d.ag.input.value.install_id, error_msg);
      422 	     end;
      423 
      424 
      425 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      426 /*									*/
      427 /* 1) Stop execution if any errors were reported earlier.				*/
      428 /* 2) Establish cleanup handler for temporary segments.				*/
      429 /* 3) Get all temp segments needed for any hcom operation.				*/
      430 /* 4) Call hcom_process_path_ to process all the arguments.				*/
      431 /* 5) Release all temp segments and return.					*/
      432 /*									*/
      433 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      434 
      435 	if check_error$error_has_occurred () then do;
      436 	     if d.Saf then
      437 	        call set_return_arg ("false");
      438 	     go to FATAL_ERROR;
      439 	     end;
      440 
      441 	on cleanup call hcom_janitor ();
      442 
      443 	call get_temp_segments_ (CALLER, temp_seg_array, code);
      444 	call check_error$fatal (code, CALLER, "^/^3xError obtaining temporary segments.");
      445 
      446 	call hcom_process_path_ (addr (d));
      447 
      448 	if d.ag.op.name = EXISTS & ^d.Saf then
      449 	     call ioa_ ("^a", ret);
      450 
      451 FATAL_ERROR:
      452 	call hcom_janitor ();
      453 	return;
      454 
      455 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      456 
      457 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      458 
      459 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      460 /*									*/
      461 /* The check_arg function entrypoints return TRUE if the current control argument is one	*/
      462 /* accepted by a given entrypoint; and FALSE otherwise.  If TRUE is returned and the	*/
      463 /* control argument accepts operands, then check_arg processes the operands.  Values in	*/
      464 /* the d.ag structure are adjusted appropriately based upon the given control argument	*/
      465 /* and its operands.							*/
      466 /*									*/
      467 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      468 
      469 check_arg:
      470      proc;
      471 
      472 check_arg$apv:
      473      entry returns (bit (1));
      474 
      475 	if arg = "-approve" | arg = "-apv" then do;
      476 		if get_op ("An approval value is required.  For example, MCR6734.", arg) then do;
      477 			if op = "" then do;
      478 				d.ag.input.value.approve_value = "";
      479 				d.ag.input.value.approve_dt = "";
      480 				d.ag.input.apv = CLEARxxx;
      481 			     end;
      482 			else do;
      483 				if length (op) > maxlength (d.ag.input.approve_value) then
      484 				     call check_error (error_table_$bigarg, CALLER, "^3x-approve ^a^/An approve value must^/^3xbe <= ^d characters long.", d.ag.input.approve_value, maxlength (d.ag.input.value.approve_value));
      485 
      486 				d.ag.input.value.approve_value = op;
      487 				d.ag.input.value.approve_dt = current_date;
      488 				d.ag.input.apv = OPERANDxxx;
      489 			     end;
      490 		     end;
      491 		return (TRUE);
      492 	     end;
      493 	else if arg = "-input_approve" | arg = "-iapv" then do;
      494 		d.ag.input.value.approve_value = "";
      495 		d.ag.input.value.approve_dt = "";
      496 		d.ag.input.apv = INPUTxxx;
      497 		return (TRUE);
      498 	     end;
      499 	else if arg = "-no_approve" | arg = "-napv" then do;
      500 		d.ag.input.value.approve_value = "";
      501 		d.ag.input.value.approve_dt = "";
      502 		d.ag.input.apv = NOxxx;
      503 		return (TRUE);
      504 	     end;
      505 	return (FALSE);
      506 
      507 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      508 
      509 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      510 
      511 check_arg$audit:
      512      entry returns (bit (1));
      513 
      514 	if arg = "-audit" | arg = "-aud" then do;
      515 		d.ag.input.value.audit_person = rtrim (user_name);
      516 		d.ag.input.value.audit_dt = current_date;
      517 		d.ag.input.aud = OPERANDxxx;
      518 		return (TRUE);
      519 	     end;
      520 	else if arg = "-no_audit" | arg = "-naud" then do;
      521 		d.ag.input.value.audit_person = "";
      522 		d.ag.input.value.audit_dt = "";
      523 		d.ag.input.aud = NOxxx;
      524 		return (TRUE);
      525 	     end;
      526 	return (FALSE);
      527 
      528 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      529 check_arg$cfix:
      530      entry returns (bit (1));
      531 
      532 	if arg = "-cfix" then do;
      533 		d.Scfix = TRUE;
      534 		if d.ag.input.apv = OPERANDxxx & index (d.ag.input.value.approve_value, "fix_") = 0 then
      535 		     call check_error (error_table_$bad_arg, CALLER, "^3x-approve ^a^/The cfix arg has been specified a critical fix number is required.",
      536 			d.ag.input.approve_value);
      537 		d.ag.vdt = hcom_cfix_validate_;
      538 		return (TRUE);
      539 	     end;
      540 	return (FALSE);
      541 
      542 
      543 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      544 
      545 check_arg$error:
      546      entry returns (bit (1));
      547 
      548 	if arg = "-errors" | arg = "-er" then do;
      549 		d.ag.ctl.errors = TRUE;
      550 		return (TRUE);
      551 	     end;
      552 	else if arg = "-no_errors" | arg = "-ner" then do;
      553 		d.ag.ctl.errors = FALSE;
      554 		return (TRUE);
      555 	     end;
      556 	return (FALSE);
      557 
      558 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      559 
      560 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      561 
      562 check_arg$field_name:
      563      entry returns (bit (1));
      564 
      565 	dcl     (field, i, j, k)	 fixed bin,
      566 	        match		 fixed bin (1),
      567 	        (OPTIONAL		 init (0),
      568 	        REQUIRED		 init (1)) fixed bin (1) int static options (constant);
      569 
      570 	dcl     field_name		 (9, 2) char (20) var int static options (constant) init (
      571 				 "change_date", "cdt", /* 1*/
      572 				 "change_person_id", "cpi", /* 2*/
      573 				 "approve_date", "apvdt", /* 3*/
      574 				 "approve_id", "apvi", /* 4*/
      575 				 "audit_date", "auddt", /* 5*/
      576 				 "audit_person_id", "audpi", /* 6*/
      577 				 "install_date", "indt", /* 7*/
      578 				 "install_id", "ini", /* 8*/
      579 				 "summary", "sm");	/* 9*/
      580 
      581 	d.field_array (*), k = 0;
      582 
      583 	if arg = "-field_name" | arg = "-fn" then do;	/* multiple -fn controls   */
      584 						/*   add to existing names */
      585 		if get_op ("One or more field names are required.", arg) then ;
      586 		do match = REQUIRED, OPTIONAL by 1 while (get_op ("", arg));
      587 		     field = 0;
      588 		     do j = lbound (field_name, 2) to hbound (field_name, 2) while (field = 0);
      589 			do i = lbound (field_name, 1) to hbound (field_name, 1) while (field = 0);
      590 			     if op = field_name (i, j) then
      591 				field = i;
      592 			end;
      593 		     end;
      594 
      595 		     if field > 0 then do;
      596 			     substr (string (d.ag.output), field, 1) = TRUE;
      597 			     k = k + 1;		/* store fld no so display can be positional	*/
      598 			     d.field_array (k) = field;
      599 			end;
      600 		     else if match = REQUIRED then do;
      601 			     call check_error (-1, CALLER, "^3xUnknown history comment field name: ^a ^a", arg, op);
      602 			     return (TRUE);
      603 			end;
      604 		     else do;
      605 			     call put_op ();
      606 			     return (TRUE);
      607 			end;
      608 		end;
      609 		return (TRUE);
      610 	     end;
      611 	return (FALSE);
      612 
      613 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      614 
      615 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      616 check_arg$fill:
      617      entry returns (bit (1));
      618 
      619 	if arg = "-no_fill" | arg = "-nfi" then do;
      620 		d.ag.ctl.fill = FALSE;
      621 		Sfill_arg = TRUE;
      622 		return (TRUE);
      623 	     end;
      624 	else if arg = "-fill" | arg = "-fi" then do;
      625 		d.ag.ctl.fill = TRUE;
      626 		Sfill_arg = TRUE;
      627 		return (TRUE);
      628 	     end;
      629 
      630 	return (FALSE);
      631 
      632 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      633 
      634 check_arg$install_required:
      635      entry returns (bit (1));
      636      
      637           if arg = "-no_install" | arg = "-nin" then
      638              return (FALSE);
      639 
      640 check_arg$install:
      641      entry returns (bit (1));
      642 
      643 	if arg = "-install" | arg = "-in" then do;
      644 		if get_op ("An install id is required.  For example, MR12.0-00234.", arg) then do;
      645 			if op = "" then do;
      646 				d.ag.input.value.install_id = "";
      647 				d.ag.input.value.install_dt = "";
      648 				d.ag.input.in = CLEARxxx;
      649 			     end;
      650 			else do;
      651 				if Lop > maxlength (d.ag.input.install_id) then
      652 				     call check_error (error_table_$bigarg, CALLER, "^3x-install ^a^/An install value must be <= ^d",
      653 					op, maxlength (d.ag.input.value.install_id));
      654 
      655 				d.ag.input.value.install_id = op;
      656 				d.ag.input.value.install_dt = current_date;
      657 				d.ag.input.in = OPERANDxxx;
      658 			     end;
      659 		     end;
      660 		return (TRUE);
      661 	     end;
      662 
      663 	else if arg = "-input_install" | arg = "-iin" then do;
      664 		d.ag.input.value.install_id = "";
      665 		d.ag.input.value.install_dt = "";
      666 		d.ag.input.in = INPUTxxx;
      667 		return (TRUE);
      668 	     end;
      669 
      670 	else if arg = "-no_install" | arg = "-nin" then do;
      671 		d.ag.input.value.install_id = "";
      672 		d.ag.input.value.install_dt = "";
      673 		d.ag.input.in = NOxxx;
      674 		return (TRUE);
      675 	     end;
      676 
      677 	return (FALSE);
      678 
      679 
      680 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      681 
      682 check_arg$orig:
      683      entry returns (bit (1));
      684 
      685 	if arg = "-original" | arg = "-orig" then do;
      686 		if get_op ("   Pathname of original version of the segment is required.", arg) then
      687 		     d.ag.orig.path = op;
      688 		return (TRUE);
      689 	     end;
      690 	return (FALSE);
      691 
      692 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      693 
      694 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      695 
      696 check_arg$rnb:
      697      entry returns (bit (1));
      698 
      699 	if arg = "-renumber" | arg = "-rnb" then do;
      700 		d.ag.ctl.renumber = TRUE;
      701 		return (TRUE);
      702 	     end;
      703 	else if arg = "-no_renumber" | arg = "-nrnb" then do;
      704 		d.ag.ctl.renumber = FALSE;
      705 		return (TRUE);
      706 	     end;
      707 	return (FALSE);
      708 
      709 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      710 
      711 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      712 
      713 check_arg$no_summary:
      714      entry returns (bit (1));
      715 
      716 	if arg = "-no_summary" | arg = "-nsm" then do;
      717 		d.ag.input.value.summary = "";
      718 		d.ag.input.sm = NOxxx;
      719 		return (TRUE);
      720 	     end;
      721 
      722 check_arg$summary:
      723      entry returns (bit (1));
      724 
      725 	if arg = "-summary" | arg = "-sm" then do;
      726 		if get_op ("A change summary is required.", arg) then do;
      727 			if op = "" then do;
      728 				call check_error (error_table_$bad_arg, CALLER, "^3x^a """" Clearing the summary field is not allowed.", arg);
      729 			     end;
      730 			else do;
      731 				if length (op) > maxlength (d.ag.input.summary) then
      732 				     call check_error (error_table_$bigarg, CALLER, "^3xOperand of -summary must be <= ^d characters 
      733                long.", op, maxlength (d.ag.input.value.summary));
      734 
      735 				d.ag.input.value.summary = op || NL;
      736 				d.ag.input.sm = OPERANDxxx;
      737 			     end;
      738 		     end;
      739 		return (TRUE);
      740 	     end;
      741 	else if arg = "-input_summary" | arg = "-ism" then do;
      742 		d.ag.input.value.summary = "";
      743 		d.ag.input.sm = INPUTxxx;
      744 		return (TRUE);
      745 	     end;
      746 	return (FALSE);
      747 
      748 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      749 
      750 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      751 
      752 check_arg$vdt:
      753      entry returns (bit (1));
      754 
      755 	if arg = "-validate" | arg = "-vdt" then do;
      756 		if get_op ("A validation routine acceptable to cv_entry_ is required.", arg) then do;
      757 			d.ag.vdt = cv_entry_ (op, codeptr (FATAL_ERROR), code);
      758 
      759 			call check_error (code, CALLER, "^3x^a ^a^/^3xInvalid validation entry name",
      760 			     arg, op);
      761 		     end;
      762 		return (TRUE);
      763 	     end;
      764 	return (FALSE);
      765 						/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      766 
      767 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      768 
      769 check_arg$ERROR:
      770      entry;
      771 
      772 	call check_error (error_table_$badopt, CALLER, "^3x^a^/^3xfor the ^a operation.", arg, oper (d.ag.op.name, 1));
      773 	if d.Saf then do;
      774 		call set_return_arg ("false");
      775 		Sactive_function_err = TRUE;
      776 	     end;
      777 
      778 	return;
      779 
      780      end check_arg;
      781 
      782 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      783 
      784 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      785 
      786 	dcl     Serror_has_occurred	 bit (1);		/* On if check_error has detected an error.	*/
      787 
      788 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      789 /*									*/
      790 /* Syntax:  dcl check_error entry options(variable);				*/
      791 /* 	  call check_error (code, procedure_name, ioa_ctl_str, args);		*/
      792 /*     or:  dcl check_error$fatal entry options(variable);				*/
      793 /*	  call check_error$fatal (code, procedure_name, ioa_ctl_str, args);		*/
      794 /*									*/
      795 /* Function: calls com_err_ or active_fnc_error_ as appropriate, to report an error on	*/
      796 /* behalf of vtm.  check_error continues processing after the error is reported (but	*/
      797 /* only if the user types "start" after active_fnc_err_ is called), whereas		*/
      798 /* check_error$fatal stops all processing after the error message is printed.		*/
      799 /*									*/
      800 /* Args:									*/
      801 /* code (fixed bin(35))							*/
      802 /*    a status code.							*/
      803 /* procedure_name (char(*))							*/
      804 /*    name of the procedure reporting the error.					*/
      805 /* ioa_ctl_str								*/
      806 /*    error message								*/
      807 /* args									*/
      808 /*    args ioa_ will substitute into the error message.				*/
      809 /*									*/
      810 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      811 
      812 
      813 check_error:
      814      proc options (variable);
      815 
      816 	dcl     Pcode		 ptr,
      817 	        Serrors_are_fatal	 bit (1),		/* On if errors are fatal.			*/
      818 	        code		 fixed bin (35) based (Pcode);
      819 
      820 	dcl     com_err_		 entry () options (variable),
      821 	        cu_$arg_list_ptr	 entry returns (ptr),
      822 	        cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      823 
      824 
      825 	Serrors_are_fatal = FALSE;
      826 	go to COMMON;
      827 
      828 check_error$fatal:
      829      entry options (variable);
      830 
      831 	Serrors_are_fatal = TRUE;
      832 	go to COMMON;
      833 
      834 COMMON:	call cu_$arg_ptr (1, Pcode, 0, 0);		/* Access error table code argument.		*/
      835 	if code = 0 then return;			/* If non-zero, this ISN'T an error.		*/
      836 	Serror_has_occurred = TRUE;
      837 	if code = -1 then code = 0;			/* No error table code fits the desired err msg.	*/
      838 	call cu_$generate_call (com_err_, cu_$arg_list_ptr ());
      839 	if Serrors_are_fatal then do;
      840 	     if d.Saf then
      841 	        call set_return_arg ("false");
      842 	     go to FATAL_ERROR;
      843 	     end;
      844 	return;
      845 
      846 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      847 
      848 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      849 /*									*/
      850 /* Syntax:  call check_error$init();						*/
      851 /*									*/
      852 /* Function:  Initializes switch indicating that no errors occurred so far.		*/
      853 /*									*/
      854 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      855 
      856 check_error$init:
      857      entry;
      858 
      859 	Serror_has_occurred = FALSE;
      860 	return;
      861 
      862 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      863 
      864 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      865 /*									*/
      866 /* Syntax:  error_has_occurred = check_error$error_has_occurred();			*/
      867 /*									*/
      868 /* Function:  tell callers if any errors have occurred so far.			*/
      869 /*									*/
      870 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      871 
      872 
      873 check_error$error_has_occurred:
      874      entry returns (bit (1));
      875 
      876 	return (Serror_has_occurred);
      877 
      878      end check_error;
      879 
      880 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      881 
      882 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      883 
      884 	dcl     Iarg		 fixed bin,	/* Current argument being processed.		*/
      885 	        Larg		 fixed bin (21),	/* Length of current argument.		*/
      886 	        Lop		 fixed bin (21),	/* Length of current ctl arg operand.		*/
      887 	        Lret		 fixed bin (21),	/* Max length of AF return value.		*/
      888 	        Nargs		 fixed bin,	/* Number of arguments.			*/
      889 	        Parg		 ptr,		/* Ptr to current argument.			*/
      890 	        Pop		 ptr,		/* Ptr to current operand.			*/
      891 	        Pret		 ptr,		/* Ptr to AF return value.			*/
      892 	        arg		 char (Larg) based (Parg),
      893 	        op		 char (Lop) based (Pop),
      894 	        ret		 char (Lret) varying based (Pret),
      895 	        true_false_value	 char (5) varying,
      896 	        (arg_ptr		 variable,
      897 	        cu_$af_arg_ptr,
      898 	        cu_$arg_ptr)	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      899 	        cu_$af_return_arg	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      900 	        (err		 variable,
      901 	        active_fnc_err_,
      902 	        com_err_)		 entry () options (variable);
      903 
      904 get_invocation_type:				/* Were we invoked as command or af?  Arg count?	*/
      905      proc (Saf);
      906 
      907 	dcl     Saf		 bit (1) aligned;
      908 
      909 	call cu_$af_return_arg (Nargs, Pret, Lret, code);
      910 	if code = 0 then do;
      911 		Saf = TRUE;
      912 		arg_ptr = cu_$af_arg_ptr;
      913 		err = active_fnc_err_;
      914 		ret = "";
      915 	     end;
      916 	else do;
      917 		Saf = FALSE;
      918 		arg_ptr = cu_$arg_ptr;
      919 		err = com_err_;
      920 		Pret = addr (true_false_value);
      921 		Lret = maxlength (true_false_value);
      922 		ret = "";
      923 	     end;
      924 	Iarg = 0;					/* No args processed so far.			*/
      925 
      926      end get_invocation_type;
      927 
      928 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      929 
      930 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      931 
      932 get_arg:
      933      proc returns (bit (1));				/* Returns TRUE if another argument exists.	*/
      934 						/*   Its value is accessible via arg variable.	*/
      935 
      936 	if Iarg + 1 > Nargs then
      937 	     return (FALSE);
      938 	Iarg = Iarg + 1;
      939 	call arg_ptr (Iarg, Parg, Larg, code);
      940 	return (TRUE);
      941 
      942 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      943 
      944 get_op:
      945      entry (str, arg1) returns (bit (1));		/* Returns TRUE if another argument exists.	*/
      946 						/*   Its value is accessible via op variable.	*/
      947 
      948 	dcl     str		 char (*),
      949 	        arg1		 char (*);
      950 
      951 	if Iarg + 1 > Nargs then do;
      952 		if str ^= "" then
      953 		     call check_error (error_table_$noarg, CALLER, "^3xOperand of ^a^/^a", arg1, str);
      954 		return (FALSE);
      955 	     end;
      956 	Iarg = Iarg + 1;
      957 	call arg_ptr (Iarg, Pop, Lop, code);
      958 	return (TRUE);
      959 
      960 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      961 
      962 put_arg:						/* Return argument or      */
      963 put_op:						/* operand to list of      */
      964      entry;					/* unprocessed d.ag.       */
      965 
      966 	Iarg = Iarg - 1;
      967 	return;
      968 
      969 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      970 
      971 
      972 reprocess_args:					/* Reprocess argument list again, starting with	*/
      973      entry (Ith_arg);				/*   the Ith argument.			*/
      974 
      975 	dcl     Ith_arg		 fixed bin;
      976 
      977 	Iarg = Ith_arg - 1;				/* get_arg adds 1 before reading an arg.	*/
      978 	return;
      979 
      980      end get_arg;
      981 
      982 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      983 
      984 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      985 
      986 set_return_arg:					/* Set AF return value.			*/
      987      proc (str);
      988 
      989 	dcl     str		 char (*);
      990 
      991 	ret = str;
      992 	return;
      993 
      994 add_to_return_arg:
      995      entry (str);
      996 
      997 	if ret = "" then
      998 	     ret = requote_string_ (str);
      999 	else do;
     1000 		ret = ret || " ";
     1001 		ret = ret || requote_string_ (str);
     1002 	     end;
     1003 	return;
     1004 
     1005 
     1006 add_to_return_arg_var:
     1007      entry (str_var);
     1008 
     1009 	dcl     str_var		 char (*) varying;
     1010 
     1011 	if ret = "" then
     1012 	     ret = requote_string_ ((str_var));
     1013 	else do;
     1014 		ret = ret || " ";
     1015 		ret = ret || requote_string_ ((str_var));
     1016 	     end;
     1017 	return;
     1018 
     1019      end set_return_arg;
     1020 
     1021 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1022 
     1023 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1024 
     1025 get_com_spec:
     1026      proc;
     1027 
     1028 	dcl     from_arg		 char (80) var,
     1029 	        (spec, i, j)	 fixed bin,
     1030 	        to_arg		 char (80) var;
     1031 
     1032 	dcl     specs		 (11, 2) char (12) var int static options (constant) init (
     1033 				 "all", "a",	/*  1 */
     1034 				 "old", "~",	/*  2 */
     1035 				 "new", "~",	/*  3 */
     1036 				 "complete", "cpt", /*  4 */
     1037 				 "incomplete", "icpt", /*  5 */
     1038 				 "approved", "apv", /*  6 */
     1039 				 "unapproved", "unapv", /*  7 */
     1040 				 "audited", "aud",	/*  8 */
     1041 				 "unaudited", "unaud", /*  9 */
     1042 				 "installed", "in", /* 10 */
     1043 				 "uninstalled", "unin"); /* 11 */
     1044 
     1045 	spec = 0;
     1046 	do j = lbound (specs, 2) to hbound (specs, 2) while (spec = 0);
     1047 	     do i = lbound (specs, 1) to hbound (specs, 1) while (spec = 0);
     1048 		if arg = specs (i, j) then
     1049 		     spec = i;
     1050 	     end;
     1051 	end;
     1052 	if spec > 0 then
     1053 	     substr (string (d.com_spec.selected), spec, 1) = TRUE;
     1054 
     1055 	else do;
     1056 		d.com_spec.Nrange = d.com_spec.Nrange + 1;
     1057 		d.com_spec.range (d.Nrange) = 0;
     1058 		from_arg = before (arg, ":");
     1059 		to_arg = after (arg, ":");
     1060 		d.com_spec.from (d.Nrange) = get_range (from_arg);
     1061 
     1062 		if to_arg ^= "" then /* one part				*/
     1063 		     d.com_spec.to (d.Nrange) = get_range (to_arg);
     1064 	     end;					/*range*/
     1065 	return;
     1066 
     1067 get_range:
     1068      proc (arg_in) returns (1 like d.com_spec.range.from);
     1069 
     1070 	dcl     arg_in		 char (80) var;
     1071 	dcl     1 arg_out		 like d.com_spec.range.from;
     1072 
     1073 	dcl     operand		 char (80) var,
     1074 	        addend		 char (80) var;
     1075 
     1076 	operand, addend = "";
     1077 	arg_out = 0;
     1078 	arg_out.set = SET;
     1079 
     1080 	if index (arg_in, "+") > 0 then do;
     1081 		operand = before (arg_in, "+");
     1082 		addend = after (arg_in, "+");
     1083 		arg_out.op = PLUS;
     1084 	     end;
     1085 	else if index (arg_in, "-") > 0 then do;
     1086 		operand = before (arg_in, "-");
     1087 		addend = after (arg_in, "-");
     1088 		arg_out.op = MINUS;
     1089 	     end;
     1090 	else do;
     1091 		operand = arg_in;
     1092 		addend = "";
     1093 		arg_out.op = UNSET;
     1094 	     end;
     1095 
     1096 	if verify (operand, "0123456789") = 0 then
     1097 	     arg_out.no = convert (arg_out.no, operand);
     1098 	else do;
     1099 		if operand = "first" | operand = "f" then
     1100 		     arg_out.no = 1;
     1101 		else if operand = "last" | operand = "l" then
     1102 		     arg_out.set = LAST;
     1103 		else call check_error$fatal (error_table_$badopt, CALLER, "^3x^a.", arg_in);
     1104 	     end;
     1105 
     1106 	if addend ^= "" then do;
     1107 		if verify (addend, "0123456789") = 0 then
     1108 		     arg_out.addend = convert (arg_out.addend, addend);
     1109 		else
     1110 		     call check_error (error_table_$improper_data_format, CALLER, "^/^3xThe addend must be numeric:  ^a", addend);
     1111 	     end;
     1112 
     1113 	return (arg_out);
     1114 
     1115      end get_range;
     1116 
     1117      end get_com_spec;
     1118 
     1119 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1120 
     1121 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1122 
     1123 
     1124 hcom_janitor:
     1125      proc;
     1126 
     1127 	dcl     code		 fixed bin (35);
     1128 
     1129 	if temp_seg_array (1) ^= null then
     1130 	     call release_temp_segments_ (CALLER, temp_seg_array, code);
     1131 
     1132      end hcom_janitor;
     1133 
     1134 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1135 
     1136 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1137 
     1138 
     1139 init$args:
     1140      proc;
     1141 
     1142 	current_date = date_time_$format ("^yc-^my-^dm", clock (), "", "");
     1143 	call user_info_ (user_name, "", "");
     1144 
     1145 	d.ag.op.name = NOTSET;
     1146 	d.ag.op.type = NO_MODIFY;
     1147 
     1148 	Sactive_function_err = FALSE;
     1149 	Sfill_arg = FALSE;
     1150 
     1151 	on linkage_error
     1152 	     begin;
     1153 		d.Ssite = FALSE;
     1154 		d.ag.vdt = hcom_default_validate_;
     1155 		goto CONTINUE;
     1156 	     end;
     1157 
     1158 	d.ag.vdt = hcom_site_validate_;
     1159 	d.Ssite = TRUE;
     1160 
     1161 CONTINUE:
     1162 	d.ag.ctl.renumber = FALSE;
     1163 	d.ag.ctl.errors = TRUE;
     1164 	d.ag.ctl.fill = TRUE;
     1165 	d.ag.source.path, d.ag.source.dir, d.ag.source.ent, d.ag.source.comp = "";
     1166 	d.ag.source.ent_type = 0;
     1167 	d.ag.orig = d.ag.source;
     1168 	d.ag.input.select = NOxxx;
     1169 	d.ag.input.value.change_dt = current_date;
     1170 	d.ag.input.value.seqno = 0;
     1171 	d.ag.input.value.selected = FALSE;
     1172 	d.ag.input.value.Ieq = 0;
     1173 	d.ag.input.value.comment_no = 0;
     1174 	d.ag.input.value.change_person = rtrim (user_name);
     1175 	d.ag.input.value.approve_dt = "";
     1176 	d.ag.input.value.approve_value = "";
     1177 	d.ag.input.value.audit_dt = "";
     1178 	d.ag.input.value.audit_person = "";
     1179 	d.ag.input.value.install_dt = "";
     1180 	d.ag.input.value.install_id = "";
     1181 	d.ag.input.value.summary = "";
     1182 	d.ag.output = FALSE;
     1183 
     1184 	d.com_spec.selected = FALSE;
     1185 	d.com_spec.matched = FALSE;
     1186 	d.com_spec.Nrange, d.com_spec.range = 0;
     1187 
     1188 	d.check_error$fatal = check_error$fatal;
     1189 	d.set_return_arg = set_return_arg;
     1190 	d.add_to_return_arg = add_to_return_arg;
     1191 	d.add_to_return_arg_var = add_to_return_arg_var;
     1192 	d.Saf = FALSE;
     1193 	d.Scfix = FALSE;
     1194 	d.Scfix_found = FALSE;
     1195 
     1196 	d.seg_arch.dir, d.seg_arch.ent, d.seg_arch.comp = "";
     1197 	d.seg_arch.comp_type = NOCOMP;
     1198 	d.seg_arch.Pseg = null;
     1199 	d.seg_arch.Lseg, d.seg_arch.Lsegbc = 0;
     1200 
     1201 	d.seg = d.seg_arch, by name;
     1202 	d.seg.Lseg_in, d.seg.Lseg_out = 0;
     1203 	d.seg.ec_version, d.seg.type, d.seg.text_pos = 0;
     1204 	d.seg.cmt_bgn, d.seg.cmt_end = "";
     1205 	d.seg.Pbox = null;
     1206 	d.seg.Loldbox = 0;
     1207 	d.seg.Lnewbox = 0;
     1208 
     1209 	d.orig_seg = d.seg;
     1210 
     1211 	d.temp_seg = null;
     1212 
     1213      end init$args;
     1214 
     1215 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1216 
  1     1 /*  START OF:	hcom_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(85-10-02,LJAdams), approve(85-11-06,MCR7278),
  1     6*     audit(86-02-19,Gilcrease), install(86-02-19,MR12.0-1021):
  1     7*     Provides data structure for the history comment
  1     8*     programs.
  1     9*  2) change(86-04-17,LJAdams), approve(86-04-17,MCR7386),
  1    10*     audit(86-06-05,Gilcrease), install(86-06-05,MR12.0-1071):
  1    11*     Added d.ag.ctl.fill to indicate if summary is to be filled or not.
  1    12*     Added fill bit to src_array to indicate to fill/not fill comment.
  1    13*  3) change(86-04-30,LJAdams), approve(86-05-05,MCR7386),
  1    14*     audit(86-06-05,Gilcrease), install(86-06-05,MR12.0-1071):
  1    15*     Added parameter to d.ag.vdt to contain error message.
  1    16*  4) change(86-05-05,LJAdams), approve(86-05-05,MCR7386),
  1    17*     audit(86-06-05,Gilcrease), install(86-06-05,MR12.0-1071):
  1    18*     Added switch to indicate if a critical fix number had been found while
  1    19*     parsing.
  1    20*                                                   END HISTORY COMMENTS */
  1    21 
  1    22 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    23 	/*									*/
  1    24 	/* This include file contains the arguments needed for processing history comments.	*/
  1    25 	/*									*/
  1    26 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    27 
  1    28 
  1    29 dcl 	1 d			aligned based(Pd),
  1    30 	  2 ag,
  1    31 	    3 op,
  1    32 	      4 name		fixed bin,
  1    33 	      4 type		bit(1),		/* 0 = NO_MODIFY, 1 = MODIFY			*/
  1    34 	    3 vdt			entry (char(*) var, char(*) var, char(*) var, bit(1), char(*) var,
  1    35 				   char(*) var, char(100) var) variable,
  1    36 						/* = nothing for -nvdt			*/
  1    37 	    3 ctl,
  1    38 	      4 errors		bit(1) unal,
  1    39 	      4 fill                  bit(1) unal,
  1    40 	      4 renumber		bit(1) unal,
  1    41 	      4 mbz		bit(33) unal,
  1    42 	    3 source,
  1    43 	      4 path		char(202) unal,
  1    44 	      4 dir		char(168) unal,
  1    45 	      4 ent		char(32) unal,
  1    46 	      4 ent_type		fixed bin(35),	/*  0 = NONSTAR,  1 = STAR,   2 = STARSTAR	*/
  1    47 	      4 comp		char(32) unal,
  1    48 	    3 orig		like d.source,
  1    49 	    3 input,
  1    50 	      4 select,
  1    51 	        5 sm		fixed bin(2),
  1    52 	        5 apv		fixed bin(2),
  1    53 	        5 aud		fixed bin(2),
  1    54 	        5 in		fixed bin(2),	/* 0 = NOxxx,      1 = CLEARxxx		*/
  1    55 						/* 2 = OPERANDxxx, 3 = INPUTxxx		*/
  1    56 	      4 value                like src_array.comments,
  1    57 	    3 output,
  1    58 	     (4 cdt,
  1    59 	      4 cpi,
  1    60 	      4 apvdt,
  1    61 	      4 apvi,
  1    62 	      4 auddt,
  1    63 	      4 audpi,
  1    64 	      4 indt,
  1    65 	      4 ini,
  1    66 	      4 sm)		bit(1) unal,
  1    67 	      4 mbz		bit(27) unal,
  1    68 	  2 com_spec,
  1    69 	    3 selected		unal,
  1    70 	      4 all		bit(1),
  1    71 	      4 old		bit(1),
  1    72 	      4 new		bit(1),
  1    73 	      4 cpt		bit(1),
  1    74 	      4 icpt		bit(1),
  1    75 	      4 apv		bit(1),
  1    76 	      4 unapv		bit(1),
  1    77 	      4 aud		bit(1),
  1    78 	      4 unaud		bit(1),
  1    79 	      4 in		bit(1),
  1    80 	      4 unin		bit(1),
  1    81                 4 mbz		bit(25),
  1    82 	    3 matched		unaligned like d.com_spec.selected,
  1    83 	    3 Nrange		fixed bin,
  1    84 	    3 range (10),
  1    85 	      4 from,
  1    86 	        5 set		fixed bin(2),	/* 0 = UNSET, 1 = SET,  2 = LAST		*/
  1    87 	        5 no		fixed bin,
  1    88 	        5 op		fixed bin(2),	/* 0 = UNSET, 1 = PLUS  2 = MINUS		*/
  1    89 	        5 addend		fixed bin,
  1    90 	        5 result		fixed bin,
  1    91 	      4 to		like d.com_spec.range.from,
  1    92 	      4 matched		fixed bin(1),
  1    93 
  1    94 	  2 field_array (9)		fixed bin,
  1    95 	  2 check_error$fatal	entry options(variable) variable,
  1    96             2 set_return_arg            entry (char(*)) variable,
  1    97             2 add_to_return_arg	entry (char(*)) variable,
  1    98 	  2 add_to_return_arg_var     entry (char(*) var) variable,
  1    99             2 Saf                       bit(1),		/* switch to indicate active function		*/
  1   100 
  1   101 	  2 Scfix			bit(1),		/* switch to indicate critical fix input	*/
  1   102 	  2 Scfix_found               bit(1),
  1   103 	  2 Ssite                     bit(1),             /* switch to indicate site			*/
  1   104 	  2 seg_arch,				/* info for seg or achive used by 		*/
  1   105 	    3 dir			char(168) unal,	/* hcom_process_path_			*/
  1   106 	    3 ent			char(32) unal,
  1   107 	    3 comp		char(32) unal,
  1   108 	    3 comp_type		fixed bin(35),      /* -1 = NOCOMP, 0 = NONSTAR			*/
  1   109 						/*  1 = STAR,   2 = STARSTAR			*/
  1   110 	    3 Pseg		ptr,
  1   111 	    3 Lseg		fixed bin(21),
  1   112 	    3 Lsegbc		fixed bin(24),
  1   113 
  1   114 	  2 seg,					/* info for specific seg or archive component	*/
  1   115 	    3 dir			char(168) unal,	/* used by hcom_process_seg_.			*/
  1   116 	    3 ent			char(32) unal,
  1   117 	    3 comp		char(32) unal,
  1   118 	    3 Pseg		ptr,
  1   119 	    3 Lseg_in		fixed bin(21),
  1   120 	    3 Lseg_out		fixed bin(21),
  1   121 	    3 ec_version		fixed bin,	/* if type is 3 (an exec_com), this will be its	*/
  1   122 						/* version, as obtained from get_ec_version_	*/
  1   123               3 type                    fixed bin,	/* the language type of the entry		*/
  1   124 	    3 text_pos                fixed bin(21),	/* this will be the char pos of the first	*/
  1   125 						/* non-version char in an exec_com		*/
  1   126 	    3 cmt_bgn                 char(8) var,	/* comment begin character(s)			*/
  1   127               3 cmt_end                 char(8) var,	/* comment end character(s)			*/
  1   128 	    3 Pbox		ptr,
  1   129 	    3 Loldbox		fixed bin(21),
  1   130 	    3 Lnewbox		fixed bin(21),
  1   131 	  2 orig_seg		like d.seg,	/* info for original seg/comp used by		*/
  1   132 						/* hcom_process_seg_			*/
  1   133 
  1   134 	  2 temp_seg,
  1   135 	    3 Pcomp_info		ptr,
  1   136 	    3 Pformed_string	ptr,
  1   137 	    3 Porig_array		ptr,
  1   138 	    3 Pout_string		ptr,
  1   139 	    3 Presult		ptr,
  1   140 	    3 Psort_copy		ptr,
  1   141 	    3 Psrc_array		ptr,
  1   142 	temp_seg_array (7)		ptr aligned based (addr(d.temp_seg)),
  1   143 
  1   144 	Pd              		ptr;
  1   145 
  1   146 dcl	CALLER			char(15) int static options(constant) init("history_comment"),
  1   147 
  1   148          (NOTSET			init(0),		/* values for d.ag.op.name			*/
  1   149 	ADD			init(1),
  1   150 	ADD_FIELD			init(2),
  1   151 	CHECK			init(3),
  1   152           COMPARE			init(4),
  1   153 	DISPLAY			init(5),
  1   154 	EXISTS			init(6),
  1   155 	FORMAT			init(7),
  1   156 	GET			init(8),
  1   157 	INSTALL			init(9),
  1   158 	REPLACE_FIELD		init(10)) fixed bin int static options(constant),
  1   159          (MODIFY			init("1"b),	/* values for d.ag.op.type			*/
  1   160 	NO_MODIFY			init("0"b)) bit(1) int static options(constant),
  1   161          (CLEARxxx			init(1),		/* values for d.ag.input.select		*/
  1   162 	INPUTxxx			init(3),
  1   163 	NOxxx			init(0),
  1   164 	OPERANDxxx		init(2)) fixed bin(2) int static options(constant),
  1   165          (NOCOMP			init(-1),		/* values for d.ag.ent_type, and 		*/
  1   166 	NONSTAR			init(0),		/*   d.seg_arch.comp_type			*/
  1   167 	STAR			init(1),
  1   168 	STARSTAR		          init(2)) fixed bin(35) int static options(constant),
  1   169 	ALL			bit(36) aligned int static options(constant) init("1"b),
  1   170 						/* value comparable to string(d.com_spec.selected)*/
  1   171          (LAST			init(2),		/* values for d.ag.com_spec.range.set		*/
  1   172 	SET			init(1),
  1   173 	UNSET			init(0)) fixed bin(2) int static options(constant),
  1   174          (MINUS			init(2),		/* values for d.ag.com_spec.range.op		*/
  1   175 	PLUS			init(1)) fixed bin(2) int static options(constant);
  1   176 	
  1   177 dcl	oper (10,2)         	char(16) varying int static options(constant) init (
  1   178                                "add",            "~",      /*  1 Operations */
  1   179 			 "add_field",      "af",     /*  2 */
  1   180 			 "check",          "ck",     /*  3 */
  1   181                                "compare",        "cmp",    /*  4 */
  1   182 			 "display",        "ds",     /*  5 */
  1   183 			 "exists",         "~",      /*  6 */
  1   184 			 "format",         "fmt",    /*  7 */
  1   185 			 "get",	         "~",      /*  8 */
  1   186 			 "install",        "~",      /*  9 */
  1   187 			 "replace_field",  "rpf");   /* 10 */
  1   188 
  1   189 dcl	1 src_array		based(Psrc_array) aligned,
  1   190 	  2 Ncoms			fixed bin,
  1   191 	  2 comments (0 refer (src_array.Ncoms)),
  1   192 	    3 change_dt		char(8),
  1   193 	    3 seqno		pic "9999",
  1   194 	    3 fill		bit(1),
  1   195 	    3 selected		bit(1),
  1   196 	    3 Ieq			fixed bin,
  1   197 	    3 comment_no		fixed bin,
  1   198 	    3 change_person		char(24) varying,
  1   199 	    3 approve_dt		char(8),
  1   200 	    3 approve_value		char(24) varying,
  1   201 	    3 audit_dt		char(8),
  1   202 	    3 audit_person		char(24) varying,
  1   203 	    3 install_dt		char(8),
  1   204 	    3 install_id		char(24) varying,
  1   205 	    3 summary		char(2000) varying,
  1   206 	    3 err_msg (5)		char(80) varying;
  1   207 	
  1   208 
  1   209 dcl	Psrc_array		ptr;
  1   210 
  1   211 /*  END OF:	hcom_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1217 
     1218 
     1219 	dcl     1 auto_hcom_data	 like d automatic;
     1220 
     1221 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1222 
  2     1 /* BEGIN INCLUDE FILE ... hcom_field_names.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-09-20,LJAdams), approve(85-11-06,MCR7278),
  2     6*     audit(86-02-19,Gilcrease), install(86-02-19,MR12.0-1021):
  2     7*     Created September 1985.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 declare   AUTHOR_FIELD_NAME char (24) varying internal static options (constant) init ("author");
  2    11 declare   APPROVAL_FIELD_NAME char (24) varying internal static options (constant) init ("approval");
  2    12 declare   AUDIT_FIELD_NAME char (24) varying internal static options (constant) init ("audit");
  2    13 declare   INSTALL_FIELD_NAME char (24) varying internal static options (constant) init ("install");
  2    14 
  2    15 /* END INCLUDE FILE ... hcom_field_names.incl.pl1 */
     1223 
     1224      end history_comment;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/12/86  1527.0  hcom.pl1                          >spec>install>1213>hcom.pl1
1217         1    06/05/86  1155.4  hcom_data.incl.pl1                >ldd>include>hcom_data.incl.pl1
1223         2    02/19/86  1535.3  hcom_field_names.incl.pl1         >ldd>include>hcom_field_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADD                                    constant        fixed bin(17,0)          initial dcl 1-146 ref 157 297 330 337
ADD_FIELD                              constant        fixed bin(17,0)          initial dcl 1-146 ref 330 341 365
APPROVAL_FIELD_NAME             000325 constant        varying char(24)         initial dcl 2-11 set ref 397* 403*
CALLER                          000500 constant        char(15)                 initial unaligned dcl 1-146 set ref 140* 145* 173*
                                                                                  303* 323* 326* 353* 359* 388* 397 399* 403 409*
                                                                                  415 418 420* 443* 444* 483* 534* 601* 651* 728*
                                                                                  731* 759* 772* 952* 1103* 1109* 1129*
CHECK                                  constant        fixed bin(17,0)          initial dcl 1-146 ref 160 168 297 373
CLEARxxx                               constant        fixed bin(2,0)           initial dcl 1-146 ref 369 370 371 480 648
COMPARE                                constant        fixed bin(17,0)          initial dcl 1-146 ref 168 326
DISPLAY                                constant        fixed bin(17,0)          initial dcl 1-146 ref 379
EXISTS                                 constant        fixed bin(17,0)          initial dcl 1-146 ref 168 177 385 448
FALSE                                  constant        bit(1)                   initial unaligned dcl 72 ref 346 363 394 414 505 526
                                                                                  540 553 556 611 620 630 637 677 690 704 707 746
                                                                                  764 825 859 917 936 954 1148 1149 1153 1161 1171
                                                                                  1182 1184 1185 1192 1193 1194
FORMAT                                 constant        fixed bin(17,0)          initial dcl 1-146 ref 330 385
GET                                    constant        fixed bin(17,0)          initial dcl 1-146 ref 172 346 388
INPUTxxx                               constant        fixed bin(2,0)           initial dcl 1-146 ref 157 163 338 342 356 496 666
                                                                                  743
INSTALL                                constant        fixed bin(17,0)          initial dcl 1-146 ref 162 168 297 330 385
INSTALL_FIELD_NAME              000316 constant        varying char(24)         initial dcl 2-13 set ref 415* 418*
Iarg                            000161 automatic       fixed bin(17,0)          dcl 884 set ref 924* 936 938* 938 939* 951 956* 956
                                                                                  957* 966* 966 977*
Ieq                     354            based           fixed bin(17,0)          level 5 dcl 1-29 set ref 1172*
Ith_arg                                parameter       fixed bin(17,0)          dcl 975 ref 972 977
LAST                                   constant        fixed bin(2,0)           initial dcl 1-146 ref 1101
Larg                            000162 automatic       fixed bin(21,0)          dcl 884 set ref 122 126 137 140 140 202 293 303 303
                                                                                  475 475 476 476 493 493 499 499 514 514 520 520
                                                                                  532 548 548 552 552 583 583 585 585 601 601 608
                                                                                  608 619 619 624 624 637 637 643 643 644 644 663
                                                                                  663 670 670 685 685 686 686 699 699 703 703 716
                                                                                  716 725 725 726 726 728 728 741 741 755 755 756
                                                                                  756 759 759 772 772 939* 1048 1058 1059
Lnewbox                2211            based           fixed bin(21,0)          level 3 dcl 1-29 set ref 1207*
Loldbox                2210            based           fixed bin(21,0)          level 3 dcl 1-29 set ref 1206*
Lop                             000163 automatic       fixed bin(21,0)          dcl 884 set ref 477 483 486 590 601 601 645 651 651
                                                                                  651 655 686 727 731 731 731 735 757 757 759 759
                                                                                  957*
Lret                            000164 automatic       fixed bin(21,0)          dcl 884 set ref 448 909* 914 921* 922 991 997 1000
                                                                                  1001 1011 1014 1015
Lseg                   2074            based           fixed bin(21,0)          level 3 dcl 1-29 set ref 1199*
Lseg_in                2172            based           fixed bin(21,0)          level 3 dcl 1-29 set ref 1202*
Lseg_out               2173            based           fixed bin(21,0)          level 3 dcl 1-29 set ref 1202*
Lsegbc                 2075            based           fixed bin(24,0)          level 3 dcl 1-29 set ref 1199*
MINUS                                  constant        fixed bin(2,0)           initial dcl 1-146 ref 1088
MODIFY                                 constant        bit(1)                   initial unaligned dcl 1-146 ref 330
NL                              012274 constant        char(1)                  initial unaligned dcl 72 ref 735
NOCOMP                                 constant        fixed bin(35,0)          initial dcl 1-146 ref 1197
NOTSET                                 constant        fixed bin(17,0)          initial dcl 1-146 ref 121 123 124 125 135 136 140
                                                                                  145 196 290 293 296 1145
NO_MODIFY                              constant        bit(1)                   initial unaligned dcl 1-146 ref 334 1146
NOxxx                                  constant        fixed bin(2,0)           initial dcl 1-146 ref 338 342 342 342 342 353 353
                                                                                  353 353 502 523 673 718 1168
Nargs                           000165 automatic       fixed bin(17,0)          dcl 884 set ref 909* 936 951
Nrange                 1561            based           fixed bin(17,0)          level 3 dcl 1-29 set ref 363 1056* 1056 1057 1057
                                                                                  1057 1057 1057 1057 1057 1057 1057 1057 1057 1057
                                                                                  1057 1060 1060 1060 1060 1060 1062 1062 1062 1062
                                                                                  1062 1186*
OPERANDxxx                             constant        fixed bin(2,0)           initial dcl 1-146 ref 356 366 367 368 488 517 534
                                                                                  657 736
OPTIONAL                               constant        fixed bin(1,0)           initial dcl 565 ref 586
PLUS                                   constant        fixed bin(2,0)           initial dcl 1-146 ref 1083
Parg                            000166 automatic       pointer                  dcl 884 set ref 122 126 137 140 202 293 303 475 475
                                                                                  476 493 493 499 499 514 514 520 520 532 548 548
                                                                                  552 552 583 583 585 601 608 619 619 624 624 637
                                                                                  637 643 643 644 663 663 670 670 685 685 686 699
                                                                                  699 703 703 716 716 725 725 726 728 741 741 755
                                                                                  755 756 759 772 939* 1048 1058 1059
Pbox                   2206            based           pointer                  level 3 dcl 1-29 set ref 1205*
Pcode                           000100 automatic       pointer                  dcl 816 set ref 834* 835 837 837
Pd                              000210 automatic       pointer                  dcl 1-29 set ref 116* 119 121 135 136 137 140 140
                                                                                  140 145 145 145 157 157 157 160 160 160 162 163
                                                                                  164 164 167 168 168 168 168 172 173 177 203 290
                                                                                  293 293 296 297 297 297 303 323 326 326 326 326
                                                                                  330 330 330 330 330 330 334 337 338 338 341 342
                                                                                  342 342 342 342 346 346 346 349 350 352 353 353
                                                                                  353 353 356 356 363 363 365 366 366 367 367 368
                                                                                  368 369 369 370 370 371 371 373 374 374 376 379
                                                                                  380 380 382 385 385 385 385 388 388 388 393 395
                                                                                  397 397 399 403 403 403 409 413 415 415 415 418
                                                                                  418 418 420 436 443 446 446 448 448 478 479 480
                                                                                  483 483 483 483 486 487 488 494 495 496 500 501
                                                                                  502 515 516 517 521 522 523 533 534 534 534 537
                                                                                  549 553 581 596 598 620 625 646 647 648 651 651
                                                                                  651 655 656 657 664 665 666 671 672 673 686 700
                                                                                  704 717 718 731 731 731 735 736 742 743 757 772
                                                                                  773 840 1052 1056 1056 1057 1057 1057 1057 1057
                                                                                  1057 1057 1057 1057 1057 1057 1057 1057 1057 1060
                                                                                  1060 1060 1060 1060 1060 1062 1062 1062 1062 1062
                                                                                  1062 1129 1129 1145 1146 1153 1154 1158 1159 1161
                                                                                  1163 1164 1165 1165 1165 1165 1166 1167 1167 1168
                                                                                  1169 1170 1171 1172 1173 1174 1175 1176 1177 1178
                                                                                  1179 1180 1181 1182 1184 1185 1186 1186 1188 1189
                                                                                  1190 1191 1192 1193 1194 1196 1196 1196 1197 1198
                                                                                  1199 1199 1201 1201 1202 1202 1203 1203 1203 1204
                                                                                  1204 1205 1206 1207 1209 1209 1211
Pop                             000170 automatic       pointer                  dcl 884 set ref 477 483 486 590 601 645 651 655 686
                                                                                  727 731 731 735 757 759 957*
Pret                            000172 automatic       pointer                  dcl 884 set ref 448 909* 914 920* 922 991 997 997
                                                                                  1000 1000 1001 1001 1011 1011 1014 1014 1015 1015
Pseg                   2072            based           pointer                  level 3 dcl 1-29 set ref 1198*
REPLACE_FIELD                          constant        fixed bin(17,0)          initial dcl 1-146 ref 330 352 388
REQUIRED                               constant        fixed bin(1,0)           initial dcl 565 ref 586 600
SET                                    constant        fixed bin(2,0)           initial dcl 1-146 ref 1078
Sactive_function_err            000141 automatic       bit(1)                   unaligned dcl 45 set ref 299 775* 1148*
Saf                                    parameter       bit(1)                   dcl 907 in procedure "get_invocation_type" set ref
                                                                                  904 911* 917*
Saf                    1772            based           bit(1)                   level 2 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 119* 140* 140* 145* 145* 160 164
                                                                                  167 436 448 773 840 1192*
Scfix                  1773            based           bit(1)                   level 2 dcl 1-29 set ref 395 415 533* 1193*
Scfix_found            1774            based           bit(1)                   level 2 dcl 1-29 set ref 1194*
Serror_has_occurred             000160 automatic       bit(1)                   unaligned dcl 786 set ref 406* 836* 859* 876
Serrors_are_fatal               000102 automatic       bit(1)                   unaligned dcl 816 set ref 825* 831* 839
Sfill_arg                       000142 automatic       bit(1)                   unaligned dcl 45 set ref 356 621* 626* 1149*
Ssite                  1775            based           bit(1)                   level 2 dcl 1-29 set ref 1153* 1159*
TRUE                                   constant        bit(1)                   initial unaligned dcl 72 ref 349 374 376 380 382 385
                                                                                  406 491 497 503 518 524 533 538 549 550 554 596
                                                                                  602 606 609 621 622 625 626 627 660 667 674 688
                                                                                  700 701 705 719 739 744 762 775 831 836 911 940
                                                                                  958 1052 1159 1163 1164
UNSET                                  constant        fixed bin(2,0)           initial dcl 1-146 ref 1093
active_fnc_err_                 000064 constant        entry                    external dcl 884 ref 913
add_to_return_arg      1762            based           entry variable           level 2 dcl 1-29 set ref 1190*
add_to_return_arg_var
                       1766            based           entry variable           level 2 dcl 1-29 set ref 1191*
addend                          002736 automatic       varying char(80)         dcl 1073 in procedure "get_range" set ref 1076*
                                                                                  1082* 1087* 1092* 1106 1107 1107 1109*
addend                    3     002704 automatic       fixed bin(17,0)          level 2 in structure "arg_out" dcl 1071 in procedure
                                                                                  "get_range" set ref 1107* 1107
addr                                                   builtin function         dcl 98 ref 116 443 446 446 920 1129 1129
after                                                  builtin function         dcl 98 ref 1059 1082 1087
ag                                     based           structure                level 2 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom"
ag                              000212 automatic       structure                level 2 in structure "auto_hcom_data" unaligned
                                                                                  dcl 1219 in procedure "hcom"
all                    1557            based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 382* 385*
approve_dt              365            based           char(8)                  level 5 dcl 1-29 set ref 479* 487* 495* 501* 1175*
approve_value           367            based           varying char(24)         level 5 dcl 1-29 set ref 393 397* 397* 399* 403*
                                                                                  403* 409* 478* 483 483* 483 483 486* 494* 500* 534
                                                                                  534* 1176*
apv                     344            based           fixed bin(2,0)           level 5 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 157* 342 342* 353 367 370 480* 488*
                                                                                  496* 502* 534
apv                    1557(05)        based           bit(1)                   level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 370*
arg                                    based           char                     unaligned dcl 884 set ref 122 126 137 140* 202 293
                                                                                  303* 475 475 476* 493 493 499 499 514 514 520 520
                                                                                  532 548 548 552 552 583 583 585* 601* 608* 619 619
                                                                                  624 624 637 637 643 643 644* 663 663 670 670 685
                                                                                  685 686* 699 699 703 703 716 716 725 725 726* 728*
                                                                                  741 741 755 755 756* 759* 772* 1048 1058 1059
arg1                                   parameter       char                     unaligned dcl 948 set ref 944 952*
arg_in                                 parameter       varying char(80)         dcl 1070 set ref 1067 1080 1081 1082 1085 1086 1087
                                                                                  1091 1103*
arg_out                         002704 automatic       structure                level 1 unaligned dcl 1071 set ref 1077* 1113
arg_ptr                         000200 automatic       entry variable           dcl 884 set ref 912* 918* 939 957
aud                    1557(07)        based           bit(1)                   level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 369*
aud                     345            based           fixed bin(2,0)           level 5 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 342 353 366 369 517* 523*
audit_dt                376            based           char(8)                  level 5 dcl 1-29 set ref 516* 522* 1177*
audit_person            400            based           varying char(24)         level 5 dcl 1-29 set ref 515* 521* 1178*
auto_hcom_data                  000212 automatic       structure                level 1 unaligned dcl 1219 set ref 116
before                                                 builtin function         dcl 98 ref 1058 1081 1086
change_dt               347            based           char(8)                  level 5 dcl 1-29 set ref 1169*
change_person           356            based           varying char(24)         level 5 dcl 1-29 set ref 1174*
check_error$fatal      1752            based           entry variable           level 2 dcl 1-29 set ref 1188*
cleanup                         000152 stack reference condition                dcl 103 ref 441
clock                                                  builtin function         dcl 98 ref 1142 1142
cmt_bgn                2177            based           varying char(8)          level 3 dcl 1-29 set ref 1204*
cmt_end                2202            based           varying char(8)          level 3 dcl 1-29 set ref 1204*
code                                   based           fixed bin(35,0)          dcl 816 in procedure "check_error" set ref 835 837
                                                                                  837*
code                            000100 automatic       fixed bin(35,0)          dcl 1127 in procedure "hcom_janitor" set ref 1129*
code                            000100 automatic       fixed bin(35,0)          dcl 45 in procedure "hcom" set ref 443* 444* 757*
                                                                                  759* 909* 910 939* 957*
codeptr                                                builtin function         dcl 98 ref 757 757
com_err_                        000066 constant        entry                    external dcl 884 in procedure "hcom" ref 919
com_err_                        000070 constant        entry                    external dcl 820 in procedure "check_error" ref 838
                                                                                  838
com_spec               1556     000212 automatic       structure                level 2 in structure "auto_hcom_data" unaligned
                                                                                  dcl 1219 in procedure "hcom"
com_spec               1557            based           structure                level 2 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom"
comment_no              355            based           fixed bin(17,0)          level 5 dcl 1-29 set ref 1173*
comments                  1            based           structure                array level 2 dcl 1-189
comp                    155            based           char(32)                 level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 1165*
comp                   2060            based           char(32)                 level 3 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 1196*
comp_type              2070            based           fixed bin(35,0)          level 3 dcl 1-29 set ref 1197*
control                         000101 automatic       fixed bin(17,0)          dcl 45 set ref 123* 124 125 126*
convert                                                builtin function         dcl 98 ref 1096 1107
ctl                       6            based           structure                level 3 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom"
ctl                             000504 constant        varying char(20)         initial array dcl 77 in procedure "hcom" ref 124 124
                                                                                  125 125 126 127
cu_$af_arg_ptr                  000056 constant        entry                    external dcl 884 ref 912
cu_$af_return_arg               000062 constant        entry                    external dcl 884 ref 909
cu_$arg_list_ptr                000072 constant        entry                    external dcl 820 ref 838 838
cu_$arg_ptr                     000060 constant        entry                    external dcl 884 in procedure "hcom" ref 918
cu_$arg_ptr                     000074 constant        entry                    external dcl 820 in procedure "check_error" ref 834
cu_$generate_call               000010 constant        entry                    external dcl 58 ref 838
current_date                    000102 automatic       char(8)                  unaligned dcl 45 set ref 487 516 656 1142* 1169
cv_entry_                       000012 constant        entry                    external dcl 58 ref 757
d                                      based           structure                level 1 dcl 1-29 set ref 446 446
date_time_$format               000014 constant        entry                    external dcl 58 ref 1142
dir                      71(18)        based           char(168)                level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 1165*
dir                    1776            based           char(168)                level 3 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 1196*
ec_version             2174            based           fixed bin(17,0)          level 3 dcl 1-29 set ref 1203*
ent                    2050            based           char(32)                 level 3 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 1196*
ent                     143(18)        based           char(32)                 level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 1165*
ent_type                154            based           fixed bin(35,0)          level 4 dcl 1-29 set ref 1166*
err                             000204 automatic       entry variable           dcl 884 set ref 913* 919*
error_msg                       000104 automatic       varying char(100)        dcl 45 set ref 397* 399* 403* 405 409* 415* 418*
                                                                                  420*
error_table_$active_function    000040 external static fixed bin(35,0)          dcl 89 set ref 173*
error_table_$bad_arg            000042 external static fixed bin(35,0)          dcl 89 set ref 140* 303* 359* 534* 728*
error_table_$badopt             000044 external static fixed bin(35,0)          dcl 89 set ref 772* 1103*
error_table_$bigarg             000046 external static fixed bin(35,0)          dcl 89 set ref 483* 651* 731*
error_table_$improper_data_format
                                000050 external static fixed bin(35,0)          dcl 89 set ref 1109*
error_table_$inconsistent       000052 external static fixed bin(35,0)          dcl 89 set ref 326*
error_table_$noarg              000054 external static fixed bin(35,0)          dcl 89 set ref 145* 323* 353* 388* 952*
errors                    6            based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 160* 164*
                                                                                  549* 553* 1163*
field                           002560 automatic       fixed bin(17,0)          dcl 565 set ref 587* 588 589 590* 595 596 598
field_array            1740            based           fixed bin(17,0)          array level 2 dcl 1-29 set ref 346 350* 581* 598*
field_name                      000142 constant        varying char(20)         initial array dcl 570 ref 588 588 589 589 590
fill                      6(01)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 620* 625*
                                                                                  1164*
from                   1562            based           structure                array level 4 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 1060*
from                   1561     000212 automatic       structure                array level 4 in structure "auto_hcom_data"
                                                                                  unaligned dcl 1219 in procedure "hcom"
from_arg                        002620 automatic       varying char(80)         dcl 1028 set ref 1058* 1060*
get_temp_segments_              000016 constant        entry                    external dcl 58 ref 443
hbound                                                 builtin function         dcl 98 ref 124 125 127 135 136 346 588 589 1046 1047
hcom_cfix_validate_             000020 constant        entry                    external dcl 58 ref 397 415 537
hcom_default_validate_          000022 constant        entry                    external dcl 58 ref 1154
hcom_process_path_              000026 constant        entry                    external dcl 58 ref 446
hcom_site_validate_             000024 constant        entry                    external dcl 58 ref 1158
i                               000136 automatic       fixed bin(24,0)          dcl 45 in procedure "hcom" set ref 125* 126 126 127*
                                                                                  136* 137 137* 346* 349 350 350*
i                               002561 automatic       fixed bin(17,0)          dcl 565 in procedure "check_arg" set ref 589* 590
                                                                                  590*
i                               002646 automatic       fixed bin(17,0)          dcl 1028 in procedure "get_com_spec" set ref 1047*
                                                                                  1048 1048*
icpt                   1557(04)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 376*
in                      346            based           fixed bin(2,0)           level 5 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 163* 342 353 368 371 648* 657* 666*
                                                                                  673*
in                     1557(09)        based           bit(1)                   level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 371*
index                                                  builtin function         dcl 98 ref 122 202 534 1080 1085
input                   343            based           structure                level 3 dcl 1-29
install_dt              407            based           char(8)                  level 5 dcl 1-29 set ref 647* 656* 665* 672* 1179*
install_id              411            based           varying char(24)         level 5 dcl 1-29 set ref 413 415* 415* 418* 418*
                                                                                  420* 646* 651 651 651 655* 664* 671* 1180*
ioa_                            000030 constant        entry                    external dcl 58 ref 448
j                               002647 automatic       fixed bin(17,0)          dcl 1028 in procedure "get_com_spec" set ref 1046*
                                                                                  1048*
j                               002562 automatic       fixed bin(17,0)          dcl 565 in procedure "check_arg" set ref 588* 590*
j                               000137 automatic       fixed bin(24,0)          dcl 45 in procedure "hcom" set ref 124* 126* 135*
                                                                                  137*
k                               002563 automatic       fixed bin(17,0)          dcl 565 set ref 581* 597* 597 598
lbound                                                 builtin function         dcl 98 ref 124 125 135 136 588 589 1046 1047
length                                                 builtin function         dcl 98 ref 483 731
linkage_error                   000000 stack reference condition                dcl 103 ref 1151
match                           002564 automatic       fixed bin(1,0)           dcl 565 set ref 586* 600*
matched                1560            based           structure                level 3 packed unaligned dcl 1-29 set ref 1185*
maxlength                                              builtin function         dcl 98 ref 483 483 483 651 651 651 731 731 731 921
name                                   based           fixed bin(17,0)          level 4 dcl 1-29 set ref 121 135 136 137* 140 145
                                                                                  157 160 162 168 168 168 168 172 173 177 203 290
                                                                                  297 297 297 303 326 330 330 330 330 330 337 341
                                                                                  346 352 365 373 379 385 385 385 388 388 388 448
                                                                                  772 1145*
new                    1557(02)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 326 374*
                                                                                  380*
no                        1     002704 automatic       fixed bin(17,0)          level 2 dcl 1071 set ref 1096* 1096 1099*
null                                                   builtin function         dcl 98 ref 1129 1198 1205 1211
old                    1557(01)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 326
op                                     based           structure                level 3 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom"
op                                     based           char                     unaligned dcl 884 in procedure "hcom" set ref 477
                                                                                  483 486 590 601* 645 651* 655 686 727 731 731* 735
                                                                                  757* 759*
op                        2     002704 automatic       fixed bin(2,0)           level 2 in structure "arg_out" dcl 1071 in procedure
                                                                                  "get_range" set ref 1083* 1088* 1093*
oper                            000334 constant        varying char(16)         initial array dcl 1-177 set ref 135 135 136 136 137
                                                                                  140* 145* 173* 303* 388* 772*
operand                         002711 automatic       varying char(80)         dcl 1073 set ref 1076* 1081* 1086* 1091* 1096 1096
                                                                                  1099 1099 1101 1101
operation                       000140 automatic       fixed bin(17,0)          dcl 45 set ref 196* 290 290* 293 296
orig                    165            based           structure                level 3 dcl 1-29 set ref 1167*
orig_seg               2212            based           structure                level 2 dcl 1-29 set ref 1209*
output                 1556            based           structure                level 3 dcl 1-29 set ref 346 349 596 1182*
path                      7            based           char(202)                level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 293 293* 296 323 1165*
path                    165            based           char(202)                level 4 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 326 374 380 686*
range                  1562            based           structure                array level 3 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 1057* 1186*
range                  1561     000212 automatic       structure                array level 3 in structure "auto_hcom_data"
                                                                                  unaligned dcl 1219 in procedure "hcom"
release_temp_segments_          000032 constant        entry                    external dcl 58 ref 1129
renumber                  6(02)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 700* 704*
                                                                                  1161*
requote_string_                 000034 constant        entry                    external dcl 58 ref 997 1001 1011 1015
ret                                    based           varying char             dcl 884 set ref 448* 914* 922* 991* 997 997* 1000*
                                                                                  1000 1001* 1001 1011 1011* 1014* 1014 1015* 1015
rtrim                                                  builtin function         dcl 98 ref 515 1174
seg                    2072     000212 automatic       structure                level 2 in structure "auto_hcom_data" unaligned
                                                                                  dcl 1219 in procedure "hcom"
seg                    2076            based           structure                level 2 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 1201* 1209
seg_arch               1776            based           structure                level 2 dcl 1-29 set ref 1201
select                  343            based           structure                level 4 dcl 1-29 set ref 1168*
selected               1556     000212 automatic       structure                level 3 in structure "auto_hcom_data" packed
                                                                                  unaligned dcl 1219 in procedure "hcom"
selected                353            based           bit(1)                   level 5 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 1171*
selected               1557            based           structure                level 3 in structure "d" packed unaligned dcl 1-29
                                                                                  in procedure "hcom" set ref 363 1052 1184*
seqno                   351            based           picture(4)               level 5 dcl 1-29 set ref 1170*
set                             002704 automatic       fixed bin(2,0)           level 2 dcl 1071 set ref 1078* 1101*
set_return_arg         1756            based           entry variable           level 2 dcl 1-29 set ref 1189*
sm                      343            based           fixed bin(2,0)           level 5 dcl 1-29 set ref 157* 338 338* 342 353 356
                                                                                  356 718* 736* 743*
source                    7            based           structure                level 3 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 1167
source                    7     000212 automatic       structure                level 3 in structure "auto_hcom_data" unaligned
                                                                                  dcl 1219 in procedure "hcom"
spec                            002645 automatic       fixed bin(17,0)          dcl 1028 set ref 1045* 1046 1047 1048* 1052 1052
specs                           000012 constant        varying char(12)         initial array dcl 1032 ref 1046 1046 1047 1047 1048
src_array                              based           structure                level 1 dcl 1-189
str                                    parameter       char                     unaligned dcl 989 in procedure "set_return_arg" set
                                                                                  ref 986 991 994 997* 1001*
str                                    parameter       char                     unaligned dcl 948 in procedure "get_arg" set ref 944
                                                                                  952 952*
str_var                                parameter       varying char             dcl 1009 ref 1006 1011 1015
string                                                 builtin function         dcl 98 ref 346 349 363 596 1052
substr                                                 builtin function         dcl 98 set ref 349* 596* 1052*
summary                 420            based           varying char(2000)       level 5 dcl 1-29 set ref 717* 731 731 731 735* 742*
                                                                                  1181*
temp_seg               2326            based           structure                level 2 dcl 1-29 set ref 443 1129 1129 1211*
temp_seg_array                         based           pointer                  array dcl 1-29 set ref 443* 1129 1129*
text_pos               2176            based           fixed bin(21,0)          level 3 dcl 1-29 set ref 1203*
to                     1567            based           structure                array level 4 dcl 1-29 set ref 1062*
to_arg                          002650 automatic       varying char(80)         dcl 1028 set ref 1059* 1062 1062*
true_false_value                000174 automatic       varying char(5)          dcl 884 set ref 920 921
type                      1            based           bit(1)                   level 4 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 330* 334* 1146*
type                   2175            based           fixed bin(17,0)          level 3 in structure "d" dcl 1-29 in procedure
                                                                                  "hcom" set ref 1203*
unapv                  1557(06)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 367*
unaud                  1557(08)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 366*
unin                   1557(10)        based           bit(1)                   level 4 packed unaligned dcl 1-29 set ref 368*
user_info_                      000036 constant        entry                    external dcl 58 ref 1143
user_name                       000143 automatic       char(24)                 unaligned dcl 45 set ref 515 1143* 1174
valid                           000151 automatic       bit(1)                   initial unaligned dcl 45 set ref 45* 394* 397* 399
                                                                                  403* 405 409 414* 415* 418* 420
value                   347            based           structure                level 4 dcl 1-29
vdt                       2            based           entry variable           level 3 dcl 1-29 set ref 403 418 537* 757* 1154*
                                                                                  1158*
verify                                                 builtin function         dcl 98 ref 1096 1107

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL                                    internal static bit(36)                  initial dcl 1-146
AUDIT_FIELD_NAME                       internal static varying char(24)         initial dcl 2-12
AUTHOR_FIELD_NAME                      internal static varying char(24)         initial dcl 2-10
NONSTAR                                internal static fixed bin(35,0)          initial dcl 1-146
Psrc_array                             automatic       pointer                  dcl 1-209
STAR                                   internal static fixed bin(35,0)          initial dcl 1-146
STARSTAR                               internal static fixed bin(35,0)          initial dcl 1-146

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          007402 constant        label                    dcl 834 ref 826 832
CONTINUE                        011466 constant        label                    dcl 1161 ref 1155
END_OP_CTL_ARGS                 003155 constant        label                    dcl 287 ref 213 223 230 236 242 248 256 263 273 285
FATAL_ERROR                     004542 constant        label                    dcl 451 ref 407 438 757 757 842
OP_CTL_ARGS                     000000 constant        label                    array(10) dcl 205 ref 203
add_to_return_arg               010150 constant        entry                    internal dcl 994 ref 1190
add_to_return_arg_var           010304 constant        entry                    internal dcl 1006 ref 1191
check_arg                       004547 constant        entry                    internal dcl 469
check_arg$ERROR                 007262 constant        entry                    internal dcl 769 ref 212 222 229 235 241 247 255 262
                                                                                  272 284
check_arg$apv                   004553 constant        entry                    internal dcl 472 ref 207 215 268 278
check_arg$audit                 005035 constant        entry                    internal dcl 511 ref 218 280
check_arg$cfix                  005163 constant        entry                    internal dcl 529 ref 208 217 269 279
check_arg$error                 005277 constant        entry                    internal dcl 545 ref 227 267
check_arg$field_name            005376 constant        entry                    internal dcl 562 ref 127 260
check_arg$fill                  005727 constant        entry                    internal dcl 616 ref 211 254 283
check_arg$install               006064 constant        entry                    internal dcl 640 ref 209 219 281
check_arg$install_required      006032 constant        entry                    internal dcl 634 ref 270
check_arg$no_summary            006552 constant        entry                    internal dcl 713 ref 277
check_arg$orig                  006347 constant        entry                    internal dcl 682 ref 221 225 232 238 244 250 258 265
                                                                                  275
check_arg$rnb                   006453 constant        entry                    internal dcl 696 ref 252
check_arg$summary               006610 constant        entry                    internal dcl 722 ref 205
check_arg$vdt                   007070 constant        entry                    internal dcl 752 ref 210 220 228 234 240 246 253 261
                                                                                  271 282
check_error                     007356 constant        entry                    internal dcl 813 ref 303 323 326 353 359 388 399 409
                                                                                  420 483 534 601 651 728 731 759 772 952 1109
check_error$error_has_occurred  007544 constant        entry                    internal dcl 873 ref 435
check_error$fatal               007370 constant        entry                    internal dcl 828 ref 140 145 173 444 1103 1188
check_error$init                007523 constant        entry                    internal dcl 856 ref 117
get_arg                         007646 constant        entry                    internal dcl 932 ref 121 129 201
get_com_spec                    010457 constant        entry                    internal dcl 1025 ref 307
get_invocation_type             007567 constant        entry                    internal dcl 904 ref 119
get_op                          007722 constant        entry                    internal dcl 944 ref 476 585 608 644 686 726 756
get_range                       010711 constant        entry                    internal dcl 1067 ref 1060 1062
hcom                            002014 constant        entry                    external dcl 29
hcom_janitor                    011272 constant        entry                    internal dcl 1124 ref 441 451
history_comment                 002024 constant        entry                    external dcl 29
init$args                       011327 constant        entry                    internal dcl 1139 ref 118
put_arg                         010066 constant        entry                    internal dcl 962
put_op                          010063 constant        entry                    internal dcl 962 ref 605
reprocess_args                  010101 constant        entry                    internal dcl 972 ref 195
set_return_arg                  010120 constant        entry                    internal dcl 986 ref 168 177 302 436 774 840 1189

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12744       13042   12301       12754
Length     13340   12301        76         262     442           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hcom                               1966 external procedure  is an external procedure.  
on unit on line 441                  64 on unit               
check_arg                               internal procedure  shares stack frame of external procedure hcom.  
check_error                          94 internal procedure  is assigned to an entry variable, and is declared options(variable).  
get_invocation_type                     internal procedure  shares stack frame of external procedure hcom.  
get_arg                                 internal procedure  shares stack frame of external procedure hcom.  
set_return_arg                       82 internal procedure  is assigned to an entry variable.  
get_com_spec                            internal procedure  shares stack frame of external procedure hcom.  
get_range                               internal procedure  shares stack frame of external procedure hcom.  
hcom_janitor                         80 internal procedure  is called by several nonquick procedures.  
init$args                           164 internal procedure  enables or reverts conditions.  
on unit on line 1151                 64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
check_error              000100 Pcode                       check_error
                         000102 Serrors_are_fatal           check_error
hcom                     000100 code                        hcom
                         000101 control                     hcom
                         000102 current_date                hcom
                         000104 error_msg                   hcom
                         000136 i                           hcom
                         000137 j                           hcom
                         000140 operation                   hcom
                         000141 Sactive_function_err        hcom
                         000142 Sfill_arg                   hcom
                         000143 user_name                   hcom
                         000151 valid                       hcom
                         000160 Serror_has_occurred         hcom
                         000161 Iarg                        hcom
                         000162 Larg                        hcom
                         000163 Lop                         hcom
                         000164 Lret                        hcom
                         000165 Nargs                       hcom
                         000166 Parg                        hcom
                         000170 Pop                         hcom
                         000172 Pret                        hcom
                         000174 true_false_value            hcom
                         000200 arg_ptr                     hcom
                         000204 err                         hcom
                         000210 Pd                          hcom
                         000212 auto_hcom_data              hcom
                         002560 field                       check_arg
                         002561 i                           check_arg
                         002562 j                           check_arg
                         002563 k                           check_arg
                         002564 match                       check_arg
                         002620 from_arg                    get_com_spec
                         002645 spec                        get_com_spec
                         002646 i                           get_com_spec
                         002647 j                           get_com_spec
                         002650 to_arg                      get_com_spec
                         002704 arg_out                     get_range
                         002711 operand                     get_range
                         002736 addend                      get_range
hcom_janitor             000100 code                        hcom_janitor

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             r_ge_a              alloc_char_temp     call_ent_var_desc   call_ent_var
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return_mac          move_label_var      make_label_var      tra_ext_1           signal_op           enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      set_chars_eis       index_chars_eis
any_to_any_truncate_clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      com_err_                      cu_$af_arg_ptr
cu_$af_return_arg             cu_$arg_list_ptr              cu_$arg_ptr                   cu_$arg_ptr
cu_$generate_call             cv_entry_                     date_time_$format             get_temp_segments_
hcom_cfix_validate_           hcom_default_validate_        hcom_process_path_            hcom_site_validate_
ioa_                          release_temp_segments_        requote_string_               user_info_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$active_function  error_table_$bad_arg          error_table_$badopt           error_table_$bigarg
error_table_$improper_data_format                           error_table_$inconsistent     error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     45 002010        29 002013       116 002032       117 002034       118 002040       119 002044       121 002053
    122 002065       123 002101       124 002103       125 002113       126 002123       127 002143       129 002154
    131 002161       132 002163       133 002165       135 002166       136 002175       137 002205       138 002225
    139 002227       140 002231       144 002302       145 002303       157 002345       160 002354       162 002367
    163 002371       164 002374       167 002402       168 002406       172 002432       173 002435       175 002466
    177 002467       195 002504       196 002510       201 002512       202 002517       203 002533       205 002535
    207 002543       208 002551       209 002557       210 002565       211 002573       212 002601       213 002602
    215 002603       217 002611       218 002617       219 002625       220 002633       221 002641       222 002647
    223 002650       225 002651       227 002657       228 002665       229 002673       230 002674       232 002675
    234 002703       235 002711       236 002712       238 002713       240 002721       241 002727       242 002730
    244 002731       246 002737       247 002745       248 002746       250 002747       252 002755       253 002763
    254 002771       255 002777       256 003000       258 003001       260 003007       261 003015       262 003023
    263 003024       265 003025       267 003033       268 003041       269 003047       270 003055       271 003063
    272 003071       273 003072       275 003073       277 003101       278 003107       279 003115       280 003123
    281 003131       282 003137       283 003145       284 003153       285 003154       290 003155       293 003162
    296 003177       297 003206       299 003215       302 003220       303 003232       306 003273       307 003274
    310 003275       323 003276       326 003327       330 003366       334 003405       337 003407       338 003411
    340 003415       341 003416       342 003420       345 003432       346 003433       349 003445       350 003451
    351 003452       352 003455       353 003457       356 003513       359 003524       363 003550       365 003555
    366 003560       367 003567       368 003576       369 003605       370 003614       371 003623       372 003632
    373 003633       374 003635       376 003644       378 003646       379 003647       380 003651       382 003660
    384 003662       385 003663       388 003674       393 003731       394 003737       395 003741       397 003743
    399 004010       401 004051       403 004052       405 004116       406 004130       407 004132       409 004133
    413 004173       414 004201       415 004203       418 004253       420 004317       435 004360       436 004371
    438 004407       441 004410       443 004432       444 004454       446 004477       448 004510       451 004542
    453 004546       469 004547       472 004552       475 004556       476 004570       477 004621       478 004627
    479 004631       480 004634       481 004636       483 004637       486 004700       487 004712       488 004715
    491 004717       493 004733       494 004743       495 004745       496 004750       497 004752       499 004766
    500 004776       501 005000       502 005003       503 005005       505 005021       511 005035       514 005040
    515 005052       516 005073       517 005076       518 005100       520 005114       521 005124       522 005126
    523 005131       524 005133       526 005147       529 005163       532 005166       533 005174       534 005177
    537 005241       538 005247       540 005263       545 005277       548 005302       549 005314       550 005317
    552 005333       553 005343       554 005346       556 005362       562 005376       581 005401       583 005414
    585 005426       586 005457       587 005463       588 005464       589 005473       590 005503       592 005523
    593 005525       595 005527       596 005531       597 005535       598 005536       599 005540       600 005541
    601 005544       602 005607       605 005623       606 005624       608 005640       609 005677       611 005713
    616 005727       619 005732       620 005744       621 005747       622 005751       624 005765       625 005775
    626 006000       627 006002       630 006016       634 006032       637 006035       640 006063       643 006067
    644 006101       645 006132       646 006140       647 006142       648 006145       649 006147       651 006150
    655 006212       656 006224       657 006227       660 006231       663 006245       664 006255       665 006257
    666 006262       667 006264       670 006300       671 006310       672 006312       673 006315       674 006317
    677 006333       682 006347       685 006352       686 006364       688 006423       690 006437       696 006453
    699 006456       700 006470       701 006473       703 006507       704 006517       705 006522       707 006536
    713 006552       716 006555       717 006567       718 006571       719 006573       722 006607       725 006613
    726 006625       727 006656       728 006664       729 006717       731 006720       735 006762       736 007005
    739 007010       741 007024       742 007034       743 007036       744 007040       746 007054       752 007070
    755 007073       756 007105       757 007136       759 007171       762 007232       764 007246       769 007262
    772 007265       773 007326       774 007332       775 007344       778 007346       813 007355       825 007365
    826 007366       828 007367       831 007377       832 007401       834 007402       835 007423       836 007434
    837 007437       838 007442       839 007466       840 007470       842 007510       844 007513       856 007522
    859 007532       860 007534       873 007543       876 007552       904 007567       909 007571       910 007606
    911 007610       912 007613       913 007620       914 007623       915 007624       917 007625       918 007627
    919 007634       920 007637       921 007641       922 007643       924 007644       926 007645       932 007646
    936 007654       938 007672       939 007673       940 007707       944 007722       951 007745       952 007751
    954 010020       956 010033       957 010034       958 010050       962 010063       966 010070       967 010072
    972 010101       977 010104       978 010110       986 010117       991 010133       992 010146       994 010147
    997 010163       999 010230      1000 010231      1001 010240      1002 010301      1003 010302      1006 010303
   1011 010317      1013 010374      1014 010375      1015 010404      1016 010455      1017 010456      1025 010457
   1045 010460      1046 010461      1047 010471      1048 010501      1050 010521      1051 010523      1052 010525
   1056 010534      1057 010536      1058 010567      1059 010605      1060 010627      1062 010655      1065 010710
   1067 010711      1076 010713      1077 010715      1078 010722      1080 010724      1081 010737      1082 010754
   1083 010777      1084 011001      1085 011002      1086 011014      1087 011031      1088 011054      1089 011056
   1091 011057      1093 011064      1096 011066      1099 011112      1101 011127      1103 011144      1106 011174
   1107 011201      1109 011225      1113 011255      1124 011271      1129 011277      1132 011325      1139 011326
   1142 011334      1143 011377      1145 011417      1146 011422      1148 011424      1149 011425      1151 011426
   1153 011442      1154 011446      1155 011452      1158 011455      1159 011464      1161 011466      1163 011472
   1164 011474      1165 011476      1166 011512      1167 011513      1168 011516      1169 011523      1170 011526
   1171 011532      1172 011533      1173 011534      1174 011535      1175 011555      1176 011560      1177 011561
   1178 011563      1179 011564      1180 011566      1181 011567      1182 011570      1184 011614      1185 011644
   1186 011674      1188 011723      1189 011730      1190 011735      1191 011742      1192 011747      1193 011750
   1194 011751      1196 011752      1197 011763      1198 011765      1199 011767      1201 011771      1202 012004
   1203 012006      1204 012011      1205 012013      1206 012014      1207 012015      1209 012016      1211 012021
   1213 012030


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
