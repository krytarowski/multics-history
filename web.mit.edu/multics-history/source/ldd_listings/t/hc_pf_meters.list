	COMPILATION LISTING OF SEGMENT hc_pf_meters
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1517.2 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style3 */
       12 hc_pf_meters:
       13      proc;
       14 
       15 /*  Program to print page faults by hardcore segments
       16*
       17*    Written December 1981 by J. Bongiovanni
       18*    Modified July 1984 by Keith Loepere to understand a paged sst.
       19**/
       20 
       21 /*  Automatic  */
       22 
       23 dcl	argl		fixed bin (21);
       24 dcl	argp		ptr;
       25 dcl	arg_no		fixed bin;
       26 dcl	code		fixed bin (35);
       27 dcl	cur_time		fixed bin (71);
       28 dcl	hr		fixed bin;
       29 dcl	HR		pic "zzz9";
       30 dcl	init_temp_segp	(4) ptr;
       31 dcl	metering_time	fixed bin (71);
       32 dcl	minute		fixed bin (35);
       33 dcl	MINUTE		pic "99";
       34 dcl	1 my_seg_aste	aligned like seg_aste;
       35 dcl	n_args		fixed bin;
       36 dcl	n_to_print	fixed bin (35);
       37 dcl	pct_pf		float;
       38 dcl	pt_relp		fixed bin (24);
       39 dcl	report_sw		bit (1);
       40 dcl	reset_sw		bit (1);
       41 dcl	sec		fixed bin (35);
       42 dcl	SEC		pic "99";
       43 dcl	seg_entryp	ptr;
       44 dcl	segn		fixed bin;
       45 dcl	segx		fixed bin;
       46 dcl	sort_sw		bit (1);
       47 dcl	sst_size		fixed bin (19);
       48 dcl	sstadd		fixed bin (24);
       49 dcl	sstp		ptr;
       50 dcl	stack_no		pic "999";
       51 dcl	total_pf		fixed bin (35);
       52 dcl	unpaged_page_tables_header
       53 			(8) bit (36) aligned;	/* should be big enough */
       54 
       55 /*  Static  */
       56 
       57 dcl	init		bit (1) int static init ("0"b);
       58 dcl	last_time		fixed bin (71) int static init (0);
       59 dcl	temp_segp		(2) ptr int static;
       60 dcl	MYNAME		char (12) int static options (constant) init ("hc_pf_meters");
       61 
       62 /*  Based  */
       63 
       64 dcl	arg		char (argl) based (argp);
       65 dcl	1 seg_info	aligned based (temp_segp (1)),
       66 	  2 n_segs	fixed bin,
       67 	  2 seg		(0 refer (seg_info.n_segs)) aligned like seg_entry;
       68 dcl	1 seg_entry	aligned based (seg_entryp),
       69 	  2 name		char (32) unaligned,
       70 	  2 rel_astep	fixed bin (18),
       71 	  2 prev_pf	fixed bin (35),
       72 	  2 cur_pf	fixed bin (35),
       73 	  2 delta_pf	fixed bin (35);
       74 dcl	1 sort_array	aligned based (temp_segp (2)),
       75 	  2 n		fixed bin (24),
       76 	  2 p		(0 refer (sort_array.n)) ptr unal;
       77 
       78 /*  Entry  */
       79 
       80 dcl	com_err_		entry options (variable);
       81 dcl	cu_$arg_count	entry (fixed bin, fixed bin (35));
       82 dcl	cu_$arg_ptr	entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       83 dcl	cv_dec_check_	entry (char (*), fixed bin (35)) returns (fixed bin (35));
       84 dcl	get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
       85 dcl	ioa_		entry options (variable);
       86 dcl	release_temp_segments_
       87 			entry (char (*), (*) ptr, fixed bin (35));
       88 dcl	ring0_get_$segptr	entry (char (*), char (*), ptr, fixed bin (35));
       89 dcl	ring_zero_peek_$by_name
       90 			entry (char (*), fixed bin (18), ptr, fixed bin (19), fixed bin (35));
       91 dcl	ring_zero_peek_$get_max_length
       92 			entry (char (*), fixed bin (19), fixed bin (35));
       93 dcl	sort_items_$general entry (ptr, entry);
       94 
       95 /*  External  */
       96 
       97 dcl	error_table_$badopt fixed bin (35) external;
       98 dcl	sys_info$time_of_bootload
       99 			fixed bin (71) external;
      100 
      101 /*  Builtin  */
      102 
      103 dcl	addr		builtin;
      104 dcl	baseno		builtin;
      105 dcl	bin		builtin;
      106 dcl	bit		builtin;
      107 dcl	clock		builtin;
      108 dcl	divide		builtin;
      109 dcl	min		builtin;
      110 dcl	mod		builtin;
      111 dcl	ptr		builtin;
      112 dcl	size		builtin;
      113 
      114 	report_sw, reset_sw, sort_sw = "0"b;
      115 	n_to_print = 262143;
      116 	call cu_$arg_count (n_args, code);
      117 	if code ^= 0
      118 	then do;
      119 		call com_err_ (code, MYNAME);
      120 		return;
      121 	     end;
      122 
      123 	do arg_no = 1 to n_args;			/* The usual argument parsing */
      124 	     call cu_$arg_ptr (arg_no, argp, argl, code);
      125 	     if arg = "-report"
      126 	     then report_sw = "1"b;
      127 	     else if arg = "-reset" | arg = "-rs"
      128 	     then reset_sw = "1"b;
      129 	     else if arg = "-report_reset" | arg = "-rr"
      130 	     then report_sw, reset_sw = "1"b;
      131 	     else if arg = "-sort"
      132 	     then sort_sw = "1"b;
      133 	     else if arg = "-first" | arg = "-ft"
      134 	     then do;
      135 		     arg_no = arg_no + 1;
      136 		     call cu_$arg_ptr (arg_no, argp, argl, code);
      137 		     if code ^= 0
      138 		     then do;
      139 			     call com_err_ (code, MYNAME, "Number to print");
      140 			     return;
      141 			end;
      142 		     n_to_print = cv_dec_check_ (arg, code);
      143 		     if code ^= 0
      144 		     then do;
      145 BAD_N_TO_PRINT:
      146 			     call com_err_ (0, MYNAME, "Invalid number to print ^a", arg);
      147 			     return;
      148 			end;
      149 		     if n_to_print <= 0
      150 		     then goto BAD_N_TO_PRINT;
      151 		     sort_sw = "1"b;
      152 		end;
      153 	     else do;
      154 		     call com_err_ (error_table_$badopt, MYNAME, arg);
      155 		     return;
      156 		end;
      157 	end;
      158 
      159 	if ^report_sw & ^reset_sw
      160 	then report_sw = "1"b;
      161 
      162 	if ^init
      163 	then do;
      164 
      165 /* First time through, copy out some (per-bootload) static data.
      166*This includes dseg, so we can find the page table (from the sdw) for
      167*a given segment so we can find its aste, the slt so we can determine if
      168*a given segment is hardcore and interesting, the name_table to find the 
      169*name of a segment, and stack_0_data so we can find out about the 
      170*(pre-allocated) ring 0 stacks floating around.  We also get the sst
      171*starting absolute address from unpaged_page_tables so we know where the
      172*sst is; and, in particular, whether a given page table address (from and
      173*sdw) describes a page table within the sst (=> capable of taking page 
      174*faults.) */
      175 
      176 		call get_temp_segments_ (MYNAME, temp_segp, code);
      177 		if code ^= 0
      178 		then do;
      179 			call com_err_ (code, MYNAME, "Getting Temp Segs");
      180 			return;
      181 		     end;
      182 		call get_temp_segments_ (MYNAME, init_temp_segp, code);
      183 		if code ^= 0
      184 		then do;
      185 			call com_err_ (code, MYNAME, "Getting Temp Segs");
      186 			call release_temp_segments_ (MYNAME, temp_segp, code);
      187 			return;
      188 		     end;
      189 
      190 		call copy_ring0_seg ("dseg", init_temp_segp (1), sdwp, code);
      191 		if code ^= 0
      192 		then do;
      193 			call com_err_ (code, MYNAME, "dseg");
      194 CLEAN_UP_INIT:
      195 			call release_temp_segments_ (MYNAME, temp_segp, code);
      196 			call release_temp_segments_ (MYNAME, init_temp_segp, code);
      197 			return;
      198 		     end;
      199 		call copy_ring0_seg ("slt", init_temp_segp (2), sltp, code);
      200 		if code ^= 0
      201 		then do;
      202 			call com_err_ (code, MYNAME, "slt");
      203 			goto CLEAN_UP_INIT;
      204 		     end;
      205 		call copy_ring0_seg ("name_table", init_temp_segp (3), names_ptr, code);
      206 		if code ^= 0
      207 		then do;
      208 			call com_err_ (code, MYNAME, "name_table");
      209 			goto CLEAN_UP_INIT;
      210 		     end;
      211 		call copy_ring0_seg ("stack_0_data", init_temp_segp (4), sdtp, code);
      212 		if code ^= 0
      213 		then do;
      214 			call com_err_ (code, MYNAME, "stack_0_data");
      215 			goto CLEAN_UP_INIT;
      216 		     end;
      217 		call ring0_get_$segptr ("", "sst", sstp, code);
      218 		if code ^= 0
      219 		then do;
      220 SST_ERR:
      221 			call com_err_ (code, MYNAME, "sst");
      222 			goto CLEAN_UP_INIT;
      223 		     end;
      224 		call ring_zero_peek_$get_max_length ("sst", sst_size, code);
      225 		if code ^= 0
      226 		then goto SST_ERR;
      227 		upt_ptr = addr (unpaged_page_tables_header);
      228 		call ring_zero_peek_$by_name ("unpaged_page_tables", 0, upt_ptr, size (unpaged_page_tables_header),
      229 		     code);
      230 		if code ^= 0
      231 		then go to SST_ERR;
      232 		sstadd = upt.sst_absloc;
      233 
      234 /* Determine what hardcore segments are interesting (which can take page 
      235*faults). */
      236 
      237 		segx = 0;
      238 		do segn = 0 to slt.last_sup_seg;
      239 		     sltep = addr (slt.seg (segn));
      240 		     if ^slte.abs_seg & ^slte.wired & ^slte.per_process & slte.paged & ^slte.init_seg & ^slte.temp_seg
      241 		     then do;			/* normal, most likely pagable hardcore segment */
      242 			     pt_relp = bin (sdwa (segn).add, 24) - sstadd;
      243 			     if sdwa (segn).add ^= "0"b & ^sdwa (segn).unpaged & sdwa (segn).df & pt_relp > 0
      244 				& pt_relp < sst_size
      245 			     then do;		/* sdw is valid and page table address for segment is within the bounds of sst */
      246 				     segx = segx + 1;
      247 						/* remember segment id */
      248 				     seg_info.seg (segx).rel_astep = pt_relp - size (aste);
      249 				     seg_info.seg (segx).prev_pf, seg_info.seg (segx).delta_pf = 0;
      250 				     seg_info.seg (segx).name =
      251 					ptr (names_ptr, slte.names_ptr) -> segnam.names (1).name;
      252 				end;
      253 			end;
      254 		end;
      255 
      256 		do segn = 1 to sdt.num_stacks;	/* remember set of ring 0 stacks (automatically pagable); 
      257*						list doesn't change across bootloads */
      258 		     stack_no = segn;
      259 		     sdtep = addr (sdt.stacks (segn));
      260 		     segx = segx + 1;
      261 		     seg_info.seg (segx).rel_astep = bin (sdte.astep);
      262 		     seg_info.seg (segx).prev_pf, seg_info.seg (segx).delta_pf = 0;
      263 		     seg_info.seg (segx).name = "stack_0." || stack_no;
      264 		end;
      265 
      266 		call release_temp_segments_ (MYNAME, init_temp_segp, code);
      267 		last_time = sys_info$time_of_bootload;
      268 		seg_info.n_segs = segx;
      269 		init = "1"b;
      270 	     end;
      271 
      272 	cur_time = clock ();
      273 	metering_time = cur_time - last_time;
      274 
      275 	sec = divide (metering_time, 1000000, 35);
      276 	minute = divide (sec, 60, 35);
      277 	hr = divide (minute, 60, 17);
      278 	sec = mod (sec, 60);
      279 	minute = mod (minute, 60);
      280 	HR = hr;
      281 	MINUTE = minute;
      282 	SEC = sec;
      283 	call ioa_ ("^/Total metering time^-^a^/", HR || ":" || MINUTE || ":" || SEC);
      284 
      285 
      286 	total_pf = 0;
      287 	sort_array.n = seg_info.n_segs;
      288 	do segx = 1 to seg_info.n_segs;
      289 	     call ring_zero_peek_$by_name ("sst", seg_info.seg (segx).rel_astep, addr (my_seg_aste), size (my_seg_aste),
      290 		code);				/* get aste for hardcore segment */
      291 	     if code ^= 0
      292 	     then do;
      293 		     call com_err_ (code, MYNAME, "sst|^o", seg_info.seg (segx).rel_astep);
      294 		     return;
      295 		end;
      296 	     seg_info.seg (segx).cur_pf = my_seg_aste.usage;
      297 						/* extract page fault data from aste */
      298 	     sort_array.p (segx) = addr (seg_info.seg (segx));
      299 	     seg_info.seg (segx).delta_pf = my_seg_aste.usage - seg_info.seg (segx).prev_pf;
      300 	     total_pf = total_pf + seg_info.seg (segx).delta_pf;
      301 	end;
      302 
      303 
      304 	if report_sw
      305 	then do;					/* report sorting and generation */
      306 
      307 		call sort_items_$general (temp_segp (2), order_entries);
      308 
      309 		call ioa_ ("Segment^26xPage Faults  % Total^/");
      310 
      311 		do segx = 1 to min (seg_info.n_segs, n_to_print);
      312 		     seg_entryp = sort_array (segx).p;
      313 		     if total_pf = 0
      314 		     then pct_pf = 0.;
      315 		     else pct_pf = seg_entry.delta_pf * 100.0 / total_pf;
      316 		     if seg_entry.delta_pf ^= 0
      317 		     then call ioa_ ("^32a ^8d     ^6.2f", seg_entry.name, seg_entry.delta_pf, pct_pf);
      318 		end;
      319 
      320 		call ioa_ ("^/Total Hardcore Page Faults^7x^8d^/", total_pf);
      321 
      322 	     end;
      323 
      324 	if reset_sw
      325 	then do;
      326 
      327 		last_time = cur_time;
      328 
      329 		do segx = 1 to seg_info.n_segs;
      330 		     seg_info.seg (segx).prev_pf = seg_info.seg (segx).cur_pf;
      331 		end;
      332 
      333 	     end;
      334 
      335 	return;
      336 
      337 copy_ring0_seg:
      338      proc (segname, seg_ptr, seg_ptr_1, code);
      339 
      340 dcl	segname		char (*);
      341 dcl	seg_ptr		ptr;
      342 dcl	seg_ptr_1		ptr;
      343 dcl	code		fixed bin (35);
      344 
      345 dcl	seg_size		fixed bin (19);
      346 
      347 
      348 	call ring_zero_peek_$get_max_length (segname, seg_size, code);
      349 	if code ^= 0
      350 	then return;
      351 
      352 	call ring_zero_peek_$by_name (segname, 0, seg_ptr, seg_size, code);
      353 	seg_ptr_1 = seg_ptr;
      354 
      355      end copy_ring0_seg;
      356 
      357 order_entries:
      358      proc (p1, p2) returns (fixed bin (1));
      359 
      360 dcl	p1		ptr unal;
      361 dcl	p2		ptr unal;
      362 dcl	1 seg1		aligned like seg_entry based (p1);
      363 dcl	1 seg2		aligned like seg_entry based (p2);
      364 
      365 	if sort_sw
      366 	then do;
      367 		if seg1.delta_pf < seg2.delta_pf
      368 		then return (1);
      369 		else if seg1.delta_pf > seg2.delta_pf
      370 		then return (-1);
      371 		else return (0);
      372 	     end;
      373 	else do;
      374 		if seg1.name < seg2.name
      375 		then return (-1);
      376 		else if seg1.name > seg2.name
      377 		then return (1);
      378 		else return (0);
      379 	     end;
      380 
      381      end order_entries;
      382 
      383 
      384 
  1     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      385 
      386 
  2     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  2     2 
  2     3 dcl  sdwp ptr;
  2     4 
  2     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  2     6 
  2     7    (2 add bit (24),					/* main memory address of page table */
  2     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  2     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  2    10     2 df_no bit (2),				/* directed fault number */
  2    11 
  2    12     2 pad1 bit (1),
  2    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  2    14     2 access,					/* access bits */
  2    15       3 read bit (1),				/* read permission bit */
  2    16       3 execute bit (1),				/* execute permission bit */
  2    17       3 write bit (1),				/* write permission bit */
  2    18       3 privileged bit (1),				/* privileged bit */
  2    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  2    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  2    21     2 cache bit (1),				/* cache enable bit */
  2    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  2    23 
  2    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  2    25 
  2    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      387 
      388 
  3     1 /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  3     2 
  3     3 /* Declarations for Segment Loading Table header and array.
  3     4*
  3     5*   Used by Initialization and MST Checker subroutines */
  3     6 
  3     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  3     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  3     9     namep ptr,					/* pointer to segment name list block */
  3    10     pathp ptr,					/* pointer to segment's directory path name */
  3    11     aclp ptr;					/* pointer to acl structure */
  3    12 
  3    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  3    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  3    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  3    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  3    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  3    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  3    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  3    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  3    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  3    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  3    23 
  3    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  3    25 
  3    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  3    27 	2 pad bit (18) unal,
  3    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  3    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  3    30 
  3    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  3    32 	2 count fixed bin (17),			/* number of segment names in this block */
  3    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  3    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  3    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  3    36 	  3 pad bit (5) unal,
  3    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  3    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  3    39 
  3    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  3    41 	2 size fixed bin (17),			/* length of pathname */
  3    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  3    43 	2 acls fixed bin;				/* ACL list starts here */
  3    44 
  3    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  3    46 	2 count fixed bin,				/* number of entries in acl list */
  3    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  3    48 	  3 userid char (32),			/* user specification */
  3    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  3    50 	  3 pad bit (36) aligned,
  3    51 	  3 code fixed bin;
  3    52 
  3    53 
  3    54 /* END INCLUDE FILE slt.incl.pl1 */
      389 
      390 
  4     1 /* BEGIN INCLUDE FILE slte.incl.pl1 */
  4     2 /* Declaration for Segment Loading Table Entry structure.
  4     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  4     4 /* modified 5/4/76 by Noel I. Morris	*/
  4     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  4     6 /* format: style3 */
  4     7 
  4     8 dcl	sltep		ptr;
  4     9 
  4    10 dcl	1 slte_uns	based (sltep) aligned,
  4    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  4    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  4    13 /**** End of word 1 */
  4    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  4    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  4    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  4    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  4    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  4    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  4    20 	  2 pad1		bit (3),			/* unused */
  4    21 	  2 wired		bit (1),			/* segment is wired if ON */
  4    22 	  2 paged		bit (1),			/* segment is paged if ON */
  4    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  4    24 	  2 pad3		bit (2),
  4    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  4    26 /**** End of 1st half of word 2 */
  4    27 	  2 pad4		bit (3),
  4    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  4    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  4    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  4    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  4    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  4    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  4    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  4    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  4    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  4    37 /***** End of word 2 */
  4    38 	  2 pad5		bit (6),
  4    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  4    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  4    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  4    42 /***** End of word 3 */
  4    43 	  2 pad7		bit (3),
  4    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  4    45 	  2 bit_count	fixed bin (24) uns
  4    46 	  )		unaligned;		/* bitcount of segment */
  4    47 
  4    48 dcl	1 slte		based (sltep) aligned,
  4    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  4    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  4    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  4    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  4    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  4    54 	  2 firmware_seg    bit (1),
  4    55 	  2 layout_seg      bit (1),
  4    56 	  2 breakpointable  bit (1),
  4    57 	  2 pad2		bit (3),
  4    58 	  2 wired		bit (1),			/* segment is wired if ON */
  4    59 	  2 paged		bit (1),			/* segment is paged if ON */
  4    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  4    61 	  2 pad3		bit (2),
  4    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  4    63 	  2 pad4		bit (3),
  4    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  4    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  4    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  4    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  4    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  4    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  4    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  4    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  4    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  4    73 	  2 pad5		bit (6),
  4    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  4    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  4    76 	  2 segno		bit (18),			/* text/link segment number */
  4    77 	  2 pad6		bit (3),
  4    78 	  2 max_length	bit (9),			/* maximum length for segment */
  4    79 	  2 bit_count	bit (24)
  4    80 	  )		unaligned;		/* bitcount of segment */
  4    81 
  4    82 /* END INCLUDE FILE slte.incl.pl1 */
      391 
      392 
  5     1 /* BEGIN INCLUDE FILE ... stack_0_data.incl.pl1 */
  5     2 
  5     3 /* Created 790509 by Mike Grady */
  5     4 
  5     5 dcl  stack_0_data$ fixed bin ext;			/* shared stack 0 data base seg */
  5     6 dcl  stack_0_data_init_number_of_stacks fixed bin;	/* Make PL/I work */
  5     7 dcl  sdtp ptr;
  5     8 
  5     9 dcl 1 sdt aligned based (sdtp),			/* stack 0 database */
  5    10     2 lock bit (36),				/* lock before changing threads */
  5    11     2 num_stacks fixed bin,				/* number of stacks in pool */
  5    12     2 freep bit (18),				/* head of free thread, managed LIFO */
  5    13     2 pad fixed bin,
  5    14     2 stacks (stack_0_data_init_number_of_stacks
  5    15 	refer (sdt.num_stacks)) like sdte;
  5    16 
  5    17 dcl  sdtep ptr;
  5    18 
  5    19 dcl 1 sdte aligned based (sdtep),			/* stack data table entry */
  5    20     2 nextp bit (18) unal,				/* thread to next free entry (if free) */
  5    21     2 pad bit (18) unal,
  5    22     2 astep bit (18) unal,				/* ptr to ASTE for this stack seg */
  5    23     2 aptep bit (18) unal,				/* ptr to APTE of process using this stack, if not free */
  5    24     2 sdw bit (72);					/* SDW for this stack seg */
  5    25 
  5    26 /* END INCLUDE FILE ... stack_0_data.incl.pl1 */
      393 
      394 
  6     1 /* BEGIN include file unpaged_page_tables.incl.pl1 */
  6     2 
  6     3 /* This include file describes the segments unpaged_page_tables and
  6     4*int_unpaged_page_tables.  These segments contain the page tables for
  6     5*segments that are paged and wired, those segments previously called
  6     6*unpaged.
  6     7*
  6     8*Written September 15, 1983 by Keith Loepere. */
  6     9 
  6    10 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  6    11 
  6    12 dcl  upt_ptr		        ptr;
  6    13 dcl  1 upt		        aligned based (upt_ptr),
  6    14        2 sst_absloc		        fixed bin (26),	/* for dump analyzers */
  6    15        2 sst_last_loc	        fixed bin (26),
  6    16        2 upt_absloc		        fixed bin (26),
  6    17        2 upt_last_loc	        fixed bin (26),
  6    18        2 iupt_absloc	        fixed bin (26),
  6    19        2 iupt_last_loc	        fixed bin (26),
  6    20 
  6    21        2 current_length	        fixed bin,		/* number of words currently used */
  6    22        2 max_length		        fixed bin,		/* max number of words in memory allocated */
  6    23        2 first_entry	        like upt_entry;
  6    24 
  6    25 dcl  upt_entry_ptr		        ptr;
  6    26 dcl  1 upt_entry		        aligned based (upt_entry_ptr),
  6    27        2 size		        fixed bin,		/* number of page table words allocated */
  6    28        2 segno		        fixed bin,		/* of hardcore segment */
  6    29        2 ptws		        (0 refer (upt_entry.size)) bit (36) aligned;
  6    30 
  6    31 /* END include file unpaged_page_tables.incl.pl1 */
      395 
      396      end hc_pf_meters;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1307.7  hc_pf_meters.pl1                  >spec>temp>41-5>hc_pf_meters.pl1
385          1    01/22/85  1321.5  aste.incl.pl1                     >spec>temp>41-5>aste.incl.pl1
387          2    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
389          3    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
391          4    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
393          5    10/25/79  0712.2  stack_0_data.incl.pl1             >ldd>include>stack_0_data.incl.pl1
395          6    07/11/84  0937.3  unpaged_page_tables.incl.pl1      >ldd>include>unpaged_page_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HR                              000111 automatic       picture(4)               unaligned dcl 29 set ref 280* 283
MINUTE                          000125 automatic       picture(2)               unaligned dcl 33 set ref 281* 283
MYNAME                          000000 constant        char(12)                 initial unaligned dcl 60 set ref 119* 139* 145* 154*
                                                                                  176* 179* 182* 185* 186* 193* 194* 196* 202* 208*
                                                                                  214* 220* 266* 293*
SEC                             000151 automatic       picture(2)               unaligned dcl 42 set ref 282* 283
abs_seg                   1(05)        based           bit(1)                   level 2 packed unaligned dcl 4-48 ref 240
add                                    based           bit(24)                  array level 2 packed unaligned dcl 2-24 ref 242 243
addr                                                   builtin function         dcl 103 ref 227 239 259 289 289 298
arg                                    based           char                     unaligned dcl 64 set ref 125 127 127 129 129 131 133
                                                                                  133 142* 145* 154*
arg_no                          000104 automatic       fixed bin(17,0)          dcl 25 set ref 123* 124* 135* 135 136*
argl                            000100 automatic       fixed bin(21,0)          dcl 23 set ref 124* 125 127 127 129 129 131 133 133
                                                                                  136* 142 142 145 145 154 154
argp                            000102 automatic       pointer                  dcl 24 set ref 124* 125 127 127 129 129 131 133 133
                                                                                  136* 142 145 154
aste                                   based           structure                level 1 dcl 1-11 ref 248
astep                                  automatic       pointer                  dcl 1-9 in procedure "hc_pf_meters" ref 248
astep                     1            based           bit(18)                  level 2 in structure "sdte" packed unaligned
                                                                                  dcl 5-19 in procedure "hc_pf_meters" ref 261
bin                                                    builtin function         dcl 105 ref 242 261
clock                                                  builtin function         dcl 107 ref 272
code                                   parameter       fixed bin(35,0)          dcl 343 in procedure "copy_ring0_seg" set ref 337
                                                                                  348* 349 352*
code                            000105 automatic       fixed bin(35,0)          dcl 26 in procedure "hc_pf_meters" set ref 116* 117
                                                                                  119* 124* 136* 137 139* 142* 143 176* 177 179*
                                                                                  182* 183 185* 186* 190* 191 193* 194* 196* 199*
                                                                                  200 202* 205* 206 208* 211* 212 214* 217* 218 220*
                                                                                  224* 225 228* 230 266* 289* 291 293*
com_err_                        000020 constant        entry                    external dcl 80 ref 119 139 145 154 179 185 193 202
                                                                                  208 214 220 293
cu_$arg_count                   000022 constant        entry                    external dcl 81 ref 116
cu_$arg_ptr                     000024 constant        entry                    external dcl 82 ref 124 136
cur_pf                   13            based           fixed bin(35,0)          array level 3 dcl 65 set ref 296* 330
cur_time                        000106 automatic       fixed bin(71,0)          dcl 27 set ref 272* 273 327
cv_dec_check_                   000026 constant        entry                    external dcl 83 ref 142
delta_pf                 13            based           fixed bin(35,0)          level 2 in structure "seg2" dcl 363 in procedure
                                                                                  "order_entries" ref 367 369
delta_pf                 13            based           fixed bin(35,0)          level 2 in structure "seg_entry" dcl 68 in procedure
                                                                                  "hc_pf_meters" set ref 315 316 316*
delta_pf                 14            based           fixed bin(35,0)          array level 3 in structure "seg_info" dcl 65
                                                                                  in procedure "hc_pf_meters" set ref 249* 262* 299*
                                                                                  300
delta_pf                 13            based           fixed bin(35,0)          level 2 in structure "seg1" dcl 362 in procedure
                                                                                  "order_entries" ref 367 369
df                        0(33)        based           bit(1)                   array level 2 packed unaligned dcl 2-24 ref 243
divide                                                 builtin function         dcl 108 ref 275 276 277
error_table_$badopt             000046 external static fixed bin(35,0)          dcl 97 set ref 154*
get_temp_segments_              000030 constant        entry                    external dcl 84 ref 176 182
hr                              000110 automatic       fixed bin(17,0)          dcl 28 set ref 277* 280
init                            000010 internal static bit(1)                   initial unaligned dcl 57 set ref 162 269*
init_seg                  1(22)        based           bit(1)                   level 2 packed unaligned dcl 4-48 ref 240
init_temp_segp                  000112 automatic       pointer                  array dcl 30 set ref 182* 190* 196* 199* 205* 211*
                                                                                  266*
ioa_                            000032 constant        entry                    external dcl 85 ref 283 309 316 320
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 3-13 ref 238
last_time                       000012 internal static fixed bin(71,0)          initial dcl 58 set ref 267* 273 327*
metering_time                   000122 automatic       fixed bin(71,0)          dcl 31 set ref 273* 275
min                                                    builtin function         dcl 109 ref 311
minute                          000124 automatic       fixed bin(35,0)          dcl 32 set ref 276* 277 279* 279 281
mod                                                    builtin function         dcl 110 ref 278 279
my_seg_aste                     000126 automatic       structure                level 1 dcl 34 set ref 289 289 289 289
n                                      based           fixed bin(24,0)          level 2 dcl 74 set ref 287*
n_args                          000142 automatic       fixed bin(17,0)          dcl 35 set ref 116* 123
n_segs                                 based           fixed bin(17,0)          level 2 dcl 65 set ref 268* 287 288 311 329
n_to_print                      000143 automatic       fixed bin(35,0)          dcl 36 set ref 115* 142* 149 311
name                                   based           char(32)                 level 2 in structure "seg1" packed unaligned dcl 362
                                                                                  in procedure "order_entries" ref 374 376
name                                   based           char(32)                 level 2 in structure "seg2" packed unaligned dcl 363
                                                                                  in procedure "order_entries" ref 374 376
name                      2            based           char(32)                 array level 3 in structure "segnam" packed unaligned
                                                                                  dcl 3-31 in procedure "hc_pf_meters" ref 250
name                      1            based           char(32)                 array level 3 in structure "seg_info" packed
                                                                                  unaligned dcl 65 in procedure "hc_pf_meters" set
                                                                                  ref 250* 263*
name                                   based           char(32)                 level 2 in structure "seg_entry" packed unaligned
                                                                                  dcl 68 in procedure "hc_pf_meters" set ref 316*
names                     1            based           structure                array level 2 dcl 3-31
names_ptr                              based           bit(18)                  level 2 in structure "slte" packed unaligned
                                                                                  dcl 4-48 in procedure "hc_pf_meters" ref 250
names_ptr                       000202 automatic       pointer                  dcl 3-7 in procedure "hc_pf_meters" set ref 205* 250
num_stacks                1            based           fixed bin(17,0)          level 2 dcl 5-9 ref 256
p                         1            based           pointer                  array level 2 packed unaligned dcl 74 set ref 298*
                                                                                  312
p1                                     parameter       pointer                  unaligned dcl 360 ref 357 367 369 374 376
p2                                     parameter       pointer                  unaligned dcl 361 ref 357 367 369 374 376
paged                     1(13)        based           bit(1)                   level 2 packed unaligned dcl 4-48 ref 240
pct_pf                          000144 automatic       float bin(27)            dcl 37 set ref 313* 315* 316*
per_process               1(14)        based           bit(1)                   level 2 packed unaligned dcl 4-48 ref 240
prev_pf                  12            based           fixed bin(35,0)          array level 3 dcl 65 set ref 249* 262* 299 330*
pt_relp                         000145 automatic       fixed bin(24,0)          dcl 38 set ref 242* 243 243 248
ptr                                                    builtin function         dcl 111 ref 250
rel_astep                11            based           fixed bin(18,0)          array level 3 dcl 65 set ref 248* 261* 289* 293*
release_temp_segments_          000034 constant        entry                    external dcl 86 ref 186 194 196 266
report_sw                       000146 automatic       bit(1)                   unaligned dcl 39 set ref 114* 125* 129* 159 159* 304
reset_sw                        000147 automatic       bit(1)                   unaligned dcl 40 set ref 114* 127* 129* 159 324
ring0_get_$segptr               000036 constant        entry                    external dcl 88 ref 217
ring_zero_peek_$by_name         000040 constant        entry                    external dcl 89 ref 228 289 352
ring_zero_peek_$get_max_length  000042 constant        entry                    external dcl 91 ref 224 348
sdt                                    based           structure                level 1 dcl 5-9
sdte                                   based           structure                level 1 dcl 5-19
sdtep                           000210 automatic       pointer                  dcl 5-17 set ref 259* 261
sdtp                            000206 automatic       pointer                  dcl 5-7 set ref 211* 256 259
sdw                                    based           structure                level 1 dcl 2-5
sdwa                                   based           structure                array level 1 dcl 2-24
sdwp                            000176 automatic       pointer                  dcl 2-3 set ref 190* 242 243 243 243
sec                             000150 automatic       fixed bin(35,0)          dcl 41 set ref 275* 276 278* 278 282
seg                      10            based           structure                array level 2 in structure "slt" dcl 3-13
                                                                                  in procedure "hc_pf_meters" set ref 239
seg                       1            based           structure                array level 2 in structure "seg_info" dcl 65
                                                                                  in procedure "hc_pf_meters" set ref 298
seg1                                   based           structure                level 1 dcl 362
seg2                                   based           structure                level 1 dcl 363
seg_aste                               based           structure                level 1 dcl 1-96
seg_entry                              based           structure                level 1 dcl 68
seg_entryp                      000152 automatic       pointer                  dcl 43 set ref 312* 315 316 316 316
seg_info                               based           structure                level 1 dcl 65
seg_ptr                                parameter       pointer                  dcl 341 set ref 337 352* 353
seg_ptr_1                              parameter       pointer                  dcl 342 set ref 337 353*
seg_size                        000230 automatic       fixed bin(19,0)          dcl 345 set ref 348* 352*
segn                            000154 automatic       fixed bin(17,0)          dcl 44 set ref 238* 239 242 243 243 243* 256* 258
                                                                                  259*
segnam                                 based           structure                level 1 dcl 3-31
segname                                parameter       char                     unaligned dcl 340 set ref 337 348* 352*
segx                            000155 automatic       fixed bin(17,0)          dcl 45 set ref 237* 246* 246 248 249 249 250 260*
                                                                                  260 261 262 262 263 268 288* 289 293 296 298 298
                                                                                  299 299 300* 311* 312* 329* 330 330*
size                                                   builtin function         dcl 112 ref 228 228 248 289 289
slt                                    based           structure                level 1 dcl 3-13
slte                                   based           structure                level 1 dcl 4-48
sltep                           000204 automatic       pointer                  dcl 4-8 set ref 239* 240 240 240 240 240 240 250
sltp                            000200 automatic       pointer                  dcl 3-7 set ref 199* 238 239
sort_array                             based           structure                level 1 dcl 74
sort_items_$general             000044 constant        entry                    external dcl 93 ref 307
sort_sw                         000156 automatic       bit(1)                   unaligned dcl 46 set ref 114* 131* 151* 365
sst_absloc                             based           fixed bin(26,0)          level 2 dcl 6-13 ref 232
sst_size                        000157 automatic       fixed bin(19,0)          dcl 47 set ref 224* 243
sstadd                          000160 automatic       fixed bin(24,0)          dcl 48 set ref 232* 242
sstp                            000162 automatic       pointer                  dcl 49 set ref 217*
stack_no                        000164 automatic       picture(3)               unaligned dcl 50 set ref 258* 263
stacks                    4            based           structure                array level 2 dcl 5-9 set ref 259
sys_info$time_of_bootload       000050 external static fixed bin(71,0)          dcl 98 ref 267
temp_seg                  1(23)        based           bit(1)                   level 2 packed unaligned dcl 4-48 ref 240
temp_segp                       000014 internal static pointer                  array dcl 59 set ref 176* 186* 194* 248 249 249 250
                                                                                  261 262 262 263 268 287 287 288 289 293 296 298
                                                                                  298 299 299 300 307* 311 312 329 330 330
total_pf                        000165 automatic       fixed bin(35,0)          dcl 51 set ref 286* 300* 300 313 315 320*
unpaged                   1(19)        based           bit(1)                   array level 2 packed unaligned dcl 2-24 ref 243
unpaged_page_tables_header      000166 automatic       bit(36)                  array dcl 52 set ref 227 228 228
upt                                    based           structure                level 1 dcl 6-13
upt_entry                              based           structure                level 1 dcl 6-26
upt_ptr                         000212 automatic       pointer                  dcl 6-12 set ref 227* 228* 232
usage                    10     000126 automatic       fixed bin(35,0)          level 2 dcl 34 set ref 296 299
wired                     1(12)        based           bit(1)                   level 2 packed unaligned dcl 4-48 ref 240

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
aclp                                   automatic       pointer                  dcl 3-7
acls                                   based           structure                level 1 dcl 3-45
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
baseno                                                 builtin function         dcl 104
bit                                                    builtin function         dcl 106
name_seg                               based           structure                level 1 dcl 3-26
namep                                  automatic       pointer                  dcl 3-7
path                                   based           structure                level 1 dcl 3-40
pathp                                  automatic       pointer                  dcl 3-7
slte_uns                               based           structure                level 1 dcl 4-10
stack_0_data$                          external static fixed bin(17,0)          dcl 5-5
stack_0_data_init_number_of_stacks     automatic       fixed bin(17,0)          dcl 5-6
upt_entry_ptr                          automatic       pointer                  dcl 6-25

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_N_TO_PRINT                  000434 constant        label                    dcl 145 ref 149
CLEAN_UP_INIT                   000736 constant        label                    dcl 194 ref 203 209 215 222
SST_ERR                         001165 constant        label                    dcl 220 ref 225 230
copy_ring0_seg                  002164 constant        entry                    internal dcl 337 ref 190 199 205 211
hc_pf_meters                    000174 constant        entry                    external dcl 12
order_entries                   002265 constant        entry                    internal dcl 357 ref 307 307

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2674        2746    2475        2704
Length      3276    2475        52         314     177          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hc_pf_meters                        268 external procedure  is an external procedure.  
copy_ring0_seg                          internal procedure  shares stack frame of external procedure hc_pf_meters.  
order_entries                        70 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 init                        hc_pf_meters
000012 last_time                   hc_pf_meters
000014 temp_segp                   hc_pf_meters

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
hc_pf_meters             000100 argl                        hc_pf_meters
                         000102 argp                        hc_pf_meters
                         000104 arg_no                      hc_pf_meters
                         000105 code                        hc_pf_meters
                         000106 cur_time                    hc_pf_meters
                         000110 hr                          hc_pf_meters
                         000111 HR                          hc_pf_meters
                         000112 init_temp_segp              hc_pf_meters
                         000122 metering_time               hc_pf_meters
                         000124 minute                      hc_pf_meters
                         000125 MINUTE                      hc_pf_meters
                         000126 my_seg_aste                 hc_pf_meters
                         000142 n_args                      hc_pf_meters
                         000143 n_to_print                  hc_pf_meters
                         000144 pct_pf                      hc_pf_meters
                         000145 pt_relp                     hc_pf_meters
                         000146 report_sw                   hc_pf_meters
                         000147 reset_sw                    hc_pf_meters
                         000150 sec                         hc_pf_meters
                         000151 SEC                         hc_pf_meters
                         000152 seg_entryp                  hc_pf_meters
                         000154 segn                        hc_pf_meters
                         000155 segx                        hc_pf_meters
                         000156 sort_sw                     hc_pf_meters
                         000157 sst_size                    hc_pf_meters
                         000160 sstadd                      hc_pf_meters
                         000162 sstp                        hc_pf_meters
                         000164 stack_no                    hc_pf_meters
                         000165 total_pf                    hc_pf_meters
                         000166 unpaged_page_tables_header  hc_pf_meters
                         000176 sdwp                        hc_pf_meters
                         000200 sltp                        hc_pf_meters
                         000202 names_ptr                   hc_pf_meters
                         000204 sltep                       hc_pf_meters
                         000206 sdtp                        hc_pf_meters
                         000210 sdtep                       hc_pf_meters
                         000212 upt_ptr                     hc_pf_meters
                         000230 seg_size                    copy_ring0_seg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              mod_fx1             shorten_stack
ext_entry           int_entry           divide_fx3          clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_
get_temp_segments_            ioa_                          release_temp_segments_        ring0_get_$segptr
ring_zero_peek_$by_name       ring_zero_peek_$get_max_length                              sort_items_$general

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           sys_info$time_of_bootload


CONSTANTS
002361  aa  070 322 000 000	8

002362  aa  103 070 321 000	C8

002363  aa  070 323 000 000	8

002364  aa     000010000000
002365  aa     000010000000
002366  aa     600000000041
002367  aa     000232000000
002370  aa     600000000041
002371  aa     000120000000
002372  aa     600000000041
002373  aa     000206000000
002374  aa     600000000041
002375  aa     000105000000
002376  ta     000022000000
002377  aa     000000000000
002400  ta     000026000000
002401  aa     000000000000
002402  ta     000026000000
002403  aa     000000000000
002404  ta     000043000000
002405  aa     000000000000

002406  aa     000010000000
002407  aa     000010000000
002410  aa     600000000041
002411  aa     000232000000
002412  aa     600000000041
002413  aa     000116000000
002414  aa     600000000041
002415  aa     000202000000
002416  aa     600000000041
002417  aa     000105000000
002420  ta     000023000000
002421  aa     000000000000
002422  ta     000026000000
002423  aa     000000000000
002424  ta     000026000000
002425  aa     000000000000
002426  ta     000043000000
002427  aa     000000000000

002430  aa     000010000000
002431  aa     000010000000
002432  aa     600000000041
002433  aa     000231000000
002434  aa     600000000041
002435  aa     000114000000
002436  aa     600000000041
002437  aa     000200000000
002440  aa     600000000041
002441  aa     000105000000
002442  ta     000024000000
002443  aa     000000000000
002444  ta     000026000000
002445  aa     000000000000
002446  ta     000026000000
002447  aa     000000000000
002450  ta     000043000000
002451  aa     000000000000

002452  aa     000010000000
002453  aa     000010000000
002454  aa     600000000041
002455  aa     000231000000
002456  aa     600000000041
002457  aa     000112000000
002460  aa     600000000041
002461  aa     000176000000
002462  aa     600000000041
002463  aa     000105000000
002464  ta     000027000000
002465  aa     000000000000
002466  ta     000026000000
002467  aa     000000000000
002470  ta     000026000000
002471  aa     000000000000
002472  ta     000043000000
002473  aa     000000000000

000000  aa  150 143 137 160	hc_p
000001  aa  146 137 155 145	f_me
000002  aa  164 145 162 163	ters

000003  aa     466000000000

000004  aa     526077777777

000005  aa     524000000044

000006  aa     414000000033

000007  aa     526000000040

000010  aa     524000000022

000011  aa     524000000041

000012  aa     524000000006

000013  aa     524000000033

002474  aa     000000000074

000014  aa     000003641100

000015  aa     404000000022

000016  aa     524000000023

000017  aa     404000000023

000020  aa  163 163 164 000	sst

000021  aa     524000000000

000022  aa     524000000014

000023  aa     524000000012

000024  aa     524000000003

000025  aa  163 154 164 000	slt

000026  aa     464000000000

000027  aa     524000000004

000030  aa  144 163 145 147	dseg

000031  aa     524000000021

000032  aa     524000000032

000033  aa     404000000005

000034  aa     526000000000

000035  aa     524000000017

000036  aa  055 146 164 000	-ft

000037  aa  055 162 162 000	-rr

000040  aa  055 162 163 000	-rs

000041  aa     526000000014

000042  aa     404000000001

000043  aa     404000000043

000044  aa  163 163 164 174	sst|
000045  aa  136 157 000 000	^o

000046  aa  163 164 141 143	stac
000047  aa  153 137 060 056	k_0.

000050  aa  055 146 151 162	-fir
000051  aa  163 164 000 000	st

000052  aa  055 163 157 162	-sor
000053  aa  164 000 000 000	t

000054  aa  055 162 145 163	-res
000055  aa  145 164 000 000	et

000056  aa  055 162 145 160	-rep
000057  aa  157 162 164 000	ort

000060  aa  163 164 141 143	stac
000061  aa  153 137 060 137	k_0_
000062  aa  144 141 164 141	data

000063  aa  156 141 155 145	name
000064  aa  137 164 141 142	_tab
000065  aa  154 145 000 000	le

000066  aa     464100000000
000067  aa     000000000001
000070  aa     000000000004
000071  aa     000000000002

000072  aa     464100000000
000073  aa     000000000001
000074  aa     000000000002
000075  aa     000000000002

000076  aa  116 165 155 142	Numb
000077  aa  145 162 040 164	er t
000100  aa  157 040 160 162	o pr
000101  aa  151 156 164 000	int

000102  aa  055 162 145 160	-rep
000103  aa  157 162 164 137	ort_
000104  aa  162 145 163 145	rese
000105  aa  164 000 000 000	t

000106  aa  136 063 062 141	^32a
000107  aa  040 136 070 144	 ^8d
000110  aa  040 040 040 040	    
000111  aa  040 136 066 056	 ^6.
000112  aa  062 146 000 000	2f

000113  aa  165 156 160 141	unpa
000114  aa  147 145 144 137	ged_
000115  aa  160 141 147 145	page
000116  aa  137 164 141 142	_tab
000117  aa  154 145 163 000	les

000120  aa  107 145 164 164	Gett
000121  aa  151 156 147 040	ing 
000122  aa  124 145 155 160	Temp
000123  aa  040 123 145 147	 Seg
000124  aa  163 000 000 000	s

000125  aa  162 145 164 165	retu
000126  aa  162 156 137 143	rn_c
000127  aa  157 156 166 145	onve
000130  aa  162 163 151 157	rsio
000131  aa  156 137 145 162	n_er
000132  aa  162 157 162 000	ror

000133  aa  136 057 124 157	^/To
000134  aa  164 141 154 040	tal 
000135  aa  155 145 164 145	mete
000136  aa  162 151 156 147	ring
000137  aa  040 164 151 155	 tim
000140  aa  145 136 055 136	e^-^
000141  aa  141 136 057 000	a^/

000142  aa  111 156 166 141	Inva
000143  aa  154 151 144 040	lid 
000144  aa  156 165 155 142	numb
000145  aa  145 162 040 164	er t
000146  aa  157 040 160 162	o pr
000147  aa  151 156 164 040	int 
000150  aa  136 141 000 000	^a

000151  aa  136 057 124 157	^/To
000152  aa  164 141 154 040	tal 
000153  aa  110 141 162 144	Hard
000154  aa  143 157 162 145	core
000155  aa  040 120 141 147	 Pag
000156  aa  145 040 106 141	e Fa
000157  aa  165 154 164 163	ults
000160  aa  136 067 170 136	^7x^
000161  aa  070 144 136 057	8d^/

000162  aa  123 145 147 155	Segm
000163  aa  145 156 164 136	ent^
000164  aa  062 066 170 120	26xP
000165  aa  141 147 145 040	age 
000166  aa  106 141 165 154	Faul
000167  aa  164 163 040 040	ts  
000170  aa  045 040 124 157	% To
000171  aa  164 141 154 136	tal^
000172  aa  057 000 000 000	/

BEGIN PROCEDURE hc_pf_meters
ENTRY TO hc_pf_meters                                       STATEMENT 1 ON LINE 12
hc_pf_meters:
     proc;

000173  da     000164200000
000174  aa   000420 6270 00	eax7 	272
000175  aa  7 00034 3521 20	epp2 	pr7|28,*
000176  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000177  aa     000000000000
000200  aa     000000000000
						STATEMENT 1 ON LINE 114
	report_sw, reset_sw, sort_sw = "0"b;

000201  aa  6 00146 4501 00	stz  	pr6|102		report_sw
000202  aa  6 00147 4501 00	stz  	pr6|103		reset_sw
000203  aa  6 00156 4501 00	stz  	pr6|110		sort_sw
						STATEMENT 1 ON LINE 115
	n_to_print = 262143;

000204  aa   777777 2360 07	ldq  	262143,dl
000205  aa  6 00143 7561 00	stq  	pr6|99		n_to_print
						STATEMENT 1 ON LINE 116
	call cu_$arg_count (n_args, code);

000206  aa  6 00142 3521 00	epp2 	pr6|98		n_args
000207  aa  6 00234 2521 00	spri2	pr6|156
000210  aa  6 00105 3521 00	epp2 	pr6|69		code
000211  aa  6 00236 2521 00	spri2	pr6|158
000212  aa  6 00232 6211 00	eax1 	pr6|154
000213  aa   010000 4310 07	fld  	4096,dl
000214  la  4 00022 3521 20	epp2 	pr4|18,*		cu_$arg_count
000215  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 117
	if code ^= 0
	then do;

000216  aa  6 00105 2361 00	ldq  	pr6|69		code
000217  aa   000017 6000 04	tze  	15,ic		000236
						STATEMENT 1 ON LINE 119
		call com_err_ (code, MYNAME);

000220  aa  6 00105 3521 00	epp2 	pr6|69		code
000221  aa  6 00242 2521 00	spri2	pr6|162
000222  aa   777556 3520 04	epp2 	-146,ic		000000 = 150143137160
000223  aa  6 00244 2521 00	spri2	pr6|164
000224  aa   777617 3520 04	epp2 	-113,ic		000043 = 404000000043
000225  aa  6 00246 2521 00	spri2	pr6|166
000226  aa   777613 3520 04	epp2 	-117,ic		000041 = 526000000014
000227  aa  6 00250 2521 00	spri2	pr6|168
000230  aa  6 00240 6211 00	eax1 	pr6|160
000231  aa   010000 4310 07	fld  	4096,dl
000232  aa  6 00044 3701 20	epp4 	pr6|36,*
000233  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000234  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 120
		return;

000235  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 121
	     end;

						STATEMENT 1 ON LINE 123
	do arg_no = 1 to n_args;

000236  aa  6 00142 2361 00	ldq  	pr6|98		n_args
000237  aa  6 00214 7561 00	stq  	pr6|140
000240  aa   000001 2360 07	ldq  	1,dl
000241  aa  6 00104 7561 00	stq  	pr6|68		arg_no
000242  aa  6 00104 2361 00	ldq  	pr6|68		arg_no
000243  aa  6 00214 1161 00	cmpq 	pr6|140
000244  aa   000261 6054 04	tpnz 	177,ic		000525
						STATEMENT 1 ON LINE 124
	     call cu_$arg_ptr (arg_no, argp, argl, code);

000245  aa  6 00104 3521 00	epp2 	pr6|68		arg_no
000246  aa  6 00242 2521 00	spri2	pr6|162
000247  aa  6 00102 3521 00	epp2 	pr6|66		argp
000250  aa  6 00244 2521 00	spri2	pr6|164
000251  aa  6 00100 3521 00	epp2 	pr6|64		argl
000252  aa  6 00246 2521 00	spri2	pr6|166
000253  aa  6 00105 3521 00	epp2 	pr6|69		code
000254  aa  6 00250 2521 00	spri2	pr6|168
000255  aa  6 00240 6211 00	eax1 	pr6|160
000256  aa   020000 4310 07	fld  	8192,dl
000257  aa  6 00044 3701 20	epp4 	pr6|36,*
000260  la  4 00024 3521 20	epp2 	pr4|20,*		cu_$arg_ptr
000261  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 125
	     if arg = "-report"
	     then report_sw = "1"b;

000262  aa  6 00102 3735 20	epp7 	pr6|66,*		argp
000263  aa  6 00100 2351 00	lda  	pr6|64		argl
000264  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000265  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000266  aa   777572 00 0007	desc9a	-134,7		000056 = 055162145160
000267  aa   000004 6010 04	tnz  	4,ic		000273
000270  aa   400000 2350 03	lda  	131072,du
000271  aa  6 00146 7551 00	sta  	pr6|102		report_sw
000272  aa   000231 7100 04	tra  	153,ic		000523
						STATEMENT 1 ON LINE 127
	     else if arg = "-reset" | arg = "-rs"
	     then reset_sw = "1"b;

000273  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000274  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000275  aa   777561 00 0006	desc9a	-143,6		000054 = 055162145163
000276  aa   000005 6000 04	tze  	5,ic		000303
000277  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000300  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000301  aa   777541 00 0003	desc9a	-159,3		000040 = 055162163000
000302  aa   000004 6010 04	tnz  	4,ic		000306
000303  aa   400000 2350 03	lda  	131072,du
000304  aa  6 00147 7551 00	sta  	pr6|103		reset_sw
000305  aa   000216 7100 04	tra  	142,ic		000523
						STATEMENT 1 ON LINE 129
	     else if arg = "-report_reset" | arg = "-rr"
	     then report_sw, reset_sw = "1"b;

000306  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000307  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000310  aa   777574 00 0015	desc9a	-132,13		000102 = 055162145160
000311  aa   000005 6000 04	tze  	5,ic		000316
000312  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000313  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000314  aa   777525 00 0003	desc9a	-171,3		000037 = 055162162000
000315  aa   000005 6010 04	tnz  	5,ic		000322
000316  aa   400000 2350 03	lda  	131072,du
000317  aa  6 00146 7551 00	sta  	pr6|102		report_sw
000320  aa  6 00147 7551 00	sta  	pr6|103		reset_sw
000321  aa   000202 7100 04	tra  	130,ic		000523
						STATEMENT 1 ON LINE 131
	     else if arg = "-sort"
	     then sort_sw = "1"b;

000322  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000323  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000324  aa   777530 00 0005	desc9a	-168,5		000052 = 055163157162
000325  aa   000004 6010 04	tnz  	4,ic		000331
000326  aa   400000 2350 03	lda  	131072,du
000327  aa  6 00156 7551 00	sta  	pr6|110		sort_sw
000330  aa   000173 7100 04	tra  	123,ic		000523
						STATEMENT 1 ON LINE 133
	     else if arg = "-first" | arg = "-ft"
	     then do;

000331  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000332  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000333  aa   777517 00 0006	desc9a	-177,6		000050 = 055146151162
000334  aa   000005 6000 04	tze  	5,ic		000341
000335  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
000336  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
000337  aa   777501 00 0003	desc9a	-191,3		000036 = 055146164000
000340  aa   000136 6010 04	tnz  	94,ic		000476
						STATEMENT 1 ON LINE 135
		     arg_no = arg_no + 1;

000341  aa  6 00104 0541 00	aos  	pr6|68		arg_no
						STATEMENT 1 ON LINE 136
		     call cu_$arg_ptr (arg_no, argp, argl, code);

000342  aa  6 00104 3521 00	epp2 	pr6|68		arg_no
000343  aa  6 00242 2521 00	spri2	pr6|162
000344  aa  6 00102 3521 00	epp2 	pr6|66		argp
000345  aa  6 00244 2521 00	spri2	pr6|164
000346  aa  6 00100 3521 00	epp2 	pr6|64		argl
000347  aa  6 00246 2521 00	spri2	pr6|166
000350  aa  6 00105 3521 00	epp2 	pr6|69		code
000351  aa  6 00250 2521 00	spri2	pr6|168
000352  aa  6 00240 6211 00	eax1 	pr6|160
000353  aa   020000 4310 07	fld  	8192,dl
000354  aa  6 00044 3701 20	epp4 	pr6|36,*
000355  la  4 00024 3521 20	epp2 	pr4|20,*		cu_$arg_ptr
000356  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 137
		     if code ^= 0
		     then do;

000357  aa  6 00105 2361 00	ldq  	pr6|69		code
000360  aa   000027 6000 04	tze  	23,ic		000407
						STATEMENT 1 ON LINE 139
			     call com_err_ (code, MYNAME, "Number to print");

000361  aa   777515 2370 04	ldaq 	-179,ic		000076 = 116165155142 145162040164
000362  aa  6 00232 7571 00	staq 	pr6|154
000363  aa   777515 2370 04	ldaq 	-179,ic		000100 = 157040160162 151156164000
000364  aa  6 00234 7571 00	staq 	pr6|156
000365  aa  6 00105 3521 00	epp2 	pr6|69		code
000366  aa  6 00254 2521 00	spri2	pr6|172
000367  aa   777411 3520 04	epp2 	-247,ic		000000 = 150143137160
000370  aa  6 00256 2521 00	spri2	pr6|174
000371  aa  6 00232 3521 00	epp2 	pr6|154
000372  aa  6 00260 2521 00	spri2	pr6|176
000373  aa   777450 3520 04	epp2 	-216,ic		000043 = 404000000043
000374  aa  6 00262 2521 00	spri2	pr6|178
000375  aa   777444 3520 04	epp2 	-220,ic		000041 = 526000000014
000376  aa  6 00264 2521 00	spri2	pr6|180
000377  aa   777436 3520 04	epp2 	-226,ic		000035 = 524000000017
000400  aa  6 00266 2521 00	spri2	pr6|182
000401  aa  6 00252 6211 00	eax1 	pr6|170
000402  aa   014000 4310 07	fld  	6144,dl
000403  aa  6 00044 3701 20	epp4 	pr6|36,*
000404  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000405  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 140
			     return;

000406  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 141
			end;

						STATEMENT 1 ON LINE 142
		     n_to_print = cv_dec_check_ (arg, code);

000407  aa  6 00100 2361 00	ldq  	pr6|64		argl
000410  aa   526000 2760 03	orq  	175104,du
000411  aa  6 00231 7561 00	stq  	pr6|153
000412  aa  6 00102 3521 20	epp2 	pr6|66,*		arg
000413  aa  6 00254 2521 00	spri2	pr6|172
000414  aa  6 00105 3521 00	epp2 	pr6|69		code
000415  aa  6 00256 2521 00	spri2	pr6|174
000416  aa  6 00143 3521 00	epp2 	pr6|99		n_to_print
000417  aa  6 00260 2521 00	spri2	pr6|176
000420  aa  6 00231 3521 00	epp2 	pr6|153
000421  aa  6 00262 2521 00	spri2	pr6|178
000422  aa   777421 3520 04	epp2 	-239,ic		000043 = 404000000043
000423  aa  6 00264 2521 00	spri2	pr6|180
000424  aa  6 00266 2521 00	spri2	pr6|182
000425  aa  6 00252 6211 00	eax1 	pr6|170
000426  aa   014000 4310 07	fld  	6144,dl
000427  aa  6 00044 3701 20	epp4 	pr6|36,*
000430  la  4 00026 3521 20	epp2 	pr4|22,*		cv_dec_check_
000431  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 143
		     if code ^= 0
		     then do;

000432  aa  6 00105 2361 00	ldq  	pr6|69		code
000433  aa   000036 6000 04	tze  	30,ic		000471
						STATEMENT 1 ON LINE 145
BAD_N_TO_PRINT:
			     call com_err_ (0, MYNAME, "Invalid number to print ^a", arg);

000434  aa  6 00100 2361 00	ldq  	pr6|64		argl
000435  aa   526000 2760 03	orq  	175104,du
000436  aa  6 00231 7561 00	stq  	pr6|153
000437  aa  6 00270 4501 00	stz  	pr6|184
000440  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000441  aa   777502 00 0034	desc9a	-190,28		000142 = 111156166141
000442  aa  6 00240 00 0034	desc9a	pr6|160,28
000443  aa  6 00270 3521 00	epp2 	pr6|184
000444  aa  6 00274 2521 00	spri2	pr6|188
000445  aa   777333 3520 04	epp2 	-293,ic		000000 = 150143137160
000446  aa  6 00276 2521 00	spri2	pr6|190
000447  aa  6 00240 3521 00	epp2 	pr6|160
000450  aa  6 00300 2521 00	spri2	pr6|192
000451  aa  6 00102 3521 20	epp2 	pr6|66,*		arg
000452  aa  6 00302 2521 00	spri2	pr6|194
000453  aa   777360 3520 04	epp2 	-272,ic		000033 = 404000000005
000454  aa  6 00304 2521 00	spri2	pr6|196
000455  aa   777364 3520 04	epp2 	-268,ic		000041 = 526000000014
000456  aa  6 00306 2521 00	spri2	pr6|198
000457  aa   777353 3520 04	epp2 	-277,ic		000032 = 524000000032
000460  aa  6 00310 2521 00	spri2	pr6|200
000461  aa  6 00231 3521 00	epp2 	pr6|153
000462  aa  6 00312 2521 00	spri2	pr6|202
000463  aa  6 00272 6211 00	eax1 	pr6|186
000464  aa   020000 4310 07	fld  	8192,dl
000465  aa  6 00044 3701 20	epp4 	pr6|36,*
000466  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000467  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 147
			     return;

000470  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 148
			end;

						STATEMENT 1 ON LINE 149
		     if n_to_print <= 0
		     then goto BAD_N_TO_PRINT;

000471  aa  6 00143 2361 00	ldq  	pr6|99		n_to_print
000472  aa   777742 6044 04	tmoz 	-30,ic		000434
						STATEMENT 1 ON LINE 151
		     sort_sw = "1"b;

000473  aa   400000 2350 03	lda  	131072,du
000474  aa  6 00156 7551 00	sta  	pr6|110		sort_sw
						STATEMENT 1 ON LINE 152
		end;

000475  aa   000026 7100 04	tra  	22,ic		000523
						STATEMENT 1 ON LINE 153
	     else do;

						STATEMENT 1 ON LINE 154
		     call com_err_ (error_table_$badopt, MYNAME, arg);

000476  aa  6 00100 2361 00	ldq  	pr6|64		argl
000477  aa   526000 2760 03	orq  	175104,du
000500  aa  6 00231 7561 00	stq  	pr6|153
000501  aa  6 00044 3701 20	epp4 	pr6|36,*
000502  la  4 00046 3521 20	epp2 	pr4|38,*		error_table_$badopt
000503  aa  6 00254 2521 00	spri2	pr6|172
000504  aa   777274 3520 04	epp2 	-324,ic		000000 = 150143137160
000505  aa  6 00256 2521 00	spri2	pr6|174
000506  aa  7 00000 3521 00	epp2 	pr7|0		arg
000507  aa  6 00260 2521 00	spri2	pr6|176
000510  aa   777333 3520 04	epp2 	-293,ic		000043 = 404000000043
000511  aa  6 00262 2521 00	spri2	pr6|178
000512  aa   777327 3520 04	epp2 	-297,ic		000041 = 526000000014
000513  aa  6 00264 2521 00	spri2	pr6|180
000514  aa  6 00231 3521 00	epp2 	pr6|153
000515  aa  6 00266 2521 00	spri2	pr6|182
000516  aa  6 00252 6211 00	eax1 	pr6|170
000517  aa   014000 4310 07	fld  	6144,dl
000520  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000521  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 155
		     return;

000522  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 156
		end;

						STATEMENT 1 ON LINE 157
	end;

000523  aa  6 00104 0541 00	aos  	pr6|68		arg_no
000524  aa   777516 7100 04	tra  	-178,ic		000242
						STATEMENT 1 ON LINE 159
	if ^report_sw & ^reset_sw
	then report_sw = "1"b;

000525  aa  6 00146 2351 00	lda  	pr6|102		report_sw
000526  aa   000005 6010 04	tnz  	5,ic		000533
000527  aa  6 00147 2351 00	lda  	pr6|103		reset_sw
000530  aa   000003 6010 04	tnz  	3,ic		000533
000531  aa   400000 2350 03	lda  	131072,du
000532  aa  6 00146 7551 00	sta  	pr6|102		report_sw
						STATEMENT 1 ON LINE 162
	if ^init
	then do;

000533  aa  6 00044 3701 20	epp4 	pr6|36,*
000534  ia  4 00010 2351 00	lda  	pr4|8		init
000535  aa   000755 6010 04	tnz  	493,ic		001512
						STATEMENT 1 ON LINE 176
		call get_temp_segments_ (MYNAME, temp_segp, code);

000536  aa   777242 3520 04	epp2 	-350,ic		000000 = 150143137160
000537  aa  6 00254 2521 00	spri2	pr6|172
000540  ia  4 00014 3521 00	epp2 	pr4|12		temp_segp
000541  aa  6 00256 2521 00	spri2	pr6|174
000542  aa  6 00105 3521 00	epp2 	pr6|69		code
000543  aa  6 00260 2521 00	spri2	pr6|176
000544  aa   777275 3520 04	epp2 	-323,ic		000041 = 526000000014
000545  aa  6 00262 2521 00	spri2	pr6|178
000546  aa   777324 3520 04	epp2 	-300,ic		000072 = 464100000000
000547  aa  6 00264 2521 00	spri2	pr6|180
000550  aa   777273 3520 04	epp2 	-325,ic		000043 = 404000000043
000551  aa  6 00266 2521 00	spri2	pr6|182
000552  aa  6 00252 6211 00	eax1 	pr6|170
000553  aa   014000 4310 07	fld  	6144,dl
000554  la  4 00030 3521 20	epp2 	pr4|24,*		get_temp_segments_
000555  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 177
		if code ^= 0
		then do;

000556  aa  6 00105 2361 00	ldq  	pr6|69		code
000557  aa   000031 6000 04	tze  	25,ic		000610
						STATEMENT 1 ON LINE 179
			call com_err_ (code, MYNAME, "Getting Temp Segs");

000560  aa   777340 2370 04	ldaq 	-288,ic		000120 = 107145164164 151156147040
000561  aa  6 00232 7571 00	staq 	pr6|154
000562  aa   777340 2370 04	ldaq 	-288,ic		000122 = 124145155160 040123145147
000563  aa  6 00234 7571 00	staq 	pr6|156
000564  aa   163000 2350 03	lda  	58880,du
000565  aa  6 00236 7551 00	sta  	pr6|158
000566  aa  6 00105 3521 00	epp2 	pr6|69		code
000567  aa  6 00254 2521 00	spri2	pr6|172
000570  aa   777210 3520 04	epp2 	-376,ic		000000 = 150143137160
000571  aa  6 00256 2521 00	spri2	pr6|174
000572  aa  6 00232 3521 00	epp2 	pr6|154
000573  aa  6 00260 2521 00	spri2	pr6|176
000574  aa   777247 3520 04	epp2 	-345,ic		000043 = 404000000043
000575  aa  6 00262 2521 00	spri2	pr6|178
000576  aa   777243 3520 04	epp2 	-349,ic		000041 = 526000000014
000577  aa  6 00264 2521 00	spri2	pr6|180
000600  aa   777231 3520 04	epp2 	-359,ic		000031 = 524000000021
000601  aa  6 00266 2521 00	spri2	pr6|182
000602  aa  6 00252 6211 00	eax1 	pr6|170
000603  aa   014000 4310 07	fld  	6144,dl
000604  aa  6 00044 3701 20	epp4 	pr6|36,*
000605  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000606  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 180
			return;

000607  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 181
		     end;

						STATEMENT 1 ON LINE 182
		call get_temp_segments_ (MYNAME, init_temp_segp, code);

000610  aa   777170 3520 04	epp2 	-392,ic		000000 = 150143137160
000611  aa  6 00254 2521 00	spri2	pr6|172
000612  aa  6 00112 3521 00	epp2 	pr6|74		init_temp_segp
000613  aa  6 00256 2521 00	spri2	pr6|174
000614  aa  6 00105 3521 00	epp2 	pr6|69		code
000615  aa  6 00260 2521 00	spri2	pr6|176
000616  aa   777223 3520 04	epp2 	-365,ic		000041 = 526000000014
000617  aa  6 00262 2521 00	spri2	pr6|178
000620  aa   777246 3520 04	epp2 	-346,ic		000066 = 464100000000
000621  aa  6 00264 2521 00	spri2	pr6|180
000622  aa   777221 3520 04	epp2 	-367,ic		000043 = 404000000043
000623  aa  6 00266 2521 00	spri2	pr6|182
000624  aa  6 00252 6211 00	eax1 	pr6|170
000625  aa   014000 4310 07	fld  	6144,dl
000626  aa  6 00044 3701 20	epp4 	pr6|36,*
000627  la  4 00030 3521 20	epp2 	pr4|24,*		get_temp_segments_
000630  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 183
		if code ^= 0
		then do;

000631  aa  6 00105 2361 00	ldq  	pr6|69		code
000632  aa   000052 6000 04	tze  	42,ic		000704
						STATEMENT 1 ON LINE 185
			call com_err_ (code, MYNAME, "Getting Temp Segs");

000633  aa   777265 2370 04	ldaq 	-331,ic		000120 = 107145164164 151156147040
000634  aa  6 00232 7571 00	staq 	pr6|154
000635  aa   777265 2370 04	ldaq 	-331,ic		000122 = 124145155160 040123145147
000636  aa  6 00234 7571 00	staq 	pr6|156
000637  aa   163000 2350 03	lda  	58880,du
000640  aa  6 00236 7551 00	sta  	pr6|158
000641  aa  6 00105 3521 00	epp2 	pr6|69		code
000642  aa  6 00254 2521 00	spri2	pr6|172
000643  aa   777135 3520 04	epp2 	-419,ic		000000 = 150143137160
000644  aa  6 00256 2521 00	spri2	pr6|174
000645  aa  6 00232 3521 00	epp2 	pr6|154
000646  aa  6 00260 2521 00	spri2	pr6|176
000647  aa   777174 3520 04	epp2 	-388,ic		000043 = 404000000043
000650  aa  6 00262 2521 00	spri2	pr6|178
000651  aa   777170 3520 04	epp2 	-392,ic		000041 = 526000000014
000652  aa  6 00264 2521 00	spri2	pr6|180
000653  aa   777156 3520 04	epp2 	-402,ic		000031 = 524000000021
000654  aa  6 00266 2521 00	spri2	pr6|182
000655  aa  6 00252 6211 00	eax1 	pr6|170
000656  aa   014000 4310 07	fld  	6144,dl
000657  aa  6 00044 3701 20	epp4 	pr6|36,*
000660  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000661  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 186
			call release_temp_segments_ (MYNAME, temp_segp, code);

000662  aa   777116 3520 04	epp2 	-434,ic		000000 = 150143137160
000663  aa  6 00254 2521 00	spri2	pr6|172
000664  aa  6 00044 3701 20	epp4 	pr6|36,*
000665  ia  4 00014 3521 00	epp2 	pr4|12		temp_segp
000666  aa  6 00256 2521 00	spri2	pr6|174
000667  aa  6 00105 3521 00	epp2 	pr6|69		code
000670  aa  6 00260 2521 00	spri2	pr6|176
000671  aa   777150 3520 04	epp2 	-408,ic		000041 = 526000000014
000672  aa  6 00262 2521 00	spri2	pr6|178
000673  aa   777177 3520 04	epp2 	-385,ic		000072 = 464100000000
000674  aa  6 00264 2521 00	spri2	pr6|180
000675  aa   777146 3520 04	epp2 	-410,ic		000043 = 404000000043
000676  aa  6 00266 2521 00	spri2	pr6|182
000677  aa  6 00252 6211 00	eax1 	pr6|170
000700  aa   014000 4310 07	fld  	6144,dl
000701  la  4 00034 3521 20	epp2 	pr4|28,*		release_temp_segments_
000702  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 187
			return;

000703  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 188
		     end;

						STATEMENT 1 ON LINE 190
		call copy_ring0_seg ("dseg", init_temp_segp (1), sdwp, code);

000704  aa   777124 2350 04	lda  	-428,ic		000030 = 144163145147
000705  aa  6 00231 7551 00	sta  	pr6|153
000706  aa   001544 3520 04	epp2 	868,ic		002452 = 000010000000
000707  aa  2 00000 2351 00	lda  	pr2|0
000710  aa   001254 6700 04	tsp4 	684,ic		002164
						STATEMENT 1 ON LINE 191
		if code ^= 0
		then do;

000711  aa  6 00105 2361 00	ldq  	pr6|69		code
000712  aa   000067 6000 04	tze  	55,ic		001001
						STATEMENT 1 ON LINE 193
			call com_err_ (code, MYNAME, "dseg");

000713  aa   777115 2350 04	lda  	-435,ic		000030 = 144163145147
000714  aa  6 00231 7551 00	sta  	pr6|153
000715  aa  6 00105 3521 00	epp2 	pr6|69		code
000716  aa  6 00254 2521 00	spri2	pr6|172
000717  aa   777061 3520 04	epp2 	-463,ic		000000 = 150143137160
000720  aa  6 00256 2521 00	spri2	pr6|174
000721  aa  6 00231 3521 00	epp2 	pr6|153
000722  aa  6 00260 2521 00	spri2	pr6|176
000723  aa   777120 3520 04	epp2 	-432,ic		000043 = 404000000043
000724  aa  6 00262 2521 00	spri2	pr6|178
000725  aa   777114 3520 04	epp2 	-436,ic		000041 = 526000000014
000726  aa  6 00264 2521 00	spri2	pr6|180
000727  aa   777100 3520 04	epp2 	-448,ic		000027 = 524000000004
000730  aa  6 00266 2521 00	spri2	pr6|182
000731  aa  6 00252 6211 00	eax1 	pr6|170
000732  aa   014000 4310 07	fld  	6144,dl
000733  aa  6 00044 3701 20	epp4 	pr6|36,*
000734  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000735  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 194
CLEAN_UP_INIT:
			call release_temp_segments_ (MYNAME, temp_segp, code);

000736  aa   777042 3520 04	epp2 	-478,ic		000000 = 150143137160
000737  aa  6 00254 2521 00	spri2	pr6|172
000740  aa  6 00044 3701 20	epp4 	pr6|36,*
000741  ia  4 00014 3521 00	epp2 	pr4|12		temp_segp
000742  aa  6 00256 2521 00	spri2	pr6|174
000743  aa  6 00105 3521 00	epp2 	pr6|69		code
000744  aa  6 00260 2521 00	spri2	pr6|176
000745  aa   777074 3520 04	epp2 	-452,ic		000041 = 526000000014
000746  aa  6 00262 2521 00	spri2	pr6|178
000747  aa   777123 3520 04	epp2 	-429,ic		000072 = 464100000000
000750  aa  6 00264 2521 00	spri2	pr6|180
000751  aa   777072 3520 04	epp2 	-454,ic		000043 = 404000000043
000752  aa  6 00266 2521 00	spri2	pr6|182
000753  aa  6 00252 6211 00	eax1 	pr6|170
000754  aa   014000 4310 07	fld  	6144,dl
000755  la  4 00034 3521 20	epp2 	pr4|28,*		release_temp_segments_
000756  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 196
			call release_temp_segments_ (MYNAME, init_temp_segp, code);

000757  aa   777021 3520 04	epp2 	-495,ic		000000 = 150143137160
000760  aa  6 00254 2521 00	spri2	pr6|172
000761  aa  6 00112 3521 00	epp2 	pr6|74		init_temp_segp
000762  aa  6 00256 2521 00	spri2	pr6|174
000763  aa  6 00105 3521 00	epp2 	pr6|69		code
000764  aa  6 00260 2521 00	spri2	pr6|176
000765  aa   777054 3520 04	epp2 	-468,ic		000041 = 526000000014
000766  aa  6 00262 2521 00	spri2	pr6|178
000767  aa   777077 3520 04	epp2 	-449,ic		000066 = 464100000000
000770  aa  6 00264 2521 00	spri2	pr6|180
000771  aa   777052 3520 04	epp2 	-470,ic		000043 = 404000000043
000772  aa  6 00266 2521 00	spri2	pr6|182
000773  aa  6 00252 6211 00	eax1 	pr6|170
000774  aa   014000 4310 07	fld  	6144,dl
000775  aa  6 00044 3701 20	epp4 	pr6|36,*
000776  la  4 00034 3521 20	epp2 	pr4|28,*		release_temp_segments_
000777  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 197
			return;

001000  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 198
		     end;

						STATEMENT 1 ON LINE 199
		call copy_ring0_seg ("slt", init_temp_segp (2), sltp, code);

001001  aa   777024 2350 04	lda  	-492,ic		000025 = 163154164000
001002  aa  6 00231 7551 00	sta  	pr6|153
001003  aa   001425 3520 04	epp2 	789,ic		002430 = 000010000000
001004  aa  2 00000 2351 00	lda  	pr2|0
001005  aa   001157 6700 04	tsp4 	623,ic		002164
						STATEMENT 1 ON LINE 200
		if code ^= 0
		then do;

001006  aa  6 00105 2361 00	ldq  	pr6|69		code
001007  aa   000025 6000 04	tze  	21,ic		001034
						STATEMENT 1 ON LINE 202
			call com_err_ (code, MYNAME, "slt");

001010  aa   777015 2350 04	lda  	-499,ic		000025 = 163154164000
001011  aa  6 00231 7551 00	sta  	pr6|153
001012  aa  6 00105 3521 00	epp2 	pr6|69		code
001013  aa  6 00254 2521 00	spri2	pr6|172
001014  aa   776764 3520 04	epp2 	-524,ic		000000 = 150143137160
001015  aa  6 00256 2521 00	spri2	pr6|174
001016  aa  6 00231 3521 00	epp2 	pr6|153
001017  aa  6 00260 2521 00	spri2	pr6|176
001020  aa   777023 3520 04	epp2 	-493,ic		000043 = 404000000043
001021  aa  6 00262 2521 00	spri2	pr6|178
001022  aa   777017 3520 04	epp2 	-497,ic		000041 = 526000000014
001023  aa  6 00264 2521 00	spri2	pr6|180
001024  aa   777000 3520 04	epp2 	-512,ic		000024 = 524000000003
001025  aa  6 00266 2521 00	spri2	pr6|182
001026  aa  6 00252 6211 00	eax1 	pr6|170
001027  aa   014000 4310 07	fld  	6144,dl
001030  aa  6 00044 3701 20	epp4 	pr6|36,*
001031  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001032  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 203
			goto CLEAN_UP_INIT;

001033  aa   777703 7100 04	tra  	-61,ic		000736
						STATEMENT 1 ON LINE 204
		     end;

						STATEMENT 1 ON LINE 205
		call copy_ring0_seg ("name_table", init_temp_segp (3), names_ptr, code);

001034  aa   777027 2350 04	lda  	-489,ic		000063 = 156141155145
001035  aa   777027 2360 04	ldq  	-489,ic		000064 = 137164141142
001036  aa  6 00232 7571 00	staq 	pr6|154
001037  aa   154145 2350 03	lda  	55397,du
001040  aa  6 00234 7551 00	sta  	pr6|156
001041  aa   001345 3520 04	epp2 	741,ic		002406 = 000010000000
001042  aa  2 00000 2351 00	lda  	pr2|0
001043  aa   001121 6700 04	tsp4 	593,ic		002164
						STATEMENT 1 ON LINE 206
		if code ^= 0
		then do;

001044  aa  6 00105 2361 00	ldq  	pr6|69		code
001045  aa   000030 6000 04	tze  	24,ic		001075
						STATEMENT 1 ON LINE 208
			call com_err_ (code, MYNAME, "name_table");

001046  aa   777015 2350 04	lda  	-499,ic		000063 = 156141155145
001047  aa   777015 2360 04	ldq  	-499,ic		000064 = 137164141142
001050  aa  6 00232 7571 00	staq 	pr6|154
001051  aa   154145 2350 03	lda  	55397,du
001052  aa  6 00234 7551 00	sta  	pr6|156
001053  aa  6 00105 3521 00	epp2 	pr6|69		code
001054  aa  6 00254 2521 00	spri2	pr6|172
001055  aa   776723 3520 04	epp2 	-557,ic		000000 = 150143137160
001056  aa  6 00256 2521 00	spri2	pr6|174
001057  aa  6 00232 3521 00	epp2 	pr6|154
001060  aa  6 00260 2521 00	spri2	pr6|176
001061  aa   776762 3520 04	epp2 	-526,ic		000043 = 404000000043
001062  aa  6 00262 2521 00	spri2	pr6|178
001063  aa   776756 3520 04	epp2 	-530,ic		000041 = 526000000014
001064  aa  6 00264 2521 00	spri2	pr6|180
001065  aa   776736 3520 04	epp2 	-546,ic		000023 = 524000000012
001066  aa  6 00266 2521 00	spri2	pr6|182
001067  aa  6 00252 6211 00	eax1 	pr6|170
001070  aa   014000 4310 07	fld  	6144,dl
001071  aa  6 00044 3701 20	epp4 	pr6|36,*
001072  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001073  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 209
			goto CLEAN_UP_INIT;

001074  aa   777642 7100 04	tra  	-94,ic		000736
						STATEMENT 1 ON LINE 210
		     end;

						STATEMENT 1 ON LINE 211
		call copy_ring0_seg ("stack_0_data", init_temp_segp (4), sdtp, code);

001075  aa   776763 2370 04	ldaq 	-525,ic		000060 = 163164141143 153137060137
001076  aa  6 00232 7571 00	staq 	pr6|154
001077  aa   776763 2350 04	lda  	-525,ic		000062 = 144141164141
001100  aa  6 00234 7551 00	sta  	pr6|156
001101  aa   001263 3520 04	epp2 	691,ic		002364 = 000010000000
001102  aa  2 00000 2351 00	lda  	pr2|0
001103  aa   001061 6700 04	tsp4 	561,ic		002164
						STATEMENT 1 ON LINE 212
		if code ^= 0
		then do;

001104  aa  6 00105 2361 00	ldq  	pr6|69		code
001105  aa   000027 6000 04	tze  	23,ic		001134
						STATEMENT 1 ON LINE 214
			call com_err_ (code, MYNAME, "stack_0_data");

001106  aa   776752 2370 04	ldaq 	-534,ic		000060 = 163164141143 153137060137
001107  aa  6 00232 7571 00	staq 	pr6|154
001110  aa   776752 2350 04	lda  	-534,ic		000062 = 144141164141
001111  aa  6 00234 7551 00	sta  	pr6|156
001112  aa  6 00105 3521 00	epp2 	pr6|69		code
001113  aa  6 00254 2521 00	spri2	pr6|172
001114  aa   776664 3520 04	epp2 	-588,ic		000000 = 150143137160
001115  aa  6 00256 2521 00	spri2	pr6|174
001116  aa  6 00232 3521 00	epp2 	pr6|154
001117  aa  6 00260 2521 00	spri2	pr6|176
001120  aa   776723 3520 04	epp2 	-557,ic		000043 = 404000000043
001121  aa  6 00262 2521 00	spri2	pr6|178
001122  aa   776717 3520 04	epp2 	-561,ic		000041 = 526000000014
001123  aa  6 00264 2521 00	spri2	pr6|180
001124  aa   776676 3520 04	epp2 	-578,ic		000022 = 524000000014
001125  aa  6 00266 2521 00	spri2	pr6|182
001126  aa  6 00252 6211 00	eax1 	pr6|170
001127  aa   014000 4310 07	fld  	6144,dl
001130  aa  6 00044 3701 20	epp4 	pr6|36,*
001131  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001132  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 215
			goto CLEAN_UP_INIT;

001133  aa   777603 7100 04	tra  	-125,ic		000736
						STATEMENT 1 ON LINE 216
		     end;

						STATEMENT 1 ON LINE 217
		call ring0_get_$segptr ("", "sst", sstp, code);

001134  aa   776664 2350 04	lda  	-588,ic		000020 = 163163164000
001135  aa  6 00270 7551 00	sta  	pr6|184
001136  aa  6 00231 3521 00	epp2 	pr6|153
001137  aa  6 00274 2521 00	spri2	pr6|188
001140  aa  6 00270 3521 00	epp2 	pr6|184
001141  aa  6 00276 2521 00	spri2	pr6|190
001142  aa  6 00162 3521 00	epp2 	pr6|114		sstp
001143  aa  6 00300 2521 00	spri2	pr6|192
001144  aa  6 00105 3521 00	epp2 	pr6|69		code
001145  aa  6 00302 2521 00	spri2	pr6|194
001146  aa   776653 3520 04	epp2 	-597,ic		000021 = 524000000000
001147  aa  6 00304 2521 00	spri2	pr6|196
001150  aa   776654 3520 04	epp2 	-596,ic		000024 = 524000000003
001151  aa  6 00306 2521 00	spri2	pr6|198
001152  aa   776654 3520 04	epp2 	-596,ic		000026 = 464000000000
001153  aa  6 00310 2521 00	spri2	pr6|200
001154  aa   776667 3520 04	epp2 	-585,ic		000043 = 404000000043
001155  aa  6 00312 2521 00	spri2	pr6|202
001156  aa  6 00272 6211 00	eax1 	pr6|186
001157  aa   020000 4310 07	fld  	8192,dl
001160  aa  6 00044 3701 20	epp4 	pr6|36,*
001161  la  4 00036 3521 20	epp2 	pr4|30,*		ring0_get_$segptr
001162  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 218
		if code ^= 0
		then do;

001163  aa  6 00105 2361 00	ldq  	pr6|69		code
001164  aa   000025 6000 04	tze  	21,ic		001211
						STATEMENT 1 ON LINE 220
SST_ERR:
			call com_err_ (code, MYNAME, "sst");

001165  aa   776633 2350 04	lda  	-613,ic		000020 = 163163164000
001166  aa  6 00270 7551 00	sta  	pr6|184
001167  aa  6 00105 3521 00	epp2 	pr6|69		code
001170  aa  6 00254 2521 00	spri2	pr6|172
001171  aa   776607 3520 04	epp2 	-633,ic		000000 = 150143137160
001172  aa  6 00256 2521 00	spri2	pr6|174
001173  aa  6 00270 3521 00	epp2 	pr6|184
001174  aa  6 00260 2521 00	spri2	pr6|176
001175  aa   776646 3520 04	epp2 	-602,ic		000043 = 404000000043
001176  aa  6 00262 2521 00	spri2	pr6|178
001177  aa   776642 3520 04	epp2 	-606,ic		000041 = 526000000014
001200  aa  6 00264 2521 00	spri2	pr6|180
001201  aa   776623 3520 04	epp2 	-621,ic		000024 = 524000000003
001202  aa  6 00266 2521 00	spri2	pr6|182
001203  aa  6 00252 6211 00	eax1 	pr6|170
001204  aa   014000 4310 07	fld  	6144,dl
001205  aa  6 00044 3701 20	epp4 	pr6|36,*
001206  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001207  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 222
			goto CLEAN_UP_INIT;

001210  aa   777526 7100 04	tra  	-170,ic		000736
						STATEMENT 1 ON LINE 223
		     end;

						STATEMENT 1 ON LINE 224
		call ring_zero_peek_$get_max_length ("sst", sst_size, code);

001211  aa   776607 2350 04	lda  	-633,ic		000020 = 163163164000
001212  aa  6 00270 7551 00	sta  	pr6|184
001213  aa  6 00270 3521 00	epp2 	pr6|184
001214  aa  6 00254 2521 00	spri2	pr6|172
001215  aa  6 00157 3521 00	epp2 	pr6|111		sst_size
001216  aa  6 00256 2521 00	spri2	pr6|174
001217  aa  6 00105 3521 00	epp2 	pr6|69		code
001220  aa  6 00260 2521 00	spri2	pr6|176
001221  aa   776603 3520 04	epp2 	-637,ic		000024 = 524000000003
001222  aa  6 00262 2521 00	spri2	pr6|178
001223  aa   776574 3520 04	epp2 	-644,ic		000017 = 404000000023
001224  aa  6 00264 2521 00	spri2	pr6|180
001225  aa   776616 3520 04	epp2 	-626,ic		000043 = 404000000043
001226  aa  6 00266 2521 00	spri2	pr6|182
001227  aa  6 00252 6211 00	eax1 	pr6|170
001230  aa   014000 4310 07	fld  	6144,dl
001231  aa  6 00044 3701 20	epp4 	pr6|36,*
001232  la  4 00042 3521 20	epp2 	pr4|34,*		ring_zero_peek_$get_max_length
001233  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 225
		if code ^= 0
		then goto SST_ERR;

001234  aa  6 00105 2361 00	ldq  	pr6|69		code
001235  aa   777730 6010 04	tnz  	-40,ic		001165
						STATEMENT 1 ON LINE 227
		upt_ptr = addr (unpaged_page_tables_header);

001236  aa  6 00166 3735 00	epp7 	pr6|118		unpaged_page_tables_header
001237  aa  6 00212 6535 00	spri7	pr6|138		upt_ptr
						STATEMENT 1 ON LINE 228
		call ring_zero_peek_$by_name ("unpaged_page_tables", 0, upt_ptr, size (unpaged_page_tables_header),
		     code);

001240  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001241  aa   776653 00 0024	desc9a	-597,20		000113 = 165156160141
001242  aa  6 00232 00 0024	desc9a	pr6|154,20
001243  aa  6 00270 4501 00	stz  	pr6|184
001244  aa   000010 2360 07	ldq  	8,dl
001245  aa  6 00231 7561 00	stq  	pr6|153
001246  aa  6 00232 3521 00	epp2 	pr6|154
001247  aa  6 00316 2521 00	spri2	pr6|206
001250  aa  6 00270 3521 00	epp2 	pr6|184
001251  aa  6 00320 2521 00	spri2	pr6|208
001252  aa  6 00212 3521 00	epp2 	pr6|138		upt_ptr
001253  aa  6 00322 2521 00	spri2	pr6|210
001254  aa  6 00231 3521 00	epp2 	pr6|153
001255  aa  6 00324 2521 00	spri2	pr6|212
001256  aa  6 00105 3521 00	epp2 	pr6|69		code
001257  aa  6 00326 2521 00	spri2	pr6|214
001260  aa   776536 3520 04	epp2 	-674,ic		000016 = 524000000023
001261  aa  6 00330 2521 00	spri2	pr6|216
001262  aa   776533 3520 04	epp2 	-677,ic		000015 = 404000000022
001263  aa  6 00332 2521 00	spri2	pr6|218
001264  aa   776542 3520 04	epp2 	-670,ic		000026 = 464000000000
001265  aa  6 00334 2521 00	spri2	pr6|220
001266  aa   776531 3520 04	epp2 	-679,ic		000017 = 404000000023
001267  aa  6 00336 2521 00	spri2	pr6|222
001270  aa   776553 3520 04	epp2 	-661,ic		000043 = 404000000043
001271  aa  6 00340 2521 00	spri2	pr6|224
001272  aa  6 00314 6211 00	eax1 	pr6|204
001273  aa   024000 4310 07	fld  	10240,dl
001274  aa  6 00044 3701 20	epp4 	pr6|36,*
001275  la  4 00040 3521 20	epp2 	pr4|32,*		ring_zero_peek_$by_name
001276  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 230
		if code ^= 0
		then go to SST_ERR;

001277  aa  6 00105 2361 00	ldq  	pr6|69		code
001300  aa   777665 6010 04	tnz  	-75,ic		001165
						STATEMENT 1 ON LINE 232
		sstadd = upt.sst_absloc;

001301  aa  6 00212 2361 20	ldq  	pr6|138,*		upt.sst_absloc
001302  aa  6 00160 7561 00	stq  	pr6|112		sstadd
						STATEMENT 1 ON LINE 237
		segx = 0;

001303  aa  6 00155 4501 00	stz  	pr6|109		segx
						STATEMENT 1 ON LINE 238
		do segn = 0 to slt.last_sup_seg;

001304  aa  6 00200 3735 20	epp7 	pr6|128,*		sltp
001305  aa  7 00004 2361 00	ldq  	pr7|4		slt.last_sup_seg
001306  aa  6 00215 7561 00	stq  	pr6|141
001307  aa  6 00154 4501 00	stz  	pr6|108		segn
001310  aa  6 00154 2361 00	ldq  	pr6|108		segn
001311  aa  6 00215 1161 00	cmpq 	pr6|141
001312  aa   000072 6054 04	tpnz 	58,ic		001404
						STATEMENT 1 ON LINE 239
		     sltep = addr (slt.seg (segn));

001313  aa   000002 7360 00	qls  	2
001314  aa  6 00200 3735 20	epp7 	pr6|128,*		sltp
001315  aa  7 00010 3735 06	epp7 	pr7|8,ql		slt.seg
001316  aa  6 00204 6535 00	spri7	pr6|132		sltep
						STATEMENT 1 ON LINE 240
		     if ^slte.abs_seg & ^slte.wired & ^slte.per_process & slte.paged & ^slte.init_seg & ^slte.temp_seg
		     then do;

001317  aa  7 00001 2351 00	lda  	pr7|1		slte.per_process
001320  aa   010050 3150 03	cana 	4136,du
001321  aa   000061 6010 04	tnz  	49,ic		001402
001322  aa  7 00001 2351 00	lda  	pr7|1		slte.paged
001323  aa   000020 3150 03	cana 	16,du
001324  aa   000056 6000 04	tze  	46,ic		001402
001325  aa  7 00001 2351 00	lda  	pr7|1		slte.temp_seg
001326  aa   030000 3150 07	cana 	12288,dl
001327  aa   000053 6010 04	tnz  	43,ic		001402
						STATEMENT 1 ON LINE 242
			     pt_relp = bin (sdwa (segn).add, 24) - sstadd;

001330  aa  6 00154 2361 00	ldq  	pr6|108		segn
001331  aa   000001 7360 00	qls  	1
001332  aa  6 00176 2351 66	lda  	pr6|126,*ql	sdwa.add
001333  aa  6 00231 7561 00	stq  	pr6|153
001334  aa  0 00060 3771 00	anaq 	pr0|48		= 777777770000 000000000000
001335  aa  6 00270 7551 00	sta  	pr6|184		sdwa.add
001336  aa   000060 7730 00	lrl  	48
001337  aa  6 00160 1761 00	sbq  	pr6|112		sstadd
001340  aa  6 00145 7561 00	stq  	pr6|101		pt_relp
						STATEMENT 1 ON LINE 243
			     if sdwa (segn).add ^= "0"b & ^sdwa (segn).unpaged & sdwa (segn).df & pt_relp > 0
				& pt_relp < sst_size
			     then do;

001341  aa  6 00270 2351 00	lda  	pr6|184		sdwa.add
001342  aa   000040 6000 04	tze  	32,ic		001402
001343  aa  6 00231 7271 00	lxl7 	pr6|153
001344  aa  6 00176 3715 20	epp5 	pr6|126,*		sdwp
001345  aa  5 00001 2351 17	lda  	pr5|1,7		sdwa.unpaged
001346  aa   200000 3150 07	cana 	65536,dl
001347  aa   000033 6010 04	tnz  	27,ic		001402
001350  aa  5 00000 2351 17	lda  	pr5|0,7		sdwa.df
001351  aa   000004 3150 07	cana 	4,dl
001352  aa   000030 6000 04	tze  	24,ic		001402
001353  aa  6 00145 2361 00	ldq  	pr6|101		pt_relp
001354  aa   000026 6044 04	tmoz 	22,ic		001402
001355  aa  6 00157 1161 00	cmpq 	pr6|111		sst_size
001356  aa   000024 6050 04	tpl  	20,ic		001402
						STATEMENT 1 ON LINE 246
				     segx = segx + 1;

001357  aa  6 00155 0541 00	aos  	pr6|109		segx
						STATEMENT 1 ON LINE 248
				     seg_info.seg (segx).rel_astep = pt_relp - size (aste);

001360  aa  6 00155 2361 00	ldq  	pr6|109		segx
001361  aa   000014 4020 07	mpy  	12,dl
001362  aa   000000 6260 06	eax6 	0,ql
001363  aa  6 00145 2361 00	ldq  	pr6|101		pt_relp
001364  aa   000014 1760 07	sbq  	12,dl
001365  aa  6 00044 3701 20	epp4 	pr6|36,*
001366  ia  4 00014 3535 20	epp3 	pr4|12,*		temp_segp
001367  aa  3 77775 7561 16	stq  	pr3|-3,6		seg_info.rel_astep
						STATEMENT 1 ON LINE 249
				     seg_info.seg (segx).prev_pf, seg_info.seg (segx).delta_pf = 0;

001370  aa  3 77776 4501 16	stz  	pr3|-2,6		seg_info.prev_pf
001371  aa  3 00000 4501 16	stz  	pr3|0,6		seg_info.delta_pf
						STATEMENT 1 ON LINE 250
				     seg_info.seg (segx).name =
					ptr (names_ptr, slte.names_ptr) -> segnam.names (1).name;

001372  aa  7 00000 2351 00	lda  	pr7|0		slte.names_ptr
001373  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001374  aa  6 00202 3521 20	epp2 	pr6|130,*		names_ptr
001375  aa   000000 3120 01	eawp2	0,au
001376  aa  3 77765 3515 16	epp1 	pr3|-11,6		seg_info.name
001377  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001400  aa  2 00002 00 0040	desc9a	pr2|2,32		segnam.name
001401  aa  1 00000 00 0040	desc9a	pr1|0,32		seg_info.name
						STATEMENT 1 ON LINE 252
				end;

						STATEMENT 1 ON LINE 253
			end;

						STATEMENT 1 ON LINE 254
		end;

001402  aa  6 00154 0541 00	aos  	pr6|108		segn
001403  aa   777705 7100 04	tra  	-59,ic		001310
						STATEMENT 1 ON LINE 256
		do segn = 1 to sdt.num_stacks;

001404  aa  6 00206 3735 20	epp7 	pr6|134,*		sdtp
001405  aa  7 00001 2361 00	ldq  	pr7|1		sdt.num_stacks
001406  aa  6 00216 7561 00	stq  	pr6|142
001407  aa   000001 2360 07	ldq  	1,dl
001410  aa  6 00154 7561 00	stq  	pr6|108		segn
001411  aa   000000 0110 03	nop  	0,du
001412  aa  6 00154 2361 00	ldq  	pr6|108		segn
001413  aa  6 00216 1161 00	cmpq 	pr6|142
001414  aa   000046 6054 04	tpnz 	38,ic		001462
						STATEMENT 1 ON LINE 258
		     stack_no = segn;

001415  aa  000 100 301 500	btd  	(pr),(pr)
001416  aa  6 00154 00 0004	desc9a	pr6|108,4		segn
001417  aa  6 00231 01 0004	desc9ls	pr6|153,4,0
001420  aa  6 00164 4501 00	stz  	pr6|116		stack_no
001421  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001422  aa  6 00231 01 0004	desc9ls	pr6|153,4,0
001423  aa   000742 00 0002	desc9a	482,2		002363 = 070323000000
001424  aa  6 00164 00 0003	desc9a	pr6|116,3		stack_no
						STATEMENT 1 ON LINE 259
		     sdtep = addr (sdt.stacks (segn));

001425  aa   000002 7360 00	qls  	2
001426  aa  6 00206 3735 66	epp7 	pr6|134,*ql	sdt.stacks
001427  aa  6 00210 6535 00	spri7	pr6|136		sdtep
						STATEMENT 1 ON LINE 260
		     segx = segx + 1;

001430  aa  6 00155 0541 00	aos  	pr6|109		segx
						STATEMENT 1 ON LINE 261
		     seg_info.seg (segx).rel_astep = bin (sdte.astep);

001431  aa  6 00155 2361 00	ldq  	pr6|109		segx
001432  aa   000014 4020 07	mpy  	12,dl
001433  aa  7 00001 2351 00	lda  	pr7|1		sdte.astep
001434  aa   000000 6270 06	eax7 	0,ql
001435  aa   000066 7730 00	lrl  	54
001436  aa  6 00044 3701 20	epp4 	pr6|36,*
001437  ia  4 00014 3715 20	epp5 	pr4|12,*		temp_segp
001440  aa  5 77775 7561 17	stq  	pr5|-3,7		seg_info.rel_astep
						STATEMENT 1 ON LINE 262
		     seg_info.seg (segx).prev_pf, seg_info.seg (segx).delta_pf = 0;

001441  aa  5 77776 4501 17	stz  	pr5|-2,7		seg_info.prev_pf
001442  aa  5 00000 4501 17	stz  	pr5|0,7		seg_info.delta_pf
						STATEMENT 1 ON LINE 263
		     seg_info.seg (segx).name = "stack_0." || stack_no;

001443  aa   000013 2360 07	ldq  	11,dl
001444  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_cs
001445  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001446  aa   776401 00 0010	desc9a	-767,8		000046 = 163164141143
001447  aa  2 00000 00 0010	desc9a	pr2|0,8
001450  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001451  aa  6 00164 00 0003	desc9a	pr6|116,3		stack_no
001452  aa  2 00002 00 0003	desc9a	pr2|2,3
001453  aa  5 77765 3535 17	epp3 	pr5|-11,7		seg_info.name
001454  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001455  aa  2 00000 00 0013	desc9a	pr2|0,11
001456  aa  3 00000 00 0040	desc9a	pr3|0,32		seg_info.name
						STATEMENT 1 ON LINE 264
		end;

001457  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
001460  aa  6 00154 0541 00	aos  	pr6|108		segn
001461  aa   777731 7100 04	tra  	-39,ic		001412
						STATEMENT 1 ON LINE 266
		call release_temp_segments_ (MYNAME, init_temp_segp, code);

001462  aa   776316 3520 04	epp2 	-818,ic		000000 = 150143137160
001463  aa  6 00254 2521 00	spri2	pr6|172
001464  aa  6 00112 3521 00	epp2 	pr6|74		init_temp_segp
001465  aa  6 00256 2521 00	spri2	pr6|174
001466  aa  6 00105 3521 00	epp2 	pr6|69		code
001467  aa  6 00260 2521 00	spri2	pr6|176
001470  aa   776351 3520 04	epp2 	-791,ic		000041 = 526000000014
001471  aa  6 00262 2521 00	spri2	pr6|178
001472  aa   776374 3520 04	epp2 	-772,ic		000066 = 464100000000
001473  aa  6 00264 2521 00	spri2	pr6|180
001474  aa   776347 3520 04	epp2 	-793,ic		000043 = 404000000043
001475  aa  6 00266 2521 00	spri2	pr6|182
001476  aa  6 00252 6211 00	eax1 	pr6|170
001477  aa   014000 4310 07	fld  	6144,dl
001500  aa  6 00044 3701 20	epp4 	pr6|36,*
001501  la  4 00034 3521 20	epp2 	pr4|28,*		release_temp_segments_
001502  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 267
		last_time = sys_info$time_of_bootload;

001503  aa  6 00044 3701 20	epp4 	pr6|36,*
001504  la  4 00050 2371 20	ldaq 	pr4|40,*		sys_info$time_of_bootload
001505  ia  4 00012 7571 00	staq 	pr4|10		last_time
						STATEMENT 1 ON LINE 268
		seg_info.n_segs = segx;

001506  aa  6 00155 2361 00	ldq  	pr6|109		segx
001507  ia  4 00014 7561 20	stq  	pr4|12,*		seg_info.n_segs
						STATEMENT 1 ON LINE 269
		init = "1"b;

001510  aa   400000 2350 03	lda  	131072,du
001511  ia  4 00010 7551 00	sta  	pr4|8		init
						STATEMENT 1 ON LINE 270
	     end;

						STATEMENT 1 ON LINE 272
	cur_time = clock ();

001512  aa  0 01435 7001 00	tsx0 	pr0|797		clock
001513  aa  6 00106 7571 00	staq 	pr6|70		cur_time
						STATEMENT 1 ON LINE 273
	metering_time = cur_time - last_time;

001514  aa  6 00044 3701 20	epp4 	pr6|36,*
001515  ia  4 00012 1771 00	sbaq 	pr4|10		last_time
001516  aa  6 00122 7571 00	staq 	pr6|82		metering_time
						STATEMENT 1 ON LINE 275
	sec = divide (metering_time, 1000000, 35);

001517  aa   776275 3520 04	epp2 	-835,ic		000014 = 000003641100
001520  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
001521  aa     000000000000
001522  aa  6 00150 7561 00	stq  	pr6|104		sec
						STATEMENT 1 ON LINE 276
	minute = divide (sec, 60, 35);

001523  aa   000074 5060 07	div  	60,dl
001524  aa  6 00124 7561 00	stq  	pr6|84		minute
						STATEMENT 1 ON LINE 277
	hr = divide (minute, 60, 17);

001525  aa   000074 5060 07	div  	60,dl
001526  aa  6 00110 7561 00	stq  	pr6|72		hr
						STATEMENT 1 ON LINE 278
	sec = mod (sec, 60);

001527  aa  6 00150 2361 00	ldq  	pr6|104		sec
001530  aa   000744 3520 04	epp2 	484,ic		002474 = 000000000074
001531  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
001532  aa  6 00150 7561 00	stq  	pr6|104		sec
						STATEMENT 1 ON LINE 279
	minute = mod (minute, 60);

001533  aa  6 00124 2361 00	ldq  	pr6|84		minute
001534  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
001535  aa  6 00124 7561 00	stq  	pr6|84		minute
						STATEMENT 1 ON LINE 280
	HR = hr;

001536  aa  000 100 301 500	btd  	(pr),(pr)
001537  aa  6 00110 00 0004	desc9a	pr6|72,4		hr
001540  aa  6 00342 01 0005	desc9ls	pr6|226,5,0
001541  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001542  aa  6 00342 01 0005	desc9ls	pr6|226,5,0
001543  aa   000621 00 0003	desc9a	401,3		002362 = 103070321000
001544  aa  6 00111 00 0004	desc9a	pr6|73,4		HR
						STATEMENT 1 ON LINE 281
	MINUTE = minute;

001545  aa  000 100 301 500	btd  	(pr),(pr)
001546  aa  6 00124 00 0004	desc9a	pr6|84,4		minute
001547  aa  6 00231 01 0003	desc9ls	pr6|153,3,0
001550  aa  6 00125 4501 00	stz  	pr6|85		MINUTE
001551  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001552  aa  6 00231 01 0003	desc9ls	pr6|153,3,0
001553  aa   000610 00 0002	desc9a	392,2		002361 = 070322000000
001554  aa  6 00125 00 0002	desc9a	pr6|85,2		MINUTE
						STATEMENT 1 ON LINE 282
	SEC = sec;

001555  aa  000 100 301 500	btd  	(pr),(pr)
001556  aa  6 00150 00 0004	desc9a	pr6|104,4		sec
001557  aa  6 00231 01 0003	desc9ls	pr6|153,3,0
001560  aa  6 00151 4501 00	stz  	pr6|105		SEC
001561  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001562  aa  6 00231 01 0003	desc9ls	pr6|153,3,0
001563  aa   000600 00 0002	desc9a	384,2		002361 = 070322000000
001564  aa  6 00151 00 0002	desc9a	pr6|105,2		SEC
						STATEMENT 1 ON LINE 283
	call ioa_ ("^/Total metering time^-^a^/", HR || ":" || MINUTE || ":" || SEC);

001565  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001566  aa   776346 00 0034	desc9a	-794,28		000133 = 136057124157
001567  aa  6 00240 00 0034	desc9a	pr6|160,28
001570  aa  6 00111 2351 00	lda  	pr6|73		HR
001571  aa   072000 2360 03	ldq  	29696,du
001572  aa  6 00342 7571 00	staq 	pr6|226
001573  aa  6 00125 2351 00	lda  	pr6|85		MINUTE
001574  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
001575  aa   000055 7730 00	lrl  	45
001576  aa  6 00342 2771 00	oraq 	pr6|226
001577  aa  6 00342 7571 00	staq 	pr6|226
001600  aa   072000 2350 03	lda  	29696,du
001601  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
001602  aa   000077 7730 00	lrl  	63
001603  aa  6 00342 2771 00	oraq 	pr6|226
001604  aa  6 00342 7571 00	staq 	pr6|226
001605  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001606  aa  6 00342 00 0010	desc9a	pr6|226,8
001607  aa  6 00232 00 0010	desc9a	pr6|154,8
001610  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001611  aa  6 00151 00 0002	desc9a	pr6|105,2		SEC
001612  aa  6 00234 00 0002	desc9a	pr6|156,2
001613  aa  6 00240 3521 00	epp2 	pr6|160
001614  aa  6 00254 2521 00	spri2	pr6|172
001615  aa  6 00232 3521 00	epp2 	pr6|154
001616  aa  6 00256 2521 00	spri2	pr6|174
001617  aa   776174 3520 04	epp2 	-900,ic		000013 = 524000000033
001620  aa  6 00260 2521 00	spri2	pr6|176
001621  aa   776202 3520 04	epp2 	-894,ic		000023 = 524000000012
001622  aa  6 00262 2521 00	spri2	pr6|178
001623  aa  6 00252 6211 00	eax1 	pr6|170
001624  aa   010000 4310 07	fld  	4096,dl
001625  la  4 00032 3521 20	epp2 	pr4|26,*		ioa_
001626  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 286
	total_pf = 0;

001627  aa  6 00165 4501 00	stz  	pr6|117		total_pf
						STATEMENT 1 ON LINE 287
	sort_array.n = seg_info.n_segs;

001630  aa  6 00044 3701 20	epp4 	pr6|36,*
001631  ia  4 00014 2361 20	ldq  	pr4|12,*		seg_info.n_segs
001632  ia  4 00016 7561 20	stq  	pr4|14,*		sort_array.n
						STATEMENT 1 ON LINE 288
	do segx = 1 to seg_info.n_segs;

001633  aa  6 00217 7561 00	stq  	pr6|143
001634  aa   000001 2360 07	ldq  	1,dl
001635  aa  6 00155 7561 00	stq  	pr6|109		segx
001636  aa  6 00155 2361 00	ldq  	pr6|109		segx
001637  aa  6 00217 1161 00	cmpq 	pr6|143
001640  aa   000133 6054 04	tpnz 	91,ic		001773
						STATEMENT 1 ON LINE 289
	     call ring_zero_peek_$by_name ("sst", seg_info.seg (segx).rel_astep, addr (my_seg_aste), size (my_seg_aste),
		code);

001641  aa   776154 2360 04	ldq  	-916,ic		000015 = 404000000022
001642  aa  6 00231 7561 00	stq  	pr6|153
001643  aa   776155 2350 04	lda  	-915,ic		000020 = 163163164000
001644  aa  6 00270 7551 00	sta  	pr6|184
001645  aa  6 00155 2361 00	ldq  	pr6|109		segx
001646  aa   000014 4020 07	mpy  	12,dl
001647  aa  6 00126 3735 00	epp7 	pr6|86		my_seg_aste
001650  aa  6 00342 6535 00	spri7	pr6|226
001651  aa   000000 6270 06	eax7 	0,ql
001652  aa   000014 2360 07	ldq  	12,dl
001653  aa  6 00271 7561 00	stq  	pr6|185
001654  aa  6 00270 3521 00	epp2 	pr6|184
001655  aa  6 00316 2521 00	spri2	pr6|206
001656  aa  6 00044 3701 20	epp4 	pr6|36,*
001657  ia  4 00014 3715 20	epp5 	pr4|12,*		temp_segp
001660  aa  5 77775 3521 17	epp2 	pr5|-3,7		seg_info.rel_astep
001661  aa  6 00320 2521 00	spri2	pr6|208
001662  aa  6 00342 3521 00	epp2 	pr6|226
001663  aa  6 00322 2521 00	spri2	pr6|210
001664  aa  6 00271 3521 00	epp2 	pr6|185
001665  aa  6 00324 2521 00	spri2	pr6|212
001666  aa  6 00105 3521 00	epp2 	pr6|69		code
001667  aa  6 00326 2521 00	spri2	pr6|214
001670  aa   776134 3520 04	epp2 	-932,ic		000024 = 524000000003
001671  aa  6 00330 2521 00	spri2	pr6|216
001672  aa  6 00231 3521 00	epp2 	pr6|153
001673  aa  6 00332 2521 00	spri2	pr6|218
001674  aa   776132 3520 04	epp2 	-934,ic		000026 = 464000000000
001675  aa  6 00334 2521 00	spri2	pr6|220
001676  aa   776121 3520 04	epp2 	-943,ic		000017 = 404000000023
001677  aa  6 00336 2521 00	spri2	pr6|222
001700  aa   776143 3520 04	epp2 	-925,ic		000043 = 404000000043
001701  aa  6 00340 2521 00	spri2	pr6|224
001702  aa  6 00314 6211 00	eax1 	pr6|204
001703  aa   024000 4310 07	fld  	10240,dl
001704  la  4 00040 3521 20	epp2 	pr4|32,*		ring_zero_peek_$by_name
001705  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 291
	     if code ^= 0
	     then do;

001706  aa  6 00105 2361 00	ldq  	pr6|69		code
001707  aa   000036 6000 04	tze  	30,ic		001745
						STATEMENT 1 ON LINE 293
		     call com_err_ (code, MYNAME, "sst|^o", seg_info.seg (segx).rel_astep);

001710  aa   776105 2360 04	ldq  	-955,ic		000015 = 404000000022
001711  aa  6 00231 7561 00	stq  	pr6|153
001712  aa   776132 2370 04	ldaq 	-934,ic		000044 = 163163164174 136157000000
001713  aa  6 00342 7571 00	staq 	pr6|226
001714  aa  6 00155 2361 00	ldq  	pr6|109		segx
001715  aa   000014 4020 07	mpy  	12,dl
001716  aa  6 00105 3521 00	epp2 	pr6|69		code
001717  aa  6 00274 2521 00	spri2	pr6|188
001720  aa   776060 3520 04	epp2 	-976,ic		000000 = 150143137160
001721  aa  6 00276 2521 00	spri2	pr6|190
001722  aa  6 00342 3521 00	epp2 	pr6|226
001723  aa  6 00300 2521 00	spri2	pr6|192
001724  aa  6 00044 3701 20	epp4 	pr6|36,*
001725  ia  4 00014 3735 20	epp7 	pr4|12,*		temp_segp
001726  aa  7 77775 3521 06	epp2 	pr7|-3,ql		seg_info.rel_astep
001727  aa  6 00302 2521 00	spri2	pr6|194
001730  aa   776113 3520 04	epp2 	-949,ic		000043 = 404000000043
001731  aa  6 00304 2521 00	spri2	pr6|196
001732  aa   776107 3520 04	epp2 	-953,ic		000041 = 526000000014
001733  aa  6 00306 2521 00	spri2	pr6|198
001734  aa   776056 3520 04	epp2 	-978,ic		000012 = 524000000006
001735  aa  6 00310 2521 00	spri2	pr6|200
001736  aa  6 00231 3521 00	epp2 	pr6|153
001737  aa  6 00312 2521 00	spri2	pr6|202
001740  aa  6 00272 6211 00	eax1 	pr6|186
001741  aa   020000 4310 07	fld  	8192,dl
001742  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001743  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 294
		     return;

001744  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 295
		end;

						STATEMENT 1 ON LINE 296
	     seg_info.seg (segx).cur_pf = my_seg_aste.usage;

001745  aa  6 00155 2361 00	ldq  	pr6|109		segx
001746  aa   000014 4020 07	mpy  	12,dl
001747  aa   000000 6270 06	eax7 	0,ql
001750  aa  6 00136 2361 00	ldq  	pr6|94		my_seg_aste.usage
001751  aa  6 00044 3701 20	epp4 	pr6|36,*
001752  ia  4 00014 3735 20	epp7 	pr4|12,*		temp_segp
001753  aa  7 77777 7561 17	stq  	pr7|-1,7		seg_info.cur_pf
						STATEMENT 1 ON LINE 298
	     sort_array.p (segx) = addr (seg_info.seg (segx));

001754  aa  7 77765 3715 17	epp5 	pr7|-11,7		seg_info.seg
001755  aa  6 00155 7261 00	lxl6 	pr6|109		segx
001756  ia  4 00016 5451 76	sprp5	pr4|14,*6		sort_array.p
						STATEMENT 1 ON LINE 299
	     seg_info.seg (segx).delta_pf = my_seg_aste.usage - seg_info.seg (segx).prev_pf;

001757  aa  6 00136 3361 00	lcq  	pr6|94		my_seg_aste.usage
001760  aa   000044 7770 00	llr  	36
001761  aa   000044 7330 00	lrs  	36
001762  aa  7 77776 0331 17	adl  	pr7|-2,7		seg_info.prev_pf
001763  aa   000000 5330 00	negl 	0
001764  aa  7 00000 7561 17	stq  	pr7|0,7		seg_info.delta_pf
						STATEMENT 1 ON LINE 300
	     total_pf = total_pf + seg_info.seg (segx).delta_pf;

001765  aa   000044 7770 00	llr  	36
001766  aa   000044 7330 00	lrs  	36
001767  aa  6 00165 0331 00	adl  	pr6|117		total_pf
001770  aa  6 00165 7561 00	stq  	pr6|117		total_pf
						STATEMENT 1 ON LINE 301
	end;

001771  aa  6 00155 0541 00	aos  	pr6|109		segx
001772  aa   777644 7100 04	tra  	-92,ic		001636
						STATEMENT 1 ON LINE 304
	if report_sw
	then do;

001773  aa  6 00146 2351 00	lda  	pr6|102		report_sw
001774  aa   000143 6000 04	tze  	99,ic		002137
						STATEMENT 1 ON LINE 307
		call sort_items_$general (temp_segp (2), order_entries);

001775  aa   000270 3520 04	epp2 	184,ic		002265 = 000120627000
001776  aa  6 00232 2521 00	spri2	pr6|154		cp.267
001777  aa  6 00234 6521 00	spri6	pr6|156		cp.267
002000  aa  6 00044 3701 20	epp4 	pr6|36,*
002001  ia  4 00016 3521 00	epp2 	pr4|14		temp_segp
002002  aa  6 00242 2521 00	spri2	pr6|162
002003  aa  6 00232 3521 00	epp2 	pr6|154		cp.267
002004  aa  6 00244 2521 00	spri2	pr6|164
002005  aa  6 00240 6211 00	eax1 	pr6|160
002006  aa   010000 4310 07	fld  	4096,dl
002007  la  4 00044 3521 20	epp2 	pr4|36,*		sort_items_$general
002010  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 309
		call ioa_ ("Segment^26xPage Faults  % Total^/");

002011  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002012  aa   776151 00 0044	desc9a	-919,36		000162 = 123145147155
002013  aa  6 00240 00 0044	desc9a	pr6|160,36
002014  aa  6 00240 3521 00	epp2 	pr6|160
002015  aa  6 00234 2521 00	spri2	pr6|156
002016  aa   775773 3520 04	epp2 	-1029,ic		000011 = 524000000041
002017  aa  6 00236 2521 00	spri2	pr6|158
002020  aa  6 00232 6211 00	eax1 	pr6|154
002021  aa   004000 4310 07	fld  	2048,dl
002022  aa  6 00044 3701 20	epp4 	pr6|36,*
002023  la  4 00032 3521 20	epp2 	pr4|26,*		ioa_
002024  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 311
		do segx = 1 to min (seg_info.n_segs, n_to_print);

002025  aa  6 00044 3701 20	epp4 	pr6|36,*
002026  ia  4 00014 2361 20	ldq  	pr4|12,*		seg_info.n_segs
002027  aa  6 00143 1161 00	cmpq 	pr6|99		n_to_print
002030  aa   000002 6040 04	tmi  	2,ic		002032
002031  aa  6 00143 2361 00	ldq  	pr6|99		n_to_print
002032  aa  6 00220 7561 00	stq  	pr6|144
002033  aa   000001 2360 07	ldq  	1,dl
002034  aa  6 00155 7561 00	stq  	pr6|109		segx
002035  aa   000000 0110 03	nop  	0,du
002036  aa  6 00155 2361 00	ldq  	pr6|109		segx
002037  aa  6 00220 1161 00	cmpq 	pr6|144
002040  aa   000057 6054 04	tpnz 	47,ic		002117
						STATEMENT 1 ON LINE 312
		     seg_entryp = sort_array (segx).p;

002041  aa  6 00044 3701 20	epp4 	pr6|36,*
002042  ia  4 00016 7671 66	lprp7	pr4|14,*ql	sort_array.p
002043  aa  6 00152 6535 00	spri7	pr6|106		seg_entryp
						STATEMENT 1 ON LINE 313
		     if total_pf = 0
		     then pct_pf = 0.;

002044  aa  6 00165 2361 00	ldq  	pr6|117		total_pf
002045  aa   000004 6010 04	tnz  	4,ic		002051
002046  aa   400000 4310 03	fld  	131072,du
002047  aa  6 00144 4551 00	fst  	pr6|100		pct_pf
002050  aa   000011 7100 04	tra  	9,ic		002061
						STATEMENT 1 ON LINE 315
		     else pct_pf = seg_entry.delta_pf * 100.0 / total_pf;

002051  aa  7 00013 2361 00	ldq  	pr7|11		seg_entry.delta_pf
002052  aa   003100 4020 07	mpy  	1600,dl
002053  aa  6 00165 3521 00	epp2 	pr6|117		total_pf
002054  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
002055  aa     000000000024
002056  aa   136000 4110 03	lde  	48128,du
002057  aa   400000 4750 03	fad  	131072,du
002060  aa  6 00144 4551 00	fst  	pr6|100		pct_pf
						STATEMENT 1 ON LINE 316
		     if seg_entry.delta_pf ^= 0
		     then call ioa_ ("^32a ^8d     ^6.2f", seg_entry.name, seg_entry.delta_pf, pct_pf);

002061  aa  7 00013 2361 00	ldq  	pr7|11		seg_entry.delta_pf
002062  aa   000033 6000 04	tze  	27,ic		002115
002063  aa   776023 2370 04	ldaq 	-1005,ic		000106 = 136063062141 040136070144
002064  aa  6 00232 7571 00	staq 	pr6|154
002065  aa   776023 2370 04	ldaq 	-1005,ic		000110 = 040040040040 040136066056
002066  aa  6 00234 7571 00	staq 	pr6|156
002067  aa   062146 2350 03	lda  	25702,du
002070  aa  6 00236 7551 00	sta  	pr6|158
002071  aa  6 00232 3521 00	epp2 	pr6|154
002072  aa  6 00274 2521 00	spri2	pr6|188
002073  aa  7 00000 3521 00	epp2 	pr7|0		seg_entry.name
002074  aa  6 00276 2521 00	spri2	pr6|190
002075  aa  7 00013 3521 00	epp2 	pr7|11		seg_entry.delta_pf
002076  aa  6 00300 2521 00	spri2	pr6|192
002077  aa  6 00144 3521 00	epp2 	pr6|100		pct_pf
002100  aa  6 00302 2521 00	spri2	pr6|194
002101  aa   775707 3520 04	epp2 	-1081,ic		000010 = 524000000022
002102  aa  6 00304 2521 00	spri2	pr6|196
002103  aa   775704 3520 04	epp2 	-1084,ic		000007 = 526000000040
002104  aa  6 00306 2521 00	spri2	pr6|198
002105  aa   775736 3520 04	epp2 	-1058,ic		000043 = 404000000043
002106  aa  6 00310 2521 00	spri2	pr6|200
002107  aa   775677 3520 04	epp2 	-1089,ic		000006 = 414000000033
002110  aa  6 00312 2521 00	spri2	pr6|202
002111  aa  6 00272 6211 00	eax1 	pr6|186
002112  aa   020000 4310 07	fld  	8192,dl
002113  la  4 00032 3521 20	epp2 	pr4|26,*		ioa_
002114  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 318
		end;

002115  aa  6 00155 0541 00	aos  	pr6|109		segx
002116  aa   777720 7100 04	tra  	-48,ic		002036
						STATEMENT 1 ON LINE 320
		call ioa_ ("^/Total Hardcore Page Faults^7x^8d^/", total_pf);

002117  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002120  aa   776032 00 0044	desc9a	-998,36		000151 = 136057124157
002121  aa  6 00240 00 0044	desc9a	pr6|160,36
002122  aa  6 00240 3521 00	epp2 	pr6|160
002123  aa  6 00254 2521 00	spri2	pr6|172
002124  aa  6 00165 3521 00	epp2 	pr6|117		total_pf
002125  aa  6 00256 2521 00	spri2	pr6|174
002126  aa   775657 3520 04	epp2 	-1105,ic		000005 = 524000000044
002127  aa  6 00260 2521 00	spri2	pr6|176
002130  aa   775713 3520 04	epp2 	-1077,ic		000043 = 404000000043
002131  aa  6 00262 2521 00	spri2	pr6|178
002132  aa  6 00252 6211 00	eax1 	pr6|170
002133  aa   010000 4310 07	fld  	4096,dl
002134  aa  6 00044 3701 20	epp4 	pr6|36,*
002135  la  4 00032 3521 20	epp2 	pr4|26,*		ioa_
002136  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 322
	     end;

						STATEMENT 1 ON LINE 324
	if reset_sw
	then do;

002137  aa  6 00147 2351 00	lda  	pr6|103		reset_sw
002140  aa   000023 6000 04	tze  	19,ic		002163
						STATEMENT 1 ON LINE 327
		last_time = cur_time;

002141  aa  6 00106 2371 00	ldaq 	pr6|70		cur_time
002142  aa  6 00044 3701 20	epp4 	pr6|36,*
002143  ia  4 00012 7571 00	staq 	pr4|10		last_time
						STATEMENT 1 ON LINE 329
		do segx = 1 to seg_info.n_segs;

002144  ia  4 00014 2361 20	ldq  	pr4|12,*		seg_info.n_segs
002145  aa  6 00221 7561 00	stq  	pr6|145
002146  aa   000001 2360 07	ldq  	1,dl
002147  aa  6 00155 7561 00	stq  	pr6|109		segx
002150  aa  6 00155 2361 00	ldq  	pr6|109		segx
002151  aa  6 00221 1161 00	cmpq 	pr6|145
002152  aa   000011 6054 04	tpnz 	9,ic		002163
						STATEMENT 1 ON LINE 330
		     seg_info.seg (segx).prev_pf = seg_info.seg (segx).cur_pf;

002153  aa   000014 4020 07	mpy  	12,dl
002154  aa  6 00044 3701 20	epp4 	pr6|36,*
002155  ia  4 00014 3735 20	epp7 	pr4|12,*		temp_segp
002156  aa   000000 6270 06	eax7 	0,ql
002157  aa  7 77777 2361 06	ldq  	pr7|-1,ql		seg_info.cur_pf
002160  aa  7 77776 7561 17	stq  	pr7|-2,7		seg_info.prev_pf
						STATEMENT 1 ON LINE 331
		end;

002161  aa  6 00155 0541 00	aos  	pr6|109		segx
002162  aa   777766 7100 04	tra  	-10,ic		002150
						STATEMENT 1 ON LINE 333
	     end;

						STATEMENT 1 ON LINE 335
	return;

002163  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 396
     end hc_pf_meters;

BEGIN PROCEDURE copy_ring0_seg
ENTRY TO copy_ring0_seg                                     STATEMENT 1 ON LINE 337
copy_ring0_seg:
     proc (segname, seg_ptr, seg_ptr_1, code);

002164  aa  6 00222 6501 00	spri4	pr6|146
002165  aa  6 00224 2521 00	spri2	pr6|148
002166  aa  2 00002 3521 01	epp2 	pr2|2,au
002167  aa  6 00226 2521 00	spri2	pr6|150
002170  aa  2 00000 2361 20	ldq  	pr2|0,*
002171  aa   000002 6040 04	tmi  	2,ic		002173
002172  aa   777777 3760 07	anq  	262143,dl
002173  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002174  aa  6 00345 7561 00	stq  	pr6|229
						STATEMENT 1 ON LINE 348
	call ring_zero_peek_$get_max_length (segname, seg_size, code);

002175  aa  6 00224 3735 20	epp7 	pr6|148,*
002176  aa  7 00002 3521 20	epp2 	pr7|2,*		segname
002177  aa  6 00350 2521 00	spri2	pr6|232
002200  aa  6 00230 3521 00	epp2 	pr6|152		seg_size
002201  aa  6 00352 2521 00	spri2	pr6|234
002202  aa  7 00010 3521 20	epp2 	pr7|8,*		code
002203  aa  6 00354 2521 00	spri2	pr6|236
002204  aa  6 00226 3715 20	epp5 	pr6|150,*
002205  aa  5 00000 3521 20	epp2 	pr5|0,*
002206  aa  6 00356 2521 00	spri2	pr6|238
002207  aa   775610 3520 04	epp2 	-1144,ic		000017 = 404000000023
002210  aa  6 00360 2521 00	spri2	pr6|240
002211  aa   775632 3520 04	epp2 	-1126,ic		000043 = 404000000043
002212  aa  6 00362 2521 00	spri2	pr6|242
002213  aa  6 00346 6211 00	eax1 	pr6|230
002214  aa   014000 4310 07	fld  	6144,dl
002215  aa  6 00044 3701 20	epp4 	pr6|36,*
002216  la  4 00042 3521 20	epp2 	pr4|34,*		ring_zero_peek_$get_max_length
002217  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 349
	if code ^= 0
	then return;

002220  aa  6 00224 3735 20	epp7 	pr6|148,*
002221  aa  7 00010 2361 20	ldq  	pr7|8,*		code
002222  aa   000002 6000 04	tze  	2,ic		002224
002223  aa  6 00222 6101 00	rtcd 	pr6|146
						STATEMENT 1 ON LINE 352
	call ring_zero_peek_$by_name (segname, 0, seg_ptr, seg_size, code);

002224  aa  6 00364 4501 00	stz  	pr6|244
002225  aa  7 00002 3521 20	epp2 	pr7|2,*		segname
002226  aa  6 00370 2521 00	spri2	pr6|248
002227  aa  6 00364 3521 00	epp2 	pr6|244
002230  aa  6 00372 2521 00	spri2	pr6|250
002231  aa  7 00004 3521 20	epp2 	pr7|4,*		seg_ptr
002232  aa  6 00374 2521 00	spri2	pr6|252
002233  aa  6 00230 3521 00	epp2 	pr6|152		seg_size
002234  aa  6 00376 2521 00	spri2	pr6|254
002235  aa  7 00010 3521 20	epp2 	pr7|8,*		code
002236  aa  6 00400 2521 00	spri2	pr6|256
002237  aa  6 00226 3715 20	epp5 	pr6|150,*
002240  aa  5 00000 3521 20	epp2 	pr5|0,*
002241  aa  6 00402 2521 00	spri2	pr6|258
002242  aa   775553 3520 04	epp2 	-1173,ic		000015 = 404000000022
002243  aa  6 00404 2521 00	spri2	pr6|260
002244  aa   775562 3520 04	epp2 	-1166,ic		000026 = 464000000000
002245  aa  6 00406 2521 00	spri2	pr6|262
002246  aa   775551 3520 04	epp2 	-1175,ic		000017 = 404000000023
002247  aa  6 00410 2521 00	spri2	pr6|264
002250  aa   775573 3520 04	epp2 	-1157,ic		000043 = 404000000043
002251  aa  6 00412 2521 00	spri2	pr6|266
002252  aa  6 00366 6211 00	eax1 	pr6|246
002253  aa   024000 4310 07	fld  	10240,dl
002254  aa  6 00044 3701 20	epp4 	pr6|36,*
002255  la  4 00040 3521 20	epp2 	pr4|32,*		ring_zero_peek_$by_name
002256  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 353
	seg_ptr_1 = seg_ptr;

002257  aa  6 00224 3735 20	epp7 	pr6|148,*
002260  aa  7 00004 3715 20	epp5 	pr7|4,*		seg_ptr
002261  aa  5 00000 3715 20	epp5 	pr5|0,*		seg_ptr
002262  aa  7 00006 6515 20	spri5	pr7|6,*		seg_ptr_1
						STATEMENT 1 ON LINE 355
     end copy_ring0_seg;

002263  aa  6 00222 6101 00	rtcd 	pr6|146
  END PROCEDURE copy_ring0_seg
BEGIN PROCEDURE order_entries
ENTRY TO order_entries                                      STATEMENT 1 ON LINE 357
order_entries:
     proc (p1, p2) returns (fixed bin (1));

002264  da     000173220000
002265  aa   000120 6270 00	eax7 	80
002266  aa  7 00034 3521 20	epp2 	pr7|28,*
002267  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
002270  aa     000006000000
002271  aa     000000000000
						STATEMENT 1 ON LINE 365
	if sort_sw
	then do;

002272  aa  6 00040 3735 20	epp7 	pr6|32,*
002273  aa  7 00156 2351 00	lda  	pr7|110		sort_sw
002274  aa   000032 6000 04	tze  	26,ic		002326
						STATEMENT 1 ON LINE 367
		if seg1.delta_pf < seg2.delta_pf
		then return (1);

002275  aa  6 00032 3715 20	epp5 	pr6|26,*
002276  aa  5 00002 3535 20	epp3 	pr5|2,*
002277  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002300  aa  3 00000 00 0044	descb	pr3|0,36		p1
002301  aa  6 00100 00 0044	descb	pr6|64,36		p1
002302  aa  6 00100 7611 00	lprp1	pr6|64		p1
002303  aa  5 00004 3535 20	epp3 	pr5|4,*
002304  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002305  aa  3 00000 00 0044	descb	pr3|0,36		p2
002306  aa  6 00100 00 0044	descb	pr6|64,36		p2
002307  aa  6 00100 7631 00	lprp3	pr6|64		p2
002310  aa  1 00013 2361 00	ldq  	pr1|11		seg1.delta_pf
002311  aa  3 00013 1161 00	cmpq 	pr3|11		seg2.delta_pf
002312  aa  6 00102 2515 00	spri1	pr6|66
002313  aa  6 00104 2535 00	spri3	pr6|68
002314  aa   000004 6050 04	tpl  	4,ic		002320
002315  aa   000001 2360 07	ldq  	1,dl
002316  aa  5 00006 7561 20	stq  	pr5|6,*
002317  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 369
		else if seg1.delta_pf > seg2.delta_pf
		then return (-1);

002320  aa   000004 6044 04	tmoz 	4,ic		002324
002321  aa   000001 3360 07	lcq  	1,dl
002322  aa  5 00006 7561 20	stq  	pr5|6,*
002323  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 371
		else return (0);

002324  aa  5 00006 4501 20	stz  	pr5|6,*
002325  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 372
	     end;

						STATEMENT 1 ON LINE 373
	else do;

						STATEMENT 1 ON LINE 374
		if seg1.name < seg2.name
		then return (-1);

002326  aa  6 00032 3715 20	epp5 	pr6|26,*
002327  aa  5 00002 3535 20	epp3 	pr5|2,*
002330  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002331  aa  3 00000 00 0044	descb	pr3|0,36		p1
002332  aa  6 00101 00 0044	descb	pr6|65,36		p1
002333  aa  6 00101 7611 00	lprp1	pr6|65		p1
002334  aa  5 00004 3535 20	epp3 	pr5|4,*
002335  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002336  aa  3 00000 00 0044	descb	pr3|0,36		p2
002337  aa  6 00101 00 0044	descb	pr6|65,36		p2
002340  aa  6 00101 7631 00	lprp3	pr6|65		p2
002341  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
002342  aa  1 00000 00 0040	desc9a	pr1|0,32		seg1.name
002343  aa  3 00000 00 0040	desc9a	pr3|0,32		seg2.name
002344  aa  6 00104 2515 00	spri1	pr6|68
002345  aa  6 00102 2535 00	spri3	pr6|66
002346  aa   000004 6030 04	trc  	4,ic		002352
002347  aa   000001 3360 07	lcq  	1,dl
002350  aa  5 00006 7561 20	stq  	pr5|6,*
002351  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 376
		else if seg1.name > seg2.name
		then return (1);

002352  aa   000005 6020 04	tnc  	5,ic		002357
002353  aa   000004 6000 04	tze  	4,ic		002357
002354  aa   000001 2360 07	ldq  	1,dl
002355  aa  5 00006 7561 20	stq  	pr5|6,*
002356  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 378
		else return (0);

002357  aa  5 00006 4501 20	stz  	pr5|6,*
002360  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 379
	     end;

  END PROCEDURE order_entries
  END PROCEDURE hc_pf_meters


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
