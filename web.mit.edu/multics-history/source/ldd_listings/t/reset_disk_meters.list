	COMPILATION LISTING OF SEGMENT reset_disk_meters
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 04/26/88  1214.7 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(87-10-06,Parisek), approve(88-02-03,MCR7845),
       16*     audit(88-04-05,Lippard), install(88-04-26,MR12.2-1043):
       17*     Implement multi_segment file application for possible >256K disk_stat
       18*     segment.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 /* format: style5,ind5 */
       23 
       24 reset_disk_meters:
       25      procedure options (variable);
       26 
       27 /* This program reads the disk usage from "disk_stat" and subtracts the
       28*   value found with the specified directory's tpp.  It is run once a
       29*   month after disk usage has been billed. */
       30 
       31 /* Written by THVV.
       32*   Modified on 5 June 1975 by J. C. Whitmore to set system_privileges if possible
       33*   Modified April 1976 by T. Casey to reset directory page tpp as well as segent page tpp.
       34*   Modified 1985-02-20 by E. Swenson to work with the new directory control.
       35**/
       36 
       37      sp = null ();				      /* for cleanup handler */
       38      undop = null ();			      /* ditto */
       39      set_privileges = "0"b;			      /* ditto */
       40      forced_access = "0"b;			      /* we haven't yet */
       41      on condition (cleanup) call CLEAN_UP ();
       42 
       43      acla.userid = get_group_id_ ();
       44      dacl.userid = acla.userid;
       45      acla.mode = SMA_ACCESS;
       46      path = "disk_stat";			      /* Find the disk statistics file. */
       47 
       48      an = 0;				      /* set argument index to 0, initially */
       49      more_args = "1"b;			      /* initially */
       50      do while (more_args);
       51 	an = an + 1;			      /* bump argument number */
       52 	call cu_$arg_ptr (an, ap, al, ec);
       53 	if ec ^= 0 then
       54 	     more_args = "0"b;
       55 	else
       56 	     do;
       57 	     if bchr = "-brief" then
       58 		brief_sw = "1"b;
       59 	     else if bchr = "-bf" then
       60 		brief_sw = "1"b;
       61 	     else if substr (bchr, 1, 1) = "-" then
       62 		call com_err_ (error_table_$badopt, ME, "^a", bchr);
       63 	     else
       64 		path = bchr;
       65 	     end;
       66      end;
       67 
       68      ti = 0;
       69 
       70      call expand_pathname_ (path, dn, en, ec);
       71      if ec ^= 0 then
       72 	do;
       73 	call com_err_ (ec, ME, "^a", path);
       74 	return;
       75 	end;
       76 
       77      call msf_manager_$open (dn, en, fcbp, ec);	
       78      if ec ^= 0 then
       79 	do;
       80 	call com_err_ (ec, ME, "Cannot open msf.");
       81 	return;
       82 	end;
       83      acpx, cpx = 0;	
       84 cpx_loop:
       85      call msf_manager_$get_ptr (fcbp, cpx, "0"b, cp_array (cpx), 0, ec);
       86      if ec = 0 then do;
       87 	cpx = cpx + 1;
       88 	goto cpx_loop;
       89      end;
       90      
       91      working_dir = get_wdir_ ();
       92      call initiate_file_ (working_dir, "projfile", RW_ACCESS, pp, (0), ec);
       93      if ec ^= 0 then
       94 	do;
       95 	call com_err_ (ec, ME, "^a", pathname_ (working_dir, "projfile"));
       96 	call CLEAN_UP ();
       97 	return;
       98 	end;
       99 
      100      call get_temp_segment_ (ME, undop, ec);
      101      if ec ^= 0 then
      102 	do;
      103 	call com_err_ (ec, ME, "Getting temporary segment.");
      104 	call CLEAN_UP ();
      105 	return;
      106 	end;
      107 
      108      sp = cp_array (0);	
      109      n = disk_stat.dents;			      /* Get number of entries. */
      110 
      111      call check_gate_access_ ("system_privilege_", codeptr (reset_disk_meters),
      112          ec);
      113      if ec ^= 0 then
      114 	call com_err_ (ec, ME,
      115 	    "system_privilege_.  Cannot enable directory privileges.  Access to storage system may not be complete"
      116 	    );
      117      else
      118 	do;
      119 	call system_privilege_$dir_priv_on (priv_set_already);
      120 	if priv_set_already = 1 then
      121 	     set_privileges = "1"b;
      122 	end;
      123 
      124 
      125      call ioa_ ("^a: Resetting disk for ^d directories.", ME, n);
      126 
      127      last_n = n;
      128 comp_loop:
      129      do i = 1 to last_n;				/* Loop through all directories. */
      130 	dn = spth (i);				/* Get the name of the directory. */
      131 
      132 	call get_quota ("segment");
      133 	if code ^= 0 then
      134 	     xqta = 0;			      /* avoid trying to reset it */
      135 	call get_quota ("directory");
      136 	if code ^= 0 then
      137 	     dir_xqta = 0;			      /* avoid trying to reset it */
      138 
      139 	if xqta > 0 then
      140 	     call reset_quota ("segment", xtpp, disk_stat.stpp (i));
      141 	if dir_xqta > 0 then
      142 	     call reset_quota ("directory", dir_xtpp, disk_stat.dtpp (i));
      143 
      144 /**** The following call will terminate the specified directory in some
      145*      cases and is helpful in cleaning up the address space.  It is not
      146*      guaranteed to work in all cases, so we ignore the error code. */
      147 
      148 	call hcs_$terminate_file (dn, "", 0, (0));
      149 
      150 	if (lodh + (i+1) * lode) > sys_info$max_seg_size then do;
      151 	     ti = ti + i;		
      152 	     last_n = n - ti;
      153 	     acpx = acpx + 1;
      154 	     sp = cp_array (acpx);
      155 	     goto comp_loop;
      156 	end;
      157      end;
      158 
      159 /**** Now reset the field in the projfile which corresponds to disk
      160*      usage */
      161 
      162      do i = 1 to projfile.nproj;
      163 	projfile.projfiletab (i).disk_psec = 0;
      164      end;
      165 
      166      sp = cp_array (0);
      167      disk_stat.dreset = disk_stat.dtime;
      168      disk_stat.dtime = clock ();
      169 
      170      call ioa_ ("^a: Disk usage reset.", ME);
      171 
      172      call CLEAN_UP ();
      173      return;
      174 
      175 CLEAN_UP:
      176      procedure ();
      177 
      178      if set_privileges then
      179 	call system_privilege_$dir_priv_off ((0));
      180 
      181      if fcbp ^= null () then
      182 	call msf_manager_$close (fcbp);
      183 
      184      if sp ^= null () then sp = null ();
      185 
      186      if undop ^= null then
      187 	do;
      188 	if forced_access | (n_undo > 0) then
      189 	     do i = n_undo to 1 by -1;
      190 		call hcs_$delete_dir_acl_entries ((undo (i).dir),
      191 		    (undo (i).ent), addr (dacl), 1, code);
      192 		if code ^= 0 then
      193 		     call com_err_ (code, ME,
      194 		         "Could not reset access to ^a",
      195 		         pathname_ ((undo (i).dir), (undo (i).ent)));
      196 	     end;
      197 
      198 
      199 	call release_temp_segment_ (ME, undop, (0));
      200 	undop = null ();
      201 	end;
      202 
      203      return;
      204      end CLEAN_UP;
      205 
      206 get_quota:
      207      procedure (Seg_dir);
      208 
      209      dcl	   Seg_dir	       char (*) parameter;
      210 
      211      dcl	   i		       fixed bin (17);
      212      dcl	   try_again	       bit (1) aligned;
      213 
      214      try_again = "1"b;
      215      do i = 1 to 2 while (try_again);
      216 	if Seg_dir = "segment" then
      217 	     call hcs_$quota_read (dn, xqta, xtpp, (""b), (""b), (0), (0),
      218 	         code);
      219 	else
      220 	     call hcs_$dir_quota_read (dn, dir_xqta, dir_xtpp, (""b), (""b),
      221 	         (0), (0), code);
      222 	if code = 0 then
      223 	     try_again = "0"b;		      /* no need */
      224 	else if i = 1 then			      /* if we haven't tried to force access yet */
      225 	     do;
      226 	     call force_access (dn, code);
      227 	     if code ^= 0 then
      228 		try_again = "0"b;		      /* no sense */
      229 	     end;
      230      end;
      231 
      232      if code ^= 0 then
      233 	call com_err_ (code, ME, "Cannot get ^a quota for ^a", Seg_dir, dn);
      234      return;
      235 
      236      end get_quota;
      237 
      238 force_access:
      239      procedure (Dir, Code) recursive;
      240 
      241      dcl	   Dir		       char (168);
      242      dcl	   Code		       fixed bin (35);
      243 
      244      dcl	   td		       char (168);
      245      dcl	   te		       char (32);
      246      dcl	   i		       fixed bin;
      247      dcl	   j		       fixed bin;
      248      dcl	   try_again	       bit (1) aligned;
      249 
      250      if code ^= error_table_$moderr then
      251 	if code ^= error_table_$no_info then
      252 	     if code ^= error_table_$incorrect_access then
      253 		return;
      254 
      255      j = 168;
      256      do while (substr (Dir, j, 1) ^= ">");
      257 	j = j - 1;
      258      end;
      259 
      260      td = substr (Dir, 1, j - 1);
      261      te = substr (Dir, j + 1);
      262 
      263      n_undo = n_undo + 1;
      264      undo (n_undo).dir = td;
      265      undo (n_undo).ent = te;
      266 
      267      try_again = "1"b;
      268      if ^brief_sw then
      269 	call ioa_ ("^a: Now forcing access to ^a", ME, Dir);
      270      do i = 1 to 2 while (try_again);
      271 	call hcs_$add_dir_acl_entries (td, te, addr (acla), 1, code);
      272 	if code = 0 then
      273 	     do;
      274 	     if forced_access = "0"b then
      275 		forced_access = "1"b;
      276 	     try_again = "0"b;		      /* no need */
      277 	     end;
      278 	else
      279 	     do;				      /* could not set access */
      280 	     call force_access (td, code);	      /* recurse */
      281 	     if code ^= 0 then
      282 		try_again = "0"b;		      /* wouldn't do any good */
      283 	     end;
      284      end;
      285      end force_access;
      286 
      287 reset_quota:
      288      procedure (Seg_dir, Cur_tpp, Reset_tpp);
      289 
      290      dcl	   Seg_dir	       char (*) parameter;
      291      dcl	   Cur_tpp	       fixed bin (71) parameter;
      292      dcl	   Reset_tpp	       fixed bin (71) parameter;
      293 
      294      dcl	   i		       fixed bin;
      295      dcl	   try_again	       bit (1) aligned;
      296 
      297      if Cur_tpp < Reset_tpp then
      298 	if ^brief_sw then
      299 	     call com_err_ (0, ME,
      300 	         "^a would get negative ^a tpp ^.1f - ignored", dn, Seg_dir,
      301 	         (Cur_tpp - Reset_tpp) / 86400e0);
      302 	else
      303 	     ;
      304 
      305      else
      306 	do;
      307 	try_again = "1"b;
      308 	do i = 1 to 2 while (try_again);
      309 	     call RESET_TPP (Seg_dir, dn, Reset_tpp, code);
      310 	     if code = 0 then
      311 		try_again = "0"b;		      /* no need */
      312 	     else if i = 1 then		      /* if we haven't tried to force access yet */
      313 		do;
      314 		call force_access (dn, code);
      315 		if code ^= 0 then
      316 		     try_again = "0"b;	      /* no sense */
      317 		end;
      318 	end;
      319 
      320 	if code ^= 0 then
      321 	     call com_err_ (code, ME, "Cannot reset ^a tpp on ^a", Seg_dir,
      322 	         dn);
      323 	end;
      324      return;
      325 
      326      end reset_quota;
      327 
      328 RESET_TPP:
      329      procedure (Seg_dir, Dir_name, Reset_tpp, Code);
      330 
      331      dcl	   Seg_dir	       char (*) parameter;
      332      dcl	   Dir_name	       char (*) parameter;
      333      dcl	   Reset_tpp	       fixed bin (71) parameter;
      334      dcl	   Code		       fixed bin (35) parameter;
      335 
      336      if ^debugging then
      337 	do;
      338 	if Seg_dir = "segment" then
      339 	     call hphcs_$get_reset_quota (dn, Reset_tpp, Code);
      340 	else
      341 	     call hphcs_$dir_get_reset_quota (dn, Reset_tpp, Code);
      342 	end;
      343      else
      344 	Code = 0;
      345      return;
      346      end RESET_TPP;
      347 
      348 /* Declarations */
      349 
      350 /* Automatic */
      351 
      352      dcl     acpx                    fixed bin;         /* msf counter */
      353      dcl	   path		       char (168);
      354      dcl	   dn		       char (168);
      355      dcl	   en		       char (32);
      356      dcl	   ec		       fixed bin (35);    /* status code */
      357      dcl	   code		       fixed bin (35);    /* status code */
      358      dcl     cpx                     fixed bin;         /* msf counter */
      359      dcl     fcbp                    ptr;
      360      dcl	   ap		       ptr;	      /* argument pointer */
      361      dcl	   al		       fixed bin (21);    /* argument length */
      362      dcl	   brief_sw	       bit (1) aligned initial ("0"b);
      363      dcl	   an		       fixed bin;	      /* argument number */
      364      dcl	   pp		       ptr;	      /* pointer to projfile */
      365      dcl	   undop		       ptr;	      /* pointer to table of directories to undo access for */
      366      dcl	   xqta		       fixed bin (18);
      367      dcl	   dir_xqta	       fixed bin (18);
      368      dcl	   xtpp		       fixed bin (71);
      369      dcl	   dir_xtpp	       fixed bin (71);
      370      dcl	   i		       fixed bin;	      /* index */
      371      dcl	   n		       fixed bin;	      /* index */
      372      dcl	   set_privileges	       bit (1) aligned;
      373      dcl	   more_args	       bit (1) aligned;
      374      dcl	   priv_set_already	       fixed bin (35);
      375      dcl	   working_dir	       char (168);
      376      dcl	   forced_access	       bit (1) aligned;   /* whether we have or not */
      377      dcl     last_n                  fixed bin;
      378      dcl     ti                      fixed bin;
      379 
      380      dcl	   1 acla		       aligned,
      381 	     2 userid	       char (32),
      382 	     2 mode	       bit (36),
      383 	     2 rcode	       fixed bin (35);
      384 
      385      dcl	   1 dacl		       aligned,
      386 	     2 userid	       char (32),
      387 	     2 rcode	       fixed bin (35);
      388 
      389      dcl     cp_array                (0:4) ptr;
      390 
      391 
      392 /* Conditions */
      393 
      394      dcl	   cleanup	       condition;
      395 
      396 /* Based */
      397 
      398      dcl	   bchr		       char (al) based (ap) unaligned;
      399 					      /* argument */
      400      dcl	   1 undoseg	       based (undop) aligned,
      401 	     2 n_undo	       fixed bin,
      402 	     2 upad	       (7) fixed bin,
      403 	     2 undo	       (100),
      404 	       3 dir	       char (168),
      405 	       3 ent	       char (32);
      406 
      407 /* Builtin */
      408 
      409      dcl	   addr		       builtin;
      410      dcl	   clock		       builtin;
      411      dcl     codeptr                 builtin;
      412      dcl	   null		       builtin;
      413      dcl	   substr		       builtin;
      414 
      415 /* External */
      416 
      417      dcl	   error_table_$badopt     fixed bin (35) external;
      418      dcl	   error_table_$incorrect_access
      419 			       fixed bin (35) external;
      420      dcl	   error_table_$no_info    fixed bin (35) external;
      421      dcl	   error_table_$moderr     fixed bin (35) external;
      422 
      423      dcl     sys_info$max_seg_size   fixed bin (35) external static;
      424 
      425 /* Entries */
      426 
      427      dcl	   check_gate_access_      entry (char (*), ptr, fixed bin (35));
      428      dcl	   com_err_	       entry options (variable);
      429      dcl	   cu_$arg_ptr	       entry (fixed bin, ptr, fixed bin (21),
      430 			       fixed bin (35));
      431 
      432      dcl	   expand_pathname_	       entry (char (*), char (*), char (*),
      433 			       fixed bin (35));
      434 
      435      dcl	   get_group_id_	       entry returns (char (32) aligned);
      436      dcl	   get_temp_segment_       entry (char (*), ptr, fixed bin (35));
      437      dcl	   get_wdir_	       entry () returns (char (168));
      438      dcl	   hcs_$add_dir_acl_entries
      439 			       entry (char (*), char (*), ptr, fixed bin,
      440 			       fixed bin (35));
      441      dcl	   hcs_$delete_dir_acl_entries
      442 			       entry (char (*), char (*), ptr, fixed bin,
      443 			       fixed bin (35));
      444      dcl	   hcs_$quota_read	       entry (char (*), fixed bin (18),
      445 			       fixed bin (71), bit (36) aligned, bit (36),
      446 			       fixed bin (1), fixed bin (18),
      447 			       fixed bin (35));
      448      dcl	   hcs_$dir_quota_read     entry (char (*), fixed bin (18),
      449 			       fixed bin (71), bit (36) aligned, bit (36),
      450 			       fixed bin (1), fixed bin (18),
      451 			       fixed bin (35));
      452      dcl	   hcs_$terminate_file     entry (char (*), char (*), fixed bin (1),
      453 			       fixed bin (35));
      454      dcl	   hphcs_$get_reset_quota  entry (char (*), fixed bin (71),
      455 			       fixed bin (35));
      456      dcl	   hphcs_$dir_get_reset_quota
      457 			       entry (char (*), fixed bin (71),
      458 			       fixed bin (35));
      459      dcl	   initiate_file_	       entry (char (*), char (*), bit (*), ptr,
      460 			       fixed bin (24), fixed bin (35));
      461      dcl	   ioa_		       entry options (variable);
      462      dcl     msf_manager_$close      entry (ptr);
      463      dcl     msf_manager_$get_ptr    entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      464      dcl     msf_manager_$open       entry (char (*), char (*), ptr, fixed bin (35));
      465      dcl	   pathname_	       entry (char (*), char (*))
      466 			       returns (char (168));
      467      dcl	   release_temp_segment_   entry (char (*), ptr, fixed bin (35));
      468      dcl	   system_privilege_$dir_priv_on
      469 			       entry (fixed bin (35));
      470      dcl	   system_privilege_$dir_priv_off
      471 			       entry (fixed bin (35));
      472 
      473 /* Constants */
      474 
      475      dcl	   debugging	       bit (1) aligned initial ("0"b)
      476 			       internal static options (constant);
      477      dcl	   ME		       char (32)
      478 			       initial ("reset_disk_meters")
      479 			       internal static options (constant);
      480 
      481 /* format: off */
      482  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      482 
      483  /* BEGIN INCLUDE FILE ... disk_stat.incl.pl1 */
  2     2 
  2     3 /* This segment is created by "sweep" and read by "charge_disk" when disk stats are being charged. */
  2     4 /* Modified April 1976 by TAC to add dqta, duse, and dtpp */
  2     5 
  2     6 dcl  sp ptr;					/* pointer to segment */
  2     7 
  2     8 dcl 1 disk_stat based (sp) aligned,			/* structure of segment */
  2     9     2 dents fixed bin,				/* number of entries */
  2    10     2 dpad1 fixed bin,
  2    11     2 dtime fixed bin (71),				/* Time file was generated */
  2    12     2 dreset fixed bin (71),				/* Time of disk reset */
  2    13     2 dpad2 (2) fixed bin,
  2    14     2 dtab (1000),					/* one for each dir with a quota */
  2    15       3 spth char (168),				/* path name */
  2    16       3 sqta fixed bin,				/* segment quota */
  2    17       3 dqta fixed bin,				/* directory quota */
  2    18       3 suse fixed bin,				/* segment pages qued */
  2    19       3 duse fixed bin,				/* directory pages used */
  2    20       3 stpp fixed bin (71),				/* time-page product for segments */
  2    21       3 dtpp fixed bin (71),				/* time-page product for directories */
  2    22       3 slvid bit (36),				/* son's lvid of this dir */
  2    23       3 slev fixed bin;				/* recursion level */
  2    24 
  2    25 dcl  lodh fixed bin init (8),				/* lth of disk_stat head */
  2    26      lode fixed bin init (52);			/* lth of disk_stat entry */
  2    27 
  2    28 /* END INCLUDE FILE ... disk_stat.incl.pl1 */
      483 
      484  /* BEGIN INCLUDE FILE .. projfile.incl.pl1 */
  3     2 /* Modified by T. Casey April 1976 to change disk_infs (obsolete) to dir_disk_use */
  3     3 /* Modified 1984-07-09 BIM for dir_disk_quota, version */
  3     4 /* Modified 1984-09-14 BIM for reasonable array size */
  3     5 
  3     6 dcl 1 projfile based (pp) aligned,			/* Project history file */
  3     7     2 nproj fixed bin (35),				/* number of entries */
  3     8     2 version fixed bin,
  3     9     2 projfilexx0 (6) bit (36) aligned,
  3    10     2 projfiletab (3000),				/* in seg limit */
  3    11       3 id char (12) unal,				/* project ID */
  3    12       3 title char (52) unal,				/* project title */
  3    13       3 inv char (32) unal,				/* name of principal investigator */
  3    14       3 inv_addr char (32) unal,			/* address */
  3    15       3 sup char (32) unal,				/* name of supervisor */
  3    16       3 sup_addr char (32) unal,			/* address */
  3    17       3 sup_phone char (16) unal,			/* telephone */
  3    18       3 on fixed bin (71),				/* date on */
  3    19       3 off fixed bin (71),				/* date off */
  3    20       3 disk_psec fixed bin (71),			/* project disk page-seconds */
  3    21       3 disk_quota fixed bin (35),			/* project disk quota */
  3    22       3 dir_disk_quota fixed bin (35),			/* project dir disk quota */
  3    23       3 disk_use fixed bin (35),			/* total segment pages used */
  3    24       3 dir_disk_use fixed bin (35),			/* total directory pages used */
  3    25       3 misc_charges float bin,			/* manuals, etc */
  3    26       3 n_misc fixed bin,				/* number of entries */
  3    27       3 processed fixed bin,				/* temp for usage-report */
  3    28       3 pad bit (36) aligned;				/* out to even number of words */
  3    29 
  3    30 dcl  loph int static fixed bin (17) options (constant) init (8), /* lth of projfile header */
  3    31      lope int static fixed bin (17) options (constant) init (66); /* lth of projflile entry */
  3    32 
  3    33 dcl PROJFILE_VERSION fixed bin init (3) int static options (constant);
  3    34 
  3    35 /* END INCLUDE FILE ... projfile.incl.pl1 */
      484 
      485 /* format: on */
      486 
      487      end reset_disk_meters;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/26/88  1214.7  reset_disk_meters.pl1             >spec>install>1043>reset_disk_meters.pl1
482          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
483          2    06/22/76  1355.6  disk_stat.incl.pl1                >ldd>include>disk_stat.incl.pl1
484          3    09/20/84  0925.7  projfile.incl.pl1                 >ldd>include>projfile.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Code                                   parameter       fixed bin(35,0)          dcl 334 in procedure "RESET_TPP" set ref 328 338*
                                                                                  340* 343*
Code                                   parameter       fixed bin(35,0)          dcl 242 in procedure "force_access" ref 238
Cur_tpp                                parameter       fixed bin(71,0)          dcl 291 ref 287 297 297
Dir                                    parameter       char(168)                packed unaligned dcl 241 set ref 238 256 260 261
                                                                                  268*
Dir_name                               parameter       char                     packed unaligned dcl 332 ref 328
ME                              000001 constant        char(32)                 initial packed unaligned dcl 477 set ref 61* 73* 80*
                                                                                  95* 100* 103* 113* 125* 170* 192* 199* 232* 268*
                                                                                  297* 320*
RW_ACCESS                       000000 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 92*
Reset_tpp                              parameter       fixed bin(71,0)          dcl 333 in procedure "RESET_TPP" set ref 328 338*
                                                                                  340*
Reset_tpp                              parameter       fixed bin(71,0)          dcl 292 in procedure "reset_quota" set ref 287 297
                                                                                  297 309*
SMA_ACCESS                             constant        bit(3)                   initial packed unaligned dcl 1-11 ref 45
Seg_dir                                parameter       char                     packed unaligned dcl 209 in procedure "get_quota"
                                                                                  set ref 206 216 232*
Seg_dir                                parameter       char                     packed unaligned dcl 290 in procedure "reset_quota"
                                                                                  set ref 287 297* 309* 320*
Seg_dir                                parameter       char                     packed unaligned dcl 331 in procedure "RESET_TPP"
                                                                                  ref 328 338
acla                            000344 automatic       structure                level 1 dcl 380 set ref 271 271
acpx                            000100 automatic       fixed bin(17,0)          dcl 352 set ref 83* 153* 153 154
addr                                                   builtin function         dcl 409 ref 190 190 271 271
al                              000244 automatic       fixed bin(21,0)          dcl 361 set ref 52* 57 59 61 61 61 63
an                              000246 automatic       fixed bin(17,0)          dcl 363 set ref 48* 51* 51 52*
ap                              000242 automatic       pointer                  dcl 360 set ref 52* 57 59 61 61 63
bchr                                   based           char                     packed unaligned dcl 398 set ref 57 59 61 61* 63
brief_sw                        000245 automatic       bit(1)                   initial dcl 362 set ref 57* 59* 268 297 362*
check_gate_access_              000022 constant        entry                    external dcl 427 ref 111
cleanup                         000402 stack reference condition                dcl 394 ref 41
clock                                                  builtin function         dcl 410 ref 168
code                            000236 automatic       fixed bin(35,0)          dcl 357 set ref 133 136 190* 192 192* 216* 219* 222
                                                                                  226* 227 232 232* 250 250 250 271* 272 280* 281
                                                                                  309* 310 314* 315 320 320*
codeptr                                                builtin function         dcl 411 ref 111 111
com_err_                        000024 constant        entry                    external dcl 428 ref 61 73 80 95 103 113 192 232 297
                                                                                  320
cp_array                        000370 automatic       pointer                  array dcl 389 set ref 84* 108 154 166
cpx                             000237 automatic       fixed bin(17,0)          dcl 358 set ref 83* 84* 84 87* 87
cu_$arg_ptr                     000026 constant        entry                    external dcl 429 ref 52
dacl                            000356 automatic       structure                level 1 dcl 385 set ref 190 190
debugging                              constant        bit(1)                   initial dcl 475 ref 336
dents                                  based           fixed bin(17,0)          level 2 dcl 2-8 ref 109
dir                      10            based           char(168)                array level 3 dcl 400 set ref 190 192 192 264*
dir_xqta                        000255 automatic       fixed bin(18,0)          dcl 367 set ref 136* 141 219*
dir_xtpp                        000260 automatic       fixed bin(71,0)          dcl 369 set ref 141* 219*
disk_psec               100            based           fixed bin(71,0)          array level 3 dcl 3-6 set ref 163*
disk_stat                              based           structure                level 1 dcl 2-8
dn                              000153 automatic       char(168)                packed unaligned dcl 354 set ref 70* 77* 130* 148*
                                                                                  216* 219* 226* 232* 297* 309* 314* 320* 338* 340*
dreset                    4            based           fixed bin(71,0)          level 2 dcl 2-8 set ref 167*
dtab                     10            based           structure                array level 2 dcl 2-8
dtime                     2            based           fixed bin(71,0)          level 2 dcl 2-8 set ref 167 168*
dtpp                     70            based           fixed bin(71,0)          array level 3 dcl 2-8 set ref 141*
ec                              000235 automatic       fixed bin(35,0)          dcl 356 set ref 52* 53 70* 71 73* 77* 78 80* 84* 86
                                                                                  92* 93 95* 100* 101 103* 111* 113 113*
en                              000225 automatic       char(32)                 packed unaligned dcl 355 set ref 70* 77*
ent                      62            based           char(32)                 array level 3 dcl 400 set ref 190 192 192 265*
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 417 set ref 61*
error_table_$incorrect_access   000012 external static fixed bin(35,0)          dcl 418 ref 250
error_table_$moderr             000016 external static fixed bin(35,0)          dcl 421 ref 250
error_table_$no_info            000014 external static fixed bin(35,0)          dcl 420 ref 250
expand_pathname_                000030 constant        entry                    external dcl 432 ref 70
fcbp                            000240 automatic       pointer                  dcl 359 set ref 77* 84* 181 181*
forced_access                   000341 automatic       bit(1)                   dcl 376 set ref 40* 188 274 274*
get_group_id_                   000032 constant        entry                    external dcl 435 ref 43
get_temp_segment_               000034 constant        entry                    external dcl 436 ref 100
get_wdir_                       000036 constant        entry                    external dcl 437 ref 91
hcs_$add_dir_acl_entries        000040 constant        entry                    external dcl 438 ref 271
hcs_$delete_dir_acl_entries     000042 constant        entry                    external dcl 441 ref 190
hcs_$dir_quota_read             000046 constant        entry                    external dcl 448 ref 219
hcs_$quota_read                 000044 constant        entry                    external dcl 444 ref 216
hcs_$terminate_file             000050 constant        entry                    external dcl 452 ref 148
hphcs_$dir_get_reset_quota      000054 constant        entry                    external dcl 456 ref 340
hphcs_$get_reset_quota          000052 constant        entry                    external dcl 454 ref 338
i                               000262 automatic       fixed bin(17,0)          dcl 370 in procedure "reset_disk_meters" set ref
                                                                                  128* 130 139 141 150 151* 162* 163* 188* 190 190
                                                                                  192 192 192 192*
i                               000434 automatic       fixed bin(17,0)          dcl 294 in procedure "reset_quota" set ref 308* 312*
i                               000424 automatic       fixed bin(17,0)          dcl 211 in procedure "get_quota" set ref 215* 224*
i                               000162 automatic       fixed bin(17,0)          dcl 246 in procedure "force_access" set ref 270*
initiate_file_                  000056 constant        entry                    external dcl 459 ref 92
ioa_                            000060 constant        entry                    external dcl 461 ref 125 170 268
j                               000163 automatic       fixed bin(17,0)          dcl 247 set ref 255* 256 257* 257 260 261
last_n                          000342 automatic       fixed bin(17,0)          dcl 377 set ref 127* 128 152*
lode                            000413 automatic       fixed bin(17,0)          initial dcl 2-25 set ref 150 2-25*
lodh                            000412 automatic       fixed bin(17,0)          initial dcl 2-25 set ref 150 2-25*
mode                     10     000344 automatic       bit(36)                  level 2 dcl 380 set ref 45*
more_args                       000265 automatic       bit(1)                   dcl 373 set ref 49* 50 53*
msf_manager_$close              000062 constant        entry                    external dcl 462 ref 181
msf_manager_$get_ptr            000064 constant        entry                    external dcl 463 ref 84
msf_manager_$open               000066 constant        entry                    external dcl 464 ref 77
n                               000263 automatic       fixed bin(17,0)          dcl 371 set ref 109* 125* 127 152
n_undo                                 based           fixed bin(17,0)          level 2 dcl 400 set ref 188 188 263* 263 264 265
nproj                                  based           fixed bin(35,0)          level 2 dcl 3-6 ref 162
null                                                   builtin function         dcl 412 ref 37 38 181 184 184 186 200
path                            000101 automatic       char(168)                packed unaligned dcl 353 set ref 46* 63* 70* 73*
pathname_                       000070 constant        entry                    external dcl 465 ref 95 95 192 192
pp                              000250 automatic       pointer                  dcl 364 set ref 92* 162 163
priv_set_already                000266 automatic       fixed bin(35,0)          dcl 374 set ref 119* 120
projfile                               based           structure                level 1 dcl 3-6
projfiletab              10            based           structure                array level 2 dcl 3-6
release_temp_segment_           000072 constant        entry                    external dcl 467 ref 199
set_privileges                  000264 automatic       bit(1)                   dcl 372 set ref 39* 120* 178
sp                              000410 automatic       pointer                  dcl 2-6 set ref 37* 108* 109 130 139 141 154* 166*
                                                                                  167 167 168 184 184*
spth                     10            based           char(168)                array level 3 dcl 2-8 ref 130
stpp                     66            based           fixed bin(71,0)          array level 3 dcl 2-8 set ref 139*
substr                                                 builtin function         dcl 413 ref 61 256 260 261
sys_info$max_seg_size           000020 external static fixed bin(35,0)          dcl 423 ref 150
system_privilege_$dir_priv_off  000076 constant        entry                    external dcl 470 ref 178
system_privilege_$dir_priv_on   000074 constant        entry                    external dcl 468 ref 119
td                              000100 automatic       char(168)                packed unaligned dcl 244 set ref 260* 264 271* 280*
te                              000152 automatic       char(32)                 packed unaligned dcl 245 set ref 261* 265 271*
ti                              000343 automatic       fixed bin(17,0)          dcl 378 set ref 68* 151* 151 152
try_again                       000164 automatic       bit(1)                   dcl 248 in procedure "force_access" set ref 267* 270
                                                                                  276* 281*
try_again                       000425 automatic       bit(1)                   dcl 212 in procedure "get_quota" set ref 214* 215
                                                                                  222* 227*
try_again                       000435 automatic       bit(1)                   dcl 295 in procedure "reset_quota" set ref 307* 308
                                                                                  310* 315*
undo                     10            based           structure                array level 2 dcl 400
undop                           000252 automatic       pointer                  dcl 365 set ref 38* 100* 186 188 188 190 190 192 192
                                                                                  192 192 199* 200* 263 263 264 264 265 265
undoseg                                based           structure                level 1 dcl 400
userid                          000344 automatic       char(32)                 level 2 in structure "acla" dcl 380 in procedure
                                                                                  "reset_disk_meters" set ref 43* 44
userid                          000356 automatic       char(32)                 level 2 in structure "dacl" dcl 385 in procedure
                                                                                  "reset_disk_meters" set ref 44*
working_dir                     000267 automatic       char(168)                packed unaligned dcl 375 set ref 91* 92* 95* 95*
xqta                            000254 automatic       fixed bin(18,0)          dcl 366 set ref 133* 139 216*
xtpp                            000256 automatic       fixed bin(71,0)          dcl 368 set ref 139* 216*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PROJFILE_VERSION                       internal static fixed bin(17,0)          initial dcl 3-33
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
lope                                   internal static fixed bin(17,0)          initial dcl 3-30
loph                                   internal static fixed bin(17,0)          initial dcl 3-30

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEAN_UP                        001421 constant        entry                    internal dcl 175 ref 41 96 104 172
RESET_TPP                       002562 constant        entry                    internal dcl 328 ref 309
comp_loop                       001152 constant        label                    dcl 128 ref 155
cpx_loop                        000567 constant        label                    dcl 84 ref 88
force_access                    002133 constant        entry                    internal dcl 238 ref 226 280 314
get_quota                       001673 constant        entry                    internal dcl 206 ref 132 135
reset_disk_meters               000236 constant        entry                    external dcl 24 ref 111 111
reset_quota                     002343 constant        entry                    internal dcl 287 ref 139 141

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3266        3366    2676        3276
Length      3666    2676       100         264     367           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
reset_disk_meters                   516 external procedure  is an external procedure.  
on unit on line 41                   64 on unit               
CLEAN_UP                            200 internal procedure  is called by several nonquick procedures.  
get_quota                               internal procedure  shares stack frame of external procedure reset_disk_meters.  
force_access                        164 internal procedure  calls itself recursively.  
reset_quota                             internal procedure  shares stack frame of external procedure reset_disk_meters.  
RESET_TPP                               internal procedure  shares stack frame of external procedure reset_disk_meters.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
force_access             000100 td                          force_access
                         000152 te                          force_access
                         000162 i                           force_access
                         000163 j                           force_access
                         000164 try_again                   force_access
reset_disk_meters        000100 acpx                        reset_disk_meters
                         000101 path                        reset_disk_meters
                         000153 dn                          reset_disk_meters
                         000225 en                          reset_disk_meters
                         000235 ec                          reset_disk_meters
                         000236 code                        reset_disk_meters
                         000237 cpx                         reset_disk_meters
                         000240 fcbp                        reset_disk_meters
                         000242 ap                          reset_disk_meters
                         000244 al                          reset_disk_meters
                         000245 brief_sw                    reset_disk_meters
                         000246 an                          reset_disk_meters
                         000250 pp                          reset_disk_meters
                         000252 undop                       reset_disk_meters
                         000254 xqta                        reset_disk_meters
                         000255 dir_xqta                    reset_disk_meters
                         000256 xtpp                        reset_disk_meters
                         000260 dir_xtpp                    reset_disk_meters
                         000262 i                           reset_disk_meters
                         000263 n                           reset_disk_meters
                         000264 set_privileges              reset_disk_meters
                         000265 more_args                   reset_disk_meters
                         000266 priv_set_already            reset_disk_meters
                         000267 working_dir                 reset_disk_meters
                         000341 forced_access               reset_disk_meters
                         000342 last_n                      reset_disk_meters
                         000343 ti                          reset_disk_meters
                         000344 acla                        reset_disk_meters
                         000356 dacl                        reset_disk_meters
                         000370 cp_array                    reset_disk_meters
                         000410 sp                          reset_disk_meters
                         000412 lodh                        reset_disk_meters
                         000413 lode                        reset_disk_meters
                         000424 i                           get_quota
                         000425 try_again                   get_quota
                         000434 i                           reset_quota
                         000435 try_again                   reset_quota

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_gate_access_            com_err_                      cu_$arg_ptr                   expand_pathname_
get_group_id_                 get_temp_segment_             get_wdir_                     hcs_$add_dir_acl_entries
hcs_$delete_dir_acl_entries   hcs_$dir_quota_read           hcs_$quota_read               hcs_$terminate_file
hphcs_$dir_get_reset_quota    hphcs_$get_reset_quota        initiate_file_                ioa_
msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open             pathname_
release_temp_segment_         system_privilege_$dir_priv_off                              system_privilege_$dir_priv_on

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$incorrect_access error_table_$moderr           error_table_$no_info
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000235       362 000243    2   25 000244        37 000250        38 000252        39 000253        40 000254
     41 000255        43 000277        44 000306        45 000311        46 000313        48 000316        49 000317
     50 000321        51 000324        52 000325        53 000342        57 000346        59 000357        61 000366
     63 000425        66 000430        68 000431        70 000432        71 000456        73 000460        74 000507
     77 000510        78 000535        80 000537        81 000564        83 000565        84 000567        86 000615
     87 000617        88 000620        91 000621        92 000630        93 000670        95 000672        96 000743
     97 000747       100 000750       101 000771       103 000773       104 001017       105 001023       108 001024
    109 001026       111 001030       113 001061       119 001110       120 001117       125 001124       127 001150
    128 001152       130 001161       132 001167       133 001174       135 001177       136 001206       139 001211
    141 001237       148 001267       150 001316       151 001330       152 001332       153 001335       154 001336
    155 001342       157 001343       162 001345       163 001355       164 001362       166 001364       167 001366
    168 001370       170 001373       172 001413       173 001417       175 001420       178 001426       181 001440
    184 001454       186 001463       188 001467       190 001502       192 001551       196 001641       199 001645
    200 001667       203 001672       206 001673       214 001704       215 001706       216 001715       219 001775
    222 002045       224 002051       226 002054       227 002064       230 002067       232 002071       234 002131
    238 002132       250 002140       255 002150       256 002152       257 002161       258 002163       260 002164
    261 002171       263 002176       264 002200       265 002207       267 002213       268 002215       270 002243
    271 002253       272 002312       274 002315       276 002321       277 002322       280 002323       281 002334
    284 002340       285 002342       287 002343       297 002354       302 002434       307 002435       308 002437
    309 002447       310 002475       312 002501       314 002504       315 002514       318 002517       320 002521
    324 002561       328 002562       336 002600       338 002602       340 002633       342 002654       343 002655
    345 002657


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
