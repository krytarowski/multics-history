	COMPILATION LISTING OF SEGMENT multics_library_search_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/10/84  1006.1 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* Modified 10/11/83 by Jim Lippard to remove references to sys_dates_ */
       11 /* Modified 03/05/84 by Jim Lippard to return error_table_$logical_volume_not_connected			*/
       12 
       13 multics_library_search_:	procedure options(rename((alloc_,smart_alloc_)));
       14 
       15      dcl						/* 		parameters		*/
       16 /*	Pnode			ptr,		/* ptr to node to be examined/searched. (In)	*/
       17 	path			char(168) varying;	/* path name of this node. (In)		*/
  1     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures for the arrays of library names and search*/
  1     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  1     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  1    10 	/* to the lib_descriptor_ subroutine.						*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  1    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  1    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  1    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  1    18 	/*									*/
  1    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    20 
  1    21 
  1    22      dcl	1 library			aligned based (Plibrary),
  1    23 						/* a structure containing names of libraries to	*/
  1    24 						/*   be searched.				*/
  1    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  1    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  1    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  1    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  1    30 						/*     this library name.			*/
  1    31 
  1    32      dcl	1 starname		aligned based (Pstarname),
  1    33 						/* a structure containing names of library entries*/
  1    34 						/*   being searched for.			*/
  1    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  1    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  1    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  1    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    39 						/*     this starname.			*/
  1    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  1    41 
  1    42      dcl	1 exclude			aligned based (Pexclude),
  1    43 						/* a structure containing names of library entries*/
  1    44 						/*   being excluded from the search.		*/
  1    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  1    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  1    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  1    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    49 						/*     this exclude.			*/
  1    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  1    51 
  1    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       18 
       19      dcl	APstarname		ptr,		/* ptr to input starnames. (In)		*/
       20 	APexclude			ptr,		/* ptr to input exclude search names. (In)	*/
       21 	ASrequirements		bit(72) aligned,	/* requirements bits. (In)			*/
       22 	AScontrol			bit(36) aligned,	/* control bits.				*/
       23 	tree_level		fixed bin,	/* depth of our node in the tree. (In)		*/
       24 	link_level		fixed bin,	/* number of links chased from last non-link node	*/
       25 						/*    to reach our node. (In)			*/
       26 	Parea			ptr,		/* ptr to an allocation area.			*/
       27 	Adirector			entry (ptr, char(168) varying, ptr, bit(72) aligned,
       28 				       bit(36) aligned, fixed bin, fixed bin, ptr, entry, ptr, ptr,
       29 				       fixed bin(35)) variable,
       30 						/* entry point where our search proc entered.(In)	*/
       31 	PA			ptr,		/* ptr to our control argument struc. (In)	*/
       32 	PA_saved			ptr,		/* saved copy of PA so we can return info to caller */
       33 /*	PDnodes			ptr,		/* ptr to descendant nodes of input node. (Out)	*/
       34 	Acode			fixed bin(35);	/* a status code. (Out)			*/
       35 
       36      dcl						/*		automatic variables		*/
       37 	Soutputable		bit(1) aligned,	/* on if an MSF node is outputable.		*/
       38 	1 auto_star		structure,	/* a star name temporary.			*/
       39 	  2 N			fixed bin,
       40 	  2 V			char(32),
       41 	  2 C			fixed bin(35),
       42 	code			fixed bin(35),	/* a status code.				*/
       43          (max_Scontrol, min_Scontrol)	bit(36) aligned,	/* max/min control bits.			*/
       44 	1 director_args,				/* our control argument structure.		*/
       45 	  2 command		fixed bin,	/*    command index.			*/
       46 						/*      1 = library_info			*/
       47 						/*      2 = library_map			*/
       48 						/*      3 = library_print			*/
       49 	  2 n_found		fixed bin,	/*    = number of entries found		*/
       50 	  2 Pstar			ptr,		/*    = addr (starname) at level 1.		*/
       51 	  2 Sreq			bit(72) aligned,	/*    = ASrequirements at level 1.		*/
       52 	  2 Scontrol		bit(36) aligned,	/*    = AScontrol at level 1.			*/
       53 	  2 search_type		fixed bin,	/*    type of search being performed.		*/
       54 						/*      1 = online directories.		*/
       55 						/*      2 = hardcore directories.		*/
       56          (i, j)			fixed bin,	/* a do-group index.			*/
       57 	search_type		fixed bin;	/* type of search being performed, as specified	*/
       58 						/*    in director_args.search_type.		*/
       59 
       60      dcl						/*		based variables		*/
       61 	1 A			like director_args based (PA);
       62 						/* our control argument structure.		*/
       63 
       64      dcl						/*		builtin functions		*/
       65          (addr, index, mod, null, reverse, string, substr)
       66 				builtin;
       67 
       68      dcl						/*		entry constants		*/
       69 	get_ring_			entry returns (fixed bin(6)),
       70 	lib_free_node_$array	entry (ptr),
       71 	lib_get_tree_		entry (ptr, char(168) varying, ptr, ptr, bit(72) aligned,
       72 				       bit(36) aligned, fixed bin, fixed bin, ptr, entry, ptr, ptr,
       73 				       fixed bin(35)),
       74 	match_star_name_		entry (char(*), char(*), fixed bin(35));
       75 
       76      dcl						/*		static variables		*/
       77 	Sinit			bit(1) aligned int static init ("1"b),
       78 						/* switch:  on if requirements must be inited.	*/
       79 	max_Srequirements (1:5)	bit(72) aligned int static,
       80          (max_cleanup_Scontrol,
       81 	min_cleanup_Scontrol)	bit(36) aligned int static,
       82          (max_exec_Scontrol,
       83 	max_list_info_Scontrol,
       84 	max_object_Scontrol,
       85 	max_source_Scontrol,
       86 	min_exec_Scontrol,
       87 	min_list_info_Scontrol,
       88 	min_object_Scontrol,
       89 	min_source_Scontrol) (1:4)
       90 				bit(36) aligned int static,
       91          (Sreq_archive_comp_parent,
       92 	Sreq_archive_comp_no_parent,
       93 	Sreq_msf_comp,
       94 	Sreq_link,
       95 	Sreq_offline_seg,
       96 	Sreq_seg) (1:5)
       97 				bit(72) aligned int static,
       98          (error_table_$logical_volume_not_connected,
       99 	error_table_$nomatch,
      100 	error_table_$process_stopped,
      101 	error_table_$undefined_order_request)
      102 				fixed bin(35) ext static,
      103 	ring			fixed bin(6) int static,
      104 	1 starstar		int static options(constant),
      105 	  2 N			fixed bin init(1),	/* starname structure for a star name of "**".	*/
      106 	  2 V			char(32) init ("**"),
      107 	  2 C			fixed bin(35) init (2);
      108 
      109 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      110 
      111 
      112 offline_execution_dirs:
      113 online_execution_dirs:
      114 execution_dirs: entry (Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      115 			link_level, Parea, Adirector, PA, PDnodes, Acode);
      116 
      117 	Scontrol = AScontrol;
      118 	if Sc.first_match & A.n_found > 0 then go to reject;
      119 	go to execdir(A.command * 10 + tree_level);
      120 
      121 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      122 
      123 
      124 offline_list_info_dirs:
      125 online_list_info_dirs:
      126 list_info_dirs: entry (Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      127 			link_level, Parea, Adirector, PA, PDnodes, Acode);
      128 
      129 	Scontrol = AScontrol;
      130 	if Sc.first_match & A.n_found > 0 then go to reject;
      131 	go to lsinfodir(A.command * 10 + tree_level);
      132 
      133 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      134 
      135 
      136 offline_object_dirs:
      137 online_object_dirs:
      138 object_dirs: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      139 			 link_level, Parea, Adirector, PA, PDnodes, Acode);
      140 
      141 	Scontrol = AScontrol;
      142 	if Sc.first_match & A.n_found > 0 then go to reject;
      143 	go to objdir(A.command * 10 + tree_level);
      144 
      145 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      146 
      147 
      148 offline_source_dirs:
      149 online_source_dirs:
      150 source_dirs: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      151 			 link_level, Parea, Adirector, PA, PDnodes, Acode);
      152 
      153 	Scontrol = AScontrol;
      154 	if Sc.first_match & A.n_found > 0 then go to reject;
      155 	go to searchdir(A.command * 10 + tree_level);
      156 
      157 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      158 
      159 execdir(11):					/* library_info,  level 1:  execution dirs.	*/
      160 execdir(21):					/* library_map,   level 1:  execution dirs.	*/
      161 execdir(31):					/* library_print, level 1:  execution dirs.	*/
      162 execdir(41):					/* library_fetch, level 1:  execution dirs.	*/
      163 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      164 	min_Scontrol = min_exec_Scontrol(A.command);	/* set up control info.			*/
      165 	max_Scontrol = max_exec_Scontrol(A.command);
      166 	go to online_level_1;
      167 
      168 
      169 lsinfodir(11):					/* library_info,  level 1:  list/info dirs.	*/
      170 lsinfodir(21):					/* library_map,   level 1:  list/info dirs.	*/
      171 lsinfodir(31):					/* library_print, level 1:  list/info dirs.	*/
      172 lsinfodir(41):					/* library_fetch, level 1:  list/info dirs.	*/
      173 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      174 	min_Scontrol = min_list_info_Scontrol(A.command);	/* set up control info.			*/
      175 	max_Scontrol = max_list_info_Scontrol(A.command);
      176 	go to online_level_1;
      177 
      178 
      179 objdir(11):					/* library_info,  level 1:  object dirs.	*/
      180 objdir(21):					/* library_map,   level 1:  object dirs.	*/
      181 objdir(31):					/* library_print, level 1:  object dirs.	*/
      182 objdir(41):					/* library_fetch, level 1:  object dirs.	*/
      183 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      184 	min_Scontrol = min_object_Scontrol(A.command);	/* set up control info.			*/
      185 	max_Scontrol = max_object_Scontrol(A.command);
      186 	go to online_level_1;
      187 
      188 
      189 searchdir(11):					/* library_info,  level 1:  source dirs.	*/
      190 searchdir(21):					/* library_map,   level 1:  source dirs.	*/
      191 searchdir(31):					/* library_print, level 1:  source dirs.	*/
      192 searchdir(41):					/* library_fetch, level 1:  source dirs.	*/
      193 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      194 	min_Scontrol = min_source_Scontrol(A.command);	/* set up control info.			*/
      195 	max_Scontrol = max_source_Scontrol(A.command);
      196 	go to online_level_1;
      197 
      198 
      199 
      200 online_level_1:
      201 	if node.T ^= Tdirectory then go to reject;	/* accept only directories as root nodes.	*/
      202 	search_type = 1;
      203 	call set_director_args (min_Scontrol, max_Scontrol, search_type);
      204 						/* set up complete director control arguments.	*/
      205 	node.Sreq = ""b;				/* output nothing about root directory.		*/
      206 	call next_tree_level (Sreq_seg(A.command), reject);
      207 						/* apply segment default requirements when	*/
      208 						/*    getting the next level of the tree, and	*/
      209 						/*    reject the directory root node of the tree	*/
      210 						/*    if no matching library entries were found	*/
      211 						/*    in that directory.			*/
      212 	PA = PA_saved;
      213 	A.n_found = director_args.n_found;
      214 	go to return;
      215 
      216 execdir(12):					/* library_info,  level 2:  exec ents.		*/
      217 lsinfodir(12):					/* library_info,  level 2:  list/info ents.	*/
      218 objdir(12):					/* library_info,  level 2:  object ents.	*/
      219 searchdir(12):					/* library_info,  level 2:  source ents.	*/
      220 execdir(22):					/* library_map,   level 2:  exec ents.		*/
      221 lsinfodir(22):					/* library_map,   level 2:  list/info ents.	*/
      222 objdir(22):					/* library_map,   level 2:  object ents.	*/
      223 searchdir(22):					/* library_map,   level 2:  source ents.	*/
      224 	Scontrol = A.Scontrol;
      225 	if Sc.retain then;				/* eliminate nodes for library entries awaiting	*/
      226 	else call reject_node_if_obsolete();		/*    deletion.				*/
      227 	if node.Pparent -> node.T = Tlink then		/* mark first name of link target as outputable.	*/
      228 	     Sreq.primary_name = "1"b;
      229 	if node.T = Tsegment			/* for segments:				*/
      230 	     then ;
      231 	else if node.T = Tlink then do;		/* for links:				*/
      232 	     if Sc.default then			/*    add further default requirements to link.	*/
      233 		node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
      234 	     call next_tree_level ((ASrequirements), return);
      235 	     end;
      236 	else if node.T = Tarchive then do;		/* for archives:				*/
      237 	     if Sc.components then
      238 		Pstarname = addr(starstar);		/*    tell about all archive components.	*/
      239 	     else Pstarname = A.Pstar;
      240 	     Srequirements = A.Sreq;
      241 	     if Sc.default then
      242 		if Sc.container then		/*    say little about archive component if we	*/
      243 		     Srequirements = Srequirements | Sreq_archive_comp_parent(A.command);
      244 		else				/*    we are already given that info about parent.*/
      245 		     Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
      246 	     call next_tree_level_special (suppress_nomatch);
      247 	     Sreq.cross_ref = "0"b;			/*  do not cross-reference archive names.	*/
      248 	     if Sc.container then do;			/* say nothing about added names on parent archive*/
      249 						/*   when all comps being listed unless asked.	*/
      250 		Srequirements = A.Sreq;
      251 		Pstarname = A.Pstar;
      252 		if starname(1).C = 2 then do;		/* User is listing all comps in all archives.	*/
      253 		     Sreq.names = S.names;		/*   Give only names explicitly reqd (non-default)*/
      254 		     Sreq.matching_names = S.matching_names;
      255 		     Sreq.primary_name = "1"b;	/*   But always return first name.		*/
      256 		     end;
      257 		else if Sc.components then		/* User listing all comps of one archive.	*/
      258 		     Sreq.names = S.names;		/*   Only give all names if explicitly asked for.	*/
      259 		end;
      260 	     else if Sc.components & (A.command ^= library_info) then
      261 		if Sc.default then do;
      262 		     Srequirements = A.Sreq;
      263 		     Sreq.names = S.names;
      264 		     Sreq.matching_names = S.matching_names;
      265 		     end;
      266 		else;
      267 	     else					/* if user didn't ask about parent archive,	*/
      268 		node.Sreq = ""b;			/*    then mum's the word.			*/
      269 	     end;
      270 	else if node.T = Tmsf then			/* for msfs:				*/
      271 	     call next_tree_level (Sreq_msf_comp(A.command), return);
      272 	else go to reject;				/* reject all other node types.		*/
      273 	go to return;
      274 
      275 
      276 execdir(13):					/* library_info,  level 3:  exec comps.		*/
      277 lsinfodir(13):					/* library_info,  level 3:  list/info comp?	*/
      278 objdir(13):					/* library_info,  level 3:  object comps.	*/
      279 searchdir(13):					/* library_info,  level 3:  source comps.	*/
      280 execdir(23):					/* library_map,   level 3:  exec comps.		*/
      281 lsinfodir(23):					/* library_map,   level 3:  list/info comp?	*/
      282 objdir(23):					/* library_map,   level 3:  object comps.	*/
      283 searchdir(23):					/* library_map,   level 3:  source comps.	*/
      284 	Scontrol = A.Scontrol;
      285 	Sreq.names = "1"b;				/* must always require that names of things	*/
      286 						/*   at this level be output, so that when -match	*/
      287 						/*   is specified, archive and MSF component names*/
      288 						/*   are still printed.			*/
      289 	if node.T = Tarchive_comp	 		/* for archive components:			*/
      290 	     then ;
      291 	else if node.Pparent -> node.T = Tmsf then do;	/* for msf components:			*/
      292 	     if node.T = Tmsf_comp then;
      293 	     else if node.T = Tlink then do;		/*    msf components which are links --		*/
      294 chase_searchdir23:	if Sc.default then
      295 		     node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
      296 		call next_tree_level ((ASrequirements), return);
      297 		end;
      298 	     else go to reject;
      299 	     end;
      300 	else if node.Pparent -> node.T = Tlink then do;	/* for msf components which are links --	*/
      301 	     if node.T = Tsegment then;
      302 	     else if node.T = Tlink then go to chase_searchdir23;
      303 	     else go to reject;
      304 	     end;
      305 	else go to reject;				/* reject all other node types.		*/
      306 	go to return;
      307 
      308 execdir(32):					/* library_print, level 2:  exec ents.		*/
      309 lsinfodir(32):					/* library_print, level 2:  list/info ents.	*/
      310 objdir(32):					/* library_print, level 2:  object ents.	*/
      311 searchdir(32):					/* library_print, level 2:  source ents.	*/
      312 	Scontrol = A.Scontrol;
      313 	if Sc.retain then;				/* eliminate nodes for library entries awaiting	*/
      314 	else call reject_node_if_obsolete();		/*    deletion.				*/
      315 	if node.Pparent -> node.T = Tlink then		/* mark first name of link target as outputable.	*/
      316 	     Sreq.primary_name = "1"b;
      317 	if node.T = Tsegment then			/* for segments:				*/
      318 	     if node_outputable (Pnode) then;		/*    ensure outputability of node.		*/
      319 	     else go to reject;
      320 	else if node.T = Tlink then do;		/* for links:				*/
      321 	     if Sc.default then			/*    add further default requirements to link.	*/
      322 		node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
      323 	     call next_tree_level ((ASrequirements), reject);
      324 	     end;					/*    reject link if its target is rejected.	*/
      325 	else if node.T = Tarchive then do;		/* for archives:				*/
      326 	     if Sc.components then			/*    if asked to, output all components of arch.	*/
      327 		Pstarname = addr(starstar);
      328 	     else					/*    otherwise, output matching components.	*/
      329 		Pstarname = A.Pstar;
      330 	     Srequirements = A.Sreq;
      331 	     if Sc.default then
      332 		Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
      333 	     if node_outputable (Pnode) then do;	/*    if archive itself is outputable:		*/
      334 		call next_tree_level_special (suppress_nomatch);
      335 		node.Sreq = ""b;			/*       output entire archive _o_n_l_y if no comps 	*/
      336 		end;				/*       match star names.			*/
      337 	     else do;				/*    if archive is not printable:		*/
      338 		call next_tree_level_special (reject);	/*       reject it if no matching comps found,	*/
      339 		node.Sreq = ""b;			/*       or mark it unprintable if matches found.	*/
      340 		end;
      341 	     end;
      342 	else if node.T = Tmsf then do;		/* for msfs:				*/
      343 	     call next_tree_level (Sreq_msf_comp(3), return);
      344 	     Dnodes.Pnext = node.PD;
      345 	     node.PD = PDnodes;
      346 	     Svalid.kids = "1"b;
      347 	     Soutputable = node_outputable (Pnode);
      348 	     node.PD = Dnodes.Pnext;
      349 	     Dnodes.Pnext = null;
      350 	     Svalid.kids = "0"b;
      351 	     if ^Soutputable then go to reject;		/*    reject MSF if any components not outputable	*/
      352 	     end;
      353 	else go to reject;				/* reject all other node types.		*/
      354 	go to return;
      355 
      356 execdir(33):					/* library_print, level 3:  exec comps.		*/
      357 lsinfodir(33):					/* library_print, level 3:  list/info comp?	*/
      358 objdir(33):					/* library_print, level 3:  object comps.	*/
      359 searchdir(33):					/* library_print, level 3:  source comps.	*/
      360 	Scontrol = A.Scontrol;
      361 	Sreq.names = "1"b;				/* must always require that names of things	*/
      362 						/*   at this level be output, so that when -match	*/
      363 						/*   is specified, archive and MSF component names*/
      364 						/*   are still printed.			*/
      365 	if node.T = Tarchive_comp then		/* for archive components:			*/
      366 	     if node_outputable (Pnode) then;		/*    reject component if not outputable.	*/
      367 	     else go to reject;
      368 	else if node.Pparent -> node.T = Tmsf then do;	/* for msf components:			*/
      369 	     if node.T = Tmsf_comp then;
      370 	     else if node.T = Tlink then do;		/*    msf components which are links --		*/
      371 chase_searchdir33:	if Sc.default then
      372 		     node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
      373 		call next_tree_level ((ASrequirements), return);
      374 		end;
      375 	     end;
      376 	else if node.Pparent -> node.T = Tlink then do;	/* for msf components which are links --	*/
      377 	     if node.T = Tsegment then;
      378 	     else if node.T = Tlink then go to chase_searchdir33;
      379 	     end;
      380 	else go to reject;				/* reject all other node types.		*/
      381 	go to return;
      382 
      383 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      384 
      385 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      386 
      387 
      388 execdir(42):					/* library_fetch, level 2:  exec ents.		*/
      389 lsinfodir(42):					/* library_fetch, level 2:  list/info ents.	*/
      390 objdir(42):					/* library_fetch, level 2:  object ents.	*/
      391 searchdir(42):					/* library_fetch, level 2:  source ents.	*/
      392 	Scontrol = A.Scontrol;
      393 	if Sc.retain then;				/* eliminate nodes for library entries awaiting	*/
      394 	else call reject_node_if_obsolete();		/*   deletion.				*/
      395 	if node.T = Tsegment then;			/* for segments, all done.			*/
      396 	else if node.T = Tlink then do;		/* for links:				*/
      397 	     if Sc.default then			/*   add further default requirements to link.	*/
      398 		node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
      399 	     if Sc.chase then			/*   if caller asked to chase links, do so.	*/
      400 		call next_tree_level ((ASrequirements), return);
      401 	     end;
      402 	else if node.T = Tarchive then do;		/* for archives:				*/
      403 	     if Sc.components then			/* tell about archive components.		*/
      404 		Pstarname = addr(starstar);
      405 	     else					/* tell about selected archive components.	*/
      406 		Pstarname = A.Pstar;
      407 	     if Sc.container then			/* wants to extract parent archive, not components*/
      408 		Sreq.primary_name = "1"b;		/*   must return first name of archive as well.	*/
      409 	     else do;				/* wants matching components, not parent archive.	*/
      410 		Srequirements = A.Sreq;
      411 		if Sc.default then Srequirements = Srequirements | Sreq_seg(4);
      412 		call next_tree_level_special (return);
      413 		node.Sreq = ""b;			/* return nothing about archive if matching	*/
      414 		end;				/*   archive component(s) found.		*/
      415 	     end;
      416 	else if node.T = Tmsf then			/* for msfs:				*/
      417 	     call next_tree_level (Sreq_msf_comp(A.command), return);
      418 	else go to reject;				/* all other types of nodes should not be.	*/
      419 	go to return;
      420 
      421 execdir(43):					/* library_fetch, level 3:  exec comps.		*/
      422 lsinfodir(43):					/* library_fetch, level 3:  list/info comp?	*/
      423 objdir(43):					/* library_fetch, level 3:  object comps.	*/
      424 searchdir(43):					/* library_fetch, level 3:  source comps.	*/
      425 	Scontrol = A.Scontrol;
      426 	if node.T = Tarchive_comp then
      427 	     Sreq.primary_name = "1"b;		/* must get atleast first name back.		*/
      428 	else if node.Pparent -> node.T = Tmsf then do;	/* for msf components:			*/
      429 	     if node.T = Tmsf_comp then;
      430 	     else if node.T = Tlink then do;		/*    msf components which are links --		*/
      431 chase_searchdir43:	if Sc.default then
      432 		     node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
      433 		call next_tree_level ((ASrequirements), return);
      434 		end;
      435 	     else go to reject;
      436 	     end;
      437 	else if node.Pparent -> node.T = Tlink then do;	/* for msf components which are links --	*/
      438 	     if node.T = Tsegment then;
      439 	     else if node.T = Tlink then go to chase_searchdir43;
      440 	     else go to reject;
      441 	     end;
      442 	else go to reject;
      443 	go to return;
      444 
      445 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      446 
      447 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      448 
      449 
      450 execdir(51):					/* library_cleanup,level 1: execution dirs.	*/
      451 lsinfodir(51):					/* library_cleanup,level 1: list/info dirs.	*/
      452 objdir(51):					/* library_cleanup,level 1: object dirs.	*/
      453 searchdir(51):					/* library_cleanup,level 1: source dirs.	*/
      454 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      455 	if node.T ^= Tdirectory then go to reject;	/* accept only directories as root nodes.	*/
      456 	min_Scontrol = min_cleanup_Scontrol;
      457 	max_Scontrol = max_cleanup_Scontrol;
      458 	search_type = 1;
      459 	call set_director_args (min_Scontrol, max_Scontrol, search_type);
      460 						/* set up complete director control arguments.	*/
      461 	node.Sreq = ""b;				/* output nothing about the root directory.	*/
      462 	call next_tree_level (Sreq_seg(A.command), reject);
      463 	go to return;				/* get nodes for lib entries p be deleted.	*/
      464 
      465 
      466 execdir(52):					/* library_cleanup,level 2: exec ents.		*/
      467 lsinfodir(52):					/* library_cleanup,level 2: list/info ents.	*/
      468 objdir(52):					/* library_cleanup,level 2: object ents.	*/
      469 searchdir(52):					/* library_cleanup,level 2: source ents.	*/
      470 	if APstarname->starname.N = 1 then if APstarname->starname.V(1) = "!??????????????" then go to obsolete;
      471 						/* if looking only for obsolete segments, skip	*/
      472 						/* next check.				*/
      473 	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      474 	     end;					/* make sure entry has a unique name on it.	*/
      475 	do i = 1 to APstarname->starname.N;
      476 	     if APstarname->starname.V(i) = "!??????????????" then go to test;
      477 	     end;
      478 	go to obsolete;				/* omit test for unique name if no search name	*/
      479 						/*   matches unique names.			*/
      480 test:	if index (string(Dnames.names), "!") > 0 then
      481 	     do i = 1 to Dnames.N;
      482 		call match_star_name_ (Dnames.names(i), "!??????????????", code);
      483 		if code = 0 then go to obsolete;
      484 		end;
      485 	go to reject;				/* reject nodes which aren't obsolete.		*/
      486 
      487 obsolete:	if node.T = Tdirectory then go to reject;	/* can't delete directories; shouldn't anyway.	*/
      488 	if node.T = Tarchive_comp then go to reject;	/* same for archive components.		*/
      489 	if node.T = Tmsf_comp then go to reject;	/* same for msf components.			*/
      490 	go to return;				/* all other types of nodes can be deleted.	*/
      491 
      492 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      493 
      494 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      495 
      496 
      497 hardcore_bc_dir:	entry     (Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      498 			 link_level, Parea, Adirector, PA, PDnodes, Acode);
      499 
      500 	Scontrol = AScontrol;
      501 	if Sc.first_match & A.n_found > 0 then go to reject;
      502 	go to hbd(A.command * 10 + tree_level);
      503 
      504 
      505 
      506 hbd(11):						/* library_info,  level 1:  hardcore bc dir.	*/
      507 hbd(21):						/* library_map,   level 1:  hardcore bc dir.	*/
      508 hbd(31):						/* library_print, level 1:  hardcore bc dir.	*/
      509 hbd(41):						/* library_fetch, level 1:  hardcore bc dir.	*/
      510 	search_type = 2;				/* set search type info for hardcore.		*/
      511 
      512 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      513 	if node.T ^= Tdirectory then go to reject;	/* accept only the bound component dir as a root.	*/
      514 	call set_director_args (min_object_Scontrol(A.command), max_object_Scontrol(A.command), search_type);
      515 						/* set up complete director control arguments.	*/
      516 	node.Sreq = ""b;				/* output nothing about the root directory.	*/
      517 	Scontrol = A.Scontrol;			/* Because some of user's star names may match	*/
      518 	Srequirements = A.Sreq;			/*    bc archives while others may match only	*/
      519 	if Sc.default then Srequirements = Srequirements | Sreq_offline_seg(A.command);
      520 	Pstarname = addr(starstar);			/*    bc archive components, we must search _a_l_l	*/
      521 	call next_tree_level_special (reject);		/*    does not cost use anything if the user's	*/
      522 	go to return;				/*    star name is "**".			*/
      523 
      524 hbd(12):						/* library_info,  level 2:  hardcore bc archives.	*/
      525 hbd(22):						/* library_map,   level 2:  hardcore bc archives.	*/
      526 hbd(42):						/* library_fetch, level 2:  hardcore bc archives.	*/
      527 	if ^Svalid.names then go to bc_nonames;
      528 	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      529 	     end;					/* If any of this bc archive's names match a	*/
      530 	Pstarname = A.Pstar;			/*    user-specified star name, then output info	*/
      531 						/*    about this bc archive.  Otherwise, don't.	*/
      532 	do i = 1 to Dnames.N;
      533 	     do j = 1 to starname.N;
      534 		go to bc_test (starname.C(j));
      535 
      536 bc_test(0):	if Dnames.names(i) = starname.V(j) then go to bc_match;
      537 		else go to bc_nomatch;
      538 
      539 bc_test(1):	call match_star_name_ (Dnames.names(i), starname.V(j), code);
      540 		if code = 0 then go to bc_match;
      541 		else go to bc_nomatch;
      542 
      543 bc_test(2):	go to bc_match;
      544 bc_nomatch:	end;
      545 	     end;
      546 bc_nonames:					/* Case 1:  no archive names match user star names*/
      547 	if node.T ^= Tarchive then go to reject;	/*  Only archives handled in this case.		*/
      548 	Scontrol = A.Scontrol;
      549 	if starname.N = 1 then do;			/* speed up extraction of bind files.		*/
      550 	     call match_star_name_ (starname.V(1), "**.bind", code);
      551 	     if code = 0 then do;
      552 		i = 33 - index(reverse(starname.V(1)), ".");
      553 		auto_star.V = substr(starname.V(1),1,i) || "archive";
      554 		call match_star_name_ (Dnames.names(1), auto_star.V, code);
      555 		if code ^= 0 then go to reject;
      556 		end;
      557 	     end;
      558 	if Sc.container then do;			/* user want's to know about parent archive	*/
      559 						/*    of a matching archive component.		*/
      560 	     call next_tree_level (Sreq_archive_comp_parent(A.command), reject);
      561 	     if A.command = library_fetch then		/* for library_fetch, want to extract only the	*/
      562 		call lib_free_node_$array (PDnodes);	/*   archive containing matching components, not	*/
      563 						/*   the components as well.			*/
      564 	     end;
      565 	else do;					/* user doesn't want to know about parent archive.*/
      566 	     node.Sreq = ""b;
      567 	     call next_tree_level (Sreq_archive_comp_no_parent(A.command), reject);
      568 	     end;
      569 	go to return;
      570 bc_match:						/* Case 2:  an archive name matches user star name*/
      571 	if node.T ^= Tarchive then go to lsinfodir (A.command * 10 + tree_level);
      572 	Scontrol = A.Scontrol;			/* set up control and requirements info.	*/
      573 	Srequirements = A.Sreq;
      574 	if Sc.default then 
      575 	     if Sc.container then			/*    say little about archive component if we	*/
      576 	          Srequirements = Srequirements | Sreq_archive_comp_parent(A.command);
      577 	     else					/*    we are already given that info about parent.*/
      578 	          Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
      579 
      580 	if Sc.components then			/* user wants to know about _a_l_l archive comps	*/
      581 	     Pstarname = addr(starstar);		/*    in this matching archive.		*/
      582 	else					/* user wants info on only matching archive comps.*/
      583 	     Pstarname = A.Pstar;
      584 	call next_tree_level_special (suppress_nomatch);
      585 	if A.command = library_fetch then		/* for library_fetch, if matching components	*/
      586 	     node.Sreq = ""b;			/*    found, don't extract matching archive too.	*/
      587 	else if ^Sc.container then 			/* if matching components found and parent info	*/
      588 	     node.Sreq = ""b;			/*   not required, don't output it.		*/
      589 	go to return;
      590  
      591 hbd(13):						/* library_info,  level 3:  hardcore bc arch comp.*/
      592 hbd(23):						/* library_map,   level 3:  hardcore bc arch comp.*/
      593 	if node.Pparent -> node.T ^= Tarchive then go to reject;
      594 						/* reject any node which isn't an archive comp.	*/
      595 	Sreq.names = "1"b;				/* must always require that names of things	*/
      596 						/*   at this level be output, so that when -match	*/
      597 						/*   is specified, archive and MSF component names*/
      598 						/*   are still printed.			*/
      599 	go to return;
      600 
      601 
      602 hbd(43):						/* library_fetch, level 3:  hardcore bc arch comp.*/
      603 	if node.Pparent -> node.T ^= Tarchive then go to reject;
      604 						/* reject any node (archive component or archived	*/
      605 						/*   archive) which isn't in an archive.	*/
      606 	Sreq.primary_name = "1"b;			/* must get atleast first name back.		*/
      607 	go to return;
      608 
      609 hbd(32):						/* library_print, level 2:  hardcore bc archives.	*/
      610 	if node.T = Tarchive then node.Sreq = ""b;	/* an object archive itself can never be output.	*/
      611 	if ^Svalid.names then go to bc_pr_nonames;
      612 	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      613 	     end;					/* If any of this bc archive's names match a	*/
      614 	Pstarname = A.Pstar;			/*    user-specified star name, then output info	*/
      615 						/*    about this bc archive.  Otherwise, don't.	*/
      616 	do i = 1 to Dnames.N;
      617 	     do j = 1 to starname.N;
      618 		go to bc_pr_test (starname.C(j));
      619 
      620 bc_pr_test(0):	if Dnames.names(i) = starname.V(j) then go to bc_pr_match;
      621 		else go to bc_pr_nomatch;
      622 
      623 bc_pr_test(1):	call match_star_name_ (Dnames.names(i), starname.V(j), code);
      624 		if code = 0 then go to bc_pr_match;
      625 		else go to bc_pr_nomatch;
      626 
      627 bc_pr_test(2):	go to bc_pr_match;
      628 bc_pr_nomatch:	end;
      629 	     end;
      630 bc_pr_nonames:					/* Case 1:  no archive names match user star names*/
      631 	if node.T ^= Tarchive then go to reject;
      632 	call next_tree_level (Sreq_archive_comp_no_parent(A.command), reject);
      633 	go to return;
      634 
      635 bc_pr_match:					/* Case 2:  an archive name matches user star name*/
      636 	if node.T ^= Tarchive then go to lsinfodir(A.command * 10 + tree_level);
      637 	Scontrol = A.Scontrol;			/* set up control and requirements info.	*/
      638 	Srequirements = A.Sreq;
      639 	if Sc.default then Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
      640 	if Sc.components then			/* user wants to know about all components of	*/
      641 	     Pstarname = addr(starstar);		/*    of this matching archive.		*/
      642 	else					/* user wants info on only matching archive comps.*/
      643 	     Pstarname = A.Pstar;
      644 	call next_tree_level_special (reject);
      645 	go to return;
      646 
      647 
      648 hbd(33):						/* library_print, level 3:  hardcore bc arch comp.*/
      649 	if node.Pparent -> node.T ^= Tarchive then go to reject;
      650 						/* reject any node which isn't an archive comp.	*/
      651 	if node_outputable (Pnode) then;		/* reject an unoutputable archive component.	*/
      652 	else go to reject;
      653 	Sreq.names = "1"b;				/* must always require that names of things	*/
      654 						/*   at this level be output, so that when -match	*/
      655 						/*   is specified, archive and MSF component names*/
      656 						/*   are still printed.			*/
      657 	go to return;
      658 
      659 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      660 
      661 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      662 
      663 
      664 hardcore_object_dir: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      665 			 link_level, Parea, Adirector, PA, PDnodes, Acode);
      666 
      667 	Scontrol = AScontrol;
      668 	if Sc.first_match & A.n_found > 0 then go to reject;
      669 	go to hod(A.command * 10 + tree_level);
      670 
      671 
      672 
      673 hod(11):						/* library_info,  level 1:  hardcore object dir.	*/
      674 hod(21):						/* library_map,   level 1:  hardcore object dir.	*/
      675 hod(31):						/* library_print, level 1:  hardcore object dir.	*/
      676 hod(41):						/* library_fetch, level 1:  hardcore object dir.	*/
      677 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      678 	search_type = 2;				/* set up search type.			*/
      679 
      680 	if node.T ^= Tdirectory then go to reject;	/* accept only the object directory as a root.	*/
      681 	call set_director_args (min_exec_Scontrol(A.command), max_exec_Scontrol(A.command), search_type);
      682 						/* set up complete director control arguments.	*/
      683 	node.Sreq = ""b;				/* output nothing about the root directory.	*/
      684 	call next_tree_level (Sreq_offline_seg(A.command), reject);
      685 						/* apply offline segment reqmts when getting	*/
      686 	go to return;				/*    object segments at next tree level.	*/
      687 
      688 hod(12):						/* library_info,  level 2:  hardcore object ents.	*/
      689 hod(22):						/* library_map,   level 2:  hardcore object ents.	*/
      690 hod(42):						/* library_fetch, level 2:  hardcore object ents.	*/
      691 	if node.T ^= Tsegment then go to reject;	/* only segments are allowed in object dir.	*/
      692 	go to return;				/* add system id to node information.		*/
      693 
      694 
      695 hod(32):						/* library_print, level 2:  hardcore object ents.	*/
      696 	if node.T ^= Tsegment then go to reject;	/* only segments are allowed in object dir.	*/
      697 	if node_outputable (Pnode) then;		/* reject any unoutputable segment.		*/
      698 	else go to reject;
      699 	go to return;				/* add system id to node information.		*/
      700 
      701 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      702 
      703 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      704 
      705 
      706 hardcore_source_dir: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
      707 			 link_level, Parea, Adirector, PA, PDnodes, Acode);
      708 
      709 	Scontrol = AScontrol;
      710 	if Sc.first_match & A.n_found > 0 then go to reject;
      711 	go to hsd(A.command * 10 + tree_level);
      712 
      713 
      714 hsd(11):						/* library_info,  level 1:  hardcore source dir.	*/
      715 hsd(21):						/* library_map,   level 1:  hardcore source dir.	*/
      716 hsd(31):						/* library_print, level 1:  hardcore source dir.	*/
      717 hsd(41):						/* library_fetch, level 1:  hardcore source dir.	*/
      718 	search_type = 2;				/* set search type info for hardcore.		*/
      719 
      720 	if Sinit then call init_vars();		/* initialize internal static variables.	*/
      721 	if node.T ^= Tdirectory then go to reject;	/* accept only the source directory as a root.	*/
      722 	call set_director_args (min_source_Scontrol(A.command), max_source_Scontrol(A.command), search_type);
      723 						/* set up complete director control arguments.	*/
      724 	node.Sreq = ""b;				/* output nothing about the source directory.	*/
      725 	Scontrol = A.Scontrol;			/* set up control and requirements info in	*/
      726 	Srequirements = A.Sreq;			/*    for getting next tree level.		*/
      727 	if Sc.default then Srequirements = Srequirements | Sreq_offline_seg(A.command);
      728 	Pstarname = A.Pstar;			/* access the user's star name.		*/
      729 	code = 1;
      730 	if A.command = library_info then		/* for library_info, if a single star name was	*/
      731 	     if starname.N = 1 then			/*   given, and it matches archive name format,	*/
      732 		call match_star_name_ (starname.V(1), "**.archive", code);
      733 						/*   treat it as the search name w/o modification.*/
      734 	if (starname.N = 1) & (code ^= 0) then do;	/* if he gave only 1 star name, we can look only	*/
      735 						/*    in those source archives which might hold	*/
      736 						/*    matches for that name.			*/
      737 	     auto_star.N = 1;
      738 	     auto_star.V = substr(starname.V(1),1,1) || "?.archive";
      739 	     auto_star.C = 1;			/* map    "able.pl1" into "a?.archive";		*/
      740 	     Pstarname = addr(auto_star);		/*	"*.alm"    into "*?.archive";		*/
      741 	     end;					/*	"?able.*"  into "??.archive".		*/
      742 	else if code = 0 then;			/* use user's archive name if in that format.	*/
      743 	else					/* if more than one star name, we must look in	*/
      744 	     Pstarname = addr(starstar);		/*    _a_l_l source archives for matches.		*/
      745 	call next_tree_level_special (reject);		/* get tree nodes for archives which contain	*/
      746 						/*    source components which match user's star	*/
      747 	go to return;				/*    names.				*/
      748 
      749 
      750 hsd(12):						/* library_info,  level 2:  hardcore source arch.	*/
      751 hsd(22):						/* library_map,   level 2:  hardcore source arch.	*/
      752 hsd(32):						/* library_print, level 2:  hardcore source arch.	*/
      753 hsd(42):						/* library_fetch, level 2:  hardcore source arch.	*/
      754 	if node.T ^= Tarchive then go to reject;	/* accept only source archives.		*/
      755 	Pstarname = A.Pstar;			/* see if this archive can possible contain what	*/
      756 	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      757 	     end;					/*     what we're looking for.		*/
      758 	do i = 1 to starname.N;
      759 	     call match_star_name_ (Dnames.names(1), substr(starname.V(i),1,1) || "?.archive", code);
      760 	     if code = 0 then go to hs_match;
      761 	     end;
      762 	go to reject;
      763 hs_match:	if A.command ^= library_info then do;
      764 	     call next_tree_level (Sreq_archive_comp_no_parent(A.command), reject);
      765 						/* get tree nodes for matching source comps, but	*/
      766 						/*    reject node for source archive if no	*/
      767 						/*    matching source components are found.	*/
      768 	     node.Sreq = ""b;
      769 	     end;
      770 	else do;					/* for library_info, allow information about the	*/
      771 						/*   source archives, themselves.		*/
      772 	     Scontrol = A.Scontrol;
      773 	     Srequirements = A.Sreq;
      774 	     if Sc.default then
      775 		if Sc.container then		/*    say little about archive component if we	*/
      776 		     Srequirements = Srequirements | Sreq_archive_comp_parent(A.command);
      777 		else				/*    we are already given that info about parent.*/
      778 		     Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
      779 	     if APstarname = A.Pstar then do;		/* if user gave an archive name, rather than a	*/
      780 						/*   component name, process things differently.	*/
      781 		if Sc.components then do;		/* User wants all components back as well. OK	*/
      782 		     Pstarname = addr(starstar);
      783 		     call next_tree_level_special (return);
      784 		     end;
      785 		end;
      786 	     else do;				/* user gave an archive component name.		*/
      787 		Pstarname = A.Pstar;
      788 		call next_tree_level_special (reject);	/* find matching archive components.		*/
      789 		if ^Sc.container then
      790 		    node.Sreq = ""b;
      791 		end;
      792 	     end;
      793 	go to return;
      794 
      795 
      796 hsd(13):						/* library_info,  level 3:  hardcore source comp.	*/
      797 hsd(23):						/* library_map,   level 3:  hardcore source comp.	*/
      798 hsd(33):						/* library_print, level 3:  hardcore source comp.	*/
      799 hsd(43):						/* library_fetch, level 3:  hardcore source comp.	*/
      800 	if node.T ^= Tarchive_comp then go to reject;	/* accept only archive components at this level.	*/
      801 	Sreq.names = "1"b;				/* must always require that names of things	*/
      802 						/*   at this level be output, so that when -match	*/
      803 						/*   is specified, archive and MSF component names*/
      804 						/*   are still printed.			*/
      805 	go to return;
      806 
      807 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      808 
      809 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      810 
      811 
      812          execdir(61):
      813          lsinfodir(61):
      814          objdir(61):
      815          searchdir(61):
      816          ptd(61):
      817 hbd(51): hbd(61):
      818 hod(51): hod(61):
      819 hsd(51): hsd(61):
      820 	Acode = error_table_$undefined_order_request;	/* complain about unsupported commands/dirs	*/
      821 	go to return;
      822 
      823 reject:	Acode = error_table_$nomatch;			/* reject our input node.			*/
      824 	return;
      825 
      826 return:	if node.Sreq ^= ""b then A.n_found = A.n_found + 1;
      827 	if Sc.first_match & A.n_found > 0 then Acode = error_table_$process_stopped;
      828 	if PDnodes ^= null then
      829 	     if Dnodes.C = error_table_$logical_volume_not_connected then Acode = Dnodes.C;
      830 	return;					/* return our input node, in spite of any error	*/
      831 						/*    in getting its descendant nodes.		*/
      832 
      833 suppress_nomatch:					/* suppress a nomatch error when getting any	*/
      834 	if PDnodes = null then;			/*    descendants of our input node.		*/
      835 	else call lib_free_node_$array(PDnodes);
      836 	go to return;
      837 
      838 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      839 
      840 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      841 
      842 init_vars:  procedure;		  		/* This procedure initializes internal static	*/
      843 						/*    variables which are used as constants.	*/
      844 						/*    The variables include node requirement	*/
      845 				 		/*    switches and search control switches.  They	*/
      846 			 			/*    are initialized by referencing the switch	*/
      847 						/*    bits by name to allow flexibility in	*/
      848 						/*    reordering and extending the switches, and	*/
      849 						/*    to simplify the interpretation of the	*/
      850 						/*    array of switch bits.			*/
      851 
      852 	ring = get_ring_();				/* get current ring number.			*/
      853 
      854 	Srequirements = ""b;
      855 	S.primary_name = "1"b;
      856 	S.matching_names = "1"b;
      857 	S.type = "1"b;
      858 	S.pathname = "1"b;
      859 	S.dtm = "1"b;
      860 	S.level = "1"b;
      861 	S.new_line = "1"b;
      862 	S.kids_error = "1"b;
      863 	Sreq_offline_seg(1) = Srequirements;		/* library_info:  default requirements		*/
      864 	Sreq_seg(1) = Srequirements;
      865 
      866 	string(S) = ""b;
      867 	S.primary_name = "1"b;
      868 	S.matching_names = "1"b;
      869 	S.names = "1"b;
      870 	S.type = "1"b;
      871 	S.pathname = "1"b;
      872 	S.dtm = "1"b;
      873 	S.dtem = "1"b;
      874 	S.copy = "1"b;
      875 	S.safety = "1"b;
      876 	S.level = "1"b;
      877 	S.new_line = "1"b;
      878 	S.kids_error = "1"b;
      879 	S.cross_ref = "1"b;
      880 	Sreq_offline_seg(2) = Srequirements;		/* library_map:  offline segs, default reqmts.	*/
      881 	S.dtd = "1"b;
      882 	S.current_length = "1"b;
      883 	S.records_used = "1"b;
      884 	S.max_length = "1"b;
      885 	S.bit_count = "1"b;
      886 	S.rb = "1"b;
      887 	Sreq_seg(2) = Srequirements;			/* library_map:  online segs, default requirements*/
      888 
      889 	string(S) = ""b;
      890 	S.primary_name = "1"b;
      891 	S.matching_names = "1"b;
      892 	S.names = "1"b;
      893 	S.type = "1"b;
      894 	S.pathname = "1"b;
      895 	S.dtm = "1"b;
      896 	S.dtem = "1"b;
      897 	S.copy = "1"b;
      898 	S.level = "1"b;
      899 	S.new_line = "1"b;
      900 	S.kids_error = "1"b;
      901 	Sreq_seg(3) = Srequirements;			/* library_print:  online segs, default reqmts.	*/
      902 	Sreq_offline_seg(3) = Srequirements;		/* library_print:  offline segs, default reqmts.	*/
      903 
      904 	string(S) = ""b;
      905 	S.primary_name = "1"b;
      906 	S.matching_names = "1"b;
      907 	S.type = "1"b;
      908 	S.pathname = "1"b;
      909 	S.dtm = "1"b;
      910 	S.copy = "1"b;
      911 	S.bit_count = "1"b;
      912 	S.dtc = "1"b;
      913 	S.compiler_version = "1"b;
      914 	S.compiler_options = "1"b;
      915 	S.object_info = "1"b;
      916 	S.level = "1"b;
      917 	S.new_line = "1"b;
      918 	S.kids_error = "1"b;
      919 	Sreq_seg(4) = Srequirements;			/* library_fetch:  default requirements.	*/
      920 	Sreq_offline_seg(4) = Srequirements;
      921 
      922 	string(S) = ""b;
      923 	S.primary_name = "1"b;
      924 	S.matching_names = "1"b;
      925 	S.type = "1"b;
      926 	S.pathname = "1"b;
      927 	S.dtem = "1"b;
      928 	S.copy = "1"b;
      929 	S.kids_error = "1"b;
      930 	Sreq_seg(5) = Srequirements;			/* library_cleanup:  default requirements	*/
      931 
      932 	string(S) = ""b;
      933 	S.link_target = "1"b;
      934 	Sreq_link(4) = Srequirements;			/* for library_fetch - add only link path.	*/
      935 	S.dtem = "1"b;
      936 	Sreq_link(1) = Srequirements;			/* requirements added by default for links.	*/
      937 	Sreq_link(2) = Srequirements;
      938 	Sreq_link(3) = Srequirements;
      939 	Sreq_link(5) = Srequirements;
      940 
      941 	Sreq_msf_comp(1) = Sreq_seg(1);		/* requirements for online msf comp = online segs.*/
      942 	Sreq_msf_comp(2) = Sreq_seg(2);
      943 	Sreq_msf_comp(3) = Sreq_seg(3);
      944 	Sreq_msf_comp(4) = Sreq_seg(4);
      945 
      946 	string(S) = ""b;				/* requirements for mapped archive components	*/
      947 	S.primary_name = "1"b;
      948 	S.matching_names = "1"b;
      949 	S.names = "1"b;
      950 	S.dtem = "1"b;
      951 	S.level = "1"b;
      952 	S.new_line = "1"b;
      953 	S.kids_error = "1"b;
      954 	Sreq_archive_comp_parent(1) = Srequirements;	/* for archive comp when parent archive listed.	*/
      955 	S.cross_ref = "1"b;
      956 	Sreq_archive_comp_parent(2) = Srequirements;
      957 	S.cross_ref = "0"b;
      958 	Sreq_archive_comp_parent(3) = Srequirements;
      959 	Sreq_archive_comp_parent(4) = Sreq_seg(4);
      960 	S.type = "1"b;
      961 	S.pathname = "1"b;
      962 	Sreq_archive_comp_no_parent(1) = Srequirements;	/* for archive comp when parent archive omitted.	*/
      963 	Sreq_archive_comp_no_parent(2) = Srequirements;
      964 	Sreq_archive_comp_no_parent(3) = Srequirements;
      965 	S.bit_count = "1"b;
      966 	S.dtc = "1"b;
      967 	S.compiler_version = "1"b;
      968 	S.compiler_options = "1"b;
      969 	S.object_info = "1"b;
      970 	S.level = "0"b;
      971 	Sreq_archive_comp_no_parent(4) = Srequirements;
      972 
      973 	max_Srequirements(2) = (72)"1"b;		/* any requirements are allowed for library_map.	*/
      974 	Srequirements = (72)"1"b;
      975 	S.cross_ref = "0"b;
      976 	max_Srequirements(1) = Srequirements;		/* name cross-reference omitted for library_info. */
      977 	max_Srequirements(3) = Srequirements;		/* same for library_print.			*/
      978 	max_Srequirements(4) = Srequirements;		/* same for library_fetch.			*/
      979 	max_Srequirements(5) = Srequirements;		/* same for library_cleanup.			*/
      980 
      981 	min_cleanup_Scontrol = ""b;			/* library_cleanup:  no minimum control.	*/
      982 	Scontrol = (36)"1"b;
      983 	Sc.chase = "0"b;
      984 	Sc.object_info = "0"b;
      985 	Sc.acl = "0"b;
      986 	Sc.iacl = "0"b;
      987 	Sc.all_status = "0"b;
      988 	Sc.check_ascii = "0"b;
      989 	Sc.check_archive = "0"b;
      990 	max_cleanup_Scontrol = Scontrol;		/* library_cleanup:  maximum control.		*/
      991 
      992 	min_exec_Scontrol(1) = ""b;			/* library_info:   exec dirs, no minimum control.	*/
      993 	min_exec_Scontrol(2) = ""b;			/* library_map:    exec dirs, no minimum control.	*/
      994 	Scontrol = ""b;
      995 	Sc.check_ascii = "1"b;
      996 	min_exec_Scontrol(3) = Scontrol;		/* library_print:  exec dirs, check printability.	*/
      997 	Scontrol = ""b;
      998 	Sc.object_info = "1"b;
      999 	min_exec_Scontrol(4) = Scontrol;		/* library_fetch:  exec dirs, check for obj seg.	*/
     1000 	Scontrol = (36)"1"b;
     1001 	Sc.check_archive = "0"b;
     1002 	max_exec_Scontrol(1) = Scontrol;		/* library_info:   exec dirs, no archives.	*/
     1003 	max_exec_Scontrol(2) = Scontrol;		/* library_map:    exec dirs, no archives.	*/
     1004 	max_exec_Scontrol(3) = Scontrol;		/* library_print:  exec dirs, no archives.	*/
     1005 	Sc.check_ascii = "0"b;
     1006 	max_exec_Scontrol(4) = Scontrol;		/* library_fetch:  no ascii check either.	*/
     1007 
     1008 	min_list_info_Scontrol(1) = ""b;		/* library_info:   list/info, no minimum control.	*/
     1009 	min_list_info_Scontrol(2) = ""b;		/* library_map:    list/info, no minimum control.	*/
     1010 	min_list_info_Scontrol(3) = ""b;		/* library_print:  list/info, no minimum control.	*/
     1011 	min_list_info_Scontrol(4) = ""b;		/* library_fetch:  list/info, no minimum control.	*/
     1012 	Scontrol = (36)"1"b;
     1013 	Sc.object_info = "0"b;
     1014 	Sc.check_archive = "0"b;
     1015 	Sc.check_ascii = "0"b;
     1016 	max_list_info_Scontrol(1) = Scontrol;		/* library_info:   list/info, no checking needed.	*/
     1017 	max_list_info_Scontrol(2) = Scontrol;		/* library_map:    list/info, no checking needed.	*/
     1018 	max_list_info_Scontrol(3) = Scontrol;		/* library_print:  list/info, no checking needed.	*/
     1019 	max_list_info_Scontrol(4) = Scontrol;		/* library_fetch:  list/info, no checking needed.	*/
     1020 
     1021 	Scontrol = ""b;
     1022 	Sc.check_archive = "1"b;
     1023 	min_object_Scontrol(1) = Scontrol;		/* library_info:   object dirs, check archives.	*/
     1024 	min_object_Scontrol(2) = Scontrol;		/* library_map:    object dirs, check archives.	*/
     1025 	Sc.check_ascii = "1"b;
     1026 	min_object_Scontrol(3) = Scontrol;		/* library_print:  object dirs, check printability*/
     1027 	Scontrol = ""b;
     1028 	Sc.check_archive = "1"b;
     1029 	Sc.object_info = "1"b;
     1030 	min_object_Scontrol(4) = Scontrol;		/* library_fetch:  object dirs, check arch/obj seg*/
     1031 	max_object_Scontrol(1) = (36)"1"b;		/* library_info:   object dirs, no maximum control*/
     1032 	max_object_Scontrol(2) = (36)"1"b;		/* library_map:    object dirs, no maximum control*/
     1033 	max_object_Scontrol(3) = (36)"1"b;		/* library_print:  object dirs, no maximum control*/
     1034 	max_object_Scontrol(4) = (36)"1"b;		/* library_fetch:  object dirs, no maximum control*/
     1035 
     1036 	Scontrol = ""b;
     1037 	Sc.check_archive = "1"b;
     1038 	min_source_Scontrol(1) = Scontrol;		/* library_info:   source dirs, check archives.	*/
     1039 	min_source_Scontrol(2) = Scontrol;		/* library_map:    source dirs, check archives.	*/
     1040 	min_source_Scontrol(3) = Scontrol;		/* library_print:  source dirs, check archives.	*/
     1041 	min_source_Scontrol(4) = Scontrol;		/* library_fetch:  source dirs, check archives.	*/
     1042 	Scontrol = (36)"1"b;
     1043 	Sc.object_info = "0"b;
     1044 	Sc.check_ascii = "0"b;
     1045 	max_source_Scontrol(1) = Scontrol;		/* library_info:   source dirs, no obj/ascii segs.*/
     1046 	max_source_Scontrol(2) = Scontrol;		/* library_map:    source dirs, no obj/ascii segs.*/
     1047 	max_source_Scontrol(3) = Scontrol;		/* library_print:  source dirs, no obj/ascii segs.*/
     1048 	max_source_Scontrol(4) = Scontrol;		/* library_fetch:  source dirs, no obj/ascii segs.*/
     1049 
     1050 	Sinit = "0"b;
     1051 
     1052 	end init_vars;
     1053 
     1054 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1055 
     1056 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1057 
     1058 
     1059 next_tree_level:	procedure (default_Sreq, error_return);	/* procedure which obtains descendants of our	*/
     1060 						/*    input node.				*/
     1061 
     1062      dcl	default_Sreq		bit(72) aligned,	/* default requirements switches. (In)		*/
     1063 	error_return		label;		/* error return point. (In)			*/
     1064 
     1065 	Scontrol = A.Scontrol;
     1066 	Srequirements = A.Sreq;
     1067 	if Sc.default then Srequirements = Srequirements | default_Sreq;
     1068 						/* apply default requirements if asked to do so.	*/
     1069 	Pstarname = A.Pstar;
     1070 
     1071 
     1072 next_tree_level_special:	entry	(error_return);	/* entry for using special star names, etc.	*/
     1073 
     1074 	call lib_get_tree_ (Pnode, path, Pstarname, APexclude, Srequirements, Scontrol, tree_level,
     1075 			link_level, Parea, Adirector, PA, PDnodes, code);
     1076 						/* get the node(s) at the descendant tree level.	*/
     1077 	if PDnodes = null then go to error_return;	/* a very serious error has occurred.		*/
     1078 	if Dnodes.C = error_table_$nomatch then		/* only other important error is no descendants.	*/
     1079 	     go to error_return;
     1080 
     1081 	end next_tree_level;
     1082 
     1083 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1084 
     1085 
     1086 node_outputable:	procedure (Pnode_)			/* This internal procedure determines if a library*/
     1087 	     returns	(bit(1) aligned);		/* entry is outputable.			*/
     1088 
     1089      dcl	Pnode_			ptr;		/* ptr to node to be tested.			*/
     1090 
     1091      dcl	PDnodes_			ptr,		/* ptr to a node array descriptor.		*/
     1092 	i			fixed bin;	/* a do-group index.			*/
     1093 
     1094      dcl	1 Dnodes_			aligned based (PDnodes_),
     1095 		     				/* a node array descriptor.			*/
     1096 	  2 header		like Dnodes.header, 
     1097 	  2 nodes (Nnodes refer (Dnodes_.N))
     1098 				like node,
     1099 
     1100 	1 node_			aligned based (Pnode_) like node,
     1101 		     				/* a node.				*/
     1102 	1 Svalid			aligned based (addr (node_.Svalid)) like Svalid_req;
     1103 		     				/* switches indicating which node info is valid.	*/
     1104 
     1105 	if node_.T = Tsegment then			/* if this node is a segment,			*/
     1106 msf_comp:	     if node_.rb(2) < ring then;		/*    and it is readable in this ring,		*/
     1107 	     else if ^substr(node_.Smode,1,1) then;
     1108 	     else
     1109 arch_comp:	if node_.bit_count < 9 then;		/*    and it has a non-zero bit count,		*/
     1110 	     else if mod (node_.bit_count, 9) ^= 0 then;	/*    and its bit count says it contains chars,	*/
     1111 	     else if Svalid.object_info then;		/*    and it was not proven to be an obj segment	*/
     1112 	     else if Svalid.not_ascii then;
     1113 						/*    and it is not a non-ascii or pt seg, 	*/
     1114 	     else return ("1"b);			/*    then segment is outputable.		*/
     1115 
     1116 	else if node_.T = Tmsf_comp then		/* if this node is an msf component, treat it	*/
     1117 	     go to msf_comp;			/*    like a segment.			*/
     1118 
     1119 	else if node_.T = Tlink then			/* if this node is a link,			*/
     1120 	     if Svalid.kids then do;			/*    if the link was chased,			*/
     1121 	          do PDnodes_ = node_.PD repeat Dnodes_.Pnext while (Dnodes_.header.T ^= Tnodes);
     1122 		     end;
     1123 	     	return (node_outputable (addr (Dnodes_.nodes(1))));
     1124 	          end;				/*    Let outputability of link target determine	*/
     1125 	     else;				/*    outputability of link.			*/
     1126 
     1127 	else if node_.T = Tarchive then		/* if this node is an archive,		*/
     1128 	     if Svalid.not_ascii then;		/*    and it is not a non-ascii archive,	*/
     1129 	     else return ("1"b);			/*    then it is outputable.			*/
     1130 
     1131 	else if node_.T = Tarchive_comp then		/* if this node is an archive component,	*/
     1132 	     go to arch_comp;			/*    treat it like a segment to which we already	*/
     1133 		     				/*    know we have access.  (We found out it was	*/
     1134 		     				/*    an archive component, didn't we?)		*/
     1135 
     1136 	else if node_.T = Tmsf then			/* if this node is an MSF, let it's outputability	*/
     1137 	     if Svalid.kids then do;			/*    hinge on outputability of its components.	*/
     1138 	          do PDnodes_ = node_.PD repeat Dnodes_.Pnext while (Dnodes_.header.T ^= Tnodes);
     1139 		     end;
     1140 	          do i = 1 to Dnodes_.N while (node_outputable (addr (Dnodes_.nodes(i))));
     1141 		     end;
     1142 		if i > Dnodes_.N then return ("1"b);	/*    if all components outputable, so if MSF.	*/
     1143 	          end;
     1144 
     1145 	return ("0"b);				/* otherwise, node is not outputable.		*/
     1146 
     1147 	end node_outputable;
     1148 
     1149 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1150 
     1151 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1152 
     1153 
     1154 reject_node_if_obsolete:	procedure;		/* This procedure examines the names on a node to	*/
     1155 						/*    determine if any are unique names.  If so,	*/
     1156 						/*    then the node is rejected.		*/
     1157 
     1158 	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
     1159 	     end;
     1160 	if index (string(Dnames.names), "!") > 0 then
     1161 	     do i = 1 to Dnames.N;
     1162 	          call match_star_name_ (Dnames.names(i), "!??????????????", code);
     1163 	          if code = 0 then go to reject;
     1164 	          end;
     1165 
     1166 	end reject_node_if_obsolete;
     1167 
     1168 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1169 
     1170 
     1171 set_director_args:	procedure (min_Scontrol, max_Scontrol, search_type);
     1172 						/* procedure to replace incoming director	*/
     1173 						/*    control argument, which is a command index,	*/
     1174 						/*    by a more elaborate structure which includes*/
     1175 						/*    all user arguments which might be modified	*/
     1176 						/*    when getting one tree level, and then be	*/
     1177 						/*    restored at the next tree level.		*/
     1178 
     1179      dcl (max_Scontrol, min_Scontrol)	bit(36) aligned,	/* min/max control switch settings. (In)	*/
     1180 	search_type		fixed bin;	/* search type. (In)			*/
     1181 
     1182 	director_args.command = A.command;		/* fill in director arguments.		*/
     1183 	director_args.n_found = A.n_found;
     1184 	PA_saved = PA;
     1185 	PA = addr(director_args);
     1186 	A.Pstar = APstarname;
     1187 	A.Sreq = ASrequirements & max_Srequirements(A.command);
     1188 	Scontrol = AScontrol;
     1189 	Scontrol = Scontrol & max_Scontrol;
     1190 	Scontrol = Scontrol | min_Scontrol;
     1191 	A.Scontrol = Scontrol;
     1192 	A.search_type = search_type;
     1193 
     1194 	end set_director_args;
     1195 
     1196 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1197 
  2     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  2     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  2     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  2    10 	/* called the node target.							*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  2    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  2    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  2    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  2    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  2    19 	/*									*/
  2    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 
  2    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    23 	/*									*/
  2    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  2    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  2    26 	/* both types of nodes are the same length.					*/
  2    27 	/*									*/
  2    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    29 
  2    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  2    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  2    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  2    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  2    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  2    35 						/*             (= node.Svalid & Srequirements)	*/
  2    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  2    37 	  2 switches		unaligned,
  2    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  2    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  2    40 						/* 	     entry before lib_access_mode_$set.	*/
  2    41 	    3 pad			bit(22),
  2    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  2    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  2    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  2    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  2    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  2    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  2    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  2    49 						/*	     in this directory;  if off, records*/
  2    50 						/*	     charged against 1st superior	*/
  2    51 						/*	     directory with switch on.	*/
  2    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  2    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  2    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  2    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  2    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  2    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  2    58 
  2    59 						/* From here on, link_nodes differ from nodes	*/
  2    60 						/*  for other types of node targets.		*/
  2    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  2    62 
  2    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    64 	/*									*/
  2    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  2    66 	/*									*/
  2    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    68 
  2    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  2    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  2    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  2    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  2    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  2    74 						/*             (= node.Svalid & Srequirements)	*/
  2    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  2    76 	  2 switches		unaligned,
  2    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  2    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  2    79 						/* 	     entry before lib_access_mode_$set.	*/
  2    80 	    3 pad			bit(22),
  2    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  2    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  2    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  2    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  2    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  2    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  2    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  2    88 						/*	     in this directory;  if off, records*/
  2    89 						/*	     charged against 1st superior	*/
  2    90 						/*	     directory with switch on.	*/
  2    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  2    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  2    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  2    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  2    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  2    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  2    97 
  2    98 						/* From here on, other nodes differ from	*/
  2    99 						/*  link_nodes.				*/
  2   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  2   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  2   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  2   103 	  2 pad1 (1)		fixed bin,
  2   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  2   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  2   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  2   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  2   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  2   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  2   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  2   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  2   112 						/*             component from the base of archive.*/
  2   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  2   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  2   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  2   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  2   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  2   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  2   119 						/*	     updated.			*/
  2   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  2   121 						/*	     directories with Sterminal_account	*/
  2   122 						/*	     on.				*/
  2   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  2   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  2   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  2   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  2   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  2   128 						/*	     updated.			*/
  2   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  2   130 						/*	     directories with Sterminal_account	*/
  2   131 						/*	     on.				*/
  2   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  2   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  2   134 	  2 pad2 (5)		fixed bin,
  2   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  2   136 
  2   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   138 	/*									*/
  2   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  2   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  2   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  2   142 	/* descriptors are the only ones that have been defined.				*/
  2   143 	/*									*/
  2   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   145 
  2   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  2   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  2   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  2   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  2   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  2   152 
  2   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  2   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  2   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  2   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   163 	    3 zero_pad		bit(36),
  2   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  2   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  2   167 	Vacl_1			fixed bin int static options(constant) init (1),
  2   168 						/* version:   version of ACL descriptor.	*/
  2   169 	Tacl			fixed bin int static options(constant) init (7);
  2   170 						/* attribute: type of a segment ACL descriptor.	*/
  2   171 
  2   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  2   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  2   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  2   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  2   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  2   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  2   186 						/* version:   version of directory ACL descriptor.*/
  2   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  2   188 						/* attribute: type of a directory ACL descriptor.	*/
  2   189 
  2   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  2   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  2   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  2   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  2   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  2   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  2   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  2   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  2   206 						/* version:   version of dir IACL descriptor.	*/
  2   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  2   208 
  2   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  2   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  2   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  2   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  2   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  2   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   221 	    3 zero_pad		bit(36),
  2   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  2   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  2   225 	Viacl_1			fixed bin int static options(constant) init (1),
  2   226 						/* version:   version of segment IACL descriptor.	*/
  2   227 	Tiacl			fixed bin int static options(constant) init (10);
  2   228 						/* attribute: type of a segment IACL descriptor.	*/
  2   229 
  2   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  2   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  2   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  2   236 	  2 names (Nnames refer (Dnames.N))
  2   237 				char(32),		/* attribute: names.			*/
  2   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  2   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  2   240 	Vnames_1			fixed bin int static options(constant) init (1),
  2   241 						/* version:   version of names descriptor.	*/
  2   242 	Tnames			fixed bin int static options(constant) init (1);
  2   243 						/* attribute: type of a name descriptor.	*/
  2   244 
  2   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  2   246 						/* nodes.					*/
  2   247 	  2 header,
  2   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  2   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  2   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  2   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  2   255 				like node,
  2   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  2   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  2   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  2   259 						/* version:   version of nodes descriptor.	*/
  2   260 	Tnodes			fixed bin int static options(constant) init (2);
  2   261 						/* attribute: type of a node descriptor.	*/
  2   262 
  2   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  2   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  2   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   268 	  2 info,
  2   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  2   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  2   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  2   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  2   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  2   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  2   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  2   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  2   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  2   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  2   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  2   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  2   281 	    3 format		aligned,
  2   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  2   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  2   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  2   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  2   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  2   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  2   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  2   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  2   290 	      4 pad		bit(28) unal,
  2   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  2   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  2   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  2   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  2   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  2   296 	    3 cversion,				/* attribite: compiler version string.		*/
  2   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  2   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  2   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  2   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  2   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  2   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  2   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  2   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  2   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  2   306 	Vobj_1			fixed bin int static options(constant) init (1),
  2   307 						/* version:   version of object_info_ descriptor.	*/
  2   308 	Tobj			fixed bin int static options(constant) init (3);
  2   309 						/* attribute: type of a node descriptor.	*/
  2   310 
  2   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  2   312 						/* library root search_proc attribute descriptor.	*/
  2   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  2   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  2   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  2   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  2   320 						/* version:   version of search_proc info descrip.*/
  2   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  2   322 						/* attribute: type of a search_proc descriptor.	*/
  2   323 
  2   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  2   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  2   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  2   330 						/*            output.			*/
  2   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  2   332 	  2 info			char(Luser refer (Duser.L)),
  2   333 						/* attribute: user info string.		*/
  2   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  2   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  2   336 	Vuser_1			fixed bin int static options(constant) init (1),
  2   337 						/* version:   version of user info descriptor.	*/
  2   338 	Tuser			fixed bin int static options(constant) init (6);
  2   339 						/* attribute: type of a user descriptor.	*/
  2   340 
  3     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the switches which request/validate the fields	*/
  3     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  3     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  3    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  3    11 	/* descriptor commands to obtain information about entries in a library.		*/
  3    12 	/*									*/
  3    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  3    14 	/* is requested for output.							*/
  3    15 	/*									*/
  3    16 	/* S__t_a_t_u_s									*/
  3    17 	/*									*/
  3    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  3    19 	/*									*/
  3    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    21 
  3    22 
  3    23      dcl	1 Svalid_req		aligned based,
  3    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  3    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  3    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  3    27 
  3    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  3    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  3    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  3    31 
  3    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  3    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  3    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  3    35 
  3    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  3    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  3    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  3    39 
  3    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  3    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  3    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  3    43 
  3    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  3    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  3    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  3    47 
  3    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  3    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  3    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  3    51 
  3    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  3    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  3    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  3    55 
  3    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  3    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  3    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  3    59 
  3    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  3    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  3    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  3    63 
  3    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  3    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  3    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  3    67 
  3    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  3    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  3    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  3    71 
  3    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  3    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  3    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  3    75 
  3    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  3    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  3    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  3    79 	  2 pad			bit(26) unal,
  3    80 
  3    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  3    82 
  3    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  3    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  3    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  3    86 
  3    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    88 	/*									*/
  3    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  3    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  3    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  3    92 	/*									*/
  3    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    94 
  3    95 
  3    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  3    97 	Srequirements		bit(72) aligned;
  3    98 
  3    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   341 
  2   342 
  2   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  2   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  2   345 
  4     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  4     6 	/*									*/
  4     7 	/*      This include segment defines the control switches used by library descriptor	*/
  4     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  4     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  4    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  4    11 	/* to the lib_descriptor_ subroutine.						*/
  4    12 	/*									*/
  4    13 	/* S__t_a_t_u_s									*/
  4    14 	/*									*/
  4    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  4    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  4    17 	/*									*/
  4    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    19 
  4    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  4    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  4    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  4    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  4    24 
  4    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  4    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  4    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  4    28 						/*         nodes of the tree, and about all the	*/
  4    29 						/*	 nodes below the parent.		*/
  4    30 
  4    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  4    32 						/*         nodes of the tree.			*/
  4    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  4    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  4    35 
  4    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  4    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  4    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  4    39 						/*         deletion.			*/
  4    40 
  4    41 	  2 pad			bit(10) unal,
  4    42 
  4    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  4    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  4    45 
  4    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  4    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  4    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  4    49 
  4    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  4    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  4    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  4    53 
  4    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  4    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  4    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  4    57 
  4    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  4    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  4    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  4    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  4    62 
  4    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   346 
  2   347 
  2   348 
  2   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   350 	/*									*/
  2   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  2   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  2   353 	/* that:		mod (type, 2) = 1;						*/
  2   354 	/*									*/
  2   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   356 
  2   357 
  2   358      dcl (Tlink			init (0),
  2   359 	Tsegment			init (1),
  2   360 	Tdirectory		init (2),
  2   361 	Tmsf			init (3),
  2   362 	Tmsf_comp			init (4),
  2   363 	Tarchive			init (5),
  2   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  2   365 
  2   366 
  2   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   368 	/*									*/
  2   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  2   370 	/* Both brief and long string arrays are provided.				*/
  2   371 	/*									*/
  2   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   373 
  2   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  2   375 				"link",
  2   376 				"segment",
  2   377 				"directory",
  2   378 				"multisegment file",
  2   379 				"multi-segment file component",
  2   380 				"archive",
  2   381 				"archive component"),
  2   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  2   383 				"link",
  2   384 				"segment",
  2   385 				"directory",
  2   386 				"msf",
  2   387 				"msf comp",
  2   388 				"archive",
  2   389 				"arch comp");
  2   390 
  2   391 
  2   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1198 
     1199 
     1200 
  5     1 /* START OF:	lib_commands_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* N__a_m_e:  lib_commands_.incl.pl1						*/
  5     6 	/*									*/
  5     7 	/*      This include segment defines the names of all commands which use library 	*/
  5     8 	/* descriptor segments.  These descriptor segments are the data base of the Multics	*/
  5     9 	/* library maintenance tools.  As such, the commands are referred to collectively as	*/
  5    10 	/* library descriptor commands.  The include segment also defines the command index value	*/
  5    11 	/* associated with each command.  This is used to index into some of the arrays of the	*/
  5    12 	/* library descriptor.							*/
  5    13 	/*									*/
  5    14 	/* S__t_a_t_u_s									*/
  5    15 	/*									*/
  5    16 	/* 0) Created by:  G. C. Dixon  in  January, 1975					*/
  5    17 	/*									*/
  5    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    19 
  5    20 
  5    21      dcl	library_info		fixed bin int static init (1),
  5    22 	library_map		fixed bin int static init (2),
  5    23 	library_print		fixed bin int static init (3),
  5    24 	library_fetch		fixed bin int static init (4),
  5    25 	library_cleanup		fixed bin int static init (5);
  5    26 						/* index into command_default_values of info	*/
  5    27 						/*    structure for commands which reference the	*/
  5    28 						/*    library descriptor.			*/
  5    29      dcl	command_name (5)		char(16) varying int static options(constant) init (
  5    30 				     "library_info", "library_map", "library_print",
  5    31 				     "library_fetch", "library_cleanup"),
  5    32 	command_abbrev (5)		char(4) varying int static options(constant) init (
  5    33 				     "li", "lm", "lpr", "lf", "lcln");
  5    34 						/* names and abbreviations of lib maint. commands.*/
  5    35 
  5    36 /* END OF:	lib_commands_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1201 
     1202 
     1203 	end multics_library_search_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/10/84  1004.2  multics_library_search_.pl1       >special_ldd>on>6770>multics_library_search_.pl1
18           1    02/16/84  0928.6  lib_based_args_.incl.pl1          >ldd>include>lib_based_args_.incl.pl1
1198         2    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
2-341        3    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
2-346        4    02/16/84  0928.6  lib_Scontrol_.incl.pl1            >ldd>include>lib_Scontrol_.incl.pl1
1201         5    02/28/77  1409.3  lib_commands_.incl.pl1            >ldd>include>lib_commands_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                                      based           structure                level 1 unaligned dcl 60
APexclude                              parameter       pointer                  dcl 19 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 497 664 706 1074*
APstarname                             parameter       pointer                  dcl 19 ref 112 112 112 124 124 124 136 136 136 148
                                                                                  148 148 466 466 475 476 497 664 706 779 1186
AScontrol                              parameter       bit(36)                  dcl 19 ref 112 112 112 117 124 124 124 129 136 136
                                                                                  136 141 148 148 148 153 497 500 664 667 706 709
                                                                                  1188
ASrequirements                         parameter       bit(72)                  dcl 19 ref 112 112 112 124 124 124 136 136 136 148
                                                                                  148 148 234 296 323 373 399 433 497 664 706 1187
Acode                                  parameter       fixed bin(35,0)          dcl 19 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 497 664 706 812* 823* 827* 828*
Adirector                              parameter       entry variable           dcl 19 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 497 664 706 1074*
C                        11            based           fixed bin(35,0)          array level 3 in structure "starname" dcl 1-32
                                                                                  in procedure "multics_library_search_" ref 252 534
                                                                                  618
C                         4            based           fixed bin(35,0)          level 3 in structure "Dnodes" dcl 2-245 in procedure
                                                                                  "multics_library_search_" ref 828 828 1078
C                        11     000105 automatic       fixed bin(35,0)          level 2 in structure "auto_star" dcl 36 in procedure
                                                                                  "multics_library_search_" set ref 739*
Dnames                                 based           structure                level 1 unaligned dcl 2-230
Dnodes                                 based           structure                level 1 unaligned dcl 2-245
Dnodes_                                based           structure                level 1 dcl 1094
N                               000105 automatic       fixed bin(17,0)          level 2 in structure "auto_star" dcl 36 in procedure
                                                                                  "multics_library_search_" set ref 737*
N                         5            based           fixed bin(17,0)          level 3 in structure "Dnodes_" dcl 1094 in procedure
                                                                                  "node_outputable" ref 1140 1142
N                                      based           fixed bin(17,0)          level 2 in structure "starname" dcl 1-32
                                                                                  in procedure "multics_library_search_" ref 466 475
                                                                                  533 549 617 730 734 758
N                         4            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 2-230 in procedure
                                                                                  "multics_library_search_" ref 480 480 532 616 1160
                                                                                  1160
PA                                     parameter       pointer                  dcl 19 set ref 112 112 112 118 119 124 124 124 130
                                                                                  131 136 136 136 142 143 148 148 148 154 155 164
                                                                                  165 174 175 184 185 194 195 206 212* 213 216 232
                                                                                  239 240 241 244 250 251 260 262 270 276 294 308
                                                                                  321 328 330 331 356 371 388 397 405 410 416 421
                                                                                  431 462 497 501 502 514 514 517 518 519 530 548
                                                                                  560 561 567 570 572 573 574 577 582 585 614 632
                                                                                  635 637 638 639 642 664 668 669 681 681 684 706
                                                                                  710 711 722 722 725 726 727 728 730 755 763 764
                                                                                  772 773 774 777 779 787 826 826 827 1065 1066 1069
                                                                                  1074* 1182 1183 1184 1185* 1186 1187 1187 1191
                                                                                  1192
PA_saved                        000102 automatic       pointer                  dcl 19 set ref 212 1184*
PD                        2            based           pointer                  level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "multics_library_search_" set ref 344 345* 348*
                                                                                  473 528 612 756 1158
PD                        2            based           pointer                  level 2 in structure "node_" dcl 1094 in procedure
                                                                                  "node_outputable" ref 1121 1138
PDnames                         000136 automatic       pointer                  dcl 2-230 set ref 473* 473* 474 480 480 482 528*
                                                                                  528* 529 532 536 539 554 612* 612* 613 616 620 623
                                                                                  756* 756* 757 759 1158* 1158* 1159 1160 1160 1162
PDnodes                                parameter       pointer                  dcl 2-245 set ref 112 112 112 124 124 124 136 136
                                                                                  136 148 148 148 344 345 348 349 497 561* 664 706
                                                                                  828 828 828 833 835* 1074* 1077 1078
PDnodes_                        000100 automatic       pointer                  dcl 1091 set ref 1121* 1121* 1122 1123 1123 1138*
                                                                                  1138* 1139 1140 1140 1140 1142
Parea                                  parameter       pointer                  dcl 19 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 497 664 706 1074*
Pnext                     2            based           pointer                  level 2 in structure "Dnames" dcl 2-230 in procedure
                                                                                  "multics_library_search_" ref 474 529 613 757 1159
Pnext                     2            based           pointer                  level 3 in structure "Dnodes_" dcl 1094 in procedure
                                                                                  "node_outputable" ref 1122 1139
Pnext                     2            based           pointer                  level 3 in structure "Dnodes" dcl 2-245 in procedure
                                                                                  "multics_library_search_" set ref 344* 348 349*
Pnode                                  parameter       pointer                  dcl 2-69 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 200 205 227 227 229 231 232 232 232
                                                                                  236 247 253 254 255 257 263 264 267 270 285 289
                                                                                  291 292 293 294 294 294 300 301 302 315 315 317
                                                                                  317* 320 321 321 321 325 333* 335 339 342 344 345
                                                                                  346 347* 348 350 361 365 365* 368 369 370 371 371
                                                                                  371 376 377 378 395 396 397 397 397 402 407 413
                                                                                  416 426 426 428 429 430 431 431 431 437 438 439
                                                                                  455 461 473 487 488 489 497 513 516 524 528 546
                                                                                  566 570 585 587 591 595 602 606 609 609 611 612
                                                                                  630 635 648 651* 653 664 680 683 688 695 697* 706
                                                                                  721 724 750 756 768 789 796 801 826 1074* 1158
Pnode_                                 parameter       pointer                  dcl 1089 ref 1086 1105 1105 1107 1108 1110 1111 1112
                                                                                  1116 1119 1119 1121 1127 1127 1131 1136 1136 1138
Pparent                                based           pointer                  level 2 dcl 2-69 ref 227 291 300 315 368 376 428 437
                                                                                  591 602 648
Pstar                     2            based           pointer                  level 2 dcl 60 set ref 239 251 328 405 530 582 614
                                                                                  642 728 755 779 787 1069 1186*
Pstarname                       000100 automatic       pointer                  dcl 1-40 set ref 237* 239* 251* 252 326* 328* 403*
                                                                                  405* 520* 530* 533 534 536 539 549 550 552 553
                                                                                  580* 582* 614* 617 618 620 623 640* 642* 728* 730
                                                                                  730 734 738 740* 743* 755* 758 759 782* 787* 1069*
                                                                                  1074*
S                                      based           structure                level 1 dcl 3-96 set ref 866* 889* 904* 922* 932*
                                                                                  946*
Sc                                     based           structure                level 1 dcl 4-20
Scontrol                        000142 automatic       bit(36)                  dcl 4-20 in procedure "multics_library_search_" set
                                                                                  ref 117* 118 129* 130 141* 142 153* 154 216* 225
                                                                                  232 237 241 241 248 257 260 260 276* 294 308* 313
                                                                                  321 326 331 356* 371 388* 393 397 399 403 407 411
                                                                                  421* 431 500* 501 517* 519 548* 558 572* 574 574
                                                                                  580 587 637* 639 640 667* 668 709* 710 725* 727
                                                                                  772* 774 774 781 789 827 982* 983 984 985 986 987
                                                                                  988 989 990 994* 995 996 997* 998 999 1000* 1001
                                                                                  1002 1003 1004 1005 1006 1012* 1013 1014 1015 1016
                                                                                  1017 1018 1019 1021* 1022 1023 1024 1025 1026
                                                                                  1027* 1028 1029 1030 1036* 1037 1038 1039 1040
                                                                                  1041 1042* 1043 1044 1045 1046 1047 1048 1065*
                                                                                  1067 1074* 1188* 1189* 1189 1190* 1190 1191
Scontrol                  6            based           bit(36)                  level 2 in structure "A" dcl 60 in procedure
                                                                                  "multics_library_search_" set ref 216 276 308 356
                                                                                  388 421 517 548 572 637 725 772 1065 1191*
Sinit                           000010 internal static bit(1)                   initial dcl 76 set ref 159 169 179 189 450 512 673
                                                                                  720 1050*
Smode                    11            based           bit(3)                   level 3 packed unaligned dcl 1094 ref 1107
Soutputable                     000104 automatic       bit(1)                   dcl 36 set ref 347* 351
Sreq                                   based           structure                level 1 dcl 2-343 in procedure
                                                                                  "multics_library_search_"
Sreq                      6            based           bit(72)                  level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "multics_library_search_" set ref 205* 227 232*
                                                                                  232 247 253 254 255 257 263 264 267* 285 294* 294
                                                                                  315 321* 321 335* 339* 361 371* 371 397* 397 407
                                                                                  413* 426 431* 431 461* 516* 566* 585* 587* 595 606
                                                                                  609* 653 683* 724* 768* 789* 801 826
Sreq                      4            based           bit(72)                  level 2 in structure "A" dcl 60 in procedure
                                                                                  "multics_library_search_" set ref 240 250 262 330
                                                                                  410 518 573 638 726 773 1066 1187*
Sreq_archive_comp_no_parent     000077 internal static bit(72)                  array dcl 76 set ref 244 331 567* 577 632* 639 764*
                                                                                  777 962* 963* 964* 971*
Sreq_archive_comp_parent        000065 internal static bit(72)                  array dcl 76 set ref 241 560* 574 774 954* 956* 958*
                                                                                  959*
Sreq_link                       000123 internal static bit(72)                  array dcl 76 set ref 232 294 321 371 397 431 934*
                                                                                  936* 937* 938* 939*
Sreq_msf_comp                   000111 internal static bit(72)                  array dcl 76 set ref 270* 343* 416* 941* 942* 943*
                                                                                  944*
Sreq_offline_seg                000135 internal static bit(72)                  array dcl 76 set ref 519 684* 727 863* 880* 902*
                                                                                  920*
Sreq_seg                        000147 internal static bit(72)                  array dcl 76 set ref 206* 411 462* 864* 887* 901*
                                                                                  919* 930* 941 942 943 944 959
Srequirements                   000140 automatic       bit(72)                  dcl 3-96 set ref 240* 241* 241 244* 244 250* 253 254
                                                                                  257 262* 263 264 330* 331* 331 410* 411* 411 518*
                                                                                  519* 519 573* 574* 574 577* 577 638* 639* 639 726*
                                                                                  727* 727 773* 774* 774 777* 777 854* 855 856 857
                                                                                  858 859 860 861 862 863 864 866 867 868 869 870
                                                                                  871 872 873 874 875 876 877 878 879 880 881 882
                                                                                  883 884 885 886 887 889 890 891 892 893 894 895
                                                                                  896 897 898 899 900 901 902 904 905 906 907 908
                                                                                  909 910 911 912 913 914 915 916 917 918 919 920
                                                                                  922 923 924 925 926 927 928 929 930 932 933 934
                                                                                  935 936 937 938 939 946 947 948 949 950 951 952
                                                                                  953 954 955 956 957 958 960 961 962 963 964 965
                                                                                  966 967 968 969 970 971 974* 975 976 977 978 979
                                                                                  1066* 1067* 1067 1074*
Svalid                                 based           structure                level 1 dcl 2-343 in procedure
                                                                                  "multics_library_search_"
Svalid                                 based           structure                level 1 dcl 1094 in procedure "node_outputable"
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "multics_library_search_" set ref 232 294 321 346
                                                                                  350 371 397 431 524 611
Svalid                    4            based           bit(72)                  level 2 in structure "node_" dcl 1094 in procedure
                                                                                  "node_outputable" set ref 1111 1112 1119 1127 1136
Svalid_req                             based           structure                level 1 dcl 3-23
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 2-230 in procedure
                                                                                  "multics_library_search_" ref 473 528 612 756 1158
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "multics_library_search_" ref 200 227 229 231 236
                                                                                  270 289 291 292 293 300 301 302 315 317 320 325
                                                                                  342 365 368 369 370 376 377 378 395 396 402 416
                                                                                  426 428 429 430 437 438 439 455 487 488 489 513
                                                                                  546 570 591 602 609 630 635 648 680 688 695 721
                                                                                  750 796
T                        10            based           fixed bin(35,0)          level 2 in structure "node_" dcl 1094 in procedure
                                                                                  "node_outputable" ref 1105 1116 1119 1127 1131
                                                                                  1136
T                         1            based           fixed bin(17,0)          level 3 in structure "Dnodes_" dcl 1094 in procedure
                                                                                  "node_outputable" ref 1121 1138
Tarchive                               constant        fixed bin(17,0)          initial dcl 2-358 ref 236 325 402 546 570 591 602
                                                                                  609 630 635 648 750 1127
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 2-358 ref 289 365 426 488 796 1131
Tdirectory                             constant        fixed bin(17,0)          initial dcl 2-358 ref 200 455 487 513 680 721
Tlink                                  constant        fixed bin(17,0)          initial dcl 2-358 ref 227 231 293 300 302 315 320
                                                                                  370 376 378 396 430 437 439 1119
Tmsf                                   constant        fixed bin(17,0)          initial dcl 2-358 ref 270 291 342 368 416 428 1136
Tmsf_comp                              constant        fixed bin(17,0)          initial dcl 2-358 ref 292 369 429 489 1116
Tnames                                 constant        fixed bin(17,0)          initial dcl 2-230 ref 473 528 612 756 1158
Tnodes                                 constant        fixed bin(17,0)          initial dcl 2-245 ref 1121 1138
Tsegment                               constant        fixed bin(17,0)          initial dcl 2-358 ref 229 301 317 377 395 438 688
                                                                                  695 1105
V                         1            based           char(32)                 array level 3 in structure "starname" packed
                                                                                  unaligned dcl 1-32 in procedure
                                                                                  "multics_library_search_" set ref 466 476 536 539*
                                                                                  550* 552 553 620 623* 730* 738 759
V                         1     000105 automatic       char(32)                 level 2 in structure "auto_star" packed unaligned
                                                                                  dcl 36 in procedure "multics_library_search_" set
                                                                                  ref 553* 554* 738*
acl                                    based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 985*
addr                                                   builtin function         dcl 64 ref 118 130 142 154 225 227 232 237 237 241
                                                                                  241 247 248 253 253 254 254 255 257 257 257 260
                                                                                  260 263 263 264 264 285 294 313 315 321 326 326
                                                                                  331 346 350 361 371 393 397 399 403 403 407 407
                                                                                  411 426 431 501 519 520 524 558 574 574 580 580
                                                                                  587 595 606 611 639 640 640 653 668 710 727 740
                                                                                  743 774 774 781 782 789 801 827 855 856 857 858
                                                                                  859 860 861 862 866 867 868 869 870 871 872 873
                                                                                  874 875 876 877 878 879 881 882 883 884 885 886
                                                                                  889 890 891 892 893 894 895 896 897 898 899 900
                                                                                  904 905 906 907 908 909 910 911 912 913 914 915
                                                                                  916 917 918 922 923 924 925 926 927 928 929 932
                                                                                  933 935 946 947 948 949 950 951 952 953 955 957
                                                                                  960 961 965 966 967 968 969 970 975 983 984 985
                                                                                  986 987 988 989 995 998 1001 1005 1013 1014 1015
                                                                                  1022 1025 1028 1029 1037 1043 1044 1067 1111 1112
                                                                                  1119 1123 1123 1127 1136 1140 1140 1185
all_status                0(01)        based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 987*
auto_star                       000105 automatic       structure                level 1 unaligned dcl 36 set ref 740
bit_count                 0(24)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  885* 911* 965*
bit_count                43            based           fixed bin(35,0)          level 2 in structure "node_" dcl 1094 in procedure
                                                                                  "node_outputable" ref 1108 1110
chase                     0(02)        based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 399 983*
check_archive             0(03)        based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 989* 1001*
                                                                                  1014* 1022* 1028* 1037*
check_ascii               0(04)        based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 988* 995*
                                                                                  1005* 1015* 1025* 1044*
code                            000117 automatic       fixed bin(35,0)          dcl 36 set ref 482* 483 539* 540 550* 551 554* 555
                                                                                  623* 624 729* 730* 734 742 759* 760 1074* 1162*
                                                                                  1163
command                                based           fixed bin(17,0)          level 2 in structure "A" dcl 60 in procedure
                                                                                  "multics_library_search_" ref 119 131 143 155 164
                                                                                  165 174 175 184 185 194 195 206 232 241 244 260
                                                                                  270 294 321 331 371 397 416 431 462 502 514 514
                                                                                  519 560 561 567 570 574 577 585 632 635 639 669
                                                                                  681 681 684 711 722 722 727 730 763 764 774 777
                                                                                  1182 1187
command                         000122 automatic       fixed bin(17,0)          level 2 in structure "director_args" dcl 36
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  1182*
compiler_options          1            based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 914* 968*
compiler_version          0(35)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 913* 967*
components                0(05)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 237 257 260
                                                                                  326 403 580 640 781
container                 0(06)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 241 248 407
                                                                                  558 574 587 774 789
copy                      0(10)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 874* 897*
                                                                                  910* 928*
cross_ref                 1(33)        based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 2-343 in procedure "multics_library_search_"
                                                                                  set ref 247*
cross_ref                 1(33)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  879* 955* 957* 975*
current_length            0(21)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 882*
default                   0(07)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 232 241 260
                                                                                  294 321 331 371 397 411 431 519 574 639 727 774
                                                                                  1067
default_Sreq                           parameter       bit(72)                  dcl 1062 ref 1059 1067
director_args                   000122 automatic       structure                level 1 unaligned dcl 36 set ref 1185
dtc                       0(33)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 912* 966*
dtd                       0(14)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 881*
dtem                      0(13)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 873* 896*
                                                                                  927* 935* 950*
dtm                       0(16)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 859* 872*
                                                                                  895* 909*
error_return                           parameter       label variable           dcl 1062 ref 1059 1072 1077 1078
error_table_$logical_volume_not_connected
                                000172 external static fixed bin(35,0)          dcl 76 ref 828
error_table_$nomatch            000174 external static fixed bin(35,0)          dcl 76 ref 823 1078
error_table_$process_stopped    000176 external static fixed bin(35,0)          dcl 76 ref 827
error_table_$undefined_order_request
                                000200 external static fixed bin(35,0)          dcl 76 ref 812
first_match               0(22)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 118 130 142
                                                                                  154 501 668 710 827
get_ring_                       000162 constant        entry                    external dcl 68 ref 852
group                     1            based           structure                array level 2 dcl 1-32
header                                 based           structure                level 2 in structure "Dnodes" unaligned dcl 2-245
                                                                                  in procedure "multics_library_search_"
header                                 based           structure                level 2 in structure "Dnodes_" dcl 1094 in procedure
                                                                                  "node_outputable"
i                               000102 automatic       fixed bin(17,0)          dcl 1091 in procedure "node_outputable" set ref
                                                                                  1140* 1140 1140* 1142
i                               000132 automatic       fixed bin(17,0)          dcl 36 in procedure "multics_library_search_" set
                                                                                  ref 475* 476* 480* 482* 532* 536 539* 552* 553
                                                                                  616* 620 623* 758* 759* 1160* 1162*
iacl                      0(08)        based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 986*
index                                                  builtin function         dcl 64 ref 480 552 1160
j                               000133 automatic       fixed bin(17,0)          dcl 36 set ref 533* 534 536 539* 617* 618 620 623*
kids                      0(04)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 2-343 in procedure "multics_library_search_"
                                                                                  set ref 346* 350*
kids                      0(04)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 1094 in procedure "node_outputable" ref 1119
                                                                                  1136
kids_error                0(05)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 862* 878*
                                                                                  900* 918* 929* 953*
level                     1(34)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 860* 876*
                                                                                  898* 916* 951* 970*
lib_free_node_$array            000164 constant        entry                    external dcl 68 ref 561 835
lib_get_tree_                   000166 constant        entry                    external dcl 68 ref 1074
library_fetch                          constant        fixed bin(17,0)          initial dcl 5-21 ref 561 585
library_info                           constant        fixed bin(17,0)          initial dcl 5-21 ref 260 730 763
link_level                             parameter       fixed bin(17,0)          dcl 19 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 497 664 706 1074*
link_target               0(15)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 933*
match_star_name_                000170 constant        entry                    external dcl 68 ref 482 539 550 554 623 730 759 1162
matching_names            0(01)        based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 2-343 in procedure "multics_library_search_"
                                                                                  set ref 254* 264*
matching_names            0(01)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref 254
                                                                                  264 856* 868* 891* 906* 924* 948*
max_Scontrol                    000120 automatic       bit(36)                  dcl 36 in procedure "multics_library_search_" set
                                                                                  ref 165* 175* 185* 195* 203* 457* 459*
max_Scontrol                           parameter       bit(36)                  dcl 1179 in procedure "set_director_args" ref 1171
                                                                                  1189
max_Srequirements               000011 internal static bit(72)                  array dcl 76 set ref 973* 976* 977* 978* 979* 1187
max_cleanup_Scontrol            000023 internal static bit(36)                  dcl 76 set ref 457 990*
max_exec_Scontrol               000025 internal static bit(36)                  array dcl 76 set ref 165 681* 1002* 1003* 1004*
                                                                                  1006*
max_length                0(22)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 884*
max_list_info_Scontrol          000031 internal static bit(36)                  array dcl 76 set ref 175 1016* 1017* 1018* 1019*
max_object_Scontrol             000035 internal static bit(36)                  array dcl 76 set ref 185 514* 1031* 1032* 1033*
                                                                                  1034*
max_source_Scontrol             000041 internal static bit(36)                  array dcl 76 set ref 195 722* 1045* 1046* 1047*
                                                                                  1048*
min_Scontrol                    000121 automatic       bit(36)                  dcl 36 in procedure "multics_library_search_" set
                                                                                  ref 164* 174* 184* 194* 203* 456* 459*
min_Scontrol                           parameter       bit(36)                  dcl 1179 in procedure "set_director_args" ref 1171
                                                                                  1190
min_cleanup_Scontrol            000024 internal static bit(36)                  dcl 76 set ref 456 981*
min_exec_Scontrol               000045 internal static bit(36)                  array dcl 76 set ref 164 681* 992* 993* 996* 999*
min_list_info_Scontrol          000051 internal static bit(36)                  array dcl 76 set ref 174 1008* 1009* 1010* 1011*
min_object_Scontrol             000055 internal static bit(36)                  array dcl 76 set ref 184 514* 1023* 1024* 1026*
                                                                                  1030*
min_source_Scontrol             000061 internal static bit(36)                  array dcl 76 set ref 194 722* 1038* 1039* 1040*
                                                                                  1041*
mod                                                    builtin function         dcl 64 ref 1110
n_found                   1            based           fixed bin(17,0)          level 2 in structure "A" dcl 60 in procedure
                                                                                  "multics_library_search_" set ref 118 130 142 154
                                                                                  213* 501 668 710 826* 826 827 1183
n_found                   1     000122 automatic       fixed bin(17,0)          level 2 in structure "director_args" dcl 36
                                                                                  in procedure "multics_library_search_" set ref 213
                                                                                  1183*
names                     0(02)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 2-343 in procedure "multics_library_search_"
                                                                                  ref 524 611
names                     0(02)        based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 2-343 in procedure "multics_library_search_"
                                                                                  set ref 253* 257* 263* 285* 361* 595* 653* 801*
names                     5            based           char(32)                 array level 2 in structure "Dnames" packed unaligned
                                                                                  dcl 2-230 in procedure "multics_library_search_"
                                                                                  set ref 480 482* 536 539* 554* 620 623* 759* 1160
                                                                                  1162*
names                     0(02)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref 253
                                                                                  257 263 869* 892* 949*
new_line                  1(35)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 861* 877*
                                                                                  899* 917* 952*
node                                   based           structure                level 1 unaligned dcl 2-69
node_                                  based           structure                level 1 dcl 1094
nodes                     6            based           structure                array level 2 dcl 1094 set ref 1123 1123 1140 1140
not_ascii                 1(02)        based           bit(1)                   level 2 packed unaligned dcl 1094 ref 1112 1127
null                                                   builtin function         dcl 64 ref 349 828 833 1077
object_info               1(01)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  915* 969*
object_info               1(01)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 1094 in procedure "node_outputable" ref 1111
object_info               0(09)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 4-20
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  984* 998* 1013* 1029* 1043*
path                                   parameter       varying char(168)        dcl 15 set ref 112 112 112 124 124 124 136 136 136
                                                                                  148 148 148 497 664 706 1074*
pathname                  0(03)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 858* 871*
                                                                                  894* 908* 926* 961*
primary_name                           based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 2-343 in procedure "multics_library_search_"
                                                                                  set ref 227* 255* 315* 407* 426* 606*
primary_name                           based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  855* 867* 890* 905* 923* 947*
rb                        0(18)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 3-96
                                                                                  in procedure "multics_library_search_" set ref
                                                                                  886*
rb                       31            based           fixed bin(3,0)           array level 2 in structure "node_" dcl 1094
                                                                                  in procedure "node_outputable" ref 1105
records_used              0(20)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 883*
retain                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 225 313 393
reverse                                                builtin function         dcl 64 ref 552
ring                            000161 internal static fixed bin(6,0)           dcl 76 set ref 852* 1105
safety                    0(08)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 875*
search_type                     000134 automatic       fixed bin(17,0)          dcl 36 in procedure "multics_library_search_" set
                                                                                  ref 202* 203* 458* 459* 506* 514* 678* 681* 714*
                                                                                  722*
search_type                            parameter       fixed bin(17,0)          dcl 1179 in procedure "set_director_args" ref 1171
                                                                                  1192
search_type               7            based           fixed bin(17,0)          level 2 in structure "A" dcl 60 in procedure
                                                                                  "multics_library_search_" set ref 1192*
starname                               based           structure                level 1 dcl 1-32
starstar                        000000 constant        structure                level 1 unaligned dcl 76 set ref 237 326 403 520 580
                                                                                  640 743 782
string                                                 builtin function         dcl 64 set ref 480 866* 889* 904* 922* 932* 946*
                                                                                  1160
substr                                                 builtin function         dcl 64 ref 553 738 759 1107
switches                 11            based           structure                level 2 packed unaligned dcl 1094
tree_level                             parameter       fixed bin(17,0)          dcl 19 set ref 112 112 112 119 124 124 124 131 136
                                                                                  136 136 143 148 148 148 155 497 502 570 635 664
                                                                                  669 706 711 1074*
type                      0(06)        based           bit(1)                   level 2 packed unaligned dcl 3-96 set ref 857* 870*
                                                                                  893* 907* 925* 960*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 2-146
Dacl                                   based           structure                level 1 unaligned dcl 2-153
Ddir_acl                               based           structure                level 1 unaligned dcl 2-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 2-190
Diacl                                  based           structure                level 1 unaligned dcl 2-209
Dobj                                   based           structure                level 1 unaligned dcl 2-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 2-311
Duser                                  based           structure                level 1 unaligned dcl 2-324
Luser                                  automatic       fixed bin(17,0)          dcl 2-324
Nacls                                  automatic       fixed bin(17,0)          dcl 2-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 2-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 2-190
Niacls                                 automatic       fixed bin(17,0)          dcl 2-209
Nnames                                 automatic       fixed bin(17,0)          dcl 2-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 2-245
PD                                     automatic       pointer                  dcl 2-146
PDacl                                  automatic       pointer                  dcl 2-153
PDdir_acl                              automatic       pointer                  dcl 2-172
PDdir_iacl                             automatic       pointer                  dcl 2-190
PDiacl                                 automatic       pointer                  dcl 2-209
PDobj                                  automatic       pointer                  dcl 2-263
PDsearch_proc                          automatic       pointer                  dcl 2-311
PDuser                                 automatic       pointer                  dcl 2-324
Pexclude                               automatic       pointer                  dcl 1-50
Plibrary                               automatic       pointer                  dcl 1-29
Tacl                                   internal static fixed bin(17,0)          initial dcl 2-153
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 2-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 2-190
Tiacl                                  internal static fixed bin(17,0)          initial dcl 2-209
Tobj                                   internal static fixed bin(17,0)          initial dcl 2-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 2-311
Tuser                                  internal static fixed bin(17,0)          initial dcl 2-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 2-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 2-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 2-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 2-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 2-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 2-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 2-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 2-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 2-324
brief_node_type                        internal static varying char(12)         initial array dcl 2-374
command_abbrev                         internal static varying char(4)          initial array dcl 5-29
command_name                           internal static varying char(16)         initial array dcl 5-29
exclude                                based           structure                level 1 dcl 1-42
library                                based           structure                level 1 dcl 1-22
library_cleanup                        internal static fixed bin(17,0)          initial dcl 5-21
library_map                            internal static fixed bin(17,0)          initial dcl 5-21
library_print                          internal static fixed bin(17,0)          initial dcl 5-21
link_node                              based           structure                level 1 unaligned dcl 2-30
node_type                              internal static varying char(32)         initial array dcl 2-374

NAMES DECLARED BY EXPLICIT CONTEXT.
arch_comp                       005644 constant        label                    dcl 1108 ref 1131
bc_match                        003373 constant        label                    dcl 570 ref 536 540 543
bc_nomatch                      003154 constant        label                    dcl 544 ref 537 541
bc_nonames                      003160 constant        label                    dcl 546 ref 524
bc_pr_match                     003706 constant        label                    dcl 635 ref 620 624 627
bc_pr_nomatch                   003654 constant        label                    dcl 628 ref 621 625
bc_pr_nonames                   003660 constant        label                    dcl 630 ref 611
bc_pr_test                      000414 constant        label                    array(0:2) dcl 620 ref 618
bc_test                         000411 constant        label                    array(0:2) dcl 536 ref 534
chase_searchdir23               001542 constant        label                    dcl 294 ref 302
chase_searchdir33               002143 constant        label                    dcl 371 ref 378
chase_searchdir43               002421 constant        label                    dcl 431 ref 439
execdir                         000012 constant        label                    array(11:61) dcl 159 ref 119
execution_dirs                  000650 constant        entry                    external dcl 112
hardcore_bc_dir                 002720 constant        entry                    external dcl 497
hardcore_object_dir             004011 constant        entry                    external dcl 664
hardcore_source_dir             004145 constant        entry                    external dcl 706
hbd                             000326 constant        label                    array(11:61) dcl 506 ref 502
hod                             000417 constant        label                    array(11:61) dcl 673 ref 669
hs_match                        004454 constant        label                    dcl 763 ref 760
hsd                             000502 constant        label                    array(11:61) dcl 714 ref 711
init_vars                       004677 constant        entry                    internal dcl 842 ref 159 169 179 189 450 512 673 720
list_info_dirs                  000716 constant        entry                    external dcl 124
lsinfodir                       000075 constant        label                    array(11:61) dcl 169 ref 131 570 635
msf_comp                        005630 constant        label                    dcl 1105 ref 1116
multics_library_search_         000631 constant        entry                    external dcl 13
next_tree_level                 005501 constant        entry                    internal dcl 1059 ref 206 234 270 296 323 343 373
                                                                                  399 416 433 462 560 567 632 684 764
next_tree_level_special         005530 constant        entry                    internal dcl 1072 ref 246 334 338 412 521 584 644
                                                                                  745 783 788
node_outputable                 005615 constant        entry                    internal dcl 1086 ref 317 333 347 365 651 697 1123
                                                                                  1140
objdir                          000160 constant        label                    array(11:61) dcl 179 ref 143
object_dirs                     000764 constant        entry                    external dcl 136
obsolete                        002703 constant        label                    dcl 487 ref 466 478 483
offline_execution_dirs          000670 constant        entry                    external dcl 112
offline_list_info_dirs          000736 constant        entry                    external dcl 124
offline_object_dirs             001004 constant        entry                    external dcl 136
offline_source_dirs             001052 constant        entry                    external dcl 148
online_execution_dirs           000660 constant        entry                    external dcl 112
online_level_1                  001161 constant        label                    dcl 200 ref 166 176 186 196
online_list_info_dirs           000726 constant        entry                    external dcl 124
online_object_dirs              000774 constant        entry                    external dcl 136
online_source_dirs              001042 constant        entry                    external dcl 148
reject                          004614 constant        label                    dcl 823 ref 118 130 142 154 200 206 206 270 293 300
                                                                                  303 317 323 323 338 338 342 351 365 376 416 430
                                                                                  437 440 455 462 462 485 487 488 489 501 513 521
                                                                                  521 546 555 560 560 567 567 591 602 630 632 632
                                                                                  644 644 648 651 668 680 684 684 688 695 697 710
                                                                                  721 745 745 750 762 764 764 788 788 796 1163
reject_node_if_obsolete         006036 constant        entry                    internal dcl 1154 ref 226 314 394
return                          004621 constant        label                    dcl 826 ref 214 234 234 270 270 273 296 296 306 343
                                                                                  343 354 373 373 381 399 399 412 412 416 416 419
                                                                                  433 433 443 463 490 522 569 589 599 607 633 645
                                                                                  657 686 692 699 747 783 783 793 805 821 836
searchdir                       000243 constant        label                    array(11:61) dcl 189 ref 155
set_director_args               006141 constant        entry                    internal dcl 1171 ref 203 459 514 681 722
source_dirs                     001032 constant        entry                    external dcl 148
suppress_nomatch                004661 constant        label                    dcl 833 ref 246 246 334 334 584 584
test                            002615 constant        label                    dcl 480 ref 476

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6572        6774    6245        6602
Length      7414    6245       202         404     325         152

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
multics_library_search_             219 external procedure  is an external procedure.  
init_vars                               internal procedure  shares stack frame of external procedure multics_library_search_.  
next_tree_level                         internal procedure  shares stack frame of external procedure multics_library_search_.  
node_outputable                      80 internal procedure  calls itself recursively.  
reject_node_if_obsolete                 internal procedure  shares stack frame of external procedure multics_library_search_.  
set_director_args                       internal procedure  shares stack frame of external procedure multics_library_search_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 Sinit                       multics_library_search_
000011 max_Srequirements           multics_library_search_
000023 max_cleanup_Scontrol        multics_library_search_
000024 min_cleanup_Scontrol        multics_library_search_
000025 max_exec_Scontrol           multics_library_search_
000031 max_list_info_Scontrol      multics_library_search_
000035 max_object_Scontrol         multics_library_search_
000041 max_source_Scontrol         multics_library_search_
000045 min_exec_Scontrol           multics_library_search_
000051 min_list_info_Scontrol      multics_library_search_
000055 min_object_Scontrol         multics_library_search_
000061 min_source_Scontrol         multics_library_search_
000065 Sreq_archive_comp_parent    multics_library_search_
000077 Sreq_archive_comp_no_parent multics_library_search_
000111 Sreq_msf_comp               multics_library_search_
000123 Sreq_link                   multics_library_search_
000135 Sreq_offline_seg            multics_library_search_
000147 Sreq_seg                    multics_library_search_
000161 ring                        multics_library_search_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
multics_library_search_  000100 Pstarname                   multics_library_search_
                         000102 PA_saved                    multics_library_search_
                         000104 Soutputable                 multics_library_search_
                         000105 auto_star                   multics_library_search_
                         000117 code                        multics_library_search_
                         000120 max_Scontrol                multics_library_search_
                         000121 min_Scontrol                multics_library_search_
                         000122 director_args               multics_library_search_
                         000132 i                           multics_library_search_
                         000133 j                           multics_library_search_
                         000134 search_type                 multics_library_search_
                         000136 PDnames                     multics_library_search_
                         000140 Srequirements               multics_library_search_
                         000142 Scontrol                    multics_library_search_
node_outputable          000100 PDnodes_                    node_outputable
                         000102 i                           node_outputable

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_label_var       mod_fx1             shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_ring_                     lib_free_node_$array          lib_get_tree_                 match_star_name_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$logical_volume_not_connected                   error_table_$nomatch          error_table_$process_stopped
error_table_$undefined_order_request




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000630       112 000636       117 000675       118 000700       119 000707       124 000714       129 000743
    130 000746       131 000755       136 000762       141 001011       142 001014       143 001023       148 001030
    153 001057       154 001062       155 001071       159 001076       164 001101       165 001107       166 001111
    169 001112       174 001116       175 001124       176 001126       179 001127       184 001133       185 001141
    186 001143       189 001144       194 001150       195 001156       196 001160       200 001161       202 001166
    203 001170       205 001172       206 001200       212 001217       213 001222       214 001226       216 001227
    225 001234       226 001240       227 001241       229 001252       231 001257       232 001261       234 001301
    235 001312       236 001313       237 001315       239 001323       240 001327       241 001335       244 001353
    246 001362       247 001367       248 001374       250 001401       251 001406       252 001410       253 001413
    254 001417       255 001423       256 001425       257 001426       259 001435       260 001436       262 001450
    263 001454       264 001460       266 001464       267 001465       269 001470       270 001471       273 001512
    276 001513       285 001520       289 001524       291 001530       292 001534       293 001540       294 001542
    296 001565       299 001577       300 001600       301 001602       302 001606       303 001610       306 001611
    308 001612       313 001617       314 001623       315 001624       317 001635       320 001655       321 001657
    323 001677       324 001710       325 001711       326 001713       328 001721       330 001725       331 001733
    333 001745       334 001760       335 001765       336 001773       338 001774       339 002001       341 002007
    342 002010       343 002012       344 002026       345 002035       346 002042       347 002046       348 002056
    349 002065       350 002071       351 002075       354 002100       356 002101       361 002106       365 002112
    368 002131       369 002135       370 002141       371 002143       373 002166       375 002200       376 002201
    377 002203       378 002207       381 002211       388 002212       393 002217       394 002223       395 002224
    396 002233       397 002235       399 002255       401 002271       402 002272       403 002274       405 002304
    407 002310       410 002316       411 002324       412 002334       413 002341       415 002347       416 002350
    419 002371       421 002372       426 002377       428 002407       429 002413       430 002417       431 002421
    433 002444       436 002456       437 002457       438 002461       439 002465       440 002467       443 002470
    450 002471       455 002475       456 002503       457 002506       458 002510       459 002512       461 002514
    462 002522       463 002541       466 002542       473 002554       474 002564       475 002567       476 002601
    477 002612       478 002614       480 002615       482 002643       483 002676       484 002700       485 002702
    487 002703       488 002711       489 002713       490 002715       497 002716       500 002725       501 002730
    502 002737       506 002744       512 002746       513 002752       514 002760       516 002775       517 003003
    518 003007       519 003012       520 003024       521 003026       522 003033       524 003034       528 003041
    529 003050       530 003053       532 003060       533 003067       534 003077       536 003103       537 003116
    539 003117       540 003150       541 003152       543 003153       544 003154       545 003156       546 003160
    548 003166       549 003172       550 003175       551 003223       552 003225       553 003242       554 003256
    555 003303       558 003305       560 003310       561 003330       564 003344       566 003345       567 003353
    569 003372       570 003373       572 003406       573 003412       574 003415       577 003433       580 003442
    582 003450       584 003452       585 003457       587 003472       589 003502       591 003503       595 003511
    599 003514       602 003515       606 003523       607 003526       609 003527       611 003537       612 003542
    613 003550       614 003553       616 003560       617 003567       618 003577       620 003603       621 003616
    623 003617       624 003650       625 003652       627 003653       628 003654       629 003656       630 003660
    632 003666       633 003705       635 003706       637 003721       638 003725       639 003730       640 003742
    642 003750       644 003752       645 003757       648 003760       651 003766       653 004001       657 004006
    664 004007       667 004016       668 004021       669 004030       673 004035       678 004041       680 004043
    681 004051       683 004066       684 004074       686 004113       688 004114       692 004121       695 004122
    697 004127       699 004142       706 004143       709 004152       710 004155       711 004164       714 004171
    720 004173       721 004177       722 004205       724 004222       725 004230       726 004234       727 004237
    728 004251       729 004253       730 004255       734 004313       737 004320       738 004322       739 004336
    740 004341       741 004343       742 004344       743 004347       745 004351       747 004356       750 004357
    755 004364       756 004367       757 004376       758 004401       759 004411       760 004447       761 004451
    762 004453       763 004454       764 004461       768 004476       769 004504       772 004505       773 004510
    774 004513       777 004531       779 004540       781 004544       782 004547       783 004551       785 004556
    787 004557       788 004561       789 004566       793 004577       796 004600       801 004605       805 004607
    812 004610       821 004613       823 004614       824 004620       826 004621       827 004633       828 004645
    830 004660       833 004661       835 004667       836 004676       842 004677       852 004700       854 004707
    855 004711       856 004713       857 004715       858 004717       859 004721       860 004723       861 004725
    862 004727       863 004731       864 004735       866 004740       867 004742       868 004744       869 004746
    870 004750       871 004752       872 004754       873 004756       874 004760       875 004762       876 004764
    877 004766       878 004770       879 004772       880 004774       881 004777       882 005001       883 005003
    884 005005       885 005007       886 005011       887 005013       889 005016       890 005020       891 005022
    892 005024       893 005026       894 005030       895 005032       896 005034       897 005036       898 005040
    899 005042       900 005044       901 005046       902 005051       904 005054       905 005056       906 005060
    907 005062       908 005064       909 005066       910 005070       911 005072       912 005074       913 005076
    914 005100       915 005102       916 005104       917 005106       918 005110       919 005112       920 005115
    922 005120       923 005122       924 005124       925 005126       926 005130       927 005132       928 005134
    929 005136       930 005140       932 005143       933 005145       934 005147       935 005152       936 005154
    937 005157       938 005161       939 005163       941 005165       942 005171       943 005175       944 005201
    946 005205       947 005207       948 005211       949 005213       950 005215       951 005217       952 005221
    953 005223       954 005225       955 005230       956 005232       957 005235       958 005237       959 005242
    960 005246       961 005250       962 005252       963 005255       964 005260       965 005263       966 005265
    967 005267       968 005271       969 005273       970 005275       971 005277       973 005302       974 005305
    975 005306       976 005310       977 005313       978 005315       979 005317       981 005321       982 005322
    983 005324       984 005326       985 005330       986 005332       987 005334       988 005336       989 005340
    990 005342       992 005344       993 005345       994 005346       995 005347       996 005351       997 005353
    998 005354       999 005356      1000 005360      1001 005362      1002 005364      1003 005366      1004 005370
   1005 005372      1006 005374      1008 005376      1009 005377      1010 005400      1011 005401      1012 005402
   1013 005404      1014 005406      1015 005410      1016 005412      1017 005414      1018 005415      1019 005416
   1021 005417      1022 005420      1023 005422      1024 005424      1025 005426      1026 005430      1027 005432
   1028 005433      1029 005435      1030 005437      1031 005441      1032 005443      1033 005444      1034 005445
   1036 005446      1037 005447      1038 005451      1039 005453      1040 005455      1041 005457      1042 005461
   1043 005463      1044 005465      1045 005467      1046 005471      1047 005473      1048 005475      1050 005477
   1052 005500      1059 005501      1065 005505      1066 005512      1067 005515      1069 005525      1072 005527
   1074 005534      1077 005574      1078 005603      1081 005613      1086 005614      1105 005622      1107 005640
   1108 005644      1110 005653      1111 005657      1112 005665      1114 005671      1116 005675      1119 005677
   1121 005704      1122 005712      1123 005715      1125 005735      1127 005736      1129 005744      1131 005750
   1136 005752      1138 005757      1139 005766      1140 005771      1141 006021      1142 006023      1145 006033
   1154 006036      1158 006037      1159 006050      1160 006053      1162 006101      1163 006134      1164 006136
   1166 006140      1171 006141      1182 006143      1183 006147      1184 006152      1185 006153      1186 006155
   1187 006160      1188 006175      1189 006177      1190 006201      1191 006203      1192 006205      1194 006207


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
