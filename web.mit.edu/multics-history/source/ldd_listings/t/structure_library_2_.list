	COMPILATION LISTING OF SEGMENT !BBBJZhFzfZCnGN
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 10/25/89  1022.6 mst Wed
	    Options: table map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* format: off */
        9 
       10 /* Modified December 1984 by Bonnie Braun to add io_page_tables. */
       11 /* Modified December 1984 by Eric Swenson for event_channel_name. */
       12 /* Modified December 1984 by Robert Coren to add hc_fast_lock and these notices. */
       13 /* Modified Jan 21 1985 by B. Braun to delete reference to fgbx.incl.pl1 and add reference to flagbox.incl.pl1 */
       14 
       15 
       16 /* HISTORY COMMENTS:
       17*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
       18*     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
       19*     Modified ect_structures to support control point management.  These
       20*     changes were really made in February 1985 by G. Palter.
       21*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7479),
       22*     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
       23*     Recompiled due to ect_structure changes to support async event channels.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 structure_library_2_:
       28      procedure ();
       29 
       30 /* First come all the structures */
       31 
       32 dcl  sp pointer; /* something seems to need this */
       33 
       34 begin; /* There is a conflict with "lock" */
       35    /* Begin include file dir_lock_seg_.incl.pl1 BIM 830312 */
  1     2 /* From dirlockt.incl.pl1 */
  1     3 
  1     4 /* format: style3,idind25,indcomtxt */
  1     5 
  1     6 /**** Several arrays in this program are zero based. The zero-th
  1     7*      entries are NEVER USED. referencers should start at 1, not lbound.
  1     8*      The zero entries are there to improve the compiler's subscript
  1     9*      calculations. The compiler can fetch dir_lock_all_dir_locks (foo).uid
  1    10*      with an lda pr6|FOO,*ql */
  1    11 
  1    12 dcl	dir_lock_seg$	     external static;	/* name of the segment containing the directory locks */
  1    13 
  1    14 dcl	dir_lock_segp	     pointer;		/* pointer to the dirlock table */
  1    15 
  1    16 dcl	1 dir_lock_seg	     based (dir_lock_segp) aligned,
  1    17 	  2 header	     aligned like dir_lock_seg_header,
  1    18 	  2 dir_locks	     (0:dir_lock_seg.header.n_dir_locks) aligned like dir_lock,
  1    19 	  2 readers	     (0:dir_lock_seg.header.n_dir_locks, dir_lock_seg.header.max_readers) bit (36) aligned;
  1    20 
  1    21 declare	(dir_lock_all_locksp, dir_lock_all_readersp)
  1    22 			     pointer;
  1    23 
  1    24 declare	1 dir_lock_all_dir_locks (0:dir_lock_seg.header.n_dir_locks) aligned like dir_lock based (dir_lock_all_locksp);
  1    25 declare	dir_lock_all_readers     (0:dir_lock_seg.header.n_dir_locks, dir_lock_seg.header.max_readers) bit (36)
  1    26 			     aligned based (dir_lock_all_readersp);
  1    27 
  1    28 declare	DIR_LOCK_SEG_EVENT	     char (4) aligned init ("drls") int static options (constant);
  1    29 
  1    30 declare	1 dir_lock_seg_header    aligned based,
  1    31 	  2 seg_lock	     aligned like lock,
  1    32 	  2 n_dir_locks	     fixed bin,		/* max number */
  1    33 	  2 highest_in_use	     fixed bin,
  1    34 	  2 max_readers	     fixed bin,
  1    35 	  2 pad_even	     bit (36) aligned,
  1    36 	  2 readers_ptr	     pointer,
  1    37 	  2 locks_ptr	     pointer,
  1    38 	  2 meters	     aligned,
  1    39 	    3 find_calls	     fixed bin (35),
  1    40 	    3 find_failures	     fixed bin (35),
  1    41 	    3 max_in_use	     fixed bin (35),
  1    42 	    3 pad_meters	     fixed bin (35),
  1    43 	  2 pad		     (16) bit (36) aligned;	/* to 32 */
  1    44 
  1    45 declare	dir_lockp		     pointer;
  1    46 declare	1 dir_lock	     aligned based (dir_lockp),
  1    47 	  2 uid		     bit (36) aligned,
  1    48 	  2 flags		     aligned,
  1    49 	    3 notify_sw	     bit (1) unaligned,
  1    50 	    3 salvage_sw	     bit (1) unaligned,	/* ON if dir was locked for salvage */
  1    51 	    3 pad		     bit (34) unaligned,
  1    52 	  2 lock_count	     fixed bin (17),	/* POSITIVE --> write_lock */
  1    53 						/* NEGATIVE --> -number of lockers */
  1    54 						/* ZERO --> not locked */
  1    55 	  2 write_locker	     bit (36) aligned;	/* in case of read, see next declaration, and expect this 0 */
  1    56 
  1    57 declare	dir_read_lockers_ptr     pointer;
  1    58 declare	dir_read_lockers	     (dir_lock_seg.header.max_readers) bit (36) aligned based (dir_read_lockers_ptr);
  1    59 
  1    60 /* End include file dir_lock_seg_.incl.pl1 */
       35 
       36    /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  2     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  2     3*   encourages name conflicts.
  2     4*   USE HC_FAST_LOCK INSTEAD!
  2     5**/
  2     6 
  2     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     8 
  2     9 /* format: style3 */
  2    10 
  2    11 declare	lock_ptr		pointer;
  2    12 declare	1 lock		aligned based (lock_ptr),
  2    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    15 	  2 flags		aligned,
  2    16 	    3 notify_sw	bit (1) unaligned,
  2    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    18 
  2    19 /* End include file hc_lock.incl.pl1 */
       36 
       37       call add ("dir_lock_seg", addr (p -> dir_lock_seg));
       38       call add ("dir_lock_seg_header", addr (p -> dir_lock_seg_header));
       39       call add ("dir_lock", addr (p -> dir_lock));
       40       dcl 1 fast_lock aligned like lock based;
       41       call add ("fast_lock", addr (p -> fast_lock));
       42    end;
  3     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  3     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  3     7*     Add support for subvolumes.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 
  3    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  3    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  3    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  3    14 
  3    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  3    16 
  3    17 dcl  dtp ptr,
  3    18      dtep ptr,
  3    19      lvep ptr;
  3    20 
  3    21      
  3    22 
  3    23 dcl 1 dt based (dtp) aligned,
  3    24 
  3    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  3    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  3    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  3    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  3    29     2 version fixed bin init (1),
  3    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  3    31     2 pad (2) bit (36),
  3    32     2 array (0 refer (dt.max_n_entries)) like dte,
  3    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  3    34 
  3    35 dcl 1 dte based (dtep) aligned,
  3    36     2 drive_name char (8),				/* device name */
  3    37     (2 device_type fixed bin (8),			/* device type */
  3    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  3    39     2 known bit (1),				/* TRUE if label has been read and checked */
  3    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  3    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  3    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  3    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  3    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  3    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  3    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  3    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  3    48     2 is_sub_vol bit (1),
  3    49     2 pad bit (3),
  3    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  3    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  3    52     2 sv_num  fixed bin unal,				/* this sv number */
  3    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  3    54     2 sv_name   char (2) aligned,
  3    55     2 pvid bit (36),				/* physical volume ID */
  3    56     2 pvname char (32);				/* Physical volume name. */
  3    57 
  3    58 dcl 1 lve based (lvep) aligned,
  3    59     2 lvid bit (36),				/* logical volume ID */
  3    60     (2 used bit (1),				/* TRUE if entry used */
  3    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  3    62     2 public bit (1),				/* TRUE for public vol */
  3    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  3    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  3    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  3    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  3    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  3    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  3    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  3    70     2 pad bit (26)) unal,
  3    71     2 lvname char (32),				/* Logical volume name */
  3    72     2 min_access_class bit (72),			/* Security stuff */
  3    73     2 max_access_class bit (72);			/* .. */
  3    74 
  3    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
       43 
       44    dcl 1 disk_table aligned like dt based;
       45    call add ("disk_table", addr (p -> disk_table));
       46    dcl 1 disk_table_entry aligned like dte based;
       47    call add ("disk_table_entry", addr (p -> disk_table_entry));
       48    dcl 1 disk_table_lv_entry aligned like lve based;
       49    call add ("disk_table_lv_entry", addr (p -> disk_table_lv_entry));
  4     1 /*  BEGIN dn355_data.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  4     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  4     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  4     9*     implementation.
  4    10*  2) change(89-03-20,Parisek), approve(89-06-06,MCR8110),
  4    11*     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
  4    12*     Add support of protocol mpx.
  4    13*                                                   END HISTORY COMMENTS */
  4    14 
  4    15 
  4    16 /* Date Last Modified and Reason
  4    17*
  4    18*   Created 07/25/74 by R. B. Snyder for new ttydim.
  4    19*   Modified 06/23/77 by J. Stern to add channel_work_reqd and cwork_count
  4    20*   Modified 08/14/78 by Robert Coren to remove devx_tab and invent PCBs
  4    21*   Modified 79 May 14 by Art Beattie to add fnp_mem_size
  4    22*   Modified December 1979 by Robert Coren to add FNP queue lock
  4    23*   Modified January 1980 by Larry Johnson to increase max number of FNPs to 8
  4    24*   Modified 02/12/80 by Robert Coren to add dcw_list_array_ptr
  4    25*   Modified 03/06/80 by Robert Coren to add some metering info
  4    26*   Modified 12/10/80 by Robert Coren to add get_meters_waiting flag
  4    27*   Modified 83-12-16 BIM to use a chanid instead of iom/channel fb's.
  4    28*   Modified 1984-07-26 BIM for paged iom.
  4    29*   Modified in September 1985 for the DN7100 version interim.
  4    30**/
  4    31 
  4    32 /* LOCKING RULES: A fnp is locked by its LCTE unless its LCTE is uninitialized.
  4    33*   In that case, the configuration_lock must be held.
  4    34*   if tty_lock$lock_lcte returns io_no_permission, then the caller must
  4    35*   lock$lock_fast the configuration lock and retry the LCTE lock. If
  4    36*   the lcte is now initialized, too bad. Otherwise, the config lock protects.
  4    37*
  4    38*   Configuration locking is interesting to init_multiplexer and
  4    39*   all of fnp t&d and reconfiguration. The guts of the multiplexer
  4    40*   pay no attention to it. Thus, if the LCTE can be locked, it MUST be
  4    41*   locked before changing the io_manager_assigned flag. */
  4    42 
  4    43 /* format: style4,delnl,insnl,^ifthendo */
  4    44 
  4    45 dcl  max_no_355s fixed bin int static init (8) options (constant);
  4    46 						/* max no of 355s we can handle (arbitrary) */
  4    47 dcl  dn355_data$ external fixed bin;
  4    48 
  4    49 dcl  infop pointer;
  4    50 dcl  fnpp ptr;
  4    51 
  4    52 dcl  1 datanet_info aligned based (infop),
  4    53        2 configuration_lock aligned,
  4    54          3 pid bit (36) aligned,
  4    55          3 event bit (36) aligned,
  4    56          3 flags aligned,
  4    57 	 4 notify_sw bit (1) unaligned,
  4    58 	 4 pad bit (35) aligned,
  4    59        2 no_of_355s fixed bin,			/* no. of FNP's */
  4    60        2 trace bit (1) aligned,			/* watch events on console */
  4    61        2 debug_stop bit (1) aligned,			/* crash on errors */
  4    62        2 uncp_bufp ptr,                                     /* pointer to the circular buffer */
  4    63        2 protocol_datap ptr,				/* pointer to protocol_mpx data */
  4    64        2 pad1 (6) bit (36) aligned,
  4    65        2 per_datanet (max_no_355s) aligned like fnp_info;	/* data per datanet */
  4    66 
  4    67 dcl  1 fnp_info aligned based (fnpp),			/* structure for each FNP */
  4    68        2 mbx_pt pointer,				/* pointer to mailbox NULL if not in config */
  4    69        2 pcb_array_ptr pointer,			/* pointer to array of physical channel blocks */
  4    70        2 dcw_list_array_ptr pointer,			/* pointer to array of space reserved for output DCW lists */
  4    71        2 no_of_channels fixed bin,			/* number of channels on this FNP */
  4    72        2 fnp_id,
  4    73          3 fnp_tag char (1) unaligned,			/* letter identifying FNP */
  4    74          3 fnp_number fixed bin (9) unsigned unaligned,	/* sequence number of FNP */
  4    75          3 padc bit (18) unaligned,
  4    76        2 io_chanid char (8) aligned,
  4    77        2 io_manager_chx fixed bin (35),			/* devx for DIA on iom */
  4    78        2 lsla_idx (0:5) fixed bin aligned,		/* index into PCB array for lsla lines */
  4    79        2 hsla_idx (0:2) fixed bin aligned,		/* index into PCB array for hsla lines */
  4    80        2 count fixed bin,				/* number of items in delay queue */
  4    81        2 cur_ptr fixed bin,				/* offset in tty_buf of next delay queue element */
  4    82        2 last_ptr fixed bin,				/* offset in tty_buf of last delay queue element */
  4    83        2 bleft_355 fixed bin,				/* number of free buffers in this 355 */
  4    84        2 flags,
  4    85          3 work_reqd bit (1) unaligned,			/* mailbox messages queued up */
  4    86          3 bootloading bit (1) unaligned,		/* currently being bootloaded */
  4    87          3 running bit (1) unaligned,			/* this FNP is running */
  4    88          3 wired bit (1) unaligned,			/* bootload buffer is wired */
  4    89          3 dump_patch_in_progress bit (1) unaligned,	/* a dump or patch order is in progress */
  4    90          3 level_3_pending bit (1) unaligned,		/* level 3 interrupt pending */
  4    91          3 level_7_pending bit (1) unaligned,		/* level 7 interrupt pending */
  4    92          3 dump_patch_disabled bit (1) unaligned,		/* dump & patch orders disabled because of timeout */
  4    93          3 t_and_d_in_progress bit (1) unaligned,		/* T & D using FNP */
  4    94          3 t_and_d_lev_3_occurred bit (1) unaligned,	/* A level 3 occurred */
  4    95          3 t_and_d_lev_7_occurred bit (1) unaligned,
  4    96          3 t_and_d_notify_requested bit (1) unaligned,
  4    97          3 t_and_d_assigned bit (1) unaligned,		/* AS has given fnp to process */
  4    98          3 get_meters_waiting bit (1) unaligned,		/* waiting for meter copy to complete */
  4    99          3 padb bit (7) unaligned,
  4   100          3 active_dial unaligned,
  4   101             4 active_bit (15) bit (1) unaligned,		/* ON if the process is active */
  4   102        2 lcte_ptr ptr,				/* pointer to this FNP's LCT entry */
  4   103        2 astep ptr,					/* pointer to aste of wired bootload buffer */
  4   104        2 boot_ev_chan fixed bin (71),			/* event channel over which to signal bootload completion */
  4   105        2 boot_process_id bit (36),			/* process that initiated bootload */
  4   106        2 version char (4),				/* version id of core image */
  4   107        2 fnp_mem_size fixed bin (18) unsigned,		/* memory size of this FNP in 18-bit words */
  4   108        2 queue_lock bit (36) aligned,			/* lock for interrupt queue */
  4   109        2 dump_patch_lock bit (36),			/* lock for fnp_dump or _patch operation */
  4   110        2 q_entries_made fixed bin (35),			/* count of delay queue entries made */
  4   111        2 input_reject_count fixed bin,			/* number of times input rejected */
  4   112        2 processed_from_q fixed bin (35),		/* number of interrupts processed from queue */
  4   113        2 fnp_channel_locked fixed bin (35),		/* number of times dn355 found per-FNP lock locked */
  4   114        2 input_data_transactions fixed bin (35),		/* number of mailbox transactions for input */
  4   115        2 output_data_transactions fixed bin (35),		/* number of mailbox transactions for output */
  4   116        2 input_control_transactions fixed bin (35),	/* number of mailbox transactions for inbound control info */
  4   117        2 output_control_transactions fixed bin (35),	/* number of mailbox transactions for outbound control info */
  4   118        2 cumulative_mbx_in_use fixed bin (35),		/* cumulative count of number of outbound mailboxes in use */
  4   119        2 max_mbx_in_use fixed bin,			/* maximum number of mailboxes in use at any given time */
  4   120        2 mbx_in_use_updated fixed bin (35),		/* number of increments to cumulative_mbx_in_use */
  4   121        2 mbx_unavailable fixed bin (35),		/* number of times had to queue mailbox transaction because none available */
  4   122        2 free_size fixed bin (35),			/* cumulative amount of bleft_355 */
  4   123        2 free_count fixed bin,			/* number of adds to above */
  4   124        2 fnp_space_restricted_output fixed bin (35),	/* number of times available FNP space restricted amount of output sent */
  4   125        2 tandd_pcbx fixed bin,			/* index of PCB for COLTS channel */
  4   126        2 n_pages_wired fixed bin,			/* pages wired for loading */
  4   127        2 config_flags aligned,
  4   128          3 available bit (1) unaligned,			/* reconfig says "yes" */
  4   129          3 io_manager_assigned bit (1) unaligned,		/* We have channel assigned to us */
  4   130          3 pad bit (34) unaligned,
  4   131        2 uncp_pcbx1 fixed bin (17) unaligned,		/* For the DN7100 */
  4   132        2 uncp_pcbx2 fixed bin (17) unaligned,		/* For the DN7100 */  
  4   133        2 ptx fixed bin,				/* page table index, used only at bootload */
  4   134        2 ptp pointer unaligned;			/* page table for this FNP */
  4   135 
  4   136 /**** The following named constants are used to lay out the
  4   137*      iom page tables. Each FNP has to have its own page
  4   138*      table because there is not enough room to have eight different
  4   139*      bootload images of 32 K and > 64 K of tty_buf 
  4   140*
  4   141*      THE MAX TTY BUF LENGTH IS 192 K words. We could have another 16 K
  4   142*      easily, and then after that it would get hard. */ 
  4   143 
  4   144 /**** The layout
  4   145*
  4   146*      Page   I/O address   Memory address     Comments
  4   147*      ----      ------     --------------     --------
  4   148*      0              0       xxxxxx           invalid PTW
  4   149*      1           2000         2000           write-enabled (mailbox)
  4   150*      2           4000         4000           write-enabled (mailbox)
  4   151*      3	        6000         6000           write-enabled (mailbox)
  4   152*      4          10000       as needed        bootload image segment page 0
  4   153*      ....        ....         ....           ....
  4   154*      35        110000       as needed        bootload image segment page 31
  4   155*      36        112000       xxxxxx           invalid PTW
  4   156*      ...         ....         ....           ....
  4   157*      63        160000         ....           invalid PTW
  4   158*      64        200000       as needed        tty_buf page 0
  4   159*      ...         ....         ....           ....
  4   160*      127       260000       as needed        tty_buf page 63
  4   161*      255       ......        .....           tty_buf page 191
  4   162**/
  4   163 
  4   164 /**** We assume that the page table starts at all zeros. */
  4   165 
  4   166 declare  FIRST_BOOTLOAD_PAGEX fixed bin init (4) int static options (constant);
  4   167 declare  FIRST_TTY_BUF_PAGEX fixed bin init (64) int static options (constant);
  4   168 
  4   169 /* End include file dn355_data.incl.pl1 */
       50 
       51    call add ("datanet_info", addr (p -> datanet_info));
       52    call add ("fnp_info", addr (p -> fnp_info));
  5     1 /*			BEGIN dn355_mailbox.incl.pl1			*/
  5     2 
  5     3 /* Date Last Modified and Reason
  5     4*   Created 07/25/74 by R. B. Snyder for new ttydim.
  5     5*   Modified 08/20/75 by Mike Grady to prepare for multiple 355's
  5     6*   Modified 11/08/78 by Robert Coren to introduce FNP-controlled mailboxes
  5     7*   Modified 02/19/80 by Robert Coren to specify format of accept_input mailbox
  5     8*   Modified 04/23/80 by Robert Coren to replace lock with num_in_use
  5     9*   Modified 09/21/82 by Robert Coren to make subfields of crash_data be fixed bin (18) unsigned
  5    10*   */
  5    11 
  5    12 dcl 1 datanet_mbx aligned based (mbxp),			/* declaration of 355 mailbox */
  5    13     2 dia_pcw aligned,				/* Peripheral Control Word for DIA */
  5    14       3 zero bit (18) unaligned,
  5    15       3 error bit (1) unaligned,			/* set to "1"b if error on connect */
  5    16       3 pad1 bit (5) unaligned,
  5    17       3 mbx_no bit (6) unaligned,			/* number of submbx being sent to 355 */
  5    18       3 command bit (6) unaligned,			/* always 71 (octal) */
  5    19     2 mailbox_requests fixed bin,			/* 0 mod 256K cnt of mbx requests by 355 */
  5    20     2 term_inpt_mpx_wd bit (36) aligned,		/* terminate interrupt multiplex word */
  5    21     2 last_mbx_req_count fixed bin,			/* previous value of mailbox_requests */
  5    22     2 num_in_use fixed bin,				/* number of submailboxes currently in use */
  5    23     2 mbx_used_flags,				/* one bit for each mailbox */
  5    24       3 used (0:7) bit (1) unaligned,			/* "1"b means this mbx is being used */
  5    25       3 pad2 bit (28) unaligned,
  5    26     2 crash_data,					/* data for 355 emergency interrupt */
  5    27       3 fault_code fixed bin (18) unal unsigned,
  5    28       3 ic fixed bin (18) unal unsigned,
  5    29       3 iom_fault_status fixed bin (18) unal unsigned,
  5    30       3 fault_word fixed bin (18) unal unsigned,		/* contains either faulting instruction or iomchannel no */
  5    31     2 dn355_sub_mbxes (0:7) aligned,			/* 8 CS-initiated submailboxes */
  5    32       3 pad4 (8) fixed bin,				/* eight words each */
  5    33     2 fnp_sub_mbxes (0:3) aligned,			/* 4 FNP-initiated mailboxes */
  5    34       3 pad5 (28) fixed bin;				/* 28 words each */
  5    35 
  5    36 dcl 1 sub_mbx aligned based (subp),			/* declaration of a submailbox */
  5    37     2 dn355_no bit (3) unaligned,			/* 355 number */
  5    38     2 pad1 bit (5) unaligned,
  5    39     2 line_number unaligned,				/* line number assigned by 355 */
  5    40       3 is_hsla bit (1) unaligned,			/* on if hsla, off if lsla */
  5    41       3 la_no bit (3) unaligned,			/* line adapter (high or low speed) number */
  5    42       3 slot_no bit (6) unaligned,			/* physical slot/subchannel number */
  5    43     2 terminal_id bit (18) unaligned,			/* not used */
  5    44 
  5    45     2 terminal_type bit (9) unaligned,			/* unused */
  5    46     2 cmd_data_len fixed bin (8) unaligned,		/* no. of 6 bit chars in command data */
  5    47     2 op_code fixed bin (8) unaligned,			/* op code */
  5    48     2 io_cmd fixed bin (8) unaligned,			/* i/o cmd */
  5    49 
  5    50     2 command_data (3) bit (36) unaligned,		/* data associated with op code */
  5    51 
  5    52     2 address unal,					/* dcw buffer or circular queue address */
  5    53       3 data_addr bit (18) unaligned,			/* data address */
  5    54       3 word_cnt fixed bin (18) unsigned unaligned,	/* data length */
  5    55     2 pad3 bit (72) unaligned;
  5    56 
  5    57 /* The structure below defines the long form of submailbox used by the FNP. Note that
  5    58*   the declaration of command_data and input_data is that used for the input_in_mailbox
  5    59*   operation; other FNP-initiated operations use the command_data format described by
  5    60*   the above (short mailbox) structure
  5    61**/
  5    62 
  5    63 dcl 1 fnp_sub_mbx aligned based (subp),			/* format used for FNP-controlled mailbox */
  5    64     2 dn355_no bit (3) unaligned,			/* as above */
  5    65     2 pad1 bit (5) unaligned,
  5    66     2 line_number unaligned,				/* as above */
  5    67       3 is_hsla bit (1) unaligned,
  5    68       3 la_no bit (3) unaligned,
  5    69       3 slot_no bit (6) unaligned,
  5    70     2 n_free_buffers fixed bin (17) unaligned,		/* number of free blocks in FNP at present */
  5    71 
  5    72     2 pad3 bit (9) unaligned,
  5    73     2 n_chars fixed bin (9) unsigned unaligned,		/* number of data characters (if input) */
  5    74     2 op_code fixed bin (9) unsigned unaligned,		/* as above */
  5    75     2 io_cmd fixed bin (9) unsigned unaligned,		/* as above */
  5    76 
  5    77     2 input_data char (100) unaligned,			/* input characters for input_in_mailbox op */
  5    78     2 command_data bit (36) unaligned;			/* shouldn't need more than one word */
  5    79 
  5    80 /* The structure below defines the format of a long submailbox used for an accept_input operation
  5    81*   when the data is too long to fit directly in the mailbox. command_data and n_chars occupy the same position as for input_in_mailbox, above.
  5    82**/
  5    83 
  5    84 dcl 1 input_sub_mbx aligned based (subp),
  5    85     2 pad1 bit (8) unaligned,
  5    86     2 line_number unaligned like sub_mbx.line_number,
  5    87     2 n_free_buffers fixed bin (17) unaligned,		/* number of free blocks in FNP at present */
  5    88 
  5    89     2 n_chars fixed bin (17) unaligned,			/* total number of data characters */
  5    90     2 op_code fixed bin (9) unsigned unaligned,
  5    91     2 io_cmd fixed bin (9) unsigned unaligned,
  5    92 
  5    93     2 n_buffers fixed bin,				/* number of buffers in this input chain */
  5    94     2 dcw (24),					/* "pseudo-DCWs"  used to specify buffer addresses and tallies */
  5    95       3 abs_addr bit (24) unaligned,			/* supplied by CS */
  5    96       3 tally fixed bin (12) unsigned unaligned,		/* in characters, supplied by FNP */
  5    97     2 command_data bit (36) unaligned;			/* as above */
  5    98 
  5    99 dcl  subp pointer;
  5   100 dcl  mbxp pointer;
  5   101 
  5   102 /*			END dn355_mailbox.incl.pl1			*/
       53 
       54    call add ("datanet_mbx", addr (p -> datanet_mbx));
       55    dcl 1 short_fnp_sub_mbx aligned like sub_mbx based;
       56    call add ("short_fnp_sub_mbx", addr (p -> short_fnp_sub_mbx));
       57    call add ("fnp_sub_mbx", addr (p -> fnp_sub_mbx));
       58    call add ("input_sub_mbx", addr (p -> input_sub_mbx));
  6     1 /* Begin include file ...... dskdcl.incl.pl1 */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  6     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  6     6*     Support for FIPS dev 0.
  6     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
  6     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
  6     9*     Added reconnect_announce_time to chantab to allow announcement of
  6    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
  6    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 /* Structures used by the Disk DIM */
  6    15 
  6    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
  6    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
  6    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
  6    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
  6    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
  6    21 
  6    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
  6    23 
  6    24 dcl  disk_seg$ ext;					/* disk data segment */
  6    25 
  6    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
  6    27      diskp ptr,					/* pointer to disk DIM info structure */
  6    28      optp ptr,					/* pointer to opt_info */
  6    29      sysp ptr;					/* pointer to sys_info */
  6    30 
  6    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
  6    32        2 subsystems fixed bin,			/* number of subsystems */
  6    33        2 free_offset bit (18),			/* offset of first unused location in segment */
  6    34        2 status_mask bit (36),			/* mask for checking for disk error */
  6    35        2 lock bit (36) unal,				/* disk_data lock */
  6    36        2 free_q like qht,				/* head/tail offsets */
  6    37        2 free_q_size fixed bin,			/* length of queue */
  6    38        2 array (32),				/* per subsystem info */
  6    39          (
  6    40          3 offset bit (18),				/* location of data for this subsystem */
  6    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
  6    42          3 name char (4)
  6    43          ) unal,					/* name of subsystem */
  6    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
  6    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
  6    46        2 pad bit (36),				/* double word align */
  6    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
  6    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
  6    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
  6    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
  6    51 
  6    52 
  6    53 /* The following system table is used to hold the maximum queue loading
  6    54*   permitted system-wide for each IO type.  From the current loading and
  6    55*   the maximum loading a multiplier fraction is calculated.  These combine
  6    56*   to produce the final optimization multiplier to derive a Logcial Seek
  6    57*   from a Physical Seek. */
  6    58 
  6    59 dcl  1 sys_info aligned based (sysp),
  6    60        3 depth float bin (27),			/* current load */
  6    61        3 max_depth float bin (27),			/* max permissible */
  6    62        3 fraction float bin (27),			/* load fraction */
  6    63        3 depth_map bit (18) unaligned,			/* which depth counter */
  6    64        3 pad bit (18) unaligned;
  6    65 
  6    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
  6    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
  6    68*   dctl's use. */
  6    69 
  6    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
  6    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
  6    72 
  6    73 
  6    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
  6    75        2 lock bit (36) unal,				/* data base lock */
  6    76        2 nchan fixed bin,				/* number of disk channels */
  6    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
  6    78        2 last_dev fixed bin unal,			/* highest disk drive number */
  6    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
  6    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
  6    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
  6    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
  6    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
  6    84        2 dev_index fixed bin (17) unal,			/* current device to check */
  6    85        2 errors fixed bin,				/* error count */
  6    86        2 ferrors fixed bin,				/* fatal error count */
  6    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
  6    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
  6    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
  6    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
  6    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
  6    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
  6    93 
  6    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
  6    95 
  6    96 
  6    97 dcl  qp ptr,					/* pointer to queue entry */
  6    98      cp ptr;					/* pointer to channel information table */
  6    99 
  6   100 
  6   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
  6   102*   expansion space.  They will always be positive and upper bits can be
  6   103*   stolen for other fields.
  6   104*
  6   105*   Entries are forward and back linked to permit easy chasing and removal. */
  6   106 
  6   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
  6   108 						/* WORD 1 */
  6   109        2 next bit (18) unaligned,			/* forward link */
  6   110        2 prev bit (18) unaligned,			/* back link */
  6   111 						/* WORD 2 */
  6   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
  6   113        2 used bit (1) unaligned,			/* entry in use */
  6   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
  6   115        2 pad bit (6) unaligned,			/* future expansion */
  6   116        2 coreadd bit (24) unaligned,			/* main memory address */
  6   117 						/* WORD 3 */
  6   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
  6   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
  6   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
  6   121        2 pad2 bit (5) unaligned,
  6   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
  6   123 						/* WORD 4 */
  6   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
  6   125        2 pad3 bit (9) unaligned,
  6   126        2 sector bit (21) unaligned,			/* device sector desired */
  6   127 						/* WORDS 5&6 */
  6   128        2 time fixed bin (71);				/* clock at queue */
  6   129 
  6   130 
  6   131 
  6   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
  6   133        2 chx fixed bin (35),				/* io_manager channel index */
  6   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
  6   135        2 statusp ptr,				/* pointer to hardware status word */
  6   136        2 chanid char (8),				/* channel name */
  6   137        (
  6   138        2 pad0 bit (18),
  6   139        2 in_use bit (1),				/* non-zero if channel being used */
  6   140        2 active bit (1),				/* non-zero if channel active */
  6   141        2 rsr bit (1),				/* non-zero if RSR in progress */
  6   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
  6   143        2 inop bit (1),				/* non-zero if channel inoperative */
  6   144        2 broken bit (1),				/* non-zero if channel broken */
  6   145        2 action_code bit (2),				/* saved from status */
  6   146        2 pad1 bit (10)
  6   147        ) unal,
  6   148        (
  6   149        2 qrp bit (18),				/* rel ptr to queue entry */
  6   150        2 pad2 bit (3),
  6   151        2 command bit (6),				/* peripheral command */
  6   152        2 erct fixed bin (8)
  6   153        ) unal,					/* error retry count */
  6   154        2 select_data,				/* data passed to IOM on select */
  6   155          (
  6   156          3 limit bit (12),				/* limit on number of sectors */
  6   157          3 mbz bit (3),
  6   158          3 sector bit (21)
  6   159          ) unaligned,				/* sector address */
  6   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
  6   161        2 connect_time fixed bin (52),			/* time of last connect */
  6   162        2 connects fixed bin,				/* count of connects performed */
  6   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
  6   164        2 rstdcw bit (36),				/* restore command */
  6   165        2 scdcw bit (36),				/* select command */
  6   166        2 sddcw bit (36),				/* select data xfer */
  6   167        2 dcdcw bit (36),				/* command to read or write */
  6   168        2 dddcw bit (36),				/* data xfer DCW */
  6   169        2 dscdcw bit (36),				/* RSR command */
  6   170        2 dsddcw bit (36),				/* RSR data xfer */
  6   171        2 rssdcw bit (36),				/* RSS command */
  6   172        2 status bit (36) aligned,			/* saved status */
  6   173 						/* Lossage counters for interrupt loss. */
  6   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
  6   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
  6   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
  6   177        2 status_from_run fixed bin (35);		/* status missed til run called */
  6   178 
  6   179 dcl  1 qht aligned based,				/* queue head/tail structure */
  6   180        2 sum fixed bin (35),				/* sum of depths */
  6   181        2 count fixed bin (35),			/* allocs */
  6   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
  6   183        2 depth fixed bin (17) unaligned,		/* current depth */
  6   184        2 head bit (18) unaligned,			/* queue head */
  6   185        2 tail bit (18) unaligned;			/* queue tail */
  6   186 
  6   187 dcl  dp ptr,					/* pointer to device information table */
  6   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
  6   189 
  6   190 dcl  1 devtab based (dp) aligned,			/* device information table */
  6   191        (
  6   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
  6   193        2 inop bit (1),				/* device inoperative */
  6   194        2 was_broken bit (1),				/* device previously broken */
  6   195        2 broken bit (1),				/* device down */
  6   196        2 abandoned bit (1),				/* device lost and gone forever */
  6   197        2 forward bit (1),				/* moving low->high */
  6   198        2 pad bit (10),
  6   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
  6   200        2 pdi unsigned fixed bin (6)
  6   201        ) unal,					/* primary device index */
  6   202        2 cylinder fixed bin (35),			/* current cylinder position */
  6   203        2 comb fixed bin (35),				/* number of combs */
  6   204        2 pad1 fixed bin (35),
  6   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
  6   206        2 wq like qht,				/* work queue */
  6   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
  6   208        2 opt_info (0:6) like opt_info;			/* optimizer */
  6   209 
  6   210 
  6   211 /* Optimizing table for device. Must be even multiple words long. */
  6   212 /* Slope and intercept define a straight line of y = intercept - slope*x
  6   213*   Multiplier is calculated from this and current system loading.
  6   214*
  6   215*   sys_info is the offset to the relevant system queue loading fraction. */
  6   216 
  6   217 dcl  1 opt_info aligned based (optp),
  6   218        3 multiplier float bin (27),			/* depth mult */
  6   219        3 slope float bin (27),			/* slope of line */
  6   220        3 intercept float bin (27),			/* Y intercept */
  6   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
  6   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
  6   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
  6   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
  6   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
  6   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
  6   227 
  6   228 
  6   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
  6   230        (
  6   231        2 sx fixed bin (11),				/* structure index */
  6   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
  6   233        2 unused_sect_per_cyl fixed bin (11)
  6   234        ) unal;					/* # of unused sectors at end of cylinder */
  6   235 
  6   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
  6   237        2 count fixed bin,				/* total number of attempts */
  6   238        2 waits fixed bin,				/* number of attempts which required waiting */
  6   239        2 wait_time fixed bin (52);			/* total time spent waiting */
  6   240 
  6   241 dcl  (
  6   242      RST_LISTX init (1),				/* listx for restore */
  6   243      SC_LISTX init (2),				/* listx for select */
  6   244      DSC_LISTX init (6),				/* listx for RSR */
  6   245      RSS_LISTX init (8)
  6   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
  6   247 
  6   248 /* IO types defined.  Value is also index of write_map to determine if
  6   249*   the IO type is a read or a write. */
  6   250 
  6   251 dcl  (
  6   252      PAGE_READ init (0),
  6   253      PAGE_WRITE init (1),
  6   254      VTOC_READ init (2),
  6   255      VTOC_WRITE init (3),
  6   256      TEST init (4),
  6   257      BOOTLOAD_READ init (5),
  6   258      BOOTLOAD_WRITE init (6),
  6   259      MAX_IO_TYPE init (6)
  6   260      ) fixed bin (4) static options (constant);
  6   261 
  6   262 dcl  IO_TYPE (0:6) char (16)
  6   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
  6   264 	static options (constant);
  6   265 
  6   266 /* Map indexed by IO type to determine if operation is a read or write. */
  6   267 
  6   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
  6   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
  6   270 
  6   271 /* Map indexed by IO type to determine if operation is a sector IO. */
  6   272 
  6   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
  6   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
  6   275 
  6   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
  6   277 
  6   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
  6   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
  6   280 
  6   281 /* End of include file ...... dskdcl.incl.pl1 */
       59 
       60    call add ("disk_data", addr (p -> disk_data));
       61    call add ("disktab", addr (p -> disktab));
       62    call add ("disk_channel_table", addr (p -> disk_channel_table)); 
       63    call add ("quentry", addr (p -> quentry));
       64    call add ("chantab", addr (p -> chantab));
       65    call add ("devtab", addr (p -> devtab));
       66 
  7     1 /*	BEGIN INCLUDE FILE ... ect_structures.incl.pl1 ... Jan 1981 */
  7     2 
  7     3 /* Modified 1984-10-28 by E. Swenson for new ipc validation and to move
  7     4*   event_channel_name declarations from here to event_channel_name.incl.pl1 */
  7     5 
  7     6 
  7     7 /****^  HISTORY COMMENTS:
  7     8*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  7     9*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  7    10*     Changed to support control point management.  These changes were actually
  7    11*     done in February 1985 by G. Palter.
  7    12*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7479),
  7    13*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  7    14*     Modified to eke out some flag bits by making the type fixed bin (8) in
  7    15*     order to support async event channels.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 /* format: style3 */
  7    20 
  7    21 
  7    22 /* Definition of the Event Channel Table (ECT) header */
  7    23 
  7    24 dcl	1 ect_header	aligned based (ect_ptr),
  7    25 	  2 ect_areap	ptr,			/* pointer to area in which ECT entries are allocated */
  7    26 	  2 ect_area_size	fixed bin (19),		/* number of words in ECT area */
  7    27 	  2 count		(-1:5) fixed bin,		/* totals of entries allocated */
  7    28 						/* -1 = waiting control points */
  7    29 						/* 0 = total entries, 1 = wait channels */
  7    30 						/* 2 = call channels, 3 = call channel messages */
  7    31 						/* 4 = ITT messages, 5 = wait channel messages */
  7    32 	  2 entry_list_ptrs (5),			/* head and tail of lists in ECT */
  7    33 						/* 1 = wait channels, 2 = call channels */
  7    34 						/* 3 = call channel messages, 4 = ITT messages */
  7    35 						/* 5 = wait channel messages */
  7    36 	    3 firstp	ptr,			/* head of list */
  7    37 	    3 lastp	ptr,			/* tail of list */
  7    38 	  2 meters,
  7    39 	    3 total_wakeups fixed bin (33),		/* total wakeups sent on all channels */
  7    40 	    3 total_wait_wakeups
  7    41 			fixed bin (33),		/* wakeups sent on wait channels */
  7    42 	    3 total_call_wakeups
  7    43 			fixed bin (33),		/* wakeups sent on call channels */
  7    44 	    3 ittes_tossed	fixed bin (33),		/* number invalid ITT messages received, ignored */
  7    45 	  2 seed		fixed bin (33),		/* used to generate uid portion of channel name */
  7    46 	  2 flags,
  7    47 	    3 call_priority bit (1) unal,		/* = "0"b if wait chns have priority - default */
  7    48 						/* = "1"b if call chans have priority */
  7    49 	    3 wakeup_control_points			/** ON => we must wakeup other control points before */
  7    50 			bit (1) unaligned,		/* ... processing any event messages */
  7    51 	    3 unused1	bit (16) unaligned,
  7    52 	    3 mask_call_count
  7    53 			fixed bin (17) unal,	/* number times event call chans masked */
  7    54 	  2 ecit_ptr	ptr,			/* pointer to the ECIT */
  7    55 	  2 ecit_lth	fixed bin (17),		/* length of the ECIT (see below) */
  7    56 	  2 r_offset	fixed bin (18),		/* operand used to encode/decode channel names */
  7    57 	  2 r_factor	fixed bin (35),		/* operand used to encode/decode channel names */
  7    58 	  2 last_fast_channel_events			/** prior fast channel settings */
  7    59 			bit (36) aligned;
  7    60 
  7    61 dcl	ect_ptr		pointer;
  7    62 
  7    63 dcl	TOTAL		fixed bin (8) static options (constant) init (0);
  7    64 dcl	WAIT		fixed bin (8) static options (constant) init (1);
  7    65 dcl	CALL		fixed bin (8) static options (constant) init (2);
  7    66 dcl	EV_CALL_MESSAGE	fixed bin (8) static options (constant) init (3);
  7    67 dcl	ITT_MESSAGE	fixed bin (8) static options (constant) init (4);
  7    68 dcl	EV_WAIT_MESSAGE	fixed bin (8) static options (constant) init (5);
  7    69 dcl	WAITING_CP	fixed bin (8) static options (constant) init (-1);
  7    70 						/* used to index count and entry_list_ptrs arrays */
  7    71 
  7    72 
  7    73 /* Definition of the Event Channel Index Table (ECIT) -- Given an event channel
  7    74*   name, ipc_validate_$decode_event_channel_name will yield an index into this
  7    75*   table which contains a pointer to the definition of the channel (its ECT) */
  7    76 
  7    77 dcl	1 ecit		aligned based (ecit_ptr),
  7    78 	  2 ecte_ptr	(ecit_lth) pointer unaligned;
  7    79 
  7    80 dcl	ecit_ptr		pointer;
  7    81 dcl	ecit_lth		fixed binary (17);
  7    82 
  7    83 
  7    84 /* Definition of an event wait channel */
  7    85 
  7    86 dcl	1 wait_channel	aligned based (ectep),
  7    87 	  2 word_0,
  7    88 	    3 unused1	fixed bin (17) unal,
  7    89 	    3 flags	unal,
  7    90 	      4 async_call	bit (1) unal,		/* Only checked for call channels. */
  7    91 	      4 pad	bit (8) unal,
  7    92 	    3 type	fixed bin (8) unal,		/* = WAIT */
  7    93 	  2 next_chanp	ptr unal,			/* pointer to next wait channel */
  7    94 	  2 prev_chanp	ptr unal,			/* pointer to previous wait channel */
  7    95 	  2 word_3,
  7    96 	    3 fast_channel	bit (1) unal,		/* ON => this is a fast channel */
  7    97 	    3 inhibit_count fixed bin (16) unal,	/* number of times message reception has been inhibited */
  7    98 	    3 wakeup_control_points			/** ON => wakeup the control points waiting on this channel */
  7    99 			bit (1) unaligned,
  7   100 	    3 wakeup_count	fixed bin (17) unal unsigned, /* number of wakeups received over this channel */
  7   101 	  2 name		bit (72),			/* event channel name associated with this channel */
  7   102 	  2 first_ev_msgp	ptr unal,			/* pointer to first message in queue */
  7   103 	  2 last_ev_msgp	ptr unal,			/* pointer to last message in queue */
  7   104 	  2 first_wcpp	ptr unal,			/* pointer to first control point waiting on this channel */
  7   105 	  2 last_wcpp	ptr unal,			/* pointer to last control point waiting on this channel */
  7   106 	  2 fast_channel_id fixed binary,		/* index into ipc_data_$fast_channel_events */
  7   107 	  2 unused2	fixed binary;		/* pad to 12 words */
  7   108 
  7   109 
  7   110 /* Definition of an event call channel */
  7   111 
  7   112 dcl	1 call_channel	aligned based (ectep),
  7   113 	  2 word_0,
  7   114 	    3 priority	fixed bin (17) unal,	/* indicated priority relative to other call chns */
  7   115 	    3 flags	unal,
  7   116 	      4 async_call	bit (1) unal,		/* Send IPS "wkp_" on wakeup. */
  7   117 	      4 pad	bit (8) unal,
  7   118 	    3 type	fixed bin (8) unal,		/* = CALL */
  7   119 	  2 next_chanp	ptr unal,			/* pointer to next call channel */
  7   120 	  2 prev_chanp	ptr unal,			/* pointer to prev call channel */
  7   121 	  2 word_3,
  7   122 	    3 call_inhibit	bit (1) unal,		/* = "1"b if call to associated proc in progress */
  7   123 	    3 inhibit_count fixed bin (16) unal,	/* number of times message reception has been inhibited */
  7   124 	    3 wakeup_control_points			/** ON => wakeup the control point waiting on this channel */
  7   125 			bit (1) unaligned,
  7   126 	    3 wakeup_count	fixed bin (17) unal unsigned, /* number of wakeups received over this channel */
  7   127 	  2 name		bit (72),			/* event channel name associated with this channel */
  7   128 	  2 first_ev_msgp	ptr unal,			/* pointer to first message in queue */
  7   129 	  2 last_ev_msgp	ptr unal,			/* pointer to last message in queue */
  7   130 	  2 data_ptr	ptr unal,			/* pointer to associated data base */
  7   131 	  2 procedure_value,			/* procedure to call when message arrives */
  7   132 	    3 procedure_ptr ptr unal,			/* pointer to entry point */
  7   133 	    3 environment_ptr
  7   134 			ptr unal,			/* pointer to stack frame */
  7   135 	  2 control_point_id			/** ID of control point which "owns" this channel */
  7   136 			bit (36) aligned;
  7   137 
  7   138 dcl	ectep		pointer;
  7   139 
  7   140 
  7   141 /* Definition of a message for either an event wait or an event call channel */
  7   142 
  7   143 dcl	1 event_message	aligned based,
  7   144 	  2 word_0,
  7   145 	    3 priority	fixed bin (17) unal,	/* priority of call channel */
  7   146 	    3 type	fixed bin (17) unal,	/* = EV_CALL_MESSAGE or EV_WAIT_MESSAGE */
  7   147 	  2 chanp		ptr unal,			/* pointer to associated event channel */
  7   148 	  2 message_data	like event_message_data aligned,
  7   149 						/* event message as returned from ipc_$block */
  7   150 	  2 next_ev_msgp	ptr unal,			/* pointer to next event call/wait channel message */
  7   151 	  2 prev_ev_msgp	ptr unal,			/* pointer to previous event call/wait channel message */
  7   152 	  2 next_chan_msgp	ptr unal,			/* pointer to next message for this channel */
  7   153 	  2 prev_chan_msgp	ptr unal;			/* pointer to previous message for this channel */
  7   154 
  7   155 
  7   156 /* Definition of an ITT message as returned from ring 0 */
  7   157 
  7   158 dcl	1 itt_message	aligned based,
  7   159 	  2 word_0,
  7   160 	    3 unused1	fixed bin (17) unal,
  7   161 	    3 type	fixed bin (17) unal,
  7   162 	  2 next_itt_msgp	ptr unal,			/* pointer to next itt message entry in ECT currently */
  7   163 	  2 message_data	like event_message_data aligned,
  7   164 	  2 unused2	(4) fixed bin;		/* pad to 12 words */
  7   165 
  7   166 
  7   167 /* Definition of an event message as returned from ring 0 */
  7   168 
  7   169 dcl	1 event_message_data
  7   170 			aligned based,
  7   171 	  2 channel_id	fixed bin (71),		/* event channel name */
  7   172 	  2 message	fixed bin (71),		/* 72 bit message associated with wakeup */
  7   173 	  2 sender	bit (36),			/* process ID of sender */
  7   174 	  2 origin,
  7   175 	    3 dev_signal	bit (18) unal,		/* "1"b if device signal */
  7   176 						/* "0"b if user event */
  7   177 	    3 ring	fixed bin (17) unal;	/* ring of sending process */
  7   178 
  7   179 
  7   180 /* Definition of a control point which is blocked on a channel */
  7   181 
  7   182 dcl	1 waiting_control_point
  7   183 			aligned based (wcpp),
  7   184 	  2 word_0,
  7   185 	    3 block_count	fixed binary (17) unaligned,	/* # of in-progress ipc_$block calls by this control point */
  7   186 	    3 type	fixed binary (17) unaligned,	/* = WAITING_CP */
  7   187 	  2 control_point_id			/** ID of the waiting control point */
  7   188 			bit (36) aligned,
  7   189 	  2 chain,
  7   190 	    3 next_wcpp	pointer,			/* pointer to previous waiting control point */
  7   191 	    3 prev_wcpp	pointer,			/* pointer to next waiting control point */
  7   192 	  2 unused	(6) bit (36) aligned;	/* pad to 12 words */
  7   193 
  7   194 dcl	wcpp		pointer;
  7   195 
  7   196 /* 	END INCLUDE file ... ect_structures.incl.pl1 */
       67 
       68    call add ("ect_header", addr (p -> ect_header));
       69    ecit_lth = 0;		/* avoids WARNING 307 */
       70    call add ("ecit", addr (p -> ecit));
       71    call add ("wait_channel", addr (p -> wait_channel));
       72    call add ("call_channel", addr (p -> call_channel));
       73    call add ("event_message", addr (p -> event_message));
       74    call add ("itt_message", addr (p -> itt_message));
       75    call add ("event_message_data", addr (p -> event_message_data));
       76    call add ("waiting_control_point", addr (p -> waiting_control_point));
  8     1 /* Begin include file event_channel_name.incl.pl1 */
  8     2 
  8     3 /* format: style4 */
  8     4 
  8     5 /* Written 1984-11-02 by E. Swenson */
  8     6 
  8     7 
  8     8 /****^  HISTORY COMMENTS:
  8     9*  1) change(86-08-09,Kissel), approve(86-08-12,MCR7479),
  8    10*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  8    11*     Added constants for the flag values and declared a structure to describe
  8    12*     the encoded_index after it is decoded.  This include file has also been
  8    13*     converted to ALM for use by pxss.
  8    14*                                                   END HISTORY COMMENTS */
  8    15 
  8    16 
  8    17 dcl  1 event_channel_name structure aligned based,
  8    18        2 encoded_index bit (18) unaligned,
  8    19        2 verifier bit (18) unaligned,
  8    20        2 ring fixed bin (3) unsigned unaligned,
  8    21        2 type bit (1) unaligned,			/* "1"b for regular, "0"b for fast */
  8    22        2 mbz bit (14) unaligned,
  8    23        2 unique_id fixed bin (18) unsigned unaligned;
  8    24 
  8    25 dcl  FAST_CHANNEL_TYPE bit (1) aligned initial ("0"b) internal static options (constant);
  8    26 dcl  REGULAR_CHANNEL_TYPE bit (1) aligned initial ("1"b) internal static options (constant);
  8    27 
  8    28 dcl  NORMAL_CHANNEL_FLAGS bit (3) aligned internal static options (constant) init ("000"b);
  8    29 dcl  SEND_IPS_WKP_CHANNEL_FLAGS bit (3) aligned internal static options (constant) init ("001"b);
  8    30 
  8    31 /* Structure for use after the encoded_index in the event_channel_name has been decoded. */
  8    32 
  8    33 dcl  1 decoded_index structure aligned based,
  8    34        2 flags bit (3) unaligned,
  8    35        2 index fixed bin (15) unsigned unaligned;
  8    36 
  8    37 dcl  ENCODED_INDEX_CONSTANT fixed bin (35) internal static options (constant) init (262144);
  8    38 
  8    39 /* End include file event_channel_name.incl.pl1 */
       77 
       78    call add ("event_channel_name", addr (p -> event_channel_name));
  9     1 /* BEGIN INCLUDE FILE event_call_info.incl.pl1 */
  9     2 
  9     3 /* T. Casey, May 1978 */
  9     4 
  9     5 dcl  event_call_info_ptr ptr;
  9     6 
  9     7 dcl 1 event_call_info aligned based (event_call_info_ptr),	/* argument structure passed to event call procedure */
  9     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
  9     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
  9    10     2 sender bit (36),				/* process id of sender */
  9    11     2 origin,
  9    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
  9    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
  9    14     2 data_ptr ptr;					/* ptr given to dcl_event_call_channel */
  9    15 
  9    16 /* END INCLUDE FILE event_call_info.incl.pl1 */
       79 
       80    call add ("event_call_info", addr (p -> event_call_info));
 10     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
 10     2 
 10     3 /* T. Casey, May 1978 */
 10     4 
 10     5 dcl  event_wait_info_ptr ptr;
 10     6 
 10     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
 10     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
 10     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
 10    10     2 sender bit (36),				/* process id of sender */
 10    11     2 origin,
 10    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
 10    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
 10    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
 10    15 
 10    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
       81 
       82    call add ("event_wait_info", addr (p -> event_wait_info));
       83 
 11     1 
 11     2 /* BEGIN INCLUDE FILE ... fault_vector.incl.pl1 ... last modified February 1981 */
 11     3 
 11     4 dcl  fvp ptr;					/* pointer to the fault and interrupt vectors */
 11     5 
 11     6 dcl 1 fv based (fvp) aligned,				/* fault and interrupt vectors */
 11     7     2 ipair (0: 31),				/* interrupt pairs */
 11     8       3 scu bit (36),				/* SCU instruction */
 11     9       3 tra bit (36),				/* TRA instruction */
 11    10     2 fpair (0: 31),				/* fault pairs */
 11    11       3 scu bit (36),				/* SCU instruction */
 11    12       3 tra bit (36),				/* TRA instruction */
 11    13     2 i_tra_ptr (0: 31) ptr,				/* ITS pair for interrupt TRA instruction */
 11    14     2 i_scu_ptr (0: 31) ptr,				/* ITS pair for interrupt SCU instruction */
 11    15     2 f_tra_ptr (0: 31) ptr,				/* ITS pairs for fault TRA instruction */
 11    16     2 f_scu_ptr (0: 31) ptr;				/* ITS pairs for fault SCU instruction */
 11    17 
 11    18 /* Fault Types by fault number								*/
 11    19 	
 11    20    dcl (FAULT_NO_SDF  init (0),			/* Shutdown 				*/
 11    21         FAULT_NO_STR  init (1),			/* Store 				*/
 11    22         FAULT_NO_MME  init (2),			/* Master Mode Entry 1			*/
 11    23         FAULT_NO_F1   init (3),			/* Fault Tag 1				*/
 11    24         FAULT_NO_TRO  init (4),			/* Timer Runout				*/
 11    25         FAULT_NO_CMD  init (5),			/* Command				*/
 11    26         FAULT_NO_DRL  init (6),			/* Derail					*/
 11    27         FAULT_NO_LUF  init (7),			/* Lockup					*/
 11    28         FAULT_NO_CON  init (8),			/* Connect				*/
 11    29         FAULT_NO_PAR  init (9),			/* Parity					*/
 11    30         FAULT_NO_IPR  init (10),			/* Illegal Procedure			*/
 11    31         FAULT_NO_ONC  init (11),			/* Operation Not Complete			*/
 11    32         FAULT_NO_SUF  init (12),			/* Startup				*/
 11    33         FAULT_NO_OFL  init (13),			/* Overflow				*/
 11    34         FAULT_NO_DIV  init (14),			/* Divide Check				*/
 11    35         FAULT_NO_EXF  init (15),			/* Execute				*/
 11    36         FAULT_NO_DF0  init (16),			/* Directed Fault 0 (Segment Fault)		*/
 11    37         FAULT_NO_DF1  init (17),			/* Directed Fault 1 (Page Fault)		*/
 11    38         FAULT_NO_DF2  init (18),			/* Directed Fault 2				*/
 11    39         FAULT_NO_DF3  init (19),			/* Directed Fault 3				*/
 11    40         FAULT_NO_ACV  init (20),			/* Access Violation				*/
 11    41         FAULT_NO_MME2 init (21),			/* Master Mode Entry 2			*/
 11    42         FAULT_NO_MME3 init (22),			/* Master Mode Entry 3			*/
 11    43         FAULT_NO_MME4 init (23),			/* Master Mode Entry 4			*/
 11    44         FAULT_NO_F2   init (24),			/* Fault Tag 2 (Linkage Fault)		*/
 11    45         FAULT_NO_F3   init (25),			/* Fault Tag 3				*/
 11    46 						/* Fault Numbers 26-30 unassigned 		*/
 11    47         FAULT_NO_TRB  init (31)			/* Trouble				*/
 11    48 	
 11    49                                 ) fixed bin (17) int static options (constant);
 11    50 	
 11    51 
 11    52 
 11    53 /* END INCLUDE FILE ... fault_vector.incl.pl1 */
 11    54 
       84 
       85    dcl 1 fault_vector aligned like fv based;
       86    call add ("fault_vector", addr (p -> fault_vector));
 12     1 /* BEGIN INCLUDE FILE ... flagbox.incl.pl1 */
 12     2 
 12     3 
 12     4 /****^  HISTORY COMMENTS:
 12     5*  1) change(87-02-26,Farley), approve(87-04-15,MCR7661),
 12     6*     audit(87-04-21,Fawcett), install(87-04-28,MR12.1-1028):
 12     7*     Added io_reconfig flag to inhibit BCE from attempting an emergency
 12     8*     shutdown when the data in memory could be corrupted.
 12     9*                                                   END HISTORY COMMENTS */
 12    10 
 12    11 
 12    12 /* last modified 5/3/77 by Noel I. Morris	*/
 12    13 /* Modified 8/79 by R.J.C. Kissel to add FNP blast message. */
 12    14 /* Modified 7/82 BIM for recognizable sentinel field */
 12    15 /* Modified for bootload Multics flagbox starting in 8/83 by Keith Loepere. */
 12    16 
 12    17 /* The contents of this segment are data shared by Multics and bce.
 12    18*   This entity occupies the locations within the toehold starting at 40o
 12    19*   (not counting the toehold_used spacer at the beginning). */
 12    20 
 12    21 dcl  flagbox$ ext;
 12    22 dcl  fgbxp ptr;
 12    23 
 12    24 dcl 1 fgbx based (fgbxp) aligned,
 12    25     2 toehold_used (32) bit (36) aligned,		/* flagbox seg now mapped onto all of first page of toehold -
 12    26*						This is what was unused before. */
 12    27     2 flags (36) bit (1) unal,			/* communications switches */
 12    28     2 slt_segno bit (18),				/* segment # of the SLT */
 12    29     2 pad1 fixed bin,
 12    30     2 rtb,					/* return to bce info */
 12    31      (3 ssenb bit (1),				/* "1"b if storage system enabled */
 12    32       3 call_bce bit (1),				/* "1"b if bce called by operator */
 12    33       3 shut bit (1),				/* "1"b if bce called after shutdown */
 12    34       3 mess bit (1),				/* "1"b if message has been provided */
 12    35       3 alert bit (1),				/* "1"b if audible alarm to be sounded */
 12    36       3 breakpoint bit (1),				/* "1"b is breakpoint caused call to bce */
 12    37       3 manual_crash bit (1),				/* either manual entry or execute fault */
 12    38       3 io_reconfig bit (1),				/* "1"b if I/O reconfiguration */
 12    39 						/* could cause memory corruption */
 12    40       3 pad bit (21),
 12    41       3 bce_entry fixed bin (6) uns) unal,		/* type of entry into bce
 12    42*						   00o => Multics entry
 12    43*						   20o => manual entry
 12    44*						   40o => esd entry */
 12    45     2 sentinel char (32) aligned,			/* set by bce (for now) */
 12    46     2 sst_sdw bit (72),				/* set by init_sst */
 12    47     2 hc_dbr bit (72),				/* set by start_cpu, idle DBR */
 12    48     2 message char (64),				/* message for return to bce */
 12    49     2 return_to_bce_command char (128) unal;		/* command to run upon crash/shutdown */
 12    50 
 12    51 declare FLAGBOX_SENTINEL char (32) init ("Flagbox & Toehold Valid") int static options (constant);
 12    52 
 12    53 /* END INCLUDE FILE ... flagbox.incl.pl1 */
       87 
       88    call add ("fgbx", addr (p -> fgbx));
 13     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
 13     2 
 13     3 /****^  HISTORY COMMENTS:
 13     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
 13     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
 13     6*     Add the subvolume info.
 13     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 13     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 13     9*     Added inconsistent_dbm bit used to determine consistency of volume
 13    10*     dumper bit maps.
 13    11*                                                   END HISTORY COMMENTS */
 13    12 
 13    13 /* This is the label at fixed location of each physical volume. Length 1 page */
 13    14 /* Note: fsout_vol clears pad fields before writing the label */
 13    15 
 13    16 dcl  labelp ptr;
 13    17 
 13    18 dcl 1 label based (labelp) aligned,
 13    19 
 13    20 /* First comes data not used by Multics.. for compatibility with GCOS */
 13    21 
 13    22     2 gcos (5*64) fixed bin,
 13    23 
 13    24 /* Now we have the Multics label */
 13    25 
 13    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
 13    27     2 version fixed bin,				/* Version 1 */
 13    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
 13    29     2 pv_name char (32),				/* Physical volume name. */
 13    30     2 lv_name char (32),				/* Name of logical volume for pack */
 13    31     2 pvid bit (36),				/* Unique ID of this pack */
 13    32     2 lvid bit (36),				/* unique ID of its logical vol */
 13    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
 13    34     2 time_registered fixed bin (71),			/* time imported to system */
 13    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
 13    36     2 vol_size fixed bin,				/* total size of volume, in records */
 13    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
 13    38     2 not_used bit (1) unal,				/* used to be multiple_class */
 13    39     2 private bit (1) unal,				/* TRUE if was registered as private */
 13    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
 13    41     2 flagpad bit (33) unal,
 13    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
 13    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
 13    44     2 password bit (72),				/* not yet used */
 13    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
 13    46     2 this_sv fixed bin,				/* what subvolume number it is */
 13    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
 13    48     2 pad1 (13) fixed bin,
 13    49     2 time_mounted fixed bin (71),			/* time mounted */
 13    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
 13    51 
 13    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
 13    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
 13    54* */
 13    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
 13    56     2 pad6 fixed bin,				
 13    57 
 13    58     2 time_salvaged fixed bin (71),			/* time salvaged */
 13    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
 13    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
 13    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
 13    62     2 pad1a (2) fixed bin,
 13    63     2 err_hist_size fixed bin,			/* size of pack error history */
 13    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
 13    65     2 time_last_reloaded fixed bin (71),		/* what it says */
 13    66     2 pad2 (40) fixed bin,
 13    67     2 root,
 13    68       3 here bit (1),				/* TRUE if the root is on this pack */
 13    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
 13    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
 13    71       3 pad7 bit (1) aligned,				
 13    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
 13    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
 13    74       3 esd_state fixed bin,				/* State of esd */
 13    75     2 volmap_record fixed bin,			/* Begin record of volume map */
 13    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
 13    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
 13    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
 13    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
 13    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
 13    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
 13    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
 13    83     2 pad3 (52) fixed bin,
 13    84     2 nparts fixed bin,				/* Number of special partitions on pack */
 13    85     2 parts (47),
 13    86       3 part char (4),				/* Name of partition */
 13    87       3 frec fixed bin,				/* First record */
 13    88       3 nrec fixed bin,				/* Number of records */
 13    89       3 pad5 fixed bin,
 13    90     2 pad4 (5*64) fixed bin;
 13    91 
 13    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
 13    93 
 13    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
       89 
       90    dcl 1 disk_label aligned like label based;
       91    call add ("disk_label", addr (p -> disk_label));
       92 
 14     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
 14     2 
 14     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
 14     4 
 14     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
 14     6 
 14     7 /* format: style3 */
 14     8 
 14     9 declare	lock_ptr		pointer;
 14    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
 14    11 	  2 pid		bit (36) aligned,		/* holder of lock */
 14    12 	  2 event		bit (36) aligned,		/* event associated with lock */
 14    13 	  2 flags		aligned,
 14    14 	    3 notify_sw	bit (1) unaligned,
 14    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
 14    16 
 14    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
       93 
       94    call add ("hc_fast_lock", addr (p -> hc_fast_lock));
       95 
       96 begin;	/* to avoid conflict with lock_ptr in hc_fast_lock */
       97   /*  START OF:	io_page_tables.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 15     2 
 15     3 /* Definition of the I/O page table segment.  For details of how this is manipulated, see io_page_table.pl1. */
 15     4 /* Written April 1983 by Chris Jones */
 15     5 /* Modified 1985-01-02, BIM: removed include of hc_lock. */
 15     6 
 15     7 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 15     8 dcl	io_page_table_seg$	   external;
 15     9 
 15    10 dcl	io_page_table_seg_ptr  ptr;
 15    11 
 15    12 dcl	1 io_page_tables	   aligned based (io_page_table_seg_ptr),
 15    13 	  2 lock		   like hc_fast_lock,	/* (0) standard fast lock */
 15    14 	  2 free_64_ptx	   fixed bin (9) unsigned unaligned,
 15    15 						/* (3) index of first free 64 word pt */
 15    16 	  2 free_256_ptx	   fixed bin (9) unsigned unaligned,
 15    17 						/* (3) pointer to first free 256 word pt */
 15    18 	  2 n_pages_wired	   fixed bin (9) unsigned unaligned,
 15    19 						/* (3) how many pages are in use now */
 15    20 	  2 pad1		   bit (9) unaligned,
 15    21 	  2 pt_info	   (5:256),		/* (4) one for each page table */
 15    22 	    3 size	   bit (1) unaligned,
 15    23 	    3 in_use	   bit (1) unaligned,
 15    24 	    3 pad1	   bit (25) unaligned,
 15    25 	    3 next_pt	   fixed bin (9) unsigned unaligned;
 15    26 
 15    27 /* This include file requires hc_fast_lock.incl.pl1 */
 15    28 
 15    29 dcl	ioptp		   ptr;
 15    30 dcl	io_page_table_size	   fixed bin;
 15    31 
 15    32 dcl	1 page_table	   (0:io_page_table_size - 1) aligned based (ioptp),
 15    33 	  2 ptw		   like io_ptw;
 15    34 
 16     1 /* Begin include file io_ptw.incl.pl1 */
 16     2 
 16     3 dcl  io_ptwp ptr;
 16     4 dcl  1 io_ptw aligned based (io_ptwp),
 16     5        2 pad1 bit (2) unaligned,
 16     6        2 address uns fixed bin (16) unaligned,
 16     7        2 pad2 bit (13) unaligned,
 16     8        2 write bit (1) unaligned,
 16     9        2 housekeeping bit (1) unaligned,
 16    10        2 valid bit (1) unaligned,
 16    11        2 pad3 bit (2) unaligned;
 16    12 
 16    13 /* End include file io_ptw.incl.pl1 */
 15    35 
 15    36 
 15    37 dcl	IO_PAGE_TABLE_LOCK_EVENT
 15    38 			   char (4) static options (constant) init ("iopt");
 15    39 dcl	MAX_IO_PAGE_TABLE_SEG_PAGES
 15    40 			   fixed bin (9) static options (constant) init (16);
 15    41 dcl	PT_64_SIZE	   bit (1) static options (constant) init ("0"b);
 15    42 dcl	PT_256_SIZE	   bit (1) static options (constant) init ("1"b);
 15    43 dcl	PTS_PER_PAGE	   fixed bin static options (constant) init (16);
 15    44 dcl	SMALL_PT_SIZE	   fixed bin (19) static options (constant) init (65536);
 15    45 
 15    46 /*  END OF:	io_page_tables.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       97 
       98      declare 1 io_page_table_256 (0:255) aligned like io_ptw based;
       99      declare 1 io_page_table_64 (0:63) aligned like io_ptw based;
      100      call add ("io_page_tables", addr (p -> io_page_tables));
      101      call add ("io_page_table_256", addr (p -> io_page_table_256));
      102      call add ("io_page_table_64", addr (p -> io_page_table_64));
      103      call add ("io_ptw", addr (p -> io_ptw));
      104   end;
      105 
 17     1 /* Begin include file ...... io_special_status.incl.pl1 */
 17     2 /* Written February 1981 by Chris Jones (from iom_stat.incl.pl1) */
 17     3 
 17     4 
 17     5 /****^  HISTORY COMMENTS:
 17     6*  1) change(88-01-06,Farley), approve(88-03-01,MCR7831),
 17     7*     audit(88-03-01,Parisek), install(88-03-08,MR12.2-1032):
 17     8*     Corrected channel size to 6 bits, was incorrectly set to 8.
 17     9*                                                   END HISTORY COMMENTS */
 17    10 
 17    11 
 17    12 dcl  io_special_status_ptr ptr;			/* pointer to status */
 17    13 
 17    14 dcl  1 io_special_status based (io_special_status_ptr) aligned,
 17    15 						/* special status from PSIA */
 17    16        (
 17    17        2 t bit (1),					/* entry present bit */
 17    18        2 pad bit (2),
 17    19        2 channel bit (6),				/* channel number */
 17    20        2 pad1 bit (3),
 17    21        2 device bit (6),				/* device address */
 17    22        2 pad2 bit (1),
 17    23        2 byte2 bit (8),				/* device dependent information */
 17    24        2 pad3 bit (1),
 17    25        2 byte3 bit (8)
 17    26        ) unal;					/* device dependent information */
 17    27 
 17    28 /* End of include file io_special_status.incl.pl1 */
      106 
      107    call add ("io_special_status", addr (p -> io_special_status));
 18     1 /* include io_status */
 18     2 dcl 1 status, 					/* I/O system status string. */
 18     3     2 code fixed binary,				/* Overall error code. */
 18     4     2 bits, 					/* Fine structure. */
 18     5       3 successful bit (4), 				/* Logical/physical initiation/termination. */
 18     6       3 transaction_terminated bit (1), 		/* No further status change. */
 18     7       3 unassigned bit (4),
 18     8       3 end_of_data bit (1), 				/* Obvious. */
 18     9       3 pad bit (5),
 18    10       3 ioname_detached bit (1), 			/* .. */
 18    11       3 pad2 bit (20),
 18    12      status_bits based (sp) bit (72) aligned; 		/* Overlay for IO calls. */
 18    13 						/* end io_status */
      108 
      109    dcl 1 io_status aligned like status based;
      110    call add ("io_status", addr (p -> io_status));
 19     1 /* Begin include file io_status_entry.incl.pl1 */
 19     2 /* Written by C. Hornig sometime late in 1980. */
 19     3 /* Modified January 1983 by Chris Jones to show detailed status. */
 19     4 
 19     5 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 19     6 dcl	io_status_entry_ptr	   ptr;
 19     7 dcl	1 io_status_entry	   aligned based (io_status_entry_ptr),
 19     8 	  2 word1		   like io_status_word,	/* major status word */
 19     9 	  2 word2,
 19    10 	    3 next_lpw_offset  bit (18) unaligned,
 19    11 	    3 rfu1	   bit (5) unaligned,
 19    12 	    3 workspace	   bit (1) unaligned,	/* DCW is in the workspace */
 19    13 	    3 rfu2	   bit (12) unaligned,
 19    14 	  2 word3		   bit (36),
 19    15 	  2 word4,
 19    16 	    3 next_dcw_offset  bit (18) unaligned,	/* 1 + offset of last data word */
 19    17 	    3 character_position
 19    18 			   uns fixed bin (3) unaligned,
 19    19 	    3 write	   bit (1) unaligned,
 19    20 	    3 action_code	   bit (2) unaligned,
 19    21 	    3 tally_residue	   uns fixed bin (12) unaligned,
 19    22 						/* residue of last DCW tally */
 19    23 	  2 word5,
 19    24 	    3 data_count	   uns fixed bin (26) unaligned,
 19    25 						/* total words transferred (on IIOC & IOX) */
 19    26 	    3 rfu		   bit (10) unaligned,
 19    27 	  2 words		   (6:8) bit (36),
 19    28 	  2 detailed_status	   (8) bit (36);		/* detailed status (IIOC and IOX) */
 19    29 
 20     1 /* Begin include file io_status_word.incl.pl1 */
 20     2 /* Made from iom_stat.incl.pl1 by C. Hornig */
 20     3 
 20     4 dcl  io_status_word_ptr ptr;
 20     5 dcl  1 io_status_word based (io_status_word_ptr) aligned,	/* I/O status information */
 20     6        (
 20     7        2 t bit (1),					/* set to "1"b by IOM */
 20     8        2 power bit (1),				/* non-zero if peripheral absent or power off */
 20     9        2 major bit (4),				/* major status */
 20    10        2 sub bit (6),				/* substatus */
 20    11        2 eo bit (1),				/* even/odd bit */
 20    12        2 marker bit (1),				/* non-zero if marker status */
 20    13        2 soft bit (2),				/* software status */
 20    14        2 initiate bit (1),				/* initiate bit */
 20    15        2 abort bit (1),				/* software abort bit */
 20    16        2 channel_stat bit (3),			/* IOM channel status */
 20    17        2 central_stat bit (3),			/* IOM central status */
 20    18        2 mbz bit (6),
 20    19        2 rcount bit (6)
 20    20        ) unaligned;					/* record count residue */
 20    21 
 20    22 /* End include file io_status_word.incl.pl1 */
 19    30 
 19    31 
 19    32 /* End include file io_status_entry.incl.pl1 */
      111 
      112    call add ("io_status_entry", addr (p -> io_status_entry));
      113    call add ("io_status_word", addr (p -> io_status_word));
 21     1 /* Begin include file ..... io_syserr_msg.incl.pl1 */
 21     2 
 21     3 /* Created October 1975 by Larry Johnson */
 21     4 /* Modified 11/11/76 by Noel I. Morris */
 21     5 /* Modified November 1979 by Larry Johnson for detailed status */
 21     6 /* Modified February 1981 by Chris Jones to use channel names */
 21     7 
 21     8 /* This include file defines the format of the syserr message generated for I/O errors. */
 21     9 /* This message is also defined (size and type) by the "io_msg" and "io_msg_detail"
 21    10*   constants in syserr_binary_def.incl.pl1 */
 21    11 
 21    12 dcl  io_msgp ptr;					/* Pointer to syserr message structure */
 21    13 
 21    14 dcl  1 io_msg aligned based (io_msgp),
 21    15        (
 21    16        2 level bit (3),				/* Level of interrupt being logged */
 21    17        2 fill1 bit (9),
 21    18        2 device bit (6),				/* Device which caused error */
 21    19        2 time_out bit (1),				/* Set if error caused by channel timeout */
 21    20        2 type bit (2),				/* Type of last DCW */
 21    21        2 command bit (6),				/* Command being executed by device */
 21    22        2 fill2 bit (3),
 21    23        2 count bit (6)
 21    24        ) unal,					/* Count of message repetitions */
 21    25        2 channel char (8),				/* Channel over which interrupt came */
 21    26        2 status bit (36),				/* First word of IOM status */
 21    27        2 devname char (4),				/* Device name */
 21    28        2 detailed_status bit (216) unaligned;               /* Optional detailed device status */
 21    29 
 21    30 /* End include file ..... io_syserr_msg.incl.pl1 */
      114  call add ("io_msg", addr (p -> io_msg));
 22     1 /* BEGIN INCLUDE FILE iocbx.incl.pl1 */
 22     2 /* written 27 Dec 1973, M. G. Smith */
 22     3 /* returns attributes removed, hashing support BIM Spring 1981 */
 22     4 /* version made character string June 1981 BIM */
 22     5 /* Modified 11/29/82 by S. Krupp to add new entries and to change
 22     6*      version number to IOX2. */
 22     7 /* format: style2 */
 22     8 
 22     9      dcl	   1 iocb		      aligned based,	/* I/O control block. */
 22    10 	     2 version	      character (4) aligned,	/* IOX2 */
 22    11 	     2 name	      char (32),		/* I/O name of this block. */
 22    12 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
 22    13 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
 22    14 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
 22    15 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
 22    16 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
 22    17 	     2 event_channel      bit (72),		/* Event channel for asynchronous I/O. */
 22    18 	     2 detach_iocb	      entry (ptr, fixed bin (35)),
 22    19 						/* detach_iocb(p) */
 22    20 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed bin (35)),
 22    21 						/* open(p,mode,not_used) */
 22    22 	     2 close	      entry (ptr, fixed bin (35)),
 22    23 						/* close(p) */
 22    24 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
 22    25 						/* get_line(p,bufptr,buflen,actlen) */
 22    26 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
 22    27 						/* get_chars(p,bufptr,buflen,actlen) */
 22    28 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed bin (35)),
 22    29 						/* put_chars(p,bufptr,buflen) */
 22    30 	     2 modes	      entry (ptr, char (*), char (*), fixed bin (35)),
 22    31 						/* modes(p,newmode,oldmode) */
 22    32 	     2 position	      entry (ptr, fixed, fixed (21), fixed bin (35)),
 22    33 						/* position(p,u1,u2) */
 22    34 	     2 control	      entry (ptr, char (*), ptr, fixed bin (35)),
 22    35 						/* control(p,order,infptr) */
 22    36 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed bin (35)),
 22    37 						/* read_record(p,bufptr,buflen,actlen) */
 22    38 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed bin (35)),
 22    39 						/* write_record(p,bufptr,buflen) */
 22    40 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed bin (35)),
 22    41 						/* rewrite_record(p,bufptr,buflen) */
 22    42 	     2 delete_record      entry (ptr, fixed bin (35)),
 22    43 						/* delete_record(p) */
 22    44 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed bin (35)),
 22    45 						/* seek_key(p,key,len) */
 22    46 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed bin (35)),
 22    47 						/* read_key(p,key,len) */
 22    48 	     2 read_length	      entry (ptr, fixed (21), fixed bin (35)),
 22    49 						/* read_length(p,len) */
 22    50 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
 22    51 						/* open_file(p,mode,desc,not_used,s) */
 22    52 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
 22    53 						/* close_file(p,desc,s) */
 22    54 	     2 detach	      entry (ptr, char (*), fixed bin (35)),
 22    55 						/* detach(p,desc,s) */
 22    56 						/* Hidden information, to support SYN attachments. */
 22    57 	     2 ios_compatibility  ptr,		/* Ptr to old DIM's IOS transfer vector. */
 22    58 	     2 syn_inhibits	      bit (36),		/* Operations inhibited by SYN. */
 22    59 	     2 syn_father	      ptr,		/* IOCB immediately SYNed to. */
 22    60 	     2 syn_brother	      ptr,		/* Next IOCB SYNed as this one is. */
 22    61 	     2 syn_son	      ptr,		/* First IOCB SYNed to this one. */
 22    62 	     2 hash_chain_ptr     ptr;		/* Next IOCB in hash bucket */
 22    63 
 22    64      declare iox_$iocb_version_sentinel
 22    65 			      character (4) aligned external static;
 22    66 
 22    67 /* END INCLUDE FILE iocbx.incl.pl1 */
      115  	call add ("iocb", addr (p -> iocb));
      116 begin; /* There is a conflict with "dte" */
      117    /* Begin include file ...... ioi_data.incl.pl1 */
 23     2 
 23     3 
 23     4 /****^  HISTORY COMMENTS:
 23     5*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
 23     6*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
 23     7*     Support for FIPS and
 23     8*     IMU.
 23     9*  2) change(86-05-16,Kissel), approve(86-07-30,MCR7461), audit(86-07-31,Coren),
 23    10*     install(86-08-19,MR12.0-1120):
 23    11*     Changed the value of IOI_DEFAULT_MAX_BOUND from 4096 to 1024.  This
 23    12*     corrects a problem when RCP tries to set the maximum workspace size if it
 23    13*     is less than 4096.  Since ioi_ (actually grab_aste) touched all the pages
 23    14*     at assignment time, the current length is 4, and trying to set the max
 23    15*     length to less than 4 (e.g. because the max unprivileged workspace size in
 23    16*     RCP for a special device is 1) returns an error.
 23    17*                                                   END HISTORY COMMENTS */
 23    18 
 23    19 /* Rewritten May 1982 by C. Hornig for new ioi_ */
 23    20 /* Rewrite finished March 1983 by Chris Jones */
 23    21 /* Extended for reconfiguration April 1983 by Chris Jones. */
 23    22 /* Modified November 1983 by Chris Jones to separate items in the dte protected by different locks. */
 23    23 /* Modified January 1984 by Chris Jones to add ite's. */
 23    24 /* Modified Feb 1984 by Rich Fawcett to add ipc and fips */
 23    25 /* Modified Sept 1985 by Paul Farley to add controller flag to dte. */
 23    26 
 23    27 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 23    28 
 23    29 dcl	idp		   ptr;			/* pointer to IOI data structure */
 23    30 dcl	gtep		   ptr;			/* pointer to channel/device group entry */
 23    31 dcl	ctep		   ptr;			/* pointer to channel table entry */
 23    32 dcl	dtep		   ptr;			/* pointer to wired device table entry */
 23    33 dcl	itep		   ptr;			/* pointer to I/O multiplexer entry */
 23    34 
 23    35 dcl	(ioi_subsystems, ioi_devices, ioi_channels, ioi_multiplexers)
 23    36 			   fixed bin;
 23    37 dcl	ioi_data$		   external;		/* IOI data segment */
 23    38 
 23    39 
 23    40 dcl	1 ioi_data	   based (idp) aligned,	/* I/O Interfacer data structure */
 23    41 	  2 ngt		   fixed bin,		/* number of groups */
 23    42 	  2 nct		   fixed bin,		/* number of channels */
 23    43 	  2 ndt		   fixed bin,		/* number of devices */
 23    44 	  2 nit		   fixed bin,		/* number of IOMs */
 23    45 	  2 spurious_interrupts
 23    46 			   fixed bin (35),		/* interrupts with no status */
 23    47 	  2 reconfig_lock	   like lock,		/* lock for reconfiguring devices, channels, etc. */
 23    48 	  2 flags,
 23    49 	    3 setup	   bit (1) unal,		/* "1"b => ioi_init has run */
 23    50 	    3 pad1	   bit (35) unal,
 23    51 	  2 rss_idcw	   bit (36),		/* reset status IDCW */
 23    52 	  2 pad2		   (6) fixed bin (35),	/* pad to 16 words */
 23    53 	  2 dt		   (ioi_devices refer (ioi_data.ndt)) like dte aligned,
 23    54 						/* device table */
 23    55 	  2 gt		   (ioi_subsystems refer (ioi_data.ngt)) like gte aligned,
 23    56 						/* channel/device group table */
 23    57 	  2 ct		   (ioi_channels refer (ioi_data.nct)) like cte aligned,
 23    58 						/* channel table */
 23    59 	  2 it		   (ioi_multiplexers refer (ioi_data.nit)) like ite aligned;
 23    60 						/* multiplexer table */
 24     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
 24     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
 24     3*   encourages name conflicts.
 24     4*   USE HC_FAST_LOCK INSTEAD!
 24     5**/
 24     6 
 24     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
 24     8 
 24     9 /* format: style3 */
 24    10 
 24    11 declare	lock_ptr		pointer;
 24    12 declare	1 lock		aligned based (lock_ptr),
 24    13 	  2 pid		bit (36) aligned,		/* holder of lock */
 24    14 	  2 event		bit (36) aligned,		/* event associated with lock */
 24    15 	  2 flags		aligned,
 24    16 	    3 notify_sw	bit (1) unaligned,
 24    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
 24    18 
 24    19 /* End include file hc_lock.incl.pl1 */
 23    61 
 23    62 
 23    63 dcl	1 ite		   based (itep) aligned,	/* I/O multiplexer table entry */
 23    64 	  2 model		   char (4),		/* which flavor we are */
 23    65 	  2 flags,
 23    66 	  ( 3 deleting	   bit (1),
 23    67 	    3 deleted	   bit (1)
 23    68 	    )		   unaligned,
 23    69 	  2 pad1		   bit (16) unaligned,
 23    70 	  2 iom_table_idx	   fixed bin (17) unaligned,
 23    71 	  2 tag		   fixed bin (3),
 23    72 	  2 pad2		   (5) bit (36);
 23    73 
 23    74 dcl	1 gte		   based (gtep) aligned,	/* channel/device group table entry */
 23    75 	  2 lock		   bit (36),		/* (0) loop lock */
 23    76 	  2 name		   char (4),		/* (1) subsystem name */
 23    77 	  2 dtep		   bit (18) unaligned,	/* (2) rel ptr to device just serviced */
 23    78 	  2 ctep		   bit (18) unaligned,	/* (2) rel ptr to thread of channel table entries */
 23    79 	  2 detailed_status_cmd
 23    80 			   bit (6) unal,		/* (3) idcw command to read detailed status */
 23    81 	  2 flags		   unaligned,		/* (3) */
 23    82 	    3 psia	   bit (1),		/* "1"b if channel is PSIA */
 23    83 	    3 suspend_devices  bit (1),		/* "1"b if device I/O suspended */
 23    84 	    3 dual_controller  bit (1),		/* "1"b if dual controller subsystem (disk only) */
 23    85 	    3 ascii_dtst	   bit (1),		/* "1"b if detailed status sent in ASCII mode */
 23    86 	    3 mplex	   bit (1),		/* "1"b if channels are multiplexed among devices */
 23    87 	    3 ipc		   bit (1),		/* "1"b if devices are on an IMU */
 23    88 	    3 fips	   bit (1),		/* "1"b if devices start at zero */
 23    89 	    3 pad		   bit (23),
 23    90 	  2 n_devices	   fixed bin,		/* (4) number of devices in device table thread */
 23    91 	  2 pending_connects   fixed bin,		/* (5) count of pending connect requests */
 23    92 	  2 io_log_info_index  fixed bin,		/* (6) index into io_log_status_info table */
 23    93 	  2 disk_data_subsystem_idx
 23    94 			   fixed bin;		/* (7) index into disk_data.array for disks */
 23    95 
 23    96 dcl	1 cte		   based (ctep) aligned,	/* channel table entry */
 23    97 	  2 next_ctep	   bit (18) unaligned,	/* (0) rel ptr to next channel table entry */
 23    98 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
 23    99 	  2 flags1	   unaligned,		/* (1) */
 23   100 	    3 ioi_use	   bit (1),		/* "1"b if channel currently being used */
 23   101 	    3 connected	   bit (1),		/* "1"b if channel is connected */
 23   102 	    3 toss_status	   bit (1),		/* "1"b if status is to be ignored */
 23   103 	    3 quiescing	   bit (1),		/* "1"b if the channel is just finishing what it's doing */
 23   104 	    3 direct	   bit (1),		/* "1"b if this is a direct channel */
 23   105 	    3 pad1	   bit (4),
 23   106 	  2 disktab_ctx	   fixed bin (9) uns unal,	/* (1) index into disktab.chantab for this channel */
 23   107 	  2 cur_dtep	   bit (18) unaligned,	/* (1) current device table entry */
 23   108 	  2 chanid	   char (8),		/* (2) io_manager's name for channel */
 23   109 	  2 statusp	   ptr unal,		/* (4) pointer to first word of status */
 23   110 	  2 chx		   fixed bin (35),		/* (5) channel index for io_manager */
 23   111 	  2 time_limit	   fixed bin (71),		/* (6) connect time limit */
 23   112 	  2 saved_status	   unaligned,		/* (8) status repository while reading detailed status */
 23   113 	    3 word1	   bit (36),
 23   114 	    3 word2	   bit (36),
 23   115 	    3 word4	   bit (36),
 23   116 	    3 next_lpw_offset  bit (18),
 23   117 	    3 command	   bit (6),
 23   118 	  2 pad3		   bit (12) unaligned,	/* (11) */
 23   119 	  2 base_ctep	   bit (18) unaligned,	/* (12) rel ptr to base logical chan. of physical chan. */
 23   120 	  2 itep		   bit (18) unaligned,	/* (12) rel ptr to itep */
 23   121 	  2 flags2	   unaligned,		/* (13) */
 23   122 	    3 deleting	   bit (1),		/* "1"b if attempting to delete this channel */
 23   123 	    3 deleted	   bit (1),		/* "1"b if channel deleted */
 23   124 	  2 pad4		   bit (16) unaligned,	/* (13) */
 23   125 	  2 channel_table_idx  fixed bin (17) unaligned,
 23   126 	  2 pad5		   (2) bit (36);		/* (14) pad to 8 word boundary */
 23   127 
 23   128 dcl	1 dte		   based (dtep) aligned,	/* wired device table entry */
 23   129 	  2 next_dtep	   bit (18) unaligned,	/* (0) rel ptr to next entry in thread */
 23   130 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
 23   131 	  2 cur_ctep	   bit (18) unaligned,	/* (1) rel ptr to channel in use */
 23   132 	  2 flags1	   unaligned,		/* (1) flags protected by gte lock */
 23   133 	    3 connected	   bit (1),		/* "1"b if device has a channel */
 23   134 	    3 log_status_cnt   bit (1),		/* "1"b if count in log_status is valid */
 23   135 	    3 reading_detailed_status
 23   136 			   bit (1),		/* "1"b if read of detailed device status in progress */
 23   137 	    3 pad1	   bit (15),
 23   138 	  2 channel_required   char (8),		/* (2) channel name of required channel */
 23   139 	  2 ev_chn	   fixed bin (71),		/* (4) event ID for status wakeups */
 23   140 	  2 workspace_ptr	   ptr,			/* (6) workspace pointer */
 23   141 	  2 workspace_astep	   ptr,			/* (8) workspace ASTE ptr */
 23   142 	  2 workspace_sdw	   fixed bin (71),		/* (10) SDW of workspace segment */
 23   143 	  2 ptp		   ptr,			/* (12) device page table */
 23   144 	  2 max_bound	   fixed bin (19),		/* (14) largest allowable bound of workspace segment */
 23   145 	  2 bound		   fixed bin (19),		/* (15) bound of workspace */
 23   146 	  2 process_id	   bit (36),		/* (16) ID of process owning device */
 23   147 	  2 ring		   fixed bin (3),		/* (17) highest ring allowed to access device */
 23   148 	  2 device	   bit (6) unal,		/* (18) device code */
 23   149 	  2 flags2	   unal,			/* (18) constant or protected by dte lock */
 23   150 	    3 priv	   bit (1),		/* "1"b if privileged user */
 23   151 	    3 in_use	   bit (1),		/* "1"b if device is to be used */
 23   152 	    3 deleting	   bit (1),		/* "1"b if trying to delete this device */
 23   153 	    3 deleted	   bit (1),		/* "1"b if this device is deleted */
 23   154 	    3 suspended	   bit (1),		/* "1"b if device isn't to be used temporarily */
 23   155 	    3 workspace_wired  bit (1),		/* "1"b if workspace is wired */
 23   156               3 direct           bit (1),                   /* "1"b if device is connected to a direct channel */
 23   157 	    3 controller	   bit (1),		/* "1"b if dte for the devices controller */
 23   158 	    3 pad2	   bit (4),
 23   159 	  2 device_table_idx   fixed bin (17) unaligned,
 23   160 	  2 listx		   uns fixed bin (18) unal,	/* (19) DCW list index for connect */
 23   161 	  2 idcw_listx	   uns fixed bin (18) unal,	/* (19) DCW list index of IDCW */
 23   162 	  2 timeout	   fixed bin (35),		/* (20) time limit for I/O completion (usec) */
 23   163 	  2 max_timeout	   fixed bin (35),		/* (21) maximum allowable timeout grace time (usec) */
 23   164 	  2 unwire_time	   fixed bin (71),		/* (22) when to unwire the workspace */
 23   165 	  2 pcw		   bit (36),		/* (24) peripheral control word (PCW) */
 23   166 	  2 status_control,				/* (25) */
 23   167 	    3 status_offset	   fixed bin (18) unsigned unaligned,
 23   168 						/* offset of status queue in user workspace */
 23   169 	    3 status_entries   fixed bin (9) unsigned unaligned,
 23   170 						/* number of entries in status queue */
 23   171 	    3 status_entry_idx fixed bin (9) unsigned unaligned,
 23   172 						/* next entry to be used */
 23   173 	  2 idcw		   bit (36),		/* (26) instruction DCW (KEEP ON EVEN WORD BOUNDARY) */
 23   174 	  2 tdcw		   bit (36),		/* (27) transfer DCW to remainder of list */
 23   175 	  2 special_status	   bit (36),		/* (28) special interrupt status */
 23   176 	  2 lock		   like lock,		/* (29) wait lock */
 23   177 	  2 log_status,				/* (32) */
 23   178 	  ( 3 level	   fixed bin (3) unsigned,
 23   179 	    3 time_out	   bit (1),
 23   180 	    3 type	   bit (2),
 23   181 	    3 command	   bit (6),
 23   182 	    3 count	   fixed bin (6) unsigned,
 23   183 	    3 channel	   bit (18),
 23   184 	    3 status	   bit (36)
 23   185 	    )		   unaligned,
 23   186 	  2 ptx		   fixed bin,		/* (34) index of page table */
 23   187 	  2 active	   bit (1),		/* (35) "1"b if device running or to run */
 23   188 	  2 special_interrupt  bit (1),		/* (36) "1"b if special interrupt received */
 23   189 	  2 detailed_status_valid
 23   190 			   bit (1),		/* (37) "1"b if detailed status read sucessfully */
 23   191 	  2 last_log_time	   fixed bin (71),		/* (38) when status was last logged */
 23   192 	  2 detailed_status	   (8) bit (36),		/* (40) (buffer for reading most recent detailed status */
 23   193 	  2 log_detailed_status
 23   194 			   (8) bit (36);		/* (48) copy of last detailed status logged */
 23   195 
 23   196 /**** Defaults for various I/O parameters */
 23   197 
 23   198 dcl	IOI_DEFAULT_MAX_BOUND  fixed bin (19) static options (constant) init (1024);
 23   199 dcl	IOI_DEFAULT_MAX_TIMEOUT
 23   200 			   fixed bin (35) static options (constant) init (30000000);
 23   201 dcl	IOI_DEFAULT_TIMEOUT	   fixed bin (35) static options (constant) init (30000000);
 23   202 
 23   203 dcl	IO_STATUS_ERROR_MASK   bit (36) static options (constant) init ("370000770000"b3);
 23   204 
 23   205 dcl	IO_CHANNEL_LOCK_TEMPLATE
 23   206 			   char (2) int static options (constant) init ("ch");
 23   207 dcl	IOI_DEVICE_LOCK_EVENT_TEMPLATE
 23   208 			   char (2) static options (constant) init ("dv");
 23   209 
 23   210 /* End of include file ...... ioi_data.incl.pl1 */
      117 
      118       call addx ("ioi_data", addr (p -> ioi_data));
      119       call addx ("gte", addr (p -> gte)); /* addx because of conflict with */
      120       call addx ("cte", addr (p -> cte)); /* add in ioi_data! */
      121       call addx ("dte", addr (p -> dte));
      122       end;
 25     1 /* Begin include file ...... iom_data.incl.pl1
 25     2*   First written in August 1971 by R F Mabee.
 25     3*   Modified for paged IOM November 1980 by C. Hornig.
 25     4*   More IIOC changes by C. Hornig, June 1982.
 25     5*   Modified for channel reconfiguration by Chris Jones, January 1984.
 25     6*   Modified to remove support of non-paged IOMs by Chris Jones, August 1984.
 25     7*   Modified to add IMW read protocol flags by M. Pandolf, January 1985.
 25     8**/
 25     9 
 25    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 25    11 dcl	iom_data$		   external;
 25    12 dcl	iom_mailbox$	   external;
 25    13 
 25    14 dcl	n_devices		   fixed bin;
 25    15 dcl	iom_data_ptr	   ptr;
 25    16 
 25    17 dcl	1 iom_data	   based (iom_data_ptr) aligned,
 25    18 	  2 n_devices	   fixed bin,		/* (0) Maximum number of channels. */
 25    19 	  2 stop_lpw	   bit (36),		/* (1) LPW pointing to stop_dcw. */
 25    20 	  2 stop_dcw	   bit (36),		/* (2) DCW to stop channel, probably storing bad status. */
 25    21 	  2 stop_scw	   bit (36),		/* (3) SCW for same */
 25    22 	  2 imw_lock	   fixed bin (35),		/* (4) Essentially a lock for iom switch checking: */
 25    23 						/* 1  : OK to poll IMW */
 25    24 						/* 0  : lock in transition */
 25    25 						/* -1 : DONT poll IMW */
 25    26 	  2 n_intr_procs fixed bin (35),		/* (5) Number of processors in interrupt handler */
 25    27 	  2 pad1		   (2) bit (36),
 25    28 	  2 stop_status	   bit (72),		/* (10) All unused channels store status here. */
 25    29 	  2 rfh1		   (6) bit (36),		/* can't use this */
 25    30 	  2 stop_ext_status	   bit (8 * 36),		/* (20) Unused channels' extended status */
 25    31 	  2 pad3		   (5) bit (36),
 25    32 	  2 invalid_interrupts fixed bin (35),		/* (35) interrupts on unused channels */
 25    33 	  2 null_interrupts	   fixed bin (35),		/* (36) spurious interrupts */
 25    34 	  2 multiple_interrupts
 25    35 			   fixed bin (35),		/* (37) several interrupts at a time */
 25    36 	  2 per_iom	   (4) like per_iom,	/* (40) for each IOM */
 25    37 	  2 per_device	   (n_devices refer (iom_data.n_devices)) like per_device;
 25    38 						/* (240) Data for assigned channels. */
 25    39 
 25    40 dcl	1 per_iom		   aligned based,
 25    41 	  2 lock		   bit (36),		/* (40) connect mailbox lock */
 25    42 	  2 flags,				/* (41) */
 25    43 	    3 configured	   bit (1) unal,		/* is configured */
 25    44 	    3 on_line	   bit (1) unal,		/* is ON */
 25    45 	    3 pad1	   bit (34) unal,
 25    46 	  2 model		   char (4),		/* (42) what kind of IOM */
 25    47 	  2 port		   fixed bin (3),		/* (43) SC port */
 25    48 	  2 connect_time	   fixed bin (71),		/* (44) time of last connect */
 25    49 	  2 connect_lpw	   bit (36),		/* (46) LPW for connect channel */
 25    50 	  2 cow		   bit (36),		/* (47) Connect Operand Word */
 25    51 	  2 special_chx	   fixed bin (35),		/* (50) chx of special status channel */
 25    52 	  2 fault_chx	   fixed bin (35),		/* (51) chx of system fault channel */
 25    53 	  2 pad2		   (4) bit (36),
 25    54 	  2 abandoned_connects fixed bin (35),		/* (56) times we couldn't get IOM to listen at all */
 25    55 	  2 reconnects	   fixed bin (35),		/* (57) times a connect was lost */
 25    56 	  2 chantab	   (0:63) uns fixed bin (9) unal;
 25    57 						/* (60) packed devtab indices */
 25    58 
 25    59 dcl	1 per_device	   aligned based,
 25    60 	  2 status	   bit (72),		/* (0) Status for channel is stored here. */
 25    61 	  2 rfh1		   (6) bit (36),
 25    62 	  2 ext_status	   bit (8 * 36),		/* (10) extended status stored by IIOC */
 25    63 	  2 iom		   uns fixed bin (3),	/* (20) IOM# (1-4) */
 25    64 	  2 channel	   uns fixed bin (6),	/* (21) channel # */
 25    65 	  2 handler	   entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 25    66 						/* (22) Interrupt handler for device. */
 25    67 	  2 flags,				/* (26) */
 25    68 	    3 in_use	   bit (1) unal,		/* assigned */
 25    69 	    3 queue_status	   bit (1) unal,		/* maintain status queue */
 25    70 	    3 on_line	   bit (1) unal,		/* can be assigned */
 25    71 	  2 index		   fixed bin (35),		/* (27) Channel identification index. */
 25    72 	  2 pcw		   bit (72),		/* (30) Peripheral Control Word */
 25    73 	  2 lpw		   bit (72),		/* (32) List Pointer Word */
 25    74 	  2 scw		   bit (36),		/* (34) Status Control Word */
 25    75 	  2 pad1		   fixed bin (35),
 25    76 	  2 status_queue_ptr   ptr,			/* (36) Status queue */
 25    77 	  2 connect_time	   fixed bin (71),		/* (40) time of last connect */
 25    78 	  2 connects	   fixed bin (71),		/* (42) Total connects */
 25    79 	  2 interrupts	   fixed bin (71),		/* (44) Total number of interrupts for this channel. */
 25    80 	  2 interrupt_time	   fixed bin (71);		/* (46) Total interrupt time for this channel. */
 25    81 
 25    82 dcl	iom_mailbox_seg_ptr	   ptr;
 25    83 dcl	1 iom_mailbox_seg	   aligned based (iom_mailbox_seg_ptr),
 25    84 	  2 imw_array	   (0:31) bit (32),		/* Indexed by interrupt cell number. One bit for each channel. */
 25    85 	  2 system_fault	   (4) aligned like status_queue,
 25    86 						/* system faults store here (12 words/IOM) */
 25    87 	  2 special_status	   (4) aligned like status_queue,
 25    88 						/* special status words here (12 words/IOM) */
 25    89 	  2 iom_mailbox	   (4) like iom_mailbox;	/* Used to communicate with the IOM. */
 25    90 
 25    91 dcl	status_queue_ptr	   ptr;
 25    92 dcl	1 status_queue	   aligned based (status_queue_ptr),
 25    93 	  2 status	   (12) bit (36);
 25    94 
 25    95 dcl	1 iom_mailbox	   aligned based,
 25    96 	  2 channel_mailbox	   (0:63) like channel_mailbox;
 25    97 
 25    98 dcl	1 channel_mailbox	   aligned based,
 25    99 	  2 lpw		   bit (72),		/* List pointer word. Points to DCW list. */
 25   100 	  2 scw		   bit (36),		/* Status control word. Points to channel_table.status. */
 25   101 	  2 dcw		   bit (36);		/* Data control word. Primarily scratch space for IOM. */
 25   102 
 25   103 /* Defined channel numbers. */
 25   104 
 25   105 dcl	(
 25   106 	system_fault_channel   init (1),		/* Stores system fault words using LPW and DCW. */
 25   107 	connect_channel	   init (2),		/* Starts other channels using LPW pointing to PCW. */
 25   108 	special_status_channel init (6)		/* Stores special status using LPW and DCW. */
 25   109 	)		   fixed bin (6) static options (constant);
 25   110 
 25   111 /* End of include file ..... iom_data.incl.pl1 */
      123 
      124    call add ("iom_data", addr (p -> iom_data));
      125    dcl 1 iom_per_device aligned like per_device based;
      126    call add ("iom_per_device", addr (p -> iom_per_device));
      127    dcl 1 iom_per_iom aligned like per_iom based;
      128    call add ("iom_per_iom", addr (p -> iom_per_iom));
      129    call add ("iom_mailbox_seg", addr (p -> iom_mailbox_seg));
      130    call add ("iom_mailbox", addr (p -> iom_mailbox));
      131    call add ("channel_mailbox", addr (p -> channel_mailbox));
      132 
      133 /* Followed by the include file containing the code to do the work */
      134 
      135 dcl  WHOAMI char (32) internal static options (constant) init ("structure_library_2_");
      136 
 26     1 
 26     2 
 26     3 /* *  	STRUCTURE_LIBRARY_CODE.INCL.PL1
 26     4*   *
 26     5*   *	This procedure generates the default library segment for the
 26     6*   *      structure display system.  The way it operates is hardly what one
 26     7*   *      would call normal, however. It has to do a number of rather unclean
 26     8*   *      things, and modifications must be made carefully following these
 26     9*   *      conventions:
 26    10*   * 
 26    11*   *      Because the compiler insists on actually having a structure appear
 26    12*   *      in some reference context for it to appear in the symbol table,
 26    13*   *      regardless of options, every structure defined herein must be
 26    14*   *      referenced somehow. This is accomplished with the calls to the
 26    15*   *      "add" procedure. The first argument to the "add" procedure is the
 26    16*   *      name of the structure, put there so it can be added to the table
 26    17*   *      of contents for the segment.
 26    18*   *
 26    19*   *      The second argument to the add procedure is a pointer, which must
 26    20*   *      always be of the form "addr (p -> structure)".  This is done to 
 26    21*   *      that the structure will be referenced, while at the same time 
 26    22*   *      avoiding any reference to its implicit base, or to other values
 26    23*   *      which must be initialized to avoid warnings.  
 26    24*   *
 26    25*   *      Finally, this program compiles and runs itself using 
 26    26*   *      create_data_segment; this is done both to ensure that it gets
 26    27*   *      compiled with a symbol table, and to make it possible copy the 
 26    28*   *      object segment and write into the internal static options (constant)
 26    29*   *      array that is the table of structures. All in all, it's pretty 
 26    30*   *      complicated.
 26    31*   *
 26    32*   *      The code for this program is in an include file in order to ease
 26    33*   *	the construction of user-defined structure libraries. In order to
 26    34*   *      use this code, one must create a program looking like this:
 26    35*   *
 26    36*   *	structure_library_7_:
 26    37*   *	     procedure ();
 26    38*   *
 26    39*   *		< %include statements, calls to add >
 26    40*   *
 26    41*   *       dcl  WHOAMI char (32) internal static options (constant) init ("structure_library_7_");
 26    42*   *	%include structure_library_code;
 26    43*   *	          end structure_library_7_;
 26    44*   *
 26    45*   *	The standard structure libraries (structure_library_1_.cds,
 26    46*   *	for example, provide a good example of this.
 26    47*   *	
 26    48*   *      30 May 1983, W. Olin Sibert
 26    49*   */
 26    50 
 26    51 /*  */
 26    52 
 26    53 /* Now come the more ordinary parts of code that usually appear in a program */
 26    54 
 26    55 dcl  code	fixed binary (35);
 26    56 dcl  severity_ptr pointer;
 26    57 dcl  severity_value fixed bin (35) based (severity_ptr);
 26    58 dcl  answer bit (1) aligned;
 26    59 dcl  new_segp pointer;
 26    60 dcl  old_segp pointer;
 26    61 dcl  bitcount fixed bin (24);
 26    62 dcl  n_words fixed bin (18);
 26    63 dcl  based_words (n_words) bit (36) aligned based;
 26    64 
 26    65 dcl  p pointer init (null ());			/* our general-purpose base */
 26    66 
 26    67 dcl  com_err_ entry options (variable);
 26    68 dcl  command_query_$yes_no entry options (variable);
 26    69 dcl  get_external_variable_ entry (char (*), pointer, fixed bin (19), pointer, fixed bin (35));
 26    70 dcl  get_wdir_ entry () returns (char (168));
 26    71 dcl  hcs_$make_seg entry (char (*), char (*), char (*), 
 26    72      fixed bin (5), pointer, fixed bin (35));
 26    73 dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
 26    74 dcl  hcs_$status_mins entry 
 26    75     (pointer, fixed bin (2), fixed bin (24), fixed bin (35));
 26    76 dcl  hcs_$terminate_noname entry (pointer, fixed bin (35));
 26    77 dcl  nothing entry options (variable);
 26    78 
 26    79 dcl  INITIALIZED bit (1) aligned internal static options (constant) init ("0"b);
 26    80 dcl  initialized_bit bit (1) aligned based;
 26    81 
 26    82 /* The following array is important: it defines the "table of contents"
 26    83*   for the structure library segment.  It is declared and initialized to
 26    84*   empty, but when the object segment is copied into the library segment, 
 26    85*   it is filled in with the actual names of all the structures, which were
 26    86*   collected by all the calls to "add", above. */
 26    87 
 26    88 dcl  STRUCTURES (200) char (32) unaligned internal static options (constant) 
 26    89      init ((200)(32)"");
 26    90 
 26    91 /* This is the automatic array where the data is collected, and the based
 26    92*   overlay used later on to copy it into the new segment */
 26    93 
 26    94 dcl  based_structures (n_structures) char (32) unaligned based;
 26    95 dcl  structures (hbound (STRUCTURES, 1)) char (32) unaligned automatic;
 26    96 dcl  n_structures fixed bin init (0);
 26    97 
 26    98 dcl (addr, codeptr, null, rel, size, unspec) builtin;
 26    99 
 26   100 /**/
 26   101 
 26   102 /* Finally, the real code, which copies one segment onto the other and
 26   103*   updates the structures arrays. */
 26   104 
 26   105 	if INITIALIZED then do;
 26   106 	     call com_err_ (0, WHOAMI, "This program is a data segment, and may not be executed.");
 26   107 	     return;
 26   108 	     end;
 26   109 
 26   110 	call get_external_variable_ ("pl1_severity_", severity_ptr, (0), (null ()), code);
 26   111 	if (code ^= 0) then do;
 26   112 	     call com_err_ (code,  WHOAMI, "Cannot determine severity for compilation of ^a.", WHOAMI);
 26   113 	     return;
 26   114 	     end;
 26   115 
 26   116 	if (severity_value = 2) then do;
 26   117 	     call command_query_$yes_no (answer, 0, WHOAMI, 
 26   118 
 26   119 "ERROR 366 means that the program is too large to construct a symbol table;
 26   120 this quite commonly happens to structure libraries because of their enormous
 26   121 symbol tables. You may be able to fix the error by rearranging some of the
 26   122 include files.",
 26   123 
 26   124 "Warning: A severity two PL/I error has occurred. 
 26   125 If it is ERROR 366, the result of this compilation will be partially invalid.
 26   126 Do you wish to continue and generate the library segment anyway?");
 26   127 
 26   128 	     if ^answer then return;
 26   129 	     end;
 26   130 
 26   131 	old_segp = pointer (addr (STRUCTURES), 0);
 26   132 
 26   133 	call hcs_$status_mins (old_segp, (0), bitcount, code);
 26   134 	if (code ^= 0) then do;
 26   135 	     call com_err_ (code, WHOAMI, 
 26   136 		"Cannot get bitcount of original segment.");
 26   137 	     return;
 26   138 	     end;
 26   139 
 26   140 	call hcs_$make_seg ((get_wdir_ ()), WHOAMI, "", 01010b, new_segp, code);
 26   141 	if (new_segp = null ()) then do;
 26   142 	     call com_err_ (code, WHOAMI, "Cannot create [wd]>^a", WHOAMI);
 26   143 	     return;
 26   144 	     end;
 26   145 
 26   146 	n_words = divide (bitcount, 36, 18, 0);
 26   147 	new_segp -> based_words = old_segp -> based_words;
 26   148 
 26   149 	call hcs_$set_bc_seg (new_segp, bitcount, code);
 26   150 	if (code ^= 0) then do;
 26   151 	     call com_err_ (code, WHOAMI,
 26   152 		"Cannot set bitcount on [wd]>^a", WHOAMI);
 26   153 	     return;
 26   154 	     end;
 26   155 
 26   156 /* Finally, copy in the structure list */
 26   157 
 26   158 	pointer (new_segp, rel (addr (STRUCTURES))) -> based_structures
 26   159 	     = addr (structures) -> based_structures;
 26   160 	pointer (new_segp, rel (addr (INITIALIZED))) -> initialized_bit = "1"b;
 26   161 
 26   162 	call hcs_$terminate_noname (new_segp, (0));
 26   163 
 26   164 ERROR_RETURN:
 26   165 	return;
 26   166 
 26   167 /*  */
 26   168 
 26   169 /* This is called once for each structure which goes in the table of contents.
 26   170*   It adds the structure to the automatic array, and increments the count. */
 26   171 
 26   172 add:
 26   173 addx:
 26   174      procedure (name, useless_pointer);
 26   175 
 26   176 dcl  name char (32);
 26   177 dcl  useless_pointer pointer;
 26   178 
 26   179 /* The bounds check is against hbound - 1, since it is necessary to always
 26   180*   leave at least one blank entry in the table of contents to show where
 26   181*   the last valid entry is. */
 26   182 
 26   183 
 26   184 	if (n_structures >= (hbound (STRUCTURES, 1) - 1)) then do;
 26   185 	     call com_err_ (0, WHOAMI, 
 26   186 		"Too many structures defined. Max is ^d.^/^3xChange the dimension of the STRUCTURES array and recompile.",
 26   187 		hbound (STRUCTURES, 1));
 26   188 	     goto ERROR_RETURN;
 26   189 	     end;
 26   190 
 26   191 	n_structures = n_structures + 1;
 26   192 	structures (n_structures) = name;
 26   193 	structures (n_structures + 1) = "";
 26   194 	return;
 26   195 	end add;
      137 
      138 
      139 	end structure_library_2_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/25/89  1000.0  !BBBJZhFzfZCnGN.pl1               >special_ldd>install>MR12.3-1100>structure_library_2_.cds
35           1    11/29/83  0931.2  dir_lock_seg_.incl.pl1            >ldd>include>dir_lock_seg_.incl.pl1
36           2    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
43           3    07/24/86  2051.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
50           4    10/25/89  0959.9  dn355_data.incl.pl1               >special_ldd>install>MR12.3-1100>dn355_data.incl.pl1
53           5    10/20/82  0938.5  dn355_mailbox.incl.pl1            >ldd>include>dn355_mailbox.incl.pl1
59           6    08/11/88  2011.5  dskdcl.incl.pl1                   >ldd>include>dskdcl.incl.pl1
67           7    11/07/86  1550.3  ect_structures.incl.pl1           >ldd>include>ect_structures.incl.pl1
77           8    11/07/86  1550.3  event_channel_name.incl.pl1       >ldd>include>event_channel_name.incl.pl1
79           9    06/29/79  1728.0  event_call_info.incl.pl1          >ldd>include>event_call_info.incl.pl1
81          10    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
84          11    06/22/81  1815.3  fault_vector.incl.pl1             >ldd>include>fault_vector.incl.pl1
87          12    04/30/87  1513.7  flagbox.incl.pl1                  >ldd>include>flagbox.incl.pl1
89          13    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
93          14    01/06/85  1422.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
97          15    01/06/85  1422.5  io_page_tables.incl.pl1           >ldd>include>io_page_tables.incl.pl1
15-35       16    05/13/82  1421.2  io_ptw.incl.pl1                   >ldd>include>io_ptw.incl.pl1
106         17    03/10/88  2009.5  io_special_status.incl.pl1        >ldd>include>io_special_status.incl.pl1
108         18    05/06/74  1742.1  io_status.incl.pl1                >ldd>include>io_status.incl.pl1
111         19    10/26/83  1107.8  io_status_entry.incl.pl1          >ldd>include>io_status_entry.incl.pl1
19-30       20    03/27/82  0430.3  io_status_word.incl.pl1           >ldd>include>io_status_word.incl.pl1
114         21    01/18/85  0953.2  io_syserr_msg.incl.pl1            >ldd>include>io_syserr_msg.incl.pl1
115         22    06/03/83  1008.5  iocbx.incl.pl1                    >ldd>include>iocbx.incl.pl1
117         23    09/02/86  1552.9  ioi_data.incl.pl1                 >ldd>include>ioi_data.incl.pl1
23-61       24    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
123         25    04/11/85  1452.4  iom_data.incl.pl1                 >ldd>include>iom_data.incl.pl1
137         26    09/12/84  2307.0  structure_library_code.incl.pl1   >ldd>include>structure_library_code.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
INITIALIZED                     000041 constant        bit(1)                   initial dcl 26-79 set ref 26-105 26-160
IOI_DEFAULT_MAX_TIMEOUT         000000 constant        fixed bin(35,0)          initial dcl 23-199
STRUCTURES                      006170 constant        char(32)                 initial array packed unaligned dcl 26-88 set ref
                                                                                  26-95 26-131 26-158 26-184 26-185 26-185
WHOAMI                          000001 constant        char(32)                 initial packed unaligned dcl 135 set ref 26-106*
                                                                                  26-112* 26-112* 26-117* 26-135* 26-140* 26-142*
                                                                                  26-142* 26-151* 26-151* 26-185*
addr                                                   builtin function         dcl 26-98 ref 45 45 47 47 49 49 51 51 52 52 54 54 56
                                                                                  56 57 57 58 58 60 60 61 61 62 62 63 63 64 64 65 65
                                                                                  68 68 70 70 71 71 72 72 73 73 74 74 75 75 76 76 78
                                                                                  78 80 80 82 82 86 86 88 88 91 91 94 94 107 107 110
                                                                                  110 112 112 113 113 114 114 115 115 124 124 126
                                                                                  126 128 128 129 129 130 130 131 131 26-131 26-158
                                                                                  26-158 26-160 37 37 38 38 39 39 41 41 100 100 101
                                                                                  101 102 102 103 103 118 118 119 119 120 120 121
                                                                                  121
answer                          000214 automatic       bit(1)                   dcl 26-58 set ref 26-117* 26-128
based_structures                       based           char(32)                 array packed unaligned dcl 26-94 set ref 26-158*
                                                                                  26-158
based_words                            based           bit(36)                  array dcl 26-63 set ref 26-147* 26-147
bitcount                        000222 automatic       fixed bin(24,0)          dcl 26-61 set ref 26-133* 26-146 26-149*
call_channel                           based           structure                level 1 dcl 7-112 set ref 72 72
channel_mailbox                        based           structure                level 1 dcl 25-98 set ref 131 131
chantab                                based           structure                level 1 dcl 6-132 set ref 64 64
code                            000210 automatic       fixed bin(35,0)          dcl 26-55 set ref 26-110* 26-111 26-112* 26-133*
                                                                                  26-134 26-135* 26-140* 26-142* 26-149* 26-150
                                                                                  26-151*
com_err_                        000036 constant        entry                    external dcl 26-67 ref 26-106 26-112 26-135 26-142
                                                                                  26-151 26-185
command_query_$yes_no           000040 constant        entry                    external dcl 26-68 ref 26-117
cp                              000132 automatic       pointer                  dcl 6-97 ref 6-132 6-132 6-132 6-132 6-132 6-132
                                                                                  6-132 6-132 6-132 6-132 6-132 6-132 6-132 6-132
                                                                                  6-132 6-132 6-132 6-132 6-132 6-132 6-132 6-132
                                                                                  6-132 6-132 6-132 6-132 6-132 6-132 6-132 6-132
                                                                                  6-132 6-132 6-132 6-132 6-132 6-132 6-132 6-132
                                                                                  6-132
cte                                    based           structure                level 1 dcl 23-96 set ref 120 120
ctep                            000264 automatic       pointer                  dcl 23-31 ref 23-96 23-96 23-96 23-96 23-96 23-96
                                                                                  23-96 23-96 23-96 23-96 23-96 23-96 23-96 23-96
                                                                                  23-96 23-96 23-96 23-96 23-96 23-96 23-96 23-96
                                                                                  23-96 23-96 23-96 23-96 23-96 23-96 23-96 23-96
                                                                                  23-96
datanet_info                           based           structure                level 1 dcl 4-52 set ref 51 51
datanet_mbx                            based           structure                level 1 dcl 5-12 set ref 54 54
devtab                                 based           structure                level 1 dcl 6-190 set ref 65 65
dir_lock                               based           structure                level 1 dcl 1-46 set ref 39 39
dir_lock_seg                           based           structure                level 1 dcl 1-16 set ref 37 37
dir_lock_seg_header                    based           structure                level 1 dcl 1-30 set ref 38 38
dir_lock_segp                   000234 automatic       pointer                  dcl 1-14 ref 1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16
                                                                                  1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16
                                                                                  1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16 1-16
                                                                                  1-16
dir_lockp                       000242 automatic       pointer                  dcl 1-45 ref 1-46 1-46 1-46 1-46 1-46 1-46 1-46 1-46
disk_channel_table                     based           structure                array level 1 dcl 6-94 set ref 62 62
disk_data                              based           structure                level 1 dcl 6-31 set ref 60 60
disk_label                             based           structure                level 1 dcl 90 set ref 91 91
disk_lock_meters                       based           structure                level 1 dcl 6-236
disk_table                             based           structure                level 1 dcl 44 set ref 45 45
disk_table_entry                       based           structure                level 1 dcl 46 set ref 47 47
disk_table_lv_entry                    based           structure                level 1 dcl 48 set ref 49 49
diskp                           000122 automatic       pointer                  dcl 6-26 ref 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74
disksp                          000120 automatic       pointer                  dcl 6-26 ref 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31
                                                                                  6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31
                                                                                  6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31
                                                                                  6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31
                                                                                  6-31 6-31 6-31 6-31 6-31 6-31
disktab                                based           structure                level 1 dcl 6-74 set ref 61 61
dp                              000134 automatic       pointer                  dcl 6-187 ref 6-190 6-190 6-190 6-190 6-190 6-190
                                                                                  6-190 6-190 6-190 6-190 6-190 6-190 6-190 6-190
                                                                                  6-190 6-190 6-190 6-190 6-190 6-190 6-190 6-190
                                                                                  6-190 6-190 6-190 6-190 6-190 6-190 6-190 6-190
                                                                                  6-190
dt                                     based           structure                level 1 dcl 3-23
dte                                    based           structure                level 1 dcl 3-35 in procedure "structure_library_2_"
dte                                    based           structure                level 1 dcl 23-128 in begin block on line 116 set
                                                                                  ref 121 121
dtep                            000104 automatic       pointer                  dcl 3-17 in procedure "structure_library_2_" ref
                                                                                  3-35 3-35 3-35 3-35 3-35 3-35 3-35 3-35 3-35 3-35
                                                                                  3-35 3-35 3-35 3-35 3-35 3-35 3-35 3-35 3-35 3-35
                                                                                  3-35 3-35
dtep                            000266 automatic       pointer                  dcl 23-32 in begin block on line 116 ref 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128 23-128 23-128 23-128 23-128 23-128 23-128
                                                                                  23-128
dtp                             000102 automatic       pointer                  dcl 3-17 ref 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
ecit                                   based           structure                level 1 dcl 7-77 set ref 70 70
ecit_lth                        000144 automatic       fixed bin(17,0)          dcl 7-81 set ref 69* 7-77
ecit_ptr                        000142 automatic       pointer                  dcl 7-80 ref 7-77 7-77
ect_header                             based           structure                level 1 dcl 7-24 set ref 68 68
ect_ptr                         000140 automatic       pointer                  dcl 7-61 ref 7-24 7-24 7-24 7-24 7-24 7-24 7-24 7-24
                                                                                  7-24 7-24 7-24 7-24 7-24 7-24 7-24 7-24 7-24 7-24
                                                                                  7-24 7-24 7-24 7-24 7-24
ectep                           000146 automatic       pointer                  dcl 7-138 ref 7-86 7-86 7-86 7-86 7-86 7-86 7-86
                                                                                  7-86 7-86 7-86 7-86 7-86 7-86 7-86 7-86 7-86 7-86
                                                                                  7-86 7-86 7-86 7-86 7-112 7-112 7-112 7-112 7-112
                                                                                  7-112 7-112 7-112 7-112 7-112 7-112 7-112 7-112
                                                                                  7-112 7-112 7-112 7-112 7-112 7-112 7-112 7-112
                                                                                  7-112
event_call_info                        based           structure                level 1 dcl 9-7 set ref 80 80
event_call_info_ptr             000152 automatic       pointer                  dcl 9-5 ref 9-7 9-7 9-7 9-7 9-7 9-7 9-7 9-7
event_channel_name                     based           structure                level 1 dcl 8-17 set ref 78 78
event_message                          based           structure                level 1 dcl 7-143 set ref 73 73
event_message_data                     based           structure                level 1 dcl 7-169 set ref 75 75
event_wait_info                        based           structure                level 1 dcl 10-7 set ref 82 82
event_wait_info_ptr             000154 automatic       pointer                  dcl 10-5 ref 10-7 10-7 10-7 10-7 10-7 10-7 10-7 10-7
fast_lock                              based           structure                level 1 dcl 40 set ref 41 41
fault_vector                           based           structure                level 1 dcl 85 set ref 86 86
fgbx                                   based           structure                level 1 dcl 12-24 set ref 88 88
fgbxp                           000160 automatic       pointer                  dcl 12-22 ref 12-24 12-24 12-24 12-24 12-24 12-24
                                                                                  12-24 12-24 12-24 12-24 12-24 12-24 12-24 12-24
                                                                                  12-24 12-24 12-24 12-24 12-24 12-24 12-24
fnp_info                               based           structure                level 1 dcl 4-67 set ref 52 52
fnp_sub_mbx                            based           structure                level 1 dcl 5-63 set ref 57 57
fnpp                            000112 automatic       pointer                  dcl 4-50 ref 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
                                                                                  4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
                                                                                  4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
                                                                                  4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
                                                                                  4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
                                                                                  4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
                                                                                  4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67 4-67
free_q_size              10            based           fixed bin(17,0)          level 2 dcl 6-31 set ref 6-31 6-31 6-31 6-31 6-31
                                                                                  6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31 6-31
                                                                                  6-31 6-31
fv                                     based           structure                level 1 dcl 11-6
fvp                             000156 automatic       pointer                  dcl 11-4 ref 11-6 11-6 11-6 11-6 11-6 11-6 11-6 11-6
                                                                                  11-6 11-6 11-6
get_external_variable_          000042 constant        entry                    external dcl 26-69 ref 26-110
get_wdir_                       000044 constant        entry                    external dcl 26-70 ref 26-140
gte                                    based           structure                level 1 dcl 23-74 set ref 119 119
gtep                            000262 automatic       pointer                  dcl 23-30 ref 23-74 23-74 23-74 23-74 23-74 23-74
                                                                                  23-74 23-74 23-74 23-74 23-74 23-74 23-74 23-74
                                                                                  23-74 23-74 23-74 23-74 23-74
hc_fast_lock                           based           structure                level 1 dcl 14-10 set ref 94 94
hcs_$make_seg                   000046 constant        entry                    external dcl 26-71 ref 26-140
hcs_$set_bc_seg                 000050 constant        entry                    external dcl 26-73 ref 26-149
hcs_$status_mins                000052 constant        entry                    external dcl 26-74 ref 26-133
hcs_$terminate_noname           000054 constant        entry                    external dcl 26-76 ref 26-162
header                                 based           structure                level 2 dcl 1-16
idp                             000260 automatic       pointer                  dcl 23-29 ref 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40
infop                           000110 automatic       pointer                  dcl 4-49 ref 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52 4-52
                                                                                  4-52 4-52 4-52
initialized_bit                        based           bit(1)                   dcl 26-80 set ref 26-160*
input_sub_mbx                          based           structure                level 1 dcl 5-84 set ref 58 58
io_msg                                 based           structure                level 1 dcl 21-14 set ref 114 114
io_msgp                         000176 automatic       pointer                  dcl 21-12 ref 21-14 21-14 21-14 21-14 21-14 21-14
                                                                                  21-14 21-14 21-14 21-14 21-14 21-14 21-14
io_page_table_256                      based           structure                array level 1 dcl 98 set ref 101 101
io_page_table_64                       based           structure                array level 1 dcl 99 set ref 102 102
io_page_table_seg_ptr           000250 automatic       pointer                  dcl 15-10 ref 15-12 15-12 15-12 15-12 15-12 15-12
                                                                                  15-12 15-12 15-12 15-12 15-12 15-12 15-12 15-12
                                                                                  15-12 15-12
io_page_tables                         based           structure                level 1 dcl 15-12 set ref 100 100
io_ptw                                 based           structure                level 1 dcl 16-4 set ref 103 103
io_ptwp                         000256 automatic       pointer                  dcl 16-3 ref 16-4 16-4 16-4 16-4 16-4 16-4 16-4 16-4
io_special_status                      based           structure                level 1 dcl 17-14 set ref 107 107
io_special_status_ptr           000166 automatic       pointer                  dcl 17-12 ref 17-14 17-14 17-14 17-14 17-14 17-14
                                                                                  17-14 17-14 17-14 17-14
io_status                              based           structure                level 1 dcl 109 set ref 110 110
io_status_entry                        based           structure                level 1 dcl 19-7 set ref 112 112
io_status_entry_ptr             000172 automatic       pointer                  dcl 19-6 ref 19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7
                                                                                  19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7
                                                                                  19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7 19-7
                                                                                  19-7 19-7 19-7 19-7
io_status_word                         based           structure                level 1 dcl 20-5 set ref 113 113
io_status_word_ptr              000174 automatic       pointer                  dcl 20-4 ref 20-5 20-5 20-5 20-5 20-5 20-5 20-5 20-5
                                                                                  20-5 20-5 20-5 20-5 20-5 20-5
iocb                                   based           structure                level 1 dcl 22-9 set ref 115 115
ioi_data                               based           structure                level 1 dcl 23-40 set ref 118 118
iom_data                               based           structure                level 1 dcl 25-17 set ref 124 124
iom_data_ptr                    000202 automatic       pointer                  dcl 25-15 ref 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17
iom_mailbox                            based           structure                level 1 dcl 25-95 set ref 130 130
iom_mailbox_seg                        based           structure                level 1 dcl 25-83 set ref 129 129
iom_mailbox_seg_ptr             000204 automatic       pointer                  dcl 25-82 ref 25-83 25-83 25-83 25-83 25-83 25-83
                                                                                  25-83 25-83 25-83 25-83 25-83
iom_per_device                         based           structure                level 1 dcl 125 set ref 126 126
iom_per_iom                            based           structure                level 1 dcl 127 set ref 128 128
ite                                    based           structure                level 1 dcl 23-63
itep                            000270 automatic       pointer                  dcl 23-33 ref 23-63 23-63 23-63 23-63 23-63 23-63
                                                                                  23-63 23-63 23-63
itt_message                            based           structure                level 1 dcl 7-158 set ref 74 74
label                                  based           structure                level 1 dcl 13-18
labelp                          000162 automatic       pointer                  dcl 13-16 ref 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
                                                                                  13-18 13-18 13-18 13-18 13-18 13-18 13-18 13-18
last_dev                  2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-74 set ref
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74 6-74
                                                                                  6-74
line_number               0(08)        based           structure                level 2 in structure "short_fnp_sub_mbx" packed
                                                                                  packed unaligned dcl 55 in procedure
                                                                                  "structure_library_2_"
line_number               0(08)        based           structure                level 2 in structure "sub_mbx" packed packed
                                                                                  unaligned dcl 5-36 in procedure
                                                                                  "structure_library_2_"
lock                                   based           structure                level 1 dcl 2-12 in begin block on line 34
lock                                   based           structure                level 1 dcl 24-12 in begin block on line 116
lock_ptr                        000164 automatic       pointer                  dcl 14-9 in procedure "structure_library_2_" ref
                                                                                  14-10 14-10 14-10 14-10 14-10 14-10
lock_ptr                        000246 automatic       pointer                  dcl 2-11 in begin block on line 34 ref 2-12 2-12
                                                                                  2-12 2-12 2-12 2-12
lock_ptr                        000276 automatic       pointer                  dcl 24-11 in begin block on line 116 ref 24-12 24-12
                                                                                  24-12 24-12 24-12 24-12
lve                                    based           structure                level 1 dcl 3-58
lvep                            000106 automatic       pointer                  dcl 3-17 ref 3-58 3-58 3-58 3-58 3-58 3-58 3-58 3-58
                                                                                  3-58 3-58 3-58 3-58 3-58 3-58 3-58 3-58
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 3-23 ref 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23
                                                                                  3-23 3-23 3-23 3-23 3-23 3-23 3-23 3-23 44 44 44
                                                                                  44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44
                                                                                  44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44
                                                                                  44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44
max_no_355s                     011270 constant        fixed bin(17,0)          initial dcl 4-45 ref 4-52
max_readers               5            based           fixed bin(17,0)          level 3 dcl 1-16 set ref 1-16 1-16
mbxp                            000116 automatic       pointer                  dcl 5-100 ref 5-12 5-12 5-12 5-12 5-12 5-12 5-12
                                                                                  5-12 5-12 5-12 5-12 5-12 5-12 5-12 5-12 5-12 5-12
                                                                                  5-12 5-12 5-12 5-12 5-12 5-12
n_devices                              based           fixed bin(17,0)          level 2 dcl 25-17 set ref 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17 25-17 25-17 25-17 25-17 25-17 25-17 25-17
                                                                                  25-17
n_dir_locks               3            based           fixed bin(17,0)          level 3 dcl 1-16 set ref 1-16 1-16 1-16 1-16 1-16
                                                                                  1-16 1-16 1-16 1-16 1-16
n_structures                    000226 automatic       fixed bin(17,0)          initial dcl 26-96 set ref 26-94 26-96* 26-158 26-158
                                                                                  26-158 26-184 26-191* 26-191 26-192 26-193
n_words                         000223 automatic       fixed bin(18,0)          dcl 26-62 set ref 26-63 26-146* 26-147
name                                   parameter       char(32)                 packed unaligned dcl 26-176 ref 26-172 26-172 26-192
nchan                     1            based           fixed bin(17,0)          level 2 dcl 6-74 set ref 6-94 6-94 6-94 6-94 6-94
                                                                                  6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94
                                                                                  6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94
                                                                                  6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94 6-94
                                                                                  6-94 6-94 6-94 6-94
nct                       1            based           fixed bin(17,0)          level 2 dcl 23-40 set ref 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40
ndt                       2            based           fixed bin(17,0)          level 2 dcl 23-40 set ref 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
new_segp                        000216 automatic       pointer                  dcl 26-59 set ref 26-140* 26-141 26-147 26-149*
                                                                                  26-158 26-160 26-162*
ngt                                    based           fixed bin(17,0)          level 2 dcl 23-40 set ref 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40 23-40 23-40
nit                       3            based           fixed bin(17,0)          level 2 dcl 23-40 set ref 23-40 23-40 23-40 23-40
                                                                                  23-40 23-40 23-40 23-40 23-40
null                                                   builtin function         dcl 26-98 ref 26-65 26-110 26-141
old_segp                        000220 automatic       pointer                  dcl 26-60 set ref 26-131* 26-133* 26-147
opt_info                               based           structure                level 1 dcl 6-217
optp                            000124 automatic       pointer                  dcl 6-26 ref 6-217 6-217 6-217 6-217 6-217 6-217
                                                                                  6-217 6-217 6-217 6-217
p                               000224 automatic       pointer                  initial dcl 26-65 set ref 45 45 47 47 49 49 51 51 52
                                                                                  52 54 54 56 56 57 57 58 58 60 60 61 61 62 62 63 63
                                                                                  64 64 65 65 68 68 70 70 71 71 72 72 73 73 74 74 75
                                                                                  75 76 76 78 78 80 80 82 82 86 86 88 88 91 91 94 94
                                                                                  107 107 110 110 112 112 113 113 114 114 115 115
                                                                                  124 124 126 126 128 128 129 129 130 130 131 131
                                                                                  26-65* 37 37 38 38 39 39 41 41 100 100 101 101 102
                                                                                  102 103 103 118 118 119 119 120 120 121 121
per_device                             based           structure                level 1 dcl 25-59
per_iom                                based           structure                level 1 dcl 25-40
qht                                    based           structure                level 1 dcl 6-179
qp                              000130 automatic       pointer                  dcl 6-97 ref 6-107 6-107 6-107 6-107 6-107 6-107
                                                                                  6-107 6-107 6-107 6-107 6-107 6-107 6-107 6-107
                                                                                  6-107 6-107 6-107
quentry                                based           structure                level 1 dcl 6-107 set ref 63 63
rel                                                    builtin function         dcl 26-98 ref 26-158 26-160
severity_ptr                    000212 automatic       pointer                  dcl 26-56 set ref 26-57 26-110* 26-116
severity_value                         based           fixed bin(35,0)          dcl 26-57 ref 26-116
short_fnp_sub_mbx                      based           structure                level 1 dcl 55 set ref 56 56
status                          000170 automatic       structure                level 1 unaligned dcl 18-2
status_queue                           based           structure                level 1 dcl 25-92
status_queue_ptr                000206 automatic       pointer                  dcl 25-91 ref 25-92 25-92
structures                      000226 automatic       char(32)                 array packed unaligned dcl 26-95 set ref 26-158
                                                                                  26-192* 26-193*
sub_mbx                                based           structure                level 1 dcl 5-36
subp                            000114 automatic       pointer                  dcl 5-99 ref 5-36 5-36 5-36 5-36 5-36 5-36 5-36 5-36
                                                                                  5-36 5-36 5-36 5-36 5-36 5-36 5-36 5-36 5-36 5-63
                                                                                  5-63 5-63 5-63 5-63 5-63 5-63 5-63 5-63 5-63 5-63
                                                                                  5-63 5-63 5-63 5-84 5-84 5-84 5-84 5-84 5-84 5-84
                                                                                  5-84 5-84 5-84 5-84 5-84 5-84 5-84 5-84
sys_info                               based           structure                level 1 dcl 6-59
sysp                            000126 automatic       pointer                  dcl 6-26 ref 6-59 6-59 6-59 6-59 6-59 6-59
useless_pointer                        parameter       pointer                  dcl 26-177 ref 26-172 26-172
wait_channel                           based           structure                level 1 dcl 7-86 set ref 71 71
waiting_control_point                  based           structure                level 1 dcl 7-182 set ref 76 76
wcpp                            000150 automatic       pointer                  dcl 7-194 ref 7-182 7-182 7-182 7-182 7-182 7-182
                                                                                  7-182 7-182 7-182

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BOOTLOAD_READ                          constant        fixed bin(4,0)           initial dcl 6-251
BOOTLOAD_WRITE                         constant        fixed bin(4,0)           initial dcl 6-251
CALL                                   constant        fixed bin(8,0)           initial dcl 7-65
DIR_LOCK_SEG_EVENT                     constant        char(4)                  initial dcl 1-28
DSC_LISTX                              constant        fixed bin(12,0)          initial dcl 6-241
ENCODED_INDEX_CONSTANT                 constant        fixed bin(35,0)          initial dcl 8-37
EV_CALL_MESSAGE                        constant        fixed bin(8,0)           initial dcl 7-66
EV_WAIT_MESSAGE                        constant        fixed bin(8,0)           initial dcl 7-68
FAST_CHANNEL_TYPE                      constant        bit(1)                   initial dcl 8-25
FAULT_NO_ACV                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_CMD                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_CON                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_DF0                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_DF1                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_DF2                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_DF3                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_DIV                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_DRL                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_EXF                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_F1                            constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_F2                            constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_F3                            constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_IPR                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_LUF                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_MME                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_MME2                          constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_MME3                          constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_MME4                          constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_OFL                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_ONC                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_PAR                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_SDF                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_STR                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_SUF                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_TRB                           constant        fixed bin(17,0)          initial dcl 11-20
FAULT_NO_TRO                           constant        fixed bin(17,0)          initial dcl 11-20
FIRST_BOOTLOAD_PAGEX                   constant        fixed bin(17,0)          initial dcl 4-166
FIRST_TTY_BUF_PAGEX                    constant        fixed bin(17,0)          initial dcl 4-167
FLAGBOX_SENTINEL                       constant        char(32)                 initial packed unaligned dcl 12-51
IOI_DEFAULT_MAX_BOUND                  constant        fixed bin(19,0)          initial dcl 23-198
IOI_DEFAULT_TIMEOUT                    constant        fixed bin(35,0)          initial dcl 23-201
IOI_DEVICE_LOCK_EVENT_TEMPLATE         constant        char(2)                  initial packed unaligned dcl 23-207
IO_CHANNEL_LOCK_TEMPLATE               constant        char(2)                  initial packed unaligned dcl 23-205
IO_PAGE_TABLE_LOCK_EVENT               constant        char(4)                  initial packed unaligned dcl 15-37
IO_STATUS_ERROR_MASK                   constant        bit(36)                  initial packed unaligned dcl 23-203
IO_TYPE                                constant        char(16)                 initial array packed unaligned dcl 6-262
ITT_MESSAGE                            constant        fixed bin(8,0)           initial dcl 7-67
MAX_IO_PAGE_TABLE_SEG_PAGES            constant        fixed bin(9,0)           initial dcl 15-39
MAX_IO_TYPE                            constant        fixed bin(4,0)           initial dcl 6-251
Multics_ID_String               000010 internal static char(32)                 initial packed unaligned dcl 13-92
NORMAL_CHANNEL_FLAGS                   constant        bit(3)                   initial dcl 8-28
PAGE_READ                              constant        fixed bin(4,0)           initial dcl 6-251
PAGE_WRITE                             constant        fixed bin(4,0)           initial dcl 6-251
PTS_PER_PAGE                           constant        fixed bin(17,0)          initial dcl 15-43
PT_256_SIZE                            constant        bit(1)                   initial packed unaligned dcl 15-42
PT_64_SIZE                             constant        bit(1)                   initial packed unaligned dcl 15-41
REGULAR_CHANNEL_TYPE                   constant        bit(1)                   initial dcl 8-26
RSS_LISTX                              constant        fixed bin(12,0)          initial dcl 6-241
RST_LISTX                              constant        fixed bin(12,0)          initial dcl 6-241
SC_LISTX                               constant        fixed bin(12,0)          initial dcl 6-241
SEND_IPS_WKP_CHANNEL_FLAGS             constant        bit(3)                   initial dcl 8-29
SMALL_PT_SIZE                          constant        fixed bin(19,0)          initial dcl 15-44
TEST                                   constant        fixed bin(4,0)           initial dcl 6-251
TOTAL                                  constant        fixed bin(8,0)           initial dcl 7-63
VTOC_READ                              constant        fixed bin(4,0)           initial dcl 6-251
VTOC_WRITE                             constant        fixed bin(4,0)           initial dcl 6-251
WAIT                                   constant        fixed bin(8,0)           initial dcl 7-64
WAITING_CP                             constant        fixed bin(8,0)           initial dcl 7-69
bootload_map                           defined         bit(1)                   array packed unaligned dcl 6-279
bootload_mapping                       constant        bit(7)                   initial packed unaligned dcl 6-278
codeptr                                                builtin function         dcl 26-98
connect_channel                        constant        fixed bin(6,0)           initial dcl 25-105
decoded_index                          based           structure                level 1 dcl 8-33
dir_lock_all_dir_locks                 based           structure                array level 1 dcl 1-24
dir_lock_all_locksp             000236 automatic       pointer                  dcl 1-21
dir_lock_all_readers                   based           bit(36)                  array dcl 1-25
dir_lock_all_readersp           000240 automatic       pointer                  dcl 1-21
dir_lock_seg$                   000056 external static fixed bin(17,0)          dcl 1-12
dir_read_lockers                       based           bit(36)                  array dcl 1-58
dir_read_lockers_ptr            000244 automatic       pointer                  dcl 1-57
disk_seg$                       000024 external static fixed bin(17,0)          dcl 6-24
dn355_data$                     000022 external static fixed bin(17,0)          dcl 4-47
dskdcl_chans_per_subsys                constant        fixed bin(17,0)          initial dcl 6-70
dskdcl_chans_per_subsys_shift          constant        fixed bin(17,0)          initial dcl 6-71
flagbox$                        000026 external static fixed bin(17,0)          dcl 12-21
io_page_table_seg$              000060 external static fixed bin(17,0)          dcl 15-8
io_page_table_size              000254 automatic       fixed bin(17,0)          dcl 15-30
ioi_channels                    000274 automatic       fixed bin(17,0)          dcl 23-35
ioi_data$                       000062 external static fixed bin(17,0)          dcl 23-37
ioi_devices                     000273 automatic       fixed bin(17,0)          dcl 23-35
ioi_multiplexers                000275 automatic       fixed bin(17,0)          dcl 23-35
ioi_subsystems                  000272 automatic       fixed bin(17,0)          dcl 23-35
iom_data$                       000032 external static fixed bin(17,0)          dcl 25-11
iom_mailbox$                    000034 external static fixed bin(17,0)          dcl 25-12
ioptp                           000252 automatic       pointer                  dcl 15-29
iox_$iocb_version_sentinel      000030 external static char(4)                  dcl 22-64
n_devices                       000200 automatic       fixed bin(17,0)          dcl 25-14
nothing                         000000 constant        entry                    external dcl 26-77
page_table                             based           structure                array level 1 dcl 15-32
pvtdi                                  based           structure                level 1 dcl 6-229
pvtdip                          000136 automatic       pointer                  dcl 6-187
sector_map                             defined         bit(1)                   array packed unaligned dcl 6-274
sector_mapping                         constant        bit(7)                   initial packed unaligned dcl 6-273
size                                                   builtin function         dcl 26-98
sp                              000100 automatic       pointer                  dcl 32
special_status_channel                 constant        fixed bin(6,0)           initial dcl 25-105
status_bits                            based           bit(72)                  dcl 18-2
system_fault_channel                   constant        fixed bin(6,0)           initial dcl 25-105
unspec                                                 builtin function         dcl 26-98
write_map                              defined         bit(1)                   array packed unaligned dcl 6-269
write_mapping                          constant        bit(7)                   initial packed unaligned dcl 6-268

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    006052 constant        label                    dcl 26-164 ref 26-188
add                             006056 constant        entry                    internal dcl 26-172 ref 37 38 39 41 45 47 49 51 52
                                                                                  54 56 57 58 60 61 62 63 64 65 68 70 71 72 73 74 75
                                                                                  76 78 80 82 86 88 91 94 100 101 102 103 107 110
                                                                                  112 113 114 115 124 126 128 129 130 131
addx                            006053 constant        entry                    internal dcl 26-172 ref 118 119 120 121
structure_library_2_            004543 constant        entry                    external dcl 27

NAMES DECLARED BY CONTEXT OR IMPLICATION.
divide                                                 builtin function         ref 26-146
hbound                                                 builtin function         ref 26-95 26-184 26-185 26-185
pointer                                                builtin function         ref 26-131 26-158 26-160

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11516       11602   11271       11526
Length     51020   11271        64       37201     225          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
structure_library_2_                450 external procedure  is an external procedure.  
begin block on line 34                  begin block         shares stack frame of external procedure structure_library_2_.  
begin block on line 96                  begin block         shares stack frame of external procedure structure_library_2_.  
begin block on line 116                 begin block         shares stack frame of external procedure structure_library_2_.  
addx                                    internal procedure  shares stack frame of external procedure structure_library_2_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 Multics_ID_String           structure_library_2_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
structure_library_2_     000100 sp                          structure_library_2_
                         000102 dtp                         structure_library_2_
                         000104 dtep                        structure_library_2_
                         000106 lvep                        structure_library_2_
                         000110 infop                       structure_library_2_
                         000112 fnpp                        structure_library_2_
                         000114 subp                        structure_library_2_
                         000116 mbxp                        structure_library_2_
                         000120 disksp                      structure_library_2_
                         000122 diskp                       structure_library_2_
                         000124 optp                        structure_library_2_
                         000126 sysp                        structure_library_2_
                         000130 qp                          structure_library_2_
                         000132 cp                          structure_library_2_
                         000134 dp                          structure_library_2_
                         000136 pvtdip                      structure_library_2_
                         000140 ect_ptr                     structure_library_2_
                         000142 ecit_ptr                    structure_library_2_
                         000144 ecit_lth                    structure_library_2_
                         000146 ectep                       structure_library_2_
                         000150 wcpp                        structure_library_2_
                         000152 event_call_info_ptr         structure_library_2_
                         000154 event_wait_info_ptr         structure_library_2_
                         000156 fvp                         structure_library_2_
                         000160 fgbxp                       structure_library_2_
                         000162 labelp                      structure_library_2_
                         000164 lock_ptr                    structure_library_2_
                         000166 io_special_status_ptr       structure_library_2_
                         000170 status                      structure_library_2_
                         000172 io_status_entry_ptr         structure_library_2_
                         000174 io_status_word_ptr          structure_library_2_
                         000176 io_msgp                     structure_library_2_
                         000200 n_devices                   structure_library_2_
                         000202 iom_data_ptr                structure_library_2_
                         000204 iom_mailbox_seg_ptr         structure_library_2_
                         000206 status_queue_ptr            structure_library_2_
                         000210 code                        structure_library_2_
                         000212 severity_ptr                structure_library_2_
                         000214 answer                      structure_library_2_
                         000216 new_segp                    structure_library_2_
                         000220 old_segp                    structure_library_2_
                         000222 bitcount                    structure_library_2_
                         000223 n_words                     structure_library_2_
                         000224 p                           structure_library_2_
                         000226 structures                  structure_library_2_
                         000226 n_structures                structure_library_2_
                         000234 dir_lock_segp               begin block on line 34
                         000236 dir_lock_all_locksp         begin block on line 34
                         000240 dir_lock_all_readersp       begin block on line 34
                         000242 dir_lockp                   begin block on line 34
                         000244 dir_read_lockers_ptr        begin block on line 34
                         000246 lock_ptr                    begin block on line 34
                         000250 io_page_table_seg_ptr       begin block on line 96
                         000252 ioptp                       begin block on line 96
                         000254 io_page_table_size          begin block on line 96
                         000256 io_ptwp                     begin block on line 96
                         000260 idp                         begin block on line 116
                         000262 gtep                        begin block on line 116
                         000264 ctep                        begin block on line 116
                         000266 dtep                        begin block on line 116
                         000270 itep                        begin block on line 116
                         000272 ioi_subsystems              begin block on line 116
                         000273 ioi_devices                 begin block on line 116
                         000274 ioi_channels                begin block on line 116
                         000275 ioi_multiplexers            begin block on line 116
                         000276 lock_ptr                    begin block on line 116

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_temp          call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_$yes_no         get_external_variable_        get_wdir_
hcs_$make_seg                 hcs_$set_bc_seg               hcs_$status_mins              hcs_$terminate_noname

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 004542   26   65 004550   26   95 004552   26   96 004561        37 004562        38 004571        39 004600
     41 004607        45 004616        47 004625        49 004634        51 004643        52 004652        54 004661
     56 004670        57 004677        58 004706        60 004715        61 004724        62 004733        63 004742
     64 004751        65 004760        68 004767        69 004776        70 004777        71 005006        72 005015
     73 005024        74 005033        75 005042        76 005051        78 005060        80 005067        82 005076
     86 005105        88 005114        91 005123        94 005132       100 005141       101 005150       102 005157
    103 005166       107 005175       110 005204       112 005213       113 005222       114 005231       115 005240
    118 005247       119 005256       120 005265       121 005274       124 005303       126 005312       128 005321
    129 005330       130 005337       131 005346   26  105 005355   26  106 005357   26  107 005404   26  110 005405
26  111 005446   26  112 005450   26  113 005477   26  116 005500   26  117 005503   26  128 005543   26  131 005546
26  133 005551   26  134 005570   26  135 005572   26  137 005616   26  140 005617   26  141 005665   26  142 005671
26  143 005720   26  146 005721   26  147 005724   26  149 005732   26  150 005745   26  151 005747   26  153 005776
26  158 005777   26  160 006027   26  162 006036   26  164 006052   26  172 006053   26  184 006060   26  185 006063
26  188 006116   26  191 006117   26  192 006120   26  193 006130   26  194 006136


Object Segment >special_ldd>install>MR12.3-1100>structure_library_2_
Created on 10/25/89  1022.6 mst Wed
by Hirneisen.SysMaint.a
using Multics PL/I Compiler, Release 32f, of October 9, 1989

        Object    Text    Defs    Link    Symb  Static
Start        0       0   11271   11516   11602   11526
Length   51020   11271     225      64   37201      10


3 Definitions:


segname:    !BBBJZhFzfZCnGN

text|4543       structure_library_2_            Entrypoint
symb|0          symbol_table


18 Links:

link|20     *symbol|0
link|36     com_err_
link|40     command_query_$yes_no
link|56     dir_lock_seg|0
link|24     disk_seg|0
link|22     dn355_data|0
link|26     flagbox|0
link|42     get_external_variable_
link|44     get_wdir_
link|54     hcs_$terminate_noname
link|52     hcs_$status_mins
link|50     hcs_$set_bc_seg
link|46     hcs_$make_seg
link|60     io_page_table_seg|0
link|62     ioi_data|0
link|32     iom_data|0
link|34     iom_mailbox|0
link|30     iox_$iocb_version_sentinel





                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
