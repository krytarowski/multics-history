	COMPILATION LISTING OF SEGMENT lib_fetch_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/25/84  1155.3 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Modified October 26, 1983 by Jim Lippard to fix bug in the call to get_equal_name_ and to properly handle	*/
       12 /*    name duplication									*/
       13 /* Modified June 13, 1984 by Jim Lippard to not sort found names					*/
       14 
       15 
       16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       17 
       18 
       19 lib_fetch_: 	procedure (Plibrary, Pstarname, Pexclude, Srequirements, Scontrol, Parg_struc, Acode)
       20 		options	(rename ((alloc_, smart_alloc_)));
       21 
       22      dcl						/*	Parameter				*/
       23 	Acode			fixed bin(35);	/* an error table code.			*/
       24 
       25      dcl						/*	automatic variables			*/
       26 	Iname			fixed bin,	/* count of names processed so far.		*/
       27 	Lcopy			fixed bin(21),	/* length of target segment (in chars).		*/
       28 	Nentries_fetched		fixed bin,	/* number of library entries successfully fetched.*/
       29 	Parea			ptr,		/* ptr to an MSA.				*/
       30 	Pcopy			ptr,		/* ptr to target segment (ie, copy fetched into).	*/
       31 	Pent			ptr,		/* ptr to library entry being fetched.		*/
       32 	Pmsf_fcb			ptr,		/* ptr to msf_manager_'s control block.		*/
       33 	Ptarget_node		ptr,		/* ptr to node for actual library entry being	*/
       34 						/*   fetched.				*/
       35 	Ptree			ptr,		/* ptr to a tree of status nodes.		*/
       36 	1 S_			structure,	/* switches:				*/
       37 	 (2 link_error_output,			/*     on if link error message already output.	*/
       38 	  2 error,				/*     on if error occurred making target seg.	*/
       39 	  2 fetch_not_done,				/*     on if fetch not yet complete.		*/
       40 	  2 acl_init,				/*     on if ACL structure already initialized.	*/
       41 	  2 msf,					/*     on if entry being fetched is an MSF.	*/
       42 	  2 no_action,				/*     on if user said "no" to nd_handler_	*/
       43 	  2 delete_msf)		bit(1) unal,	/*     on if target MSF needs to be deleted after	*/
       44 						/*       an error occurred.			*/
       45 	1 acl			structure,	/* an ACL addition structure.			*/
       46 	  2 access_name		char(32),
       47 	  2 modes			bit(36),
       48 	  2 zero_pad		bit(36),
       49 	  2 code			fixed bin(35),
       50 	bc			fixed bin(24),	/* bit count of library entry.		*/
       51 	clock			fixed bin(71),	/* a clock value.				*/
       52 	code			fixed bin(35),	/* a status code.				*/
       53 	date			char(16) aligned,	/* a date/time string.			*/
       54 	dir			char(168) varying,	/* dir part of library entry pathname.		*/
       55 	ent			char(32) varying,	/* ent part of library entry pathnamer.	*/
       56 	1 fcb_temp		like fcb,		/* storage for file control block.		*/
       57 	i			fixed bin,	/* a do-group index.			*/
       58 	into_dir			char(168),	/* dir part of into_path.			*/
       59 	into_ent			char(32),		/* ent part of into_path.			*/
       60 	msf_comp			fixed bin(24),	/* number of next msf_comp to be initiated.	*/
       61 	nd_result			fixed bin(35),	/* return code from nd_handler_.		*/
       62 	node_name			char(32),		/* a name on the library entry being fetched.	*/
       63 	progress			fixed bin init (0),	/* integer indicating progress of our search.	*/
       64 						/*   0 = search beginning.			*/
       65 						/*   1 = finding library descriptor.		*/
       66 						/*   2 = seeing if library_fetch command supported*/
       67 						/*       by this descriptor.			*/
       68 						/*   3 = getting default library names if user	*/
       69 						/*       specified none.			*/
       70 						/*   4 = getting default search names if user	*/
       71 						/*       specified none.			*/
       72 						/*   5 = allocating the root nodes of the tree.	*/
       73 						/*   6 = searching each library root for entries	*/
       74 						/*       identified by the search names.	*/
       75 						/*   7 = no entries matching search names found.	*/
       76 	state			char(16),		/* an error temporary char string.		*/
       77 	target_name		char(32),		/* name to be put on target segment.		*/
       78 	unique_name		char(32);		/* unique name by which target segment created.	*/
       79 
       80      dcl						/* 	based variables			*/
       81 	area			area based (Parea),	/* an MSA (multi-segment area).		*/
       82 	copy			char(Lcopy) based (Pcopy);
       83 						/* (all or part of) library entry being fetched.	*/
       84 
       85      dcl (addr, divide, length, min, null, string, substr)
       86 				builtin;
       87      dcl	cleanup			condition;
       88 
       89      dcl						/*	Entries Called			*/
       90 	clock_			entry returns (fixed bin(71)),
       91 	condition_		entry (char(*),  entry),
       92 	date_time_		entry (fixed bin(71), char(*) aligned),
       93 	delete_$path		entry (char(*), char(*), bit(6), char(*), fixed bin(35)),
       94 	expand_path_		entry (ptr, fixed bin, ptr, ptr, fixed bin(35)),
       95 	get_equal_name_		entry (char(*), char(*), char(32), fixed bin(35)),
       96          (get_group_id_,
       97 	get_group_id_$tag_star)	entry returns (char(32) aligned),
       98 	get_system_msa_		entry (ptr, fixed bin, ptr),
       99 	hcs_$add_acl_entries	entry (char(*), char(*), ptr, fixed bin, fixed bin(35)),
      100 	hcs_$chname_file		entry (char(*), char(*), char(*), char(*), fixed bin(35)),
      101 	hcs_$make_seg		entry (char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35)),
      102 	hcs_$set_bc_seg		entry (ptr, fixed bin(24), fixed bin(35)),
      103 	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
      104          (ioa_,
      105 	ioa_$ioa_switch)		entry options (variable),
      106 	iox_$attach_ioname		entry (char(*), ptr, char(*), fixed bin(35)),
      107 	iox_$close		entry (ptr, fixed bin(35)),
      108 	iox_$detach_iocb		entry (ptr, fixed bin(35)),
      109 	iox_$open			entry (ptr, fixed bin, bit(1) aligned, fixed bin(35)),
      110 	lib_array_list_		entry (char(32) varying, ptr, ptr),
      111 	lib_descriptor_$fetch	entry (char(168) varying, ptr, ptr, ptr, bit(72) aligned,  bit(36) aligned,
      112 				       ptr, ptr, fixed bin, fixed bin(35)),
      113 	lib_error_list_		entry (char(32) varying, ptr, char(32) varying),
      114 	lib_next_name_		entry (bit(72) aligned, ptr, fixed bin, ptr) returns (char(32)),
      115 	lib_node_path_		entry (ptr, char(168) varying, char(32) varying),
      116 	lib_output_node_list_$info	entry (ptr, ptr, ptr, ptr, char(45) varying, bit(72) aligned, ptr),
      117 	lib_ptr_and_bc_		entry (ptr, fixed bin(24), ptr, ptr, fixed bin(24), fixed bin(35)),
      118 	lib_sort_tree_$make_name_list
      119 				entry (ptr, ptr, ptr, ptr, fixed bin(35)),
      120 	msa_manager_$area_handler	entry,
      121 	msf_manager_$open		entry (char(*), char(*), ptr, fixed bin(35)),
      122 	msf_manager_$get_ptr	entry (ptr, fixed bin, bit(1), ptr, fixed bin(24), fixed bin(35)),
      123 	msf_manager_$close		entry (ptr),
      124 	nd_handler_		entry (char(*), char(*), char(*), fixed bin(35)),
      125 	release_system_msa_		entry (ptr, fixed bin(35)),
      126 	unique_chars_		entry (bit(*) aligned) returns (char(15));
      127 
      128      dcl						/*	static variables			*/
      129 	False			bit(1) int static options(constant) init ("0"b),
      130 	True			bit(1) int static options(constant) init ("1"b),
      131          (error_table_$action_not_performed,
      132 	error_table_$entlong,
      133 	error_table_$longeql,
      134 	error_table_$namedup,
      135 	error_table_$noentry,
      136 	error_table_$not_detached,
      137 	error_table_$not_done,
      138 	error_table_$not_open)	fixed bin(35) ext static,
      139 	finish			bit(1) aligned int static options(constant) init ("1"b),
      140 	group_id			char(32) int static init (""),
      141 	on_unit			bit(1) aligned int static options(constant) init ("0"b),
      142 	stream_output		fixed bin int static init (2);
      143 						/* iox_ opening mode for stream-output I/O.	*/
      144 
      145 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      146 
      147 
      148 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      149 	/*									*/
      150 	/* 1) initialize library pgm's file control block.				*/
      151 	/* 2) establish cleanup on unit.						*/
      152 	/* 3) attach/open output file.						*/
      153 	/* 4) get ptr to system multi-segment area, and establish area on unit.		*/
      154 	/* 5) search and build status tree for library entries being sought.			*/
      155 	/* 6) make a list of found entries						*/
      156 	/*									*/
      157 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      158 
      159 	Acode = 0;				/* initialize output argument.		*/
      160 
      161 	Pfcb = addr(fcb_temp);
      162 	fcb.version = Vfcb_1;
      163 	fcb.ioname = "lib_fetch_";			/* do all of our output on the lib_fetch_ ioname.	*/
      164 	fcb.Piocb = null;				/* indicate no attachment so far.		*/
      165 	fcb.Eend_page = no_end_page;
      166 	fcb.page_length = 131071;
      167 	fcb.page_text_length = 131071;
      168 	fcb.page_no = 1;
      169 	fcb.line_length = 79;
      170 	fcb.line_no = 2;
      171 
      172 	Parea = null;				/* initialize values used by cleanup on unit.	*/
      173 	Pent = null;
      174 	Pmsf_fcb = null;
      175 	Pcopy = null;
      176 	string(S_) = ""b;				/* initialize all switches.			*/
      177 	on cleanup call janitor(on_unit);
      178 
      179 	if Sc.output_file then do;			/* attach/open output file if required.		*/
      180 	     if substr(arg_struc.output_file, length(arg_struc.output_file)-5) ^= ".fetch" then
      181 		if length(arg_struc.output_file) > 162 then do;
      182 		     code = error_table_$entlong;
      183 		     go to  BAD_ATTACH;
      184 		     end;
      185 		else arg_struc.output_file = arg_struc.output_file || ".fetch";
      186 	     call iox_$attach_ioname (fcb.ioname, fcb.Piocb,
      187 		"vfile_ " || arg_struc.output_file || " -extend", code);
      188 	     if code ^= 0 then go to BAD_ATTACH;
      189 	     call iox_$open (fcb.Piocb, stream_output, "0"b, code);
      190 	     if code ^= 0 then go to BAD_OPEN;
      191 	     end;
      192 
      193 	call expand_path_ (addr(substr(arg_struc.into_path,1)), length(arg_struc.into_path), addr(into_dir),
      194 	     addr(into_ent), code);
      195 	if code ^= 0 then go to BAD_INTO;		/* validate -into path specification.		*/
      196 	call get_equal_name_ ((32) ".", into_ent, target_name, code);
      197 	if code = error_table_$longeql then;
      198 	else if code ^= 0 then go to BAD_INTO;
      199 
      200 	call condition_ ("area", msa_manager_$area_handler);
      201 						/* let msa_manager_ handle area conditions.	*/
      202 	call get_system_msa_ (addr(Parea), 0, (null));	/* get MSA ptr.				*/
      203 
      204 	call lib_descriptor_$fetch (arg_struc.descriptor, Plibrary, Pstarname, Pexclude,
      205 	     Srequirements, Scontrol, Parea, Ptree, progress, code);
      206 						/* get a tree of status nodes reflecting the	*/
      207 	if code ^= 0 then go to BAD_SEARCH;		/* library entries which match the star name.	*/
      208 
      209 	allocate 	index_list in (area),		/* allocate space for sorting the status nodes.	*/
      210 		name_list in (area),
      211 		node_list in (area);
      212 	index_list.I = 0;				/* initialize count of entries in each list.	*/
      213 	name_list.I = 0;
      214 	node_list.I = 0;
      215 	call lib_sort_tree_$make_name_list (Ptree, Pname_list, Pindex_list, Pnode_list, code);
      216 	if code ^= 0 then go to NO_MATCH;		/* put the outputable nodes into a name list.	*/
      217 	do i = 1 to index_list.I;			/* initialize the index list			*/
      218 	     index_list.e (i) = i;
      219 	end;
      220 
      221 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      222 	/*									*/
      223 	/* For EACH library entry which was found:					*/
      224 	/* 1) Get a pointer to the node describing the found entry.				*/
      225 	/* 2) Complain if the entry is a link, and links are not being chased.		*/
      226 	/* 3) Get pointer to, and bit count of, the library entry to be fetched.		*/
      227 	/* 4) For segments, archives, archive components, and MSF components:			*/
      228 	/*    a) create a uniquely-named target segment in the user-specified directory.	*/
      229 	/*    b) copy the library entry into the target segment.				*/
      230 	/*    c) if the library entry is an object segment, set the user's access to the target	*/
      231 	/*       segment to 're'.							*/
      232 	/*    d) terminate the library entry.						*/
      233 	/*									*/
      234 	/*    For MSFs:								*/
      235 	/*    a) create a uniquely-name target MSF in the user-specified directory, via 	*/
      236 	/*       msf_manager_.							*/
      237 	/*    b) copy the library MSF into the target MSF, component by component.		*/
      238 	/*    c) terminate each library MSF component as it is copied.			*/
      239 	/* 5) Add ALL, the PRIMARY, or the MATCHING names to the uniquely-named target, as	*/
      240 	/*    the user specified.							*/
      241 	/* 6) Remove the unique name.							*/
      242 	/* 7) Output message to the user if -long was specified.				*/
      243 	/*									*/
      244 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      245 
      246 
      247 	Nentries_fetched = 0;
      248 	do i = 1 to index_list.I;			/* loop through nodes to be fetched.		*/
      249 	     unique_name = unique_chars_ (""b);		/*     get unique name to place on target segment.*/
      250 	     Pnode = node_list.e (index_list.e(i));	/*     get ptr to node.			*/
      251 	     call lib_node_path_ (Pnode, dir, ent);	/*     get pathname of library entry.		*/
      252 	     if node.T = Tlink then if ^Sc.chase then do;	/*     warn user that links aren't chased.	*/
      253 		if S_.link_error_output then
      254 		     call arg_struc.put_error (error_table_$not_done, arg_struc.program, " Link  ^a>^a",
      255 			dir, ent);
      256 		else do;
      257 		     call arg_struc.put_error (error_table_$not_done, arg_struc.program, "
      258   Use the -chase option to fetch the target of the link
      259   ^a>^a.", dir, ent);
      260 		     S_.link_error_output = True;
      261 		     end;
      262 		node_list.e (index_list.e(i)) = null;
      263 		Acode = code;
      264 		go to NEXT_NODE;
      265 		end;
      266 	     msf_comp = 0;
      267 	     call lib_ptr_and_bc_ (Pnode, msf_comp, Ptarget_node, Pent, bc, code);
      268 	     if code ^= 0 then do;
      269 		if node.T = Tlink then
      270 		     call arg_struc.put_error (code, arg_struc.program, "
      271   Unable to fetch through null link  ^a>^a.", dir, ent);
      272 		else call arg_struc.put_error (code, arg_struc.program, "
      273   Unable to fetch ^a  ^a>^a.", node_type(node.T), dir, ent);
      274 		node_list.e (index_list.e(i)) = null;
      275 		Acode = code;
      276 		go to NEXT_NODE;
      277 		end;
      278 	     if node.T = Tlink then
      279 		go to COPY (Ptarget_node->node.T);	/*     copy according to type of library entry.	*/
      280 	     else go to COPY (node.T);
      281  
      282 COPY(1):						/*     segment entries.			*/
      283 COPY(4):						/*     MSF component entries.			*/
      284 COPY(5):						/*     archive entries.			*/
      285 COPY(6):						/*     archive component entries.		*/
      286 	     call hcs_$make_seg (into_dir, unique_name, "", 01010b, Pcopy, code);
      287 	     if Pcopy = null then do;			/*     create new segment in which ent is copied.	*/
      288 		call arg_struc.put_error (code, arg_struc.program, "
      289   Unable to create segment  ^a
      290   (^a>^a)
      291   into which the library entry will be copied.", ent, into_dir, unique_name);
      292 		S_.error = True;
      293 		Acode = code;
      294 		go to TERM_ENT;
      295 		end;
      296 	     S_.fetch_not_done = True;
      297 	     Lcopy = divide (bc+8, 9, 21, 0);		/*     compute number of characters to be copied.	*/
      298 	     copy = Pent -> copy;			/*     copy library entry into target segment.	*/
      299 	     call hcs_$set_bc_seg (Pcopy, bc, code);	/*     set the bit count on the target segment.	*/
      300 	     if Svalid.object_info then do;		/*     set ACL of object segs to 're'		*/
      301 		if ^S_.acl_init then do;
      302 		     if group_id = "" then group_id = get_group_id_$tag_star();
      303 		     acl.access_name = group_id;
      304 		     acl.modes       = "110"b;
      305 		     acl.zero_pad    = ""b;
      306 		     end;
      307 		call hcs_$add_acl_entries (into_dir, unique_name, addr(acl), 1, code);
      308 		if code ^= 0 then
      309 		     call arg_struc.put_error (code, arg_struc.program, "
      310   Unable to give user 're' access to fetched entry  ^a,
      311   (^a>^a).", ent, into_dir, unique_name);
      312 		end;
      313 TERM_ENT:	     call hcs_$terminate_noname (Pent, code);
      314 	     Pent = null;
      315 	     if S_.error then do;
      316 		S_.error = False;
      317 		node_list.e(index_list.e(i)) = null;
      318 		go to NEXT_NODE;
      319 		end;
      320 	     go to JOIN;
      321  
      322 COPY(3):						/*     MSF entries.				*/
      323 	     S_.msf = True;				/*     Indicate we're dealing with an MSF.	*/
      324 	     call msf_manager_$open (into_dir, unique_name, Pmsf_fcb, code);
      325 	     if code ^= 0 then if code ^= error_table_$noentry then do;
      326 						/*     create new MSF into which ent is copied.	*/
      327 		call arg_struc.put_error (code, arg_struc.program, "
      328   Unable to create MSF  ^a
      329   (^a>^a)
      330   into which the library MSF will be copied.", ent, into_dir, unique_name);
      331 		S_.error = True;
      332 		Acode = code;
      333 		go to TERM_MSF;
      334 		end;
      335 	     do while (Pent ^= null);			/*     copy MSF, component by component.	*/
      336 		call msf_manager_$get_ptr (Pmsf_fcb, msf_comp-1, True, Pcopy, 0, code);
      337 		if Pcopy = null then do;
      338 		     call arg_struc.put_error (code, arg_struc.program, "
      339   Unable to create MSF component ^d in MSF  ^a
      340   (^a>^a).", msf_comp-1, ent, into_dir, unique_name);
      341 		     S_.error = True;
      342 		     S_.delete_msf = (msf_comp >= 2);
      343 		     Acode = code;
      344 		     go to TERM_MSF;
      345 		     end;
      346 	  	S_.fetch_not_done = True;
      347 		Lcopy = divide (bc+8, 9, 21, 0);
      348 		copy = Pent -> copy;
      349 		call hcs_$set_bc_seg (Pcopy, bc, code);
      350 		call hcs_$terminate_noname (Pent, 0);
      351 		call lib_ptr_and_bc_ (Pnode, msf_comp, Ptarget_node, Pent, bc, code);
      352 		end;
      353 TERM_MSF:	     call msf_manager_$close (Pmsf_fcb);
      354 	     Pmsf_fcb = null;
      355 	     if S_.delete_msf then do;
      356 		call delete_$path (into_dir, unique_name, "000100"b, (arg_struc.program), code);
      357 		S_.delete_msf = False;
      358 		end;
      359 	     if S_.error then do;
      360 		S_.error = False;
      361 		node_list.e(index_list.e(i)) = null;
      362 		go to NEXT_NODE;
      363 		end;
      364 	     go to JOIN;
      365 
      366 JOIN:	     do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      367 		end;				/*     get list of names on library entry.	*/
      368 	     Iname = 0;				/*     indicate no names in list processed yet.	*/
      369 	     node_name = lib_next_name_ (node.Sreq, PDnames, Iname, Pstarname);
      370 	     S_.no_action = False;
      371 
      372 	     do while (node_name ^= "");		/*     add names to target, 1 by 1.		*/
      373 		call get_equal_name_ (node_name, into_ent, target_name, code);
      374 		if code ^= 0 then do;
      375 		     call arg_struc.put_error (code, arg_struc.program, "
      376   Unable to apply equal name  ^a  to library entry name  ^a.", into_ent, node_name);
      377 		     go to NEXT_NAME;
      378 		     end;
      379 		call hcs_$chname_file (into_dir, unique_name, "", target_name, code);
      380 		if code = error_table_$namedup then do;
      381 		     call nd_handler_ ((arg_struc.program), into_dir, target_name, nd_result);
      382 		     if nd_result = 0 then
      383 			call hcs_$chname_file (into_dir, unique_name, "", target_name, code);
      384 		     else if nd_result = error_table_$action_not_performed then S_.no_action = True;
      385 		     end;
      386 		else if code ^= 0 then do;
      387 		     call arg_struc.put_error (code, arg_struc.program, "
      388   Unable to add name  ^a  to copied library entry  ^a
      389   (^a>^a).", target_name, Dnames.names(1), into_dir, unique_name);
      390 		     Acode = code;
      391 		     end;
      392 NEXT_NAME:	node_name = lib_next_name_ (node.Sreq, PDnames, Iname, Pstarname);
      393 		end;
      394 
      395 	     S_.fetch_not_done = False;
      396 	     call hcs_$chname_file (into_dir, unique_name, unique_name, "", code);
      397 	     if code ^= 0 then do;			/* If unique name is only name on copy, complain!	*/
      398 		if ^S_.no_action then call arg_struc.put_error (code, arg_struc.program, "
      399   Unable to add any names to copied library entry  ^a
      400   The entry could not be fetched.", Dnames.names(1));
      401 		call delete_$path (into_dir, unique_name, "000100"b, (arg_struc.program), code);
      402 		node_list.e(index_list.e(i)) = null;
      403 		go to NEXT_NODE;
      404 		end;
      405 
      406 	     Nentries_fetched = Nentries_fetched + 1;	/* Increment count of entries actually fetched.	*/
      407 
      408 	     if Sc.long then do;			/*     output the fetched message.		*/
      409 		call ioa_ ("Library ^a  ^a  ^/  fetched from  ^a", node_type(node.T), ent, dir);
      410 		if arg_struc.into_path ^= "==" then
      411 		     call ioa_ ("  into  ^a>^a.", into_dir, target_name);
      412 		end;
      413 
      414 NEXT_NODE:     end;					/* That completes the processing for this node.	*/
      415 
      416 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      417 	/*									*/
      418 	/* Output list of fetched nodes into output file.					*/
      419 	/*									*/
      420 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      421 
      422 	if Nentries_fetched = 0 then return;
      423 	else if Sc.output_file then;
      424 	else return;
      425 
      426 	clock = clock_();
      427 	call date_time_ (clock, date);
      428 	if Nentries_fetched = 1 then
      429 	     call ioa_$ioa_switch (fcb.Piocb, "^/Entry   Fetched:^-^5x1");
      430 	else call ioa_$ioa_switch (fcb.Piocb, "^/Entries Fetched:^-^5x^d", Nentries_fetched);
      431 	call ioa_$ioa_switch (fcb.Piocb, "     Fetched on:^-^5x^a", date);
      432 	call ioa_$ioa_switch (fcb.Piocb, "     Fetched by:^-^5x^a", get_group_id_());
      433 	call ioa_$ioa_switch (fcb.Piocb, "     Descriptor:^-^5x^a", arg_struc.descriptor);
      434 	if library.N = 1 then
      435 	     call lib_array_list_ (" Library Name", Plibrary, fcb.Piocb);
      436 	else call lib_array_list_ ("Library Name", Plibrary, fcb.Piocb);
      437 	if starname.N = 1 then
      438 	     call lib_array_list_ ("  Search Name", Pstarname, fcb.Piocb);
      439 	else call lib_array_list_ (" Search Name", Pstarname, fcb.Piocb);
      440 
      441 	call lib_output_node_list_$info (Pfcb, Pnode_list, Pname_list, Pindex_list, "",
      442 	     (72)"1"b, addr(starname));
      443 						/* print the nodes, including names which	*/
      444 						/*    match the user's search names.		*/
      445 DETACH:	if Acode = 0 then Acode = code;
      446 	call janitor(finish);			/* clean up.				*/
      447 	return;
      448 
      449 janitor:	procedure (invocation_mode);			/* cleanup procedure.			*/
      450 
      451      dcl	invocation_mode		bit(1) aligned;	/* off if invoked by cleanup on unit.		*/
      452 
      453 	if Parea ^= null then			/* cleanup by releasing any system MSA.		*/
      454 	     call release_system_msa_ (addr(Parea), code);
      455 	if fcb.Piocb ^= null then do;			/* close/detach our output file, if open.	*/
      456 	     call iox_$close (fcb.Piocb, code);
      457 	     if invocation_mode = finish then if code ^= 0 then if code ^= error_table_$not_open
      458 		then go to BAD_CLOSE;
      459 	     call iox_$detach_iocb (fcb.Piocb, code);
      460 	     fcb.Piocb = null;			/* we've done all we can.  Stop trying.		*/
      461 	     if invocation_mode = finish then if code ^= 0 then go to BAD_DETACH;
      462 	     end;
      463 	if Pent ^= null then
      464 	     call hcs_$terminate_noname (Pent, code);
      465 	if S_.msf then
      466 	     if Pmsf_fcb ^= null then
      467 		call msf_manager_$close (Pmsf_fcb);
      468 	     else;
      469 	else if Pcopy ^= null then
      470 	     call hcs_$terminate_noname (Pent, code);
      471 	if S_.fetch_not_done then
      472 	     call delete_$path (into_dir, unique_name, "000100"b, (arg_struc.program), code);
      473 
      474 	end janitor;
      475 
      476 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      477 
      478 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      479 
      480 
      481 BAD_ATTACH:
      482 	if code = error_table_$not_detached then go to MULTIPLE_ATTACH;
      483 	state = "attaching";
      484 	fcb.Piocb = null;
      485 	go to BAD_IO;
      486 BAD_CLOSE:
      487 	state = "closing";
      488 	go to BAD_IO;
      489 BAD_DETACH:
      490 	state = "detaching";
      491 	go to BAD_IO;
      492 BAD_OPEN:
      493 	state = "opening";
      494 BAD_IO:	call arg_struc.put_error (code,arg_struc.program, "
      495   While ^a the fetch record  ^R^a^B
      496   using the I/O switch  ^R^a^B.",
      497 	     state, arg_struc.output_file, fcb.ioname);
      498 	go to DETACH;
      499 
      500 MULTIPLE_ATTACH:
      501 	call arg_struc.put_error (code, arg_struc.program, "
      502   While attaching the map file  ^R^a^B
      503   to the I/O switch  ^R^a^B.
      504   Release any other activations of ^a and try again.", arg_struc.output_file, fcb.ioname, arg_struc.program);
      505 	Acode = code;
      506 	return;
      507 
      508 BAD_INTO:	call arg_struc.put_error (code, arg_struc.program, " -into ^a", arg_struc.into_path);
      509 	Acode = code;
      510 	return;
      511 
      512 BAD_SEARCH:
      513 	progress = min (progress, 7);
      514 	go to BAD_S (progress);
      515 BAD_S(0): call arg_struc.put_error (code, arg_struc.program, "
      516   While calling lib_descriptor_$map.");
      517 	go to DETACH;
      518 BAD_S(1): call arg_struc.put_error (code, arg_struc.program, "
      519   While finding the  '^R^a^B'  library descriptor.",
      520 	     arg_struc.descriptor);
      521 	go to DETACH;
      522 BAD_S(2): call arg_struc.put_error (code, arg_struc.program, "
      523   Library descriptor  '^R^a^B'  does not implement
      524   the ^a command.",
      525 	     arg_struc.descriptor, arg_struc.program);
      526 	go to DETACH;
      527 BAD_S(3): state = "library";
      528 	go to NO_DEFAULT_NAMES;
      529 BAD_S(4): state = "search";
      530 NO_DEFAULT_NAMES:
      531 	call arg_struc.put_error (code, arg_struc.program, "
      532   No ^a names were specified, and the  '^R^a^B'
      533   library descriptor does not define any default ^a names.", state, arg_struc.descriptor, state);
      534 	go to DETACH;
      535 BAD_S(5): call arg_struc.put_error (code, arg_struc.program, "
      536   While allocating the root nodes of the library tree.");
      537 	go to DETACH;
      538 
      539 BAD_S(6):
      540 NO_MATCH:	call arg_struc.put_error (code, arg_struc.program, "
      541   While searching for entries in the library.
      542   Descriptor:^-^5x^a",
      543 	     arg_struc.descriptor);
      544 	call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      545 	call lib_error_list_ ("search name", Pstarname, arg_struc.program);
      546 	go to DETACH;
      547 BAD_S(7):	call arg_struc.put_error (code, arg_struc.program, "
      548   No libraries matching the library name(s) could be found.
      549   Descriptor:^-^5x^a", arg_struc.descriptor);
      550 	call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      551 	go to DETACH;
      552 
      553 
      554 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      555 
      556 
      557 no_end_page:	procedure;			/* This is a null end-of-page handling proc.	*/
      558 
      559 	fcb.page_no = fcb.page_no + 1;
      560 	fcb.line_no = 1;
      561 
      562 	end no_end_page;
      563 
      564 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      565 
  1     1 /* START OF	lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* NAME:  lib_arg_struc_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures used by the library maintenance tools	*/
  1     8 	/* to process their input arguments.  These structures are the arguments to the		*/
  1     9 	/* lib_args_ subroutine.							*/
  1    10 	/*									*/
  1    11 	/* STATUS									*/
  1    12 	/*									*/
  1    13 	/* 0) Created on:   May 25, 1976 by   Gary C. Dixon				*/
  1    14 	/* 1) Modified:     October 24, 1983 by Jim Lippard to add page_length		*/
  1    15 	/*									*/
  1    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    17 
  1    18 
  2     1 /* START OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_args_.incl.pl1							*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines structures for the arrays of library names and search*/
  2     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  2     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  2    10 	/* to the lib_descriptor_ subroutine.						*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  2    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  2    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  2    17 	/* 3) Modified on:  January 17, 1984 by Jim Lippard to make structures aligned.		*/
  2    18 	/*									*/
  2    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    20 
  2    21 
  2    22      dcl	1 LIBRARY			aligned,		/* a structure containing names of libraries to	*/
  2    23 						/*   be searched.				*/
  2    24 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  2    25 	  2 group (100),				/*   attribute: array of library names		*/
  2    26 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  2    27 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    28 						/*     this library name.			*/
  2    29 
  2    30      dcl	1 STARNAME		aligned,		/* a structure containing names of library entries*/
  2    31 						/*   being searched for.			*/
  2    32 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  2    33 	  2 group (1000),				/*   attribute: array of starnames		*/
  2    34 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  2    35 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    36 						/*     this starname.			*/
  2    37 
  2    38      dcl 	1 EXCLUDE			aligned like STARNAME;
  2    39 						/* structure containing names of library entries	*/
  2    40 						/*   to be excluded from a search.		*/
  2    41 
  2    42 /* END OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    19 
  1    20 
  1    21      dcl	Parg_struc		ptr;		/* ptr to the structure described below.	*/
  1    22 
  1    23      dcl	1 arg_struc		structure based (Parg_struc),
  1    24 	  2 version		fixed bin,	/* version number (currently 1).		*/
  1    25 	  2 program		char(32) varying,	/* name of calling program. 			*/
  1    26 	  2 Parg_list		ptr,		/* ptr to calling program's argument list. 	*/
  1    27 	  2 Iarg_list		fixed bin,	/* first arg of calling program's argument list	*/
  1    28 						/*   to be processed.			*/
  1    29 	  2 Larg_list		fixed bin,	/* total number of arguments in calling pgm's list*/
  1    30 	  2 put_error		entry options(variable),
  1    31 						/* program to call to output an error.		*/
  1    32 	  2 Srequirements_allowed	bit(72) aligned,	/* bits on if control argument associated with	*/
  1    33 						/*   that bit is acceptable to the program. 	*/
  1    34 	  2 Scontrol_allowed	bit(36) aligned,	/* bits on if control operation associated with	*/
  1    35 						/*   that bit is acceptable to the program. 	*/
  1    36 	  2 Srequirements_initial	bit(72) aligned,	/* bits on indicating initial settings for 	*/
  1    37 						/*   Srequirements. 			*/
  1    38 	  2 Scontrol_initial	bit(36) aligned,	/* bits on indicating initial settings for	*/
  1    39 						/*   Scontrol.  				*/
  1    40 	  2 descriptor		char(168) varying,	/* name of library descriptor to be used. 	*/
  1    41 	  2 footing		char(45) varying,	/* footing to be used on output pages. 		*/
  1    42 	  2 heading		char(120) varying,	/* heading to be used on 1st output page.	*/
  1    43 	  2 into_path		char(168) varying,	/* path into which library entries to be fetched.	*/
  1    44 	  2 output_file		char(168) varying,	/* path of output file to be written.		*/
  1    45 	  2 page_length		fixed bin,	/* length of output page			*/
  1    46 	  2 time			fixed bin;	/* grace period (in days) for library_cleanup.	*/
  1    47      dcl	1 Sreq_allowed		aligned like Svalid_req based (addr(arg_struc.Srequirements_allowed));
  1    48 						/* allowed requirements switches.		*/
  1    49      dcl	1 Sreq_init		aligned like Svalid_req based (addr(arg_struc.Srequirements_initial));
  1    50 						/* initial values for requirements switches.	*/
  1    51      dcl	1 Sc_allowed		aligned like Sc based (addr(arg_struc.Scontrol_allowed));
  1    52 						/* allowed control switches.			*/
  1    53      dcl	1 Sc_init			aligned like Sc based (addr(arg_struc.Scontrol_initial));
  1    54 						/* initial values for control switches.		*/
  1    55      dcl	Varg_struc_1		fixed bin int static init (1);
  1    56 
  1    57 /* END OF		lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      566 
      567 
  3     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines structures for the arrays of library names and search*/
  3     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  3     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  3    10 	/* to the lib_descriptor_ subroutine.						*/
  3    11 	/*									*/
  3    12 	/* S__t_a_t_u_s									*/
  3    13 	/*									*/
  3    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  3    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  3    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  3    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  3    18 	/*									*/
  3    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    20 
  3    21 
  3    22      dcl	1 library			aligned based (Plibrary),
  3    23 						/* a structure containing names of libraries to	*/
  3    24 						/*   be searched.				*/
  3    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  3    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  3    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  3    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  3    30 						/*     this library name.			*/
  3    31 
  3    32      dcl	1 starname		aligned based (Pstarname),
  3    33 						/* a structure containing names of library entries*/
  3    34 						/*   being searched for.			*/
  3    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  3    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  3    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  3    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    39 						/*     this starname.			*/
  3    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  3    41 
  3    42      dcl	1 exclude			aligned based (Pexclude),
  3    43 						/* a structure containing names of library entries*/
  3    44 						/*   being excluded from the search.		*/
  3    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  3    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  3    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  3    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    49 						/*     this exclude.			*/
  3    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  3    51 
  3    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      568 
      569 
  4     1 /* START OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3      dcl	1 fcb			based (Pfcb),	/* file control block for our output file.	*/
  4     4 	  2 version		fixed bin,	/*    version number = 1;			*/
  4     5 	  2 ioname		char(32),		/*    ioname of our I/O control block.		*/
  4     6 	  2 Piocb			ptr,		/*    ptr to our I/O control block.		*/
  4     7 	  2 Eend_page		entry variable,	/*    entry which handles endpage condition.	*/
  4     8 	  2 page_length		fixed bin,	/*    number of lines per page.		*/
  4     9 	  2 page_text_length	fixed bin,	/*    number of usable lines per page, excluding	*/
  4    10 						/*       footer lines generated by end-of-page	*/
  4    11 						/*       handler.				*/
  4    12 	  2 page_no		fixed bin,	/*    current page number.			*/
  4    13 	  2 line_length		fixed bin,	/*    number of characters per line.		*/
  4    14 	  2 line_no		fixed bin;	/*    number of lines on current page.		*/
  4    15      dcl	Pfcb			ptr;		/* ptr to file control block.			*/
  4    16      dcl	Vfcb_1			fixed bin int static options(constant) init (1);
  4    17 
  4    18 /* END OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      570 
      571 
  5     1 /* START OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* Name:  lib_list_.incl.pl1							*/
  5     6 	/*									*/
  5     7 	/*      This segment declares the list structures which are used by the library 	*/
  5     8 	/* maintenance tools.  The structures are filled in by lib_sort_tree_, and referenced by	*/
  5     9 	/* lib_output_node_list_, having been allocated originally by one of the maintenance	*/
  5    10 	/* commands (library_map, library_info, library_print, etc).			*/
  5    11 	/*									*/
  5    12 	/* Status									*/
  5    13 	/*									*/
  5    14 	/* 0) Created on:  May 30, 1976  by  G. C. Dixon					*/
  5    15 	/*									*/
  5    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    17 
  5    18 
  5    19      dcl	1 index_list		aligned based (Pindex_list),
  5    20 						/* an index list.				*/
  5    21 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    22 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    23 	  2 e (max_entries refer (index_list.N))
  5    24 				fixed bin(24),	/* the list.				*/
  5    25 	1 name_list		aligned based (Pname_list),
  5    26 						/* a name list.				*/
  5    27 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    28 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    29 	  2 e (max_entries refer (name_list.N))	ptr unal,	/* list of ptrs to node names.		*/
  5    30 	1 node_list		aligned based (Pnode_list),
  5    31 						/* a list of ptrs to nodes to be output.	*/
  5    32 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    33 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    34 	  2 e (max_entries refer (node_list.N))	ptr unal,	/* list of ptrs to nodes.			*/
  5    35 	1 page_list		aligned based (Ppage_list),
  5    36 						/* list of page numbers on which each node was	*/
  5    37 						/* output.				*/
  5    38 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    39 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    40 	  2 e (max_entries refer (page_list.N))	
  5    41 				fixed bin(24),	/* list of page numbers.			*/
  5    42 	max_entries		fixed bin int static init (32000),
  5    43 	Pindex_list		ptr,		/* ptr to index_list structure.		*/
  5    44 	Pname_list		ptr,		/* ptr to name_list structure.		*/
  5    45 	Pnode_list		ptr,		/* ptr to node_list structure.		*/
  5    46 	Ppage_list		ptr;		/* ptr to page_list structure.		*/
  5    47 
  5    48 /* END OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      572 
      573 
  6     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 	/*									*/
  6     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  6     6 	/*									*/
  6     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  6     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  6     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  6    10 	/* called the node target.							*/
  6    11 	/*									*/
  6    12 	/* S__t_a_t_u_s									*/
  6    13 	/*									*/
  6    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  6    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  6    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  6    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  6    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  6    19 	/*									*/
  6    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    21 
  6    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    23 	/*									*/
  6    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  6    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  6    26 	/* both types of nodes are the same length.					*/
  6    27 	/*									*/
  6    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    29 
  6    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  6    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  6    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  6    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  6    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  6    35 						/*             (= node.Svalid & Srequirements)	*/
  6    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  6    37 	  2 switches		unaligned,
  6    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  6    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  6    40 						/* 	     entry before lib_access_mode_$set.	*/
  6    41 	    3 pad			bit(22),
  6    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  6    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  6    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  6    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  6    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  6    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  6    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  6    49 						/*	     in this directory;  if off, records*/
  6    50 						/*	     charged against 1st superior	*/
  6    51 						/*	     directory with switch on.	*/
  6    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  6    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  6    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  6    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  6    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  6    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  6    58 
  6    59 						/* From here on, link_nodes differ from nodes	*/
  6    60 						/*  for other types of node targets.		*/
  6    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  6    62 
  6    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    64 	/*									*/
  6    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  6    66 	/*									*/
  6    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    68 
  6    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  6    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  6    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  6    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  6    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  6    74 						/*             (= node.Svalid & Srequirements)	*/
  6    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  6    76 	  2 switches		unaligned,
  6    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  6    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  6    79 						/* 	     entry before lib_access_mode_$set.	*/
  6    80 	    3 pad			bit(22),
  6    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  6    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  6    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  6    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  6    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  6    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  6    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  6    88 						/*	     in this directory;  if off, records*/
  6    89 						/*	     charged against 1st superior	*/
  6    90 						/*	     directory with switch on.	*/
  6    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  6    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  6    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  6    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  6    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  6    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  6    97 
  6    98 						/* From here on, other nodes differ from	*/
  6    99 						/*  link_nodes.				*/
  6   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  6   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  6   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  6   103 	  2 pad1 (1)		fixed bin,
  6   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  6   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  6   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  6   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  6   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  6   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  6   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  6   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  6   112 						/*             component from the base of archive.*/
  6   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  6   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  6   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  6   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  6   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  6   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  6   119 						/*	     updated.			*/
  6   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  6   121 						/*	     directories with Sterminal_account	*/
  6   122 						/*	     on.				*/
  6   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  6   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  6   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  6   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  6   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  6   128 						/*	     updated.			*/
  6   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  6   130 						/*	     directories with Sterminal_account	*/
  6   131 						/*	     on.				*/
  6   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  6   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  6   134 	  2 pad2 (5)		fixed bin,
  6   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  6   136 
  6   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   138 	/*									*/
  6   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  6   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  6   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  6   142 	/* descriptors are the only ones that have been defined.				*/
  6   143 	/*									*/
  6   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   145 
  6   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  6   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  6   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  6   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  6   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  6   152 
  6   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  6   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  6   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  6   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   163 	    3 zero_pad		bit(36),
  6   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  6   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  6   167 	Vacl_1			fixed bin int static options(constant) init (1),
  6   168 						/* version:   version of ACL descriptor.	*/
  6   169 	Tacl			fixed bin int static options(constant) init (7);
  6   170 						/* attribute: type of a segment ACL descriptor.	*/
  6   171 
  6   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  6   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  6   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  6   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  6   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  6   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  6   186 						/* version:   version of directory ACL descriptor.*/
  6   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  6   188 						/* attribute: type of a directory ACL descriptor.	*/
  6   189 
  6   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  6   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  6   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  6   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  6   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  6   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  6   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  6   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  6   206 						/* version:   version of dir IACL descriptor.	*/
  6   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  6   208 
  6   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  6   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  6   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  6   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  6   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  6   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   221 	    3 zero_pad		bit(36),
  6   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  6   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  6   225 	Viacl_1			fixed bin int static options(constant) init (1),
  6   226 						/* version:   version of segment IACL descriptor.	*/
  6   227 	Tiacl			fixed bin int static options(constant) init (10);
  6   228 						/* attribute: type of a segment IACL descriptor.	*/
  6   229 
  6   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  6   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  6   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  6   236 	  2 names (Nnames refer (Dnames.N))
  6   237 				char(32),		/* attribute: names.			*/
  6   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  6   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  6   240 	Vnames_1			fixed bin int static options(constant) init (1),
  6   241 						/* version:   version of names descriptor.	*/
  6   242 	Tnames			fixed bin int static options(constant) init (1);
  6   243 						/* attribute: type of a name descriptor.	*/
  6   244 
  6   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  6   246 						/* nodes.					*/
  6   247 	  2 header,
  6   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  6   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  6   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  6   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  6   255 				like node,
  6   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  6   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  6   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  6   259 						/* version:   version of nodes descriptor.	*/
  6   260 	Tnodes			fixed bin int static options(constant) init (2);
  6   261 						/* attribute: type of a node descriptor.	*/
  6   262 
  6   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  6   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  6   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   268 	  2 info,
  6   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  6   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  6   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  6   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  6   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  6   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  6   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  6   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  6   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  6   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  6   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  6   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  6   281 	    3 format		aligned,
  6   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  6   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  6   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  6   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  6   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  6   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  6   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  6   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  6   290 	      4 pad		bit(28) unal,
  6   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  6   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  6   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  6   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  6   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  6   296 	    3 cversion,				/* attribite: compiler version string.		*/
  6   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  6   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  6   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  6   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  6   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  6   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  6   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  6   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  6   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  6   306 	Vobj_1			fixed bin int static options(constant) init (1),
  6   307 						/* version:   version of object_info_ descriptor.	*/
  6   308 	Tobj			fixed bin int static options(constant) init (3);
  6   309 						/* attribute: type of a node descriptor.	*/
  6   310 
  6   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  6   312 						/* library root search_proc attribute descriptor.	*/
  6   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  6   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  6   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  6   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  6   320 						/* version:   version of search_proc info descrip.*/
  6   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  6   322 						/* attribute: type of a search_proc descriptor.	*/
  6   323 
  6   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  6   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  6   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  6   330 						/*            output.			*/
  6   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  6   332 	  2 info			char(Luser refer (Duser.L)),
  6   333 						/* attribute: user info string.		*/
  6   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  6   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  6   336 	Vuser_1			fixed bin int static options(constant) init (1),
  6   337 						/* version:   version of user info descriptor.	*/
  6   338 	Tuser			fixed bin int static options(constant) init (6);
  6   339 						/* attribute: type of a user descriptor.	*/
  6   340 
  7     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7     4 	/*									*/
  7     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  7     6 	/*									*/
  7     7 	/*      This include segment defines the switches which request/validate the fields	*/
  7     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  7     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  7    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  7    11 	/* descriptor commands to obtain information about entries in a library.		*/
  7    12 	/*									*/
  7    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  7    14 	/* is requested for output.							*/
  7    15 	/*									*/
  7    16 	/* S__t_a_t_u_s									*/
  7    17 	/*									*/
  7    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  7    19 	/*									*/
  7    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    21 
  7    22 
  7    23      dcl	1 Svalid_req		aligned based,
  7    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  7    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  7    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  7    27 
  7    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  7    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  7    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  7    31 
  7    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  7    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  7    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  7    35 
  7    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  7    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  7    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  7    39 
  7    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  7    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  7    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  7    43 
  7    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  7    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  7    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  7    47 
  7    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  7    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  7    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  7    51 
  7    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  7    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  7    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  7    55 
  7    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  7    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  7    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  7    59 
  7    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  7    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  7    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  7    63 
  7    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  7    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  7    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  7    67 
  7    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  7    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  7    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  7    71 
  7    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  7    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  7    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  7    75 
  7    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  7    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  7    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  7    79 	  2 pad			bit(26) unal,
  7    80 
  7    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  7    82 
  7    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  7    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  7    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  7    86 
  7    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    88 	/*									*/
  7    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  7    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  7    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  7    92 	/*									*/
  7    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    94 
  7    95 
  7    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  7    97 	Srequirements		bit(72) aligned;
  7    98 
  7    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6   341 
  6   342 
  6   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  6   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  6   345 
  8     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8     4 	/*									*/
  8     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  8     6 	/*									*/
  8     7 	/*      This include segment defines the control switches used by library descriptor	*/
  8     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  8     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  8    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  8    11 	/* to the lib_descriptor_ subroutine.						*/
  8    12 	/*									*/
  8    13 	/* S__t_a_t_u_s									*/
  8    14 	/*									*/
  8    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  8    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  8    17 	/*									*/
  8    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    19 
  8    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  8    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  8    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  8    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  8    24 
  8    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  8    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  8    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  8    28 						/*         nodes of the tree, and about all the	*/
  8    29 						/*	 nodes below the parent.		*/
  8    30 
  8    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  8    32 						/*         nodes of the tree.			*/
  8    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  8    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  8    35 
  8    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  8    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  8    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  8    39 						/*         deletion.			*/
  8    40 
  8    41 	  2 pad			bit(10) unal,
  8    42 
  8    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  8    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  8    45 
  8    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  8    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  8    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  8    49 
  8    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  8    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  8    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  8    53 
  8    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  8    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  8    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  8    57 
  8    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  8    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  8    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  8    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  8    62 
  8    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6   346 
  6   347 
  6   348 
  6   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   350 	/*									*/
  6   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  6   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  6   353 	/* that:		mod (type, 2) = 1;						*/
  6   354 	/*									*/
  6   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   356 
  6   357 
  6   358      dcl (Tlink			init (0),
  6   359 	Tsegment			init (1),
  6   360 	Tdirectory		init (2),
  6   361 	Tmsf			init (3),
  6   362 	Tmsf_comp			init (4),
  6   363 	Tarchive			init (5),
  6   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  6   365 
  6   366 
  6   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   368 	/*									*/
  6   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  6   370 	/* Both brief and long string arrays are provided.				*/
  6   371 	/*									*/
  6   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   373 
  6   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  6   375 				"link",
  6   376 				"segment",
  6   377 				"directory",
  6   378 				"multisegment file",
  6   379 				"multi-segment file component",
  6   380 				"archive",
  6   381 				"archive component"),
  6   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  6   383 				"link",
  6   384 				"segment",
  6   385 				"directory",
  6   386 				"msf",
  6   387 				"msf comp",
  6   388 				"archive",
  6   389 				"arch comp");
  6   390 
  6   391 
  6   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      574 
      575 
      576 
      577 	end lib_fetch_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/25/84  1154.5  lib_fetch_.pl1                    >spec>on>6875-09/25/84>lib_fetch_.pl1
566          1    02/16/84  0928.6  lib_arg_struc_.incl.pl1           >ldd>include>lib_arg_struc_.incl.pl1
1-19         2    02/16/84  0928.6  lib_args_.incl.pl1                >ldd>include>lib_args_.incl.pl1
568          3    02/16/84  0928.6  lib_based_args_.incl.pl1          >ldd>include>lib_based_args_.incl.pl1
570          4    01/05/79  1321.1  lib_fcb_.incl.pl1                 >ldd>include>lib_fcb_.incl.pl1
572          5    02/28/77  1409.2  lib_list_.incl.pl1                >ldd>include>lib_list_.incl.pl1
574          6    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
6-341        7    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
6-346        8    02/16/84  0928.6  lib_Scontrol_.incl.pl1            >ldd>include>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Acode                                  parameter       fixed bin(35,0)          dcl 22 set ref 19 159* 263* 275* 293* 332* 343* 390*
                                                                                  445 445* 505* 509*
Dnames                                 based           structure                level 1 unaligned dcl 6-230
Eend_page                14            based           entry variable           level 2 dcl 4-3 set ref 165*
False                                  constant        bit(1)                   initial unaligned dcl 128 ref 316 357 360 370 395
I                         1            based           fixed bin(24,0)          level 2 in structure "name_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 213*
I                         1            based           fixed bin(24,0)          level 2 in structure "index_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 212* 217 248
I                         1            based           fixed bin(24,0)          level 2 in structure "node_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 214*
Iname                           000100 automatic       fixed bin(17,0)          dcl 25 set ref 368* 369* 392*
Lcopy                           000101 automatic       fixed bin(21,0)          dcl 25 set ref 297* 298 298 347* 348 348
N                                      based           fixed bin(17,0)          level 2 in structure "library" dcl 3-22 in procedure
                                                                                  "lib_fetch_" ref 434
N                                      based           fixed bin(17,0)          level 2 in structure "starname" dcl 3-32
                                                                                  in procedure "lib_fetch_" set ref 437
N                                      based           fixed bin(24,0)          level 2 in structure "node_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 209*
N                                      based           fixed bin(24,0)          level 2 in structure "index_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 209*
N                                      based           fixed bin(24,0)          level 2 in structure "name_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 209*
Nentries_fetched                000102 automatic       fixed bin(17,0)          dcl 25 set ref 247* 406* 406 422 428 430*
PD                        2            based           pointer                  level 2 dcl 6-69 ref 366
PDnames                         022074 automatic       pointer                  dcl 6-230 set ref 366* 366* 367 369* 387 392* 398
Parea                           000104 automatic       pointer                  dcl 25 set ref 172* 202 202 204* 209 209 209 453 453
                                                                                  453
Parg_struc                             parameter       pointer                  dcl 1-21 ref 19 180 180 180 185 185 186 193 193 193
                                                                                  193 204 253 253 257 257 269 269 272 272 288 288
                                                                                  308 308 327 327 338 338 356 375 375 381 387 387
                                                                                  398 398 401 410 433 471 494 494 494 500 500 500
                                                                                  500 508 508 508 515 515 518 518 518 522 522 522
                                                                                  522 530 530 530 535 535 539 539 539 544 545 547
                                                                                  547 547 550
Pcopy                           000106 automatic       pointer                  dcl 25 set ref 175* 282* 287 298 299* 336* 337 348
                                                                                  349* 469
Pent                            000110 automatic       pointer                  dcl 25 set ref 173* 267* 298 313* 314* 335 348 350*
                                                                                  351* 463 463* 469*
Pexclude                               parameter       pointer                  dcl 3-50 set ref 19 204*
Pfcb                            022062 automatic       pointer                  dcl 4-15 set ref 161* 162 163 164 165 166 167 168
                                                                                  169 170 186 186 189 428 430 431 432 433 434 436
                                                                                  437 439 441* 455 456 459 460 484 494 500 559 559
                                                                                  560
Pindex_list                     022064 automatic       pointer                  dcl 5-19 set ref 209* 212 215* 217 218 248 250 262
                                                                                  274 317 361 402 441*
Piocb                    12            based           pointer                  level 2 dcl 4-3 set ref 164* 186* 189* 428* 430*
                                                                                  431* 432* 433* 434* 436* 437* 439* 455 456* 459*
                                                                                  460* 484*
Plibrary                               parameter       pointer                  dcl 3-29 set ref 19 204* 434 434* 436* 544* 550*
Pmsf_fcb                        000112 automatic       pointer                  dcl 25 set ref 174* 324* 336* 353* 354* 465 465*
Pname_list                      022066 automatic       pointer                  dcl 5-19 set ref 209* 213 215* 441*
Pnext                     2            based           pointer                  level 2 dcl 6-230 ref 367
Pnode                           022072 automatic       pointer                  dcl 6-69 set ref 250* 251* 252 267* 269 272 278 280
                                                                                  300 351* 366 369 392 409
Pnode_list                      022070 automatic       pointer                  dcl 5-19 set ref 209* 214 215* 250 262 274 317 361
                                                                                  402 441*
Pstarname                              parameter       pointer                  dcl 3-40 set ref 19 204* 369* 392* 437 437* 439* 441
                                                                                  441 545*
Ptarget_node                    000114 automatic       pointer                  dcl 25 set ref 267* 278 351*
Ptree                           000116 automatic       pointer                  dcl 25 set ref 204* 215*
STARNAME                        000410 automatic       structure                level 1 dcl 2-30
S_                              000120 automatic       structure                level 1 packed unaligned dcl 25 set ref 176*
Sc                                     based           structure                level 1 dcl 8-20
Scontrol                               parameter       bit(36)                  dcl 8-20 set ref 19 179 204* 252 408 423
Sreq                      6            based           bit(72)                  level 2 dcl 6-69 set ref 369* 392*
Srequirements                          parameter       bit(72)                  dcl 7-96 set ref 19 204*
Svalid                                 based           structure                level 1 dcl 6-343 in procedure "lib_fetch_"
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 6-69 in procedure
                                                                                  "lib_fetch_" set ref 300
Svalid_req                             based           structure                level 1 dcl 7-23
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 6-230 in procedure
                                                                                  "lib_fetch_" ref 366
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 6-69 in procedure
                                                                                  "lib_fetch_" ref 252 269 272 278 278 280 409
Tlink                                  constant        fixed bin(17,0)          initial dcl 6-358 ref 252 269 278
Tnames                                 constant        fixed bin(17,0)          initial dcl 6-230 ref 366
True                            000115 constant        bit(1)                   initial unaligned dcl 128 set ref 260 292 296 322
                                                                                  331 336* 341 346 384
Vfcb_1                                 constant        fixed bin(17,0)          initial dcl 4-16 ref 162
access_name                     000121 automatic       char(32)                 level 2 packed unaligned dcl 25 set ref 303*
acl                             000121 automatic       structure                level 1 unaligned dcl 25 set ref 307 307
acl_init                  0(03) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 301
addr                                                   builtin function         dcl 85 ref 161 179 193 193 193 193 193 193 202 202
                                                                                  252 300 307 307 408 423 441 441 453 453
area                                   based           area(1024)               dcl 80 ref 209 209 209
arg_struc                              based           structure                level 1 unaligned dcl 1-23
bc                              000134 automatic       fixed bin(24,0)          dcl 25 set ref 267* 297 299* 347 349* 351*
chase                     0(02)        based           bit(1)                   level 2 packed unaligned dcl 8-20 ref 252
cleanup                         000402 stack reference condition                dcl 87 ref 177
clock                           000136 automatic       fixed bin(71,0)          dcl 25 set ref 426* 427*
clock_                          000024 constant        entry                    external dcl 89 ref 426
code                            000140 automatic       fixed bin(35,0)          dcl 25 set ref 182* 186* 188 189* 190 193* 195 196*
                                                                                  197 198 204* 207 215* 216 263 267* 268 269* 272*
                                                                                  275 282* 288* 293 299* 307* 308 308* 313* 324* 325
                                                                                  325 327* 332 336* 338* 343 349* 351* 356* 373* 374
                                                                                  375* 379* 380 382* 386 387* 390 396* 397 398* 401*
                                                                                  445 453* 456* 457 457 459* 461 463* 469* 471* 481
                                                                                  494* 500* 505 508* 509 515* 518* 522* 530* 535*
                                                                                  539* 547*
condition_                      000026 constant        entry                    external dcl 89 ref 200
copy                                   based           char                     unaligned dcl 80 set ref 298* 298 348* 348
date                            000141 automatic       char(16)                 dcl 25 set ref 427* 431*
date_time_                      000030 constant        entry                    external dcl 89 ref 427
delete_$path                    000032 constant        entry                    external dcl 89 ref 356 401 471
delete_msf                0(06) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 342* 355
                                                                                  357*
descriptor               30            based           varying char(168)        level 2 dcl 1-23 set ref 204* 433* 518* 522* 530*
                                                                                  539* 547*
dir                             000145 automatic       varying char(168)        dcl 25 set ref 251* 253* 257* 269* 272* 409*
divide                                                 builtin function         dcl 85 ref 297 347
e                         2            based           fixed bin(24,0)          array level 2 in structure "index_list" dcl 5-19
                                                                                  in procedure "lib_fetch_" set ref 218* 250 262 274
                                                                                  317 361 402
e                         2            based           pointer                  array level 2 in structure "node_list" packed
                                                                                  unaligned dcl 5-19 in procedure "lib_fetch_" set
                                                                                  ref 250 262* 274* 317* 361* 402*
ent                             000220 automatic       varying char(32)         dcl 25 set ref 251* 253* 257* 269* 272* 288* 308*
                                                                                  327* 338* 409*
error                     0(01) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 292* 315
                                                                                  316* 331* 341* 359 360*
error_table_$action_not_performed
                                000132 external static fixed bin(35,0)          dcl 128 ref 384
error_table_$entlong            000134 external static fixed bin(35,0)          dcl 128 ref 182
error_table_$longeql            000136 external static fixed bin(35,0)          dcl 128 ref 197
error_table_$namedup            000140 external static fixed bin(35,0)          dcl 128 ref 380
error_table_$noentry            000142 external static fixed bin(35,0)          dcl 128 ref 325
error_table_$not_detached       000144 external static fixed bin(35,0)          dcl 128 ref 481
error_table_$not_done           000146 external static fixed bin(35,0)          dcl 128 set ref 253* 257*
error_table_$not_open           000150 external static fixed bin(35,0)          dcl 128 ref 457
expand_path_                    000034 constant        entry                    external dcl 89 ref 193
fcb                                    based           structure                level 1 unaligned dcl 4-3
fcb_temp                        000232 automatic       structure                level 1 unaligned dcl 25 set ref 161
fetch_not_done            0(02) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 296* 346*
                                                                                  395* 471
finish                          000115 constant        bit(1)                   initial dcl 128 set ref 446* 457 461
get_equal_name_                 000036 constant        entry                    external dcl 89 ref 196 373
get_group_id_                   000040 constant        entry                    external dcl 89 ref 432 432
get_group_id_$tag_star          000042 constant        entry                    external dcl 89 ref 302
get_system_msa_                 000044 constant        entry                    external dcl 89 ref 202
group_id                        000010 internal static char(32)                 initial unaligned dcl 128 set ref 302 302* 303
hcs_$add_acl_entries            000046 constant        entry                    external dcl 89 ref 307
hcs_$chname_file                000050 constant        entry                    external dcl 89 ref 379 382 396
hcs_$make_seg                   000052 constant        entry                    external dcl 89 ref 282
hcs_$set_bc_seg                 000054 constant        entry                    external dcl 89 ref 299 349
hcs_$terminate_noname           000056 constant        entry                    external dcl 89 ref 313 350 463 469
i                               000257 automatic       fixed bin(17,0)          dcl 25 set ref 217* 218 218* 248* 250 262 274 317
                                                                                  361 402*
index_list                             based           structure                level 1 dcl 5-19 set ref 209
into_dir                        000260 automatic       char(168)                unaligned dcl 25 set ref 193 193 282* 288* 307* 308*
                                                                                  324* 327* 338* 356* 379* 381* 382* 387* 396* 401*
                                                                                  410* 471*
into_ent                        000332 automatic       char(32)                 unaligned dcl 25 set ref 193 193 196* 373* 375*
into_path               157            based           varying char(168)        level 2 dcl 1-23 set ref 193 193 193 193 410 508*
invocation_mode                        parameter       bit(1)                   dcl 451 ref 449 457 461
ioa_                            000060 constant        entry                    external dcl 89 ref 409 410
ioa_$ioa_switch                 000062 constant        entry                    external dcl 89 ref 428 430 431 432 433
ioname                    1            based           char(32)                 level 2 packed unaligned dcl 4-3 set ref 163* 186*
                                                                                  494* 500*
iox_$attach_ioname              000064 constant        entry                    external dcl 89 ref 186
iox_$close                      000066 constant        entry                    external dcl 89 ref 456
iox_$detach_iocb                000070 constant        entry                    external dcl 89 ref 459
iox_$open                       000072 constant        entry                    external dcl 89 ref 189
length                                                 builtin function         dcl 85 ref 180 180 193 193
lib_array_list_                 000074 constant        entry                    external dcl 89 ref 434 436 437 439
lib_descriptor_$fetch           000076 constant        entry                    external dcl 89 ref 204
lib_error_list_                 000100 constant        entry                    external dcl 89 ref 544 545 550
lib_next_name_                  000102 constant        entry                    external dcl 89 ref 369 392
lib_node_path_                  000104 constant        entry                    external dcl 89 ref 251
lib_output_node_list_$info      000106 constant        entry                    external dcl 89 ref 441
lib_ptr_and_bc_                 000110 constant        entry                    external dcl 89 ref 267 351
lib_sort_tree_$make_name_list   000112 constant        entry                    external dcl 89 ref 215
library                                based           structure                level 1 dcl 3-22
line_length              23            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 169*
line_no                  24            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 170* 560*
link_error_output               000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 253 260*
long                      0(32)        based           bit(1)                   level 2 packed unaligned dcl 8-20 ref 408
max_entries                            constant        fixed bin(17,0)          initial dcl 5-19 ref 209 209 209 209 209 209
min                                                    builtin function         dcl 85 ref 512
modes                    10     000121 automatic       bit(36)                  level 2 packed unaligned dcl 25 set ref 304*
msa_manager_$area_handler       000114 constant        entry                    external dcl 89 ref 200 200
msf                       0(04) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 322* 465
msf_comp                        000342 automatic       fixed bin(24,0)          dcl 25 set ref 266* 267* 336 338 342 351*
msf_manager_$close              000122 constant        entry                    external dcl 89 ref 353 465
msf_manager_$get_ptr            000120 constant        entry                    external dcl 89 ref 336
msf_manager_$open               000116 constant        entry                    external dcl 89 ref 324
name_list                              based           structure                level 1 dcl 5-19 set ref 209
names                     5            based           char(32)                 array level 2 packed unaligned dcl 6-230 set ref
                                                                                  387* 398*
nd_handler_                     000124 constant        entry                    external dcl 89 ref 381
nd_result                       000343 automatic       fixed bin(35,0)          dcl 25 set ref 381* 382 384
no_action                 0(05) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 25 set ref 370* 384*
                                                                                  398
node                                   based           structure                level 1 unaligned dcl 6-69
node_list                              based           structure                level 1 dcl 5-19 set ref 209
node_name                       000344 automatic       char(32)                 unaligned dcl 25 set ref 369* 372 373* 375* 392*
node_type                       000016 constant        varying char(32)         initial array dcl 6-374 set ref 272* 409*
null                                                   builtin function         dcl 85 ref 164 172 173 174 175 202 262 274 287 314
                                                                                  317 335 337 354 361 402 453 455 460 463 465 469
                                                                                  484
object_info               1(01)        based           bit(1)                   level 2 packed unaligned dcl 6-343 ref 300
on_unit                         000164 constant        bit(1)                   initial dcl 128 set ref 177*
output_file             232            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lib_fetch_" set ref 180 180 180 185*
                                                                                  185 186 494* 500*
output_file               0(33)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lib_fetch_" ref 179 423
page_length              20            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 166*
page_no                  22            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 168* 559* 559
page_text_length         21            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 167*
program                   1            based           varying char(32)         level 2 dcl 1-23 set ref 253* 257* 269* 272* 288*
                                                                                  308* 327* 338* 356 375* 381 387* 398* 401 471 494*
                                                                                  500* 500* 508* 515* 518* 522* 522* 530* 535* 539*
                                                                                  544* 545* 547* 550*
progress                        000354 automatic       fixed bin(17,0)          initial dcl 25 set ref 25* 204* 512* 512 514
put_error                16            based           entry variable           level 2 dcl 1-23 ref 253 257 269 272 288 308 327 338
                                                                                  375 387 398 494 500 508 515 518 522 530 535 539
                                                                                  547
release_system_msa_             000126 constant        entry                    external dcl 89 ref 453
starname                               based           structure                level 1 dcl 3-32 set ref 441 441
state                           000355 automatic       char(16)                 unaligned dcl 25 set ref 483* 486* 489* 492* 494*
                                                                                  527* 529* 530* 530*
stream_output                   000020 internal static fixed bin(17,0)          initial dcl 128 set ref 189*
string                                                 builtin function         dcl 85 set ref 176*
substr                                                 builtin function         dcl 85 ref 180 193 193
target_name                     000361 automatic       char(32)                 unaligned dcl 25 set ref 196* 373* 379* 381* 382*
                                                                                  387* 410*
unique_chars_                   000130 constant        entry                    external dcl 89 ref 249
unique_name                     000371 automatic       char(32)                 unaligned dcl 25 set ref 249* 282* 288* 307* 308*
                                                                                  324* 327* 338* 356* 379* 382* 387* 396* 396* 401*
                                                                                  471*
version                                based           fixed bin(17,0)          level 2 dcl 4-3 set ref 162*
zero_pad                 11     000121 automatic       bit(36)                  level 2 packed unaligned dcl 25 set ref 305*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 6-146
Dacl                                   based           structure                level 1 unaligned dcl 6-153
Ddir_acl                               based           structure                level 1 unaligned dcl 6-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 6-190
Diacl                                  based           structure                level 1 unaligned dcl 6-209
Dnodes                                 based           structure                level 1 unaligned dcl 6-245
Dobj                                   based           structure                level 1 unaligned dcl 6-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 6-311
Duser                                  based           structure                level 1 unaligned dcl 6-324
EXCLUDE                                automatic       structure                level 1 dcl 2-38
LIBRARY                                automatic       structure                level 1 dcl 2-22
Luser                                  automatic       fixed bin(17,0)          dcl 6-324
Nacls                                  automatic       fixed bin(17,0)          dcl 6-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 6-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 6-190
Niacls                                 automatic       fixed bin(17,0)          dcl 6-209
Nnames                                 automatic       fixed bin(17,0)          dcl 6-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 6-245
PD                                     automatic       pointer                  dcl 6-146
PDacl                                  automatic       pointer                  dcl 6-153
PDdir_acl                              automatic       pointer                  dcl 6-172
PDdir_iacl                             automatic       pointer                  dcl 6-190
PDiacl                                 automatic       pointer                  dcl 6-209
PDnodes                                automatic       pointer                  dcl 6-245
PDobj                                  automatic       pointer                  dcl 6-263
PDsearch_proc                          automatic       pointer                  dcl 6-311
PDuser                                 automatic       pointer                  dcl 6-324
Ppage_list                             automatic       pointer                  dcl 5-19
S                                      based           structure                level 1 dcl 7-96
Sc_allowed                             based           structure                level 1 dcl 1-51
Sc_init                                based           structure                level 1 dcl 1-53
Sreq                                   based           structure                level 1 dcl 6-343
Sreq_allowed                           based           structure                level 1 dcl 1-47
Sreq_init                              based           structure                level 1 dcl 1-49
Tacl                                   internal static fixed bin(17,0)          initial dcl 6-153
Tarchive                               internal static fixed bin(17,0)          initial dcl 6-358
Tarchive_comp                          internal static fixed bin(17,0)          initial dcl 6-358
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 6-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 6-190
Tdirectory                             internal static fixed bin(17,0)          initial dcl 6-358
Tiacl                                  internal static fixed bin(17,0)          initial dcl 6-209
Tmsf                                   internal static fixed bin(17,0)          initial dcl 6-358
Tmsf_comp                              internal static fixed bin(17,0)          initial dcl 6-358
Tnodes                                 internal static fixed bin(17,0)          initial dcl 6-245
Tobj                                   internal static fixed bin(17,0)          initial dcl 6-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 6-311
Tsegment                               internal static fixed bin(17,0)          initial dcl 6-358
Tuser                                  internal static fixed bin(17,0)          initial dcl 6-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 6-153
Varg_struc_1                           internal static fixed bin(17,0)          initial dcl 1-55
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 6-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 6-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 6-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 6-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 6-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 6-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 6-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 6-324
brief_node_type                        internal static varying char(12)         initial array dcl 6-374
exclude                                based           structure                level 1 dcl 3-42
link_node                              based           structure                level 1 unaligned dcl 6-30
page_list                              based           structure                level 1 dcl 5-19

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_ATTACH                      004402 constant        label                    dcl 481 ref 183 188
BAD_CLOSE                       004414 constant        label                    dcl 486 ref 457
BAD_DETACH                      004420 constant        label                    dcl 489 ref 461
BAD_INTO                        004541 constant        label                    dcl 508 ref 195 198
BAD_IO                          004427 constant        label                    dcl 494 set ref 485 488 491
BAD_OPEN                        004424 constant        label                    dcl 492 set ref 190
BAD_S                           000006 constant        label                    array(0:7) dcl 515 ref 514
BAD_SEARCH                      004600 constant        label                    dcl 512 set ref 207
COPY                            000000 constant        label                    array(6) dcl 282 ref 278 280
DETACH                          004366 constant        label                    dcl 445 ref 498 517 521 526 534 537 546 551
JOIN                            003140 constant        label                    dcl 366 ref 320 364
MULTIPLE_ATTACH                 004473 constant        label                    dcl 500 ref 481
NEXT_NAME                       003501 constant        label                    dcl 392 ref 377
NEXT_NODE                       003773 constant        label                    dcl 414 ref 264 276 318 362 403
NO_DEFAULT_NAMES                004735 constant        label                    dcl 530 set ref 528
NO_MATCH                        005026 constant        label                    dcl 539 ref 216
TERM_ENT                        002500 constant        label                    dcl 313 ref 294
TERM_MSF                        003036 constant        label                    dcl 353 ref 333 344
janitor                         005206 constant        entry                    internal dcl 449 ref 177 446
lib_fetch_                      001065 constant        entry                    external dcl 19
no_end_page                     005450 constant        entry                    internal dcl 557 ref 165

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6216        6370    5474        6226
Length      7034    5474       152         427     522          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_fetch_                         9436 external procedure  is an external procedure.  
on unit on line 177                  70 on unit               
janitor                              96 internal procedure  is called by several nonquick procedures.  
no_end_page                          64 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 group_id                    lib_fetch_
000020 stream_output               lib_fetch_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_fetch_               000100 Iname                       lib_fetch_
                         000101 Lcopy                       lib_fetch_
                         000102 Nentries_fetched            lib_fetch_
                         000104 Parea                       lib_fetch_
                         000106 Pcopy                       lib_fetch_
                         000110 Pent                        lib_fetch_
                         000112 Pmsf_fcb                    lib_fetch_
                         000114 Ptarget_node                lib_fetch_
                         000116 Ptree                       lib_fetch_
                         000120 S_                          lib_fetch_
                         000121 acl                         lib_fetch_
                         000134 bc                          lib_fetch_
                         000136 clock                       lib_fetch_
                         000140 code                        lib_fetch_
                         000141 date                        lib_fetch_
                         000145 dir                         lib_fetch_
                         000220 ent                         lib_fetch_
                         000232 fcb_temp                    lib_fetch_
                         000257 i                           lib_fetch_
                         000260 into_dir                    lib_fetch_
                         000332 into_ent                    lib_fetch_
                         000342 msf_comp                    lib_fetch_
                         000343 nd_result                   lib_fetch_
                         000344 node_name                   lib_fetch_
                         000354 progress                    lib_fetch_
                         000355 state                       lib_fetch_
                         000361 target_name                 lib_fetch_
                         000371 unique_name                 lib_fetch_
                         000410 STARNAME                    lib_fetch_
                         022062 Pfcb                        lib_fetch_
                         022064 Pindex_list                 lib_fetch_
                         022066 Pname_list                  lib_fetch_
                         022070 Pnode_list                  lib_fetch_
                         022072 Pnode                       lib_fetch_
                         022074 PDnames                     lib_fetch_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ge_a              alloc_cs            cat_realloc_cs      call_var_desc       call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              tra_ext             enable              shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        condition_                    date_time_                    delete_$path
expand_path_                  get_equal_name_               get_group_id_                 get_group_id_$tag_star
get_system_msa_               hcs_$add_acl_entries          hcs_$chname_file              hcs_$make_seg
hcs_$set_bc_seg               hcs_$terminate_noname         ioa_                          ioa_$ioa_switch
iox_$attach_ioname            iox_$close                    iox_$detach_iocb              iox_$open
lib_array_list_               lib_descriptor_$fetch         lib_error_list_               lib_next_name_
lib_node_path_                lib_output_node_list_$info    lib_ptr_and_bc_               lib_sort_tree_$make_name_list
msa_manager_$area_handler     msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
nd_handler_                   release_system_msa_           smart_alloc_                  unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$entlong          error_table_$longeql
error_table_$namedup          error_table_$noentry          error_table_$not_detached     error_table_$not_done
error_table_$not_open




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     19 001057        25 001072       159 001073       161 001075       162 001077       163 001101       164 001104
    165 001106       166 001111       167 001113       168 001114       169 001116       170 001120       172 001122
    173 001124       174 001125       175 001126       176 001127       177 001131       179 001155       180 001161
    182 001200       183 001203       185 001204       186 001216       188 001271       189 001274       190 001314
    193 001316       195 001350       196 001352       197 001401       198 001406       200 001410       202 001432
    204 001452       207 001506       209 001510       212 001573       213 001575       214 001577       215 001601
    216 001620       217 001622       218 001633       219 001635       247 001637       248 001640       249 001651
    250 001671       251 001677       252 001712       253 001721       257 001764       260 002021       262 002023
    263 002031       264 002034       266 002035       267 002036       268 002057       269 002061       272 002122
    274 002163       275 002171       276 002174       278 002175       280 002203       282 002204       287 002243
    288 002247       292 002310       293 002312       294 002315       296 002316       297 002320       298 002324
    299 002331       300 002344       301 002350       302 002353       303 002372       304 002375       305 002377
    307 002400       308 002435       313 002500       314 002511       315 002513       316 002516       317 002520
    318 002526       320 002527       322 002530       324 002532       325 002557       327 002564       331 002625
    332 002627       333 002632       335 002633       336 002640       337 002665       338 002671       341 002741
    342 002743       343 002750       344 002753       346 002754       347 002756       348 002762       349 002767
    350 003002       351 003014       352 003035       353 003036       354 003045       355 003047       356 003052
    357 003120       359 003123       360 003126       361 003130       362 003136       364 003137       366 003140
    367 003150       368 003153       369 003154       370 003175       372 003177       373 003204       374 003227
    375 003231       377 003266       379 003267       380 003317       381 003323       382 003362       384 003416
    385 003423       386 003424       387 003426       390 003476       392 003501       393 003522       395 003523
    396 003525       397 003554       398 003556       401 003616       402 003664       403 003673       406 003674
    408 003675       409 003701       410 003734       414 003773       422 003775       423 003777       424 004004
    426 004005       427 004014       428 004031       430 004056       431 004103       432 004130       433 004164
    434 004214       436 004243       437 004264       439 004313       441 004334       445 004366       446 004373
    447 004401       481 004402       483 004405       484 004410       485 004413       486 004414       488 004417
    489 004420       491 004423       492 004424       494 004427       498 004472       500 004473       505 004535
    506 004540       508 004541       509 004574       510 004577       512 004600       514 004605       515 004606
    517 004634       518 004635       521 004667       522 004670       526 004725       527 004726       528 004731
    529 004732       530 004735       534 004776       535 004777       537 005025       539 005026       544 005060
    545 005103       546 005126       547 005127       550 005161       551 005204       449 005205       453 005213
    455 005232       456 005240       457 005251       459 005267       460 005302       461 005306       463 005320
    465 005336       468 005355       469 005356       471 005373       474 005445       557 005447       559 005455
    560 005460       562 005462


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
