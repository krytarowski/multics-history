	COMPILATION LISTING OF SEGMENT read_cards_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/15/89  0833.5 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* format: style2 */
       11 
       12 read_cards_:
       13      proc (root, stream_info_ptr, error_stream, test, a_code);
       14 
       15 /* Standard card input procedure for Bulk card input and Remote Job Entry */
       16 
       17 /* Modified Oct. 1977 by DRV to add new control card formats and RJE function */
       18 /* Modified Jan. 1978 by J. C. Whitmore for minor bug fixes and to restore deletion of aborted decks */
       19 /* Modified 5/78 by DRV to change calling sequence to validate_card_input_ for card input password changing */
       20 /* Modified 12/78 by DRV for general bug fixes */
       21 /* Modified by J. C. Whitmore, 3/79, for several gross bug fixes */
       22 /* Modified by J. C. Whitmore, 5/79, to fix the blank password bug */
       23 /* Modified by J. C. Whitmore, 3/80, to allow 2 EOF records between decks (for HASP) */
       24 /* Modified: 8 October 1981 by G. Palter to bypass the "classic" segment to MSF conversion problem */
       25 /* Modified 1984-08-16 by E. Swenson for Version 2 PNTs. */
       26 /* Modified 1984-12-27 by Keith Loepere for version 2 create_branch_info. */
       27 /* Modified: 03 March 1985 by C. Marker to fix problem where the use of AF brackets or semicolons on the ++RJECONTROL and ++RJEARGS could cause the Multics server to execute random commands. */
       28 
       29 	dcl     error_stream	 char (*);	/*  message stream for the caller */
       30 	dcl     a_prt_rqt		 char (*);
       31 	dcl     a_station		 char (*);
       32 	dcl     root		 char (*);	/*  card_pool_root directory */
       33 	dcl     test		 bit (1);		/*  =1 if in test mode */
       34 	dcl     a_code		 fixed bin (35);
       35 	dcl     a_pun_rqt		 char (*);
       36 
       37 	dcl     absin_ename		 char (32);
       38 	dcl     absin_online	 bit (1);
       39 	dcl     absin_pname		 char (168) var;
       40 	dcl     absout_pname	 char (168) var;
       41 	dcl     password		 char (8);
       42 	dcl     new_password	 char (8);
       43 	dcl     temp_password	 char (8);
       44 	dcl     aclec		 fixed bin;
       45 	dcl     add_nl		 bit (1);
       46 	dcl     aim_string		 char (720) var;
       47 	dcl     bc		 fixed bin (24);	/*  bit count of seg */
       48 	dcl     cancel_rje		 bit (1);
       49 	dcl     card_buffer		 char (100) aligned;/* read buffer for character input */
       50 	dcl     card_image		 char (160) var;
       51 	dcl     output_string	 char (string_len) based (deckp);
       52 	dcl     string_len		 fixed bin;
       53 	dcl     deck_char_pos	 (200) char (1) based (deckp);
       54 						/* actually only 80 will be used at a time */
       55 	dcl     remaining_chars	 fixed bin (24);
       56 	dcl     left		 fixed bin (24);
       57 	dcl     code		 fixed bin (35);
       58 	dcl     command		 char (1000) var;
       59 	dcl     component		 fixed bin;
       60 	dcl     contin		 bit (1);
       61 	dcl     control_iocbp	 ptr;
       62 	dcl     deck_auth		 bit (72);
       63 	dcl     deck_format		 char (12);	/* requested format form control card */
       64 	dcl     deck_name		 char (32) var;	/*  user supplied name of deck(truncated to 32 chars) */
       65 	dcl     deck_name_prefix	 char (32) var;
       66 	dcl     deckp		 ptr;
       67 	dcl     dirname		 char (168);	/*  pathname of personid directory in pool */
       68 	dcl     done		 bit (1);
       69 	dcl     element_size	 fixed bin;	/* element size for deck format */
       70 	dcl     epilogue_string	 char (256) var;
       71 	dcl     error_iocbp		 ptr;
       72 	dcl     error_msg		 char (132);	/*  message from validate_card_input_ */
       73 	dcl     fcbp		 ptr;
       74 	dcl     field		 (40) char (80) var;
       75 	dcl     field_begin		 fixed bin;
       76 	dcl     field_cnt		 fixed bin;
       77 	dcl     field_len		 fixed bin;
       78 	dcl     header_len		 fixed bin;
       79 	dcl     header_string	 char (600) var;
       80 	dcl     i			 fixed bin;
       81 	dcl     ignore		 fixed bin (35);
       82 	dcl     input_iocbp		 ptr;
       83 	dcl     input_modes		 char (256);
       84 	dcl     input_mode_bits	 bit (36);
       85 	dcl     control_mode_bits	 bit (36);
       86 	dcl     j			 fixed bin;
       87 	dcl     k			 fixed bin;
       88 	dcl     key		 char (32) var;
       89 	dcl     lnd		 fixed bin;	/*  length of new_deck_name with tag */
       90 	dcl     long		 char (100);	/*  space to expand an error_table_ code */
       91 	dcl     lower_case		 bit (1);
       92 	dcl     mode		 fixed bin;
       93 	dcl     nel		 fixed bin (24);
       94 	dcl     nelt		 fixed bin (24);	/*  number of elements transmitted */
       95 	dcl     num_chars_rec	 fixed bin (24);
       96 	dcl     new_deck_name	 char (32);	/*  internal name of deck */
       97 	dcl     overwrite		 bit (1);
       98 	dcl     person		 char (32);	/* person part of personid */
       99 	dcl     personid		 char (32);
      100 	dcl     pool_open		 bit (1);
      101 	dcl     proc_auth		 bit (72);	/*  access class of the process */
      102 	dcl     project		 char (32);	/* and the project part */
      103 	dcl     rje_arg_string	 char (256) var;
      104 	dcl     rje_control_string	 char (256) var;
      105 	dcl     scan_done		 bit (1);
      106 	dcl     prior_read_aborted	 bit (1);		/* flag to attempt to sync control  cards */
      107 	dcl     short		 char (8);	/*  dummy for convert_status_code_ */
      108 	dcl     string		 char (160) var;
      109 	dcl     tag		 fixed bin;	/*  dupe deck counter */
      110 	dcl     trailer_len		 fixed bin;
      111 	dcl     trailer_string	 char (600) var;
      112 	dcl     trim		 bit (1);
      113 	dcl     uid		 char (32) var;	/*  unique ID from first and last cards */
      114 
      115 	dcl     (record_quota_overflow, card_command_level, cleanup, command_error, out_of_bounds)
      116 				 condition;
      117 	dcl     any_other		 condition;
      118 
      119 	dcl     1 header		 aligned,
      120 		2 system_lines	 (6) char (80) var
      121 				 init ("&command_line off", "rdf;rje_args$set  prt_rqt", "rje_args$set  pun_rqt",
      122 				 "rje_args$set station", "&command_line on",
      123 				 "set_epilogue_command ""dp -dl -rqt [rje_args prt_rqt] [user absout]"";rdn"),
      124 		2 user_lines	 (1) char (120) var init ("");
      125 
      126 	dcl     1 trailer		 aligned,
      127 		2 system_lines	 (1) char (80) var init ("logout"),
      128 		2 user_lines	 (1) char (120) var init ("");
      129 
      130 
      131 	dcl     1 count_structure	 aligned,		/* structure used for the get_count control order */
      132 		2 line		 fixed bin,	/* most fields are pads, because this structure */
      133 		2 page_len	 fixed bin,	/* is based on the printer defined structure */
      134 		2 lmarg		 fixed bin,	/* shown in prt_order_info.incl.pl1 */
      135 		2 rmarg		 fixed bin,
      136 		2 cards		 fixed bin (35),	/* this is the normal line count field */
      137 		2 page_count	 fixed bin;
      138 
      139 
      140 	dcl     1 cond_info		 aligned,
  1     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  1     2*	   coded by M. Weaver 12 July 1973 */
  1     3 
  1     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  1     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  1     6 	  2 condition_name char(32) var,		/* name of condition */
  1     7 	  2 infoptr ptr,				/* ptr to software info structure */
  1     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  1     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  1    10 	  2 flags aligned,
  1    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  1    12 	    3 pad1 bit(35) unal,
  1    13 	  2 pad_word bit(36) aligned,
  1    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  1    15 	  2 pad (4) bit(36) aligned;
  1    16 
  1    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      141 
      142 
      143 	dcl     1 command_error_info	 aligned based (cond_info.infoptr),
  2     1 
  2     2 	/* begin include file ... cond_info_structure.incl.pl1 */
  2     3 	/* last modified 5/7/73 */
  2     4 
  2     5 	  2 length fixed bin,			/* length in words of this structure */
  2     6 	  2 version fixed bin,		/* version number of this structure */
  2     7 	  2 action_flags aligned,		/* tell handler how to proceed */
  2     8 	    3 cant_restart bit(1) unal,	/* caller doesn't ever want to be returned to */
  2     9 	    3 default_restart bit(1) unal,	/* caller can be returned to with no further action */
  2    10 	    3 pad bit(34) unal,
  2    11 	  2 info_string char(256) var,	/* may contain printable message */
  2    12 	  2 status_code fixed bin(35),	/* if^=0, code interpretable by com_err_ */
  2    13 	/* end include file ... cond_info_structure.incl.pl1 */
      144 
      145 	2 name_ptr ptr, 2 name_lth fixed bin, 2 errmess_ptr ptr, 2 errmess_lth fixed bin, 2 max_errmess_lth fixed bin,
      146 	     2 print_sw bit (1);
      147 
      148 	dcl     1 acle		 (2) aligned,	/*  ACL entry */
      149 		2 name		 char (32),
      150 		2 mode		 bit (36),
      151 		2 pad		 bit (36),
      152 		2 code		 fixed bin (35);
      153 
      154 	dcl     control_modes	 char (32) int static init ("^add_nl,lower_case,^trim.") options (constant);
      155 	dcl     tools_dir		 char (32) var int static init (">system_library_tools") options (constant);
      156 	dcl     space		 char (1) int static init (" ") options (constant);
      157 	dcl     NL		 char (1) int static options (constant) init ("
      158 ");
      159 
      160 dcl SPECIAL_CHARACTERS char (8) static init ("()[];
      161 ") options (constant);
      162 	dcl     tell_user		 bit (1) int static init ("1"b) options (constant);
      163 
      164 	dcl     silent		 bit (1) int static init ("0"b) options (constant);
      165 	dcl     data		 fixed bin int static init (1);
      166 	dcl     rje		 fixed bin int static init (2);
      167 	dcl     prt_rqt		 char (32) var init ("printer") int static;
      168 	dcl     pun_rqt		 char (32) var init ("punch") int static;
      169 	dcl     station		 char (32) var int static init ("reader");
      170 
      171 	dcl     error_message	 char (command_error_info.errmess_lth) based (command_error_info.errmess_ptr);
      172 
      173 	dcl     1 local_cbi		 aligned like create_branch_info auto;
      174 
      175 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      176 	dcl     error_table_$short_record
      177 				 ext fixed bin (35);
      178 	dcl     error_table_$end_of_info
      179 				 fixed bin (35) ext;
      180 	dcl     error_table_$ai_restricted
      181 				 ext static fixed bin (35);
      182 	dcl     error_table_$eof_record
      183 				 ext fixed bin (35);
      184 	dcl     error_table_$namedup	 ext static fixed bin (35);
      185 
      186 	dcl     card_util_$modes	 entry (char (*), bit (36), char (*), fixed bin (35));
      187 	dcl     card_util_$translate	 entry (bit (36), char (*) var);
      188 	dcl     continue_to_signal_	 entry (fixed bin (35));
      189 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      190 	dcl     scramble_		 entry (char (8)) returns (char (8));
      191 	dcl     send_mail_		 entry (char (*), char (*), ptr, fixed bin (35));
      192 	dcl     validate_card_input_$user
      193 				 entry (char (*), char (*), char (*), char (*), char (*), fixed bin, char (*),
      194 				 fixed bin (35));
      195 	dcl     suffixed_name_$make	 entry (char (*), char (*), char (*), fixed bin (35));
      196 	dcl     msf_manager_$adjust	 entry (ptr, fixed bin, fixed bin (24), bit (3), fixed bin (35));
      197 	dcl     aim_check_$equal	 entry (bit (72), bit (72)) returns (bit (1));
      198 	dcl     convert_status_code_	 entry (fixed bin (35), char (8), char (100));
      199 	dcl     convert_authorization_$from_string
      200 				 entry (bit (72), char (*), fixed bin (35));
      201 	dcl     cu_$cp		 entry (ptr, fixed bin, fixed bin (35));
      202 	dcl     cu_$level_get	 entry returns (fixed bin);
      203 	dcl     delete_$path	 entry (char (*), char (*), bit (6), char (*), fixed bin (35));
      204 	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
      205 	dcl     get_authorization_	 entry returns (bit (72));
      206 	dcl     get_group_id_	 entry returns (char (32));
      207 	dcl     get_group_id_$tag_star entry returns (char (32));
      208 	dcl     msf_manager_$close	 entry (ptr);
      209 	dcl     msf_manager_$open	 entry (char (*), char (*), ptr, fixed bin (35));
      210 	dcl     msf_manager_$get_ptr	 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      211 	dcl     msf_manager_$acl_add	 entry (ptr, ptr, fixed bin, fixed bin (35));
      212 	dcl     hcs_$create_branch_	 entry (char (*), char (*), ptr, fixed bin (35));
      213 	dcl     ioa_$ioa_stream	 entry options (variable);
      214 	dcl     ioa_$rsnnl		 entry options (variable);
      215 	dcl     iox_$get_chars	 entry (ptr, ptr, fixed bin (24), fixed bin (24), fixed bin (35));
      216 	dcl     iox_$look_iocb	 entry (char (*) aligned, ptr, fixed bin (35));
      217 	dcl     iox_$control	 entry (ptr, char (*) aligned, ptr, fixed bin (35));
      218 	dcl     pool_manager_$add_quota
      219 				 entry (char (*), fixed bin, fixed bin (35));
      220 	dcl     pool_manager_$close_user_pool
      221 				 entry (char (*), char (*), fixed bin, bit (36), fixed bin (35));
      222 	dcl     pool_manager_$open_user_pool
      223 				 entry (char (*), char (*), char (*), fixed bin (35));
      224 
      225 	dcl     (addr, null, index, substr, verify, length, addrel, multiply, hbound, divide)
      226 				 builtin;
      227 	dcl     (rtrim, before, after, unspec, search, ltrim)
      228 				 builtin;
      229 
  3     1 /* BEGIN INCLUDE FILE ... card_stream_info.incl.pl1 */
  3     2 
  3     3 /* This is the info structure passed to read_cards_ which defines the data streams
  3     4*   used to interpret user card decks according to the Multics card input facility. */
  3     5 
  3     6 dcl  stream_info_ptr ptr;
  3     7 
  3     8 dcl 1 card_stream_info aligned based (stream_info_ptr),
  3     9     2 control_stream char (32),			/* stream used for control card reading */
  3    10     2 n_streams fixed bin,				/* number of data streams active in the list */
  3    11     2 data_streams (5),				/* array of streams for different card formats */
  3    12       3 format char (12),				/* name of the stream format (e.g. mcc, raw) */
  3    13       3 name char (32),				/* name of the stream as attached */
  3    14       3 el_size fixed bin;				/* element size for the stream */
  3    15 
  3    16 /* END INCLUDE FILE ... card_stream_info.incl.pl1 */
      230 
      231 
  4     1 /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  4     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  4     7*       1. Declare version constant properly.
  4     8*       2. Remove version 1 since it was never referenced and to force
  4     9*          callers to upgrade their programs.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  4    14 
  4    15 /* this include files gives the argument structure for create_branch_ */
  4    16 
  4    17 dcl 1 create_branch_info aligned based,
  4    18     2 version fixed bin,				/* set this to the largest value given below */
  4    19     2 switches unaligned,
  4    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  4    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  4    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  4    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  4    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  4    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  4    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  4    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  4    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  4    29     2 userid char (32),				/* user's access control name */
  4    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  4    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  4    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  4    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  4    34 
  4    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  4    36 
  4    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  4    38 
      232 
      233 
  5     1 /*  BEGIN  send_mail_info include file */
  5     2 
  5     3 dcl send_mail_info_version_2 fixed bin init(2);
  5     4 
  5     5 dcl 1 send_mail_info aligned,
  5     6      2 version fixed bin,  /* = 2 */
  5     7      2 sent_from char(32) aligned,
  5     8      2 switches,
  5     9       3 wakeup bit(1) unal,
  5    10       3 mbz1 bit(1) unal,
  5    11       3 always_add bit(1) unal,
  5    12       3 never_add bit(1) unal,
  5    13       3 notify bit(1) unal,
  5    14       3 acknowledge bit(1) unal,
  5    15       3 mbz bit(30) unal;
  5    16 
  5    17 /*  END  send_mail_info include file */
      234 
      235 
      236 	unspec (send_mail_info) = "0"b;
      237 	send_mail_info.version = send_mail_info_version_2;
      238 	send_mail_info.sent_from = station;
      239 	send_mail_info.wakeup = "1"b;
      240 	send_mail_info.always_add = "1"b;
      241 	send_mail_info.never_add = "0"b;
      242 	send_mail_info.notify = "0"b;
      243 	send_mail_info.acknowledge = "0"b;		/* process arguments */
      244 	call init;
      245 	proc_auth = get_authorization_ ();		/*  get caller's authorization */
      246 
      247 	on record_quota_overflow call overflow_handler;
      248 
      249 	on command_error
      250 	     begin;
      251 		call find_condition_info_ (null, addr (cond_info), (0));
      252 		if before (error_message, ":") = "enter_abs_request"
      253 		then do;
      254 			call notify_user ("Unable to submit RJE request: " || after (error_message, ":"));
      255 			call ioa_$ioa_stream (error_stream, "^a", error_message);
      256 			call report ("Unable to submit RJE request.", silent);
      257 						/* don't give message twice */
      258 			call clean_up;
      259 			call iox_$control (error_iocbp, "runout", null, code);
      260 						/* be sure operator sees any messages */
      261 			go to start;		/* get back in sync */
      262 		     end;
      263 		else call continue_to_signal_ (0);
      264 	     end;
      265 
      266 	on cleanup
      267 	     begin;
      268 		code = 0;
      269 		call report ("Aborting card input. Clear the hopper before continuing.", silent);
      270 						/* don't tell user */
      271 		call clean_up;			/* delete any partial input */
      272 	     end;
      273 
      274 	call iox_$look_iocb (card_stream_info.control_stream, control_iocbp, code);
      275 	if code ^= 0
      276 	then call abort ("Unable to find control iocbp.");
      277 	call iox_$look_iocb ((error_stream), error_iocbp, code);
      278 	if code ^= 0
      279 	then call abort ("Unable to find error iocbp.");
      280 
      281 	call card_util_$modes (control_modes, control_mode_bits, "", code);
      282 	if code ^= 0
      283 	then call abort ("Unable to set modes on control stream.");
      284 
      285 start:
      286 	call init;
      287 
      288 	call read_control_card;
      289 	if code ^= error_table_$eof_record
      290 	then do;					/*  not an EOF?  not nice */
      291 		call abort_read ("Deck must begin with ++EOF card.", silent);
      292 	     end;
      293 read_uid:
      294 	call read_control_card;
      295 	if code = error_table_$eof_record
      296 	then do;					/* an EOF? */
      297 		call read_control_card;		/* allow 2 in a row */
      298 		if code = error_table_$eof_record
      299 		then do;				/* but no more */
      300 			call ioa_$ioa_stream (error_stream, "Unexpected ++EOF card. Check deck format.");
      301 			goto finale;
      302 		     end;
      303 	     end;
      304 	if key = "++uid"
      305 	then do;
      306 		uid = field (1);
      307 		if uid = ""
      308 		then call abort_read ("Blank field in ++UID card.", silent);
      309 	     end;
      310 	else call abort_read ("++UID card expected.", silent);
      311 
      312 	call read_control_card;
      313 	if code = error_table_$eof_record
      314 	then do;
      315 		if prior_read_aborted
      316 		then goto read_uid;			/* when out of sync, this is probably the next deck */
      317 		call abort_read ("++EOF card found among control cards. Aborting deck.", silent);
      318 
      319 	     end;
      320 	call ioa_$ioa_stream (error_stream, "*Begin deck*");
      321 
      322 	if key = "++data"
      323 	then do;
      324 		mode = data;
      325 		call parse_first_card ("++DATA");
      326 		personid = rtrim (person) || "." || rtrim (project);
      327 		call check_card_input_password;
      328 		done = "0"b;
      329 		do while (^done);
      330 		     call read_control_card;
      331 		     if code = error_table_$eof_record
      332 		     then call abort_read ("Unexpected ++EOF card among control cards.", tell_user);
      333 		     if key = "++format"
      334 		     then call parse_format_card;
      335 		     else if key = "++aim"
      336 		     then aim_string = aim_string || string;
      337 		     else if key = "++control"
      338 		     then do;
      339 			     if field (1) = "overwrite" & password ^= ""
      340 			     then overwrite = "1"b;
      341 			     else call abort_read ("Invalid ++CONTROL card", tell_user);
      342 			end;
      343 		     else if key = "++input"
      344 		     then done = "1"b;
      345 		     else if key = "++data"
      346 		     then call abort_read ("Out of sequence ++DATA card", tell_user);
      347 		     else call abort_read ("Unrecognized control card key: " || key, tell_user);
      348 		end;
      349 	     end;
      350 	else if key = "++rje"
      351 	then do;
      352 		mode = rje;
      353 		call parse_first_card ("++RJE");
      354 		if substr (deck_name, length (deck_name) - 6) = ".absin"
      355 		then deck_name = substr (deck_name, 1, length (deck_name) - 6);
      356 		personid = rtrim (person) || "." || rtrim (project);
      357 		call check_card_input_password;
      358 		rje_arg_string = "-arguments";
      359 		rje_control_string = "-proxy " || rtrim (personid) || " -sender " || rtrim (station);
      360 		done = "0"b;
      361 		do while (^done);
      362 		     call read_control_card;
      363 		     if code = error_table_$eof_record
      364 		     then call abort_read ("Unexpected ++EOF card among control cards.", tell_user);
      365 		     if key = "++aim"
      366 		     then aim_string = aim_string || string;
      367 		     else if key = "++rjeargs"
      368 		     then rje_arg_string = rje_arg_string || space || string;
      369 		     else if key = "++rjecontrol"
      370 		     then rje_control_string = rje_control_string || space || string;
      371 		     else if key = "++format"
      372 		     then call parse_format_card;
      373 		     else if key = "++epilogue"
      374 		     then epilogue_string = epilogue_string || space || string;
      375 		     else if key = "++absin"
      376 		     then do;
      377 			     absin_online = "1"b;
      378 			     if field_cnt < 1 | field_cnt > 2
      379 			     then call abort_read ("Incorrect ++ABSIN card", tell_user);
      380 			     call expand_pathname_ ((field (1)), dirname, absin_ename, code);
      381 			     if code ^= 0
      382 			     then call abort_read ("Unable to decode ++ABSIN segment definition. " || field (1),
      383 				     tell_user);
      384 			     call suffixed_name_$make ((absin_ename), "absin", absin_ename, code);
      385 			     if code ^= 0
      386 			     then call abort_read ("Bad absin name on ++ABSIN card " || field (1), tell_user);
      387 			     if field (2) ^= ""
      388 			     then do;
      389 				     if field (2) = "system"
      390 				     then do;
      391 					     absin_pname = tools_dir || ">" || absin_ename;
      392 					end;
      393 				     else call abort_read ("Invalid option on ++ABSIN card " || field (2),
      394 					     tell_user);
      395 				     call ioa_$rsnnl (">user_dir_dir>^a>^a>^a.absout", absout_pname, 0, project,
      396 					person, before (absin_ename, ".absin"));
      397 				end;
      398 			     else do;
      399 				     if substr (field (1), 1, 1) = ">"
      400 				     then absin_pname = rtrim (dirname) || ">" || absin_ename;
      401 				     else call ioa_$rsnnl (">user_dir_dir>^a>^a>^a", absin_pname, 0, project,
      402 					     person, absin_ename);
      403 				     absout_pname =
      404 					substr (absin_pname, 1, length (rtrim (absin_pname)) - 6) || ".absout";
      405 				end;
      406 			end;
      407 		     else if key = "++input"
      408 		     then done = "1"b;
      409 		     else if key = "++rje"
      410 		     then call abort_read ("Out of sequence ++RJE card", tell_user);
      411 		     else call abort_read ("Unrecognized control card key: " || key, tell_user);
      412 		end;
      413 	     end;
      414 	else call abort_read ("Unexpected control card key: " || key, tell_user);
      415 
      416 	call convert_authorization_$from_string (deck_auth, (aim_string), code);
      417 						/*  and convert the access_class */
      418 	if code ^= 0
      419 	then call abort_read ("Unable to convert deck access class " || aim_string, tell_user);
      420 	if ^aim_check_$equal (proc_auth, deck_auth)
      421 	then do;					/*  wrong level ? */
      422 		a_code = error_table_$ai_restricted;
      423 		return;
      424 	     end;
      425 	if mode = data | mode = rje & ^absin_online
      426 	then do;
      427 		do k = 1 to card_stream_info.n_streams while (card_stream_info.format (k) ^= deck_format);
      428 		end;
      429 		if k > card_stream_info.n_streams
      430 		then call abort_read ("Undefined deck format for this device: " || deck_format, tell_user);
      431 		else do;
      432 			call iox_$look_iocb (card_stream_info.name (k), input_iocbp, code);
      433 			element_size = card_stream_info.el_size (k);
      434 		     end;
      435 
      436 		if mode = rje & element_size ^= 9
      437 		then /* require character input for absin segments */
      438 		     call abort_read ("Invalid conversion format for RJE: " || rtrim (deck_format), tell_user);
      439 
      440 		call pool_manager_$open_user_pool (root, person, dirname, code);
      441 		if code ^= 0
      442 		then /* pool error is very bad */
      443 		     call abort ("Unable to open pool storage.");
      444 		pool_open = "1"b;			/*  be sure we close the pool on error */
      445 
      446 		unspec (local_cbi) = "0"b;
      447 		local_cbi.version = create_branch_version_2;
      448 		local_cbi.mode = "101"b;
      449 		local_cbi.rings (1), local_cbi.rings (2), local_cbi.rings (3) = cu_$level_get ();
      450 		local_cbi.userid = get_group_id_ ();
      451 		local_cbi.access_class = proc_auth;
      452 
      453 		tag, code = -1;
      454 		do while (code ^= 0);
      455 		     tag = tag + 1;			/*  change the name to "name.n" */
      456 		     if tag > 499
      457 		     then /* avoid infinite loop, but try hard */
      458 			call abort_read ("Aborting deck: 500 duplicate decks in " || dirname, tell_user);
      459 		     call ioa_$rsnnl ("^a.^d^[.absin^]", new_deck_name, lnd, deck_name, tag, (mode = rje));
      460 		     if lnd > 32
      461 		     then call abort_read ("Entry name too long: " || substr (new_deck_name, 1, lnd), tell_user);
      462 
      463 		     call hcs_$create_branch_ (dirname, new_deck_name, addr (local_cbi), code);
      464 		     if code = error_table_$namedup & overwrite
      465 		     then code = 0;
      466 		     if code ^= 0 & code ^= error_table_$namedup
      467 		     then /*  also very bad */
      468 			call abort_read ("Unable to create branch in pool: " || new_deck_name, silent);
      469 		end;
      470 		call msf_manager_$open (dirname, new_deck_name, fcbp, code);
      471 		if fcbp = null
      472 		then call abort_read ("Unable to open new pool entry", silent);
      473 		component = 0;
      474 		call msf_manager_$get_ptr (fcbp, component, "0"b, deckp, bc, code);
      475 		if deckp = null
      476 		then call abort_read ("Unable to initiate new pool entry: " || new_deck_name, silent);
      477 		call ioa_$ioa_stream (error_stream, "Reading ^a (^a) for ^a.", new_deck_name, deck_format, personid);
      478 
      479 		if mode = rje
      480 		then do;
      481 			absin_pname = rtrim (dirname) || ">" || new_deck_name;
      482 			deck_name_prefix = substr (new_deck_name, 1, length (rtrim (new_deck_name)) - 6);
      483 			call ioa_$rsnnl (">user_dir_dir>^a>^a>^a.absout", absout_pname, (0), project, person,
      484 			     deck_name_prefix);
      485 			call set_abs_header;
      486 		     end;
      487 		call ioa_$rsnnl ("^[^^^]trim,^[^^^]lower_case,^[^^^]add_nl,^[^^^]contin.", input_modes, (0), ^trim,
      488 		     ^lower_case, ^add_nl, ^contin);
      489 		call card_util_$modes (input_modes, input_mode_bits, "", code);
      490 		if code ^= 0
      491 		then call abort_read ("Unable to set user input modes", tell_user);
      492 
      493 		on out_of_bounds go to oob;
      494 
      495 		call iox_$control (input_iocbp, "reset", null, ignore);
      496 						/* clear the record totals */
      497 		nel = divide ((sys_info$max_seg_size * 36), element_size, 35);
      498 						/* get number of elements in a segment */
      499 
      500 		if element_size ^= 9
      501 		then do;
      502 			call iox_$get_chars (input_iocbp, deckp, nel + 1, nelt, code);
      503 			if code ^= 0
      504 			then do;
      505 				if code = error_table_$eof_record
      506 				then goto end_read_loop;
      507 				else if code = error_table_$end_of_info | code = error_table_$short_record
      508 				then code = 0;
      509 				else call abort_read ("Error while reading user data.  Aborting deck.", silent);
      510 			     end;
      511 			else call abort_read ("Attempted read of more then a segments worth of data succeeded",
      512 				silent);
      513 		     end;
      514 		else do;				/* This group ASSUMES an element size of 9 bits (chars) */
      515 			nelt = header_len;		/* set the number of chars used in last MSF component */
      516 						/* if not RJE, header_len is zero */
      517 			remaining_chars = nel - header_len;
      518 						/* set number of chars remaining in segment */
      519 
      520 read_one_card:
      521 			num_chars_rec = 0;
      522 			card_buffer = "";
      523 			call iox_$get_chars (input_iocbp, addr (card_buffer), 80, num_chars_rec, code);
      524 			if code ^= 0
      525 			then do;
      526 				if code = error_table_$eof_record
      527 				then goto end_read_loop;
      528 						/* NORMAL EXIT */
      529 
      530 				else if code = error_table_$end_of_info | code = error_table_$short_record
      531 				then code = 0;
      532 
      533 				else call abort_read ("Error while reading user data.  Aborting deck.", silent);
      534 						/* ERROR EXIT */
      535 			     end;
      536 
      537 			card_image = substr (card_buffer, 1, num_chars_rec);
      538 						/* put into var string for translation */
      539 
      540 			call card_util_$translate (input_mode_bits, card_image);
      541 			num_chars_rec = length (card_image);
      542 						/* get the new length after translation */
      543 			left = remaining_chars - num_chars_rec;
      544 						/* must be at least 1 char left to bump ptr */
      545 			if left <= 0
      546 			then do;			/* if not enough, put in part and start new component */
      547 				string_len = remaining_chars;
      548 						/* set size of output_string */
      549 				output_string = substr (card_image, 1, remaining_chars);
      550 
      551 				component = component + 1;
      552 						/* start the next MSF component */
      553 
      554 				if component = 1
      555 				then do;		/* about to force conversion to MSF ... */
      556 					call pool_manager_$add_quota (root, 260, code);
      557 						/* ... need extra quota during conversion */
      558 					if code ^= 0
      559 					then do;	/* couldn't get it: let the operator try to correct it ... */
      560 						call report (NL
      561 						     || "Insufficient quota in pool to convert to MSF." || NL,
      562 						     silent);
      563 						signal card_command_level;
      564 						call pool_manager_$add_quota (root, 260, code);
      565 						/* ... and try again */
      566 					     end;
      567 					if code ^= 0
      568 					then call abort_read ("Insufficient quota in pool to convert to MSF.",
      569 						silent);
      570 				     end;
      571 
      572 				call msf_manager_$get_ptr (fcbp, component, "1"b, deckp, bc, code);
      573 				if deckp = null
      574 				then call abort_read ("Unable to initiate next MSF component", silent);
      575 
      576 				if component = 1
      577 				then /* give back the quota we got temporarily */
      578 				     call pool_manager_$add_quota (root, -260, (0));
      579 
      580 				if left = 0
      581 				then card_image = "";
      582 						/* if it fit exactly.... */
      583 				else card_image = substr (card_image, remaining_chars + 1);
      584 						/* set image to last part of card */
      585 
      586 				string_len = length (card_image);
      587 						/* set the output_string size */
      588 				output_string = card_image;
      589 				deckp = addr (deck_char_pos (string_len + 1));
      590 						/* where the next char goes */
      591 				remaining_chars = nel - string_len;
      592 						/* room left in this component */
      593 				nelt = string_len;	/* restart last component count */
      594 			     end;
      595 			else do;			/* the full card (+ 1 char) will fit this MSF component */
      596 				string_len = length (card_image);
      597 						/* set the length of output_string */
      598 				output_string = card_image;
      599 						/* and write out the data */
      600 				deckp = addr (deck_char_pos (string_len + 1));
      601 						/* where the next char goes */
      602 				remaining_chars = left;
      603 						/* do the accounting */
      604 				nelt = nelt + string_len;
      605 						/* update the number received */
      606 			     end;
      607 			go to read_one_card;
      608 		     end;
      609 
      610 end_read_loop:
      611 		unspec (count_structure) = ""b;	/* clear the count in case the control order is unknown */
      612 
      613 		call iox_$control (input_iocbp, "get_count", addr (count_structure), ignore);
      614 						/* get the total */
      615 						/* this data can be used for accounting in the future */
      616 
      617 /*	now compute the bitcount of the last component */
      618 
      619 		if mode = rje
      620 		then do;
      621 			call set_abs_trailer;	/* this will modify nelt and maybe component */
      622 		     end;
      623 
      624 		revert out_of_bounds;
      625 
      626 		bc = multiply (nelt, element_size, 24, 0);
      627 
      628 /*	set bitcount of last component ... all others are max_seg_size * 36 */
      629 
      630 		call msf_manager_$adjust (fcbp, component, bc, "111"b, code);
      631 		if code ^= 0
      632 		then call abort_read ("Error setting bit-count.", silent);
      633 
      634 		unspec (acle) = "0"b;
      635 		acle (1).name = rtrim (personid) || ".*";
      636 						/*  set the acl */
      637 		acle (1).mode = "1"b;
      638 		if mode = rje
      639 		then do;
      640 			aclec = 2;
      641 			acle (2).name = get_group_id_$tag_star ();
      642 			acle (2).mode = "1"b;
      643 		     end;
      644 		else aclec = 1;
      645 		call msf_manager_$acl_add (fcbp, addr (acle), aclec, code);
      646 		if code ^= 0
      647 		then call abort_read ("Error setting ACL.", silent);
      648 	     end;
      649 	else do;					/* for rje absin online case */
      650 		call read_control_card;
      651 		if code ^= error_table_$eof_record
      652 		then call abort_read ("Unexpected control card " || key, silent);
      653 	     end;
      654 
      655 	call read_control_card;
      656 	if key ^= "++uid"
      657 	then call abort_read ("Expected ++UID card not found", silent);
      658 	else if uid ^= field (1)
      659 	then call abort_read ("Mismatched ++UID card. Looking for: " || uid, silent);
      660 
      661 	if fcbp ^= null
      662 	then call msf_manager_$close (fcbp);
      663 	fcbp = null;
      664 	if pool_open
      665 	then do;
      666 		call pool_manager_$close_user_pool (root, person, 1, "100"b || (33)"0"b, code);
      667 						/*  close the pool */
      668 		if code ^= 0
      669 		then call abort_read ("Error closing user's pool.", silent);
      670 	     end;
      671 	pool_open = "0"b;				/* all is well */
      672 
      673 	call ioa_$ioa_stream (error_stream, "*Successful read^[(^d cards)^]*", (count_structure.cards > 0),
      674 	     count_structure.cards);
      675 	if mode = rje
      676 	then do;					/* submit abs request */
      677 		if index (rje_control_string, " -of ") = 0 & index (rje_control_string, " -output_file ") = 0
      678 		then rje_control_string = rje_control_string || space || "-output_file " || absout_pname;
      679 		command =
      680 		     "enter_abs_request " || absin_pname || " -brief " || rje_control_string || space
      681 		     || rje_arg_string;
      682 		call cu_$cp (addrel (addr (command), 1), length (command), code);
      683 		call notify_user ("RJE job: """ || rtrim (deck_name) || """, queued for absentee.");
      684 	     end;
      685 	else call notify_user ("Successful read of card deck: " || rtrim (deck_name));
      686 
      687 	call iox_$control (error_iocbp, "runout", null, code);
      688 						/* be sure operator sees any messages */
      689 	goto start;				/*  see if there is another deck to read */
      690 
      691 
      692 end_card:
      693 	call ioa_$ioa_stream (error_stream, "++END card read.^/");
      694 	call clean_up;
      695 
      696 finale:
      697 	a_code = code;
      698 	return;
      699 oob:
      700 	call abort_read ("Multi-segment input not allowed for card mode" || rtrim (deck_format), tell_user);
      701 
      702 set_station:
      703      entry (a_station, a_code);
      704 
      705 	a_code = 0;
      706 	station = a_station;
      707 	return;
      708 
      709 set_rqt:
      710      entry (a_prt_rqt, a_pun_rqt, a_code);
      711 
      712 	a_code = 0;
      713 	prt_rqt = a_prt_rqt;
      714 	pun_rqt = a_pun_rqt;
      715 	return;
      716 
      717 abort:
      718      proc (message);
      719 	dcl     message		 char (*);
      720 	call report (message, silent);		/* use the standard messages */
      721 	call clean_up;
      722 	call ioa_$ioa_stream (error_stream, "Unable to continue.");
      723 						/* then say it is bad */
      724 	call iox_$control (error_iocbp, "runout", null, (0));
      725 						/* force out the message */
      726 	goto finale;
      727 
      728      end abort;
      729 
      730 abort_read:
      731      proc (message, tell_user);
      732 	dcl     message		 char (*);
      733 	dcl     tell_user		 bit (1);
      734 	call report (message, tell_user);		/* give an error message and cleanup the pool */
      735 	call clean_up;
      736 	call ioa_$ioa_stream (error_stream, "Skipping to next ++EOF card. ");
      737 	call iox_$control (error_iocbp, "runout", null, (0));
      738 						/* force out the message */
      739 
      740 	prior_read_aborted = "1"b;
      741 	do j = 1 by 1;
      742 	     call read_control_card;
      743 	     if code = error_table_$eof_record
      744 	     then do;				/* is this an EOF? */
      745 		     if uid ^= ""
      746 		     then do;			/* are we expecting ++UID match ? */
      747 			     call read_control_card;
      748 			     if code = error_table_$eof_record
      749 			     then call read_control_card;
      750 						/* this one must be good .. */
      751 			     if key = "++uid" & field (1) = uid
      752 			     then goto start;
      753 			end;
      754 		     else do;
      755 			     call init;
      756 			     prior_read_aborted = "1"b;
      757 			     goto read_uid;
      758 			end;
      759 		end;
      760 	end;
      761 	return;
      762 
      763      end abort_read;
      764 
      765 report:
      766      proc (message, tell_user);
      767 	dcl     message		 char (*);
      768 	dcl     tell_user		 bit (1);
      769 	if code ^= 0
      770 	then call convert_status_code_ (code, short, long);
      771 	else long = "";
      772 	on any_other goto report_ret;			/* in case the error stream is not there */
      773 	if tell_user
      774 	then call notify_user ("Aborted card input deck: " || rtrim (deck_name) || NL || message);
      775 	call ioa_$ioa_stream (error_stream,		/*  give message to the operator */
      776 	     "read_cards_: ^[Error while processing deck ""^a"" for ^a^/^;^2s^]^a^/^a", (deck_name ^= ""), deck_name,
      777 	     personid, message, long);
      778 report_ret:
      779 	return;
      780      end report;
      781 
      782 read_control_card:
      783      proc;
      784 
      785 	dcl     i			 fixed bin;
      786 
      787 	field_cnt = 0;
      788 	field (*) = "";
      789 	card_buffer, key = "";
      790 
      791 	call iox_$get_chars (control_iocbp, addr (card_buffer), 80, nelt, code);
      792 	if code ^= 0
      793 	then do;
      794 		if code = error_table_$eof_record
      795 		then return;
      796 		else if code = error_table_$end_of_info | code = error_table_$short_record
      797 		then code = 0;
      798 		else call abort ("Read error.");
      799 	     end;
      800 
      801 	card_image = substr (card_buffer, 1, nelt);
      802 	call card_util_$translate (control_mode_bits, card_image);
      803 
      804 	card_image = ltrim (card_image);		/* strip any leading spaces */
      805 	card_image = rtrim (card_image, NL || space);	/* and trailing NL's or spaces */
      806 
      807 	i = search (card_image, space);
      808 
      809 	if i = 0
      810 	then do;					/* no space, could be ++INPUT */
      811 		key = card_image;			/* try for it */
      812 		if key = "++end"
      813 		then goto end_card;
      814 		return;
      815 	     end;
      816 
      817 	key = substr (card_image, 1, i - 1);		/* record the key value */
      818 
      819 	if key = "++end"
      820 	then goto end_card;
      821 
      822 	string = ltrim (substr (card_image, i + 1));	/* see what is after the space */
      823 
      824 	if search (string, SPECIAL_CHARACTERS) > 0
      825 	then call abort ("Special characters in control string.");
      826 
      827 	field_begin = 1;
      828 	scan_done = "0"b;
      829 	do i = 1 by 1 while (^scan_done);
      830 	     field_len = search (substr (string, field_begin), " ");
      831 	     if field_len = 0
      832 	     then do;
      833 		     field_len = length (string) - field_begin + 1;
      834 		     scan_done = "1"b;
      835 		end;
      836 	     else field_len = field_len - 1;
      837 	     field (i) = substr (string, field_begin, field_len);
      838 	     field_begin = field_begin + field_len + verify (substr (string, field_begin + field_len), " ") - 1;
      839 	     field_cnt = i;
      840 	end;
      841 	return;
      842 
      843      end read_control_card;
      844 
      845 clean_up:
      846      proc;
      847 
      848 	if fcbp ^= null
      849 	then do;
      850 		call msf_manager_$close (fcbp);
      851 		fcbp = null;			/* don't repeat this */
      852 		call delete_$path (dirname, new_deck_name, "100100"b, "", (0));
      853 	     end;
      854 	if pool_open
      855 	then do;
      856 		call pool_manager_$close_user_pool (root, person, 1, "100"b || (33)"0"b, (0));
      857 		pool_open = "0"b;
      858 	     end;
      859 	return;
      860      end clean_up;
      861 
      862 overflow_handler:
      863      proc;
      864 	call pool_manager_$add_quota (root, 10, code);	/* add 10 pages and keep going */
      865 	if code ^= 0
      866 	then do;
      867 		call report ("^/No available quota in card pool.", silent);
      868 		signal card_command_level;		/* allow operator to respond */
      869 	     end;
      870 	return;					/* restart where we stopped if it returns */
      871 
      872      end overflow_handler;
      873 
      874 set_abs_header:
      875      proc;
      876 	header_string =
      877 	     header.system_lines (1) || NL || header.system_lines (2) || space || prt_rqt || NL
      878 	     || header.system_lines (3) || space || pun_rqt || NL || header.system_lines (4) || space || station
      879 	     || NL || header.system_lines (5) || NL;
      880 	if epilogue_string ^= ""
      881 	then header_string = header_string || "set_epilogue_command """ || epilogue_string || """" || NL;
      882 	else header_string = header_string || header.system_lines (6) || NL;
      883 	do i = 1 to hbound (header.user_lines, 1) while (header.user_lines (i) ^= "");
      884 	     header_string = header_string || header.user_lines (i) || NL;
      885 	end;
      886 	header_len, string_len = length (header_string);
      887 	deckp -> output_string = header_string;
      888 	deckp = addr (deckp -> deck_char_pos (header_len + 1));
      889 	return;
      890 
      891      end set_abs_header;
      892 
      893 
      894 set_abs_trailer:
      895      proc;
      896 	trailer_string = trailer.system_lines (1) || NL;
      897 	do i = 1 to hbound (trailer.user_lines, 1) while (trailer.user_lines (i) ^= "");
      898 	     trailer_string = trailer_string || trailer.user_lines (i) || NL;
      899 	end;
      900 	trailer_len, string_len = length (trailer_string);
      901 
      902 	left = remaining_chars - trailer_len;		/* will it all fit this segment? */
      903 	if left < 0
      904 	then do;					/* OOPS */
      905 		string_len = remaining_chars;		/* set size of output_string */
      906 		output_string = substr (trailer_string, 1, remaining_chars);
      907 
      908 		component = component + 1;		/* start the next MSF component */
      909 
      910 		if component = 1
      911 		then do;				/* about to force conversion to MSF ... */
      912 			call pool_manager_$add_quota (root, 260, code);
      913 						/* ... need extra quota during conversion */
      914 			if code ^= 0
      915 			then do;			/* couldn't get it: let the operator try to correct it ... */
      916 				call report (NL || "Insufficient quota in pool to convert to MSF." || NL, silent);
      917 				signal card_command_level;
      918 				call pool_manager_$add_quota (root, 260, code);
      919 						/* ... and try again */
      920 			     end;
      921 			if code ^= 0
      922 			then call abort_read ("Insufficient quota in pool to convert to MSF.", silent);
      923 		     end;
      924 
      925 		call msf_manager_$get_ptr (fcbp, component, "1"b, deckp, bc, code);
      926 		if deckp = null
      927 		then call abort_read ("Unable to initiate next MSF component", silent);
      928 
      929 		if component = 1
      930 		then /* give back the quota we got temporarily */
      931 		     call pool_manager_$add_quota (root, -260, (0));
      932 
      933 		trailer_string = substr (trailer_string, remaining_chars + 1);
      934 						/* set image to last part of card */
      935 
      936 		string_len = length (trailer_string);	/* set the output_string size */
      937 		output_string = trailer_string;
      938 		nelt = string_len;			/* restart last component count */
      939 	     end;
      940 	else do;
      941 		output_string = trailer_string;
      942 		nelt = nelt + trailer_len;		/* fix the element count so we can compute the bit count */
      943 	     end;
      944 	return;
      945 
      946 
      947      end set_abs_trailer;
      948 
      949 init:
      950      proc;
      951 	a_code, code = 0;
      952 	deck_name, person, project, personid, absin_pname, absin_ename, absout_pname, dirname = "";
      953 	aim_string, rje_control_string, rje_arg_string, epilogue_string = "";
      954 	deck_format = card_stream_info.format (1);	/* set the default to the first stream we use */
      955 	header_len, trailer_len, nelt = 0;
      956 	input_mode_bits = "0"b;
      957 	pool_open = "0"b;				/* the user pool is not yet open */
      958 	add_nl = "1"b;
      959 	absin_online = "0"b;
      960 	lower_case = "0"b;
      961 	overwrite = "0"b;
      962 	cancel_rje = "0"b;
      963 	contin = "0"b;
      964 	trim = "1"b;
      965 	uid = "";					/* get ready for a new uid value */
      966 	deckp, fcbp = null;
      967 	prior_read_aborted = "0"b;
      968 	return;
      969 
      970      end init;
      971 
      972 check_card_input_password:
      973      proc ();
      974 	call read_control_card;
      975 	if code = error_table_$eof_record
      976 	then call abort_read ("Unexpected ++EOF card looking for password.", tell_user);
      977 	if key ^= "++password"
      978 	then call abort_read ("Expected ++PASSWORD card not found", tell_user);
      979 	if field_cnt = 2 | field_cnt > 3
      980 	then /* allow no PW, PW, or PW -cpw NPW only */
      981 	     call abort_read ("Invalid ++PASSWORD card", tell_user);
      982 
      983 	if field (2) = "-cpw"
      984 	then do;
      985 		if field (3) ^= ""
      986 		then do;
      987 			temp_password = field (3);
      988 			new_password = scramble_ (temp_password);
      989 			field (3) = "";
      990 			temp_password = "";
      991 		     end;
      992 		else new_password = "";
      993 	     end;
      994 	else if field (2) ^= ""
      995 	then call abort_read ("Invalid ++PASSWORD control argument.", tell_user);
      996 	else new_password = "";
      997 
      998 	if field (1) ^= ""
      999 	then do;
     1000 		temp_password = field (1);
     1001 		password = scramble_ (temp_password);
     1002 		field (1) = "";
     1003 		temp_password = "";
     1004 	     end;
     1005 	else password = "";
     1006 
     1007 	call validate_card_input_$user (person, project, password, new_password, (station), mode, error_msg, code);
     1008 	if code ^= 0
     1009 	then do;
     1010 		code = 0;
     1011 		call abort_read (error_msg, tell_user);
     1012 	     end;
     1013 
     1014 	personid = rtrim (person) || "." || project;	/* redefine to remove any alias */
     1015 	return;
     1016 
     1017      end check_card_input_password;
     1018 
     1019 parse_format_card:
     1020      proc;
     1021 	if field_cnt < 1
     1022 	then call abort_read ("Incorrect ++FORMAT card.", tell_user);
     1023 	deck_format = field (1);
     1024 	do i = 2 to field_cnt;
     1025 	     if field (i) = "trim"
     1026 	     then trim = "1"b;
     1027 	     else if field (i) = "notrim"
     1028 	     then trim = "0"b;
     1029 	     else if field (i) = "lowercase"
     1030 	     then lower_case = "1"b;
     1031 	     else if field (i) = "uppercase"
     1032 	     then lower_case = "0"b;
     1033 	     else if field (i) = "noconvert"
     1034 	     then lower_case = "0"b;
     1035 	     else if field (i) = "addnl"
     1036 	     then add_nl = "1"b;
     1037 	     else if field (i) = "noaddnl"
     1038 	     then add_nl = "0"b;
     1039 	     else if field (i) = "contin"
     1040 	     then contin = "1"b;
     1041 	     else if field (i) = "nocontin"
     1042 	     then contin = "0"b;
     1043 	     else call abort_read ("Undefined mode on ++FORMAT  card: " || field (i), tell_user);
     1044 	end;
     1045 	return;
     1046 
     1047      end parse_format_card;
     1048 
     1049 
     1050 
     1051 notify_user:
     1052      proc (message);
     1053 	dcl     message		 char (*);
     1054 	if personid ^= ""
     1055 	then call send_mail_ (personid, message, addr (send_mail_info), (0));
     1056 	return;
     1057 
     1058      end notify_user;
     1059 
     1060 
     1061 
     1062 parse_first_card:
     1063      proc (string);
     1064 	dcl     string		 char (*);
     1065 	if field_cnt ^= 3 & field_cnt ^= 2
     1066 	then call abort_read ("Incorrect " || string || " card format.", tell_user);
     1067 	deck_name = field (1);
     1068 	if field_cnt = 3
     1069 	then do;
     1070 		person = field (2);
     1071 		project = field (3);
     1072 	     end;
     1073 	else if field_cnt = 2
     1074 	then do;
     1075 		person = before (field (2), ".");
     1076 		project = after (field (2), ".");
     1077 	     end;
     1078 	if person = "*" | person = ""
     1079 	then /* a personid of * is illegal */
     1080 	     call abort_read ("Person name must be defined.", tell_user);
     1081 	if project = "*" | project = ""
     1082 	then call abort_read ("Project name must be defined.", tell_user);
     1083 
     1084      end parse_first_card;
     1085 
     1086      end read_cards_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/89  0800.0  read_cards_.pl1                   >special_ldd>install>MR12.3-1025>read_cards_.pl1
141          1    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
144          2    05/06/74  1741.0  cond_info_structure.incl.pl1      >ldd>include>cond_info_structure.incl.pl1
230          3    09/09/75  1333.7  card_stream_info.incl.pl1         >ldd>include>card_stream_info.incl.pl1
232          4    03/15/89  0759.4  create_branch_info.incl.pl1       >special_ldd>install>MR12.3-1025>create_branch_info.incl.pl1
234          5    04/27/78  1504.4  send_mail_info.incl.pl1           >ldd>include>send_mail_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              014371 constant        char(1)                  initial packed unaligned dcl 157 ref 560 560 773 805
                                                                                  876 876 876 876 876 880 882 884 896 898 916 916
SPECIAL_CHARACTERS              000000 constant        char(8)                  initial packed unaligned dcl 160 ref 824
a_code                                 parameter       fixed bin(35,0)          dcl 34 set ref 12 422* 696* 702 705* 709 712* 951*
a_prt_rqt                              parameter       char                     packed unaligned dcl 30 ref 709 713
a_pun_rqt                              parameter       char                     packed unaligned dcl 35 ref 709 714
a_station                              parameter       char                     packed unaligned dcl 31 ref 702 706
absin_ename                     000100 automatic       char(32)                 packed unaligned dcl 37 set ref 380* 384 384* 391
                                                                                  395 395 399 401* 952*
absin_online                    000110 automatic       bit(1)                   packed unaligned dcl 38 set ref 377* 425 959*
absin_pname                     000111 automatic       varying char(168)        dcl 39 set ref 391* 399* 401* 403 403 481* 679 952*
absout_pname                    000164 automatic       varying char(168)        dcl 40 set ref 395* 403* 483* 677 952*
access_class             20     005102 automatic       bit(72)                  level 2 dcl 173 set ref 451*
acknowledge              11(05) 005126 automatic       bit(1)                   level 3 packed packed unaligned dcl 5-5 set ref 243*
acle                            005054 automatic       structure                array level 1 dcl 148 set ref 634* 645 645
aclec                           000246 automatic       fixed bin(17,0)          dcl 44 set ref 640* 644* 645*
add_nl                          000247 automatic       bit(1)                   packed unaligned dcl 45 set ref 487 958* 1035* 1037*
addr                                                   builtin function         dcl 225 ref 251 251 463 463 523 523 589 600 613 613
                                                                                  645 645 682 682 791 791 888 1054 1054
addrel                                                 builtin function         dcl 225 ref 682 682
after                                                  builtin function         dcl 227 ref 254 1076
aim_check_$equal                000102 constant        entry                    external dcl 197 ref 420
aim_string                      000250 automatic       varying char(720)        dcl 46 set ref 335* 335 365* 365 416 418 953*
always_add               11(02) 005126 automatic       bit(1)                   level 3 packed packed unaligned dcl 5-5 set ref 240*
any_other                       000000 stack reference condition                dcl 117 ref 772
bc                              000535 automatic       fixed bin(24,0)          dcl 47 set ref 474* 572* 626* 630* 925*
before                                                 builtin function         dcl 227 ref 252 395 395 1075
cancel_rje                      000536 automatic       bit(1)                   packed unaligned dcl 48 set ref 962*
card_buffer                     000537 automatic       char(100)                dcl 49 set ref 522* 523 523 537 789* 791 791 801
card_command_level              004442 stack reference condition                dcl 115 ref 563 868 917
card_image                      000570 automatic       varying char(160)        dcl 50 set ref 537* 540* 541 549 580* 583* 583 586
                                                                                  588 596 598 801* 802* 804* 804 805* 805 807 811
                                                                                  817 822
card_stream_info                       based           structure                level 1 dcl 3-8
card_util_$modes                000060 constant        entry                    external dcl 186 ref 281 489
card_util_$translate            000062 constant        entry                    external dcl 187 ref 540 802
cards                     4     005013 automatic       fixed bin(35,0)          level 2 dcl 131 set ref 673 673*
cleanup                         004450 stack reference condition                dcl 115 ref 266
code                            000644 automatic       fixed bin(35,0)          dcl 57 set ref 259* 268* 274* 275 277* 278 281* 282
                                                                                  289 295 298 313 331 363 380* 381 384* 385 416* 418
                                                                                  432* 440* 441 453* 454 463* 464 464* 466 466 470*
                                                                                  474* 489* 490 502* 503 505 507 507 507* 523* 524
                                                                                  526 530 530 530* 556* 558 564* 567 572* 630* 631
                                                                                  645* 646 651 666* 668 682* 687* 696 743 748 769
                                                                                  769* 791* 792 794 796 796 796* 864* 865 912* 914
                                                                                  918* 921 925* 951* 975 1007* 1008 1010*
command                         000645 automatic       varying char(1000)       dcl 58 set ref 679* 682 682 682 682
command_error                   004456 stack reference condition                dcl 115 ref 249
command_error_info                     based           structure                level 1 dcl 143
component                       001240 automatic       fixed bin(17,0)          dcl 59 set ref 473* 474* 551* 551 554 572* 576 630*
                                                                                  908* 908 910 925* 929
cond_info                       005022 automatic       structure                level 1 dcl 140 set ref 251 251
contin                          001241 automatic       bit(1)                   packed unaligned dcl 60 set ref 487 963* 1039* 1041*
continue_to_signal_             000064 constant        entry                    external dcl 188 ref 263
control_iocbp                   001242 automatic       pointer                  dcl 61 set ref 274* 791*
control_mode_bits               003573 automatic       bit(36)                  packed unaligned dcl 85 set ref 281* 802*
control_modes                   000013 constant        char(32)                 initial packed unaligned dcl 154 set ref 281*
control_stream                         based           char(32)                 level 2 dcl 3-8 set ref 274*
convert_authorization_$from_string
                                000106 constant        entry                    external dcl 199 ref 416
convert_status_code_            000104 constant        entry                    external dcl 198 ref 769
count_structure                 005013 automatic       structure                level 1 dcl 131 set ref 610* 613 613
create_branch_info                     based           structure                level 1 dcl 4-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 4-35 ref 447
cu_$cp                          000110 constant        entry                    external dcl 201 ref 682
cu_$level_get                   000112 constant        entry                    external dcl 202 ref 449
data                                   constant        fixed bin(17,0)          initial dcl 165 ref 324 425
data_streams             11            based           structure                array level 2 dcl 3-8
deck_auth                       001244 automatic       bit(72)                  packed unaligned dcl 62 set ref 416* 420*
deck_char_pos                          based           char(1)                  array packed unaligned dcl 53 set ref 589 600 888
deck_format                     001246 automatic       char(12)                 packed unaligned dcl 63 set ref 427 429 436 477* 699
                                                                                  954* 1023*
deck_name                       001251 automatic       varying char(32)         dcl 64 set ref 354 354 354* 354 354 459* 683 685 773
                                                                                  775 775* 952* 1067*
deck_name_prefix                001262 automatic       varying char(32)         dcl 65 set ref 482* 483*
deckp                           001274 automatic       pointer                  dcl 66 set ref 474* 475 502* 549 572* 573 588 589*
                                                                                  589 598 600* 600 887 888* 888 906 925* 926 937 941
                                                                                  966*
delete_$path                    000114 constant        entry                    external dcl 203 ref 852
dirname                         001276 automatic       char(168)                packed unaligned dcl 67 set ref 380* 399 440* 456
                                                                                  463* 470* 481 852* 952*
divide                                                 builtin function         dcl 225 ref 497
done                            001350 automatic       bit(1)                   packed unaligned dcl 68 set ref 328* 329 343* 360*
                                                                                  361 407*
el_size                  24            based           fixed bin(17,0)          array level 3 dcl 3-8 ref 433
element_size                    001351 automatic       fixed bin(17,0)          dcl 69 set ref 433* 436 497 500 626
epilogue_string                 001352 automatic       varying char(256)        dcl 70 set ref 373* 373 880 880 953*
errmess_lth             114            based           fixed bin(17,0)          level 2 dcl 143 ref 252 254 255 255
errmess_ptr             112            based           pointer                  level 2 dcl 143 ref 252 254 255
error_iocbp                     001454 automatic       pointer                  dcl 71 set ref 259* 277* 687* 724* 737*
error_message                          based           char                     packed unaligned dcl 171 set ref 252 254 255*
error_msg                       001456 automatic       char(132)                packed unaligned dcl 72 set ref 1007* 1011*
error_stream                           parameter       char                     packed unaligned dcl 29 set ref 12 255* 277 300*
                                                                                  320* 477* 673* 692* 722* 736* 775*
error_table_$ai_restricted      000052 external static fixed bin(35,0)          dcl 180 ref 422
error_table_$end_of_info        000050 external static fixed bin(35,0)          dcl 178 ref 507 530 796
error_table_$eof_record         000054 external static fixed bin(35,0)          dcl 182 ref 289 295 298 313 331 363 505 526 651 743
                                                                                  748 794 975
error_table_$namedup            000056 external static fixed bin(35,0)          dcl 184 ref 464 466
error_table_$short_record       000046 external static fixed bin(35,0)          dcl 176 ref 507 530 796
expand_pathname_                000066 constant        entry                    external dcl 189 ref 380
fcbp                            001520 automatic       pointer                  dcl 73 set ref 470* 471 474* 572* 630* 645* 661 661*
                                                                                  663* 848 850* 851* 925* 966*
field                           001522 automatic       varying char(80)         array dcl 74 set ref 306 339 380 381 385 387 389 393
                                                                                  399 658 751 788* 837* 983 985 987 989* 994 998
                                                                                  1000 1002* 1023 1025 1027 1029 1031 1033 1035 1037
                                                                                  1039 1041 1043 1067 1070 1071 1075 1076
field_begin                     003232 automatic       fixed bin(17,0)          dcl 75 set ref 827* 830 833 837 838* 838 838
field_cnt                       003233 automatic       fixed bin(17,0)          dcl 76 set ref 378 378 787* 839* 979 979 1021 1024
                                                                                  1065 1065 1068 1073
field_len                       003234 automatic       fixed bin(17,0)          dcl 77 set ref 830* 831 833* 836* 836 837 838 838
find_condition_info_            000116 constant        entry                    external dcl 204 ref 251
format                   11            based           char(12)                 array level 3 dcl 3-8 ref 427 954
get_authorization_              000120 constant        entry                    external dcl 205 ref 245
get_group_id_                   000122 constant        entry                    external dcl 206 ref 450
get_group_id_$tag_star          000124 constant        entry                    external dcl 207 ref 641
hbound                                                 builtin function         dcl 225 ref 883 897
hcs_$create_branch_             000136 constant        entry                    external dcl 212 ref 463
header                          004472 automatic       structure                level 1 dcl 119
header_len                      003235 automatic       fixed bin(17,0)          dcl 78 set ref 515 517 886* 888 955*
header_string                   003236 automatic       varying char(600)        dcl 79 set ref 876* 880* 880 882* 882 884* 884 886
                                                                                  887
i                               000100 automatic       fixed bin(17,0)          dcl 785 in procedure "read_control_card" set ref
                                                                                  807* 809 817 822 829* 837 839*
i                               003465 automatic       fixed bin(17,0)          dcl 80 in procedure "read_cards_" set ref 883* 883*
                                                                                  884* 897* 897* 898* 1024* 1025 1027 1029 1031 1033
                                                                                  1035 1037 1039 1041 1043*
ignore                          003466 automatic       fixed bin(35,0)          dcl 81 set ref 495* 613*
index                                                  builtin function         dcl 225 ref 677 677
infoptr                  14     005022 automatic       pointer                  level 2 dcl 140 set ref 252 252 254 254 255 255 255
input_iocbp                     003470 automatic       pointer                  dcl 82 set ref 432* 495* 502* 523* 613*
input_mode_bits                 003572 automatic       bit(36)                  packed unaligned dcl 84 set ref 489* 540* 956*
input_modes                     003472 automatic       char(256)                packed unaligned dcl 83 set ref 487* 489*
ioa_$ioa_stream                 000140 constant        entry                    external dcl 213 ref 255 300 320 477 673 692 722 736
                                                                                  775
ioa_$rsnnl                      000142 constant        entry                    external dcl 214 ref 395 401 459 483 487
iox_$control                    000150 constant        entry                    external dcl 217 ref 259 495 613 687 724 737
iox_$get_chars                  000144 constant        entry                    external dcl 215 ref 502 523 791
iox_$look_iocb                  000146 constant        entry                    external dcl 216 ref 274 277 432
j                               003574 automatic       fixed bin(17,0)          dcl 86 set ref 741*
k                               003575 automatic       fixed bin(17,0)          dcl 87 set ref 427* 427* 429 432 433
key                             003576 automatic       varying char(32)         dcl 88 set ref 304 322 333 335 337 343 345 347 350
                                                                                  365 367 369 371 373 375 407 409 411 414 651 656
                                                                                  751 789* 811* 812 817* 819 977
left                            000643 automatic       fixed bin(24,0)          dcl 56 set ref 543* 545 580 602 902* 903
length                                                 builtin function         dcl 225 ref 354 354 403 482 541 586 596 682 682 833
                                                                                  886 900 936
lnd                             003607 automatic       fixed bin(17,0)          dcl 89 set ref 459* 460 460
local_cbi                       005102 automatic       structure                level 1 dcl 173 set ref 446* 463 463
long                            003610 automatic       char(100)                packed unaligned dcl 90 set ref 769* 771* 775*
lower_case                      003641 automatic       bit(1)                   packed unaligned dcl 91 set ref 487 960* 1029* 1031*
                                                                                  1033*
ltrim                                                  builtin function         dcl 227 ref 804 822
message                                parameter       char                     packed unaligned dcl 1053 in procedure "notify_user"
                                                                                  set ref 1051 1054*
message                                parameter       char                     packed unaligned dcl 732 in procedure "abort_read"
                                                                                  set ref 730 734*
message                                parameter       char                     packed unaligned dcl 719 in procedure "abort" set
                                                                                  ref 717 720*
message                                parameter       char                     packed unaligned dcl 767 in procedure "report" set
                                                                                  ref 765 773 775*
mode                     10     005054 automatic       bit(36)                  array level 2 in structure "acle" dcl 148
                                                                                  in procedure "read_cards_" set ref 637* 642*
mode                      2     005102 automatic       bit(3)                   level 2 in structure "local_cbi" packed packed
                                                                                  unaligned dcl 173 in procedure "read_cards_" set
                                                                                  ref 448*
mode                            003642 automatic       fixed bin(17,0)          dcl 92 in procedure "read_cards_" set ref 324* 352*
                                                                                  425 425 436 459 479 619 638 675 1007*
msf_manager_$acl_add            000134 constant        entry                    external dcl 211 ref 645
msf_manager_$adjust             000100 constant        entry                    external dcl 196 ref 630
msf_manager_$close              000126 constant        entry                    external dcl 208 ref 661 850
msf_manager_$get_ptr            000132 constant        entry                    external dcl 210 ref 474 572 925
msf_manager_$open               000130 constant        entry                    external dcl 209 ref 470
multiply                                               builtin function         dcl 225 ref 626
n_streams                10            based           fixed bin(17,0)          level 2 dcl 3-8 ref 427 429
name                     14            based           char(32)                 array level 3 in structure "card_stream_info"
                                                                                  dcl 3-8 in procedure "read_cards_" set ref 432*
name                            005054 automatic       char(32)                 array level 2 in structure "acle" dcl 148
                                                                                  in procedure "read_cards_" set ref 635* 641*
nel                             003643 automatic       fixed bin(24,0)          dcl 93 set ref 497* 502 517 591
nelt                            003644 automatic       fixed bin(24,0)          dcl 94 set ref 502* 515* 593* 604* 604 626 791* 801
                                                                                  938* 942* 942 955*
never_add                11(03) 005126 automatic       bit(1)                   level 3 packed packed unaligned dcl 5-5 set ref 241*
new_deck_name                   003646 automatic       char(32)                 packed unaligned dcl 96 set ref 459* 460 463* 466
                                                                                  470* 475 477* 481 482 482 852*
new_password                    000242 automatic       char(8)                  packed unaligned dcl 42 set ref 988* 992* 996* 1007*
notify                   11(04) 005126 automatic       bit(1)                   level 3 packed packed unaligned dcl 5-5 set ref 242*
null                                                   builtin function         dcl 225 ref 251 251 259 259 471 475 495 495 573 661
                                                                                  663 687 687 724 724 737 737 848 851 926 966
num_chars_rec                   003645 automatic       fixed bin(24,0)          dcl 95 set ref 520* 523* 537 541* 543
out_of_bounds                   004464 stack reference condition                dcl 115 ref 493 624
output_string                          based           char                     packed unaligned dcl 51 set ref 549* 588* 598* 887*
                                                                                  906* 937* 941*
overwrite                       003656 automatic       bit(1)                   packed unaligned dcl 97 set ref 339* 464 961*
password                        000240 automatic       char(8)                  packed unaligned dcl 41 set ref 339 1001* 1005*
                                                                                  1007*
person                          003657 automatic       char(32)                 packed unaligned dcl 98 set ref 326 356 395* 401*
                                                                                  440* 483* 666* 856* 952* 1007* 1014 1070* 1075*
                                                                                  1078 1078
personid                        003667 automatic       char(32)                 packed unaligned dcl 99 set ref 326* 356* 359 477*
                                                                                  635 775* 952* 1014* 1054 1054*
pool_manager_$add_quota         000152 constant        entry                    external dcl 218 ref 556 564 576 864 912 918 929
pool_manager_$close_user_pool   000154 constant        entry                    external dcl 220 ref 666 856
pool_manager_$open_user_pool    000156 constant        entry                    external dcl 222 ref 440
pool_open                       003677 automatic       bit(1)                   packed unaligned dcl 100 set ref 444* 664 671* 854
                                                                                  857* 957*
prior_read_aborted              004115 automatic       bit(1)                   packed unaligned dcl 106 set ref 315 740* 756* 967*
proc_auth                       003700 automatic       bit(72)                  packed unaligned dcl 101 set ref 245* 420* 451
project                         003702 automatic       char(32)                 packed unaligned dcl 102 set ref 326 356 395* 401*
                                                                                  483* 952* 1007* 1014 1071* 1076* 1081 1081
prt_rqt                         000010 internal static varying char(32)         initial dcl 167 set ref 713* 876
pun_rqt                         000021 internal static varying char(32)         initial dcl 168 set ref 714* 876
record_quota_overflow           004434 stack reference condition                dcl 115 ref 247
remaining_chars                 000642 automatic       fixed bin(24,0)          dcl 55 set ref 517* 543 547 549 583 591* 602* 902
                                                                                  905 906 933
rings                     3     005102 automatic       fixed bin(3,0)           array level 2 dcl 173 set ref 449* 449* 449*
rje                                    constant        fixed bin(17,0)          initial dcl 166 ref 352 425 436 459 479 619 638 675
rje_arg_string                  003712 automatic       varying char(256)        dcl 103 set ref 358* 367* 367 679 953*
rje_control_string              004013 automatic       varying char(256)        dcl 104 set ref 359* 369* 369 677 677 677* 677 679
                                                                                  953*
root                                   parameter       char                     packed unaligned dcl 32 set ref 12 440* 556* 564*
                                                                                  576* 666* 856* 864* 912* 918* 929*
rtrim                                                  builtin function         dcl 227 ref 326 326 356 356 359 359 399 403 436 481
                                                                                  482 635 683 685 699 773 805 1014
scan_done                       004114 automatic       bit(1)                   packed unaligned dcl 105 set ref 828* 829 834*
scramble_                       000070 constant        entry                    external dcl 190 ref 988 1001
search                                                 builtin function         dcl 227 ref 807 824 830
send_mail_                      000072 constant        entry                    external dcl 191 ref 1054
send_mail_info                  005126 automatic       structure                level 1 dcl 5-5 set ref 236* 1054 1054
send_mail_info_version_2        005125 automatic       fixed bin(17,0)          initial dcl 5-3 set ref 237 5-3*
sent_from                 1     005126 automatic       char(32)                 level 2 dcl 5-5 set ref 238*
short                           004116 automatic       char(8)                  packed unaligned dcl 107 set ref 769*
silent                          000121 constant        bit(1)                   initial packed unaligned dcl 164 set ref 256* 269*
                                                                                  291* 307* 310* 317* 466* 471* 475* 509* 511* 533*
                                                                                  560* 567* 573* 631* 646* 651* 656* 658* 668* 720*
                                                                                  867* 916* 921* 926*
space                           014372 constant        char(1)                  initial packed unaligned dcl 156 ref 367 369 373 677
                                                                                  679 805 807 876 876 876
station                         000032 internal static varying char(32)         initial dcl 169 set ref 238 359 706* 876 1007
stream_info_ptr                        parameter       pointer                  dcl 3-6 ref 12 274 427 427 429 432 433 954
string                                 parameter       char                     packed unaligned dcl 1064 in procedure
                                                                                  "parse_first_card" ref 1062 1065
string                          004120 automatic       varying char(160)        dcl 108 in procedure "read_cards_" set ref 335 365
                                                                                  367 369 373 822* 824 830 833 837 838
string_len                      000641 automatic       fixed bin(17,0)          dcl 52 set ref 547* 549 586* 588 589 591 593 596*
                                                                                  598 600 604 886* 887 900* 905* 906 936* 937 938
                                                                                  941
substr                                                 builtin function         dcl 225 ref 354 354 399 403 460 482 537 549 583 801
                                                                                  817 822 830 837 838 906 933
suffixed_name_$make             000076 constant        entry                    external dcl 195 ref 384
switches                 11     005126 automatic       structure                level 2 dcl 5-5
sys_info$max_seg_size           000044 external static fixed bin(35,0)          dcl 175 ref 497
system_lines                    004727 automatic       varying char(80)         initial array level 2 in structure "trailer" dcl 126
                                                                                  in procedure "read_cards_" set ref 126* 896
system_lines                    004472 automatic       varying char(80)         initial array level 2 in structure "header" dcl 119
                                                                                  in procedure "read_cards_" set ref 119* 119* 119*
                                                                                  119* 119* 119* 876 876 876 876 876 882
tag                             004171 automatic       fixed bin(17,0)          dcl 109 set ref 453* 455* 455 456 459*
tell_user                              parameter       bit(1)                   packed unaligned dcl 733 in procedure "abort_read"
                                                                                  set ref 730 734*
tell_user                              parameter       bit(1)                   packed unaligned dcl 768 in procedure "report" ref
                                                                                  765 773
tell_user                       000113 constant        bit(1)                   initial packed unaligned dcl 162 in procedure
                                                                                  "read_cards_" set ref 331* 341* 345* 347* 363*
                                                                                  378* 381* 385* 393* 409* 411* 414* 418* 429* 436*
                                                                                  456* 460* 490* 699* 975* 977* 979* 994* 1011*
                                                                                  1021* 1043* 1065* 1078* 1081*
temp_password                   000244 automatic       char(8)                  packed unaligned dcl 43 set ref 987* 988* 990* 1000*
                                                                                  1001* 1003*
test                                   parameter       bit(1)                   packed unaligned dcl 33 ref 12
tools_dir                       000002 constant        varying char(32)         initial dcl 155 ref 391
trailer                         004727 automatic       structure                level 1 dcl 126
trailer_len                     004172 automatic       fixed bin(17,0)          dcl 110 set ref 900* 902 942 955*
trailer_string                  004173 automatic       varying char(600)        dcl 111 set ref 896* 898* 898 900 906 933* 933 936
                                                                                  937 941
trim                            004422 automatic       bit(1)                   packed unaligned dcl 112 set ref 487 964* 1025*
                                                                                  1027*
uid                             004423 automatic       varying char(32)         dcl 113 set ref 306* 307 658 658 745 751 965*
unspec                                                 builtin function         dcl 227 set ref 236* 446* 610* 634*
user_lines               25     004727 automatic       varying char(120)        initial array level 2 in structure "trailer" dcl 126
                                                                                  in procedure "read_cards_" set ref 126* 897 897
                                                                                  898
user_lines              176     004472 automatic       varying char(120)        initial array level 2 in structure "header" dcl 119
                                                                                  in procedure "read_cards_" set ref 119* 883 883
                                                                                  884
userid                    6     005102 automatic       char(32)                 level 2 dcl 173 set ref 450*
validate_card_input_$user       000074 constant        entry                    external dcl 192 ref 1007
verify                                                 builtin function         dcl 225 ref 838
version                         005102 automatic       fixed bin(17,0)          level 2 in structure "local_cbi" dcl 173
                                                                                  in procedure "read_cards_" set ref 447*
version                         005126 automatic       fixed bin(17,0)          level 2 in structure "send_mail_info" dcl 5-5
                                                                                  in procedure "read_cards_" set ref 237*
wakeup                   11     005126 automatic       bit(1)                   level 3 packed packed unaligned dcl 5-5 set ref 239*

NAMES DECLARED BY EXPLICIT CONTEXT.
abort                           010114 constant        entry                    internal dcl 717 ref 275 278 282 441 798 824
abort_read                      010233 constant        entry                    internal dcl 730 ref 291 307 310 317 331 341 345 347
                                                                                  363 378 381 385 393 409 411 414 418 429 436 456
                                                                                  460 466 471 475 490 509 511 533 567 573 631 646
                                                                                  651 656 658 668 699 921 926 975 977 979 994 1011
                                                                                  1021 1043 1065 1078 1081
check_card_input_password       012677 constant        entry                    internal dcl 972 ref 327 357
clean_up                        011345 constant        entry                    internal dcl 845 ref 258 271 694 721 735
end_card                        007700 constant        label                    dcl 692 set ref 812 819
end_read_loop                   006615 constant        label                    dcl 610 ref 505 526
finale                          007726 constant        label                    dcl 696 ref 301 726
init                            012606 constant        entry                    internal dcl 949 ref 244 285 755
notify_user                     013462 constant        entry                    internal dcl 1051 ref 254 683 685 773
oob                             007731 constant        label                    dcl 699 ref 493
overflow_handler                011472 constant        entry                    internal dcl 862 ref 247
parse_first_card                013533 constant        entry                    internal dcl 1062 ref 325 353
parse_format_card               013253 constant        entry                    internal dcl 1019 ref 333 371
read_cards_                     001635 constant        entry                    external dcl 12
read_control_card               010700 constant        entry                    internal dcl 782 ref 288 293 297 312 330 362 650 655
                                                                                  742 747 748 974
read_one_card                   006160 constant        label                    dcl 520 ref 607
read_uid                        002446 constant        label                    dcl 293 ref 315 757
report                          010452 constant        entry                    internal dcl 765 ref 256 269 560 720 734 867 916
report_ret                      010676 constant        label                    dcl 778 ref 772
set_abs_header                  011550 constant        entry                    internal dcl 874 ref 485
set_abs_trailer                 012176 constant        entry                    internal dcl 894 ref 621
set_rqt                         010041 constant        entry                    external dcl 709
set_station                     010001 constant        entry                    external dcl 702
start                           002413 constant        label                    dcl 285 ref 261 689 751

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15202       15362   14400       15212
Length     16026   14400       160         427     601          34

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
read_cards_                        2984 external procedure  is an external procedure.  
on unit on line 247                 104 on unit               
on unit on line 249                 112 on unit               
on unit on line 266                  90 on unit               
on unit on line 493                  64 on unit               
abort                               110 internal procedure  is called by several nonquick procedures.  
abort_read                          110 internal procedure  is called during a stack extension.  
report                              134 internal procedure  enables or reverts conditions.  
on unit on line 772                  64 on unit               
read_control_card                    90 internal procedure  is called by several nonquick procedures.  
clean_up                             94 internal procedure  is called by several nonquick procedures.  
overflow_handler                        internal procedure  shares stack frame of on unit on line 247.  
set_abs_header                          internal procedure  shares stack frame of external procedure read_cards_.  
set_abs_trailer                         internal procedure  shares stack frame of external procedure read_cards_.  
init                                 66 internal procedure  is called by several nonquick procedures.  
check_card_input_password               internal procedure  shares stack frame of external procedure read_cards_.  
parse_format_card                       internal procedure  shares stack frame of external procedure read_cards_.  
notify_user                          86 internal procedure  is called during a stack extension.  
parse_first_card                        internal procedure  shares stack frame of external procedure read_cards_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 prt_rqt                     read_cards_
000021 pun_rqt                     read_cards_
000032 station                     read_cards_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
read_cards_              000100 absin_ename                 read_cards_
                         000110 absin_online                read_cards_
                         000111 absin_pname                 read_cards_
                         000164 absout_pname                read_cards_
                         000240 password                    read_cards_
                         000242 new_password                read_cards_
                         000244 temp_password               read_cards_
                         000246 aclec                       read_cards_
                         000247 add_nl                      read_cards_
                         000250 aim_string                  read_cards_
                         000535 bc                          read_cards_
                         000536 cancel_rje                  read_cards_
                         000537 card_buffer                 read_cards_
                         000570 card_image                  read_cards_
                         000641 string_len                  read_cards_
                         000642 remaining_chars             read_cards_
                         000643 left                        read_cards_
                         000644 code                        read_cards_
                         000645 command                     read_cards_
                         001240 component                   read_cards_
                         001241 contin                      read_cards_
                         001242 control_iocbp               read_cards_
                         001244 deck_auth                   read_cards_
                         001246 deck_format                 read_cards_
                         001251 deck_name                   read_cards_
                         001262 deck_name_prefix            read_cards_
                         001274 deckp                       read_cards_
                         001276 dirname                     read_cards_
                         001350 done                        read_cards_
                         001351 element_size                read_cards_
                         001352 epilogue_string             read_cards_
                         001454 error_iocbp                 read_cards_
                         001456 error_msg                   read_cards_
                         001520 fcbp                        read_cards_
                         001522 field                       read_cards_
                         003232 field_begin                 read_cards_
                         003233 field_cnt                   read_cards_
                         003234 field_len                   read_cards_
                         003235 header_len                  read_cards_
                         003236 header_string               read_cards_
                         003465 i                           read_cards_
                         003466 ignore                      read_cards_
                         003470 input_iocbp                 read_cards_
                         003472 input_modes                 read_cards_
                         003572 input_mode_bits             read_cards_
                         003573 control_mode_bits           read_cards_
                         003574 j                           read_cards_
                         003575 k                           read_cards_
                         003576 key                         read_cards_
                         003607 lnd                         read_cards_
                         003610 long                        read_cards_
                         003641 lower_case                  read_cards_
                         003642 mode                        read_cards_
                         003643 nel                         read_cards_
                         003644 nelt                        read_cards_
                         003645 num_chars_rec               read_cards_
                         003646 new_deck_name               read_cards_
                         003656 overwrite                   read_cards_
                         003657 person                      read_cards_
                         003667 personid                    read_cards_
                         003677 pool_open                   read_cards_
                         003700 proc_auth                   read_cards_
                         003702 project                     read_cards_
                         003712 rje_arg_string              read_cards_
                         004013 rje_control_string          read_cards_
                         004114 scan_done                   read_cards_
                         004115 prior_read_aborted          read_cards_
                         004116 short                       read_cards_
                         004120 string                      read_cards_
                         004171 tag                         read_cards_
                         004172 trailer_len                 read_cards_
                         004173 trailer_string              read_cards_
                         004422 trim                        read_cards_
                         004423 uid                         read_cards_
                         004472 header                      read_cards_
                         004727 trailer                     read_cards_
                         005013 count_structure             read_cards_
                         005022 cond_info                   read_cards_
                         005054 acle                        read_cards_
                         005102 local_cbi                   read_cards_
                         005125 send_mail_info_version_2    read_cards_
                         005126 send_mail_info              read_cards_
read_control_card        000100 i                           read_control_card

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac
tra_ext_1           signal_op           enable_op           shorten_stack       ext_entry_desc      int_entry
int_entry_desc      set_chars_eis       index_chars_eis     divide_fx3          index_before_cs     verify_for_rtrim

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$equal              card_util_$modes              card_util_$translate          continue_to_signal_
convert_authorization_$from_string                          convert_status_code_          cu_$cp
cu_$level_get                 delete_$path                  expand_pathname_              find_condition_info_
get_authorization_            get_group_id_                 get_group_id_$tag_star        hcs_$create_branch_
ioa_$ioa_stream               ioa_$rsnnl                    iox_$control                  iox_$get_chars
iox_$look_iocb                msf_manager_$acl_add          msf_manager_$adjust           msf_manager_$close
msf_manager_$get_ptr          msf_manager_$open             pool_manager_$add_quota       pool_manager_$close_user_pool
pool_manager_$open_user_pool  scramble_                     send_mail_                    suffixed_name_$make
validate_card_input_$user

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$end_of_info      error_table_$eof_record       error_table_$namedup
error_table_$short_record     sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    119 001503       126 001605    5    3 001624        12 001630       236 001661       237 001664       238 001666
    239 001673       240 001675       241 001677       242 001701       243 001703       244 001705       245 001711
    247 001720       249 001736       251 001752       252 001772       254 002007       255 002050       256 002103
    258 002123       259 002130       261 002161       263 002164       264 002174       266 002175       268 002211
    269 002213       271 002233       272 002240       274 002241       275 002264       277 002301       278 002333
    281 002351       282 002376       285 002413       288 002417       289 002423       291 002427       293 002446
    295 002452       297 002456       298 002462       300 002466       301 002507       304 002510       306 002515
    307 002525       309 002551       310 002552       312 002574       313 002600       315 002604       317 002606
    320 002625       322 002651       324 002656       325 002660       326 002665       327 002737       328 002741
    329 002742       330 002744       331 002750       333 002773       335 003002       337 003022       339 003027
    341 003043       342 003065       343 003066       345 003076       347 003123       348 003154       349 003156
    350 003157       352 003164       353 003166       354 003173       356 003213       357 003265       358 003267
    359 003274       360 003364       361 003366       362 003370       363 003374       365 003417       367 003437
    369 003501       371 003544       373 003554       375 003616       377 003624       378 003626       380 003655
    381 003712       384 003746       385 004001       387 004034       389 004042       391 004047       392 004100
    393 004102       395 004133       397 004211       399 004213       401 004263       403 004326       405 004361
    406 004362       407 004363       409 004373       411 004420       412 004451       413 004453       414 004454
    416 004505       418 004537       420 004573       422 004612       423 004615       425 004616       427 004625
    428 004650       429 004652       432 004703       433 004725       436 004734       440 005004       441 005034
    444 005051       446 005053       447 005056       448 005060       449 005064       450 005077       451 005111
    453 005113       454 005117       455 005122       456 005123       459 005150       460 005216       463 005251
    464 005301       466 005310       469 005336       470 005337       471 005364       473 005407       474 005410
    475 005433       477 005461       479 005521       481 005524       482 005567       483 005611       485 005651
    487 005652       489 005730       490 005755       493 005776       495 006015       497 006045       500 006054
    502 006057       503 006100       505 006102       507 006105       509 006113       510 006132       511 006133
    513 006152       515 006153       517 006155       520 006160       522 006161       523 006164       524 006207
    526 006211       530 006214       533 006222       537 006241       540 006251       541 006266       543 006270
    545 006273       547 006274       549 006276       551 006302       554 006303       556 006306       558 006333
    560 006335       563 006367       564 006373       567 006420       572 006441       573 006464       576 006507
    580 006540       583 006544       586 006556       588 006560       589 006565       591 006570       593 006573
    594 006575       596 006576       598 006600       600 006605       602 006610       604 006612       607 006614
    610 006615       613 006620       619 006653       621 006656       624 006657       626 006660       630 006663
    631 006704       634 006730       635 006733       637 006761       638 006764       640 006767       641 006771
    642 007003       643 007005       644 007006       645 007010       646 007027       648 007050       650 007051
    651 007055       653 007112       655 007113       656 007117       658 007144       661 007203       663 007217
    664 007221       666 007223       668 007262       671 007303       673 007304       675 007341       677 007344
    679 007426       682 007513       683 007536       684 007605       685 007607       687 007646       689 007677
    692 007700       694 007722       696 007726       698 007730       699 007731       702 007773       705 010020
    706 010021       707 010034       709 010035       712 010065       713 010066       714 010101       715 010112
    717 010113       720 010127       721 010145       722 010152       724 010175       726 010227       730 010232
    734 010246       735 010264       736 010271       737 010314       740 010346       741 010351       742 010354
    743 010361       745 010366       747 010373       748 010400       751 010412       753 010431       755 010432
    756 010437       757 010442       760 010445       761 010450       765 010451       769 010465       771 010503
    772 010506       773 010525       775 010616       778 010676       782 010677       787 010705       788 010707
    789 010722       791 010726       792 010751       794 010754       796 010757       798 010765       801 011003
    802 011014       804 011031       805 011054       807 011073       809 011106       811 011107       812 011117
    814 011127       817 011130       819 011140       822 011150       824 011203       827 011232       828 011235
    829 011236       830 011243       831 011263       833 011264       834 011270       835 011272       836 011273
    837 011275       838 011311       839 011337       840 011341       841 011343       845 011344       848 011352
    850 011357       851 011365       852 011370       854 011424       856 011427       857 011467       859 011471
    862 011472       864 011473       865 011521       867 011524       868 011544       870 011547       874 011550
    876 011551       880 011764       882 012047       883 012104       884 012122       885 012157       886 012162
    887 012165       888 012172       889 012175       894 012176       896 012177       897 012221       898 012236
    899 012273       900 012276       902 012301       903 012304       905 012305       906 012307       908 012313
    910 012314       912 012317       914 012344       916 012346       917 012400       918 012404       921 012431
    925 012452       926 012475       929 012520       933 012551       936 012563       937 012565       938 012572
    939 012573       941 012574       942 012602       944 012604       949 012605       951 012613       952 012616
    953 012640       954 012644       955 012654       956 012657       957 012660       958 012661       959 012663
    960 012664       961 012665       962 012666       963 012667       964 012670       965 012671       966 012672
    967 012675       968 012676       972 012677       974 012700       975 012704       977 012727       979 012753
    983 013002       985 013007       987 013014       988 013020       989 013031       990 013032       991 013034
    992 013035       993 013037       994 013040       996 013065       998 013067      1000 013074      1001 013100
   1002 013111      1003 013112      1004 013114      1005 013115      1007 013117      1008 013172      1010 013175
   1011 013176      1014 013212      1015 013251      1019 013253      1021 013254      1023 013301      1024 013305
   1025 013315      1027 013330      1029 013337      1031 013347      1033 013356      1035 013365      1037 013375
   1039 013404      1041 013414      1043 013423      1044 013455      1045 013460      1051 013461      1054 013475
   1056 013532      1062 013533      1065 013544      1067 013614      1068 013625      1070 013630      1071 013634
   1072 013640      1073 013641      1075 013643      1076 013654      1078 013673      1081 013722      1084 013751


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
