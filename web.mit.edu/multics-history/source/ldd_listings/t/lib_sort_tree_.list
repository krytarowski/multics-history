	COMPILATION LISTING OF SEGMENT lib_sort_tree_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0858.7 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       12 
       13 
       14 lib_sort_tree_:	procedure;
       15 
       16      dcl	Ptree			ptr,		/* ptr to node tree to be sorted. (In)		*/
       17 	code			fixed bin(35);	/* a status code. (Out)			*/
       18 
       19      dcl	I			fixed bin,	/* do-group index.				*/
       20 	i			fixed bin;	/* do-group index.				*/
       21 
       22      dcl (addr, null)		builtin;
       23 
       24      dcl	sort_items_indirect_$char	entry (ptr, ptr, fixed bin(24));
       25 
       26      dcl	error_table_$nomatch	fixed bin(35) ext static,
       27 	null_name			char(32) aligned int static init ("");
       28 						/* a null name used for nodes without name	*/
       29 						/* descriptors.				*/
       30 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       31 
       32 
       33 make_node_list:	entry	(Ptree, Pnode_list, code);	/* entry to find inner-most tree nodes with	*/
       34 						/*   some node.Sreq bits on;  return a list of	*/
       35 						/*   such nodes.				*/
       36 	code = 0;					/* initialize output code.			*/
       37 	i = node_list.I;				/* remember how many nodes already in list.	*/
       38 	call recurse (Ptree, Pnode_list);		/* scan thru tree, putting desired nodes in list.	*/
       39 	if node_list.I = i then code = error_table_$nomatch;
       40 	return;					/* return error if no nodes found.		*/
       41 
       42 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       43 
       44 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       45 
       46 
       47 make_name_list:	entry	(Ptree, Pname_list, Pindex_list, Pnode_list, code);
       48 						/* entry to put printable nodes of a node tree	*/
       49 						/* into a name list.			*/
       50 
       51 	code = 0;					/* initialize output code.			*/
       52 	i = node_list.I;				/* remember how many nodes are already in list.	*/
       53 	call recurse (Ptree, Pnode_list);		/* scan through the tree, putting printable nodes	*/
       54 						/* into the node list.			*/
       55 	if node_list.I = i then do;			/* if no outputable entries were found,		*/
       56 	     code = error_table_$nomatch;		/* return an error.				*/
       57 	     return;
       58 	     end;
       59 	do I = i+1 to node_list.I;			/* make the name_list elements point to the	*/
       60 						/* primary name of nodes in the node list.	*/
       61 	     Pnode = node_list.e(I);			/* first, access node pointed to by node list	*/
       62 						/* element.				*/
       63 	     if Svalid.names then do;			/* if node has a name descriptor, then		*/
       64 		do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
       65 		     end;				/* access the name descriptor;		*/
       66 		name_list.e(I) = addr (Dnames.names(1));/* make name_list element point to first name.	*/
       67 		index_list.e(I) = I;		/* initialize index list.			*/
       68 		if Sreq.cross_ref then 		/* if all names on node are to be cross referenced*/
       69 		     do i = 2 to Dnames.N while (node_list.I < node_list.N);
       70 			node_list.I = node_list.I + 1;/* add the rest of it's names to the name list.	*/
       71 			node_list.e(node_list.I) = Pnode;
       72 			name_list.e(node_list.I) = addr (Dnames.names(i));
       73 			index_list.e(node_list.I) = node_list.I;
       74 			end;
       75 		end;
       76 	     else do;				/* if node has no names, then point to a null name*/
       77 		name_list.e(I) = addr (null_name);
       78 		index_list.e(I) = I;
       79 		end;
       80 	     end;
       81 	name_list.I = node_list.I;			/* set number of name list and index list elements*/
       82 	index_list.I = node_list.I;			/* equal to the number of elements in node list.	*/
       83 	return;					/* All done!				*/
       84 
       85 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       86 
       87 
       88 name_list:	entry	(Pname_list, Pindex_list);	/* entry to sort a name list.			*/
       89 
       90 	if name_list.I > 1 then			/* if there's more than one matching node,	*/
       91 	     call sort_items_indirect_$char (addr(name_list.I), addr(index_list.I), 32);
       92 						/* sort the elements of index_list.e into order	*/
       93 						/* so that:				*/
       94 						/*    name_list.e(index_list.e(i))->based_name <=	*/
       95 						/*       name_list.e(index_list.e(j))->based_name	*/
       96 						/* for all i < j.				*/
       97 	else					/* otherwise, fill in the only item's index list.	*/
       98 	     index_list.e(1) = 1;
       99 	return;					/* All done!				*/
      100 
      101 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      102 
      103 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      104 
      105 
      106 recurse:	procedure (PDnodes_, Pnode_list);		/* Recursive internal procedure to scan node tree	*/
      107 						/* looking for printable nodes to put into the	*/
      108      dcl	PDnodes_			ptr,		/* node list.				*/
      109 	Pnode_list		ptr;
      110 
      111      dcl	PD_			ptr,		/* ptr to a node array descriptor.		*/
      112 	Pnode_			ptr,		/* ptr to a node.				*/
      113 	i			fixed bin;	/* do-group index.				*/
      114 
      115      dcl	1 D_			aligned based (PD_) like D,
      116 						/* a kid's node array descriptor.		*/
      117 	1 Dnodes_			aligned based (PDnodes_),
      118 						/* node array to be scanned for outputable nodes.	*/
      119 	  2 header		like Dnodes.header,
      120 	  2 nodes (Nnodes refer (Dnodes_.N))
      121 				like node,
      122 
      123 	1 Sreq			aligned based (addr (node_.Sreq)) like Svalid_req,
      124 						/* switches defining which node data is required.	*/
      125 	1 Svalid			aligned based (addr (node_.Svalid)) like Svalid_req,
      126 						/* switches defining which node data is valid.	*/
      127 	1 node_			aligned based (Pnode_) like node,
      128 						/* a node.				*/
      129 	1 node_list		aligned based (Pnode_list),
      130 	  2 N			fixed bin,	/* the node list.				*/
      131 	  2 I			fixed bin,
      132 	  2 e (0 refer (node_list.I)) ptr unaligned;
      133 
      134 
      135 	do i = 1 to Dnodes_.N while (node_list.I < node_list.N);
      136 						/* scan all nodes in node array at this tree level*/
      137 						/* or until our node list is full.		*/
      138 	     Pnode_ = addr (Dnodes_.nodes(i));		/* address the ith node of the node array.	*/
      139 	     if node_.Pparent ^= null then		/* if node has a parent then if its parent is	*/
      140 		if node_.Pparent -> node_.Sreq then	/*    outputable, only put the node into the	*/
      141 		     if Sreq.cross_ref then;		/*    node list if it is to be cross-referenced.	*/
      142 		     else go to skip_it;		/* otherwise, do _n_o_t add to list.		*/
      143 	     if node_.Sreq then do;			/* if node can be output, then:		*/
      144 		node_list.I = node_list.I + 1;	/* get index of next node list element.		*/
      145 		node_list.e(node_list.I) = Pnode_;	/* put pointer to node in node list.		*/
      146 		if node_.T ^= Tlink then		/* if this outputable node is not a link or msf,	*/
      147 		     if node_.T ^= Tmsf then		/* add any of its kids to the node list too.	*/
      148 			if Svalid.kids then do;
      149 			     do PD_ = node_.PD repeat D_.Pnext while (D_.T ^= Tnodes);
      150 				end;
      151 			     call recurse (PD_, Pnode_list);
      152 			     end;
      153 		end;
      154 
      155 	     else if Svalid.kids then do;		/* if this node is not outputable, see if any of	*/
      156 						/* it's kids are.				*/
      157 		do PD_ = node_.PD repeat D_.Pnext while (D_.T ^= Tnodes);
      158 		     end;
      159 		call recurse (PD_, Pnode_list);
      160 		end;
      161 skip_it:	     end;
      162 
      163 	end recurse;
      164 
      165 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     1 /* START OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* Name:  lib_list_.incl.pl1							*/
  1     6 	/*									*/
  1     7 	/*      This segment declares the list structures which are used by the library 	*/
  1     8 	/* maintenance tools.  The structures are filled in by lib_sort_tree_, and referenced by	*/
  1     9 	/* lib_output_node_list_, having been allocated originally by one of the maintenance	*/
  1    10 	/* commands (library_map, library_info, library_print, etc).			*/
  1    11 	/*									*/
  1    12 	/* Status									*/
  1    13 	/*									*/
  1    14 	/* 0) Created on:  May 30, 1976  by  G. C. Dixon					*/
  1    15 	/*									*/
  1    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    17 
  1    18 
  1    19      dcl	1 index_list		aligned based (Pindex_list),
  1    20 						/* an index list.				*/
  1    21 	  2 N			fixed bin(24),	/* max length of list.			*/
  1    22 	  2 I			fixed bin(24),	/* current length of list.			*/
  1    23 	  2 e (max_entries refer (index_list.N))
  1    24 				fixed bin(24),	/* the list.				*/
  1    25 	1 name_list		aligned based (Pname_list),
  1    26 						/* a name list.				*/
  1    27 	  2 N			fixed bin(24),	/* max length of list.			*/
  1    28 	  2 I			fixed bin(24),	/* current length of list.			*/
  1    29 	  2 e (max_entries refer (name_list.N))	ptr unal,	/* list of ptrs to node names.		*/
  1    30 	1 node_list		aligned based (Pnode_list),
  1    31 						/* a list of ptrs to nodes to be output.	*/
  1    32 	  2 N			fixed bin(24),	/* max length of list.			*/
  1    33 	  2 I			fixed bin(24),	/* current length of list.			*/
  1    34 	  2 e (max_entries refer (node_list.N))	ptr unal,	/* list of ptrs to nodes.			*/
  1    35 	1 page_list		aligned based (Ppage_list),
  1    36 						/* list of page numbers on which each node was	*/
  1    37 						/* output.				*/
  1    38 	  2 N			fixed bin(24),	/* max length of list.			*/
  1    39 	  2 I			fixed bin(24),	/* current length of list.			*/
  1    40 	  2 e (max_entries refer (page_list.N))	
  1    41 				fixed bin(24),	/* list of page numbers.			*/
  1    42 	max_entries		fixed bin int static init (32000),
  1    43 	Pindex_list		ptr,		/* ptr to index_list structure.		*/
  1    44 	Pname_list		ptr,		/* ptr to name_list structure.		*/
  1    45 	Pnode_list		ptr,		/* ptr to node_list structure.		*/
  1    46 	Ppage_list		ptr;		/* ptr to page_list structure.		*/
  1    47 
  1    48 /* END OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      166 
      167 
  2     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  2     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  2     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  2    10 	/* called the node target.							*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  2    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  2    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  2    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  2    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  2    19 	/*									*/
  2    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 
  2    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    23 	/*									*/
  2    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  2    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  2    26 	/* both types of nodes are the same length.					*/
  2    27 	/*									*/
  2    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    29 
  2    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  2    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  2    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  2    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  2    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  2    35 						/*             (= node.Svalid & Srequirements)	*/
  2    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  2    37 	  2 switches		unaligned,
  2    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  2    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  2    40 						/* 	     entry before lib_access_mode_$set.	*/
  2    41 	    3 pad			bit(22),
  2    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  2    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  2    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  2    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  2    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  2    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  2    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  2    49 						/*	     in this directory;  if off, records*/
  2    50 						/*	     charged against 1st superior	*/
  2    51 						/*	     directory with switch on.	*/
  2    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  2    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  2    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  2    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  2    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  2    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  2    58 
  2    59 						/* From here on, link_nodes differ from nodes	*/
  2    60 						/*  for other types of node targets.		*/
  2    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  2    62 
  2    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    64 	/*									*/
  2    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  2    66 	/*									*/
  2    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    68 
  2    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  2    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  2    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  2    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  2    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  2    74 						/*             (= node.Svalid & Srequirements)	*/
  2    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  2    76 	  2 switches		unaligned,
  2    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  2    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  2    79 						/* 	     entry before lib_access_mode_$set.	*/
  2    80 	    3 pad			bit(22),
  2    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  2    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  2    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  2    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  2    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  2    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  2    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  2    88 						/*	     in this directory;  if off, records*/
  2    89 						/*	     charged against 1st superior	*/
  2    90 						/*	     directory with switch on.	*/
  2    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  2    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  2    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  2    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  2    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  2    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  2    97 
  2    98 						/* From here on, other nodes differ from	*/
  2    99 						/*  link_nodes.				*/
  2   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  2   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  2   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  2   103 	  2 pad1 (1)		fixed bin,
  2   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  2   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  2   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  2   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  2   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  2   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  2   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  2   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  2   112 						/*             component from the base of archive.*/
  2   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  2   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  2   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  2   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  2   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  2   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  2   119 						/*	     updated.			*/
  2   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  2   121 						/*	     directories with Sterminal_account	*/
  2   122 						/*	     on.				*/
  2   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  2   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  2   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  2   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  2   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  2   128 						/*	     updated.			*/
  2   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  2   130 						/*	     directories with Sterminal_account	*/
  2   131 						/*	     on.				*/
  2   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  2   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  2   134 	  2 pad2 (5)		fixed bin,
  2   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  2   136 
  2   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   138 	/*									*/
  2   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  2   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  2   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  2   142 	/* descriptors are the only ones that have been defined.				*/
  2   143 	/*									*/
  2   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   145 
  2   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  2   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  2   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  2   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  2   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  2   152 
  2   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  2   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  2   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  2   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   163 	    3 zero_pad		bit(36),
  2   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  2   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  2   167 	Vacl_1			fixed bin int static options(constant) init (1),
  2   168 						/* version:   version of ACL descriptor.	*/
  2   169 	Tacl			fixed bin int static options(constant) init (7);
  2   170 						/* attribute: type of a segment ACL descriptor.	*/
  2   171 
  2   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  2   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  2   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  2   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  2   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  2   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  2   186 						/* version:   version of directory ACL descriptor.*/
  2   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  2   188 						/* attribute: type of a directory ACL descriptor.	*/
  2   189 
  2   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  2   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  2   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  2   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  2   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  2   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  2   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  2   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  2   206 						/* version:   version of dir IACL descriptor.	*/
  2   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  2   208 
  2   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  2   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  2   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  2   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  2   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  2   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  2   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  2   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  2   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  2   221 	    3 zero_pad		bit(36),
  2   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  2   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  2   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  2   225 	Viacl_1			fixed bin int static options(constant) init (1),
  2   226 						/* version:   version of segment IACL descriptor.	*/
  2   227 	Tiacl			fixed bin int static options(constant) init (10);
  2   228 						/* attribute: type of a segment IACL descriptor.	*/
  2   229 
  2   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  2   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  2   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  2   236 	  2 names (Nnames refer (Dnames.N))
  2   237 				char(32),		/* attribute: names.			*/
  2   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  2   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  2   240 	Vnames_1			fixed bin int static options(constant) init (1),
  2   241 						/* version:   version of names descriptor.	*/
  2   242 	Tnames			fixed bin int static options(constant) init (1);
  2   243 						/* attribute: type of a name descriptor.	*/
  2   244 
  2   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  2   246 						/* nodes.					*/
  2   247 	  2 header,
  2   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  2   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  2   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  2   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  2   255 				like node,
  2   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  2   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  2   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  2   259 						/* version:   version of nodes descriptor.	*/
  2   260 	Tnodes			fixed bin int static options(constant) init (2);
  2   261 						/* attribute: type of a node descriptor.	*/
  2   262 
  2   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  2   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  2   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   268 	  2 info,
  2   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  2   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  2   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  2   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  2   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  2   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  2   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  2   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  2   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  2   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  2   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  2   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  2   281 	    3 format		aligned,
  2   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  2   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  2   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  2   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  2   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  2   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  2   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  2   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  2   290 	      4 pad		bit(28) unal,
  2   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  2   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  2   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  2   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  2   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  2   296 	    3 cversion,				/* attribite: compiler version string.		*/
  2   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  2   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  2   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  2   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  2   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  2   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  2   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  2   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  2   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  2   306 	Vobj_1			fixed bin int static options(constant) init (1),
  2   307 						/* version:   version of object_info_ descriptor.	*/
  2   308 	Tobj			fixed bin int static options(constant) init (3);
  2   309 						/* attribute: type of a node descriptor.	*/
  2   310 
  2   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  2   312 						/* library root search_proc attribute descriptor.	*/
  2   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  2   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  2   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  2   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  2   320 						/* version:   version of search_proc info descrip.*/
  2   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  2   322 						/* attribute: type of a search_proc descriptor.	*/
  2   323 
  2   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  2   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  2   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  2   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  2   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  2   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  2   330 						/*            output.			*/
  2   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  2   332 	  2 info			char(Luser refer (Duser.L)),
  2   333 						/* attribute: user info string.		*/
  2   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  2   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  2   336 	Vuser_1			fixed bin int static options(constant) init (1),
  2   337 						/* version:   version of user info descriptor.	*/
  2   338 	Tuser			fixed bin int static options(constant) init (6);
  2   339 						/* attribute: type of a user descriptor.	*/
  2   340 
  3     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the switches which request/validate the fields	*/
  3     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  3     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  3    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  3    11 	/* descriptor commands to obtain information about entries in a library.		*/
  3    12 	/*									*/
  3    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  3    14 	/* is requested for output.							*/
  3    15 	/*									*/
  3    16 	/* S__t_a_t_u_s									*/
  3    17 	/*									*/
  3    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  3    19 	/*									*/
  3    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    21 
  3    22 
  3    23      dcl	1 Svalid_req		aligned based,
  3    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  3    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  3    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  3    27 
  3    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  3    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  3    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  3    31 
  3    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  3    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  3    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  3    35 
  3    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  3    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  3    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  3    39 
  3    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  3    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  3    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  3    43 
  3    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  3    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  3    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  3    47 
  3    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  3    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  3    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  3    51 
  3    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  3    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  3    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  3    55 
  3    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  3    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  3    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  3    59 
  3    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  3    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  3    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  3    63 
  3    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  3    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  3    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  3    67 
  3    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  3    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  3    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  3    71 
  3    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  3    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  3    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  3    75 
  3    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  3    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  3    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  3    79 	  2 pad			bit(26) unal,
  3    80 
  3    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  3    82 
  3    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  3    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  3    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  3    86 
  3    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    88 	/*									*/
  3    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  3    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  3    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  3    92 	/*									*/
  3    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    94 
  3    95 
  3    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  3    97 	Srequirements		bit(72) aligned;
  3    98 
  3    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   341 
  2   342 
  2   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  2   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  2   345 
  4     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  4     6 	/*									*/
  4     7 	/*      This include segment defines the control switches used by library descriptor	*/
  4     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  4     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  4    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  4    11 	/* to the lib_descriptor_ subroutine.						*/
  4    12 	/*									*/
  4    13 	/* S__t_a_t_u_s									*/
  4    14 	/*									*/
  4    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  4    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  4    17 	/*									*/
  4    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    19 
  4    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  4    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  4    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  4    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  4    24 
  4    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  4    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  4    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  4    28 						/*         nodes of the tree, and about all the	*/
  4    29 						/*	 nodes below the parent.		*/
  4    30 
  4    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  4    32 						/*         nodes of the tree.			*/
  4    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  4    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  4    35 
  4    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  4    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  4    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  4    39 						/*         deletion.			*/
  4    40 
  4    41 	  2 pad			bit(10) unal,
  4    42 
  4    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  4    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  4    45 
  4    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  4    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  4    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  4    49 
  4    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  4    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  4    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  4    53 
  4    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  4    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  4    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  4    57 
  4    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  4    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  4    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  4    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  4    62 
  4    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   346 
  2   347 
  2   348 
  2   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   350 	/*									*/
  2   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  2   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  2   353 	/* that:		mod (type, 2) = 1;						*/
  2   354 	/*									*/
  2   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   356 
  2   357 
  2   358      dcl (Tlink			init (0),
  2   359 	Tsegment			init (1),
  2   360 	Tdirectory		init (2),
  2   361 	Tmsf			init (3),
  2   362 	Tmsf_comp			init (4),
  2   363 	Tarchive			init (5),
  2   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  2   365 
  2   366 
  2   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   368 	/*									*/
  2   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  2   370 	/* Both brief and long string arrays are provided.				*/
  2   371 	/*									*/
  2   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2   373 
  2   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  2   375 				"link",
  2   376 				"segment",
  2   377 				"directory",
  2   378 				"multisegment file",
  2   379 				"multi-segment file component",
  2   380 				"archive",
  2   381 				"archive component"),
  2   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  2   383 				"link",
  2   384 				"segment",
  2   385 				"directory",
  2   386 				"msf",
  2   387 				"msf comp",
  2   388 				"archive",
  2   389 				"arch comp");
  2   390 
  2   391 
  2   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      168 
      169 
      170 
      171 
      172 	end lib_sort_tree_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0819.1  lib_sort_tree_.pl1                >special_ldd>on>6588>lib_sort_tree_.pl1
166          1    02/28/77  1409.2  lib_list_.incl.pl1                >ldd>include>lib_list_.incl.pl1
168          2    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
2-341        3    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
2-346        4    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
D                                      based           structure                level 1 unaligned dcl 2-146
D_                                     based           structure                level 1 dcl 115
Dnames                                 based           structure                level 1 unaligned dcl 2-230
Dnodes                                 based           structure                level 1 unaligned dcl 2-245
Dnodes_                                based           structure                level 1 dcl 115
I                         1            based           fixed bin(17,0)          level 2 in structure "node_list" dcl 115
                                                                                  in procedure "recurse" set ref 135 144* 144 145
I                         1            based           fixed bin(24,0)          level 2 in structure "node_list" dcl 1-19
                                                                                  in procedure "lib_sort_tree_" set ref 37 39 52 55
                                                                                  59 68 70* 70 71 72 73 73 81 82
I                         1            based           fixed bin(24,0)          level 2 in structure "name_list" dcl 1-19
                                                                                  in procedure "lib_sort_tree_" set ref 81* 90 90 90
I                               000100 automatic       fixed bin(17,0)          dcl 19 in procedure "lib_sort_tree_" set ref 59* 61
                                                                                  66 67 67 77 78 78*
I                         1            based           fixed bin(24,0)          level 2 in structure "index_list" dcl 1-19
                                                                                  in procedure "lib_sort_tree_" set ref 82* 90 90
N                                      based           fixed bin(24,0)          level 2 in structure "node_list" dcl 1-19
                                                                                  in procedure "lib_sort_tree_" ref 68
N                         4            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 2-230 in procedure
                                                                                  "lib_sort_tree_" ref 68
N                                      based           fixed bin(17,0)          level 2 in structure "node_list" dcl 115
                                                                                  in procedure "recurse" ref 135
N                         5            based           fixed bin(17,0)          level 3 in structure "Dnodes_" dcl 115 in procedure
                                                                                  "recurse" ref 135
PD                        2            based           pointer                  level 2 in structure "node_" dcl 115 in procedure
                                                                                  "recurse" ref 149 157
PD                        2            based           pointer                  level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "lib_sort_tree_" ref 64
PD_                             000100 automatic       pointer                  dcl 111 set ref 149* 149* 150 151* 157* 157* 158
                                                                                  159*
PDnames                         000104 automatic       pointer                  dcl 2-230 set ref 64* 64* 65 66 68 72
PDnodes_                               parameter       pointer                  dcl 108 ref 106 135 138
Pindex_list                            parameter       pointer                  dcl 1-19 ref 47 67 73 78 82 88 90 90 97
Pname_list                             parameter       pointer                  dcl 1-19 ref 47 66 72 77 81 88 90 90 90
Pnext                     2            based           pointer                  level 2 in structure "Dnames" dcl 2-230 in procedure
                                                                                  "lib_sort_tree_" ref 65
Pnext                     2            based           pointer                  level 2 in structure "D_" dcl 115 in procedure
                                                                                  "recurse" ref 150 158
Pnode                           000102 automatic       pointer                  dcl 2-69 set ref 61* 63 64 68 71
Pnode_                          000102 automatic       pointer                  dcl 111 set ref 138* 139 139 139 143 145 146 146 146
                                                                                  149 155 157
Pnode_list                             parameter       pointer                  dcl 1-19 in procedure "lib_sort_tree_" set ref 33 37
                                                                                  38* 39 47 52 53* 55 59 61 68 68 70 70 71 71 72 73
                                                                                  73 81 82
Pnode_list                             parameter       pointer                  dcl 108 in procedure "recurse" set ref 106 135 135
                                                                                  144 144 145 145 151* 159*
Pparent                                based           pointer                  level 2 dcl 115 ref 139 139
Ptree                                  parameter       pointer                  dcl 16 set ref 33 38* 47 53*
Sreq                                   based           structure                level 1 dcl 115 in procedure "recurse"
Sreq                      6            based           bit(72)                  level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "lib_sort_tree_" set ref 68
Sreq                      6            based           bit(72)                  level 2 in structure "node_" dcl 115 in procedure
                                                                                  "recurse" set ref 139 139 143
Sreq                                   based           structure                level 1 dcl 2-343 in procedure "lib_sort_tree_"
Svalid                    4            based           bit(72)                  level 2 in structure "node_" dcl 115 in procedure
                                                                                  "recurse" set ref 146 155
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 2-69 in procedure
                                                                                  "lib_sort_tree_" set ref 63
Svalid                                 based           structure                level 1 dcl 115 in procedure "recurse"
Svalid                                 based           structure                level 1 dcl 2-343 in procedure "lib_sort_tree_"
Svalid_req                             based           structure                level 1 dcl 3-23
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 2-230 in procedure
                                                                                  "lib_sort_tree_" ref 64
T                         1            based           fixed bin(17,0)          level 2 in structure "D_" dcl 115 in procedure
                                                                                  "recurse" ref 149 157
T                        10            based           fixed bin(35,0)          level 2 in structure "node_" dcl 115 in procedure
                                                                                  "recurse" ref 146 146
Tlink                                  constant        fixed bin(17,0)          initial dcl 2-358 ref 146
Tmsf                                   constant        fixed bin(17,0)          initial dcl 2-358 ref 146
Tnames                                 constant        fixed bin(17,0)          initial dcl 2-230 ref 64
Tnodes                                 constant        fixed bin(17,0)          initial dcl 2-245 ref 149 157
addr                                                   builtin function         dcl 22 ref 63 66 68 72 77 90 90 90 90 138 139 146
                                                                                  155
code                                   parameter       fixed bin(35,0)          dcl 16 set ref 33 36* 39* 47 51* 56*
cross_ref                 1(33)        based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 2-343 in procedure "lib_sort_tree_" ref 68
cross_ref                 1(33)        based           bit(1)                   level 2 in structure "Sreq" packed unaligned dcl 115
                                                                                  in procedure "recurse" ref 139
e                         2            based           pointer                  array level 2 in structure "node_list" packed
                                                                                  unaligned dcl 115 in procedure "recurse" set ref
                                                                                  145*
e                         2            based           pointer                  array level 2 in structure "name_list" packed
                                                                                  unaligned dcl 1-19 in procedure "lib_sort_tree_"
                                                                                  set ref 66* 72* 77*
e                         2            based           fixed bin(24,0)          array level 2 in structure "index_list" dcl 1-19
                                                                                  in procedure "lib_sort_tree_" set ref 67* 73* 78*
                                                                                  97*
e                         2            based           pointer                  array level 2 in structure "node_list" packed
                                                                                  unaligned dcl 1-19 in procedure "lib_sort_tree_"
                                                                                  set ref 61 71*
error_table_$nomatch            000022 external static fixed bin(35,0)          dcl 26 ref 39 56
header                                 based           structure                level 2 in structure "Dnodes_" dcl 115 in procedure
                                                                                  "recurse"
header                                 based           structure                level 2 in structure "Dnodes" unaligned dcl 2-245
                                                                                  in procedure "lib_sort_tree_"
i                               000101 automatic       fixed bin(17,0)          dcl 19 in procedure "lib_sort_tree_" set ref 37* 39
                                                                                  52* 55 59 68* 72*
i                               000104 automatic       fixed bin(17,0)          dcl 111 in procedure "recurse" set ref 135* 138*
index_list                             based           structure                level 1 dcl 1-19
kids                      0(04)        based           bit(1)                   level 2 packed unaligned dcl 115 ref 146 155
name_list                              based           structure                level 1 dcl 1-19
names                     0(02)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 2-343 in procedure "lib_sort_tree_" ref 63
names                     5            based           char(32)                 array level 2 in structure "Dnames" packed unaligned
                                                                                  dcl 2-230 in procedure "lib_sort_tree_" set ref 66
                                                                                  72
node                                   based           structure                level 1 unaligned dcl 2-69
node_                                  based           structure                level 1 dcl 115
node_list                              based           structure                level 1 dcl 1-19 in procedure "lib_sort_tree_"
node_list                              based           structure                level 1 dcl 115 in procedure "recurse"
nodes                     6            based           structure                array level 2 dcl 115 set ref 138
null                                                   builtin function         dcl 22 ref 139
null_name                       000010 internal static char(32)                 initial dcl 26 set ref 77
sort_items_indirect_$char       000020 constant        entry                    external dcl 24 ref 90

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Dacl                                   based           structure                level 1 unaligned dcl 2-153
Ddir_acl                               based           structure                level 1 unaligned dcl 2-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 2-190
Diacl                                  based           structure                level 1 unaligned dcl 2-209
Dobj                                   based           structure                level 1 unaligned dcl 2-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 2-311
Duser                                  based           structure                level 1 unaligned dcl 2-324
Luser                                  automatic       fixed bin(17,0)          dcl 2-324
Nacls                                  automatic       fixed bin(17,0)          dcl 2-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 2-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 2-190
Niacls                                 automatic       fixed bin(17,0)          dcl 2-209
Nnames                                 automatic       fixed bin(17,0)          dcl 2-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 2-245
PD                                     automatic       pointer                  dcl 2-146
PDacl                                  automatic       pointer                  dcl 2-153
PDdir_acl                              automatic       pointer                  dcl 2-172
PDdir_iacl                             automatic       pointer                  dcl 2-190
PDiacl                                 automatic       pointer                  dcl 2-209
PDnodes                                automatic       pointer                  dcl 2-245
PDobj                                  automatic       pointer                  dcl 2-263
PDsearch_proc                          automatic       pointer                  dcl 2-311
PDuser                                 automatic       pointer                  dcl 2-324
Ppage_list                             automatic       pointer                  dcl 1-19
S                                      based           structure                level 1 dcl 3-96
Sc                                     based           structure                level 1 dcl 4-20
Scontrol                               automatic       bit(36)                  dcl 4-20
Srequirements                          automatic       bit(72)                  dcl 3-96
Tacl                                   internal static fixed bin(17,0)          initial dcl 2-153
Tarchive                               internal static fixed bin(17,0)          initial dcl 2-358
Tarchive_comp                          internal static fixed bin(17,0)          initial dcl 2-358
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 2-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 2-190
Tdirectory                             internal static fixed bin(17,0)          initial dcl 2-358
Tiacl                                  internal static fixed bin(17,0)          initial dcl 2-209
Tmsf_comp                              internal static fixed bin(17,0)          initial dcl 2-358
Tobj                                   internal static fixed bin(17,0)          initial dcl 2-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 2-311
Tsegment                               internal static fixed bin(17,0)          initial dcl 2-358
Tuser                                  internal static fixed bin(17,0)          initial dcl 2-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 2-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 2-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 2-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 2-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 2-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 2-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 2-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 2-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 2-324
brief_node_type                        internal static varying char(12)         initial array dcl 2-374
link_node                              based           structure                level 1 unaligned dcl 2-30
max_entries                            internal static fixed bin(17,0)          initial dcl 1-19
node_type                              internal static varying char(32)         initial array dcl 2-374
page_list                              based           structure                level 1 dcl 1-19

NAMES DECLARED BY EXPLICIT CONTEXT.
lib_sort_tree_                  000005 constant        entry                    external dcl 14
make_name_list                  000065 constant        entry                    external dcl 47
make_node_list                  000017 constant        entry                    external dcl 33
name_list                       000267 constant        entry                    external dcl 88
recurse                         000340 constant        entry                    internal dcl 106 ref 38 53 151 159
skip_it                         000501 constant        label                    dcl 161 ref 139

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       606         632     504         616
Length      1074     504        24         226     102          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_sort_tree_                       97 external procedure  is an external procedure.  
recurse                              78 internal procedure  calls itself recursively.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 null_name                   lib_sort_tree_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_sort_tree_           000100 I                           lib_sort_tree_
                         000101 i                           lib_sort_tree_
                         000102 Pnode                       lib_sort_tree_
                         000104 PDnames                     lib_sort_tree_
recurse                  000100 PD_                         recurse
                         000102 Pnode_                      recurse
                         000104 i                           recurse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        call_int_this       call_int_other      return              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sort_items_indirect_$char

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$nomatch




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000004        33 000012        36 000031        37 000032        38 000036        39 000047        40 000057
     47 000060        51 000103        52 000104        53 000110        55 000121        56 000126        57 000131
     59 000132        61 000141        63 000145        64 000150        65 000156        66 000161        67 000166
     68 000172        70 000213        71 000214        72 000217        73 000226        74 000232        75 000234
     77 000235        78 000242        79 000245        80 000246        81 000250        82 000256        83 000262
     88 000263        90 000301        97 000332        99 000336       106 000337       135 000345       138 000365
    139 000373       143 000407       144 000413       145 000414       146 000416       149 000425       150 000434
    151 000437       153 000451       155 000452       157 000455       158 000464       159 000467       161 000501
    163 000503


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
