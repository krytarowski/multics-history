	COMPILATION LISTING OF SEGMENT !BBBJPQgclKlWpd
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1358.4 mst Tue
	    Options: table map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: off */
        7 
        8 structure_library_3_:
        9      procedure ();
       10 
       11 /* First come all the structures */
       12 
  1     1 
  1     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  1     3 
  1     4 dcl  dcwp ptr,					/* pointer to DCW */
  1     5      tdcwp ptr;					/* pointer to TDCW */
  1     6 
  1     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  1     8      (2 address bit (18),				/* address for data transfer */
  1     9       2 char_pos bit (3),				/* character position */
  1    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  1    11       2 type bit (2),				/* DCW type */
  1    12       2 tally bit (12)) unal;				/* tally for data transfer */
  1    13 
  1    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  1    15      (2 address bit (18),				/* address to transfer to */
  1    16       2 mbz1 bit (4),
  1    17       2 type bit (2),				/* should be "10"b for TDCW */
  1    18       2 mbz2 bit (9),
  1    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  1    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  1    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  1    22 
  1    23 /* End of include file ...... iom_dcw.incl.pl1 */
  1    24 
       13 
       14    dcl 1 iom_ddcw aligned like dcw based;
       15    call add ("iom_ddcw", addr (p -> iom_ddcw));
       16    dcl 1 iom_tdcw aligned like tdcw based;
       17    call add ("iom_tdcw", addr (p -> iom_tdcw));
  2     1 
  2     2 /* Begin include file ...... iom_lpw.incl.pl1 */
  2     3 /*	modified 3/4/75 by Noel I. Morris	*/
  2     4 
  2     5 dcl  lpwp ptr,					/* pointer to LPW */
  2     6      lpwep ptr;					/* pointer to LPW extension */
  2     7 
  2     8 dcl 1 lpw based (lpwp) aligned,			/* List Pointer Word */
  2     9      (2 dcw_addr bit (18),				/* address of DCW list */
  2    10       2 res bit (1),				/* "1"b to restrict use of IDCW */
  2    11       2 iom_rel bit (1),				/* IOM controlled copy of REL bit */
  2    12       2 ae bit (1),					/* "1"b to use addr extension for DCW list service */
  2    13       2 nc bit (1),					/* "1"b to supress LPW tally update */
  2    14       2 tal bit (1),				/* "1"b to enable tally runout fault */
  2    15       2 rel bit (1),				/* "1"b to set relative mode */
  2    16       2 tally bit (12)) unal;				/* LPW tally */
  2    17 
  2    18 dcl 1 lpw_ext based (lpwep) aligned,			/* List Pointer Word Extension */
  2    19      (2 base bit (9),				/* relative addressing base */
  2    20       2 bound bit (9),				/* relative addressing bound */
  2    21       2 idcwp bit (18)) unal;				/* address of last IDCW */
  2    22 
  2    23 /* End of include file ...... iom_lpw.incl.pl1 */
  2    24 
       18 
       19    dcl 1 iom_lpw aligned like lpw based;
       20    call add ("iom_lpw", addr (p -> iom_lpw));
       21    dcl 1 iom_lpw_ext aligned like lpw_ext based;
       22    call add ("iom_lpw_ext", addr (p -> iom_lpw_ext));
  3     1 
  3     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  3     3 
  3     4 dcl  pcwp ptr;					/* pointer to PCW */
  3     5 
  3     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  3     7      (2 command bit (6),				/* device command */
  3     8       2 device bit (6),				/* device code */
  3     9       2 ext bit (6),				/* address extension */
  3    10       2 code bit (3),				/* should be "111"b for PCW */
  3    11       2 mask bit (1),				/* channel mask bit */
  3    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  3    13       2 chan_cmd bit (6),				/* type of I/O operation */
  3    14       2 count bit (6),				/* record count or control character */
  3    15       2 mbz1 bit (3),
  3    16       2 channel bit (6),				/* channel number */
  3    17       2 mbz2 bit (27)) unal;
  3    18 
  3    19 dcl  idcwp ptr;					/* pointer to IDCW */
  3    20 
  3    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  3    22      (2 command bit (6),				/* device command */
  3    23       2 device bit (6),				/* device code */
  3    24       2 ext bit (6),				/* address extension */
  3    25       2 code bit (3),				/* should be "111"b for PCW */
  3    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  3    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  3    28       2 chan_cmd bit (6),				/* type of I/O operation */
  3    29       2 count bit (6)) unal;				/* record count or control character */
  3    30 
  3    31 /* End include file ...... iom_pcw.incl.pl1 */
  3    32 
       23 
       24    dcl 1 iom_pcw aligned like pcw based;
       25    call add ("iom_pcw", addr (p -> iom_pcw));
       26    dcl 1 iom_idcw aligned like idcw based;
       27    call add ("iom_idcw", addr (p -> iom_idcw));
  4     1 
  4     2 /* Begin include file ...... iom_scw.incl.pl1 */
  4     3 
  4     4 dcl  scwp ptr;					/* pointer to SCW */
  4     5 
  4     6 dcl 1 scw based (scwp) aligned,			/* Status Control Word */
  4     7      (2 address bit (18),				/* address of status queue */
  4     8       2 lq bit (2),					/* list/queue control */
  4     9       2 mbz bit (4),
  4    10       2 tally bit (12)) unal;				/* status queue is 1 word longer than tally */
  4    11 
  4    12 /* End of include file ...... iom_scw.incl.pl1 */
  4    13 
       28 
       29    dcl 1 iom_scw aligned like scw based;
       30    call add ("iom_scw", addr (p -> iom_scw));
  5     1 /* BEGIN INCLUDE FILE its.incl.pl1
  5     2*   modified 27 July 79 by JRDavis to add its_unsigned
  5     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  5     4 
  5     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  5     6     2 pad1 bit (3) unaligned,
  5     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  5     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  5     9     2 pad2 bit (9) unaligned,
  5    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  5    11 
  5    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  5    13     2 pad3 bit (3) unaligned,
  5    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  5    15     2 pad4 bit (3) unaligned,
  5    16     2 mod bit (6) unaligned;				/* further modification */
  5    17 
  5    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  5    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  5    20     2 pad1 bit (27) unaligned,
  5    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  5    22 
  5    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  5    24     2 pad2 bit (3) unaligned,
  5    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  5    26     2 pad3 bit (3) unaligned,
  5    27     2 mod bit (6) unaligned;				/* further modification */
  5    28 
  5    29 
  5    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  5    31     2 pad1 bit (3) unaligned,
  5    32     2 segno fixed bin (15) unsigned unaligned,
  5    33     2 ringno fixed bin (3) unsigned unaligned,
  5    34     2 pad2 bit (9) unaligned,
  5    35     2 its_mod bit (6) unaligned,
  5    36 
  5    37     2 offset fixed bin (18) unsigned unaligned,
  5    38     2 pad3 bit (3) unaligned,
  5    39     2 bit_offset fixed bin (6) unsigned unaligned,
  5    40     2 pad4 bit (3) unaligned,
  5    41     2 mod bit (6) unaligned;
  5    42 
  5    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  5    44     2 pr_no fixed bin (3) unsigned unaligned,
  5    45     2 pad1 bit (27) unaligned,
  5    46     2 itp_mod bit (6) unaligned,
  5    47 
  5    48     2 offset fixed bin (18) unsigned unaligned,
  5    49     2 pad2 bit (3) unaligned,
  5    50     2 bit_offset fixed bin (6) unsigned unaligned,
  5    51     2 pad3 bit (3) unaligned,
  5    52     2 mod bit (6) unaligned;
  5    53 
  5    54 
  5    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  5    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  5    57 
  5    58 /* END INCLUDE FILE   its.incl.pl1 */
       31 
       32    call add ("its", addr (p -> its));
       33    call add ("its_unsigned", addr (p -> its_unsigned));
       34    call add ("itp", addr (p -> itp));
       35    call add ("itp_unsigned", addr (p -> itp_unsigned));
  6     1 /*	BEGIN INCLUDE FILE ... itt_entry.incl.pl1 ... Feb 1981 */
  6     2 
  6     3 /* format: style3 */
  6     4 dcl	itte_ptr		ptr;			/* pointer to entry in ITT */
  6     5 
  6     6 dcl	1 itt_entry	aligned based (itte_ptr),	/* declaration of single entry in the ITT */
  6     7 	  2 next_itt_relp	bit (18) unaligned,		/* thread of relative pointers */
  6     8 	  2 pad		bit (18) unaligned,
  6     9 	  2 sender	bit (36),			/* id of sending process */
  6    10 	  2 origin,				/* origin of event message */
  6    11 	    3 dev_signal	bit (18) unaligned,		/* 0 = user-event, 1 = device-signal */
  6    12 	    3 ring	fixed bin (17) unaligned,	/* if user-event, sender's validation ring */
  6    13 	  2 target_id	bit (36),			/* target process' id */
  6    14 	  2 channel_id	fixed bin (71),		/* target process' event channel */
  6    15 	  2 message	fixed bin (71);		/* event message */
  6    16 
  6    17 /*	END INCLUDE FILE ... itt_entry.incl.pl1 */
       36 	call add ("itt_entry", addr (p -> itt_entry));
       37 
  7     1 /*  BEGIN INCLUDE FILE  - - - kst.incl.pl1 - - - 
  7     2*
  7     3*Modified March 1976 by R. Bratt 
  7     4*Modified November 1984 to remove hdr, Keith Loepere. */
  7     5 
  7     6 dcl  pds$kstp ext ptr,
  7     7     (kstp, kstep) ptr;
  7     8 
  7     9 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  7    10     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  7    11     2 highseg fixed bin (17),				/* highest segment number described by kst */
  7    12     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  7    13     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  7    14     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  7    15     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  7    16     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  7    17     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  7    18     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  7    19     2 template bit (1) unaligned,			/* this is a template kst if set */
  7    20     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  7    21     2 unused_2 bit (9) unaligned,
  7    22     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  7    23     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  7    24     2 lv (1:256) bit (36),				/* private logical volume connection list */
  7    25     2 end_of_kst bit (36);
  7    26 
  7    27 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  7    28     2 fp bit (18) unaligned,				/* forward rel pointer */
  7    29     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  7    30     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  7    31     2 entryp ptr unaligned,				/* branch pointer */
  7    32     2 uid bit (36) aligned,				/* unique identifier */
  7    33     2 access_information unaligned,
  7    34       3 dtbm bit (36),				/* date time branch modified */
  7    35       3 extended_access bit (33),			/* extended access from the branch */
  7    36       3 access bit (3),				/* rew */
  7    37       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  7    38     2 pad1 bit (3) unaligned,
  7    39     2 flags unaligned,
  7    40       3 dirsw bit (1),				/* directory switch */
  7    41       3 allow_write bit (1),				/* set if initiated with write permission */
  7    42       3 priv_init bit (1),				/* privileged initiation */
  7    43       3 tms bit (1),				/* transparent modification switch */
  7    44       3 tus bit (1),				/* transparent usage switch */
  7    45       3 tpd bit (1),				/* transparent paging device switch */
  7    46       3 audit bit (1),				/* audit switch */
  7    47       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  7    48       3 pad bit (3),
  7    49     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  7    50 
  7    51 /*  END INCLUDE FILE - - - - - - - - - - - - kst.incl.pl1 - - - - - - - - - - - - */
       38 
       39    call add ("kst", addr (p -> kst));
       40    call add ("kste", addr (p -> kste));
       41 
  8     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  8     2 
  8     3 /* Created by J. Stern 7/26/78 */
  8     4 /* Metering information added by C. Hornig, March 1980. */
  8     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  8     6 
  8     7 dcl  lctp ptr;					/* ptr to logical channel table */
  8     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  8     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  8    10 
  8    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  8    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  8    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  8    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  8    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  8    16     2 pad (11) fixed bin,
  8    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  8    18 
  8    19 
  8    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  8    21     2 lock bit (36),				/* channel lock */
  8    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  8    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  8    24     2 flags unal,
  8    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  8    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  8    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  8    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  8    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  8    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  8    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  8    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  8    33       3 trace bit (1) unal,				/* ON to trace this channel */
  8    34       3 unused bit (1) unal,
  8    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  8    36     2 major_channel_info,
  8    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  8    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  8    39     2 queue_entries,
  8    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  8    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  8    42     2 word_counts,
  8    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  8    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  8    45 
  8    46     2 meters,
  8    47       3 in_bytes fixed bin (35),
  8    48       3 out_bytes fixed bin (35),
  8    49       3 in,
  8    50         4 calls fixed bin (35),
  8    51         4 interrupts fixed bin (35),
  8    52         4 call_time fixed bin (71),
  8    53         4 interrupt_time fixed bin (71),
  8    54       3 out like lcte.meters.in,
  8    55       3 control like lcte.meters.in,
  8    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  8    57 
  8    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  8    59 
  8    60     2 pad (3) fixed bin (35);
  8    61 
  8    62 
  8    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  8    64 
  8    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  8    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  8    67 
  8    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  8    69 
  8    70 
  8    71 /* END INCLUDE FILE ... lct.incl.pl1 */
       42 
       43    call add ("lct", addr (p -> lct));
       44    call add ("lcte", addr (p -> lcte));
       45 begin;
       46    /* BEGIN INCLUDE FILE linkdcl.incl.pl1 --- last modified 15 Nov 1971 by C Garman */
  9     2 
  9     3 /* Last Modified (Date and Reason):
  9     4*   6/75 by M.Weaver to add virgin_linkage_header declaration
  9     5*   6/75 by S.Webber to comment existing structures better
  9     6*   9/77 by M. Weaver to add run_depth to link
  9     7*   2/83 by M. Weaver to add linkage header flags and change run_depth precision
  9     8**/
  9     9 
  9    10 /* format: style3 */
  9    11 dcl	1 link		based aligned,		/* link pair in linkage section */
  9    12 	  2 head_ptr	bit (18) unal,		/* rel pointer to beginning of linkage section */
  9    13 	  2 ringno	bit (3) unal,
  9    14 	  2 mbz		bit (6) unal,
  9    15 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  9    16 	  2 ft2		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  9    17 	  2 exp_ptr	bit (18) unal,		/* pointer (rel to defs) of expression word */
  9    18 	  2 mbz2		bit (12) unal,
  9    19 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  9    20 
  9    21 dcl	1 exp_word	based aligned,		/* expression word in link definition */
  9    22 	  2 type_ptr	bit (18) unal,		/* pointer (rel to defs) of type pair structure */
  9    23 	  2 exp		bit (18) unal;		/* constant expression to be added in when snapping link */
  9    24 
  9    25 dcl	1 type_pair	based aligned,		/* type pair in link definition */
  9    26 	  2 type		bit (18) unal,		/* type of link. may be 1,2,3,4,5, or 6 */
  9    27 	  2 trap_ptr	bit (18) unal,		/* pointer (rel to defs) to the trap word */
  9    28 	  2 seg_ptr	bit (18) unal,		/* pointer to ACC reference name for segment referenced */
  9    29 	  2 ext_ptr	bit (18) unal;		/* pointer (rel to defs)  of ACC segdef name */
  9    30 
  9    31 dcl	1 header		based aligned,		/* linkage block header */
  9    32 	  2 def_ptr	ptr,			/* pointer to definition section */
  9    33 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  9    34 	  2 original_linkage_ptr
  9    35 			ptr unal,			/* pointer to linkage section in object segment */
  9    36 	  2 unused	bit (72),
  9    37 	  2 stats,
  9    38 	    3 begin_links	bit (18) unal,		/* offset (rel to this section) of first link */
  9    39 	    3 block_length	bit (18) unal,		/* number of words in this linkage section */
  9    40 	    3 segment_number
  9    41 			bit (18) unal,		/* text segment number associated with this section */
  9    42 	    3 static_length bit (18) unal;		/* number of words of static for this segment */
  9    43 
  9    44 dcl	1 linkage_header_flags
  9    45 			aligned based,		/* overlay of def_ptr for flags */
  9    46 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  9    47 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  9    48 	  2 perprocess_static
  9    49 			bit (1) unaligned,		/* 1 copy of static section is used by all tasks/run units */
  9    50 	  2 pad2		bit (6) unaligned;
  9    51 
  9    52 dcl	1 virgin_linkage_header
  9    53 			aligned based,		/* template for linkage header in object segment */
  9    54 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  9    55 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  9    56 	  2 def_offset	bit (18) unaligned,		/* offset of definition section */
  9    57 	  2 first_ref_relp	bit (18) unaligned,		/* offset of trap-at-first-reference offset array */
  9    58 	  2 filled_in_later bit (144),
  9    59 	  2 link_begin	bit (18) unaligned,		/* offset of first link */
  9    60 	  2 linkage_section_lng
  9    61 			bit (18) unaligned,		/* length of linkage section */
  9    62 	  2 segno_pad	bit (18) unaligned,		/* will be segment number of copied linkage */
  9    63 	  2 static_length	bit (18) unaligned;		/* length of static section */
  9    64 
  9    65 
  9    66 dcl	1 trap_word	based aligned,		/* trap word in link definition */
  9    67 	  2 call_ptr	bit (18) unal,		/* pointer (rel to link) of link to trap procedure */
  9    68 	  2 arg_ptr	bit (18) unal;		/* pointer (rel to link) of link to arg info for trap proc */
  9    69 
  9    70 dcl	1 name		based aligned,		/* storage of ASCII names in definitions */
  9    71 	  2 nchars	bit (9) unaligned,		/* number of characters in name */
  9    72 	  2 char_string	char (31) unaligned;	/* 31-character name */
  9    73 
  9    74 /* END INCLUDE FILE linkdcl.incl.pl1 */
       46 
       47       dcl 1 link_pair aligned like link based;
       48       call add ("link_pair", addr (p -> link_pair));
       49       dcl 1 link_exp_word aligned like exp_word based;
       50       call add ("link_exp_word", addr (p -> link_exp_word));
       51       dcl 1 link_type_pair aligned like type_pair based;
       52       call add ("link_type_pair", addr (p -> link_type_pair));
       53       dcl 1 linkage_header aligned like header based;
       54       call add ("linkage_header", addr (p -> linkage_header));
       55       call add ("virgin_linkage_header", addr (p -> virgin_linkage_header));
       56       dcl 1 link_trap_word aligned like trap_word based;
       57       call add ("link_trap_word", addr (p -> link_trap_word));
       58       end;
 10     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
 10     2 /* modified by M. Weaver 3/77 */
 10     3 
 10     4 dcl  lotp ptr;
 10     5 
 10     6 dcl 1 lot based (lotp) aligned,
 10     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
 10     8 
 10     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
 10    10 						/* lot fault has fault code = 0 and offset = 0 */
 10    11 
 10    12 dcl  isotp ptr;
 10    13 dcl 1 isot based (isotp) aligned,
 10    14     2 isp (0:9999) ptr unaligned;
 10    15 
 10    16 dcl 1 isot1 (0 :9999) aligned based,
 10    17     2 flags unaligned,
 10    18       3 fault bit (2) unaligned,
 10    19       3 system bit (1) unaligned,
 10    20       3 mbz bit (6) unaligned,
 10    21     2 fault_code fixed bin (8) unaligned,
 10    22     2 static_offset bit (18) unaligned;
 10    23 
 10    24 
 10    25 /* END INCLUDE FILE  lot.incl.pl1 */
       59 
       60    call add ("lot", addr (p -> lot));
       61    call add ("isot", addr (p -> isot));
       62    call add ("isot1", addr (p -> isot1));
 11     1 /* BEGIN INCLUDE FILE lvt.incl.pl1 -- Written Jan. 1976 by R. Bratt       */
 11     2 /*
 11     3*   This include file defines the format of the hardcore L_ogical V_olume T_able (LVT).
 11     4**/
 11     5 
 11     6 dcl  lvt$ ext;
 11     7 dcl  lvtp ptr;
 11     8 dcl  lvtep ptr;
 11     9 
 11    10 dcl 1 lvt aligned based (lvtp),
 11    11     2 max_lvtex fixed bin (17),			/* maximum number of LVs describable */
 11    12     2 high_water_lvtex fixed bin (17),			/* highest LVT index assigned */
 11    13     2 free_lvtep ptr,				/* pointer to  first free lvte  */
 11    14     2 pad1 (4) bit (36),
 11    15     2 ht (0:63) ptr unal,				/* lvid hash table */
 11    16     2 lvtes (1:1 refer (lvt.max_lvtex)) like lvte;	/* LVT entries */
 11    17 
 11    18 dcl 1 lvte aligned based (lvtep),			/* logical volume table entry */
 11    19     2 lvtep ptr unaligned,				/* lvid hash thread */
 11    20     2 pvtex fixed bin (17),				/* thread of mounted PVs */
 11    21     2 lvid bit (36),				/* logical volume id */
 11    22     2 access_class aligned,				/* access isolation mechanism stuff */
 11    23       3 min bit (72),				/* minimum access class allowed on LV */
 11    24       3 max bit (72),				/* maximum access class allowed on volume */
 11    25     2 flags unaligned,				/* flags */
 11    26       3 public bit (1),				/* => anyone can connect to this LV */
 11    27       3 read_only bit (1),				/* => no writes on this LV */
 11    28       3 pad bit (16),
 11    29       3 cycle_pvtx fixed bin (17);			/* pvtx for next per_process seg */
 11    30 
 11    31 /* END INCLUDE FILE lvt.incl.pl1                                                    */
       63  
       64    call add ("lvt", addr (p -> lvt));
       65    call add ("lvte", addr (p -> lvte));
       66 
       67 /* Followed by the include file containing the code to do the work */
       68 
       69 dcl  WHOAMI char (32) internal static options (constant) init ("structure_library_3_");
       70 
 12     1 
 12     2 
 12     3 /* *  	STRUCTURE_LIBRARY_CODE.INCL.PL1
 12     4*   *
 12     5*   *	This procedure generates the default library segment for the
 12     6*   *      structure display system.  The way it operates is hardly what one
 12     7*   *      would call normal, however. It has to do a number of rather unclean
 12     8*   *      things, and modifications must be made carefully following these
 12     9*   *      conventions:
 12    10*   * 
 12    11*   *      Because the compiler insists on actually having a structure appear
 12    12*   *      in some reference context for it to appear in the symbol table,
 12    13*   *      regardless of options, every structure defined herein must be
 12    14*   *      referenced somehow. This is accomplished with the calls to the
 12    15*   *      "add" procedure. The first argument to the "add" procedure is the
 12    16*   *      name of the structure, put there so it can be added to the table
 12    17*   *      of contents for the segment.
 12    18*   *
 12    19*   *      The second argument to the add procedure is a pointer, which must
 12    20*   *      always be of the form "addr (p -> structure)".  This is done to 
 12    21*   *      that the structure will be referenced, while at the same time 
 12    22*   *      avoiding any reference to its implicit base, or to other values
 12    23*   *      which must be initialized to avoid warnings.  
 12    24*   *
 12    25*   *      Finally, this program compiles and runs itself using 
 12    26*   *      create_data_segment; this is done both to ensure that it gets
 12    27*   *      compiled with a symbol table, and to make it possible copy the 
 12    28*   *      object segment and write into the internal static options (constant)
 12    29*   *      array that is the table of structures. All in all, it's pretty 
 12    30*   *      complicated.
 12    31*   *
 12    32*   *      The code for this program is in an include file in order to ease
 12    33*   *	the construction of user-defined structure libraries. In order to
 12    34*   *      use this code, one must create a program looking like this:
 12    35*   *
 12    36*   *	structure_library_7_:
 12    37*   *	     procedure ();
 12    38*   *
 12    39*   *		< %include statements, calls to add >
 12    40*   *
 12    41*   *       dcl  WHOAMI char (32) internal static options (constant) init ("structure_library_7_");
 12    42*   *	%include structure_library_code;
 12    43*   *	          end structure_library_7_;
 12    44*   *
 12    45*   *	The standard structure libraries (structure_library_1_.cds,
 12    46*   *	for example, provide a good example of this.
 12    47*   *	
 12    48*   *      30 May 1983, W. Olin Sibert
 12    49*   */
 12    50 
 12    51 /*  */
 12    52 
 12    53 /* Now come the more ordinary parts of code that usually appear in a program */
 12    54 
 12    55 dcl  code	fixed binary (35);
 12    56 dcl  severity_ptr pointer;
 12    57 dcl  severity_value fixed bin (35) based (severity_ptr);
 12    58 dcl  answer bit (1) aligned;
 12    59 dcl  new_segp pointer;
 12    60 dcl  old_segp pointer;
 12    61 dcl  bitcount fixed bin (24);
 12    62 dcl  n_words fixed bin (18);
 12    63 dcl  based_words (n_words) bit (36) aligned based;
 12    64 
 12    65 dcl  p pointer init (null ());			/* our general-purpose base */
 12    66 
 12    67 dcl  com_err_ entry options (variable);
 12    68 dcl  command_query_$yes_no entry options (variable);
 12    69 dcl  get_external_variable_ entry (char (*), pointer, fixed bin (19), pointer, fixed bin (35));
 12    70 dcl  get_wdir_ entry () returns (char (168));
 12    71 dcl  hcs_$make_seg entry (char (*), char (*), char (*), 
 12    72      fixed bin (5), pointer, fixed bin (35));
 12    73 dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
 12    74 dcl  hcs_$status_mins entry 
 12    75     (pointer, fixed bin (2), fixed bin (24), fixed bin (35));
 12    76 dcl  hcs_$terminate_noname entry (pointer, fixed bin (35));
 12    77 dcl  nothing entry options (variable);
 12    78 
 12    79 dcl  INITIALIZED bit (1) aligned internal static options (constant) init ("0"b);
 12    80 dcl  initialized_bit bit (1) aligned based;
 12    81 
 12    82 /* The following array is important: it defines the "table of contents"
 12    83*   for the structure library segment.  It is declared and initialized to
 12    84*   empty, but when the object segment is copied into the library segment, 
 12    85*   it is filled in with the actual names of all the structures, which were
 12    86*   collected by all the calls to "add", above. */
 12    87 
 12    88 dcl  STRUCTURES (200) char (32) unaligned internal static options (constant) 
 12    89      init ((200)(32)"");
 12    90 
 12    91 /* This is the automatic array where the data is collected, and the based
 12    92*   overlay used later on to copy it into the new segment */
 12    93 
 12    94 dcl  based_structures (n_structures) char (32) unaligned based;
 12    95 dcl  structures (hbound (STRUCTURES, 1)) char (32) unaligned automatic;
 12    96 dcl  n_structures fixed bin init (0);
 12    97 
 12    98 dcl (addr, codeptr, null, rel, size, unspec) builtin;
 12    99 
 12   100 /**/
 12   101 
 12   102 /* Finally, the real code, which copies one segment onto the other and
 12   103*   updates the structures arrays. */
 12   104 
 12   105 	if INITIALIZED then do;
 12   106 	     call com_err_ (0, WHOAMI, "This program is a data segment, and may not be executed.");
 12   107 	     return;
 12   108 	     end;
 12   109 
 12   110 	call get_external_variable_ ("pl1_severity_", severity_ptr, (0), (null ()), code);
 12   111 	if (code ^= 0) then do;
 12   112 	     call com_err_ (code,  WHOAMI, "Cannot determine severity for compilation of ^a.", WHOAMI);
 12   113 	     return;
 12   114 	     end;
 12   115 
 12   116 	if (severity_value = 2) then do;
 12   117 	     call command_query_$yes_no (answer, 0, WHOAMI, 
 12   118 
 12   119 "ERROR 366 means that the program is too large to construct a symbol table;
 12   120 this quite commonly happens to structure libraries because of their enormous
 12   121 symbol tables. You may be able to fix the error by rearranging some of the
 12   122 include files.",
 12   123 
 12   124 "Warning: A severity two PL/I error has occurred. 
 12   125 If it is ERROR 366, the result of this compilation will be partially invalid.
 12   126 Do you wish to continue and generate the library segment anyway?");
 12   127 
 12   128 	     if ^answer then return;
 12   129 	     end;
 12   130 
 12   131 	old_segp = pointer (addr (STRUCTURES), 0);
 12   132 
 12   133 	call hcs_$status_mins (old_segp, (0), bitcount, code);
 12   134 	if (code ^= 0) then do;
 12   135 	     call com_err_ (code, WHOAMI, 
 12   136 		"Cannot get bitcount of original segment.");
 12   137 	     return;
 12   138 	     end;
 12   139 
 12   140 	call hcs_$make_seg ((get_wdir_ ()), WHOAMI, "", 01010b, new_segp, code);
 12   141 	if (new_segp = null ()) then do;
 12   142 	     call com_err_ (code, WHOAMI, "Cannot create [wd]>^a", WHOAMI);
 12   143 	     return;
 12   144 	     end;
 12   145 
 12   146 	n_words = divide (bitcount, 36, 18, 0);
 12   147 	new_segp -> based_words = old_segp -> based_words;
 12   148 
 12   149 	call hcs_$set_bc_seg (new_segp, bitcount, code);
 12   150 	if (code ^= 0) then do;
 12   151 	     call com_err_ (code, WHOAMI,
 12   152 		"Cannot set bitcount on [wd]>^a", WHOAMI);
 12   153 	     return;
 12   154 	     end;
 12   155 
 12   156 /* Finally, copy in the structure list */
 12   157 
 12   158 	pointer (new_segp, rel (addr (STRUCTURES))) -> based_structures
 12   159 	     = addr (structures) -> based_structures;
 12   160 	pointer (new_segp, rel (addr (INITIALIZED))) -> initialized_bit = "1"b;
 12   161 
 12   162 	call hcs_$terminate_noname (new_segp, (0));
 12   163 
 12   164 ERROR_RETURN:
 12   165 	return;
 12   166 
 12   167 /*  */
 12   168 
 12   169 /* This is called once for each structure which goes in the table of contents.
 12   170*   It adds the structure to the automatic array, and increments the count. */
 12   171 
 12   172 add:
 12   173 addx:
 12   174      procedure (name, useless_pointer);
 12   175 
 12   176 dcl  name char (32);
 12   177 dcl  useless_pointer pointer;
 12   178 
 12   179 /* The bounds check is against hbound - 1, since it is necessary to always
 12   180*   leave at least one blank entry in the table of contents to show where
 12   181*   the last valid entry is. */
 12   182 
 12   183 
 12   184 	if (n_structures >= (hbound (STRUCTURES, 1) - 1)) then do;
 12   185 	     call com_err_ (0, WHOAMI, 
 12   186 		"Too many structures defined. Max is ^d.^/^3xChange the dimension of the STRUCTURES array and recompile.",
 12   187 		hbound (STRUCTURES, 1));
 12   188 	     goto ERROR_RETURN;
 12   189 	     end;
 12   190 
 12   191 	n_structures = n_structures + 1;
 12   192 	structures (n_structures) = name;
 12   193 	structures (n_structures + 1) = "";
 12   194 	return;
 12   195 	end add;
       71 
       72 
       73 	end structure_library_3_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1315.1  !BBBJPQgclKlWpd.pl1               >spec>temp>41-5>structure_library_3_.cds
13           1    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
18           2    06/03/75  0715.0  iom_lpw.incl.pl1                  >ldd>include>iom_lpw.incl.pl1
23           3    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
28           4    04/29/76  1103.8  iom_scw.incl.pl1                  >ldd>include>iom_scw.incl.pl1
31           5    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
36           6    03/27/82  0429.8  itt_entry.incl.pl1                >ldd>include>itt_entry.incl.pl1
38           7    01/22/85  1321.5  kst.incl.pl1                      >spec>temp>41-5>kst.incl.pl1
42           8    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
46           9    07/27/83  0910.0  linkdcl.incl.pl1                  >ldd>include>linkdcl.incl.pl1
59          10    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
63          11    11/30/76  1555.4  lvt.incl.pl1                      >ldd>include>lvt.incl.pl1
71          12    09/12/84  2307.0  structure_library_code.incl.pl1   >ldd>include>structure_library_code.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
INITIALIZED                     000032 constant        bit(1)                   initial dcl 12-79 set ref 12-105 12-160
STRUCTURES                      002204 constant        char(32)                 initial array unaligned dcl 12-88 set ref 12-95
                                                                                  12-131 12-158 12-184 12-185 12-185
WHOAMI                          000000 constant        char(32)                 initial unaligned dcl 69 set ref 12-106* 12-112*
                                                                                  12-112* 12-117* 12-135* 12-140* 12-142* 12-142*
                                                                                  12-151* 12-151* 12-185*
addr                                                   builtin function         dcl 12-98 ref 15 15 17 17 20 20 22 22 25 25 27 27 30
                                                                                  30 32 32 33 33 34 34 35 35 36 36 39 39 40 40 43 43
                                                                                  44 44 60 60 61 61 62 62 64 64 65 65 12-131 12-158
                                                                                  12-158 12-160 48 48 50 50 52 52 54 54 55 55 57 57
answer                          000150 automatic       bit(1)                   dcl 12-58 set ref 12-117* 12-128
based_structures                       based           char(32)                 array unaligned dcl 12-94 set ref 12-158* 12-158
based_words                            based           bit(36)                  array dcl 12-63 set ref 12-147* 12-147
bitcount                        000156 automatic       fixed bin(24,0)          dcl 12-61 set ref 12-133* 12-146 12-149*
code                            000144 automatic       fixed bin(35,0)          dcl 12-55 set ref 12-110* 12-111 12-112* 12-133*
                                                                                  12-134 12-135* 12-140* 12-142* 12-149* 12-150
                                                                                  12-151*
com_err_                        000016 constant        entry                    external dcl 12-67 ref 12-106 12-112 12-135 12-142
                                                                                  12-151 12-185
command_query_$yes_no           000020 constant        entry                    external dcl 12-68 ref 12-117
dcw                                    based           structure                level 1 dcl 1-7
dcwp                            000100 automatic       pointer                  dcl 1-4 ref 1-7 1-7 1-7 1-7 1-7 1-7
exp_word                               based           structure                level 1 dcl 9-21
get_external_variable_          000022 constant        entry                    external dcl 12-69 ref 12-110
get_wdir_                       000024 constant        entry                    external dcl 12-70 ref 12-140
hcs_$make_seg                   000026 constant        entry                    external dcl 12-71 ref 12-140
hcs_$set_bc_seg                 000030 constant        entry                    external dcl 12-73 ref 12-149
hcs_$status_mins                000032 constant        entry                    external dcl 12-74 ref 12-133
hcs_$terminate_noname           000034 constant        entry                    external dcl 12-76 ref 12-162
header                                 based           structure                level 1 dcl 9-31
highseg                   1            based           fixed bin(17,0)          level 2 dcl 7-9 set ref 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9
idcw                                   based           structure                level 1 dcl 3-21
idcwp                           000112 automatic       pointer                  dcl 3-19 ref 3-21 3-21 3-21 3-21 3-21 3-21 3-21 3-21
                                                                                  3-21
in                        2            based           structure                level 2 in structure "saved_meters" dcl 8-68
                                                                                  in procedure "structure_library_3_"
in                       10            based           structure                level 3 in structure "lcte" dcl 8-20 in procedure
                                                                                  "structure_library_3_"
in                       30            based           structure                array level 4 in structure "lct" dcl 8-11
                                                                                  in procedure "structure_library_3_"
initialized_bit                        based           bit(1)                   dcl 12-80 set ref 12-160*
iom_ddcw                               based           structure                level 1 dcl 14 set ref 15 15
iom_idcw                               based           structure                level 1 dcl 26 set ref 27 27
iom_lpw                                based           structure                level 1 dcl 19 set ref 20 20
iom_lpw_ext                            based           structure                level 1 dcl 21 set ref 22 22
iom_pcw                                based           structure                level 1 dcl 24 set ref 25 25
iom_scw                                based           structure                level 1 dcl 29 set ref 30 30
iom_tdcw                               based           structure                level 1 dcl 16 set ref 17 17
isot                                   based           structure                level 1 dcl 10-13 set ref 61 61
isot1                                  based           structure                array level 1 dcl 10-16 set ref 62 62
isotp                           000136 automatic       pointer                  dcl 10-12 ref 10-13 10-13
itp                                    based           structure                level 1 dcl 5-18 set ref 34 34
itp_unsigned                           based           structure                level 1 dcl 5-43 set ref 35 35
its                                    based           structure                level 1 dcl 5-5 set ref 32 32
its_unsigned                           based           structure                level 1 dcl 5-30 set ref 33 33
itt_entry                              based           structure                level 1 dcl 6-6 set ref 36 36
itte_ptr                        000116 automatic       pointer                  dcl 6-4 ref 6-6 6-6 6-6 6-6 6-6 6-6 6-6 6-6 6-6 6-6
kst                                    based           structure                level 1 dcl 7-9 set ref 39 39
kste                                   based           structure                level 1 dcl 7-27 set ref 40 40
kstep                           000122 automatic       pointer                  dcl 7-6 ref 7-27 7-27 7-27 7-27 7-27 7-27 7-27 7-27
                                                                                  7-27 7-27 7-27 7-27 7-27 7-27 7-27 7-27 7-27 7-27
                                                                                  7-27 7-27 7-27 7-27 7-27
kstp                            000120 automatic       pointer                  dcl 7-6 ref 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9
lct                                    based           structure                level 1 dcl 8-11 set ref 43 43
lcte                                   based           structure                level 1 dcl 8-20 set ref 44 44
lctep                           000126 automatic       pointer                  dcl 8-8 ref 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20
                                                                                  8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20
                                                                                  8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20
                                                                                  8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20 8-20
                                                                                  8-20 8-20 8-20 8-20 8-20 8-20 8-20
lctp                            000124 automatic       pointer                  dcl 8-7 ref 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11
link                                   based           structure                level 1 dcl 9-11
link_exp_word                          based           structure                level 1 dcl 49 set ref 50 50
link_pair                              based           structure                level 1 dcl 47 set ref 48 48
link_trap_word                         based           structure                level 1 dcl 56 set ref 57 57
link_type_pair                         based           structure                level 1 dcl 51 set ref 52 52
linkage_header                         based           structure                level 1 dcl 53 set ref 54 54
lot                                    based           structure                level 1 dcl 10-6 set ref 60 60
lotp                            000134 automatic       pointer                  dcl 10-4 ref 10-6 10-6
lowseg                                 based           fixed bin(17,0)          level 2 dcl 7-9 set ref 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9 7-9
                                                                                  7-9 7-9 7-9 7-9 7-9
lpw                                    based           structure                level 1 dcl 2-8
lpw_ext                                based           structure                level 1 dcl 2-18
lpwep                           000106 automatic       pointer                  dcl 2-5 ref 2-18 2-18 2-18 2-18
lpwp                            000104 automatic       pointer                  dcl 2-5 ref 2-8 2-8 2-8 2-8 2-8 2-8 2-8 2-8 2-8
lvt                                    based           structure                level 1 dcl 11-10 set ref 64 64
lvte                                   based           structure                level 1 dcl 11-18 set ref 65 65
lvtep                           000142 automatic       pointer                  dcl 11-8 ref 11-18 11-18 11-18 11-18 11-18 11-18
                                                                                  11-18 11-18 11-18 11-18 11-18 11-18
lvtp                            000140 automatic       pointer                  dcl 11-7 ref 11-10 11-10 11-10 11-10 11-10 11-10
                                                                                  11-10 11-10 11-10 11-10 11-10 11-10 11-10 11-10
                                                                                  11-10 11-10 11-10 11-10
max_lvtex                              based           fixed bin(17,0)          level 2 dcl 11-10 set ref 11-10 11-10 11-10 11-10
                                                                                  11-10 11-10 11-10 11-10 11-10 11-10 11-10 11-10
max_no_lctes                           based           fixed bin(17,0)          level 2 dcl 8-11 set ref 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
                                                                                  8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11 8-11
meters                   26            based           structure                array level 3 in structure "lct" dcl 8-11
                                                                                  in procedure "structure_library_3_"
meters                    6            based           structure                level 2 in structure "lcte" dcl 8-20 in procedure
                                                                                  "structure_library_3_"
n_structures                    000162 automatic       fixed bin(17,0)          initial dcl 12-96 set ref 12-94 12-96* 12-158 12-158
                                                                                  12-158 12-184 12-191* 12-191 12-192 12-193
n_words                         000157 automatic       fixed bin(18,0)          dcl 12-62 set ref 12-63 12-146* 12-147
name                                   parameter       char(32)                 unaligned dcl 12-176 ref 12-172 12-172 12-192
new_segp                        000152 automatic       pointer                  dcl 12-59 set ref 12-140* 12-141 12-147 12-149*
                                                                                  12-158 12-160 12-162*
null                                                   builtin function         dcl 12-98 ref 12-65 12-110 12-141
old_segp                        000154 automatic       pointer                  dcl 12-60 set ref 12-131* 12-133* 12-147
p                               000160 automatic       pointer                  initial dcl 12-65 set ref 15 15 17 17 20 20 22 22 25
                                                                                  25 27 27 30 30 32 32 33 33 34 34 35 35 36 36 39 39
                                                                                  40 40 43 43 44 44 60 60 61 61 62 62 64 64 65 65
                                                                                  12-65* 48 48 50 50 52 52 54 54 55 55 57 57
pcw                                    based           structure                level 1 dcl 3-6
pcwp                            000110 automatic       pointer                  dcl 3-4 ref 3-6 3-6 3-6 3-6 3-6 3-6 3-6 3-6 3-6 3-6
                                                                                  3-6 3-6
rel                                                    builtin function         dcl 12-98 ref 12-158 12-160
scw                                    based           structure                level 1 dcl 4-6
scwp                            000114 automatic       pointer                  dcl 4-4 ref 4-6 4-6 4-6 4-6 4-6
severity_ptr                    000146 automatic       pointer                  dcl 12-56 set ref 12-57 12-110* 12-116
severity_value                         based           fixed bin(35,0)          dcl 12-57 ref 12-116
structures                      000162 automatic       char(32)                 array unaligned dcl 12-95 set ref 12-158 12-192*
                                                                                  12-193*
tdcw                                   based           structure                level 1 dcl 1-14
tdcwp                           000102 automatic       pointer                  dcl 1-4 ref 1-14 1-14 1-14 1-14 1-14 1-14 1-14 1-14
trap_word                              based           structure                level 1 dcl 9-66
type_pair                              based           structure                level 1 dcl 9-25
useless_pointer                        parameter       pointer                  dcl 12-177 ref 12-172 12-172
virgin_linkage_header                  based           structure                level 1 dcl 9-52 set ref 55 55

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           constant        bit(6)                   initial unaligned dcl 5-56
ITS_MODIFIER                           constant        bit(6)                   initial unaligned dcl 5-55
codeptr                                                builtin function         dcl 12-98
lcnt                                   based           structure                level 1 dcl 8-65
lcntp                           000132 automatic       pointer                  dcl 8-63
lct_size                        000130 automatic       fixed bin(17,0)          dcl 8-9
linkage_header_flags                   based           structure                level 1 dcl 9-44
lot_fault                              constant        bit(36)                  initial dcl 10-9
lvt$                            000014 external static fixed bin(17,0)          dcl 11-6
name                                   based           structure                level 1 dcl 9-70
nothing                         000000 constant        entry                    external dcl 12-77
pds$kstp                        000012 external static pointer                  dcl 7-6
saved_meters                           based           structure                level 1 dcl 8-68
size                                                   builtin function         dcl 12-98
unspec                                                 builtin function         dcl 12-98

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    002102 constant        label                    dcl 12-164 ref 12-188
add                             002106 constant        entry                    internal dcl 12-172 ref 15 17 20 22 25 27 30 32 33
                                                                                  34 35 36 39 40 43 44 48 50 52 54 55 57 60 61 62 64
                                                                                  65
addx                            002103 constant        entry                    internal dcl 12-172
structure_library_3_            001071 constant        entry                    external dcl 8

NAMES DECLARED BY CONTEXT OR IMPLICATION.
divide                                                 builtin function         ref 12-146
hbound                                                 builtin function         ref 12-95 12-184 12-185 12-185
pointer                                                builtin function         ref 12-131 12-158 12-160

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5446        5504    5304        5456
Length     16426    5304        36       10706     142           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
structure_library_3_                358 external procedure  is an external procedure.  
begin block on line 45                  begin block         shares stack frame of external procedure structure_library_3_.  
addx                                    internal procedure  shares stack frame of external procedure structure_library_3_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
structure_library_3_     000100 dcwp                        structure_library_3_
                         000102 tdcwp                       structure_library_3_
                         000104 lpwp                        structure_library_3_
                         000106 lpwep                       structure_library_3_
                         000110 pcwp                        structure_library_3_
                         000112 idcwp                       structure_library_3_
                         000114 scwp                        structure_library_3_
                         000116 itte_ptr                    structure_library_3_
                         000120 kstp                        structure_library_3_
                         000122 kstep                       structure_library_3_
                         000124 lctp                        structure_library_3_
                         000126 lctep                       structure_library_3_
                         000130 lct_size                    structure_library_3_
                         000132 lcntp                       structure_library_3_
                         000134 lotp                        structure_library_3_
                         000136 isotp                       structure_library_3_
                         000140 lvtp                        structure_library_3_
                         000142 lvtep                       structure_library_3_
                         000144 code                        structure_library_3_
                         000146 severity_ptr                structure_library_3_
                         000150 answer                      structure_library_3_
                         000152 new_segp                    structure_library_3_
                         000154 old_segp                    structure_library_3_
                         000156 bitcount                    structure_library_3_
                         000157 n_words                     structure_library_3_
                         000160 p                           structure_library_3_
                         000162 n_structures                structure_library_3_
                         000162 structures                  structure_library_3_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_temp          call_ext_out_desc   call_ext_out        return              alloc_auto_adj      shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_$yes_no         get_external_variable_        get_wdir_
hcs_$make_seg                 hcs_$set_bc_seg               hcs_$status_mins              hcs_$terminate_noname

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
lvt$                          pds$kstp




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      8 001070   12   65 001076   12   95 001100   12   96 001107        15 001110        17 001117        20 001126
     22 001135        25 001144        27 001153        30 001162        32 001171        33 001200        34 001207
     35 001216        36 001225        39 001234        40 001243        43 001252        44 001261        48 001270
     50 001277        52 001306        54 001315        55 001324        57 001333        60 001342        61 001351
     62 001360        64 001367        65 001376   12  105 001405   12  106 001407   12  107 001434   12  110 001435
12  111 001476   12  112 001500   12  113 001527   12  116 001530   12  117 001533   12  128 001573   12  131 001576
12  133 001601   12  134 001620   12  135 001622   12  137 001646   12  140 001647   12  141 001715   12  142 001721
12  143 001750   12  146 001751   12  147 001754   12  149 001762   12  150 001775   12  151 001777   12  153 002026
12  158 002027   12  160 002057   12  162 002066   12  164 002102   12  172 002103   12  184 002110   12  185 002113
12  188 002146   12  191 002147   12  192 002150   12  193 002160   12  194 002166


Object Segment >spec>temp>41-5>structure_library_3_
Created on 01/22/85  1358.4 mst Tue
by GJohnson.SysMaint.m
using Multics PL/I Compiler, Release 28d, of October 4, 1983

        Object    Text    Defs    Link    Symb  Static
Start        0       0    5304    5446    5504    5456
Length   16426    5304     142      36   10706       0


3 Definitions:


segname:    !BBBJPQgclKlWpd

text|1071       structure_library_3_            Entrypoint
symb|0          symbol_table


11 Links:

link|10     *symbol|0
link|16     com_err_
link|20     command_query_$yes_no
link|22     get_external_variable_
link|24     get_wdir_
link|34     hcs_$terminate_noname
link|32     hcs_$status_mins
link|30     hcs_$set_bc_seg
link|26     hcs_$make_seg
link|14     lvt|0
link|12     pds$kstp





                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
