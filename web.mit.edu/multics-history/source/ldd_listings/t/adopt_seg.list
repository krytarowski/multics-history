	COMPILATION LISTING OF SEGMENT adopt_seg
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/15/89  0827.9 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 adopt_seg: proc;
       12 
       13 
       14 /* adopt_seg  Bernard Greenberg 7/19/77 */
       15 /* Modified by Mike Grady to set ex_ringbrack on adopted dirs 9/79 */
       16 /* Modified by Keith Loepere to set dir_quota 12/84 */
       17 
       18 dcl (addr, bit, empty, fixed, null, unspec) builtin;
       19 dcl  level fixed bin;
       20 dcl  cu_$level_get entry returns (fixed bin);
       21 dcl  mdc_$read_disk_table entry (ptr, fixed bin (35));
       22 dcl (error_table_$pvid_not_found, error_table_$root) fixed bin (35) external;
       23 dcl (error_table_$action_not_performed, error_table_$not_seg_type) fixed bin (35) ext;
       24 dcl  sub_entry bit (1);
       25 dcl (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr, fixed bin (35));
       26 dcl  hcs_$status_long entry (char (*), char (*), fixed bin, ptr, ptr, fixed bin (35));
       27 dcl  hcs_$get_access_class entry (char(*), char(*), bit(72) aligned, fixed bin(35));
       28 dcl  hc_backup_$retv_append entry (char (*), char (*), ptr, ptr, fixed bin (35));
       29 dcl aim_check_$greater entry (bit(72) aligned, bit(72) aligned) returns(bit(1) aligned);
       30 
       31 dcl  cleanup condition;
       32 dcl  parent_acc bit (72) aligned;
       33 dcl  q (1) ptr init (null ());
       34 dcl  pvname char (32);
       35 dcl  i fixed bin;
       36 dcl  code fixed bin (35);
       37 dcl  myname char (20) init ("adopt_seg") static options (constant);
       38 dcl  phcs_$get_vtoce entry (fixed bin, fixed bin, ptr, fixed bin (35));
       39 dcl 1 local_vtoce like vtoce aligned;
       40 dcl 1 local_entry like entry aligned;
       41 dcl 1 aretv_args like retv_append_args aligned;
       42 dcl 1 cbi like create_branch_info aligned;
       43 dcl 1 brinfo like branch_status aligned;
       44 
       45 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       46 dcl (ioa_, com_err_) entry options (variable);
       47 dcl (pvtx, vtocx) fixed bin;
       48 dcl  xarea area (10000) based (q (1));
       49 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       50 dcl  arg char (argl) based (argp);
       51 dcl  argl fixed bin, argp ptr;
       52 dcl  pvid bit (36) aligned;
       53 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
       54 dcl  apdir char (168), apent char (32);
       55 dcl  rtrname char (32);
       56 dcl  aabsname char (168);
       57 
       58 
       59 /* 	     Collect Arguments. */
       60 
       61 	sub_entry = "0"b;
       62 	on condition (cleanup) call release_temp_segments_ (myname, q, (0));;
       63 	call cu_$arg_ptr (1, argp, argl, code);
       64 	if code ^= 0 then do;
       65 usage:	     call com_err_ (code, myname, "Usage: ^a pvname vtocx newpath", myname);
       66 	     return;
       67 	end;
       68 
       69 	pvname = arg;
       70 	call get_pvtx;
       71 	if code ^= 0 then do;
       72 	     call com_err_ (code, myname, arg);
       73 	     go to nlexit;
       74 	end;
       75 
       76 	i = 1;
       77 	call cu_$arg_ptr (2, argp, argl, code);
       78 	if code ^= 0 then go to usage;
       79 	vtocx = cv_oct_check_ (arg, code);
       80 	if code ^= 0 then do;
       81 	     call com_err_ (0, myname, "Bad octal # for VTOC index: ^a.", arg);
       82 	     go to nlexit;
       83 	end;
       84 
       85 
       86 	call cu_$arg_ptr (3, argp, argl, code);
       87 	if code ^= 0 then go to usage;
       88 
       89 	call expand_pathname_ (arg, aabsname, rtrname, code);
       90 	if code = 0 then call expand_pathname_ (aabsname, apdir, apent, code);
       91 	if code ^= 0 then do;
       92 	     call com_err_ (code, myname, arg);
       93 	     go to nlexit;
       94 	end;
       95 
       96 
       97 
       98 /* 	     Validate all paramters, the target directory, and the vtoce.
       99*
      100*
      101**/
      102 
      103 process:	vtocep = addr (local_vtoce);
      104 	ep = addr (local_entry);
      105 
      106 	call phcs_$get_vtoce (pvtx, vtocx, vtocep, code);
      107 	if code ^= 0 then do;
      108 	     if sub_entry then go to rrcode;
      109 	     call com_err_ (code, myname, "Reading vtocx ^o on pvtx ^o.", vtocx, pvtx);
      110 	     go to nlexit;
      111 	end;
      112 
      113 	if vtoce.uid = "0"b then do;
      114 	     if sub_entry then do;
      115 notacted:		code = error_table_$action_not_performed;
      116 		go to rrcode;
      117 	     end;
      118 	     call com_err_ (0, myname, "Vtoce ^o on ^a is free.", vtocx, pvname);
      119 	     go to nlexit;
      120 	end;
      121 
      122 
      123 	xarea = empty ();
      124 	call hcs_$status_long (apdir, apent, 0, addr (brinfo), q (1), code);
      125 	if code ^= 0 & code = error_table_$root then brinfo.unique_id = (36)"1"b; /* avoid paging in imp. dependent way. */
      126 	else if code ^= 0 then do;
      127 	     if sub_entry then go to rrcode;
      128 	     call com_err_ (code, myname, "^a^[>^]^a", apdir, apdir ^= ">", apent);
      129 	     go to nlexit;
      130 	end;
      131 	else if brinfo.type ^= directory_type then do;
      132 	     code = error_table_$not_seg_type;
      133 	     if sub_entry then go to rrcode;
      134 	     call com_err_ (code, myname, "^a is not a directory.", aabsname);
      135 	     go to nlexit;
      136 	end;
      137 
      138 
      139 	do i = 0 to 15;
      140 	     if vtoce.uid_path (i) = "0"b then go to glev;
      141 	end;
      142 glev:	i = i - 1;
      143 	if i = -1 then do;
      144 	     code = error_table_$root;
      145 	     if sub_entry then go to rrcode;
      146 	     call com_err_ (code, myname, "Cannot retrieve the root.");
      147 	     go to nlexit;
      148 	end;
      149 
      150 	if vtoce.uid_path (i) ^= brinfo.unique_id then do;
      151 	     if sub_entry then go to notacted;
      152 	     call com_err_ (0, myname, "This vtoce is not from ^a.", aabsname);
      153 	     go to nlexit;
      154 	end;
      155 
      156 /* 	     Prepare volume backup args, new create_branch info, and new branch image.
      157*
      158**/
      159 	aretv_args.version = RETV_APPEND_ARGS_VERSION_1;
      160 	aretv_args.level = 1; /* to get multiclass segments */
      161 	level = cu_$level_get ();
      162 	aretv_args.ep = ep;
      163 
      164 /**** hc_backup_ requires that cbi.user have sma, at the current authorization,
      165*      and that the access class be <= the max in the retv_append_args */
      166       
      167 	call hcs_$get_access_class (apdir, apent, parent_acc, code);
      168 
      169 	aretv_args.max_access_authorization = vtoce.access_class;  /* has be be greater or equal to cbi.access_class */
      170 	aretv_args.access_authorization = parent_acc; /* has to be equal */
      171 	aretv_args.link = "0"b;
      172 
      173 	unspec (cbi) = "0"b;
      174 	cbi.version = create_branch_version_2;
      175 	cbi.dir_sw = vtoce.dirsw;
      176 	cbi.chase_sw = "0"b;
      177 	if code = 0 & aim_check_$greater (vtoce.access_class, parent_acc)
      178 	then do;
      179 	     cbi.priv_upgrade_sw = "1"b;
      180 	     cbi.parent_ac_sw = "0"b;
      181 	     end;
      182 	else do;
      183 	     cbi.priv_upgrade_sw = "0"b;
      184 	     cbi.parent_ac_sw = "1"b;
      185 	end;
      186 	cbi.mode = "101"b;
      187 	if cbi.priv_upgrade_sw & ^cbi.dir_sw
      188 	then cbi.rings (*) = 1; /* Only way to create multi-class seg is ring 1 seg */
      189 	else cbi.rings (*) = level;
      190 	cbi.userid = "Adopter.SysDaemon.z";
      191 	if vtoce.dirsw then do;
      192 	     cbi.quota = vtoce.quota (0);
      193 	     cbi.dir_quota = vtoce.quota (1);
      194 	end;
      195 	else cbi.bitcnt = 36*1024 * fixed (vtoce.csl, 9);
      196 	cbi.access_class = vtoce.access_class;
      197 
      198 	unspec (entry) = "0"b;
      199 	entry.type = seg_type_getter ();
      200 	entry.bs = "1"b;
      201 	entry.pvid = pvid;
      202 	entry.vtocx = vtocx;
      203 	entry.ring_brackets = bit (fixed (cbi.rings, 3), 3);
      204 	entry.size = 38;				/* Susan says this is right magic # */
      205 	entry.nnames = 1;
      206 	entry.owner = brinfo.unique_id;
      207 	entry.dtd = "0"b;
      208 	entry.bc = cbi.bitcnt;
      209 	entry.dtem = "0"b;
      210 	entry.uid = vtoce.uid;
      211 	entry.dirsw = vtoce.dirsw;
      212 	if entry.dirsw then
      213 	     entry.ex_ring_brackets = bit (fixed (level, 3), 3);
      214 
      215 	call hc_backup_$retv_append (aabsname, rtrname, addr (cbi), addr (aretv_args), code);
      216 
      217 	if sub_entry then do;
      218 rrcode:	     rcode = code;
      219 	     call release_temp_segments_ (myname, q, (0));
      220 	     return;
      221 	end;
      222 
      223 	if code ^= 0 then do;
      224 	     call com_err_ (code, myname, "Appending branch for ^a^[>^]^a.", aabsname, aabsname ^= ">", rtrname);
      225 	     go to nlexit;
      226 	end;
      227 
      228 	call ioa_ ("Appended branch ""^a"" in ^a for uid ^w.", rtrname, aabsname, vtoce.uid);
      229 nlexit:
      230 	call release_temp_segments_ (myname, q, (0));
      231 	return;
      232 
      233 
      234 /* 	*/
      235 
      236 adopt_seg_: entry (a_dirname, a_ename, a_pvid, a_pvtx, a_vtocx, rcode);
      237 
      238 dcl  a_dirname char (*);
      239 dcl  a_ename char (*);
      240 dcl  a_pvid bit (36) aligned;
      241 dcl  a_pvtx fixed bin;
      242 dcl  a_vtocx fixed bin;
      243 dcl  rcode fixed bin (35);
      244 
      245 	sub_entry = "1"b;				/* Set subroutine entry sw. */
      246 	on condition (cleanup) call release_temp_segments_ (myname, q, (0));
      247 
      248 	aabsname = a_dirname;
      249 	rtrname = a_ename;
      250 
      251 	pvid = a_pvid;
      252 	pvtx = a_pvtx;
      253 	vtocx = a_vtocx;
      254 
      255 	call get_temp_segments_ (myname, q, code);
      256 	if code ^= 0 then go to rrcode;
      257 
      258 	call expand_pathname_ (aabsname, apdir, apent, code);
      259 	if code ^= 0 then go to rrcode;		/* Do first split here */
      260 
      261 	go to process;
      262 
      263 /*  PVTX from DISK_TABLE getter */
      264 get_pvtx:	proc;
      265 
      266 /* Gets pvt index by scanning disk table for pv name. */
      267 
      268 	     call get_temp_segments_ (myname, q, code);
      269 	     if code ^= 0 then do;
      270 		call com_err_ (code, myname, "Getting temp segment for disk table");
      271 		go to nlexit;
      272 	     end;
      273 	     dtp = q (1);
      274 	     call mdc_$read_disk_table (dtp, code);
      275 	     if code ^= 0 then do;
      276 		call com_err_ (code, myname, "Getting disk table");
      277 		go to nlexit;
      278 	     end;
      279 	     do pvtx = 1 to dt.n_entries;
      280 		if dt.array (pvtx).pvname = pvname & dt.array (pvtx).used then do;
      281 		     pvid = dt.array (pvtx).pvid;
      282 		     return;
      283 		end;
      284 	     end;
      285 	     code = error_table_$pvid_not_found ;
      286 	end;
      287 
      288 
      289 /*  */
      290 
      291 	/*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  1     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  1     7*       1. Declare version constant properly.
  1     8*       2. Remove version 1 since it was never referenced and to force
  1     9*          callers to upgrade their programs.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  1    14 
  1    15 /* this include files gives the argument structure for create_branch_ */
  1    16 
  1    17 dcl 1 create_branch_info aligned based,
  1    18     2 version fixed bin,				/* set this to the largest value given below */
  1    19     2 switches unaligned,
  1    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  1    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  1    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  1    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  1    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  1    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  1    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  1    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  1    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  1    29     2 userid char (32),				/* user's access control name */
  1    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  1    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  1    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  1    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  1    34 
  1    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  1    36 
  1    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  1    38 
      291 
      292 	/* BEGIN INCLUDE FILE ... retv_append_args.incl.pl1 ... Modified BIM 84-03-16 */
  2     2 
  2     3 dcl  retv_append_argp ptr;
  2     4 
  2     5 dcl 1 retv_append_args based (retv_append_argp) aligned,
  2     6     2 version char (8) aligned,
  2     7     2 level fixed bin,
  2     8     2 access_authorization bit (72), /* of user making request */
  2     9     2 max_access_authorization bit (72), /* ditto */
  2    10     2 ep ptr,
  2    11     2 flags,
  2    12      (3 link bit (1),
  2    13       3 cross_segment bit (1))unal;
  2    14 
  2    15 declare RETV_APPEND_ARGS_VERSION_1 char (8) aligned init ("rtvag001") int static options (constant);
  2    16 
  2    17 /* END INCLUDE FILE ... retv_append_args.incl.pl1 */
      292 
      293 	/*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  3     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  3     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  3     4 
  3     5 dcl  vtocep ptr;
  3     6 
  3     7 dcl 1 vtoce based (vtocep) aligned,
  3     8 
  3     9 
  3    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  3    11 
  3    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  3    13 
  3    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  3    16     2 records bit (9),				/* number of records used by the seg in second storage */
  3    17     2 pad2 bit (9),
  3    18 
  3    19     2 dtu bit (36),					/* date and time segment was last used */
  3    20 
  3    21     2 dtm bit (36),					/* date and time segment was last modified */
  3    22 
  3    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    24     2 deciduous bit (1),				/* true if hc_sdw */
  3    25     2 nid bit (1),					/* no incremental dump switch */
  3    26     2 dnzp bit (1),					/* Dont null zero pages */
  3    27     2 gtpd bit (1),					/* Global transparent paging device */
  3    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  3    29     2 damaged bit (1),				/* TRUE if contents damaged */
  3    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  3    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  3    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  3    33     2 pad3 bit (8),
  3    34     2 dirsw bit (1),				/* directory switch */
  3    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  3    36     2 pad4 bit (16)) unaligned,			/* not used */
  3    37 
  3    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  3    39 
  3    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    41 
  3    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    43 
  3    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  3    45 
  3    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  3    47 
  3    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  3    49 
  3    50 
  3    51 
  3    52 
  3    53 
  3    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  3    55 
  3    56     2 pad6 (10) bit (36),				/* not used */
  3    57 
  3    58     2 ncd bit (1),					/* no complete dump switch */
  3    59     2 pad7 bit (17),
  3    60     2 pad8 bit (18),
  3    61 
  3    62     2 dtd bit (36),					/* date-time-dumped */
  3    63 
  3    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  3    65 
  3    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  3    67 
  3    68 
  3    69 
  3    70 
  3    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  3    72 
  3    73     2 primary_name char (32),				/* primary name of the segment */
  3    74 
  3    75     2 time_created bit (36),				/* time the segment was created */
  3    76 
  3    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  3    78 
  3    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  3    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  3    81 
  3    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  3    83 
  3    84     2 access_class bit (72),				/* access class in branch */
  3    85     2 perm_flags aligned,
  3    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  3    87       3 pad9 bit (35) unal,
  3    88     2 owner bit (36);				/* pvid of this volume */
  3    89 
  3    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  3    91 
  3    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  3    93     2 pad1 bit (7*36),
  3    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    95     2 pad2 bit (184*36);
  3    96 
  3    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      293 
  4     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  4     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  4     7*     Add support for subvolumes.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10 
  4    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  4    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  4    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  4    14 
  4    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  4    16 
  4    17 dcl  dtp ptr,
  4    18      dtep ptr,
  4    19      lvep ptr;
  4    20 
  4    21      
  4    22 
  4    23 dcl 1 dt based (dtp) aligned,
  4    24 
  4    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  4    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  4    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  4    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  4    29     2 version fixed bin init (1),
  4    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  4    31     2 pad (2) bit (36),
  4    32     2 array (0 refer (dt.max_n_entries)) like dte,
  4    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  4    34 
  4    35 dcl 1 dte based (dtep) aligned,
  4    36     2 drive_name char (8),				/* device name */
  4    37     (2 device_type fixed bin (8),			/* device type */
  4    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  4    39     2 known bit (1),				/* TRUE if label has been read and checked */
  4    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  4    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  4    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  4    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  4    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  4    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  4    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  4    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  4    48     2 is_sub_vol bit (1),
  4    49     2 pad bit (3),
  4    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  4    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  4    52     2 sv_num  fixed bin unal,				/* this sv number */
  4    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  4    54     2 sv_name   char (2) aligned,
  4    55     2 pvid bit (36),				/* physical volume ID */
  4    56     2 pvname char (32);				/* Physical volume name. */
  4    57 
  4    58 dcl 1 lve based (lvep) aligned,
  4    59     2 lvid bit (36),				/* logical volume ID */
  4    60     (2 used bit (1),				/* TRUE if entry used */
  4    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  4    62     2 public bit (1),				/* TRUE for public vol */
  4    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  4    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  4    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  4    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  4    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  4    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  4    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  4    70     2 pad bit (26)) unal,
  4    71     2 lvname char (32),				/* Logical volume name */
  4    72     2 min_access_class bit (72),			/* Security stuff */
  4    73     2 max_access_class bit (72);			/* .. */
  4    74 
  4    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      294 
      295 	     declare		/* Structure returned by hcs_$status_long */
  5     2 
  5     3 	1 branch_status aligned,				/* automatic: hcs_$status uses a pointer */
  5     4 
  5     5 	  2 type bit(2) unaligned,				/* type of entry: link, segment, dir */
  5     6 	  2 number_names bit(16) unaligned,			/* unused by directory_status_ */
  5     7 	  2 names_rel_pointer bit(18) unaligned,		/* unused by directory_status_ */
  5     8 	  2 date_time_modified bit(36) unaligned,		/* date time modified */
  5     9 	  2 date_time_used bit(36) unaligned,			/* date time entry used */
  5    10 	  2 mode bit(5) unaligned,				/* effective access of caller */
  5    11 	  2 raw_mode bit(5) unaligned,
  5    12 	  2 pad1 bit(8) unaligned,
  5    13 	  2 records bit(18) unaligned,			/* number of records in use */
  5    14 	  2 date_time_dumped bit(36) unaligned,			/* date time last dumped */
  5    15 	  2 date_time_entry_modified bit(36) unaligned,		/* date time entry modified */
  5    16 	  2 lvid bit(36) unaligned,				/* logical volume id */
  5    17 	  2 current_length bit(12) unaligned,			/* number of blocks currently allocated */
  5    18 	  2 bit_count bit(24) unaligned,			/* bit count of entry */
  5    19 	  2 pad3 bit(8) unaligned,
  5    20 	  2 copy_switch bit(1) unaligned,			/* the copy switch */
  5    21 	  2 tpd bit(1) unaligned,				/* transparent to paging device */
  5    22 	  2 mdir bit(1) unaligned,				/* master directory switch */
  5    23 	  2 damaged_switch bit (1) unaligned,			/* true if contents damaged */
  5    24 	  2 synchronized_switch bit (1) unaligned,		/* true if a DM synchronized file */
  5    25 	  2 pad4 bit(5) unaligned,
  5    26 	  2 ring_brackets (0:2) bit(6) unaligned,		/* branch ring brackets */
  5    27 	  2 unique_id bit(36) unaligned,			/* entry unique id */
  5    28 
  5    29 
  5    30 	     /* The types of each class of branch */
  5    31 	segment_type bit(2) aligned internal static initial ("01"b),
  5    32 	directory_type bit(2) aligned internal static initial ("10"b),
  5    33 	msf_type bit(2) aligned internal static initial ("10"b),	/* will eventually be different */
  5    34 	link_type bit(2) aligned internal static initial ("00"b);
  5    35 
  5    36 
      295 
      296 	/*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  6     2 
  6     3 
  6     4 /* Template for an entry. Length = 38 words */
  6     5 
  6     6 dcl  ep ptr;
  6     7 
  6     8 dcl 1 entry based (ep) aligned,
  6     9 
  6    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  6    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  6    12 
  6    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  6    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  6    15 
  6    16     2 uid bit (36),					/* unique id of entry */
  6    17 
  6    18     2 dtem bit (36),				/* date-time entry modified */
  6    19 
  6    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  6    21     2 pad0 bit (17),
  6    22     2 nnames fixed bin (17),				/* number of names for this entry */
  6    23 
  6    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  6    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  6    26 
  6    27     2 author,					/* user who created branch */
  6    28       3 pers_rp bit (18),				/* name of user who created branch */
  6    29       3 proj_rp bit (18),				/* project of user who created branch */
  6    30 
  6    31       3 tag char (1),				/* tag of user who created branch */
  6    32       3 pad1 char (3),
  6    33 
  6    34     2 primary_name bit (504),				/* first name on name list */
  6    35 
  6    36     2 dtd bit (36),					/* date time dumped */
  6    37 
  6    38     2 pad2 bit (36),
  6    39 
  6    40 
  6    41 /* the declarations below are for branch only */
  6    42 
  6    43 
  6    44     2 pvid bit (36),				/* physical volume id */
  6    45 
  6    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  6    47     2 pad3 bit (18),
  6    48 
  6    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  6    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  6    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  6    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  6    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  6    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  6    55     2 audit_flag bit (1),				/* segment must be audited for security */
  6    56     2 security_oosw bit (1),				/* security out of service switch */
  6    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  6    58     2 master_dir bit (1),				/* TRUE for master directory */
  6    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  6    60     2 pad4 bit (11),
  6    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  6    62 
  6    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  6    64 
  6    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  6    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  6    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  6    68 
  6    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  6    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  6    71 
  6    72     2 bc_author,					/* user who last set the bit count */
  6    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  6    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  6    75 
  6    76       3 tag char (1),				/* tag of user who set the bit count */
  6    77       3 pad5 bit (2),
  6    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  6    79 
  6    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  6    81 
  6    82     2 pad6 bit (36),
  6    83 
  6    84     2 checksum bit (36),				/* checksum from dtd */
  6    85 
  6    86     2 owner bit (36);				/* uid of containing directory */
  6    87 
  6    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      296 
      297 
      298 seg_type_getter: proc () returns (bit (18));
      299 						/* This is here to avoid include file name conflict on link_type */
      300 	     return (SEG_TYPE);
      301 	     /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  7     2 
  7     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  7     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  7     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  7     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  7     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  7     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  7     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  7    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  7    11 
  7    12 dcl  access_name_type fixed bin static options (constant) init (1);
  7    13 dcl  acle_type fixed bin static options (constant) init (2);
  7    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  7    15 dcl  dir_type fixed bin static options (constant) init (4);
  7    16 dcl  link_type fixed bin static options (constant) init (5);
  7    17 dcl  name_type fixed bin static options (constant) init (6);
  7    18 dcl  seg_type fixed bin static options (constant) init (7);
  7    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  7    20 
  7    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      301 
      302 	end;
      303      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/89  0800.8  adopt_seg.pl1                     >special_ldd>install>MR12.3-1025>adopt_seg.pl1
291          1    03/15/89  0759.4  create_branch_info.incl.pl1       >special_ldd>install>MR12.3-1025>create_branch_info.incl.pl1
292          2    03/23/84  1928.6  retv_append_args.incl.pl1         >ldd>include>retv_append_args.incl.pl1
293          3    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
294          4    07/24/86  2051.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
295          5    11/22/82  0955.6  branch_status.incl.pl1            >ldd>include>branch_status.incl.pl1
296          6    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
301          7    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RETV_APPEND_ARGS_VERSION_1      000000 constant        char(8)                  initial dcl 2-15 ref 159
SEG_TYPE                        002353 constant        bit(18)                  initial packed unaligned dcl 7-9 ref 300
a_dirname                              parameter       char                     packed unaligned dcl 238 ref 236 248
a_ename                                parameter       char                     packed unaligned dcl 239 ref 236 249
a_pvid                                 parameter       bit(36)                  dcl 240 ref 236 251
a_pvtx                                 parameter       fixed bin(17,0)          dcl 241 ref 236 252
a_vtocx                                parameter       fixed bin(17,0)          dcl 242 ref 236 253
aabsname                        000645 automatic       char(168)                packed unaligned dcl 56 set ref 89* 90* 134* 152*
                                                                                  215* 224* 224 228* 248* 258*
access_authorization      3     000474 automatic       bit(72)                  level 2 dcl 41 set ref 170*
access_class             20     000507 automatic       bit(72)                  level 2 in structure "cbi" dcl 42 in procedure
                                                                                  "adopt_seg" set ref 196*
access_class            274            based           bit(72)                  level 2 in structure "vtoce" dcl 3-7 in procedure
                                                                                  "adopt_seg" set ref 169 177* 196
addr                                                   builtin function         dcl 18 ref 103 104 124 124 215 215 215 215
aim_check_$greater              000036 constant        entry                    external dcl 29 ref 177
apdir                           000553 automatic       char(168)                packed unaligned dcl 54 set ref 90* 124* 128* 128
                                                                                  167* 258*
apent                           000625 automatic       char(32)                 packed unaligned dcl 54 set ref 90* 124* 128* 167*
                                                                                  258*
aretv_args                      000474 automatic       structure                level 1 dcl 41 set ref 215 215
arg                                    based           char                     packed unaligned dcl 50 set ref 69 72* 79* 81* 89*
                                                                                  92*
argl                            000546 automatic       fixed bin(17,0)          dcl 51 set ref 63* 69 72 72 77* 79 79 81 81 86* 89
                                                                                  89 92 92
argp                            000550 automatic       pointer                  dcl 51 set ref 63* 69 72 77* 79 81 86* 89 92
array                    10            based           structure                array level 2 dcl 4-23
bc                       40(11)        based           fixed bin(24,0)          level 2 packed packed unaligned dcl 6-8 set ref 208*
bit                                                    builtin function         dcl 18 ref 203 212
bitcnt                   16     000507 automatic       fixed bin(24,0)          level 2 dcl 42 set ref 195* 208
branch_status                   000724 automatic       structure                level 1 dcl 5-1
brinfo                          000532 automatic       structure                level 1 dcl 43 set ref 124 124
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 6-8 set ref 200*
cbi                             000507 automatic       structure                level 1 dcl 42 set ref 173* 215 215
chase_sw                  1(02) 000507 automatic       bit(1)                   level 3 packed packed unaligned dcl 42 set ref 176*
cleanup                         000102 stack reference condition                dcl 31 ref 62 246
code                            000125 automatic       fixed bin(35,0)          dcl 36 set ref 63* 64 65* 71 72* 77* 78 79* 80 86*
                                                                                  87 89* 90 90* 91 92* 106* 107 109* 115* 124* 125
                                                                                  125 126 128* 132* 134* 144* 146* 167* 177 215* 218
                                                                                  223 224* 255* 256 258* 259 268* 269 270* 274* 275
                                                                                  276* 285*
com_err_                        000046 constant        entry                    external dcl 46 ref 65 72 81 92 109 118 128 134 146
                                                                                  152 224 270 276
create_branch_info                     based           structure                level 1 dcl 1-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 1-35 ref 174
csl                       2(09)        based           bit(9)                   level 2 packed packed unaligned dcl 3-7 ref 195
cu_$arg_ptr                     000050 constant        entry                    external dcl 49 ref 63 77 86
cu_$level_get                   000010 constant        entry                    external dcl 20 ref 161
cv_oct_check_                   000052 constant        entry                    external dcl 53 ref 79
dir_quota                22     000507 automatic       fixed bin(18,0)          level 2 dcl 42 set ref 193*
dir_sw                    1     000507 automatic       bit(1)                   level 3 packed packed unaligned dcl 42 set ref 175*
                                                                                  187
directory_type                         constant        bit(2)                   initial dcl 5-1 ref 131
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 6-8 in procedure "adopt_seg" set ref 211* 212
dirsw                     5(18)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 3-7 in procedure "adopt_seg" ref 175 191 211
dt                                     based           structure                level 1 dcl 4-23
dtd                      26            based           bit(36)                  level 2 packed packed unaligned dcl 6-8 set ref 207*
dte                                    based           structure                level 1 dcl 4-35
dtem                      3            based           bit(36)                  level 2 dcl 6-8 set ref 209*
dtp                             000722 automatic       pointer                  dcl 4-17 set ref 273* 274* 279 280 280 281
empty                                                  builtin function         dcl 18 ref 123
entry                                  based           structure                level 1 dcl 6-8 set ref 198*
ep                              000736 automatic       pointer                  dcl 6-6 in procedure "adopt_seg" set ref 104* 162
                                                                                  198 199 200 201 202 203 204 205 206 207 208 209
                                                                                  210 211 212 212
ep                       10     000474 automatic       pointer                  level 2 in structure "aretv_args" dcl 41
                                                                                  in procedure "adopt_seg" set ref 162*
error_table_$action_not_performed
                                000020 external static fixed bin(35,0)          dcl 23 ref 115
error_table_$not_seg_type       000022 external static fixed bin(35,0)          dcl 23 ref 132
error_table_$pvid_not_found     000014 external static fixed bin(35,0)          dcl 22 ref 285
error_table_$root               000016 external static fixed bin(35,0)          dcl 22 ref 125 144
ex_ring_brackets         35(09)        based           bit(3)                   array level 2 packed packed unaligned dcl 6-8 set
                                                                                  ref 212*
expand_pathname_                000042 constant        entry                    external dcl 45 ref 89 90 258
fixed                                                  builtin function         dcl 18 ref 195 203 212
flags                    12     000474 automatic       structure                level 2 dcl 41
get_temp_segments_              000024 constant        entry                    external dcl 25 ref 255 268
hc_backup_$retv_append          000034 constant        entry                    external dcl 28 ref 215
hcs_$get_access_class           000032 constant        entry                    external dcl 27 ref 167
hcs_$status_long                000030 constant        entry                    external dcl 26 ref 124
i                               000124 automatic       fixed bin(17,0)          dcl 35 set ref 76* 139* 140* 142* 142 143 150
ioa_                            000044 constant        entry                    external dcl 46 ref 228
level                           000100 automatic       fixed bin(17,0)          dcl 19 in procedure "adopt_seg" set ref 161* 189 212
level                     2     000474 automatic       fixed bin(17,0)          level 2 in structure "aretv_args" dcl 41
                                                                                  in procedure "adopt_seg" set ref 160*
link                     12     000474 automatic       bit(1)                   level 3 packed packed unaligned dcl 41 set ref 171*
local_entry                     000426 automatic       structure                level 1 dcl 40 set ref 104
local_vtoce                     000126 automatic       structure                level 1 dcl 39 set ref 103
lve                                    based           structure                level 1 dcl 4-58
max_access_authorization
                          5     000474 automatic       bit(72)                  level 2 dcl 41 set ref 169*
mdc_$read_disk_table            000012 constant        entry                    external dcl 21 ref 274
mode                      2     000507 automatic       bit(3)                   level 2 packed packed unaligned dcl 42 set ref 186*
myname                          000002 constant        char(20)                 initial packed unaligned dcl 37 set ref 62* 65* 65*
                                                                                  72* 81* 92* 109* 118* 128* 134* 146* 152* 219*
                                                                                  224* 229* 246* 255* 268* 270* 276*
n_entries                              based           fixed bin(17,0)          level 2 dcl 4-23 ref 279
nnames                    4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-8 set ref 205*
null                                                   builtin function         dcl 18 ref 33
owner                    44            based           bit(36)                  level 2 dcl 6-8 set ref 206*
parent_ac_sw              1(04) 000507 automatic       bit(1)                   level 3 packed packed unaligned dcl 42 set ref 180*
                                                                                  184*
parent_acc                      000110 automatic       bit(72)                  dcl 32 set ref 167* 170 177*
phcs_$get_vtoce                 000040 constant        entry                    external dcl 38 ref 106
priv_upgrade_sw           1(03) 000507 automatic       bit(1)                   level 3 packed packed unaligned dcl 42 set ref 179*
                                                                                  183* 187
pvid                            000552 automatic       bit(36)                  dcl 52 in procedure "adopt_seg" set ref 201 251*
                                                                                  281*
pvid                     15            based           bit(36)                  array level 3 in structure "dt" dcl 4-23
                                                                                  in procedure "adopt_seg" ref 281
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 6-8 in procedure "adopt_seg" set ref 201*
pvname                   16            based           char(32)                 array level 3 in structure "dt" dcl 4-23
                                                                                  in procedure "adopt_seg" ref 280
pvname                          000114 automatic       char(32)                 packed unaligned dcl 34 in procedure "adopt_seg" set
                                                                                  ref 69* 118* 280
pvtx                            000544 automatic       fixed bin(17,0)          dcl 47 set ref 106* 109* 252* 279* 280 280 281*
q                               000112 automatic       pointer                  initial array dcl 33 set ref 33* 62* 123 124* 219*
                                                                                  229* 246* 255* 268* 273
quota                    17     000507 automatic       fixed bin(18,0)          level 2 in structure "cbi" dcl 42 in procedure
                                                                                  "adopt_seg" set ref 192*
quota                     7            based           fixed bin(18,0)          array level 2 in structure "vtoce" packed packed
                                                                                  unsigned unaligned dcl 3-7 in procedure
                                                                                  "adopt_seg" ref 192 193
rcode                                  parameter       fixed bin(35,0)          dcl 243 set ref 218* 236
release_temp_segments_          000026 constant        entry                    external dcl 25 ref 62 219 229 246
retv_append_args                       based           structure                level 1 dcl 2-5
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 6-8 set
                                                                                  ref 203*
rings                     3     000507 automatic       fixed bin(3,0)           array level 2 dcl 42 set ref 187* 189* 203
rtrname                         000635 automatic       char(32)                 packed unaligned dcl 55 set ref 89* 215* 224* 228*
                                                                                  249*
size                      1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-8 set ref 204*
sub_entry                       000101 automatic       bit(1)                   packed unaligned dcl 24 set ref 61* 108 114 127 133
                                                                                  145 151 217 245*
switches                  1     000507 automatic       structure                level 2 packed packed unaligned dcl 42
type                      1            based           bit(18)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 6-8 in procedure "adopt_seg" set ref 199*
type                            000532 automatic       bit(2)                   level 2 in structure "brinfo" packed packed
                                                                                  unaligned dcl 43 in procedure "adopt_seg" set ref
                                                                                  131
uid                       1            based           bit(36)                  level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 3-7 in procedure "adopt_seg" set ref 113 210
                                                                                  228*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 6-8 in procedure
                                                                                  "adopt_seg" set ref 210*
uid_path                240            based           bit(36)                  array level 2 packed packed unaligned dcl 3-7 ref
                                                                                  140 150
unique_id                11     000532 automatic       bit(36)                  level 2 packed packed unaligned dcl 43 set ref 125*
                                                                                  150 206
unspec                                                 builtin function         dcl 18 set ref 173* 198*
used                     12(09)        based           bit(1)                   array level 3 packed packed unaligned dcl 4-23 ref
                                                                                  280
userid                    6     000507 automatic       char(32)                 level 2 dcl 42 set ref 190*
version                         000474 automatic       char(8)                  level 2 in structure "aretv_args" dcl 41
                                                                                  in procedure "adopt_seg" set ref 159*
version                         000507 automatic       fixed bin(17,0)          level 2 in structure "cbi" dcl 42 in procedure
                                                                                  "adopt_seg" set ref 174*
vtoce                                  based           structure                level 1 dcl 3-7
vtocep                          000720 automatic       pointer                  dcl 3-5 set ref 103* 106* 113 140 150 169 175 177
                                                                                  191 192 193 195 196 210 211 228
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 6-8 in procedure "adopt_seg" set ref 202*
vtocx                           000545 automatic       fixed bin(17,0)          dcl 47 in procedure "adopt_seg" set ref 79* 106*
                                                                                  109* 118* 202 253*
xarea                                  based           area(10000)              dcl 48 set ref 123*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 7-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 7-4
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 7-5
DIR_TYPE                               internal static bit(18)                  initial packed unaligned dcl 7-6
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 7-10
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 7-7
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 7-8
access_name_type                       internal static fixed bin(17,0)          initial dcl 7-12
acle_type                              internal static fixed bin(17,0)          initial dcl 7-13
dir_header_type                        internal static fixed bin(17,0)          initial dcl 7-14
dir_type                               internal static fixed bin(17,0)          initial dcl 7-15
dtep                                   automatic       pointer                  dcl 4-17
hash_table_type                        internal static fixed bin(17,0)          initial dcl 7-19
link_type                              internal static bit(2)                   initial dcl 5-1 in procedure "adopt_seg"
link_type                              internal static fixed bin(17,0)          initial dcl 7-16 in procedure "seg_type_getter"
lvep                                   automatic       pointer                  dcl 4-17
msf_type                               internal static bit(2)                   initial dcl 5-1
name_type                              internal static fixed bin(17,0)          initial dcl 7-17
retv_append_argp                       automatic       pointer                  dcl 2-3
seg_type                               internal static fixed bin(17,0)          initial dcl 7-18
seg_vtoce                              based           structure                level 1 dcl 3-92
segment_type                           internal static bit(2)                   initial dcl 5-1
vtoce_parts                            based           bit(2304)                array dcl 3-90

NAMES DECLARED BY EXPLICIT CONTEXT.
adopt_seg                       000214 constant        entry                    external dcl 11
adopt_seg_                      002014 constant        entry                    external dcl 236
get_pvtx                        002171 constant        entry                    internal dcl 264 ref 70
glev                            001154 constant        label                    dcl 142 ref 140
nlexit                          001763 constant        label                    dcl 229 ref 73 82 93 110 119 129 135 147 153 225 271
                                                                                  277
notacted                        000712 constant        label                    dcl 115 ref 151
process                         000624 constant        label                    dcl 103 ref 261
rrcode                          001634 constant        label                    dcl 218 ref 108 116 127 133 145 256 259
seg_type_getter                 002337 constant        entry                    internal dcl 298 ref 199
usage                           000303 constant        label                    dcl 65 ref 78 87

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2636        2712    2356        2646
Length      3270    2356        54         341     257           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
adopt_seg                           611 external procedure  is an external procedure.  
on unit on line 62                   80 on unit               
on unit on line 246                  80 on unit               
get_pvtx                                internal procedure  shares stack frame of external procedure adopt_seg.  
seg_type_getter                         internal procedure  shares stack frame of external procedure adopt_seg.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
adopt_seg                000100 level                       adopt_seg
                         000101 sub_entry                   adopt_seg
                         000110 parent_acc                  adopt_seg
                         000112 q                           adopt_seg
                         000114 pvname                      adopt_seg
                         000124 i                           adopt_seg
                         000125 code                        adopt_seg
                         000126 local_vtoce                 adopt_seg
                         000426 local_entry                 adopt_seg
                         000474 aretv_args                  adopt_seg
                         000507 cbi                         adopt_seg
                         000532 brinfo                      adopt_seg
                         000544 pvtx                        adopt_seg
                         000545 vtocx                       adopt_seg
                         000546 argl                        adopt_seg
                         000550 argp                        adopt_seg
                         000552 pvid                        adopt_seg
                         000553 apdir                       adopt_seg
                         000625 apent                       adopt_seg
                         000635 rtrname                     adopt_seg
                         000645 aabsname                    adopt_seg
                         000720 vtocep                      adopt_seg
                         000722 dtp                         adopt_seg
                         000724 branch_status               adopt_seg
                         000736 ep                          adopt_seg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return_mac          enable_op
ext_entry           ext_entry_desc      int_entry           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$greater            com_err_                      cu_$arg_ptr                   cu_$level_get
cv_oct_check_                 expand_pathname_              get_temp_segments_            hc_backup_$retv_append
hcs_$get_access_class         hcs_$status_long              ioa_                          mdc_$read_disk_table
phcs_$get_vtoce               release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$not_seg_type     error_table_$pvid_not_found
error_table_$root




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     33 000202        11 000213        61 000222        62 000223        63 000262        64 000301        65 000303
     66 000332        69 000333        70 000340        71 000341        72 000343        73 000367        76 000370
     77 000372        78 000411        79 000413        80 000437        81 000441        82 000475        86 000476
     87 000515        89 000517        90 000547        91 000575        92 000577        93 000623       103 000624
    104 000626       106 000630       107 000645       108 000647       109 000651       110 000704       113 000705
    114 000710       115 000712       116 000715       118 000716       119 000753       123 000754       124 000757
    125 001016       126 001026       127 001030       128 001032       129 001100       131 001101       132 001105
    133 001110       134 001112       135 001141       139 001142       140 001147       141 001152       142 001154
    143 001156       144 001161       145 001164       146 001166       147 001211       150 001212       151 001216
    152 001220       153 001251       159 001252       160 001254       161 001256       162 001265       167 001267
    169 001314       170 001321       171 001324       173 001326       174 001331       175 001333       176 001340
    177 001342       179 001364       180 001366       181 001370       183 001371       184 001373       186 001375
    187 001401       189 001422       190 001433       191 001436       192 001442       193 001445       194 001450
    195 001451       196 001456       198 001462       199 001466       200 001474       201 001477       202 001501
    203 001504       204 001526       205 001530       206 001532       207 001534       208 001535       209 001541
    210 001542       211 001545       212 001552       215 001576       217 001632       218 001634       219 001637
    220 001661       223 001662       224 001664       225 001731       228 001732       229 001763       231 002005
    236 002006       245 002035       246 002037       248 002076       249 002104       251 002111       252 002113
    253 002115       255 002117       256 002140       258 002142       259 002166       261 002170       264 002171
    268 002172       269 002213       270 002215       271 002241       273 002242       274 002244       275 002255
    276 002257       277 002303       279 002304       280 002313       281 002326       282 002330       284 002331
    285 002333       286 002336       298 002337       300 002341


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
