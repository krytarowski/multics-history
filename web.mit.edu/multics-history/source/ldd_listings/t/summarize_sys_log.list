	COMPILATION LISTING OF SEGMENT summarize_sys_log
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/01/89  1356.7 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1989                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style2,indcomtxt */
       10 
       11 ssl:
       12 summarize_sys_log:
       13      procedure options (variable);
       14 
       15 /**** This command scans a standard system log for specified text
       16*      strings, writing information to pre-attached IO switches.
       17*
       18*      A control file (in an archaic and incomprehensible format)
       19*      controls what is written to the switches.
       20*
       21*      Distribution of the output is controlled by the control file.
       22*      This file has comment lines beginning with "*", and lines of the form
       23*
       24*      .	streamname,S,opcode,text
       25*
       26*      streamname	is the name of the stream on which a line will be written.
       27*      S		Is the severity to be selected, in the form L:H
       28*      .			*	selects all lines.
       29*      opcode 	is the operation code (see below)
       30*      text		is optional text which is the operand of opcode.
       31*
       32*      Legal opcodes are:
       33*      .	all	selects all lines at this severity
       34*      .	any	selects all lines containing text
       35*      .	begin	selects all lines beginning text
       36*      .	not	inhibits all lines containing text
       37*      .	nbegin	inhibits all lines beginning text
       38*      .	count	counts all lines containing text
       39*      .	bcount	counts all lines beginning text
       40*      .	allx	same as all but binary data is expanded
       41*      .	anyx	same as any but binary data is expanded
       42*      .	beginx	same as begin, but binary data is expanded
       43*
       44*      "not" and "nbegin" must precede any selectors they are to inhibit, for a given stream.
       45*
       46*      At the end of processing, total lines are written. Then, if any lines were selected, a total count is output.
       47*
       48*      THVV as daily_syserr_process
       49**/
       50 
       51 /* Modified November 1975 by Larry Johnson for new syserr format */
       52 /* Modified April 1976 by Larry Johnson to work correctly if first message read is "=" */
       53 /* Modified September 1982 by E. N. Kittlitz to increase number of selectors and streams and check array bounds */
       54 /* Modified 1984-12-03, BIM: converted to summarize_sys_log. */
       55 /* Modified 1984-12-26, BIM: Added -continuation_indent. */
       56 /* Modified 1985-02-21, Steve Herbst: Changed -dms to call dm_misc_util_$get_log_path */
       57 /* Modified 1985-03-14, Steve Herbst: Fixed to recheck time range at end of find_first_message. Fixes bug where */
       58 /*		if no messages within time range, procedure was getting the previous and next messages. */
       59 /* Modified 1985-04-09, Steve Herbst: Fixed OOB caused by star-extent reference to switches_inhibited array */
       60 /* Modified 1985-04-17, Steve Herbst: Fixed bug causing failure when using an already open output switch */
       61 /* Modified 1985-05-02, Steve Herbst: Fixed to ensure from_time<=to_time. */
       62 
       63 
       64 /****^  HISTORY COMMENTS:
       65*  1) change(86-04-30,Kissel), approve(86-07-31,MCR7456), audit(86-08-01,Wong),
       66*     install(86-11-03,MR12.0-1149):
       67*     Modified to support DSA logs using the -dsasl and -dsasal control
       68*     arguments.
       69*  2) change(89-01-18,TLNguyen), approve(89-01-18,MCR8048),
       70*     audit(89-02-23,RBarstad), install(89-03-01,MR12.3-1018):
       71*     Fix the following errors:
       72*        1. The -to control argument is ignored by summarize_sys_log.  The
       73*           command processes the entry log from the date_time given in the
       74*           -from control argument to the current date_time always.
       75*        2. The command with no argument gets fault_tag_1.
       76*                                                   END HISTORY COMMENTS */
       77 
       78 
       79 	declare COMMAND_NAME	 char (32) int static init ("summarize_sys_log") options (constant);
       80 
       81 	declare sci_ptr		 pointer;
       82 	declare arg_count		 fixed bin;
       83 	declare ap		 ptr;
       84 	declare al		 fixed bin (21);
       85 	declare arg		 char (al) based (ap);
       86 
       87 	declare dm_system_log_path	 char (168);
       88 	declare dsa_system_log_path	 char (168);
       89 	declare code		 fixed bin (35);
       90 
       91 	declare absolute_pathname_$add_suffix
       92 				 entry (character (*), character (*), character (*), fixed binary (35));
       93 	declare check_gate_access_	 entry (char (*), ptr, fixed bin (35));
       94 	declare convert_date_to_binary_
       95 				 entry (char (*), fixed bin (71), fixed bin (35));
       96 	declare cu_$arg_list_ptr	 entry returns (pointer);
       97 	declare com_err_		 entry () options (variable);
       98 	declare cv_dec_check_	 entry (character (*), fixed binary (35)) returns (fixed binary (35));
       99 	declare dm_misc_util_$get_log_path
      100 				 entry (char (*));
      101 	declare dsa_nit_$get_field	 entry (char (*), char (*), char (*), char (*), fixed bin (35));
      102 	declare expand_pathname_	 entry (character (*), character (*), character (*), fixed binary (35));
      103 	declare log_read_$open	 entry (character (*), character (*), pointer, fixed binary (35));
      104 	declare log_read_$open_long	 entry (character (*), character (*), pointer, pointer, fixed binary (35));
      105 	declare log_read_$free_message entry (pointer, pointer);
      106 	declare log_read_$hold_message entry (pointer, pointer);
      107 	declare log_read_$close	 entry (pointer, fixed binary (35));
      108 	declare log_read_$next_message entry (pointer, pointer, fixed binary (35));
      109 	declare log_read_$prev_message entry (pointer, pointer, fixed binary (35));
      110 	declare format_log_message_$init
      111 				 entry (pointer);
      112 	declare format_log_message_$adjust
      113 				 entry (pointer, fixed binary (35));
      114 	declare format_log_message_$free
      115 				 entry (pointer);
      116 	declare format_log_message_$format
      117 				 entry (pointer, pointer, pointer, character (*) var, character (*) var,
      118 				 fixed binary (35));
      119 
      120 	declare expand_log_message_	 entry (pointer, pointer, pointer, character (*) var, fixed binary (35));
      121 	declare log_format_time_	 entry (fixed binary (71)) returns (character (32) var);
      122 	declare log_limit_scan_	 entry (pointer, pointer, bit (1) aligned, pointer);
      123 
      124 	declare log_match_$add_match	 entry (pointer, character (*));
      125 	declare log_match_$add_severity
      126 				 entry (pointer, fixed binary, fixed binary);
      127 	declare log_match_$test	 entry (pointer, pointer, character (*) varying) returns (bit (1) aligned);
      128 	declare log_match_$free	 entry (pointer);
      129 	declare log_match_$print	 entry (pointer, pointer, fixed binary);
      130 
      131 	declare ioa_		 entry options (variable);
      132 	declare ioa_$ioa_switch	 ext entry options (variable);
      133 	declare get_wdir_		 entry () returns (char (168));
      134 
      135 	declare (addr, addwordno, after, before, hbound, index, length, ltrim, null, rtrim, substr, unspec)
      136 				 builtin;
      137 
      138 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  1     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  1     7 
  1     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$close entry (pointer, fixed bin (35)),
  1    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    12      iox_$delete_record entry (pointer, fixed bin (35)),
  1    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    15      iox_$err_not_attached entry options (variable),
  1    16      iox_$err_not_closed entry options (variable),
  1    17      iox_$err_no_operation entry options (variable),
  1    18      iox_$err_not_open entry options (variable),
  1    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    28      iox_$propagate entry (pointer),
  1    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  1    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  1    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  1    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  1    40 
  1    41 dcl (iox_$user_output,
  1    42      iox_$user_input,
  1    43      iox_$user_io,
  1    44      iox_$error_output) external static pointer;
  1    45 
  1    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      139 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
      140 
      141 	declare pathname_		 entry (character (*), character (*)) returns (character (168));
      142 	declare ssu_$arg_count	 entry (ptr, fixed bin);
      143 	declare ssu_$get_area	 entry (ptr, ptr, char (*), ptr);
      144 	declare ssu_$standalone_invocation
      145 				 entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
      146 	declare ssu_$destroy_invocation
      147 				 entry (ptr);
      148 	declare ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin (21));
      149 	declare ssu_$abort_line	 entry () options (variable);
      150 	declare ssu_$print_message	 entry () options (variable);
      151 	declare ssu_$set_debug_mode	 entry (ptr, bit (1) aligned);
      152 
      153 	declare unique_chars_	 entry (bit (*)) returns (char (15));
      154 
      155 	declare log_data_$syserr_log_dir
      156 				 char (168) external;
      157 	declare log_data_$syserr_log_name
      158 				 char (32) external;
      159 
      160 	declare cleanup		 condition;
      161 
  3     1 /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  3     2 
  3     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  3     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  3     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  3     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  3     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  3     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  3     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  3    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  3    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  3    12 
  3    13 declare 1 log_message         aligned based (log_message_ptr),
  3    14           2 header            aligned like log_message_header,
  3    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  3    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  3    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  3    18 
  3    19 declare   log_message_ptr pointer;
  3    20 declare   log_message_text_lth fixed bin;
  3    21 declare   log_message_data_class_lth fixed bin;
  3    22 declare   log_message_data_lth fixed bin;
  3    23 
  3    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      162 
  4     1 /* BEGIN INCLUDE FILE ... log_message_format.incl.pl1 ... 84-07-03 ... W. Olin Sibert */
  4     2 
  4     3 declare 1 log_message_format            aligned based (log_message_format_ptr),
  4     4           2 caller                      char (32) unaligned, /* Caller name to use when printing error messages */
  4     5           2 line_lth                    fixed bin,          /* Max length of output lines; longer messages are folded */
  4     6           2 indentation                 fixed bin,          /* Number of spaces at beginning of each output line */
  4     7           2 equal_sw                    bit (1) aligned,    /* Whether to suppress messages with identical text */
  4     8           2 error_sw                    bit (1) aligned,    /* Whether to print error messages via com_err_ */
  4     9           2 prefix                      char (40) varying,  /* Prefix for printing messages */
  4    10           2 number_format               char (20) varying,  /* ioa_ format for printing message numbers */
  4    11           2 time_format                 char (40) varying,  /* date_time_$format string for message times */
  4    12           2 date_format                 char (40) varying,  /* date_time_$format string for when date changes */
  4    13           2 continuation_indent	fixed bin,	/* If >= zero, value for continuation lines */
  4    14 						/* Otherwise, lined up under the text by default */
  4    15 
  4    16           2 pad (59)                    bit (36) aligned,
  4    17 
  4    18 /* ONLY format_log_message_$adjust ever changes the values below */
  4    19 
  4    20           2 internal_info               aligned,            /* Internal info, set by $adjust-- DO NOT CHANGE */
  4    21             3 area_ptr                  pointer,            /* Where this structure is allocated */
  4    22             3 date_ioa_string           char (100) varying, /* Format for date breaks,if any */
  4    23             3 message_ioa_string        char (100) varying, /* Format for first lines of messages */
  4    24             3 real_continuation_indent  fixed bin,          /* Indentation for continuation lines */
  4    25             3 prefix_lth                fixed bin,          /* Length of indent + prefix + time + sequence + severity */
  4    26             3 date_modulus              fixed bin (36),     /* Modulus for checking whether dates are equal */
  4    27 
  4    28           2 end                         fixed bin;
  4    29 
  4    30 declare   log_message_format_ptr pointer;
  4    31 
  4    32 /* END INCLUDE FILE ... log_message_format.incl.pl1 */
      163 
  5     1 /* BEGIN INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
  5     2 /* Modified 1984-12-16, BIM: for a version number */
  5     3 
  5     4 declare   log_limit_info_ptr pointer;
  5     5 
  5     6 declare 1 log_limit_info      aligned based (log_limit_info_ptr),
  5     7           2 version           char (8) aligned,
  5     8           2 to_opt            char (50) varying,            /* Input: options supplied after control */
  5     9           2 from_opt          char (50) varying,            /* argument of this name */
  5    10           2 for_opt           char (50) varying,
  5    11           2 last_opt          char (50) varying,
  5    12 
  5    13           2 first_msg         pointer,                      /* Output: results of successful processing */
  5    14           2 last_msg          pointer,                      /* of above options */
  5    15           2 msg_count         fixed bin (35);
  5    16 
  5    17 declare LOG_LIMIT_INFO_VERSION_1 char (8) init ("lliv0001") internal static options (constant);
  5    18 
  5    19 /* END INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
      164 
  6     1 /* Begin include file log_read_open_data.incl.pl1 BIM 1984-12-15 */
  6     2 /* Use this with log_read_$open_long to specify special purpose options */
  6     3 
  6     4 declare log_read_open_info_ptr pointer;
  6     5 declare 1 log_read_open_info aligned based (log_read_open_info_ptr),
  6     6         2 version char (8) aligned,
  6     7         2 reader_procedure char (32) varying,		/* this is an outer ring opening, and this procedure retrieves from the inner ring */
  6     8         2 allocation_area_ptr pointer,			/* if reader_procedure is not "",  */
  6     9 						/* this is passed to it to for allocation */		
  6    10         2 allocate_copies bit (1) aligned;		/* incompatable with reader_procedure ^= "" */
  6    11 						/* indicates that this opening must allocate copies for use by an outer ring */
  6    12 
  6    13 declare LOG_READ_OPEN_INFO_VERSION_1
  6    14         char (8) init ("logro001") int static options (constant);
  6    15 
  6    16 /* End include file log_read_open_info.incl.pl1 */
      165 
      166 	declare 1 log_open_info	 aligned like log_read_open_info;
      167 
      168 	declare 1 opt		 aligned,
      169 		2 log_read_ptr	 pointer,
      170 		2 log_pathname	 char (168) unal,
      171 		2 control_file_pathname
      172 				 char (168) unal,
      173 		2 limit		 aligned like log_limit_info,
      174 		2 procedure	 char (32) unal,
      175 		2 control_iocb	 pointer,
      176 		2 long_sw		 bit (1) aligned,
      177 		2 debug_sw	 bit (1) aligned;
      178 
      179 	declare (
      180 	        SYSERR_PATH		 init ("<<SYSERR>>"),
      181 	        AS_PATH		 init ("<<AS>>"),
      182 	        ADMIN_PATH		 init ("<<ADMIN>>"),
      183 	        DM_PATH		 init ("<<DM>>"),
      184 	        DSASL_PATH		 init ("<<DSASL>>"),
      185 	        DSASAL_PATH		 init ("<<DSASAL>>")
      186 	        )			 char (32) int static options (constant);
      187 
      188 	declare 1 switches		 (1000) aligned,
      189 		2 switch		 char (32) unal,
      190 		2 prev_message_ptr	 pointer,
      191 		2 iocb_ptr	 pointer,
      192 		2 opened_here	 bit (1) aligned,	/* Opened by this program as a courtesy */
      193 		2 message_count	 fixed bin,
      194 		2 line_length	 fixed bin;
      195 
      196 	declare 1 selectors		 (1000) aligned,
      197 		2 switchx		 fixed bin,
      198 		2 opcode		 fixed bin,
      199 		2 match_ptr	 pointer,
      200 		2 message_count	 fixed bin,
      201 		2 exclude		 bit (1) aligned,	/* exclude all other selectors for the switch */
      202 		2 expand		 bit (1) aligned;
      203 
      204 
      205 	declare (n_switches, n_selectors)
      206 				 fixed bin;
      207 
      208 	declare line		 fixed bin;
      209 	declare dir_name		 char (168);
      210 	declare entryname		 char (32);
      211 	declare buffer_space	 char (1000);
      212 	declare buffer_length	 fixed bin (21);
      213 
      214 	declare (
      215 	        ALL		 init (1),
      216 	        ANY		 init (2),
      217 	        BEGIN		 init (3),
      218 	        NOT		 init (4),
      219 	        N_BEGIN		 init (5),
      220 	        COUNT		 init (6),
      221 	        B_COUNT		 init (7)
      222 	        )			 fixed bin int static options (constant);
      223 	declare DEFAULT_CONTROL_FILE	 char (32) init ("daily_report.ssl") int static options (constant);
      224 	declare CONTROL_SUFFIX	 char (32) init ("ssl") int static options (constant);
      225 
      226 	declare error_table_$not_attached
      227 				 fixed bin (35) ext static;
      228 	declare error_table_$end_of_info
      229 				 fixed bin (35) ext static;
      230 	declare error_table_$no_log_message
      231 				 fixed bin (35) ext static;
      232 	declare error_table_$bad_arg	 fixed bin (35) ext static;
      233 	declare error_table_$badopt	 fixed bin (35) ext static;
      234 	declare error_table_$moderr	 fixed bin (35) ext static;
      235 	declare error_table_$noarg	 fixed bin (35) ext static;
      236 	declare error_table_$noentry	 fixed bin (35) ext static;
      237 	declare error_table_$too_many_args
      238 				 fixed bin (35) ext static;
      239 	declare error_table_$bad_conversion
      240 				 fixed bin (35) ext static;
      241 
      242 
      243 	declare DM_READER_PROCEDURE	 char (32) init ("dm_log_read_") int static options (constant);
      244 	declare DSA_READER_PROCEDURE	 char (32) init ("dsa_log_admin_gate_") int static options (constant);
      245 
      246 
      247 
      248 	sci_ptr = null ();
      249 	log_message_format_ptr = null ();
      250 	opt.log_read_ptr = null ();
      251 	opt.control_iocb = null ();
      252 	n_selectors, n_switches = 0;
      253 
      254 	on cleanup call clean_up;
      255 
      256 	call ssu_$standalone_invocation (sci_ptr, COMMAND_NAME, "1.0", cu_$arg_list_ptr (), SSU_ABORT, code);
      257 	if code ^= 0
      258 	then do;
      259 		call com_err_ (code, COMMAND_NAME);
      260 		return;
      261 	     end;
      262 
      263 	call ssu_$arg_count (sci_ptr, arg_count);
      264 	if arg_count = 0
      265 	then call ssu_$abort_line (sci_ptr, 0, "Usage: ^a LOG_PATHNAME {-control_arguments}", COMMAND_NAME);
      266 
      267 	call initialize_options;
      268 	call process_arguments;
      269 
      270 /**** Now find things */
      271 
      272 /**** The log itself */
      273 
      274 	call make_log_pathname;			/* pathname of log */
      275 
      276 	if opt.procedure ^= ""
      277 	then do;
      278 		log_open_info.version = LOG_READ_OPEN_INFO_VERSION_1;
      279 		log_open_info.reader_procedure = opt.procedure;
      280 		call ssu_$get_area (sci_ptr, null (), "log_read_ copies", log_open_info.allocation_area_ptr);
      281 		log_open_info.allocate_copies = "0"b;	/* That is the inner-ring's job */
      282 		call log_read_$open_long (dir_name, entryname, addr (log_open_info), opt.log_read_ptr, code);
      283 	     end;
      284 	else call log_read_$open (dir_name, entryname, opt.log_read_ptr, code);
      285 	if code ^= 0
      286 	then call ssu_$abort_line (sci_ptr, code, "^a", opt.log_pathname);
      287 
      288 	call read_control_file;
      289 
      290 	call log_limit_scan_ (sci_ptr, addr (opt.limit), "0"b, opt.log_read_ptr);
      291 
      292 	call find_first_message ();
      293 
      294 
      295 	call print_limits (iox_$user_output, "1"b);
      296 
      297 	call process_messages ();
      298 
      299 
      300 	call clean_up;
      301 	return;
      302 
      303 
      304 clean_up:
      305      procedure;
      306 
      307 	declare slx		 fixed bin;
      308 
      309 	if opt.control_iocb ^= null ()
      310 	then do;
      311 		call iox_$close (opt.control_iocb, (0));
      312 		call iox_$detach_iocb (opt.control_iocb, (0));
      313 		call iox_$destroy_iocb (opt.control_iocb, (0));
      314 	     end;
      315 
      316 	if opt.log_read_ptr ^= null ()
      317 	then call log_read_$close (opt.log_read_ptr, (0));
      318 	if log_message_format_ptr ^= null ()
      319 	then call format_log_message_$free (log_message_format_ptr);
      320 	do slx = 1 to n_selectors;
      321 	     if selectors (slx).match_ptr ^= null ()
      322 	     then call log_match_$free (selectors (slx).match_ptr);
      323 	end;
      324 	do slx = 1 to n_switches;
      325 	     if switches (slx).opened_here
      326 	     then call iox_$close (switches (slx).iocb_ptr, (0));
      327 	end;
      328 
      329 	if sci_ptr ^= null ()
      330 	then call ssu_$destroy_invocation (sci_ptr);
      331 
      332 	return;
      333 
      334      end clean_up;
      335 
      336 
      337 make_log_pathname:
      338      procedure ();
      339 
      340 
      341 	if (opt.log_pathname = SYSERR_PATH)
      342 	then do;
      343 		dir_name = log_data_$syserr_log_dir;
      344 		entryname = log_data_$syserr_log_name;
      345 		opt.log_pathname = pathname_ (dir_name, entryname);
      346 	     end;
      347 
      348 	else if opt.log_pathname = AS_PATH
      349 	then do;
      350 		dir_name = ">system_control_dir>as_logs";
      351 		entryname = "log";
      352 		opt.log_pathname = pathname_ (dir_name, entryname);
      353 	     end;
      354 	else if opt.log_pathname = ADMIN_PATH
      355 	then do;
      356 		dir_name = ">system_control_dir>as_logs";
      357 		entryname = "admin_log";
      358 		opt.log_pathname = pathname_ (dir_name, entryname);
      359 	     end;
      360 	else if opt.log_pathname = DM_PATH
      361 	then do;
      362 		call dm_misc_util_$get_log_path (dm_system_log_path);
      363 		call expand_pathname_ (dm_system_log_path, dir_name, entryname, 0);
      364 		opt.procedure = DM_READER_PROCEDURE;
      365 		opt.log_pathname = dm_system_log_path;
      366 	     end;
      367 	else if opt.log_pathname = DSASL_PATH
      368 	then do;
      369 
      370 		/*** Check to see if we will succeed. */
      371 
      372 		call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);
      373 
      374 		if code = error_table_$noentry
      375 		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.");
      376 		else if code = error_table_$moderr
      377 		then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
      378 			DSA_READER_PROCEDURE);
      379 		else if code ^= 0
      380 		then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.", DSA_READER_PROCEDURE);
      381 
      382 		/*** The code was 0, proceed. */
      383 
      384 		else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_log", dsa_system_log_path, code);
      385 
      386 		if code ^= 0
      387 		then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system log.");
      388 
      389 		call expand_pathname_ (dsa_system_log_path, dir_name, entryname, 0);
      390 		opt.procedure = DSA_READER_PROCEDURE;
      391 		opt.log_pathname = dsa_system_log_path;
      392 	     end;
      393 	else if opt.log_pathname = DSASAL_PATH
      394 	then do;
      395 
      396 		/*** Check to see if we will succeed. */
      397 
      398 		call check_gate_access_ (DSA_READER_PROCEDURE, null (), code);
      399 
      400 		if code = error_table_$noentry
      401 		then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "DSA is not installed on this system.");
      402 		else if code = error_table_$moderr
      403 		then call ssu_$abort_line (sci_ptr, code, "You need e access to ^a to read the DSA log.",
      404 			DSA_READER_PROCEDURE);
      405 		else if code ^= 0
      406 		then call ssu_$abort_line (sci_ptr, code, "Trying to check the access to: ^a.", DSA_READER_PROCEDURE);
      407 
      408 		/*** The code was 0, proceed. */
      409 
      410 		else call dsa_nit_$get_field ("mna_general_info", "", "dsa_system_aep_log", dsa_system_log_path, code)
      411 			;
      412 
      413 		if code ^= 0
      414 		then call ssu_$abort_line (sci_ptr, code, "Cannot find the name of the dsa system aep log.");
      415 
      416 		call expand_pathname_ (dsa_system_log_path, dir_name, entryname, 0);
      417 		opt.procedure = DSA_READER_PROCEDURE;
      418 		opt.log_pathname = dsa_system_log_path;
      419 	     end;
      420 
      421 	else do;
      422 		call expand_pathname_ (opt.log_pathname, dir_name, entryname, code);
      423 		if (code ^= 0)
      424 		then call ssu_$abort_line (sci_ptr, code, "Log pathname ^a", opt.log_pathname);
      425 	     end;
      426 
      427 	return;
      428      end make_log_pathname;
      429 
      430 
      431 process_line:
      432      procedure;
      433 
      434 	declare buffer		 char (buffer_length - 1) /* NO NL */ defined (buffer_space) pos (1);
      435 	declare commax		 fixed bin (21);
      436 	declare switch_name		 char (32);
      437 	declare switchx		 fixed bin;
      438 	declare 1 a_switch		 aligned like switches based (asp);
      439 	declare asp		 pointer;
      440 	declare 1 a_select		 aligned like selectors based (aslp);
      441 	declare aslp		 pointer;
      442 	declare match_text		 char (500) varying;
      443 	declare new_commax		 fixed bin (21);
      444 	declare (severity1, severity2) fixed bin;
      445 	declare start_line		 bit (1) aligned;
      446 	declare severity_string	 char (32);
      447 	declare opcode_string	 char (32);
      448 	declare text_required	 bit (1) aligned;
      449 
      450 	line = line + 1;
      451 	if substr (buffer, 1, 1) = "*"
      452 	then return;
      453 
      454 	commax = index (buffer, ",");
      455 	if commax = 0
      456 	then call ssu_$abort_line (sci_ptr, (0), "Error on line ^d: No comma after the switch name ^a.", line, buffer);
      457 	if commax = 1
      458 	then call ssu_$abort_line (sci_ptr, (0), "Error on line ^d:  Null switch name.", line);
      459 
      460 	switch_name = ltrim (substr (buffer, 1, commax - 1));
      461 	do switchx = 1 to n_switches;
      462 	     if switch_name = switches (switchx).switch
      463 	     then do;
      464 		     asp = addr (switches (switchx));
      465 		     go to FOUND_SWITCH;
      466 		end;
      467 	end;
      468 
      469 /* switchx is now 1 past n_switches. */
      470 
      471 	if switchx >= hbound (switches, 1)
      472 	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args,
      473 		"Error on line ^d: Limit of ^d switches exceeded.", line, hbound (switches, 1));
      474 	n_switches = switchx;
      475 
      476 	asp = addr (switches (switchx));
      477 
      478 	a_switch.switch = switch_name;
      479 	a_switch.prev_message_ptr = null ();
      480 	a_switch.opened_here = "0"b;			/* Until proven elsewise */
      481 	call iox_$look_iocb (switch_name, a_switch.iocb_ptr, code);
      482 	if code ^= 0
      483 	then call ssu_$abort_line (sci_ptr, code, "Error on line ^d: Switch ^a not attached.", line, switch_name);
      484 	a_switch.message_count = 0;
      485 	call check_switch_state;
      486 
      487 FOUND_SWITCH:
      488 	if n_selectors = hbound (selectors, 1)
      489 	then call ssu_$abort_line (sci_ptr, error_table_$too_many_args,
      490 		"Error on line ^d: more than ^d selection lines.", line, hbound (selectors, 1));
      491 
      492 	n_selectors = n_selectors + 1;
      493 	aslp = addr (selectors (n_selectors));
      494 
      495 	a_select.switchx = switchx;
      496 	a_select.match_ptr = null ();
      497 	a_select.message_count = 0;
      498 	a_select.expand = "0"b;
      499 
      500 /**** next we look for the severity */
      501 
      502 	new_commax = index (substr (buffer, commax + 1), ",");
      503 	if new_commax = 0
      504 	then call ssu_$abort_line (sci_ptr, (0), "Error on line ^d: No comma after the severity for switch ^a.", line,
      505 		switch_name);
      506 
      507 	severity_string = substr (buffer, commax + 1, new_commax - 1);
      508 	if length (severity_string) = 0
      509 	then call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: null severity.", line);
      510 	commax = commax + new_commax;
      511 
      512 	if severity_string = "*"
      513 	then ;
      514 	else do;					/* something here */
      515 		severity1 = cv_dec_check_ (before (severity_string, ":"), code);
      516 		if (code ^= 0)
      517 		then
      518 INVALID_SEVERITY_RANGE:
      519 		     call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      520 			"Error on line ^d: Invalid severity value ""^a"": must be <N> or <N>:<M> or *", line,
      521 			severity_string);
      522 
      523 		if (index (severity_string, ":") = 0)
      524 		then /* Not a range, just a single number */
      525 		     severity2 = severity1;
      526 		else severity2 = cv_dec_check_ (after (severity_string, ":"), code);
      527 		if (code ^= 0)
      528 		then goto INVALID_SEVERITY_RANGE;
      529 
      530 		call log_match_$add_severity (a_select.match_ptr, severity1, severity2);
      531 
      532 	     end;
      533 
      534 /**** Next, the opcode */
      535 
      536 	new_commax = index (substr (buffer, commax + 1), ",");
      537 
      538 	if new_commax = 0
      539 	then do;
      540 		opcode_string = substr (buffer, commax + 1);
      541 		commax = 0;			/* flag no text */
      542 	     end;
      543 	else do;
      544 		opcode_string = substr (buffer, commax + 1, new_commax - 1);
      545 		commax = commax + new_commax;
      546 	     end;
      547 
      548 	if opcode_string = ""
      549 	then call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: null opcode.", line);
      550 	text_required = "0"b;
      551 	a_select.exclude = "0"b;
      552 	start_line = "0"b;
      553 	if opcode_string = "all"
      554 	then a_select.opcode = ALL;
      555 	else if opcode_string = "any"
      556 	then do;
      557 		a_select.opcode = ANY;
      558 		text_required = "1"b;
      559 	     end;
      560 	else if opcode_string = "begin"
      561 	then do;
      562 		a_select.opcode = BEGIN;
      563 		text_required = "1"b;
      564 		start_line = "1"b;
      565 	     end;
      566 	else if opcode_string = "not"
      567 	then do;
      568 		a_select.opcode = NOT;
      569 		text_required = "1"b;
      570 		a_select.exclude = "1"b;
      571 	     end;
      572 	else if opcode_string = "nbegin"
      573 	then do;
      574 		a_select.opcode = N_BEGIN;
      575 		start_line = "1"b;
      576 		a_select.exclude = "1"b;
      577 		text_required = "1"b;
      578 	     end;
      579 	else if opcode_string = "count"
      580 	then a_select.opcode = COUNT;
      581 	else if opcode_string = "bcount"
      582 	then do;
      583 		a_select.opcode = B_COUNT;
      584 		start_line = "1"b;
      585 		text_required = "1"b;
      586 	     end;
      587 	else if opcode_string = "allx"
      588 	then do;
      589 		a_select.opcode = ALL;
      590 		a_select.expand = "1"b;
      591 	     end;
      592 	else if opcode_string = "anyx"
      593 	then do;
      594 		a_select.opcode = ANY;
      595 		a_select.expand = "1"b;
      596 		text_required = "1"b;
      597 	     end;
      598 	else if opcode_string = "beginx"
      599 	then do;
      600 		a_select.opcode = BEGIN;
      601 		a_select.expand = "1"b;
      602 		text_required = "1"b;
      603 		start_line = "1"b;
      604 	     end;
      605 	else call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: Invalid opcode ^a.", line, opcode_string);
      606 
      607 
      608 	if text_required & commax = 0
      609 	then call ssu_$abort_line (sci_ptr, 0, "Error on line ^d: the opcode ^a requires a selector string.", line,
      610 		opcode_string);
      611 
      612 
      613 	if commax > 1
      614 	then do;					/* add the match string */
      615 		match_text = ltrim (rtrim (substr (buffer, commax + 1)));
      616 		if start_line
      617 		then do;
      618 			match_text = "/^" || match_text;
      619 			match_text = match_text || "/";
      620 		     end;
      621 		call log_match_$add_match (a_select.match_ptr, (match_text));
      622 	     end;
      623 	return;                                           /* return from process_line internal procedure */
      624 
      625 
      626 /**** This procedure is not a "valid" use of iox_. However, there is
      627*      really no better way to find out whether a switch is open.
      628*      Doing I/O and looking at the return code is not reasonable. */
      629 
      630 check_switch_state:
      631      procedure;
      632 
      633 	if a_switch.iocb_ptr -> iocb.attach_data_ptr = null ()
      634 	then call ssu_$abort_line (sci_ptr, error_table_$not_attached, "Error on line ^d: Switch ^a.", line,
      635 		a_switch.switch);
      636 	if a_switch.iocb_ptr -> iocb.open_descrip_ptr = null ()
      637 	then do;
      638 		a_switch.opened_here = "1"b;
      639 		call iox_$open (a_switch.iocb_ptr, Stream_output, "0"b, code);
      640 		if code ^= 0
      641 		then call ssu_$abort_line (sci_ptr, code,
      642 			"Error on line ^d: Failed to open switch ^a for stream_output.", line, a_switch.switch);
      643 	     end;
      644 	return;                                           /* return from check_switch_state internal procedure */
      645 
      646 
  7     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  7     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  7     3*      version number to IOX2. */
  7     4 /* format: style2 */
  7     5 
  7     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  7     7 	     2 version	      character (4) aligned,	/* IOX2 */
  7     8 	     2 name	      char (32),		/* I/O name of this block. */
  7     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  7    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  7    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  7    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  7    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  7    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  7    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  7    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  7    17 						/* open(p,mode,not_used,s) */
  7    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  7    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  7    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  7    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    24 						/* put_chars(p,bufptr,buflen,s) */
  7    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  7    26 						/* modes(p,newmode,oldmode,s) */
  7    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  7    28 						/* position(p,u1,u2,s) */
  7    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  7    30 						/* control(p,order,infptr,s) */
  7    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  7    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  7    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  7    34 						/* write_record(p,bufptr,buflen,s) */
  7    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  7    36 						/* rewrite_record(p,bufptr,buflen,s) */
  7    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  7    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    39 						/* seek_key(p,key,len,s) */
  7    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  7    41 						/* read_key(p,key,len,s) */
  7    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  7    43 						/* read_length(p,len,s) */
  7    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  7    45 						/* open_file(p,mode,desc,not_used,s) */
  7    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  7    47 						/* close_file(p,desc,s) */
  7    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  7    49 						/* detach(p,desc,s) */
  7    50 
  7    51      declare iox_$iocb_version_sentinel
  7    52 			      character (4) aligned external static;
  7    53 
  7    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      647 
      648 
      649 
      650      end check_switch_state;
      651 
      652      end process_line;
      653 
      654 
      655 process_arguments:
      656      procedure;
      657 
      658 	declare argx		 fixed bin;
      659 	declare v_log_ename		 char (32) varying;
      660 	declare number_arg		 char (32) varying;
      661 	declare temp_number		 fixed bin;
      662 	declare (from_time, to_time)	 fixed bin (71);
      663 	declare exchange_opt	 char (50) varying;
      664 	declare code		 fixed bin (35);
      665 
      666 	do argx = 1 to arg_count;
      667 	     call ssu_$arg_ptr (sci_ptr, argx, ap, al);
      668 	     if index (arg, "-") ^= 1
      669 	     then do;
      670 		     if opt.log_pathname ^= ""
      671 		     then call two_logs;
      672 		     opt.log_pathname = arg;
      673 		end;
      674 	     else if (arg = "-syserr")
      675 	     then do;
      676 		     if opt.log_pathname ^= ""
      677 		     then call two_logs;
      678 		     opt.log_pathname = SYSERR_PATH;
      679 		end;
      680 
      681 	     else if (arg = "-answering_service") | (arg = "-as")
      682 	     then do;
      683 		     if opt.log_pathname ^= ""
      684 		     then call two_logs;
      685 		     opt.log_pathname = AS_PATH;
      686 		end;
      687 	     else if (arg = "-admin")
      688 	     then do;
      689 		     if opt.log_pathname ^= ""
      690 		     then call two_logs;
      691 		     opt.log_pathname = ADMIN_PATH;
      692 		end;
      693 	     else if (arg = "-dm_system") | (arg = "-dms")
      694 	     then do;
      695 		     if opt.log_pathname ^= ""
      696 		     then call two_logs;
      697 		     opt.log_pathname = DM_PATH;
      698 		end;
      699 	     else if (arg = "-dsa_sys_log") | (arg = "-dsasl")
      700 	     then do;
      701 		     if opt.log_pathname ^= ""
      702 		     then call two_logs;
      703 		     opt.log_pathname = DSASL_PATH;
      704 		end;
      705 	     else if (arg = "-dsa_sys_aep_log") | (arg = "-dsasal")
      706 	     then do;
      707 		     if opt.log_pathname ^= ""
      708 		     then call two_logs;
      709 		     opt.log_pathname = DSASAL_PATH;
      710 		end;
      711 	     else if (arg = "-mc_log") | (arg = "-mcl")
      712 	     then do;
      713 		     if opt.log_pathname ^= ""
      714 		     then call two_logs;
      715 		     call get_next_arg (v_log_ename);
      716 		     opt.log_pathname = pathname_ (">system_control_dir>as_logs", (v_log_ename));
      717 		end;
      718 
      719 	     else if (arg = "-from") | (arg = "-fm")
      720 	     then call get_next_arg (opt.limit.from_opt);
      721 	     else if (arg = "-last") | (arg = "-lt")
      722 	     then call get_next_arg (opt.limit.last_opt);
      723 	     else if (arg = "-to")
      724 	     then call get_next_arg (opt.limit.to_opt);
      725 	     else if (arg = "-for") | (arg = "-next")
      726 	     then call get_next_arg (opt.limit.for_opt);
      727 
      728 
      729 	     else if (arg = "-control")
      730 	     then do;
      731 		     if argx = arg_count
      732 		     then call ssu_$abort_line (sci_ptr, error_table_$noarg,
      733 			     "-control must be followed by a control file pathname.");
      734 		     argx = argx + 1;
      735 		     call ssu_$arg_ptr (sci_ptr, argx, ap, al);
      736 		     opt.control_file_pathname = arg;
      737 		end;
      738 
      739 	     else if (arg = "-long") | (arg = "-lg")
      740 	     then opt.long_sw = "1"b;
      741 	     else if (arg = "-brief") | (arg = "-bf")
      742 	     then opt.long_sw = "0"b;
      743 	     else if (arg = "-debug") | (arg = "-db")
      744 	     then do;
      745 		     opt.debug_sw = "1"b;
      746 		     call ssu_$set_debug_mode (sci_ptr, "1"b);
      747 		end;
      748 	     else if (arg = "-procedure") | (arg = "-proc")
      749 	     then do;
      750 		     if argx = arg_count
      751 		     then call ssu_$abort_line (sci_ptr, error_table_$noarg,
      752 			     "-procedure must be followed by a log reading procedure.");
      753 		     argx = argx + 1;
      754 		     call ssu_$arg_ptr (sci_ptr, argx, ap, al);
      755 		     opt.procedure = arg;
      756 		end;
      757 
      758 	     else if (arg = "-number_format") | (arg = "-nfmt")
      759 	     then do;
      760 		     call get_next_arg (log_message_format.number_format);
      761 		     call format_log_message_$adjust (log_message_format_ptr, code);
      762 		     if code ^= 0
      763 		     then call ssu_$abort_line (sci_ptr, code, "Processing -number_format",
      764 			     log_message_format.number_format);
      765 		end;
      766 
      767 	     else if (arg = "-indent") | (arg = "-ind") | (arg = "-in")
      768 	     then do;
      769 		     call get_next_arg (number_arg);
      770 		     log_message_format.indentation = cv_dec_check_ ((number_arg), code);
      771 		     if (code ^= 0) | (log_message_format.indentation < 0) | (log_message_format.indentation > 50)
      772 		     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      773 			     "Indentation must be between 0 and 50, not ^a", number_arg);
      774 
      775 		     call format_log_message_$adjust (log_message_format_ptr, code);
      776 		     if code ^= 0
      777 		     then call ssu_$abort_line (sci_ptr, code, "Processing -indent ^a", number_arg);
      778 		end;				/* Of -indent processing */
      779 	     else if (arg = "-continuation_indent") | (arg = "-ci")
      780 	     then do;
      781 		     call get_next_arg (number_arg);
      782 		     if number_arg = "std" | number_arg = "standard"
      783 		     then log_message_format.continuation_indent = -1;
      784 		     else do;
      785 			     log_message_format.continuation_indent = cv_dec_check_ ((number_arg), code);
      786 			     if (code ^= 0) | (log_message_format.continuation_indent < 0)
      787 				| (log_message_format.continuation_indent > 50)
      788 			     then call ssu_$abort_line (sci_ptr, error_table_$bad_conversion,
      789 				     "Continuation indent must be between 0 and 50 or ""standard"", not ^a",
      790 				     number_arg);
      791 			end;
      792 		     call format_log_message_$adjust (log_message_format_ptr, code);
      793 		     if code ^= 0
      794 		     then call ssu_$abort_line (sci_ptr, code,
      795 			     "Failed to adjust log message format after processing -continuation_indent ^a.", arg);
      796 		end;				/* Of -continuation_indent processing */
      797 
      798 
      799 	     else if (arg = "-prefix") | (arg = "-pfx")
      800 	     then do;
      801 		     call get_next_arg (log_message_format.prefix);
      802 		     call format_log_message_$adjust (log_message_format_ptr, code);
      803 		     if code ^= 0
      804 		     then call ssu_$abort_line (sci_ptr, code, "Error processing -prefix ^a",
      805 			     log_message_format.prefix);
      806 		end;				/* Of -prefix processing */
      807 
      808 
      809 	     else if (arg = "-time_format") | (arg = "-tfmt")
      810 	     then do;
      811 		     call get_next_arg (log_message_format.time_format);
      812 		     call format_log_message_$adjust (log_message_format_ptr, code);
      813 		     if code ^= 0
      814 		     then call ssu_$abort_line (sci_ptr, "Processing -time_format ^a", log_message_format.time_format)
      815 			     ;
      816 		end;
      817 
      818 	     else if (arg = "-date_format") | (arg = "-dfmt")
      819 	     then do;
      820 		     call get_next_arg (log_message_format.date_format);
      821 		     call format_log_message_$adjust (log_message_format_ptr, code);
      822 		     if code ^= 0
      823 		     then call ssu_$abort_line (sci_ptr, code, "Processing -date_format ^a",
      824 			     log_message_format.date_format);
      825 		end;
      826 
      827 	     else call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);
      828 	end;
      829 
      830 
      831 /**** Okay, do we have some needful args? */
      832 
      833 	if opt.log_pathname = ""
      834 	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Usage: ^a LOG_PATHNAME -control_args", COMMAND_NAME);
      835 
      836 /* Make sure the -from time is less than the -to time */
      837 
      838 	if opt.limit.from_opt ^= "" & opt.limit.to_opt ^= ""
      839 	then do;
      840 		temp_number = cv_dec_check_ ((opt.limit.from_opt), code);
      841 		if code ^= 0
      842 		then do;
      843 			temp_number = cv_dec_check_ ((opt.limit.to_opt), code);
      844 			if code ^= 0
      845 			then do;
      846 				call convert_date_to_binary_ ((opt.limit.from_opt), from_time, 0);
      847 				call convert_date_to_binary_ ((opt.limit.to_opt), to_time, 0);
      848 				if from_time > to_time
      849 				then do;
      850 					exchange_opt = opt.limit.from_opt;
      851 					opt.limit.from_opt = opt.limit.to_opt;
      852 					opt.limit.to_opt = exchange_opt;
      853 				     end;
      854 			     end;
      855 		     end;
      856 	     end;
      857 
      858 	return;                       /* complete process_arguments procedure */
      859 
      860 
      861 /* the following procedures are internal to the process_arguments procedure */
      862 
      863 /*-------------------- get_next_arg internal procedure -------------------- */
      864 get_next_arg:
      865      procedure (P_option);
      866 
      867 	declare P_option		 char (*) varying parameter;
      868 
      869 
      870 	if (argx >= arg_count)
      871 	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Value missing after ^a", arg);
      872 
      873 	argx = argx + 1;
      874 	call ssu_$arg_ptr (sci_ptr, argx, ap, al);
      875 
      876 	P_option = arg;
      877 
      878 	return;
      879      end get_next_arg;
      880 
      881 /*---------------------- two_logs internal procedure ---------------------- */
      882 two_logs:
      883      procedure;
      884 
      885 	call ssu_$abort_line (sci_ptr, 0, "More than one log was specified on the input line.  ""^a"" was the second log.", arg);
      886 
      887 	return;
      888      end two_logs;
      889 
      890 /* complete all internal procedures which are called by process_arguments */
      891 
      892      end process_arguments;
      893 
      894 
      895 initialize_options:
      896      procedure;
      897 
      898 
      899 	opt.control_iocb, opt.log_read_ptr = null ();
      900 	opt.long_sw = "0"b;
      901 	opt.debug_sw = "0"b;
      902 	opt.log_pathname, opt.control_file_pathname = "";
      903 	opt.control_file_pathname = pathname_ (get_wdir_ (), DEFAULT_CONTROL_FILE);
      904 	opt.limit.version = LOG_LIMIT_INFO_VERSION_1;
      905 	opt.limit.to_opt = "";			/* Set up to call the limit scanner */
      906 	opt.limit.from_opt = "";
      907 	opt.limit.for_opt = "";
      908 	opt.limit.last_opt = "";
      909 	opt.procedure = "";
      910 	call format_log_message_$init (log_message_format_ptr);
      911 	log_message_format.caller = COMMAND_NAME;
      912 	log_message_format.line_lth = 132;
      913 	log_message_format.indentation = 0;
      914 	log_message_format.equal_sw = "0"b;
      915 	log_message_format.error_sw = "1"b;
      916 	log_message_format.prefix = "";
      917 	call format_log_message_$adjust (log_message_format_ptr, code);
      918 	if code ^= 0
      919 	then call ssu_$abort_line (sci_ptr, code, "Failed to adjust initial log message format.");
      920 
      921 	return;
      922      end initialize_options;
      923 
      924 
      925 read_control_file:
      926      procedure;
      927 	declare control_iocb_name	 char (32);
      928 
      929 	call absolute_pathname_$add_suffix ((opt.control_file_pathname), CONTROL_SUFFIX, opt.control_file_pathname,
      930 	     code);
      931 	if code ^= 0
      932 	then call ssu_$abort_line (sci_ptr, code, "^a", opt.control_file_pathname);
      933 
      934 	control_iocb_name = "summarize_sys_log" || unique_chars_ (""b);
      935 	call iox_$attach_name (control_iocb_name, opt.control_iocb, "vfile_ " || opt.control_file_pathname, null (),
      936 	     code);
      937 	if code ^= 0
      938 	then call ssu_$abort_line (sci_ptr, code, "Failed to attach ^a", opt.control_file_pathname);
      939 	call iox_$open (opt.control_iocb, Stream_input, "0"b, code);
      940 	if code ^= 0
      941 	then call ssu_$abort_line (sci_ptr, code, "Failed to open ^a", opt.control_file_pathname);
      942 
      943 	n_switches, n_selectors = 0;
      944 
      945 	code = 0;
      946 	line = 0;
      947 	do while (code ^= error_table_$end_of_info);
      948 	     call iox_$get_line (opt.control_iocb, addr (buffer_space), length (buffer_space), buffer_length, code);
      949 	     if code = 0
      950 	     then call process_line;
      951 	     else if code ^= error_table_$end_of_info
      952 	     then do;
      953 		     line = line + 1;		/* we skipped a line */
      954 		     call ssu_$print_message (sci_ptr, code, "Error reading line ^d.", line);
      955 		end;
      956 	end;
      957 
      958 	call iox_$close (opt.control_iocb, (0));
      959 	call iox_$detach_iocb (opt.control_iocb, (0));
      960 	call iox_$destroy_iocb (opt.control_iocb, (0));
      961 	opt.control_iocb = null ();
      962 
      963 	call ioa_ ("^a: ^d streams, ^d selectors", COMMAND_NAME, n_switches, n_selectors);
      964 
      965 	if n_selectors = 0 | n_switches = 0
      966 	then call ssu_$abort_line (sci_ptr, error_table_$noarg,
      967 		"There must be at least one switch and at least one selctor.");
      968 	return;
      969      end read_control_file;
      970 
      971 
      972 print_limits:
      973      procedure (iocb, identify);
      974 
      975 	declare iocb		 pointer;
      976 	declare identify		 bit (1) aligned;
      977 
      978 	if (opt.first_msg = null ())
      979 	then call ioa_$ioa_switch (iocb, "^[^a ^;^s^]Log ^a to ^a", identify, COMMAND_NAME, opt.log_pathname,
      980 		log_format_time_ ((opt.last_msg -> log_message.time)));
      981 
      982 	else if (opt.last_msg = null ())
      983 	then call ioa_$ioa_switch (iocb, "^[^a: ^;^s^]Log ^a from ^a", identify, COMMAND_NAME, opt.log_pathname,
      984 		log_format_time_ ((opt.first_msg -> log_message.time)));
      985 	else call ioa_$ioa_switch (iocb, "^[^a: ^;^s^]Log ^a from ^a to ^a", identify, COMMAND_NAME, opt.log_pathname,
      986 		log_format_time_ ((opt.first_msg -> log_message.time)),
      987 		log_format_time_ ((opt.last_msg -> log_message.time)));
      988 
      989 	return;
      990      end print_limits;
      991 
      992 
      993 find_first_message:
      994      procedure ();
      995 
      996 	declare total_count		 fixed bin;
      997 	declare hold_message_sw	 bit (1);
      998 
      999 	total_count = 0;
     1000 
     1001 /* This procedure locates the message we're going to start with, in case we're
     1002*   doing something like "-last 10", where log_limit_scan_ can't determine the
     1003*   real starting point because it might depend (if we had -match) on message
     1004*   content. */
     1005 
     1006 	hold_message_sw = "0"b;
     1007 	if (opt.first_msg ^= null ())
     1008 	then /* We know where we're starting */
     1009 	     go to FOUND;
     1010 
     1011 /* Otherwise, we look backwards to find where to start.  We are guaranteed,
     1012*   by log_limit_scan_, that at least one limit is non-null, and also that if
     1013*   one is null, there is a limit count. If, however, we run out of messages
     1014*   before we hit the limit, that's still OK, and we print all that we have. */
     1015 
     1016 	log_message_ptr = opt.last_msg;
     1017 
     1018 	do total_count = 1 by 1 while (total_count < opt.msg_count);
     1019 
     1020 	     call log_read_$prev_message (opt.log_read_ptr, log_message_ptr, code);
     1021 	     if (code ^= 0)
     1022 	     then do;
     1023 		     if code = error_table_$no_log_message
     1024 		     then log_message_ptr = null ();
     1025 		     else call ssu_$abort_line (sci_ptr, code,
     1026 			     "Internal error: Failed to find message before message ^p.", log_message_ptr);
     1027 		end;
     1028 	     if (log_message_ptr = null ())
     1029 	     then /* If we've run out, terminate the loop */
     1030 		total_count = opt.msg_count;
     1031 	end;
     1032 
     1033 	if (log_message_ptr = null ())
     1034 	then
     1035 NO_MESSAGES:
     1036 	     call ssu_$abort_line (sci_ptr, 0, "No messages matched criteria. ^d message^[s^] read.", total_count,
     1037 		(total_count ^= 1));
     1038 
     1039 	opt.first_msg = log_message_ptr;
     1040 	hold_message_sw = "1"b;
     1041 
     1042 FOUND:
     1043 	if hold_message_sw
     1044 	then call log_read_$hold_message (opt.log_read_ptr, opt.first_msg);
     1045 	return;
     1046      end find_first_message;
     1047 
     1048 
     1049 process_messages:
     1050      procedure;
     1051 
     1052 /* Following code is the processing loop on log entries.
     1053*   Each line is checked against all selectors to see if it should be written. */
     1054 	declare total_messages	 fixed bin (35);
     1055 	declare slx		 fixed bin;
     1056 	declare s_iocb		 pointer;
     1057 
     1058 	total_messages = 0;
     1059 
     1060 	do slx = 1 to n_switches;
     1061 	     call print_limits (switches (slx).iocb_ptr, "0"b);
     1062 	     call ioa_$ioa_switch (switches (slx).iocb_ptr, "");
     1063 	end;
     1064 
     1065 	if opt.long_sw
     1066 	then call ioa_ ("^/SUMMARY OF SELECTORS:^/");
     1067 	do slx = 1 to n_selectors;
     1068 	     if opt.long_sw
     1069 	     then do;
     1070 		     call ioa_ ("^3d ^a ^[all^;any^;begin^;not^;nbegin^;count^;bcount^]^[x^]", slx,
     1071 			switches (selectors (slx).switchx).switch, selectors (slx).opcode, selectors (slx).expand);
     1072 		     if selectors (slx).match_ptr ^= null ()
     1073 		     then call log_match_$print (selectors (slx).match_ptr, iox_$user_output, 5);
     1074 		end;
     1075 
     1076 	     s_iocb = switches (selectors (slx).switchx).iocb_ptr;
     1077 	     call ioa_$ioa_switch (s_iocb, "^/^3d  ^a ^[all^;any^;begin^;not^;nbegin^;count^;bcount^]^[x^]", slx,
     1078 		switches (selectors (slx).switchx).switch, selectors (slx).opcode, selectors (slx).expand);
     1079 	     if selectors (slx).match_ptr ^= null ()
     1080 	     then call log_match_$print (selectors (slx).match_ptr, s_iocb, 5);
     1081 	     else call ioa_$ioa_switch (s_iocb, "^5xAll severities.");
     1082 	     call ioa_$ioa_switch (s_iocb, "");
     1083 	end;
     1084 
     1085 
     1086 	log_message_ptr = opt.first_msg;
     1087 	do while (log_message_ptr ^= null ());   /* Catch running out of messages */
     1088                                                    /* determine whether the current message matches selection criteria. */
     1089                                                    /* If it matches then print it out. */
     1090 	     call process_log_message;
     1091 
     1092                                                    /* Determine whether the specified last message (-to TIME, -to NUMBER) has been reached. */
     1093 	     if log_message_ptr = opt.last_msg
     1094 	     then log_message_ptr = null;        /* indicates that all requested messages are completely processed. */
     1095 	     else do;                            /* The -to control argument is not specified. */
     1096                                                    /* so continue to process all remaining messages in the log ( by default) */
     1097 		     call log_read_$next_message (opt.log_read_ptr, log_message_ptr, code);
     1098 		     if code ^= 0
     1099 		     then do;
     1100                                                    /* terminate the do while loop */
     1101 			     log_message_ptr = null ();
     1102 
     1103 		               if code ^= error_table_$no_log_message
     1104 		               then call ssu_$print_message (sci_ptr, code, "Reading next message.");
     1105 		          end;
     1106 	         end;
     1107 	end;                                    /* process all mesages in the log */
     1108 
     1109 
     1110 	/*** Skip lines on all switches */
     1111 
     1112 	do slx = 1 to n_switches;
     1113 	     call ioa_$ioa_switch (switches (slx).iocb_ptr, "");
     1114 	end;
     1115 
     1116 /**** Write summary lines for selectors */
     1117 
     1118 	do slx = 1 to n_selectors;
     1119 	     if selectors (slx).opcode = COUNT | selectors (slx).opcode = B_COUNT
     1120 	     then do;
     1121 		     call ioa_$ioa_switch (switches (selectors (slx).switchx).iocb_ptr, "^d messages:",
     1122 			selectors (slx).message_count);
     1123 		     call log_match_$print (selectors (slx).match_ptr, switches (selectors (slx).switchx).iocb_ptr,
     1124 			5 /* indent */);
     1125 		end;
     1126 	end;
     1127 
     1128 /**** Write  summary for stream */
     1129 
     1130 	do slx = 1 to n_switches;
     1131 	     call ioa_$ioa_switch (switches (slx).iocb_ptr, "^/TOTAL: ^d written.", switches (slx).message_count);
     1132 	end;
     1133 
     1134 	call ioa_ ("summarize_sys_log: ^d messages read.", total_messages);
     1135 	return;                                           /* return from process_messages internal procedure */
     1136 
     1137 
     1138 process_log_message:
     1139      procedure;
     1140 	declare text_buffer		 char (5000) varying;
     1141 	declare expand_buffer	 char (5000) varying;
     1142 	declare slx		 fixed bin;
     1143 	declare test_sw		 bit (1) aligned;
     1144 	declare switches_inhibited	 (1000) bit (1) unaligned;
     1145 
     1146 	total_messages = total_messages + 1;
     1147 	unspec (switches_inhibited) = "0"b;		/* no NOTs yet */
     1148 	do slx = 1 to n_selectors;
     1149 	     if switches_inhibited (selectors (slx).switchx)
     1150 	     then call SKIP_SELECT;
     1151 	     if selectors (slx).match_ptr ^= null ()
     1152 	     then do;
     1153 		     test_sw = log_match_$test (selectors (slx).match_ptr, log_message_ptr, "");
     1154 		     if selectors (slx).exclude
     1155 		     then do;
     1156 			     if test_sw
     1157 			     then switches_inhibited (selectors (slx).switchx) = "1"b;
     1158 			     call SKIP_SELECT;
     1159 			end;
     1160 		     else if ^test_sw
     1161 		     then call SKIP_SELECT;
     1162 		end;
     1163 
     1164 	     selectors (slx).message_count = selectors (slx).message_count + 1;
     1165 	     expand_buffer = "";
     1166 	     if selectors (slx).expand
     1167 	     then call expand_log_message_ (log_message_format_ptr, log_message_ptr, null (), expand_buffer, code);
     1168 
     1169 	     call format_log_message_$format (log_message_format_ptr, log_message_ptr,
     1170 		switches (selectors (slx).switchx).prev_message_ptr, expand_buffer, text_buffer, (0));
     1171 
     1172 	     call iox_$put_chars (switches (selectors (slx).switchx).iocb_ptr, addwordno (addr (text_buffer), 1),
     1173 		length (text_buffer), (0));
     1174 
     1175 	     if switches (selectors (slx).switchx).prev_message_ptr ^= null ()
     1176 	     then call log_read_$free_message (opt.log_read_ptr, switches (selectors (slx).switchx).prev_message_ptr);
     1177 	     call log_read_$hold_message (opt.log_read_ptr, log_message_ptr);
     1178 	     switches (selectors (slx).switchx).prev_message_ptr = log_message_ptr;
     1179 	     switches (selectors (slx).switchx).message_count = switches (selectors (slx).switchx).message_count + 1;
     1180 
     1181 SKIP_SELECTOR:
     1182 	end;
     1183 
     1184 
     1185 SKIP_SELECT:
     1186      procedure;
     1187 	go to SKIP_SELECTOR;
     1188      end SKIP_SELECT;
     1189 
     1190 
     1191      end process_log_message;
     1192 
     1193      end process_messages;
     1194 
     1195 
     1196 SSU_ABORT:
     1197      procedure;
     1198 	call clean_up;
     1199 	go to ABORT;
     1200      end SSU_ABORT;
     1201 ABORT:
     1202 	return;
     1203 
     1204      end summarize_sys_log;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/01/89  1356.7  summarize_sys_log.pl1             >spec>install>1018>summarize_sys_log.pl1
139          1    05/23/83  0916.6  iox_entries.incl.pl1              >ldd>include>iox_dcls.incl.pl1
140          2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
162          3    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
163          4    01/21/85  0912.2  log_message_format.incl.pl1       >ldd>include>log_message_format.incl.pl1
164          5    01/21/85  0912.2  log_limit_info.incl.pl1           >ldd>include>log_limit_info.incl.pl1
165          6    01/21/85  0912.3  log_read_open_info.incl.pl1       >ldd>include>log_read_open_info.incl.pl1
647          7    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADMIN_PATH                      000070 constant        char(32)                 initial packed unaligned dcl 179 ref 354 691
ALL                                    constant        fixed bin(17,0)          initial dcl 214 ref 553 589
ANY                                    constant        fixed bin(17,0)          initial dcl 214 ref 557 594
AS_PATH                         000100 constant        char(32)                 initial packed unaligned dcl 179 ref 348 685
BEGIN                                  constant        fixed bin(17,0)          initial dcl 214 ref 562 600
B_COUNT                                constant        fixed bin(17,0)          initial dcl 214 ref 583 1119
COMMAND_NAME                    000124 constant        char(32)                 initial packed unaligned dcl 79 set ref 256* 259*
                                                                                  264* 833* 911 963* 978* 982* 985*
CONTROL_SUFFIX                  000020 constant        char(32)                 initial packed unaligned dcl 224 set ref 929*
COUNT                                  constant        fixed bin(17,0)          initial dcl 214 ref 579 1119
DEFAULT_CONTROL_FILE            000030 constant        char(32)                 initial packed unaligned dcl 223 set ref 903*
DM_PATH                         000060 constant        char(32)                 initial packed unaligned dcl 179 ref 360 697
DM_READER_PROCEDURE             000010 constant        char(32)                 initial packed unaligned dcl 243 ref 364
DSASAL_PATH                     000040 constant        char(32)                 initial packed unaligned dcl 179 ref 393 709
DSASL_PATH                      000050 constant        char(32)                 initial packed unaligned dcl 179 ref 367 703
DSA_READER_PROCEDURE            000000 constant        char(32)                 initial packed unaligned dcl 244 set ref 372* 376*
                                                                                  379* 390 398* 402* 405* 417
LOG_LIMIT_INFO_VERSION_1        000122 constant        char(8)                  initial packed unaligned dcl 5-17 ref 904
LOG_READ_OPEN_INFO_VERSION_1    000120 constant        char(8)                  initial packed unaligned dcl 6-13 ref 278
NOT                                    constant        fixed bin(17,0)          initial dcl 214 ref 568
N_BEGIN                                constant        fixed bin(17,0)          initial dcl 214 ref 574
P_option                               parameter       varying char             dcl 867 set ref 864 876*
SYSERR_PATH                     000110 constant        char(32)                 initial packed unaligned dcl 179 ref 341 678
Stream_input                    000256 constant        fixed bin(17,0)          initial dcl 2-15 set ref 939*
Stream_output                   000210 constant        fixed bin(17,0)          initial dcl 2-15 set ref 639*
a_select                               based           structure                level 1 dcl 440
a_switch                               based           structure                level 1 dcl 438
absolute_pathname_$add_suffix   000010 constant        entry                    external dcl 91 ref 929
addr                                                   builtin function         dcl 135 ref 282 282 290 290 464 476 493 948 948 1172
                                                                                  1172
addwordno                                              builtin function         dcl 135 ref 1172 1172
after                                                  builtin function         dcl 135 ref 526 526
al                              000106 automatic       fixed bin(21,0)          dcl 84 set ref 667* 668 672 674 681 681 687 693 693
                                                                                  699 699 705 705 711 711 719 719 721 721 723 725
                                                                                  725 729 735* 736 739 739 741 741 743 743 748 748
                                                                                  754* 755 758 758 767 767 767 779 779 793 793 799
                                                                                  799 809 809 818 818 827 827 870 870 874* 876 885
                                                                                  885
allocate_copies          16     000246 automatic       bit(1)                   level 2 dcl 166 set ref 281*
allocation_area_ptr      14     000246 automatic       pointer                  level 2 dcl 166 set ref 280*
ap                              000104 automatic       pointer                  dcl 83 set ref 667* 668 672 674 681 681 687 693 693
                                                                                  699 699 705 705 711 711 719 719 721 721 723 725
                                                                                  725 729 735* 736 739 739 741 741 743 743 748 748
                                                                                  754* 755 758 758 767 767 767 779 779 793 799 799
                                                                                  809 809 818 818 827 870 874* 876 885
arg                                    based           char                     packed unaligned dcl 85 set ref 668 672 674 681 681
                                                                                  687 693 693 699 699 705 705 711 711 719 719 721
                                                                                  721 723 725 725 729 736 739 739 741 741 743 743
                                                                                  748 748 755 758 758 767 767 767 779 779 793* 799
                                                                                  799 809 809 818 818 827* 870* 876 885*
arg_count                       000102 automatic       fixed bin(17,0)          dcl 82 set ref 263* 264 666 731 750 870
argx                            060404 automatic       fixed bin(17,0)          dcl 658 set ref 666* 667* 731 734* 734 735* 750 753*
                                                                                  753 754* 870 873* 873 874*
aslp                            060140 automatic       pointer                  dcl 441 set ref 493* 495 496 497 498 530 551 553 557
                                                                                  562 568 570 574 576 579 583 589 590 594 595 600
                                                                                  601 621
asp                             060136 automatic       pointer                  dcl 439 set ref 464* 476* 478 479 480 481 484 633
                                                                                  633 636 638 639 640
attach_data_ptr          16            based           pointer                  level 2 dcl 7-6 ref 633
before                                                 builtin function         dcl 135 ref 515 515
buffer                                 defined         char                     packed unaligned dcl 434 set ref 451 454 455* 460
                                                                                  502 507 536 540 544 615
buffer_length                   060107 automatic       fixed bin(21,0)          dcl 212 set ref 434 948*
buffer_space                    057515 automatic       char(1000)               packed unaligned dcl 211 set ref 451 451 454 454 455
                                                                                  455 460 460 502 502 507 507 536 536 540 540 544
                                                                                  544 615 615 948 948 948 948
caller                                 based           char(32)                 level 2 packed packed unaligned dcl 4-3 set ref 911*
check_gate_access_              000012 constant        entry                    external dcl 93 ref 372 398
cleanup                         000234 stack reference condition                dcl 160 ref 254
code                            060452 automatic       fixed bin(35,0)          dcl 664 in procedure "process_arguments" set ref
                                                                                  761* 762 762* 770* 771 775* 776 776* 785* 786 792*
                                                                                  793 793* 802* 803 803* 812* 813 821* 822 822* 840*
                                                                                  841 843* 844
code                            000233 automatic       fixed bin(35,0)          dcl 89 in procedure "summarize_sys_log" set ref 256*
                                                                                  257 259* 282* 284* 285 285* 372* 374 376 376* 379
                                                                                  379* 384* 386 386* 398* 400 402 402* 405 405* 410*
                                                                                  413 413* 422* 423 423* 481* 482 482* 515* 516 526*
                                                                                  527 639* 640 640* 917* 918 918* 929* 931 931* 935*
                                                                                  937 937* 939* 940 940* 945* 947 948* 949 951 954*
                                                                                  1020* 1021 1023 1025* 1097* 1098 1103 1103* 1166*
com_err_                        000020 constant        entry                    external dcl 97 ref 259
commax                          060124 automatic       fixed bin(21,0)          dcl 435 set ref 454* 455 457 460 502 507 510* 510
                                                                                  536 540 541* 544 545* 545 608 613 615
continuation_indent      63            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 782* 785* 786 786
control_file_pathname
                         54     000266 automatic       char(168)                level 2 packed packed unaligned dcl 168 set ref 736*
                                                                                  902* 903* 929 929* 931* 935 937* 940*
control_iocb            236     000266 automatic       pointer                  level 2 dcl 168 set ref 251* 309 311* 312* 313* 899*
                                                                                  935* 939* 948* 958* 959* 960* 961*
control_iocb_name               060504 automatic       char(32)                 packed unaligned dcl 927 set ref 934* 935*
convert_date_to_binary_         000014 constant        entry                    external dcl 94 ref 846 847
cu_$arg_list_ptr                000016 constant        entry                    external dcl 96 ref 256 256
cv_dec_check_                   000022 constant        entry                    external dcl 98 ref 515 526 770 785 840 843
date_format              50            based           varying char(40)         level 2 dcl 4-3 set ref 820* 822*
debug_sw                241     000266 automatic       bit(1)                   level 2 dcl 168 set ref 745* 901*
dir_name                        057433 automatic       char(168)                packed unaligned dcl 209 set ref 282* 284* 343* 345*
                                                                                  350* 352* 356* 358* 363* 389* 416* 422*
dm_misc_util_$get_log_path      000024 constant        entry                    external dcl 99 ref 362
dm_system_log_path              000107 automatic       char(168)                packed unaligned dcl 87 set ref 362* 363* 365
dsa_nit_$get_field              000026 constant        entry                    external dcl 101 ref 384 410
dsa_system_log_path             000161 automatic       char(168)                packed unaligned dcl 88 set ref 384* 389* 391 410*
                                                                                  416* 418
entryname                       057505 automatic       char(32)                 packed unaligned dcl 210 set ref 282* 284* 344* 345*
                                                                                  351* 352* 357* 358* 363* 389* 416* 422*
equal_sw                 12            based           bit(1)                   level 2 dcl 4-3 set ref 914*
error_sw                 13            based           bit(1)                   level 2 dcl 4-3 set ref 915*
error_table_$bad_arg            000166 external static fixed bin(35,0)          dcl 232 set ref 374* 400*
error_table_$bad_conversion     000202 external static fixed bin(35,0)          dcl 239 set ref 516* 771* 786*
error_table_$badopt             000170 external static fixed bin(35,0)          dcl 233 set ref 827*
error_table_$end_of_info        000162 external static fixed bin(35,0)          dcl 228 ref 947 951
error_table_$moderr             000172 external static fixed bin(35,0)          dcl 234 ref 376 402
error_table_$no_log_message     000164 external static fixed bin(35,0)          dcl 230 ref 1023 1103
error_table_$noarg              000174 external static fixed bin(35,0)          dcl 235 set ref 731* 750* 833* 870* 965*
error_table_$noentry            000176 external static fixed bin(35,0)          dcl 236 ref 374 400
error_table_$not_attached       000160 external static fixed bin(35,0)          dcl 226 set ref 633*
error_table_$too_many_args      000200 external static fixed bin(35,0)          dcl 237 set ref 471* 487*
exchange_opt                    060434 automatic       varying char(50)         dcl 663 set ref 850* 852
exclude                   5     037730 automatic       bit(1)                   array level 2 in structure "selectors" dcl 196
                                                                                  in procedure "summarize_sys_log" set ref 1154
exclude                   5            based           bit(1)                   level 2 in structure "a_select" dcl 440 in procedure
                                                                                  "process_line" set ref 551* 570* 576*
expand                    6     037730 automatic       bit(1)                   array level 2 in structure "selectors" dcl 196
                                                                                  in procedure "summarize_sys_log" set ref 1070*
                                                                                  1077* 1166
expand                    6            based           bit(1)                   level 2 in structure "a_select" dcl 440 in procedure
                                                                                  "process_line" set ref 498* 590* 595* 601*
expand_buffer                   063123 automatic       varying char(5000)       dcl 1141 set ref 1165* 1166* 1169*
expand_log_message_             000060 constant        entry                    external dcl 120 ref 1166
expand_pathname_                000030 constant        entry                    external dcl 102 ref 363 389 416 422
first_msg               220     000266 automatic       pointer                  level 3 dcl 168 set ref 978 982 985 1007 1039* 1042*
                                                                                  1086
for_opt                 164     000266 automatic       varying char(50)         level 3 dcl 168 set ref 725* 907*
format_log_message_$adjust      000052 constant        entry                    external dcl 112 ref 761 775 792 802 812 821 917
format_log_message_$format      000056 constant        entry                    external dcl 116 ref 1169
format_log_message_$free        000054 constant        entry                    external dcl 114 ref 318
format_log_message_$init        000050 constant        entry                    external dcl 110 ref 910
from_opt                146     000266 automatic       varying char(50)         level 3 dcl 168 set ref 719* 838 840 846 850 851*
                                                                                  906*
from_time                       060430 automatic       fixed bin(71,0)          dcl 662 set ref 846* 848
get_wdir_                       000104 constant        entry                    external dcl 133 ref 903 903
hbound                                                 builtin function         dcl 135 ref 471 471 471 487 487 487
header                                 based           structure                level 2 dcl 3-13
hold_message_sw                 060531 automatic       bit(1)                   packed unaligned dcl 997 set ref 1006* 1040* 1042
identify                               parameter       bit(1)                   dcl 976 set ref 972 978* 982* 985*
indentation              11            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 770* 771 771 913*
index                                                  builtin function         dcl 135 ref 454 502 523 536 668
ioa_                            000100 constant        entry                    external dcl 131 ref 963 1065 1070 1134
ioa_$ioa_switch                 000102 constant        entry                    external dcl 132 ref 978 982 985 1062 1077 1081 1082
                                                                                  1113 1121 1131
iocb                                   based           structure                level 1 dcl 7-6 in procedure "check_switch_state"
iocb                                   parameter       pointer                  dcl 975 in procedure "print_limits" set ref 972 978*
                                                                                  982* 985*
iocb_ptr                 12            based           pointer                  level 2 in structure "a_switch" dcl 438 in procedure
                                                                                  "process_line" set ref 481* 633 636 639*
iocb_ptr                 12     000530 automatic       pointer                  array level 2 in structure "switches" dcl 188
                                                                                  in procedure "summarize_sys_log" set ref 325*
                                                                                  1061* 1062* 1076 1113* 1121* 1123* 1131* 1172*
iox_$attach_name                000106 constant        entry                    external dcl 1-8 ref 935
iox_$close                      000110 constant        entry                    external dcl 1-8 ref 311 325 958
iox_$destroy_iocb               000112 constant        entry                    external dcl 1-8 ref 313 960
iox_$detach_iocb                000114 constant        entry                    external dcl 1-8 ref 312 959
iox_$get_line                   000116 constant        entry                    external dcl 1-8 ref 948
iox_$look_iocb                  000120 constant        entry                    external dcl 1-8 ref 481
iox_$open                       000122 constant        entry                    external dcl 1-8 ref 639 939
iox_$put_chars                  000124 constant        entry                    external dcl 1-8 ref 1172
iox_$user_output                000126 external static pointer                  dcl 1-41 set ref 295* 1072*
last_msg                222     000266 automatic       pointer                  level 3 dcl 168 set ref 978 982 985 1016 1093
last_opt                202     000266 automatic       varying char(50)         level 3 dcl 168 set ref 721* 908*
length                                                 builtin function         dcl 135 ref 508 948 948 1172 1172
limit                   126     000266 automatic       structure                level 2 dcl 168 set ref 290 290
line                            057432 automatic       fixed bin(17,0)          dcl 208 set ref 450* 450 455* 457* 471* 482* 487*
                                                                                  503* 508* 516* 548* 605* 608* 633* 640* 946* 953*
                                                                                  953 954*
line_lth                 10            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 912*
log_data_$syserr_log_dir        000154 external static char(168)                packed unaligned dcl 155 ref 343
log_data_$syserr_log_name       000156 external static char(32)                 packed unaligned dcl 157 ref 344
log_format_time_                000062 constant        entry                    external dcl 121 ref 978 982 985 985
log_limit_info                         based           structure                level 1 dcl 5-6
log_limit_scan_                 000064 constant        entry                    external dcl 122 ref 290
log_match_$add_match            000066 constant        entry                    external dcl 124 ref 621
log_match_$add_severity         000070 constant        entry                    external dcl 125 ref 530
log_match_$free                 000074 constant        entry                    external dcl 128 ref 321
log_match_$print                000076 constant        entry                    external dcl 129 ref 1072 1079 1123
log_match_$test                 000072 constant        entry                    external dcl 127 ref 1153
log_message                            based           structure                level 1 dcl 3-13
log_message_format                     based           structure                level 1 dcl 4-3
log_message_format_ptr          000244 automatic       pointer                  dcl 4-30 set ref 249* 318 318* 760 761* 762 770 771
                                                                                  771 775* 782 785 786 786 792* 801 802* 803 811
                                                                                  812* 813 820 821* 822 910* 911 912 913 914 915 916
                                                                                  917* 1166* 1169*
log_message_header                     based           structure                level 1 dcl 3-3
log_message_ptr                 000242 automatic       pointer                  dcl 3-19 set ref 1016* 1020* 1023* 1025* 1028 1033
                                                                                  1039 1086* 1087 1093 1093* 1097* 1101* 1153* 1166*
                                                                                  1169* 1177* 1178
log_open_info                   000246 automatic       structure                level 1 dcl 166 set ref 282 282
log_pathname              2     000266 automatic       char(168)                level 2 packed packed unaligned dcl 168 set ref 285*
                                                                                  341 345* 348 352* 354 358* 360 365* 367 391* 393
                                                                                  418* 422* 423* 670 672* 676 678* 683 685* 689 691*
                                                                                  695 697* 701 703* 707 709* 713 716* 833 902* 978*
                                                                                  982* 985*
log_read_$close                 000042 constant        entry                    external dcl 107 ref 316
log_read_$free_message          000036 constant        entry                    external dcl 105 ref 1175
log_read_$hold_message          000040 constant        entry                    external dcl 106 ref 1042 1177
log_read_$next_message          000044 constant        entry                    external dcl 108 ref 1097
log_read_$open                  000032 constant        entry                    external dcl 103 ref 284
log_read_$open_long             000034 constant        entry                    external dcl 104 ref 282
log_read_$prev_message          000046 constant        entry                    external dcl 109 ref 1020
log_read_open_info                     based           structure                level 1 dcl 6-5
log_read_ptr                    000266 automatic       pointer                  level 2 dcl 168 set ref 250* 282* 284* 290* 316 316*
                                                                                  899* 1020* 1042* 1097* 1175* 1177*
long_sw                 240     000266 automatic       bit(1)                   level 2 dcl 168 set ref 739* 741* 900* 1065 1068
ltrim                                                  builtin function         dcl 135 ref 460 615
match_ptr                 2            based           pointer                  level 2 in structure "a_select" dcl 440 in procedure
                                                                                  "process_line" set ref 496* 530* 621*
match_ptr                 2     037730 automatic       pointer                  array level 2 in structure "selectors" dcl 196
                                                                                  in procedure "summarize_sys_log" set ref 321 321*
                                                                                  1072 1072* 1079 1079* 1123* 1151 1153*
match_text                      060142 automatic       varying char(500)        dcl 442 set ref 615* 618* 618 619* 619 621
message_count            15     000530 automatic       fixed bin(17,0)          array level 2 in structure "switches" dcl 188
                                                                                  in procedure "summarize_sys_log" set ref 1131*
                                                                                  1179* 1179
message_count            15            based           fixed bin(17,0)          level 2 in structure "a_switch" dcl 438 in procedure
                                                                                  "process_line" set ref 484*
message_count             4     037730 automatic       fixed bin(17,0)          array level 2 in structure "selectors" dcl 196
                                                                                  in procedure "summarize_sys_log" set ref 1121*
                                                                                  1164* 1164
message_count             4            based           fixed bin(17,0)          level 2 in structure "a_select" dcl 440 in procedure
                                                                                  "process_line" set ref 497*
msg_count               224     000266 automatic       fixed bin(35,0)          level 3 dcl 168 set ref 1018 1028
n_selectors                     057431 automatic       fixed bin(17,0)          dcl 205 set ref 252* 320 487 492* 492 493 943* 963*
                                                                                  965 1067 1118 1148
n_switches                      057430 automatic       fixed bin(17,0)          dcl 205 set ref 252* 324 461 474* 943* 963* 965 1060
                                                                                  1112 1130
new_commax                      060340 automatic       fixed bin(21,0)          dcl 443 set ref 502* 503 507 510 536* 538 544 545
null                                                   builtin function         dcl 135 ref 248 249 250 251 280 280 309 316 318 321
                                                                                  329 372 372 398 398 479 496 633 636 899 935 935
                                                                                  961 978 982 1007 1023 1028 1033 1072 1079 1087
                                                                                  1093 1101 1151 1166 1166 1175
number_arg                      060416 automatic       varying char(32)         dcl 660 set ref 769* 770 771* 776* 781* 782 782 785
                                                                                  786*
number_format            27            based           varying char(20)         level 2 dcl 4-3 set ref 760* 762*
opcode                    1     037730 automatic       fixed bin(17,0)          array level 2 in structure "selectors" dcl 196
                                                                                  in procedure "summarize_sys_log" set ref 1070*
                                                                                  1077* 1119 1119
opcode                    1            based           fixed bin(17,0)          level 2 in structure "a_select" dcl 440 in procedure
                                                                                  "process_line" set ref 553* 557* 562* 568* 574*
                                                                                  579* 583* 589* 594* 600*
opcode_string                   060354 automatic       char(32)                 packed unaligned dcl 447 set ref 540* 544* 548 553
                                                                                  555 560 566 572 579 581 587 592 598 605* 608*
open_descrip_ptr         20            based           pointer                  level 2 dcl 7-6 ref 636
opened_here              14     000530 automatic       bit(1)                   array level 2 in structure "switches" dcl 188
                                                                                  in procedure "summarize_sys_log" set ref 325
opened_here              14            based           bit(1)                   level 2 in structure "a_switch" dcl 438 in procedure
                                                                                  "process_line" set ref 480* 638*
opt                             000266 automatic       structure                level 1 dcl 168
pathname_                       000130 constant        entry                    external dcl 141 ref 345 352 358 716 903
prefix                   14            based           varying char(40)         level 2 dcl 4-3 set ref 801* 803* 916*
prev_message_ptr         10     000530 automatic       pointer                  array level 2 in structure "switches" dcl 188
                                                                                  in procedure "summarize_sys_log" set ref 1169*
                                                                                  1175 1175* 1178*
prev_message_ptr         10            based           pointer                  level 2 in structure "a_switch" dcl 438 in procedure
                                                                                  "process_line" set ref 479*
procedure               225     000266 automatic       char(32)                 level 2 packed packed unaligned dcl 168 set ref 276
                                                                                  279 364* 390* 417* 755* 909*
reader_procedure          2     000246 automatic       varying char(32)         level 2 dcl 166 set ref 279*
rtrim                                                  builtin function         dcl 135 ref 615
s_iocb                          060542 automatic       pointer                  dcl 1056 set ref 1076* 1077* 1079* 1081* 1082*
sci_ptr                         000100 automatic       pointer                  dcl 81 set ref 248* 256* 263* 264* 280* 285* 290*
                                                                                  329 329* 374* 376* 379* 386* 400* 402* 405* 413*
                                                                                  423* 455* 457* 471* 482* 487* 503* 508* 516* 548*
                                                                                  605* 608* 633* 640* 667* 731* 735* 746* 750* 754*
                                                                                  762* 771* 776* 786* 793* 803* 813* 822* 827* 833*
                                                                                  870* 874* 885* 918* 931* 937* 940* 954* 965* 1025*
                                                                                  1033* 1103*
selectors                       037730 automatic       structure                array level 1 dcl 196 set ref 487 487 487 493
severity1                       060341 automatic       fixed bin(17,0)          dcl 444 set ref 515* 523 530*
severity2                       060342 automatic       fixed bin(17,0)          dcl 444 set ref 523* 526* 530*
severity_string                 060344 automatic       char(32)                 packed unaligned dcl 446 set ref 507* 508 512 515
                                                                                  515 516* 523 526 526
slx                             065466 automatic       fixed bin(17,0)          dcl 1142 in procedure "process_log_message" set ref
                                                                                  1148* 1149 1151 1153 1154 1156 1164 1164 1166 1169
                                                                                  1172 1175 1175 1178 1179 1179*
slx                             000100 automatic       fixed bin(17,0)          dcl 307 in procedure "clean_up" set ref 320* 321
                                                                                  321* 324* 325 325*
slx                             060541 automatic       fixed bin(17,0)          dcl 1055 in procedure "process_messages" set ref
                                                                                  1060* 1061 1062* 1067* 1070* 1070 1070 1070 1072
                                                                                  1072 1076 1077* 1077 1077 1077 1079 1079* 1112*
                                                                                  1113* 1118* 1119 1119 1121 1121 1123 1123* 1130*
                                                                                  1131 1131*
ssu_$abort_line                 000144 constant        entry                    external dcl 149 ref 264 285 374 376 379 386 400 402
                                                                                  405 413 423 455 457 471 482 487 503 508 516 548
                                                                                  605 608 633 640 731 750 762 771 776 786 793 803
                                                                                  813 822 827 833 870 885 918 931 937 940 965 1025
                                                                                  1033
ssu_$arg_count                  000132 constant        entry                    external dcl 142 ref 263
ssu_$arg_ptr                    000142 constant        entry                    external dcl 148 ref 667 735 754 874
ssu_$destroy_invocation         000140 constant        entry                    external dcl 146 ref 329
ssu_$get_area                   000134 constant        entry                    external dcl 143 ref 280
ssu_$print_message              000146 constant        entry                    external dcl 150 ref 954 1103
ssu_$set_debug_mode             000150 constant        entry                    external dcl 151 ref 746
ssu_$standalone_invocation      000136 constant        entry                    external dcl 144 ref 256
start_line                      060343 automatic       bit(1)                   dcl 445 set ref 552* 564* 575* 584* 603* 616
substr                                                 builtin function         dcl 135 ref 451 460 502 507 536 540 544 615
switch                          000530 automatic       char(32)                 array level 2 in structure "switches" packed packed
                                                                                  unaligned dcl 188 in procedure "summarize_sys_log"
                                                                                  set ref 462 1070* 1077*
switch                                 based           char(32)                 level 2 in structure "a_switch" packed packed
                                                                                  unaligned dcl 438 in procedure "process_line" set
                                                                                  ref 478* 633* 640*
switch_name                     060125 automatic       char(32)                 packed unaligned dcl 436 set ref 460* 462 478 481*
                                                                                  482* 503*
switches                        000530 automatic       structure                array level 1 dcl 188 set ref 464 471 471 471 476
switches_inhibited              065470 automatic       bit(1)                   array packed unaligned dcl 1144 set ref 1147* 1149
                                                                                  1156*
switchx                                based           fixed bin(17,0)          level 2 in structure "a_select" dcl 440 in procedure
                                                                                  "process_line" set ref 495*
switchx                         037730 automatic       fixed bin(17,0)          array level 2 in structure "selectors" dcl 196
                                                                                  in procedure "summarize_sys_log" set ref 1070 1076
                                                                                  1077 1121 1123 1149 1156 1169 1172 1175 1175 1178
                                                                                  1179 1179
switchx                         060135 automatic       fixed bin(17,0)          dcl 437 in procedure "process_line" set ref 461* 462
                                                                                  464* 471 474 476 495
temp_number                     060427 automatic       fixed bin(17,0)          dcl 661 set ref 840* 843*
test_sw                         065467 automatic       bit(1)                   dcl 1143 set ref 1153* 1156 1160
text_buffer                     060560 automatic       varying char(5000)       dcl 1140 set ref 1169* 1172 1172 1172 1172
text_required                   060364 automatic       bit(1)                   dcl 448 set ref 550* 558* 563* 569* 577* 585* 596*
                                                                                  602* 608
time                      2(18)        based           fixed bin(53,0)          level 3 packed packed unaligned dcl 3-13 ref 978 982
                                                                                  985 985
time_format              35            based           varying char(40)         level 2 dcl 4-3 set ref 811* 813*
to_opt                  130     000266 automatic       varying char(50)         level 3 dcl 168 set ref 723* 838 843 847 851 852*
                                                                                  905*
to_time                         060432 automatic       fixed bin(71,0)          dcl 662 set ref 847* 848
total_count                     060530 automatic       fixed bin(17,0)          dcl 996 set ref 999* 1018* 1018* 1028* 1033* 1033
total_messages                  060540 automatic       fixed bin(35,0)          dcl 1054 set ref 1058* 1134* 1146* 1146
unique_chars_                   000152 constant        entry                    external dcl 153 ref 934
unspec                                                 builtin function         dcl 135 set ref 1147*
v_log_ename                     060405 automatic       varying char(32)         dcl 659 set ref 715* 716
version                         000246 automatic       char(8)                  level 2 in structure "log_open_info" dcl 166
                                                                                  in procedure "summarize_sys_log" set ref 278*
version                 126     000266 automatic       char(8)                  level 3 in structure "opt" dcl 168 in procedure
                                                                                  "summarize_sys_log" set ref 904*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
iox_$attach_loud                000000 constant        entry                    external dcl 1-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 1-8
iox_$close_file                 000000 constant        entry                    external dcl 1-8
iox_$control                    000000 constant        entry                    external dcl 1-8
iox_$delete_record              000000 constant        entry                    external dcl 1-8
iox_$detach                     000000 constant        entry                    external dcl 1-8
iox_$err_no_operation           000000 constant        entry                    external dcl 1-8
iox_$err_not_attached           000000 constant        entry                    external dcl 1-8
iox_$err_not_closed             000000 constant        entry                    external dcl 1-8
iox_$err_not_open               000000 constant        entry                    external dcl 1-8
iox_$error_output                      external static pointer                  dcl 1-41
iox_$find_iocb                  000000 constant        entry                    external dcl 1-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 1-8
iox_$get_chars                  000000 constant        entry                    external dcl 1-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 7-51
iox_$modes                      000000 constant        entry                    external dcl 1-8
iox_$move_attach                000000 constant        entry                    external dcl 1-8
iox_$open_file                  000000 constant        entry                    external dcl 1-8
iox_$position                   000000 constant        entry                    external dcl 1-8
iox_$propagate                  000000 constant        entry                    external dcl 1-8
iox_$read_key                   000000 constant        entry                    external dcl 1-8
iox_$read_length                000000 constant        entry                    external dcl 1-8
iox_$read_record                000000 constant        entry                    external dcl 1-8
iox_$rewrite_record             000000 constant        entry                    external dcl 1-8
iox_$seek_key                   000000 constant        entry                    external dcl 1-8
iox_$user_input                        external static pointer                  dcl 1-41
iox_$user_io                           external static pointer                  dcl 1-41
iox_$write_record               000000 constant        entry                    external dcl 1-8
iox_modes                              internal static char(24)                 initial array dcl 2-6
log_limit_info_ptr                     automatic       pointer                  dcl 5-4
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 3-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 3-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 3-20
log_read_open_info_ptr                 automatic       pointer                  dcl 6-4
short_iox_modes                        internal static char(4)                  initial array dcl 2-12

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT                           002145 constant        label                    dcl 1201 ref 1199
FOUND                           011171 constant        label                    dcl 1042 ref 1007
FOUND_SWITCH                    004006 constant        label                    dcl 487 ref 465
INVALID_SEVERITY_RANGE          004264 constant        label                    dcl 516 ref 527
NO_MESSAGES                     011122 constant        label                    dcl 1033
SKIP_SELECT                     012413 constant        entry                    internal dcl 1185 ref 1149 1158 1160
SKIP_SELECTOR                   012407 constant        label                    dcl 1181 ref 1187
SSU_ABORT                       012417 constant        entry                    internal dcl 1196 ref 256 256
check_switch_state              005136 constant        entry                    internal dcl 630 ref 485
clean_up                        002147 constant        entry                    internal dcl 304 ref 254 300 1198
find_first_message              011007 constant        entry                    internal dcl 993 ref 292
get_next_arg                    007450 constant        entry                    internal dcl 864 ref 715 719 721 723 725 760 769 781
                                                                                  801 811 820
initialize_options              007617 constant        entry                    internal dcl 895 ref 267
make_log_pathname               002355 constant        entry                    internal dcl 337 ref 274
print_limits                    010510 constant        entry                    internal dcl 972 ref 295 1061
process_arguments               005276 constant        entry                    internal dcl 655 ref 268
process_line                    003444 constant        entry                    internal dcl 431 ref 949
process_log_message             012063 constant        entry                    internal dcl 1138 ref 1090
process_messages                011207 constant        entry                    internal dcl 1049 ref 297
read_control_file               007767 constant        entry                    internal dcl 925 ref 288
ssl                             001502 constant        entry                    external dcl 11
summarize_sys_log               001473 constant        entry                    external dcl 11
two_logs                        007556 constant        entry                    internal dcl 882 ref 670 676 683 689 695 701 707 713

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13356       13562   12440       13366
Length     14316   12440       204         520     716           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
summarize_sys_log                 28372 external procedure  is an external procedure.  
on unit on line 254                  64 on unit               
clean_up                             75 internal procedure  is called by several nonquick procedures.  
make_log_pathname                       internal procedure  shares stack frame of external procedure summarize_sys_log.  
process_line                            internal procedure  shares stack frame of external procedure summarize_sys_log.  
check_switch_state                      internal procedure  shares stack frame of external procedure summarize_sys_log.  
process_arguments                       internal procedure  shares stack frame of external procedure summarize_sys_log.  
get_next_arg                            internal procedure  shares stack frame of external procedure summarize_sys_log.  
two_logs                                internal procedure  shares stack frame of external procedure summarize_sys_log.  
initialize_options                      internal procedure  shares stack frame of external procedure summarize_sys_log.  
read_control_file                       internal procedure  shares stack frame of external procedure summarize_sys_log.  
print_limits                            internal procedure  shares stack frame of external procedure summarize_sys_log.  
find_first_message                      internal procedure  shares stack frame of external procedure summarize_sys_log.  
process_messages                        internal procedure  shares stack frame of external procedure summarize_sys_log.  
process_log_message                     internal procedure  shares stack frame of external procedure summarize_sys_log.  
SKIP_SELECT                             internal procedure  shares stack frame of external procedure summarize_sys_log.  
SSU_ABORT                            64 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 slx                         clean_up
summarize_sys_log        000100 sci_ptr                     summarize_sys_log
                         000102 arg_count                   summarize_sys_log
                         000104 ap                          summarize_sys_log
                         000106 al                          summarize_sys_log
                         000107 dm_system_log_path          summarize_sys_log
                         000161 dsa_system_log_path         summarize_sys_log
                         000233 code                        summarize_sys_log
                         000242 log_message_ptr             summarize_sys_log
                         000244 log_message_format_ptr      summarize_sys_log
                         000246 log_open_info               summarize_sys_log
                         000266 opt                         summarize_sys_log
                         000530 switches                    summarize_sys_log
                         037730 selectors                   summarize_sys_log
                         057430 n_switches                  summarize_sys_log
                         057431 n_selectors                 summarize_sys_log
                         057432 line                        summarize_sys_log
                         057433 dir_name                    summarize_sys_log
                         057505 entryname                   summarize_sys_log
                         057515 buffer_space                summarize_sys_log
                         060107 buffer_length               summarize_sys_log
                         060124 commax                      process_line
                         060125 switch_name                 process_line
                         060135 switchx                     process_line
                         060136 asp                         process_line
                         060140 aslp                        process_line
                         060142 match_text                  process_line
                         060340 new_commax                  process_line
                         060341 severity1                   process_line
                         060342 severity2                   process_line
                         060343 start_line                  process_line
                         060344 severity_string             process_line
                         060354 opcode_string               process_line
                         060364 text_required               process_line
                         060404 argx                        process_arguments
                         060405 v_log_ename                 process_arguments
                         060416 number_arg                  process_arguments
                         060427 temp_number                 process_arguments
                         060430 from_time                   process_arguments
                         060432 to_time                     process_arguments
                         060434 exchange_opt                process_arguments
                         060452 code                        process_arguments
                         060504 control_iocb_name           read_control_file
                         060530 total_count                 find_first_message
                         060531 hold_message_sw             find_first_message
                         060540 total_messages              process_messages
                         060541 slx                         process_messages
                         060542 s_iocb                      process_messages
                         060560 text_buffer                 process_log_message
                         063123 expand_buffer               process_log_message
                         065466 slx                         process_log_message
                         065467 test_sw                     process_log_message
                         065470 switches_inhibited          process_log_message

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_$add_suffix check_gate_access_            com_err_                      convert_date_to_binary_
cu_$arg_list_ptr              cv_dec_check_                 dm_misc_util_$get_log_path    dsa_nit_$get_field
expand_log_message_           expand_pathname_              format_log_message_$adjust    format_log_message_$format
format_log_message_$free      format_log_message_$init      get_wdir_                     ioa_
ioa_$ioa_switch               iox_$attach_name              iox_$close                    iox_$destroy_iocb
iox_$detach_iocb              iox_$get_line                 iox_$look_iocb                iox_$open
iox_$put_chars                log_format_time_              log_limit_scan_               log_match_$add_match
log_match_$add_severity       log_match_$free               log_match_$print              log_match_$test
log_read_$close               log_read_$free_message        log_read_$hold_message        log_read_$next_message
log_read_$open                log_read_$open_long           log_read_$prev_message        pathname_
ssu_$abort_line               ssu_$arg_count                ssu_$arg_ptr                  ssu_$destroy_invocation
ssu_$get_area                 ssu_$print_message            ssu_$set_debug_mode           ssu_$standalone_invocation
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_conversion   error_table_$badopt           error_table_$end_of_info
error_table_$moderr           error_table_$no_log_message   error_table_$noarg            error_table_$noentry
error_table_$not_attached     error_table_$too_many_args    iox_$user_output              log_data_$syserr_log_dir
log_data_$syserr_log_name




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 001472       248 001507       249 001511       250 001512       251 001513       252 001514       254 001517
    256 001541       257 001615       259 001617       260 001635       263 001636       264 001650       267 001705
    268 001706       274 001707       276 001710       278 001714       279 001716       280 001723       281 001755
    282 001756       283 002012       284 002013       285 002042       288 002075       290 002076       292 002121
    295 002122       297 002137       300 002140       301 002144      1201 002145       304 002146       309 002154
    311 002161       312 002172       313 002205       316 002220       318 002237       320 002253       321 002265
    323 002304       324 002306       325 002317       327 002336       329 002340       332 002354       337 002355
    341 002357       343 002363       344 002371       345 002376       346 002414       348 002415       350 002421
    351 002425       352 002431       353 002450       354 002451       356 002455       357 002461       358 002465
    359 002504       360 002505       362 002511       363 002523       364 002552       365 002555       366 002560
    367 002561       372 002565       374 002611       376 002643       379 002677       384 002733       386 002773
    389 003023       390 003052       391 003055       392 003060       393 003061       398 003065       400 003111
    402 003143       405 003177       410 003233       413 003273       416 003323       417 003352       418 003355
    419 003360       422 003361       423 003406       427 003442       431 003444       434 003446       450 003451
    451 003452       454 003457       455 003472       457 003534       460 003572       461 003616       462 003626
    464 003636       465 003640       467 003641       471 003643       474 003704       476 003707       478 003712
    479 003716       480 003720       481 003721       482 003742       484 004002       485 004005       487 004006
    492 004051       493 004053       495 004057       496 004061       497 004063       498 004064       502 004065
    503 004102       507 004141       508 004152       510 004206       512 004211       515 004217       516 004261
    523 004322       526 004340       527 004410       530 004413       536 004430       538 004447       540 004450
    541 004455       542 004456       544 004457       545 004464       548 004466       550 004524       551 004526
    552 004530       553 004531       555 004541       557 004545       558 004547       559 004551       560 004552
    562 004556       563 004560       564 004562       565 004563       566 004564       568 004570       569 004572
    570 004574       571 004575       572 004576       574 004602       575 004604       576 004606       577 004607
    578 004610       579 004611       581 004620       583 004624       584 004626       585 004630       586 004631
    587 004632       589 004636       590 004640       591 004642       592 004643       594 004647       595 004651
    596 004653       597 004654       598 004655       600 004661       601 004663       602 004665       603 004666
    604 004667       605 004670       608 004725       613 004770       615 004774       616 005043       618 005045
    619 005070       621 005101       622 005133       623 005134       630 005136       633 005140       636 005203
    638 005212       639 005214       640 005234       644 005274       655 005276       666 005300       667 005310
    668 005326       670 005342       672 005347       673 005354       674 005355       676 005361       678 005366
    679 005371       681 005372       683 005402       685 005407       686 005412       687 005413       689 005417
    691 005424       692 005427       693 005430       695 005440       697 005445       698 005450       699 005451
    701 005461       703 005466       704 005471       705 005472       707 005502       709 005507       710 005512
    711 005513       713 005523       715 005530       716 005542       717 005602       719 005604       721 005626
    723 005650       725 005666       729 005710       731 005714       734 005745       735 005747       736 005765
    737 005772       739 005773       741 006006       743 006020       745 006030       746 006032       747 006046
    748 006047       750 006057       753 006110       754 006112       755 006130       756 006135       758 006136
    760 006146       761 006160       762 006173       765 006230       767 006231       769 006245       770 006257
    771 006317       775 006357       776 006372       778 006426       779 006427       781 006437       782 006451
    785 006471       786 006527       792 006567       793 006602       796 006641       799 006642       801 006652
    802 006664       803 006677       806 006734       809 006735       811 006745       812 006757       813 006772
    816 007023       818 007024       820 007034       821 007046       822 007061       825 007116       827 007117
    828 007153       833 007156       838 007213       840 007225       841 007263       843 007266       844 007323
    846 007326       847 007362       848 007420       850 007425       851 007433       852 007440       858 007446
    864 007450       870 007462       873 007521       874 007523       876 007541       878 007555       882 007556
    885 007560       887 007615       895 007617       899 007621       900 007624       901 007625       902 007626
    903 007634       904 007667       905 007671       906 007672       907 007673       908 007674       909 007675
    910 007700       911 007710       912 007714       913 007716       914 007717       915 007720       916 007722
    917 007723       918 007735       921 007765       925 007767       929 007771       931 010022       934 010055
    935 010105       937 010145       939 010201       940 010222       943 010256       945 010261       946 010262
    947 010263       948 010270       949 010314       951 010320       953 010323       954 010325       956 010355
    958 010356       959 010371       960 010405       961 010421       963 010423       965 010454       968 010506
    972 010510       978 010513       982 010604       985 010675       989 011005       993 011007       999 011011
   1006 011012      1007 011013      1016 011017      1018 011021      1020 011030      1021 011044      1023 011046
   1025 011054      1028 011104      1031 011113      1033 011116      1039 011164      1040 011166      1042 011171
   1045 011205      1049 011207      1058 011211      1060 011212      1061 011222      1062 011236      1063 011257
   1065 011262      1067 011301      1068 011312      1070 011314      1072 011354      1076 011403      1077 011413
   1079 011454      1081 011504      1082 011525      1083 011544      1086 011547      1087 011551      1090 011556
   1093 011557      1097 011566      1098 011602      1101 011604      1103 011606      1107 011637      1112 011640
   1113 011652      1114 011671      1118 011674      1119 011704      1121 011713      1123 011746      1126 011773
   1130 011776      1131 012006      1132 012035      1134 012040      1135 012061      1138 012063      1146 012065
   1147 012071      1148 012075      1149 012106      1151 012116      1153 012126      1154 012155      1156 012161
   1158 012172      1159 012173      1160 012174      1164 012201      1165 012205      1166 012206      1169 012244
   1172 012305      1175 012341      1177 012366      1178 012400      1179 012406      1181 012407      1191 012412
   1185 012413      1187 012415      1196 012416      1198 012424      1199 012431


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
