	COMPILATION LISTING OF SEGMENT od_stack_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1047.6 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 od_stack_: proc (stackptr, stacklen, sltp, namp, sstp, sstnp);
       12 
       13 /* Coded by RE Mullen June 73 */
       14 
       15 /* Called with pointer to a stack, the stack's length,
       16*   and pointers to an SLT and name_seg */
       17 
       18 dcl (stackptr, sp_next, sp_curr, lineptr) ptr;
       19 dcl (stacklen, i, frame_no, depth, slen, fword, sword, segno, spoff, case, fsize) fixed bin;
       20 dcl  stackwords (0: 1) fixed bin (35) aligned based (sb);
       21 dcl (addr, baseno, baseptr, addrel, max, min, mod, ptr, null, fixed, rel) builtin;
       22 dcl  od_print_$op_fmt_line entry (fixed bin, fixed bin, fixed bin (35));
       23 dcl  od_print_ entry options (variable);
       24 dcl (curptr, lastptr) ptr;
       25 
       26 dcl  plural char (1) aligned;
       27 dcl  nskip fixed bin;
       28 dcl  fmtskip char (21) aligned int static init ("^-^7o line^a repeated");
       29 dcl 1 dbl based aligned,
       30     2 (zero, two, four, six) fixed bin (71);
       31 dcl (entinfo, retinfo) char (128) aligned init ("");
       32 
       33 /*
       34*dcl  od_frame_owner_ entry (ptr, ptr, ptr, ptr, ptr, char (*) aligned, char (*) aligned);
       35**/
       36 dcl (sltp, ptr_to_entry, namp, ptr_to_return, sstp, sstnp) ptr;
       37 dcl (subsysfrms, save_slen) fixed bin init (0);
       38 dcl (save_sp_next, save_sp, last_sp) ptr;
       39 dcl  subsysflag fixed bin init (0);
  1     1 /* BEGIN INCLUDE FILE its.incl.pl1
  1     2*   modified 27 July 79 by JRDavis to add its_unsigned
  1     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  1     4 
  1     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  1     6     2 pad1 bit (3) unaligned,
  1     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  1     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  1     9     2 pad2 bit (9) unaligned,
  1    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  1    11 
  1    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  1    13     2 pad3 bit (3) unaligned,
  1    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  1    15     2 pad4 bit (3) unaligned,
  1    16     2 mod bit (6) unaligned;				/* further modification */
  1    17 
  1    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  1    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  1    20     2 pad1 bit (27) unaligned,
  1    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  1    22 
  1    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  1    24     2 pad2 bit (3) unaligned,
  1    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  1    26     2 pad3 bit (3) unaligned,
  1    27     2 mod bit (6) unaligned;				/* further modification */
  1    28 
  1    29 
  1    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  1    31     2 pad1 bit (3) unaligned,
  1    32     2 segno fixed bin (15) unsigned unaligned,
  1    33     2 ringno fixed bin (3) unsigned unaligned,
  1    34     2 pad2 bit (9) unaligned,
  1    35     2 its_mod bit (6) unaligned,
  1    36 
  1    37     2 offset fixed bin (18) unsigned unaligned,
  1    38     2 pad3 bit (3) unaligned,
  1    39     2 bit_offset fixed bin (6) unsigned unaligned,
  1    40     2 pad4 bit (3) unaligned,
  1    41     2 mod bit (6) unaligned;
  1    42 
  1    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  1    44     2 pr_no fixed bin (3) unsigned unaligned,
  1    45     2 pad1 bit (27) unaligned,
  1    46     2 itp_mod bit (6) unaligned,
  1    47 
  1    48     2 offset fixed bin (18) unsigned unaligned,
  1    49     2 pad2 bit (3) unaligned,
  1    50     2 bit_offset fixed bin (6) unsigned unaligned,
  1    51     2 pad3 bit (3) unaligned,
  1    52     2 mod bit (6) unaligned;
  1    53 
  1    54 
  1    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  1    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  1    57 
  1    58 /* END INCLUDE FILE   its.incl.pl1 */
       40 
  2     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  2     2 
  2     3 /* format: off */
  2     4 
  2     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  2     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  2     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  2     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  2     9 
  2    10 
  2    11 /****^  HISTORY COMMENTS:
  2    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  2    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  2    14*     Modified to add constants for the translator_id field in the stack_frame
  2    15*     structure.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 
  2    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  2    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  2    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  2    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  2    23 
  2    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  2    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  2    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  2    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  2    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  2    29 
  2    30 
  2    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  2    32 
  2    33 dcl  stack_frame_min_length fixed bin static init(48);
  2    34 
  2    35 
  2    36 dcl 1 stack_frame based(sp) aligned,
  2    37     2 pointer_registers(0 : 7) ptr,
  2    38     2 prev_sp pointer,
  2    39     2 next_sp pointer,
  2    40     2 return_ptr pointer,
  2    41     2 entry_ptr pointer,
  2    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  2    43     2 arg_ptr pointer,
  2    44     2 static_ptr ptr unaligned,
  2    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  2    46     2 on_unit_relp1 bit(18) unaligned,
  2    47     2 on_unit_relp2 bit(18) unaligned,
  2    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  2    49*						   0 => PL/I version II
  2    50*						   1 => ALM
  2    51*						   2 => PL/I version I   
  2    52*						   3 => signal caller frame
  2    53*						   4 => signaller frame */
  2    54     2 operator_return_offset bit(18) unaligned,
  2    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  2    56     2 a bit(36),					/* accumulator */
  2    57     2 q bit(36),					/* q-register */
  2    58     2 e bit(36),					/* exponent */
  2    59     2 timer bit(27) unaligned,				/* timer */
  2    60     2 pad bit(6) unaligned,
  2    61     2 ring_alarm_reg bit(3) unaligned;
  2    62 
  2    63 
  2    64 dcl 1 stack_frame_flags based(sp) aligned,
  2    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  2    66     2 xx0 bit(22) unal,
  2    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  2    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  2    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  2    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  2    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  2    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  2    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  2    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  2    75     2 xx0a bit(6) unal,
  2    76     2 xx1 fixed bin,
  2    77     2 xx2 fixed bin,
  2    78     2 xx3 bit(25) unal,
  2    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  2    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  2    81     2 xx3a bit(9) unaligned,
  2    82     2 xx4(9) bit(72) aligned,
  2    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  2    84*						*  operator puts a pointer to the base of
  2    85*						*  the calling procedure here. (text base ptr)  */
  2    86     2 xx5 bit(72) aligned,
  2    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  2    88 
  2    89 /* format: on */
  2    90 
  2    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
       41 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  3     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  3     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  3     4 /*	Modified April 1983 by C. Hornig for tasking */
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  3     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  3     9*     added the heap_header_ptr definition.
  3    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  3    12*     Modified to support control point management.  These changes were actually
  3    13*     made in February 1985 by G. Palter.
  3    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  3    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  3    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  3    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  3    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  3    19*     (ITS pair).
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 /* format: style2 */
  3    23 
  3    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  3    25 
  3    26      dcl	   1 stack_header	      based (sb) aligned,
  3    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  3    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  3    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  3    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  3    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  3    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  3    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  3    34 	     2 pad4	      bit (2) unal,
  3    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  3    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  3    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  3    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  3    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  3    40 	     2 null_ptr	      ptr,		/*  (16)  */
  3    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  3    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  3    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  3    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  3    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  3    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  3    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  3    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  3    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  3    50 	     2 return_no_pop_op_ptr
  3    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  3    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  3    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  3    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  3    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  3    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  3    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  3    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  3    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  3    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  3    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  3    62 	     2 trace,
  3    63 	       3 frames,
  3    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  3    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  3    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  3    67 	     2 pad2	      bit (36),		/*  (61) */
  3    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  3    69 
  3    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  3    71 
  3    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  3    73 						/* (551) octal */
  3    74 
  3    75 
  3    76 /*	The following constants are offsets within this transfer vector table.  */
  3    77 
  3    78      dcl	   (
  3    79 	   call_offset	      fixed bin init (271),
  3    80 	   push_offset	      fixed bin init (272),
  3    81 	   return_offset	      fixed bin init (273),
  3    82 	   return_no_pop_offset   fixed bin init (274),
  3    83 	   entry_offset	      fixed bin init (275)
  3    84 	   )		      internal static;
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 
  3    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  3    91*	move the whole stack header should use this overlay.
  3    92**/
  3    93 
  3    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  3    95 
  3    96 
  3    97 
  3    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
       42 
       43 
       44 /*  */
       45 	sp, sb = stackptr;				/* initialize and copy args */
       46 	slen = stacklen;				/* the length of the stack we will dump */
       47 
       48 	sp_next = stack_header.stack_begin_ptr;		/* we will do a forward trace */
       49 	segno = fixed (baseno (sp_next));		/* this is the segno the dead stack had */
       50 	call check_sp_next;
       51 	if case <= 4 then do;			/* its a pointer and spoff is set to rel (sp_next) */
       52 	     if segno = 49 then if spoff = 272 then sp_next = addrel (sp_next, 48); /* PRDS has bug in it . . . */
       53 	end;
       54 
       55 
       56 /* Prelim. trace to see if any next_sp = stack_end_ptr, if so
       57*   the frame will be number zero implying its owner was running */
       58 
       59 	do frame_no = 0 by 1;
       60 	     call check_sp_next;			/* internal proc to keep from being too gullible */
       61 	     if case ^= 0 then go to bad;		/* sp_next loses */
       62 	     if addr (stack_header.stack_end_ptr) -> its.its_mod ^= "100011"b then go to bad;/* not its? */
       63 	     if addr (stack_header.stack_end_ptr) -> its.mod ^= "000000"b then go to bad; /* not its? */
       64 	     if spoff > fixed (rel (stack_header.stack_end_ptr), 18) then do; /* spoff has been set to offset of sp_next */
       65 		case = 10;			/* FOR DEBUGGING */
       66 		go to bad;
       67 	     end;
       68 	     if sp_next = stack_header.stack_end_ptr then go to good; /* this frame will be number zero . . */
       69 	     sp = ptr (sb, spoff);			/* advance to next frame, but fudge segno  */
       70 	     sp_next = stack_frame.next_sp;		/* pick up new sp_next */
       71 
       72 
       73 	end;
       74 
       75 bad:	frame_no = 0;				/* if stack was bad or not active, number frames from 0 up */
       76 good:	
       77 
       78 
       79 
       80 /* Now loop through th frames. At the beginning of each
       81*   iteration sp will point to a frame to be printed (eg. sp = 334|2740),
       82*   and sword will be the relative offset from the base of thestack
       83*   of the first word of the frame.  If that frames next_sp is good
       84*   then sp will be advanced and the current frame will be printed.
       85*   If next_sp is bad then the remainder of the stack will
       86*   be dumped.  Also any frames jumped over by syserr will
       87*   be broken out with number "XX" */
       88 	curptr, sp, sb = stackptr;			/* reinitialize */
       89 	slen = stacklen;				/* in case we tampered with anything */
       90 	sp_next = stack_header.stack_begin_ptr;		/* again trace forward */
       91 	call check_sp_next;
       92 	if case <= 4 then do;			/* sp_next is ptr and spoff is set to rel (sp_next) */
       93 	     if segno = 49 then if spoff = 272  then sp_next = addrel (sp_next, 48); /* PRDS has bug in it . . . */
       94 	     sp_curr = ptr (sp_next, 0);		/* back pointers will be checked against this */
       95 	end;
       96 	sword = 0;				/* offset from base of the first word of a line to be printed */
       97 	ptr_to_entry, ptr_to_return = null;		/* for stack header */
       98 	subsysfrms = 0;				/* will = 1 if looking at frame jumped over by syserr */
       99 
      100 	do i = 0 by 1;				/* only way out of loop is if sword >= slen */
      101 below_syserr: 					/* come here when i must no increase */
      102 	     call check_sp_next;			/* which will advance spoff and set case */
      103 	     if case ^= 0 then go to dump_rest;		/* print this frame heading and rest of stack */
      104 
      105 	     last_sp = sp;				/* save this in case we find frames preserved by syserr */
      106 	     sp = ptr (sb, spoff);			/* advance sp to next frame */
      107 
      108 	     if (i > 0 & i - frame_no >= 0) | subsysfrms = 1 then do; /* skip these tests low on the stack */
      109 		if addr (stack_frame.prev_sp) -> its.its_mod ^= "100011"b then go to dump_rest; /* not its? */
      110 		if addr (stack_frame.prev_sp) -> its.mod ^= "000000"b then go to dump_rest;/* furth. mod? */
      111 		if addr (sp_curr) -> its.its_mod ^= "100011"b then go to dump_rest;/* not its? */
      112 		if addr (sp_curr) -> its.mod ^= "000000"b then go to dump_rest;/* furth. mod? */
      113 
      114 		if baseno (sp_curr) ^= baseno (stack_frame.prev_sp) then go to dump_rest; /* another segno? */
      115 		if rel (sp_curr) ^= rel (stack_frame.prev_sp) then go to dump_rest; /* back pointer bad? */
      116 	     end;
      117 
      118 	     if spoff = 12288 then if subsysfrms = 0 then do; /* probable syserr frame */
      119 		subsysfrms = 1;			/* detour to see what is between here and syserr */
      120 		save_slen = slen;			/* remember the length of the stack */
      121 		save_sp = sp;			/* and the address of the syserr frame */
      122 		save_sp_next = sp_next;		/* and the stacks internal representation of same */
      123 		slen = 12288;			/* only want to print up to the syserr frame for now */
      124 		sp = last_sp;			/* reset sp to previous frame */
      125 		sp_next = ptr_to_entry;		/* and pick up sp_next from where syserr saves it */
      126 		go to below_syserr;			/* retry the above with fudged sp_next */
      127 	     end;
      128 
      129 	     fsize = fixed (rel (sp_next), 18) - fixed (rel (sp_curr), 18); /* size of frame to be printed */
      130 	     go to print_frame;			/* and print it knowing there will be another frame */
      131 
      132 dump_rest:     fsize = slen - sword;			/* no next frame */
      133 
      134 print_frame:   
      135 
      136 	     retinfo, entinfo = "";			/* don't know anything yet */
      137 
      138 /*
      139*	     call od_frame_owner_ (ptr_to_return, ptr_to_entry, sltp, namp, sstp, sstnp, retinfo, entinfo);
      140**/
      141 	     if subsysflag = 0 then			/* a mainline frame with a number */
      142 	     call od_print_ (2, "^/^3-STACK FRAME ^d	^a", i - frame_no, retinfo); /* print the info */
      143 	     else					/* this frame has been jumped over by syserr, no number */
      144 	     call od_print_ (2, "^/^3-STACK FRAME XX	^a", retinfo);
      145 
      146 	     if entinfo ^= "" then			/* entinfo may be in retinfo, or may be absent */
      147 	     call od_print_ (2, "^5-entry_ptr: ^a^/", entinfo);
      148 	     else
      149 	     call od_print_ (2, "^/");
      150 	     if subsysfrms = 1 then subsysflag = 1;	/* frame no = XX for now */
      151 
      152 	     nskip = 0;				/* have skiped no lines so far this frame */
      153 	     do fword = 0 by 8 while (fword < fsize);	/* loop to print contents of frame */
      154 		if fword ^= 0 then			/* dont check for repeat on first line */
      155 		if lastptr -> dbl.zero = curptr -> dbl.zero then /* see if current line same al last printed line */
      156 		if lastptr -> dbl.two = curptr -> dbl.two then
      157 		if lastptr -> dbl.four = curptr -> dbl.four then
      158 		if lastptr -> dbl.six = curptr -> dbl.six then do;
      159 		     nskip = nskip + 1;		/* note that another line has been skipped */
      160 		     go to SKIP;			/* and skip printing the line */
      161 		end;
      162 		if nskip > 0 then do;		/* before printing a line check backlog of skipped lines */
      163 		     if nskip > 1 then plural = "s"; else plural = " "; /* more than one? */
      164 		     call od_print_ (1, fmtskip, nskip, plural); /* tell how many */
      165 		     nskip = 0;			/* these are accounted for */
      166 		end;
      167 		call od_print_$op_fmt_line (sword, fword, stackwords (sword)); /* now print the line */
      168 		lastptr = curptr;			/* future lines will be compared to this one */
      169 SKIP:						/* come here if line was to be skipped */
      170 		sword = sword + 8;			/* want to move to next line in any case */
      171 		curptr = addrel (curptr, 8);		/* and advance pointer to it also */
      172 	     end;					/* leave loop when frame is printed */
      173 	     if nskip > 0 then do;			/* could have skipped a lot of lines lately */
      174 		if nskip > 1 then plural = "s"; else plural = " "; /*  */
      175 		call od_print_ (1, fmtskip, nskip, plural); /* tell how many */
      176 	     end;
      177 	     if sword >= slen then do;		/* whole stack may be done . . . */
      178 		if subsysfrms = 1 then do;
      179 		     subsysfrms = 0;		/* in which case we want to continue */
      180 		     subsysflag = 0;		/* print frame num not XX from now on */
      181 		     slen = save_slen;		/* reset to real lenght of stack */
      182 		     sp = save_sp;			/* reset sp to point to syserr frame */
      183 		     sp_next = save_sp_next;		/* reset */
      184 		end;
      185 		else go to ALLDONE;			/* actually at end of stack */
      186 	     end;
      187 
      188 	     sp_curr = sp_next;			/* advance internal representation */
      189 	     ptr_to_entry = stack_frame.entry_ptr;	/* sp -> next frame to be printed, which is known to be good */
      190 	     if fixed (stack_frame.translator_id, 18) = 2	/* Version I pl1 */
      191 	     then ptr_to_return = stack_frame.pointer_registers (0);
      192 	     else ptr_to_return = stack_frame.return_ptr;	/* ret ptr in exptected place */
      193 	     sp_next = stack_frame.next_sp;		/* pick up foward pointer */
      194 	     if subsysfrms = 1 then go to below_syserr;	/* so frame nums won't increase */
      195 	end;
      196 ALLDONE:						/* exit from above loop by coming here */
      197 	return;
      198 
      199 
      200 
      201 
      202 /* -------------------------------------------------------------------------- */
      203 
      204 
      205 check_sp_next: proc;				/* verifies that sp_next might point to next stack frame */
      206 
      207 
      208 	     if addr (sp_next) -> its.mod = "000000"b then /* if sp_next is not too fancy */
      209 	     if addr (sp_next) -> its.its_mod = "100011"b then do; /* and if it is an its pointer */
      210 		spoff = fixed (rel (sp_next), 18);	/* then pick up word offset portion */
      211 		if fixed (baseno (sp_next), 18) = segno then /* if segno is good */
      212 		if spoff <= slen -stack_frame_min_length then /* if spoff is not too big */
      213 		if mod (spoff, 16) = 0 then		/* and mod16 */
      214 		if spoff >= fixed (rel (sp), 18) + stack_frame_min_length then /* and further up the stack */
      215 		case = 0;				/* then its possible sp_next points to a sack frame */
      216 		else case = 1;			/* sp_next not forword enough */
      217 		else case = 2;			/* sp_next not mod16 */
      218 		else case = 3;			/* sp_next points off end of what stack we have */
      219 		else case = 4;			/* sp_next points into some other segment */
      220 	     end;
      221 	     else case = 5;				/* sp_next is not a pointer */
      222 	     else case = 6;				/* sp_next has further modification */
      223 
      224 	     return;
      225 	end check_sp_next;
      226 
      227      end od_stack_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1034.3  od_stack_.pl1                     >special_ldd>install>MR12.0-1206>od_stack_.pl1
40           1    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
41           2    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
42           3    11/04/86  1324.3  stack_header.incl.pl1             >special_ldd>install>MR12.0-1206>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 21 ref 62 63 109 110 111 112 208 208
addrel                                                 builtin function         dcl 21 ref 52 93 171
baseno                                                 builtin function         dcl 21 ref 49 114 114 211
case                            000113 automatic       fixed bin(17,0)          dcl 19 set ref 51 61 65* 92 103 211* 216* 217* 218*
                                                                                  219* 221* 222*
curptr                          000116 automatic       pointer                  dcl 24 set ref 76* 154 154 154 154 168 171* 171
dbl                                    based           structure                level 1 dcl 29
entinfo                         000124 automatic       char(128)                initial dcl 31 set ref 31* 134* 146 146*
entry_ptr                26            based           pointer                  level 2 dcl 2-36 ref 189
fixed                                                  builtin function         dcl 21 ref 49 64 129 129 190 210 211 211
fmtskip                         000010 internal static char(21)                 initial dcl 28 set ref 164* 175*
four                      4            based           fixed bin(71,0)          level 2 dcl 29 ref 154 154
frame_no                        000105 automatic       fixed bin(17,0)          dcl 19 set ref 59* 75* 108 141
fsize                           000114 automatic       fixed bin(17,0)          dcl 19 set ref 129* 132* 153
fword                           000107 automatic       fixed bin(17,0)          dcl 19 set ref 153* 153* 154 167*
i                               000104 automatic       fixed bin(17,0)          dcl 19 set ref 100* 108 108 141*
its                                    based           structure                level 1 dcl 1-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 1-5 ref 62 109 111 208
last_sp                         000236 automatic       pointer                  dcl 38 set ref 105* 124
lastptr                         000120 automatic       pointer                  dcl 24 set ref 154 154 154 154 168*
mod                       1(30)        based           bit(6)                   level 2 in structure "its" packed unaligned dcl 1-5
                                                                                  in procedure "od_stack_" ref 63 110 112 208
mod                                                    builtin function         dcl 21 in procedure "od_stack_" ref 211
namp                                   parameter       pointer                  dcl 36 ref 11
next_sp                  22            based           pointer                  level 2 dcl 2-36 ref 70 193
nskip                           000123 automatic       fixed bin(17,0)          dcl 27 set ref 152* 159* 159 162 163 164* 165* 173
                                                                                  174 175*
null                                                   builtin function         dcl 21 ref 97
od_print_                       000020 constant        entry                    external dcl 23 ref 141 143 146 148 164 175
od_print_$op_fmt_line           000016 constant        entry                    external dcl 22 ref 167
plural                          000122 automatic       char(1)                  dcl 26 set ref 163* 163* 164* 174* 174* 175*
pointer_registers                      based           pointer                  array level 2 dcl 2-36 ref 190
prev_sp                  20            based           pointer                  level 2 dcl 2-36 set ref 109 110 114 115
ptr                                                    builtin function         dcl 21 ref 69 94 106
ptr_to_entry                    000224 automatic       pointer                  dcl 36 set ref 97* 125 189*
ptr_to_return                   000226 automatic       pointer                  dcl 36 set ref 97* 190* 192*
rel                                                    builtin function         dcl 21 ref 64 115 115 129 129 210 211
retinfo                         000164 automatic       char(128)                initial dcl 31 set ref 31* 134* 141* 143*
return_ptr               24            based           pointer                  level 2 dcl 2-36 ref 192
save_slen                       000231 automatic       fixed bin(17,0)          initial dcl 37 set ref 37* 120* 181
save_sp                         000234 automatic       pointer                  dcl 38 set ref 121* 182
save_sp_next                    000232 automatic       pointer                  dcl 38 set ref 122* 183
sb                              000244 automatic       pointer                  dcl 3-24 set ref 45* 48 62 63 64 68 69 76* 90 106
                                                                                  167
segno                           000111 automatic       fixed bin(17,0)          dcl 19 set ref 49* 52 93 211
six                       6            based           fixed bin(71,0)          level 2 dcl 29 ref 154 154
slen                            000106 automatic       fixed bin(17,0)          dcl 19 set ref 46* 89* 120 123* 132 177 181* 211
sltp                                   parameter       pointer                  dcl 36 ref 11
sp                              000242 automatic       pointer                  dcl 2-31 set ref 45* 69* 70 76* 105 106* 109 110 114
                                                                                  115 121 124* 182* 189 190 190 192 193 211
sp_curr                         000102 automatic       pointer                  dcl 18 set ref 94* 111 112 114 115 129 188*
sp_next                         000100 automatic       pointer                  dcl 18 set ref 48* 49 52* 52 68 70* 90* 93* 93 94
                                                                                  122 125* 129 183* 188 193* 208 208 210 211
spoff                           000112 automatic       fixed bin(17,0)          dcl 19 set ref 52 64 69 93 106 118 210* 211 211 211
sstnp                                  parameter       pointer                  dcl 36 ref 11
sstp                                   parameter       pointer                  dcl 36 ref 11
stack_begin_ptr          22            based           pointer                  level 2 dcl 3-26 ref 48 90
stack_end_ptr            24            based           pointer                  level 2 dcl 3-26 set ref 62 63 64 68
stack_frame                            based           structure                level 1 dcl 2-36
stack_frame_min_length                 constant        fixed bin(17,0)          initial dcl 2-33 ref 211 211
stack_header                           based           structure                level 1 dcl 3-26
stacklen                               parameter       fixed bin(17,0)          dcl 19 ref 11 46 89
stackptr                               parameter       pointer                  dcl 18 ref 11 45 76
stackwords                             based           fixed bin(35,0)          array dcl 20 set ref 167*
subsysflag                      000240 automatic       fixed bin(17,0)          initial dcl 39 set ref 39* 141 150* 180*
subsysfrms                      000230 automatic       fixed bin(17,0)          initial dcl 37 set ref 37* 98* 108 118 119* 150 178
                                                                                  179* 194
sword                           000110 automatic       fixed bin(17,0)          dcl 19 set ref 96* 132 167* 167 169* 169 177
translator_id            37            based           bit(18)                  level 2 packed unaligned dcl 2-36 ref 190
two                       2            based           fixed bin(71,0)          level 2 dcl 29 ref 154 154
zero                                   based           fixed bin(71,0)          level 2 dcl 29 ref 154 154

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 1-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 1-55
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 2-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 2-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 2-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 2-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 2-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 2-27
baseptr                                                builtin function         dcl 21
call_offset                            internal static fixed bin(17,0)          initial dcl 3-78
depth                                  automatic       fixed bin(17,0)          dcl 19
entry_offset                           internal static fixed bin(17,0)          initial dcl 3-78
itp                                    based           structure                level 1 dcl 1-18
itp_unsigned                           based           structure                level 1 dcl 1-43
its_unsigned                           based           structure                level 1 dcl 1-30
lineptr                                automatic       pointer                  dcl 18
max                                                    builtin function         dcl 21
min                                                    builtin function         dcl 21
push_offset                            internal static fixed bin(17,0)          initial dcl 3-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 3-78
return_offset                          internal static fixed bin(17,0)          initial dcl 3-78
stack_frame_flags                      based           structure                level 1 dcl 2-64
stack_header_overlay                   based           fixed bin(17,0)          array dcl 3-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 3-72

NAMES DECLARED BY EXPLICIT CONTEXT.
ALLDONE                         000723 constant        label                    dcl 196 ref 178
SKIP                            000610 constant        label                    dcl 169 ref 160
bad                             000152 constant        label                    dcl 75 ref 61 62 63 66
below_syserr                    000212 constant        label                    dcl 101 ref 126 194
check_sp_next                   000724 constant        entry                    internal dcl 205 ref 50 60 91 101
dump_rest                       000317 constant        label                    dcl 132 ref 103 109 110 111 112 114 115
good                            000153 constant        label                    dcl 76 ref 68
od_stack_                       000043 constant        entry                    external dcl 11
print_frame                     000322 constant        label                    dcl 134 ref 130

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1050        1072    1010        1060
Length      1324    1010        22         215      40           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
od_stack_                           202 external procedure  is an external procedure.  
check_sp_next                           internal procedure  shares stack frame of external procedure od_stack_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 fmtskip                     od_stack_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
od_stack_                000100 sp_next                     od_stack_
                         000102 sp_curr                     od_stack_
                         000104 i                           od_stack_
                         000105 frame_no                    od_stack_
                         000106 slen                        od_stack_
                         000107 fword                       od_stack_
                         000110 sword                       od_stack_
                         000111 segno                       od_stack_
                         000112 spoff                       od_stack_
                         000113 case                        od_stack_
                         000114 fsize                       od_stack_
                         000116 curptr                      od_stack_
                         000120 lastptr                     od_stack_
                         000122 plural                      od_stack_
                         000123 nskip                       od_stack_
                         000124 entinfo                     od_stack_
                         000164 retinfo                     od_stack_
                         000224 ptr_to_entry                od_stack_
                         000226 ptr_to_return               od_stack_
                         000230 subsysfrms                  od_stack_
                         000231 save_slen                   od_stack_
                         000232 save_sp_next                od_stack_
                         000234 save_sp                     od_stack_
                         000236 last_sp                     od_stack_
                         000240 subsysflag                  od_stack_
                         000242 sp                          od_stack_
                         000244 sb                          od_stack_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
od_print_                     od_print_$op_fmt_line

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000035        31 000050        37 000056        39 000060        45 000061        46 000066        48 000070
     49 000072        50 000076        51 000077        52 000102        59 000113        60 000114        61 000115
     62 000117        63 000124        64 000127        65 000133        66 000135        68 000136        69 000142
     70 000146        73 000150        75 000152        76 000153        89 000161        90 000163        91 000165
     92 000166        93 000171        94 000202        96 000204        97 000205        98 000210       100 000211
    101 000212       103 000213       105 000215       106 000217       108 000223       109 000232       110 000236
    111 000241       112 000245       114 000250       115 000257       118 000264       119 000271       120 000273
    121 000275       122 000276       123 000300       124 000302       125 000304       126 000306       129 000307
    130 000316       132 000317       134 000322       141 000330       143 000370       146 000416       148 000454
    150 000475       152 000502       153 000503       154 000507       159 000527       160 000530       162 000531
    163 000533       163 000540       164 000542       165 000571       167 000572       168 000606       169 000610
    171 000612       172 000615       173 000617       174 000621       174 000626       175 000630       177 000657
    178 000662       179 000665       180 000666       181 000667       182 000671       183 000673       188 000675
    189 000677       190 000702       192 000712       193 000714       194 000716       195 000721       196 000723
    205 000724       208 000725       210 000736       211 000741       216 000765       217 000770       218 000773
    219 000776       220 001000       221 001001       222 001004       224 001006


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
