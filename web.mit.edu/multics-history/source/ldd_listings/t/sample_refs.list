	COMPILATION LISTING OF SEGMENT sample_refs
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1743.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 sample_refs: srf: procedure;
       12 
       13 
       14 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       15 
       16 /*	sample_refs samples the contents of the PSR and TSR periodically, in order to determine which segments
       17*   a process is referencing.  Three data segments are used:
       18*   srf1 - individual samples - time of interrupt; PSR and TSR contents; re-used segment number count
       19*   srf2 - pathnames - segment pathnames; reference counts; link for re-used segment numbers
       20*   srf3 - re-used seg.no. pathnames - pathnames;reference counts; link for further re-usages
       21*   A CPU timer is established to interrupt the process every _n milliseconds.  (N.B. - SAMPLE RATES OF LESS
       22*   THAN 1000 MILLISECONDS ARE NOT GUARANTEED ACCURATE).  The interrupt handller sample_refs$ih attempts to
       23*   find the pathnames associated with the segment numbers as found in the PSR and TSR. (N.B. - THE CONTENTS OF
       24*   THE TSR ARE OFTEN INVALID). The pathnames are then saved in either the srf2 or srf3 data segment, depending
       25*   upon whether or not the segment number had been re-assigned since its last reference. The individual samples
       26*   data are stored in the srf1 data segment.
       27*   ONLY ONE INVOCATION OF sample_refs CAN RUN PER PROCESS. A SECONDARY INVOCATION WILL FORCE TERMINATION
       28*   OF THE FIRST.
       29*
       30*   0) Created by: Ross E. Klinger, November 11, 1973					*/
       31 
       32 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       33 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       34 
       35 declare 1 srf1seg based (srf1P) aligned,		/* srf1 data base */
       36         2 time_on fixed binary (71),			/* time srf turned on */
       37         2 time_off fixed binary (71),			/* time srf turned off */
       38         2 table_index fixed binary (35),		/* index of where_when table */
       39         2 frequency fixed binary (35),			/* sample frequency in milliseconds */
       40         2 high_hc fixed binary (35),			/* highest hardcore segment number */
       41         2 proc_seg_cnt fixed binary (35),		/* highest process segment number */
       42         2 where_when (srf1_max_index),			/* table of times and locations */
       43 	3 time fixed binary (71),			/* time of interrupt */
       44 	3 prcdr pointer,				/* prcdr pointer */
       45 	3 temporary pointer,			/* temporary pointer */
       46 	3 prul fixed binary (35),			/* psr segment number re-usage level */
       47 	3 trul fixed binary (35);			/* tsr segment number re-usage level */
       48 
       49 declare 1 srf2seg based (srf2P) aligned,		/* auxilliary srf data base */
       50         2 time_on fixed binary (71),			/* time srf turned on */
       51         2 high_segno fixed bin (35),			/* highest segno referenced (valid or invalid) */
       52         2 pad fixed bin (35),				/* pad */
       53         2 segment (srf2_max_index),			/* table of pathnames indexed by segment number */
       54 	3 pathname character (168),			/* segment pathname */
       55 	3 prc fixed binary (35),			/* psr reference count */
       56 	3 trc fixed binary (35),			/* tsr reference count */
       57 	3 ci fixed binary (35),			/* chain index to extension for re-used segment numbers */
       58 	3 bci fixed binary (35);			/* bound chain index -- NOT SET BY THIS PROGRAM */
       59 
       60 declare 1 srf3seg based (srf3P) aligned,		/* extension data base for re-used segment numbers */
       61         2 time_on fixed binary (71),			/* time srf turned on */
       62         2 ni fixed binary (35),			/* index to next available table entry */
       63         2 pad fixed binary (35),			/* pad area */
       64         2 extension (srf3_max_index),			/* table of pathnames of re-used segment numbers */
       65 	3 pathname character (168),			/* segment pathname */
       66 	3 prc fixed binary (35),			/* psr reference count */
       67 	3 trc fixed binary (35),			/* tsr reference count */
       68 	3 ci fixed binary (35),			/* chain index to extension for n > 1 re-usages */
       69 	3 bci fixed binary (35);			/* bound chain index -- NOT SET BY THIS PROGRAM */
       70 
       71 declare (srf1P, srf2P, srf3P) pointer internal static initial (null); /* data base pointers */
       72 declare (srf1_max_index, srf2_max_index, srf3_max_index) fixed bin internal static; /* maximum table indices */
       73 
       74 declare  arg character (arglen) based (aP) unaligned,	/* command argument */
       75          argcnt fixed binary,				/* number of arguments */
       76          arglen fixed binary,				/* length of the argument */
       77          code fixed binary (35),			/* error code */
       78         (i, j, rul) fixed binary,			/* temporary storage */
       79         (k, kx) bit (1) initial ("0"b),			/* (k,kx)nown (1) / un(k,kx)nown (0) segment switches */
       80          dirname character (168) aligned,		/* directory name */
       81          ename character (32) aligned,			/* entry name */
       82          date_time character (24),			/* date and time */
       83          t fixed binary (71),				/* temporary storage -- clock time */
       84          f fixed binary (35),				/* temporary storage -- frequency */
       85          name char (32) aligned,			/* suffixed entry name */
       86         (aP, bP, cP) pointer;				/* pointers */
       87 
       88 declare  error_table_$badopt external fixed binary (35);	/* error codes */
       89 declare  sys_info$max_seg_size external fixed binary (35);	/* system maximum segment size */
       90 
       91 declare  sample_refs$ih external entry (pointer);		/* srf interrupt handler */
       92 
       93 
       94 declare  com_err_ external entry options (variable),
       95          continue_to_signal_ external entry (fixed bin (35)),
       96          cu_$arg_count external entry (fixed binary),
       97          cu_$arg_ptr external entry (fixed binary, pointer, fixed binary, fixed binary (35)),
       98          cv_dec_check_ external entry (character (*), fixed binary (35)) returns (fixed binary (35)),
       99          clock_ external entry returns (fixed binary (71)),
      100          date_time_ external entry (fixed binary (71), char (*)),
      101          expand_path_ external entry (pointer, fixed binary, pointer, pointer, fixed binary (35)),
      102          find_condition_info_ external entry (ptr, ptr, fixed bin (35)),
      103          get_wdir_ ext entry returns (char (168) aligned),
      104          hcs_$high_low_seg_count external entry (fixed binary (35), fixed binary (35)),
      105          hcs_$make_seg external entry (char (*) aligned, char (*) aligned, char (*), fixed bin (5), ptr, fixed bin (35)),
      106          hcs_$terminate_noname external entry (pointer, fixed binary (35)),
      107          suffixed_name_$make ext entry (char (*) aligned, char (*), char (32) aligned, fixed bin (35)),
      108          timer_manager_$cpu_call external entry (fixed binary (71), bit (2), entry),
      109          timer_manager_$reset_cpu_call external entry (entry);
      110 
      111 declare  null builtin, (any_other, cleanup) condition;
      112 
      113 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      114 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      115 
      116 	on cleanup call cleaner;			/* terminate data base if error before timer starts */
      117 	srf1_max_index = divide (sys_info$max_seg_size - 8, 8, 17, 0); /* set maximum table indices */
      118 	srf2_max_index = divide (sys_info$max_seg_size - 4, 46, 17, 0);
      119 	srf3_max_index = srf2_max_index;
      120 
      121 	call cu_$arg_count (argcnt);			/* check number of arguments */
      122 	if argcnt = 0 then go to invock;		/* no -off option, check invocation */
      123 	call cu_$arg_ptr (1, aP, arglen, code);		/* get the first argument */
      124 	if aP -> arg ^= "-rs" then if aP -> arg ^= "-reset" then go to invock; /* is it the "-reset" option? */
      125 	if argcnt > 1 then call com_err_ (0, "sample_refs", "Options after a ""-reset"" are ignored."); /* yes -- are there others? */
      126 	if srf1P = null then return;			/* exit if nothing to turn off */
      127 	call off;					/* close data bases */
      128 	return;					/* exit */
      129 invock:	if srf1P ^= null then do;			/* if secondary invocation, close previous data bases */
      130 	     call off;				/* close */
      131 	     call com_err_ (0, "sample_refs", "Secondary invocation: previous data bases terminated."); /* warning */
      132 	end;
      133 	srf2P, srf3P = null;			/* null to avoid needless hcs_$terminate_noname calls */
      134 	f = 1000;					/* default frequency is 1000 milliseconds */
      135 	ename = " ";				/* set to blanks: implies default entry name */
      136 
      137 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      138 
      139 	do i = 1 to argcnt;				/* loop to examine arguments */
      140 	     call cu_$arg_ptr (i, aP, arglen, code);	/* get the argument */
      141 	     if aP -> arg ^= "-sm" then if aP -> arg ^= "-segment" then go to timeck; /* is it the "-segment" option? */
      142 	     i = i+1;				/* increment argument counter */
      143 	     call cu_$arg_ptr (i, aP, arglen, code);	/* get the segment name */
      144 	     if code ^= 0 then do;			/* is segment name missing? */
      145 		call com_err_ (0, "sample_refs", "No segment name after segment option."); /* write an error message */
      146 		return;				/* give up */
      147 	     end;
      148 	     bP = addr (dirname);			/* get pointer to directory portion of pathname */
      149 	     cP = addr (ename);			/* get pointer to entry name portion of pathname */
      150 	     call expand_path_ (aP, arglen, bP, cP, code); /* expand to an absolute pathname */
      151 	     if code ^= 0 then do;			/* was there an error? */
      152 		call com_err_ (code, "sample_refs", "^a", aP -> arg); /* write an error message */
      153 		return;
      154 	     end;
      155 	     go to continue;			/* look for another control option */
      156 timeck:	     if aP -> arg ^= "-tm" then if aP -> arg ^= "-time" then go to bad_opt; /* is it the "-time" option? */
      157 	     i = i+1;				/* must be -time option  --  increment argument counter */
      158 	     call cu_$arg_ptr (i, aP, arglen, code);	/* get the frequency */
      159 	     if code ^= 0 then do;			/* is the frequency missing? */
      160 err1:		call com_err_ (0, "sample_refs", "Missing or invalid time."); /* write an error message */
      161 		return;				/* give up */
      162 	     end;
      163 	     f = cv_dec_check_ (aP -> arg, code);	/* get the frequency */
      164 	     if code ^= 0 then go to err1;		/* check for an invalidity */
      165 	     if f ^> 0 then go to err1;		/* error if zero or negative */
      166 continue: end;
      167 
      168 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      169 
      170 	t = clock_ ();				/* get the clock time */
      171 	if ename = " " then do;			/* was -sm option specified? */
      172 	     call date_time_ (t, date_time);		/* no -- get string for unique name */
      173 	     ename = translate (date_time, "_", " ");	/* change all " " to "_" */
      174 	     dirname = get_wdir_ ();			/* put the segments in the working directory */
      175 	end;
      176 
      177 	i = index (ename, ".srf");			/* look for the suffix ".srf", ".srf1", ".srf2", etc. */
      178 	if i ^= 0 then substr (ename, i, 32 - i + 1) = " "; /* if found, best just to strip it off */
      179 
      180 	call suffixed_name_$make (ename, "srf1", name, code); /* add suffix */
      181 	if code ^= 0 then go to suffix_error;		/* was there an error? */
      182 	call hcs_$make_seg (dirname, name, "", 01011b, srf1P, code); /* make the segment */
      183 	if srf1P = null then go to make_error;		/* was there an error? */
      184 
      185 	call suffixed_name_$make (ename, "srf2", name, code); /* add suffix */
      186 	if code ^= 0 then go to suffix_error;		/* was there an error? */
      187 	call hcs_$make_seg (dirname, name, "", 01011b, srf2P, code); /* make the segment */
      188 	if srf2P = null then go to make_error;
      189 
      190 	call suffixed_name_$make (ename, "srf3", name, code); /* add suffix */
      191 	if code ^= 0 then go to suffix_error;		/* was there an error? */
      192 	call hcs_$make_seg (dirname, name, "", 01011b, srf3P, code); /* make the segment */
      193 	if srf3P = null then go to make_error;
      194 
      195 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      196 start_timer: srf1seg.time_on = t;			/* set on time in srf data base */
      197 	srf3seg.time_on = t;			/* set on time in srf3 data base */
      198 	srf2seg.time_on = t;			/* set on time in auxilliary data base */
      199 	frequency = f;				/* put frequency in data base */
      200 	table_index = 1;				/* initialize table index */
      201 	high_segno = 0;				/* initialize highest segno referenced */
      202 	ni = 1;					/* initialize extension index */
      203 	call hcs_$high_low_seg_count (proc_seg_cnt, high_hc); /* set the hardcore and process segment bounds */
      204 	call timer_manager_$cpu_call ((frequency*1000), "10"b, sample_refs$ih); /* start timer */
      205 	revert cleanup;
      206 	return;					/* normal exit */
      207 
      208 
      209 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      210 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      211 
      212 cleaner:	procedure;				/* terminates srf segments and resets invocation switch */
      213 	     if srf3P ^= null then call hcs_$terminate_noname (srf3P, code);
      214 	     if srf2P ^= null then call hcs_$terminate_noname (srf2P, code);
      215 	     if srf1P ^= null then do;
      216 		call hcs_$terminate_noname (srf1P, code);
      217 		srf1P = null;
      218 	     end;
      219 	     return;
      220 	end cleaner;
      221 
      222 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      223 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      224 
      225 suffix_error: call com_err_ (code, "sample_refs", ename);	/* write the error message */
      226 	call cleaner;				/* cleanup */
      227 	return;
      228 
      229 make_error: call com_err_ (code, "sample_refs", "^a>^a", dirname, name); /* write the error message */
      230 	call cleaner;				/* cleanup */
      231 	return;
      232 
      233 bad_opt:	if aP -> arg ^= "-rs" then if aP -> arg ^= "-reset" then go to bad_opt1; /* is it a "-reset" option? */
      234 	call com_err_ (0, "sample_refs", """-reset"" ignored: must be first and only option."); /* yes -- warn and ignore */
      235 	go to continue;
      236 bad_opt1: call com_err_ (error_table_$badopt, "sample_refs", "^a", aP -> arg); /* write an error message */
      237 	return;					/* exit */
      238 
      239 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      240 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      241 
      242 off:	procedure;				/* internal procedure to close data bases */
      243 
      244 	     call timer_manager_$reset_cpu_call (sample_refs$ih); /* turn the timer off */
      245 	     time_off = clock_ ();			/* set the off time */
      246 	     table_index = table_index - 1;		/* decrement to drop the last (invalid) entry */
      247 	     call hcs_$high_low_seg_count (proc_seg_cnt, high_hc); /* set the highest hardcore and process segment numbers */
      248 	     call cleaner;				/* terminate the data bases */
      249 	     return;				/* exit */
      250 
      251 	end off;
      252 
      253 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      254 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      255 
      256 ih:	entry (mcP);				/* srf interrupt handler */
      257 
      258 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      259 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      260 
      261 	on any_other begin;
      262 
      263 dcl 1 cond_info aligned,				/* filled in by find_condition_info_ */
  1     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  1     2*	   coded by M. Weaver 12 July 1973 */
  1     3 
  1     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  1     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  1     6 	  2 condition_name char(32) var,		/* name of condition */
  1     7 	  2 infoptr ptr,				/* ptr to software info structure */
  1     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  1     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  1    10 	  2 flags aligned,
  1    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  1    12 	    3 pad1 bit(35) unal,
  1    13 	  2 pad_word bit(36) aligned,
  1    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  1    15 	  2 pad (4) bit(36) aligned;
  1    16 
  1    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      264 
      265 
      266      call find_condition_info_ (null, addr (cond_info), code); /* determine type of fault */
      267 
      268 	     if cond_info.condition_name = "cleanup" then call off; /* handle this condition */
      269 	     else if cond_info.condition_name = "cput" then go to pass_it_on;
      270 	     else if cond_info.condition_name = "alrm" then go to pass_it_on;
      271 	     else if cond_info.condition_name = "quit" then go to pass_it_on;
      272 	     else if cond_info.condition_name = "stack" then go to pass_it_on;
      273 	     else if cond_info.condition_name = "finish" then go to pass_it_on;
      274 	     else if cond_info.condition_name = "program_interrupt" then
      275 pass_it_on:	call continue_to_signal_ (code);
      276 	     else;				/* ignore all other conditions */
      277 
      278 	end;
  2     1 /*  */
  2     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  2     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  2     4 /* Modified 07/07/76 by Morris for fault register data */
  2     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  2     6 
  2     7 
  2     8 /* words 0-15 pointer registers */
  2     9 
  2    10 dcl  mcp ptr;
  2    11 
  2    12 dcl 1 mc based (mcp) aligned,
  2    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  2    14    (2 regs,					/* registers */
  2    15       3 x (0:7) bit (18),				/* index registers */
  2    16       3 a bit (36),					/* accumulator */
  2    17       3 q bit (36),					/* q-register */
  2    18       3 e bit (8),					/* exponent */
  2    19       3 pad1 bit (28),
  2    20       3 t bit (27),					/* timer register */
  2    21       3 pad2 bit (6),
  2    22       3 ralr bit (3),				/* ring alarm register */
  2    23 
  2    24     2 scu (0:7) bit (36),
  2    25 
  2    26     2 mask bit (72),				/* mem controller mask at time of fault */
  2    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  2    28     2 errcode fixed bin (35),				/* fault handler's error code */
  2    29     2 fim_temp,
  2    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  2    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  2    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  2    33     2 fault_reg bit (36),				/* fault register */
  2    34     2 pad2 bit (1),
  2    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  2    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  2    37     2 fault_time bit (54),				/* time of fault */
  2    38 
  2    39     2 eis_info (0:7) bit (36)) unaligned;
  2    40 
  2    41 
  2    42 dcl (apx fixed bin init (0),
  2    43      abx fixed bin init (1),
  2    44      bpx fixed bin init (2),
  2    45      bbx fixed bin init (3),
  2    46      lpx fixed bin init (4),
  2    47      lbx fixed bin init (5),
  2    48      spx fixed bin init (6),
  2    49      sbx fixed bin init (7)) internal static;
  2    50 
  2    51 
  2    52 
  2    53 
  2    54 dcl  scup ptr;
  2    55 
  2    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  2    57 
  2    58 
  2    59 /*	WORD (0)		*/
  2    60 
  2    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  2    62       3 prr bit (3),				/* procedure ring register */
  2    63       3 psr bit (15),				/* procedure segment register */
  2    64       3 p bit (1),					/* procedure privileged bit */
  2    65 
  2    66     2 apu,					/* APPENDING UNIT STATUS */
  2    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  2    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  2    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  2    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  2    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  2    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  2    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  2    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  2    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  2    76       3 ptw bit (1),				/* Fetch of PTW */
  2    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  2    78       3 fap bit (1),				/* Fetch of final address paged */
  2    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  2    80       3 fabs bit (1),				/* Fetch of final address absolute */
  2    81 
  2    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  2    83 
  2    84 
  2    85 /*	WORD (1)		*/
  2    86 
  2    87     2 fd,						/* FAULT  DATA */
  2    88       3 iro bit (1),				/* illegal ring order */
  2    89       3 oeb bit (1),				/* out of execute bracket */
  2    90       3 e_off bit (1),				/* no execute */
  2    91       3 orb bit (1),				/* out of read bracket */
  2    92       3 r_off bit (1),				/* no read */
  2    93       3 owb bit (1),				/* out of write bracket */
  2    94       3 w_off bit (1),				/* no write */
  2    95       3 no_ga bit (1),				/* not a gate */
  2    96       3 ocb bit (1),				/* out of call bracket */
  2    97       3 ocall bit (1),				/* outward call */
  2    98       3 boc bit (1),				/* bad outward call */
  2    99       3 inret bit (1),				/* inward return */
  2   100       3 crt bit (1),				/* cross ring transfer */
  2   101       3 ralr bit (1),				/* ring alarm register */
  2   102       3 am_er bit (1),				/* associative memory fault */
  2   103       3 oosb bit (1),				/* out of segment bounds */
  2   104       3 paru bit (1),				/* processor parity upper */
  2   105       3 parl bit (1),				/* processor parity lower */
  2   106       3 onc_1 bit (1),				/* op not complete type 1 */
  2   107       3 onc_2 bit (1),				/* op not complete type 2 */
  2   108 
  2   109     2 port_stat,					/* PORT  STATUS */
  2   110       3 ial bit (4),				/* illegal action lines */
  2   111       3 iac bit (3),				/* illegal action channel */
  2   112       3 con_chan bit (3),				/* connect channel */
  2   113 
  2   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  2   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  2   116 
  2   117 
  2   118 /*	WORD (2)		*/
  2   119 
  2   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  2   121       3 trr bit (3),				/* temporary ring register */
  2   122       3 tsr bit (15),				/* temporary segment register */
  2   123 
  2   124     2 pad2 bit (9),
  2   125 
  2   126     2 cpu_no bit (3),				/* CPU number */
  2   127 
  2   128     2 delta bit (6),				/* tally modification DELTA */
  2   129 
  2   130 
  2   131 /*	WORD (3)		*/
  2   132 
  2   133     2 word3 bit (18),
  2   134 
  2   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  2   136       3 tsna,					/* Word 1 status */
  2   137         4 prn bit (3),				/* Word 1  PR  number */
  2   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  2   139       3 tsnb,					/* Word 2  status */
  2   140         4 prn bit (3),				/* Word 2  PR  number */
  2   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  2   142       3 tsnc,					/* Word 3  status */
  2   143         4 prn bit (3),				/* Word 3  PR  number */
  2   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  2   145 
  2   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  2   147 
  2   148 
  2   149 /* 	WORD (4)		*/
  2   150 
  2   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  2   152 
  2   153     2 ir,						/* INDICATOR  REGISTERS */
  2   154       3 zero bit (1),				/* zero indicator */
  2   155       3 neg bit (1),				/* negative indicator */
  2   156       3 carry bit (1),				/* carryry indicator */
  2   157       3 ovfl bit (1),				/* overflow indicator */
  2   158       3 eovf bit (1),				/* eponent overflow */
  2   159       3 eufl bit (1),				/* exponent underflow */
  2   160       3 oflm bit (1),				/* overflow mask */
  2   161       3 tro bit (1),				/* tally runout */
  2   162       3 par bit (1),				/* parity error */
  2   163       3 parm bit (1),				/* parity mask */
  2   164       3 bm bit (1),					/* ^bar mode */
  2   165       3 tru bit (1),				/* truncation mode */
  2   166       3 mif bit (1),				/* multi-word instruction mode */
  2   167       3 abs bit (1),				/* absolute mode */
  2   168       3 pad bit (4),
  2   169 
  2   170 
  2   171 /*	WORD (5)		*/
  2   172 
  2   173     2 ca bit (18),					/* COMPUTED  ADDRESS */
  2   174 
  2   175     2 cu,						/* CONTROL UNIT STATUS */
  2   176       3 rf bit (1),					/* on first cycle of repeat instr */
  2   177       3 rpt bit (1),				/* repeat instruction */
  2   178       3 rd bit (1),					/* repeat double instruction */
  2   179       3 rl bit (1),					/* repeat link instruciton */
  2   180       3 pot bit (1),				/* IT  modification */
  2   181       3 pon bit (1),				/* return type instruction */
  2   182       3 xde bit (1),				/* XDE from Even location */
  2   183       3 xdo bit (1),				/* XDE from Odd  location */
  2   184       3 poa bit (1),				/* operation preparation */
  2   185       3 rfi bit (1),				/* tells CPU to refetch instruction */
  2   186       3 its bit (1),				/* ITS modification */
  2   187       3 if bit (1),					/* fault occured during instruction fetch */
  2   188 
  2   189     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  2   190 
  2   191 
  2   192 /*	WORDS (6,7)	*/
  2   193 
  2   194     2 even_inst bit (36),				/* even instruction of faulting pair */
  2   195 
  2   196     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  2   197 
  2   198 
  2   199 
  2   200 
  2   201 
  2   202 
  2   203 /*	ALTERNATE   SCU  DECLARATION		*/
  2   204 
  2   205 
  2   206 dcl 1 scux based (scup) aligned,
  2   207 
  2   208    (2 pad0 bit (36),
  2   209 
  2   210     2 fd,						/* GROUP II  FAULT DATA */
  2   211       3 isn bit (1),				/* illegal segment number */
  2   212       3 ioc bit (1),				/* illegal op  code  */
  2   213       3 ia_am bit (1),				/* illegal address - modifier */
  2   214       3 isp bit (1),				/* illegal slave  procedure */
  2   215       3 ipr bit (1),				/* illegal procedure */
  2   216       3 nea bit (1),				/* non existent address */
  2   217       3 oobb bit (1),				/* out of bounds */
  2   218       3 pad bit (29),
  2   219 
  2   220     2 pad2 bit (36),
  2   221 
  2   222     2 pad3a bit (18),
  2   223 
  2   224     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  2   225       3 prn bit (3),				/* PR  number */
  2   226       3 prv bit (1),				/* PR  valid bit */
  2   227 
  2   228     2 pad3b bit (6)) unaligned,
  2   229 
  2   230     2 pad45 (0:1) bit (36),
  2   231 
  2   232     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  2   233 
  2   234 
  2   235 
  2   236 /*  END INCLUDE FILE   mc.incl.pl1 */
      279       /* include machine conditions declaration */
      280 
      281 declare (mcP, pP, tP) pointer;			/* pointers to conditions and segments */
      282 
      283 	where_when (table_index).time = clock_ ();	/* store the time of interrupt */
      284 	mcp = mcP;				/* initialize the include's pointer */
      285 	scup = addr (mc.scu);			/* ditto */
      286 	pP = pointer (baseptr ("000"b || scu.psr), scu.ilc); /* form pointer to prcdr segment */
      287 	where_when (table_index).prcdr = pP;		/* store in data base */
      288 	call fill_pathname_p (pP);			/* develope pathname in auxilliary data base */
      289 
      290 	if ni = srf3_max_index + 1 then do;		/* is the extension table full? */
      291 srf3_full:     call off;				/* close the data bases */
      292 	     call com_err_ (0, "sample_refs$ih", "srf3 data base full. Automatic reset."); /* write message */
      293 	     revert any_other;
      294 	     return;
      295 	end;
      296 
      297 	tP = pointer (baseptr ("000"b || scu.tsr), scu.ca); /* form pointer to temporary segment */
      298 	where_when (table_index).temporary = tP;	/* store in data base */
      299 	call fill_pathname_t (tP);			/* develop pathname in auxilliary data base */
      300 	if ni = srf3_max_index then go to srf3_full;	/* is extension table full? */
      301 
      302 	if table_index = 37767 then do;		/* is this the last possible place? */
      303 	     call off;				/* yes -- close the data bases */
      304 	     call com_err_ (0, "sample_refs$ih", "srf1 data base full. Automatic reset."); /* write  message */
      305 	     revert any_other;			/* stop intercepting faults */
      306 	     return;				/* exit */
      307 	end;
      308 
      309 	table_index = table_index + 1;		/* no -- increment the index */
      310 	call timer_manager_$cpu_call ((frequency*1000), "10"b, sample_refs$ih); /* start the timer again */
      311 	revert any_other;				/* stop intercepting faults */
      312 	return;					/* exit */
      313 
      314 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      315 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      316 
      317 fill_pathname_p: procedure (xP);			/* internal procedure to store pathnames -- psr reference entry */
      318 
      319 declare  xP pointer,				/* pointer to segment */
      320          temp_pathname character (168),			/* pathname temporary storage */
      321          tbit bit (1),				/* psr (0)/tsr (1) reference switch */
      322          ring0_get_$name external entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35)),
      323          hcs_$fs_get_path_name external entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35));
      324 
      325 	     tbit = "0"b;				/* psr reference */
      326 	     go to start;
      327 
      328 fill_pathname_t: entry (xP);				/* tsr reference entry */
      329 
      330 	     tbit = "1"b;				/* set switch on */
      331 start:	     i = fixed (baseno (xP));			/* set segment number */
      332 
      333 	     if i > srf2_max_index then do;		/* is the segment number beyond the srf2 table capacity? */
      334 		call com_err_ (0, "sample_refs$ih", "Reference to segment number ^d exceeds table capacity. Reference ignored.", i);
      335 		return;
      336 	     end;
      337 
      338 	     if i > high_segno then high_segno = i;	/* keep highest segno referenced up to data */
      339 	     if i <= high_hc then do;			/* is the segment in the hardcore? */
      340 		call ring0_get_$name (dirname, ename, xP, code); /* yes -- get the pathname components */
      341 
      342 		if code = 0 then do;		/* did it succeed? */
      343 		     j = index (dirname, " ");	/* yes -- find the first blank in the directory name */
      344 		     if j <= 1 then temp_pathname = ename; /* no directory name */
      345 		     else temp_pathname = substr (dirname, 1, j-1)||">"||ename; /* directory name found */
      346 		end;
      347 
      348 		else temp_pathname = "INVALID RING 0 SEGMENT NUMBER"; /* ring0_get_$name failed */
      349 	     end;
      350 
      351 	     else do;				/* segment not in hardcore */
      352 		call hcs_$fs_get_path_name (xP, dirname, j, ename, code); /* yes -- get the pathname components */
      353 		if code = 0 then temp_pathname = substr (dirname, 1, j)||">"||ename; /* form the pathname */
      354 		else temp_pathname = "INVALID NON-RING 0 SEGMENT NUMBER"; /* hcs_$fs_get_path_name failed */
      355 	     end;
      356 
      357 	     if segment (i).pathname < " " then do;	/* has this segment number been encountered? */
      358 		segment (i).pathname = temp_pathname;	/* no -- fill in the pathname */
      359 		go to set_seg_rc;			/* set reference count in segment table */
      360 	     end;
      361 
      362 	     if segment (i).ci = 0 then do;		/* segment number encountered -- is it re-used? */
      363 
      364 		if segment (i).pathname = temp_pathname then do; /* not re-used -- do the pathnames match? */
      365 set_seg_rc:	     if tbit then segment (i).trc = segment (i).trc + 1; /* match -- increment trc...or... */
      366 		     else segment (i).prc = segment (i).prc + 1; /* increment prc */
      367 		     return;			/* exit */
      368 		end;
      369 
      370 		else do;				/* no match -- build an extension entry for re-used segment number */
      371 		     rul = 1;			/* set re-usage level for an initial re-usage */
      372 		     segment (i).ci = ni;		/* set segment chain index to next available extension entry */
      373 		     go to set_ext;			/* fill in the extension */
      374 		end;
      375 	     end;
      376 
      377 	     j = segment (i).ci;			/* segment number previously re-used -- pick up initial chain index */
      378 	     do rul = 1 by 1 while (extension (j).ci ^= 0); /* find the last usage of the segment number */
      379 		j = extension (j).ci;
      380 	     end;
      381 
      382 	     if extension (j).pathname = temp_pathname then do; /* do the pathnames match? */
      383 		if tbit then extension (j).trc = extension (j).trc + 1; /* match -- increment trc...or... */
      384 		else extension (j).prc = extension (j).prc + 1; /* increment prc */
      385 		go to set_rul;			/* set re-usage level */
      386 	     end;
      387 
      388 	     rul = rul + 1;				/* no match -- increment re-usage level */
      389 	     extension (j).ci = ni;			/* set extension chain index to next available extension entry */
      390 set_ext:	     extension (ni).pathname = temp_pathname;	/* fill in pathname */
      391 	     if tbit then extension (ni).trc = 1;	/* set trc...or... */
      392 	     else extension (ni).prc = 1;		/* set prc */
      393 	     ni = ni + 1;				/* increment index to next available entry */
      394 set_rul:	     if tbit then where_when (table_index).trul = rul; /* set trul...or... */
      395 	     else where_when (table_index).prul = rul;	/* set prul */
      396 	     return;
      397 
      398 	end fill_pathname_p;
      399 
      400 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      401 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      402 
      403      end sample_refs;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1526.2  sample_refs.pl1                   >dumps>old>recomp>sample_refs.pl1
264          1    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
279          2    08/12/81  2025.8  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
aP                              000214 automatic       pointer                  dcl 74 set ref 123* 124 124 140* 141 141 143* 150*
                                                                                  152 156 156 158* 163 233 233 236
any_other                       000222 stack reference condition                dcl 111 ref 261 293 305 311
arg                                    based           char                     unaligned dcl 74 set ref 124 124 141 141 152* 156
                                                                                  156 163* 233 233 236*
argcnt                          000100 automatic       fixed bin(17,0)          dcl 74 set ref 121* 122 125 139
arglen                          000101 automatic       fixed bin(17,0)          dcl 74 set ref 123* 124 124 140* 141 141 143* 150*
                                                                                  152 152 156 156 158* 163 163 233 233 236 236
bP                              000216 automatic       pointer                  dcl 74 set ref 148* 150*
cP                              000220 automatic       pointer                  dcl 74 set ref 149* 150*
ca                        5            based           bit(18)                  level 2 packed unaligned dcl 2-56 ref 297
ci                       60            based           fixed bin(35,0)          array level 3 in structure "srf2seg" dcl 49
                                                                                  in procedure "srf" set ref 362 372* 377
ci                       60            based           fixed bin(35,0)          array level 3 in structure "srf3seg" dcl 60
                                                                                  in procedure "srf" set ref 378 379 389*
cleanup                         000230 stack reference condition                dcl 111 ref 116 205
clock_                          000042 constant        entry                    external dcl 94 ref 170 245 283
code                            000102 automatic       fixed bin(35,0)          dcl 74 set ref 123* 140* 143* 144 150* 151 152* 158*
                                                                                  159 163* 164 180* 181 182* 185* 186 187* 190* 191
                                                                                  192* 213* 214* 216* 225* 229* 266* 274* 340* 342
                                                                                  352* 353
com_err_                        000030 constant        entry                    external dcl 94 ref 125 131 145 152 160 225 229 234
                                                                                  236 292 304 334
cond_info                       000100 automatic       structure                level 1 dcl 263 set ref 266 266
condition_name            3     000100 automatic       varying char(32)         level 2 dcl 263 set ref 268 269 270 271 272 273 274
continue_to_signal_             000032 constant        entry                    external dcl 94 ref 274
cu_$arg_count                   000034 constant        entry                    external dcl 94 ref 121
cu_$arg_ptr                     000036 constant        entry                    external dcl 94 ref 123 140 143 158
cv_dec_check_                   000040 constant        entry                    external dcl 94 ref 163
date_time                       000172 automatic       char(24)                 unaligned dcl 74 set ref 172* 173
date_time_                      000044 constant        entry                    external dcl 94 ref 172
dirname                         000110 automatic       char(168)                dcl 74 set ref 148 174* 182* 187* 192* 229* 340* 343
                                                                                  345 352* 353
ename                           000162 automatic       char(32)                 dcl 74 set ref 135* 149 171 173* 177 178* 180* 185*
                                                                                  190* 225* 340* 344 345 352* 353
error_table_$badopt             000022 external static fixed bin(35,0)          dcl 88 set ref 236*
expand_path_                    000046 constant        entry                    external dcl 94 ref 150
extension                 4            based           structure                array level 2 dcl 60
f                               000202 automatic       fixed bin(35,0)          dcl 74 set ref 134* 163* 165 199
find_condition_info_            000050 constant        entry                    external dcl 94 ref 266
frequency                 5            based           fixed bin(35,0)          level 2 dcl 35 set ref 199* 204 310
get_wdir_                       000052 constant        entry                    external dcl 94 ref 174
hcs_$fs_get_path_name           000072 constant        entry                    external dcl 319 ref 352
hcs_$high_low_seg_count         000054 constant        entry                    external dcl 94 ref 203 247
hcs_$make_seg                   000056 constant        entry                    external dcl 94 ref 182 187 192
hcs_$terminate_noname           000060 constant        entry                    external dcl 94 ref 213 214 216
high_hc                   6            based           fixed bin(35,0)          level 2 dcl 35 set ref 203* 247* 339
high_segno                2            based           fixed bin(35,0)          level 2 dcl 49 set ref 201* 338 338*
i                               000103 automatic       fixed bin(17,0)          dcl 74 set ref 139* 140* 142* 142 143* 157* 157 158*
                                                                                  177* 178 178 178 331* 333 334* 338 338 339 357 358
                                                                                  362 364 365 365 366 366 372 377
ilc                       4            based           bit(18)                  level 2 packed unaligned dcl 2-56 ref 286
j                               000104 automatic       fixed bin(17,0)          dcl 74 set ref 343* 344 345 352* 353 377* 378 379*
                                                                                  379 382 383 383 384 384 389
k                               000106 automatic       bit(1)                   initial unaligned dcl 74 set ref 74*
kx                              000107 automatic       bit(1)                   initial unaligned dcl 74 set ref 74*
mc                                     based           structure                level 1 dcl 2-12
mcP                                    parameter       pointer                  dcl 281 ref 256 284
mcp                             000236 automatic       pointer                  dcl 2-10 set ref 284* 285
name                            000203 automatic       char(32)                 dcl 74 set ref 180* 182* 185* 187* 190* 192* 229*
ni                        2            based           fixed bin(35,0)          level 2 dcl 60 set ref 202* 290 300 372 389 390 391
                                                                                  392 393* 393
null                                                   builtin function         dcl 111 ref 126 129 133 183 188 193 213 214 215 217
                                                                                  266 266
pP                              000242 automatic       pointer                  dcl 281 set ref 286* 287 288*
pathname                  4            based           char(168)                array level 3 in structure "srf3seg" dcl 60
                                                                                  in procedure "srf" set ref 382 390*
pathname                  4            based           char(168)                array level 3 in structure "srf2seg" dcl 49
                                                                                  in procedure "srf" set ref 357 358* 364
ppr                                    based           structure                level 2 packed unaligned dcl 2-56
prc                      56            based           fixed bin(35,0)          array level 3 in structure "srf2seg" dcl 49
                                                                                  in procedure "srf" set ref 366* 366
prc                      56            based           fixed bin(35,0)          array level 3 in structure "srf3seg" dcl 60
                                                                                  in procedure "srf" set ref 384* 384 392*
prcdr                    12            based           pointer                  array level 3 dcl 35 set ref 287*
proc_seg_cnt              7            based           fixed bin(35,0)          level 2 dcl 35 set ref 203* 247*
prul                     16            based           fixed bin(35,0)          array level 3 dcl 35 set ref 395*
psr                       0(03)        based           bit(15)                  level 3 packed unaligned dcl 2-56 ref 286
ring0_get_$name                 000070 constant        entry                    external dcl 319 ref 340
rul                             000105 automatic       fixed bin(17,0)          dcl 74 set ref 371* 378* 388* 388 394 395
sample_refs$ih                  000026 constant        entry                    external dcl 91 ref 204 204 244 244 310 310
scu                                    based           structure                level 1 dcl 2-56 in procedure "srf"
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed unaligned
                                                                                  dcl 2-12 in procedure "srf" set ref 285
scup                            000240 automatic       pointer                  dcl 2-54 set ref 285* 286 286 297 297
segment                   4            based           structure                array level 2 dcl 49
srf1P                           000010 internal static pointer                  initial dcl 71 set ref 126 129 182* 183 196 199 200
                                                                                  203 203 204 215 216* 217* 245 246 246 247 247 283
                                                                                  283 287 287 298 298 302 309 309 310 339 394 394
                                                                                  395 395
srf1_max_index                  000016 internal static fixed bin(17,0)          dcl 72 set ref 117*
srf1seg                                based           structure                level 1 dcl 35
srf2P                           000012 internal static pointer                  initial dcl 71 set ref 133* 187* 188 198 201 214
                                                                                  214* 338 338 357 358 362 364 365 365 366 366 372
                                                                                  377
srf2_max_index                  000017 internal static fixed bin(17,0)          dcl 72 set ref 118* 119 333
srf2seg                                based           structure                level 1 dcl 49
srf3P                           000014 internal static pointer                  initial dcl 71 set ref 133* 192* 193 197 202 213
                                                                                  213* 290 300 372 378 379 382 383 383 384 384 389
                                                                                  389 390 390 391 391 392 392 393 393
srf3_max_index                  000020 internal static fixed bin(17,0)          dcl 72 set ref 119* 290 300
srf3seg                                based           structure                level 1 dcl 60
suffixed_name_$make             000062 constant        entry                    external dcl 94 ref 180 185 190
sys_info$max_seg_size           000024 external static fixed bin(35,0)          dcl 89 ref 117 118
t                               000200 automatic       fixed bin(71,0)          dcl 74 set ref 170* 172* 196 197 198
tP                              000244 automatic       pointer                  dcl 281 set ref 297* 298 299*
table_index               4            based           fixed bin(35,0)          level 2 dcl 35 set ref 200* 246* 246 283 287 298 302
                                                                                  309* 309 394 395
tbit                            000330 automatic       bit(1)                   unaligned dcl 319 set ref 325* 330* 365 383 391 394
temp_pathname                   000256 automatic       char(168)                unaligned dcl 319 set ref 344* 345* 348* 353* 354*
                                                                                  358 364 382 390
temporary                14            based           pointer                  array level 3 dcl 35 set ref 298*
time                     10            based           fixed bin(71,0)          array level 3 dcl 35 set ref 283*
time_off                  2            based           fixed bin(71,0)          level 2 dcl 35 set ref 245*
time_on                                based           fixed bin(71,0)          level 2 in structure "srf1seg" dcl 35 in procedure
                                                                                  "srf" set ref 196*
time_on                                based           fixed bin(71,0)          level 2 in structure "srf3seg" dcl 60 in procedure
                                                                                  "srf" set ref 197*
time_on                                based           fixed bin(71,0)          level 2 in structure "srf2seg" dcl 49 in procedure
                                                                                  "srf" set ref 198*
timer_manager_$cpu_call         000064 constant        entry                    external dcl 94 ref 204 310
timer_manager_$reset_cpu_call   000066 constant        entry                    external dcl 94 ref 244
tpr                       2            based           structure                level 2 packed unaligned dcl 2-56
trc                      57            based           fixed bin(35,0)          array level 3 in structure "srf3seg" dcl 60
                                                                                  in procedure "srf" set ref 383* 383 391*
trc                      57            based           fixed bin(35,0)          array level 3 in structure "srf2seg" dcl 49
                                                                                  in procedure "srf" set ref 365* 365
trul                     17            based           fixed bin(35,0)          array level 3 dcl 35 set ref 394*
tsr                       2(03)        based           bit(15)                  level 3 packed unaligned dcl 2-56 ref 297
where_when               10            based           structure                array level 2 dcl 35
xP                                     parameter       pointer                  dcl 319 set ref 317 328 331 340* 352*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abx                                    internal static fixed bin(17,0)          initial dcl 2-42
apx                                    internal static fixed bin(17,0)          initial dcl 2-42
bbx                                    internal static fixed bin(17,0)          initial dcl 2-42
bpx                                    internal static fixed bin(17,0)          initial dcl 2-42
lbx                                    internal static fixed bin(17,0)          initial dcl 2-42
lpx                                    internal static fixed bin(17,0)          initial dcl 2-42
sbx                                    internal static fixed bin(17,0)          initial dcl 2-42
scux                                   based           structure                level 1 dcl 2-206
spx                                    internal static fixed bin(17,0)          initial dcl 2-42

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_opt                         001560 constant        label                    dcl 233 ref 156
bad_opt1                        001622 constant        label                    dcl 236 ref 233
cleaner                         002242 constant        entry                    internal dcl 212 ref 116 226 230 248
continue                        001033 constant        label                    dcl 166 ref 155 235
err1                            000752 constant        label                    dcl 160 ref 164 165
fill_pathname_p                 002402 constant        entry                    internal dcl 317 ref 288
fill_pathname_t                 002406 constant        entry                    internal dcl 328 ref 299
ih                              001664 constant        entry                    external dcl 256
invock                          000452 constant        label                    dcl 129 ref 122 124
make_error                      001515 constant        label                    dcl 229 ref 183 188 193
off                             002325 constant        entry                    internal dcl 242 ref 127 130 268 291 303
pass_it_on                      001776 constant        label                    dcl 274 ref 269 270 271 272 273
sample_refs                     000267 constant        entry                    external dcl 11
set_ext                         002773 constant        label                    dcl 390 ref 373
set_rul                         003020 constant        label                    dcl 394 ref 385
set_seg_rc                      002703 constant        label                    dcl 365 ref 359
srf                             000257 constant        entry                    external dcl 11
srf3_full                       002057 constant        label                    dcl 291 set ref 300
start                           002412 constant        label                    dcl 331 ref 326
start_timer                     001407 constant        label                    dcl 196
suffix_error                    001463 constant        label                    dcl 225 ref 181 186 191
timeck                          000722 constant        label                    dcl 156 ref 141

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 148 149 266 266 285
baseno                                                 builtin function         ref 331
baseptr                                                builtin function         ref 286 297
divide                                                 builtin function         ref 117 118
fixed                                                  builtin function         ref 331
index                                                  builtin function         ref 177 343
pointer                                                builtin function         ref 286 297
substr                                                 builtin function         ref 178 345 353
translate                                              builtin function         ref 173

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3572        3666    3256        3602
Length      4166    3256        74         264     313          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
srf                                 374 external procedure  is an external procedure.  
on unit on line 116                  64 on unit               
cleaner                              70 internal procedure  is called by several nonquick procedures.  
off                                  78 internal procedure  is called by several nonquick procedures.  
on unit on line 261                 102 on unit               
fill_pathname_p                         internal procedure  shares stack frame of external procedure srf.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 srf1P                       srf
000012 srf2P                       srf
000014 srf3P                       srf
000016 srf1_max_index              srf
000017 srf2_max_index              srf
000020 srf3_max_index              srf

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
on unit on line 261      000100 cond_info                   on unit on line 261
srf                      000100 argcnt                      srf
                         000101 arglen                      srf
                         000102 code                        srf
                         000103 i                           srf
                         000104 j                           srf
                         000105 rul                         srf
                         000106 k                           srf
                         000107 kx                          srf
                         000110 dirname                     srf
                         000162 ename                       srf
                         000172 date_time                   srf
                         000200 t                           srf
                         000202 f                           srf
                         000203 name                        srf
                         000214 aP                          srf
                         000216 bP                          srf
                         000220 cP                          srf
                         000236 mcp                         srf
                         000240 scup                        srf
                         000242 pP                          srf
                         000244 tP                          srf
                         000256 temp_pathname               fill_pathname_p
                         000330 tbit                        fill_pathname_p

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              enable              shorten_stack       ext_entry           int_entry           set_cs_eis
index_cs_eis        divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      continue_to_signal_           cu_$arg_count
cu_$arg_ptr                   cv_dec_check_                 date_time_                    expand_path_
find_condition_info_          get_wdir_                     hcs_$fs_get_path_name         hcs_$high_low_seg_count
hcs_$make_seg                 hcs_$terminate_noname         ring0_get_$name               sample_refs$ih
suffixed_name_$make           timer_manager_$cpu_call       timer_manager_$reset_cpu_call

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     74 000252        11 000256       116 000275       117 000317       118 000331       119 000342       121 000343
    122 000351       123 000353       124 000372       125 000404       126 000440       127 000445       128 000451
    129 000452       130 000457       131 000463       133 000514       134 000520       135 000522       139 000525
    140 000534       141 000551       142 000563       143 000564       144 000601       145 000603       146 000634
    148 000635       149 000637       150 000641       151 000660       152 000662       153 000720       155 000721
    156 000722       157 000732       158 000733       159 000750       160 000752       161 001003       163 001004
    164 001027       165 001031       166 001033       170 001035       171 001044       172 001050       173 001065
    174 001076       177 001106       178 001115       180 001125       181 001153       182 001155       183 001214
    185 001221       186 001246       187 001250       188 001307       190 001314       191 001341       192 001343
    193 001402       196 001407       197 001411       198 001412       199 001413       200 001416       201 001420
    202 001422       203 001424       204 001434       205 001461       206 001462       225 001463       226 001510
    227 001514       229 001515       230 001553       231 001557       233 001560       234 001570       235 001621
    236 001622       237 001660       256 001661       261 001672       266 001706       268 001725       269 001740
    270 001745       271 001752       272 001757       273 001764       274 001771       278 002006       283 002007
    284 002022       285 002026       286 002030       287 002043       288 002047       290 002051       291 002057
    292 002063       293 002114       294 002115       297 002116       298 002132       299 002136       300 002140
    302 002145       303 002151       304 002155       305 002206       306 002207       309 002210       310 002214
    311 002237       312 002240       212 002241       213 002247       214 002264       215 002302       216 002307
    217 002320       219 002323       242 002324       244 002332       245 002344       246 002354       247 002364
    248 002374       249 002401       317 002402       325 002404       326 002405       328 002406       330 002410
    331 002412       333 002417       334 002422       335 002456       338 002457       339 002463       340 002466
    342 002512       343 002514       344 002525       345 002533       346 002561       348 002563       349 002566
    352 002567       353 002617       354 002650       357 002654       358 002666       359 002673       362 002674
    364 002677       365 002703       366 002714       367 002721       371 002722       372 002724       373 002730
    377 002731       378 002732       379 002743       380 002744       382 002746       383 002754       384 002763
    385 002767       388 002770       389 002771       390 002773       391 003002       392 003011       393 003014
    394 003020       395 003031       396 003037


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
