	COMPILATION LISTING OF SEGMENT cv_prt_rqti
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/17/86  1458.7 mst Mon
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  cv_prt_rqti.rd                  	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  03/17/86  1458.7 mst Mon                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
       14*   *                                                         *
       15*   * Copyright (c) 1972 by Massachusetts Institute of        *
       16*   * Technology and Honeywell Information Systems, Inc.      *
       17*   *                                                         *
       18*   *********************************************************** */
       19 
       20 /* format: style4,delnl,insnl,^ifthendo */
       21 
       22 /* format: off */
       23 
       24 /* Program to convert an ASCII file into a request info segment */
       25 
       26 /* Created:  May 1977 by E. Donner */
       27 /* Modified: June 1979 by C. Hornig to add banner_bars and banner_type: brief; */
       28 /* Modified: December 1981 by G. Palter to add "prt_control: force_ctl_char;" and to fix entry number 0001 (phx06682) from
       29*      the io_daemon error list: cv_prt_rqti prints a misleading error message when improper syntax appears in the
       30*      "message" statement (and probably other statements also) */
       31 /* Modified: November 1983 by C. Marker to add force_nsep */
       32 
       33 /* format: on */
       34 
       35 /*++
       36*
       37*BEGIN
       38*1	/ driver_attributes :	/ LEX(2)					/ driver_attr\
       39*
       40*2	/ driver_wait_time : <legal_wait_time> ;
       41*				/ [prt_rqti.driver_wait_time = wait_time] LEX(4)	/ BEGIN\
       42*3	/ driver_wait_time : <any-token> ;
       43*				/ NEXT_STMT				/ BEGIN\
       44*
       45*4	/ banner_type : standard ;	/ [is_printer = "1"b; prt_rqti.banner_type = 1] LEX(4)
       46*									/ BEGIN\
       47*5	/ banner_type : brief ;	/ [is_printer = "1"b; prt_rqti.banner_type = 2] LEX(4)
       48*									/ BEGIN\
       49*6	/ banner_type : none ;	/ [is_printer = "1"b; prt_rqti.banner_type = 0] LEX(4)
       50*									/ BEGIN\
       51*7	/ banner_type : <any-token> ;	/ LEX(2) ERROR(18) NEXT_STMT			/ BEGIN\
       52*8	/ banner_type : <any-token>	/ ERROR(4) NEXT_STMT			/ BEGIN\
       53*
       54*9	/ banner_bars : double ;	/ [is_printer = "1"b; prt_rqti.banner_bars = 0] LEX(4)
       55*									/ BEGIN\
       56*10	/ banner_bars : single ;	/ [is_printer = "1"b; prt_rqti.banner_bars = 1] LEX(4)
       57*									/ BEGIN\
       58*11	/ banner_bars : none ;	/ [is_printer = "1"b; prt_rqti.banner_bars = 2] LEX(4)
       59*									/ BEGIN\
       60*12	/ banner_bars : <any-token> ;	/ LEX(2) ERROR(14) NEXT_STMT			/ BEGIN\
       61*13	/ banner_bars : <any-token>	/ ERROR(4) NEXT_STMT			/ BEGIN\
       62*
       63*14	/ prt_control :		/ [is_printer = "1"b] LEX(2)			/ process_control_flags\
       64*
       65*15	/ message : <quoted-string> ;
       66*				/ LEX(2) [prt_rqti.opr_msg = token_value; is_printer = "1"b] LEX(2)
       67*									/ BEGIN\
       68*16	/ message : <any-token> 	/ ERROR(4) NEXT_STMT			/ BEGIN\
       69*
       70*17	/ paper_length : <legal_paper_len> ;
       71*				/ [prt_rqti.paper_length = paper_len; is_printer = "1"b] LEX(4)
       72*									/ BEGIN\
       73*18	/ paper_length : <any-token> ;
       74*				/ NEXT_STMT				/ BEGIN\
       75*
       76*19	/ paper_width : <legal_paper_wdth> ;
       77*				/ [prt_rqti.paper_width = paper_wdth; is_printer = "1"b] LEX(4)
       78*								          / BEGIN\
       79*20	/ paper_width : <any-token> ;	/ NEXT_STMT				/ BEGIN\
       80*
       81*21	/ lines_per_inch : <legal_lpi> ;
       82*				/ [prt_rqti.lines_per_inch = lpi; is_printer = "1"b] LEX(4)
       83*									/ BEGIN\
       84*22	/ lines_per_inch : <any-token> ;
       85*				/ NEXT_STMT				/ BEGIN\
       86*
       87*23	/ line ( <legal_line_no> ) :	/ [is_printer = "1"b] LEX(5)			/ process_nos\
       88*24	/ line ( <any-token> ) :	/ NEXT_STMT				/ BEGIN\
       89*
       90*25	/ end ;			/					/ end\
       91*
       92*26	/ <any-token> :		/ ERROR(1) NEXT_STMT			/ BEGIN\
       93*27	/ <any-token>		/ ERROR(4) NEXT_STMT			/ BEGIN\
       94*28	/ <no-token>		/ ERROR(2)				/ end\
       95*
       96*process_nos
       97*29	/ <legal_chn_no>		/ [substr(prt_rqti.channel_stops(line_no),chn_no,1)="1"b] LEX(1)
       98*									/ get_punct\
       99*30	/ <any-token>		/ NEXT_STMT				/ BEGIN\
      100*31	/ <no-token>		/ ERROR(2)				/ end\
      101*
      102*get_punct
      103*32	/ ,			/ LEX					/ process_nos\
      104*33	/ ;			/ LEX					/ BEGIN\
      105*34	/ <any-token>		/ ERROR(4) NEXT_STMT			/ BEGIN\
      106*35	/ <no-token>		/ ERROR(2)				/ end\
      107*
      108*end	/			/					/ RETURN\
      109*
      110*driver_attr
      111*37	/			/ [ind = 1; string (switches(0)) =""b; string (switches (1)) = ""b]
      112*									/ \
      113*
      114*driver_loop
      115*38	/ ;			/ LEX					/ assign_switches\
      116*39	/ ^			/ [ind = 1 - ind] LEX			/ \
      117*40	/ meter			/ [switches (ind).meter = "1"b] LEX		/ attpunct\
      118*41	/ auto_go			/ [switches (ind).auto_go = "1"b] LEX		/ attpunct\
      119*
      120*42	/ <any-token>		/ ERROR(15) NEXT_STMT			/ BEGIN\
      121*43	/ <no-token>		/ ERROR(2)				/ end\
      122*
      123*attpunct
      124*44	/ ,			/ [ind = 1] LEX				/ driver_loop\
      125*45	/ ;			/ LEX					/ assign_switches\
      126*
      127*46	/ <any-token>		/ ERROR(4) NEXT_STMT			/ BEGIN\
      128*47	/ <no-token>		/ ERROR(2)				/ end\
      129*
      130*assign_switches
      131*48	/			/ [string(prt_rqti.rqti_switches) = string(switches(1)) & ^string(switches(0))]
      132*									/ BEGIN\
      133*
      134*process_control_flags
      135*49	/			/ [ind = 1; string(flags(0)) = ""b; string(flags(1)) = ""b]
      136*									/ \
      137*
      138*flag_loop
      139*50	/ ;			/ LEX					/ assign_flags\
      140*
      141*51	/ ^			/ [ind = 1 - ind] LEX			/ \
      142*52	/ auto_print		/ [flags(ind).no_auto_print = "1"b] LEX		/ flagpunct\
      143*53	/ force_nep		/ [flags(ind).force_nep = "1"b] LEX		/ flagpunct\
      144*54	/ force_esc		/ [flags(ind).force_esc = "1"b] LEX		/ flagpunct\
      145*55	/ force_nsep		/ [flags(ind).force_nsep = "1"b] LEX		/ flagpunct\
      146*56	/ force_ctl_char		/ [flags(ind).force_ctl_char = "1"b] LEX	/ flagpunct\
      147*
      148*57	/ <any-token>		/ ERROR(16) NEXT_STMT			/ BEGIN\
      149*58	/ <no-token>		/ ERROR(2)				/ end\
      150*
      151*flagpunct
      152*59	/ ,			/ [ind = 1] LEX				/ flag_loop\
      153*60	/ ;			/ LEX					/ assign_flags\
      154*
      155*61	/ <any-token>		/ ERROR(4) NEXT_STMT			/ BEGIN\
      156*62	/ <no-token>		/ ERROR(2)				/ end\
      157*
      158*assign_flags
      159*63	/			/ [string(prt_rqti.prt_flags) = string(flags(1)) & ^string(flags(0))]
      160*									/ BEGIN\
      161*
      162*++*/
      163 
      164 /**/
      165 
      166 cv_prt_rqti:
      167      procedure () options (variable);
      168 
      169 /* AUTOMATIC VARIABLES */
      170 
      171 dcl  APstmt ptr;
      172 dcl  APtoken ptr;
      173 dcl  area_ptr ptr;
      174 dcl  arg_length fixed bin;
      175 dcl  arg_ptr ptr;
      176 dcl  bitcount fixed bin (24);
      177 dcl  chn_no fixed bin;
      178 dcl  code fixed bin (35);
      179 dcl  dname char (168);
      180 dcl  ename char (32);
      181 dcl  ind fixed bin;
      182 dcl  is_printer bit (1) aligned;
      183 dcl  len_ent fixed bin;
      184 dcl  len_rqti fixed bin (18);
      185 dcl  line_no fixed bin;
      186 dcl  lpi fixed bin;
      187 dcl  max_line_no fixed bin;
      188 dcl  n_chars fixed bin (21);
      189 dcl  paper_len fixed bin;
      190 dcl  paper_wdth fixed bin;
      191 dcl  rqti_name char (32);
      192 dcl  sourcep ptr;
      193 dcl  wait_time fixed bin;
      194 
      195 dcl  1 flags (0:1) aligned like prt_rqti.prt_flags;
      196 dcl  1 switches (0:1) aligned like rqti_header.rqti_switches;
      197 
      198 /* BASED VARIABLES */
      199 
      200 dcl  arg char (arg_length) based (arg_ptr);
      201 
      202 /* BUILTINS */
      203 
      204 dcl  (clock, collate, dimension, divide, length, null, rtrim, size, string, substr, unspec) builtin;
      205 
      206 /* CONDITIONS */
      207 
      208 dcl  cleanup condition;
      209 
      210 /* EXTERNAL ENTRIES */
      211 
      212 dcl  com_err_ entry options (variable);
      213 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      214 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
      215 dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
      216 dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
      217 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
      218 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      219 dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
      220 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      221 dcl  hcs_$truncate_seg entry (ptr, fixed bin (18), fixed bin (35));
      222 dcl  get_wdir_ entry returns (char (168) aligned);
      223 dcl  lex_error_ entry options (variable);
      224 dcl  lex_string_$init_lex_delims
      225 	entry (char (*), char (*), char (*), char (*), char (*), bit (*), char (*) var, char (*) var, char (*) var,
      226 	char (*) var);
      227 dcl  lex_string_$lex
      228 	entry (ptr, fixed bin (21), fixed bin, ptr, bit (*), char (*), char (*), char (*), char (*), char (*),
      229 	char (*) var, char (*) var, char (*) var, char (*) var, ptr, ptr, fixed bin (35));
      230 dcl  translator_temp_$get_segment entry (char (*), ptr, fixed bin (35));
      231 dcl  translator_temp_$release_all_segments entry (ptr, fixed bin (35));
      232 
      233 /* INTERNAL STATIC VARIABLES */
      234 
      235 dcl  BREAKS char (128) varying;
      236 dcl  IGBREAKS char (128) varying;
      237 dcl  LEXCTL char (128) varying;
      238 dcl  LEXDLM char (128) varying;
      239 dcl  first_time bit (1) aligned init ("1"b);
      240 
      241 /* CONSTANTS */
      242 
      243 dcl  me char (11) static options (constant) init ("cv_prt_rqti");
      244 
      245 /* EXTERNAL STATIC VARIABLES */
      246 
      247 dcl  error_table_$badopt ext fixed bin (35);
      248 dcl  error_table_$entlong ext fixed bin (35);
      249 dcl  error_table_$translation_failed ext fixed bin (35);
      250 
      251 /**/
      252 
  1     1 /* BEGIN INCLUDE FILE ... prt_rqti.incl.pl1 */
  1     2 /* Modified: 30 November 1981 by G. Palter to add force_ctl_char mode */
  1     3 /* Modified: November 1983 by C. Marker to add force_nsep */
  1     4 
  2     1 /* BEGIN INCLUDE FILE ..... rqti_header.incl.pl1 .....   */
  2     2 
  2     3 
  2     4 dcl 1 rqti_header aligned based,			/* header for a request type info seg */
  2     5     2 time_created fixed bin (71),			/* clock time when table was translated */
  2     6     2 header_version fixed bin,			/* version number of the header alone */
  2     7     2 type_code fixed bin,				/* 0 = header only */
  2     8 						/* 1 = printer generic type */
  2     9 						/* 2 = punch   generic type */
  2    10 						/* 3 = tape    generic type */
  2    11     2 rqti_switches,
  2    12      (3 meter bit (1),				/* meter this request type */
  2    13       3 auto_go bit (1),				/* driver should not request a go command */
  2    14       3 rqti_sw_pad bit (34)) unal,				/* room to grow */
  2    15     2 driver_wait_time fixed bin,			/* seconds to wait, before asking coord for service */
  2    16     2 header_pad (10) fixed bin;			/* leave 10 words for future generations */
  2    17 
  2    18 dcl  rqti_header_version_1 fixed bin int static options (constant) init (1);
  2    19 
  2    20 
  2    21 /* END INCLUDE FILE ..... rqti_header.incl.pl1 .... */
  1     5 
  1     6 
  1     7 dcl  prt_rqtip ptr;
  1     8 
  1     9 dcl 1 prt_rqti aligned based (prt_rqtip),
  1    10 
  1    11     2 header like rqti_header,			/* use a common header */
  1    12 
  1    13     2 version fixed bin,				/* version of the prt_rqti portion */
  1    14     2 opr_msg char (256),				/* operator message */
  1    15     2 banner_type fixed bin,				/* 0 = no banners */
  1    16 						/* 1 = normal head/tail sheets */
  1    17 						/* 2 = RESERVED (brief banners) */
  1    18     2 banner_bars fixed bin,				/* how separator bars should be printed */
  1    19     2 banner_indent fixed bin,			/* how far to indent the banner */
  1    20     2 banner_line fixed bin,				/* what line to start the banner on */
  1    21     2 prt_flags,
  1    22      (3 no_auto_print bit (1),			/* TRUE if we want commands for each request */
  1    23       3 force_nep bit (1),				/* TRUE if we set noskip regardless */
  1    24       3 force_esc bit (1),				/* TRUE if we assume escapes in text */
  1    25       3 force_ctl_char bit (1),			/* TRUE if we pass control characters regardless */
  1    26       3 force_nsep bit (1),                                 /* TRUE if inner head and tail sheets of multiple copies are to be supressed */
  1    27       3 prt_ctl_pad bit (31)) unal,
  1    28 
  1    29     2 default_bit_modes,				/* rqt defaults for dprint */
  1    30     (3 non_edited bit (1),				/* TRUE if not removing control chars */
  1    31       3 esc bit (1),				/* TRUE if slew escapes are to be processed */
  1    32       3 single bit (1),				/* TRUE if VT and FF are to be ignored */
  1    33       3 truncate bit (1),				/* TRUE if truncating lines at line length */
  1    34       3 center_top_label bit (1),			/* TRUE if centering top label */
  1    35       3 center_bottom_label bit (1),			/* TRUE if centering bottom label */
  1    36       3 no_endpage bit (1),				/* TRUE if printing over perforations (one big page) */
  1    37       3 mode_bit_pad bit (29)) unal,			/* room to grow */
  1    38     2 default_position_modes,				/* these are the length modes */
  1    39       3 indent fixed bin,				/* columns to indent from the left */
  1    40       3 line_length fixed bin,			/* print positions starting from col 1 */
  1    41       3 page_length fixed bin,			/* number of lines before auto skip to top */
  1    42       3 mode_pad (10) fixed bin,			/* more room to grow */
  1    43 
  1    44     2 rqt_pad (28) fixed bin,				/* pad to 128 words */
  1    45 
  1    46     2 lfi,
  1    47       3 paper_info,					/* physical paper info */
  1    48         4 paper_length fixed bin,			/* max lines to perf */
  1    49         4 paper_width fixed bin,			/* max print positions */
  1    50         4 lines_per_inch fixed bin,			/* normally 6 or 8 */
  1    51       3 lfi_pad (5) fixed bin,			/* pad to even */
  1    52       3 channel_stops (256) bit (16) unal;		/* channel stops for slews */
  1    53 
  1    54 dcl  prt_rqti_version_1 fixed bin int static options (constant) init (1);
  1    55 
  1    56 
  1    57 /* END INCLUDE FILE .... prt_rqti.incl.pl1 */
      253 
      254 
      255 /**/
      256 
      257 /* PROGRAM */
      258 
      259 	call cu_$arg_ptr (1, arg_ptr, arg_length, code);
      260 	if code ^= 0
      261 	then do;
      262 	     call com_err_ (code, me, "Usage: cv_prt_rqti pathname (-brief|-bf|-long|-lg");
      263 	     return;
      264 	end;
      265 
      266 	call expand_pathname_$add_suffix (arg, "rqti", dname, ename, code);
      267 	if code ^= 0
      268 	then do;
      269 error1:
      270 	     call com_err_ (code, me, arg);
      271 	     return;
      272 	end;
      273 
      274 	call cu_$arg_ptr (2, arg_ptr, arg_length, code);
      275 	if code = 0
      276 	then if (arg = "-bf") | (arg = "-brief")
      277 	     then SERROR_CONTROL = "01"b;
      278 	     else if (arg = "-lg") | (arg = "-long")
      279 	     then SERROR_CONTROL = "10"b;
      280 	     else do;
      281 		code = error_table_$badopt;
      282 		go to error1;
      283 	     end;
      284 
      285 	len_ent = length (rtrim (ename));
      286 
      287 	sourcep = null;
      288 	prt_rqtip = null;
      289 	area_ptr = null;
      290 
      291 	on cleanup call clean;
      292 
      293 	call hcs_$initiate_count (dname, ename, "", bitcount, 1b, sourcep, code);
      294 	if sourcep = null
      295 	then do;
      296 error2:
      297 	     call com_err_ (code, me, "^a>^a", dname, ename);
      298 	     return;
      299 	end;
      300 
      301 	n_chars = divide (bitcount + 8, 9, 22, 0);
      302 
      303 	dname = get_wdir_ ();
      304 
      305 	rqti_name = substr (ename, 1, len_ent - length (".rqti"));
      306 
      307 	call hcs_$make_seg (dname, rqti_name, "", 1011b, prt_rqtip, code);
      308 	if prt_rqtip = null
      309 	then do;
      310 error3:
      311 	     call com_err_ (code, me, "^a>^a", dname, rqti_name);
      312 	     call clean;
      313 	     return;
      314 	end;
      315 
      316 	call hcs_$truncate_seg (prt_rqtip, 0, code);
      317 	if code ^= 0
      318 	then go to error3;
      319 
      320 	unspec (prt_rqti) = "0"b;
      321 
      322 	prt_rqti.time_created = clock ();
      323 	prt_rqti.header_version = rqti_header_version_1;
      324 	prt_rqti.driver_wait_time = 30;
      325 
      326 	prt_rqti.version = prt_rqti_version_1;
      327 	prt_rqti.opr_msg = "";
      328 	prt_rqti.banner_type = 1;
      329 	prt_rqti.banner_bars = 0;
      330 	prt_rqti.banner_line = 1;
      331 	prt_rqti.paper_length = 66;
      332 	prt_rqti.paper_width = 136;
      333 	prt_rqti.lines_per_inch = 6;
      334 	prt_rqti.no_auto_print = "1"b;
      335 
      336 	max_line_no = 0;
      337 
      338 	if first_time				/* only needs to be done once/process */
      339 	then do;
      340 	     BREAKS = substr (collate (), 1, 8) || substr (collate (), 10, 24) || ":,()^";
      341 	     IGBREAKS = substr (collate (), 1, 8) || substr (collate (), 10, 24);
      342 	     call lex_string_$init_lex_delims ("""", """", "/*", "*/", ";", "10"b, BREAKS, IGBREAKS, LEXDLM, LEXCTL);
      343 	     first_time = "0"b;
      344 	end;
      345 
      346 	call translator_temp_$get_segment (me, area_ptr, code);
      347 	if area_ptr = null
      348 	then do;
      349 	     call com_err_ (code, me, "Making temporary segment in process directory.");
      350 	     call clean;
      351 	     return;
      352 	end;
      353 
      354 	call lex_string_$lex (sourcep, n_chars, 0, area_ptr, "1000"b, """", """", "/*", "*/", ";", BREAKS, IGBREAKS,
      355 	     LEXDLM, LEXCTL, APstmt, APtoken, code);
      356 	if code ^= 0
      357 	then do;
      358 	     call com_err_ (code, me, ename);
      359 	     call clean;
      360 	     return;
      361 	end;
      362 
      363 	Pthis_token = APtoken;
      364 	call SEMANTIC_ANALYSIS ();
      365 
      366 	if is_printer = "1"b
      367 	then do;
      368 
      369 	     prt_rqti.type_code = 1;
      370 	     prt_rqti.no_auto_print = ^prt_rqti.no_auto_print;
      371 
      372 	     if (SERROR_PRINTED (10) = "0"b) & (max_line_no > prt_rqti.paper_length)
      373 	     then call semant_error (9, max_line_no, prt_rqti.paper_length);
      374 
      375 	     if (SERROR_PRINTED (18) = "0"b) & (prt_rqti.banner_type = 1)
      376 	     then do;
      377 
      378 		if (SERROR_PRINTED (11) = "0"b) & (prt_rqti.paper_width < 10)
      379 		then call semant_error (5, 0, 0);
      380 
      381 		if (SERROR_PRINTED (10) = "0"b) & (SERROR_PRINTED (12) = "0"b)
      382 		     & (prt_rqti.paper_length < (24 + prt_rqti.lines_per_inch))
      383 		then call semant_error (6, (24 + prt_rqti.lines_per_inch), prt_rqti.lines_per_inch);
      384 
      385 	     end;
      386 	end;
      387 
      388 	if MERROR_SEVERITY > 1
      389 	then do;
      390 	     call com_err_ (error_table_$translation_failed, me, ename);
      391 	     call hcs_$delentry_seg (prt_rqtip, code);
      392 	     prt_rqtip = null;
      393 	end;
      394 	else do;
      395 	     if prt_rqti.type_code = 0
      396 	     then do;
      397 		len_rqti = size (rqti_header);
      398 		call hcs_$truncate_seg (prt_rqtip, len_rqti, code);
      399 	     end;
      400 	     else len_rqti = size (prt_rqti);
      401 	     bitcount = 36 * len_rqti;
      402 	     call hcs_$set_bc_seg (prt_rqtip, bitcount, code);
      403 	     if code ^= 0
      404 	     then call com_err_ (code, me, "Unable to set bitcount on ^a>^a to ^d", dname, rqti_name, bitcount);
      405 	end;
      406 
      407 	call clean;				/* terminate input & output segments */
      408 	return;
      409 
      410 /* clean up procedure */
      411 
      412 clean:
      413      procedure;
      414 
      415 	if sourcep ^= null
      416 	then call hcs_$terminate_noname (sourcep, code);
      417 
      418 	if prt_rqtip ^= null
      419 	then call hcs_$terminate_noname (prt_rqtip, code);
      420 
      421 	if area_ptr ^= null
      422 	then call translator_temp_$release_all_segments (area_ptr, code);
      423 
      424      end clean;
      425 
      426 /**/
      427 legal_paper_len:
      428      proc returns (bit (1) aligned);
      429 
      430 	paper_len = cv_dec_check_ (token_value, code);
      431 	if code ^= 0
      432 	then do;
      433 	     call statement_error (10, token_value);
      434 	     return ("0"b);
      435 	end;
      436 	if (paper_len < 10) | (paper_len > 127)
      437 	then do;
      438 	     call statement_error (10, token_value);
      439 	     return ("0"b);
      440 	end;
      441 	return ("1"b);
      442 
      443      end legal_paper_len;
      444 
      445 
      446 
      447 legal_paper_wdth:
      448      proc returns (bit (1) aligned);
      449 
      450 	paper_wdth = cv_dec_check_ (token_value, code);
      451 	if code ^= 0
      452 	then do;
      453 	     call statement_error (11, token_value);
      454 	     return ("0"b);
      455 	end;
      456 	if (paper_wdth < 1) | (paper_wdth > 200)
      457 	then do;
      458 	     call statement_error (11, token_value);
      459 	     return ("0"b);
      460 	end;
      461 
      462 	if (paper_wdth > 136)
      463 	then call statement_error (7, token_value);
      464 	return ("1"b);
      465 
      466      end legal_paper_wdth;
      467 
      468 
      469 
      470 legal_lpi:
      471      proc returns (bit (1) aligned);
      472 
      473 	lpi = cv_dec_check_ (token_value, code);
      474 	if code ^= 0
      475 	then do;
      476 	     call statement_error (12, token_value);
      477 	     return ("0"b);
      478 	end;
      479 
      480 	if (lpi = 6) | (lpi = 8)
      481 	then return ("1"b);
      482 
      483 	call statement_error (12, token_value);
      484 	return ("0"b);
      485 
      486      end legal_lpi;
      487 
      488 legal_line_no:
      489      proc returns (bit (1) aligned);
      490 
      491 	line_no = cv_dec_check_ (token_value, code);
      492 	if code ^= 0
      493 	then do;
      494 	     call statement_error (13, token_value);
      495 	     return ("0"b);
      496 	end;
      497 	if (line_no < 1) | (line_no > 127)
      498 	then do;
      499 	     call statement_error (13, token_value);
      500 	     return ("0"b);
      501 	end;
      502 	if line_no > max_line_no
      503 	then max_line_no = line_no;
      504 
      505 	return ("1"b);
      506 
      507      end legal_line_no;
      508 
      509 
      510 
      511 legal_chn_no:
      512      proc returns (bit (1) aligned);
      513 
      514 	chn_no = cv_dec_check_ (token_value, code);
      515 	if code ^= 0
      516 	then do;
      517 	     call statement_error (3, token_value);
      518 	     return ("0"b);
      519 	end;
      520 	if (chn_no < 1) | (chn_no > 16)
      521 	then do;
      522 	     call statement_error (3, token_value);
      523 	     return ("0"b);
      524 	end;
      525 	return ("1"b);
      526 
      527      end legal_chn_no;
      528 
      529 legal_wait_time:
      530      proc returns (bit (1) aligned);
      531 
      532 	wait_time = cv_dec_check_ (token_value, code);
      533 	if code ^= 0
      534 	then do;
      535 	     call statement_error (17, token_value);
      536 	     return ("0"b);
      537 	end;
      538 	if (wait_time < 30) | (wait_time > 300)
      539 	then do;
      540 	     call statement_error (17, token_value);
      541 	     return ("0"b);
      542 	end;
      543 	return ("1"b);
      544 
      545      end legal_wait_time;
      546 
      547 semant_error:
      548      proc (error_num, parm1, parm2);
      549 
      550 dcl  error_num fixed bin;
      551 dcl  parm1 fixed bin;
      552 dcl  parm2 fixed bin;
      553 
      554 	call lex_error_ (error_num, SERROR_PRINTED (error_num), (error_control_table.severity (error_num)),
      555 	     MERROR_SEVERITY, null, null, SERROR_CONTROL, (error_control_table.message (error_num)),
      556 	     (error_control_table.brief_message (error_num)), parm1, parm2);
      557 
      558      end semant_error;
      559 
      560 
      561 
      562 statement_error:
      563      proc (error_num, string1);
      564 
      565 dcl  error_num fixed bin;
      566 dcl  string1 char (*);
      567 dcl  stmt_ptr ptr;
      568 dcl  token_ptr ptr;
      569 
      570 	stmt_ptr = token.Pstmt;
      571 	token_ptr = Pthis_token;
      572 
      573 	call lex_error_ (error_num, SERROR_PRINTED (error_num), (error_control_table.severity (error_num)),
      574 	     MERROR_SEVERITY, stmt_ptr, token_ptr, SERROR_CONTROL, (error_control_table.message (error_num)),
      575 	     (error_control_table.brief_message (error_num)), string1);
      576 
      577      end statement_error;				/*						*/
      578 
      579 /* ERROR MESSAGES */
      580 
      581 dcl  1 error_control_table (18) aligned static options (constant),
      582        2 severity fixed bin unal init (/* 1 - 4 */ (4) 3,	/* 5 - 7 */
      583 	  (3) 1,					/* 8 - 18 */
      584 	  (11) 3),
      585        2 Soutput_stmt bit (1) unal init (/* 1 */ "1"b,	/* 2 */
      586 	  "0"b,					/* 3 - 4 */
      587 	  (2) (1)"1"b,				/* 5 - 6 */
      588 	  (2) (1)"0"b,				/* 7 - 18 */
      589 	  (12) (1)"1"b),
      590        2 message char (100) var init (/* 1 */ "Illegal keyword ""^a"".",
      591 						/* 2 */
      592 	  "Premature end of source segment encountered. Check for missing end statement.",
      593 						/* 3 */
      594 	  "Illegal channel number ""^a"".",		/* 4 */
      595 	  "Syntax error in ""^a"" statement.",		/* 5 */
      596 	  "Paper width should be at least 10 when using standard banners.",
      597 						/* 6 */
      598 	  "Paper length must be at least ""^d"" at ""^d"" lines per inch when using standard banners.",
      599 						/* 7 */
      600 	  "Paper width ""^a"" greater than standard printer platen of 136.",
      601 						/* 8 */
      602 	  "Unused",				/* 9 */
      603 	  "Channel stop specified for line ""^d"" which is greater than paper length ""^d"".",
      604 						/* 10 */
      605 	  "Illegal paper length ""^a"".",		/* 11 */
      606 	  "Illegal paper width ""^a"".",		/* 12 */
      607 	  "Illegal lines per inch ""^a"".",		/* 13 */
      608 	  "Illegal line number ""^a"".",		/* 14 */
      609 	  "Illegal banner bars specifier ""^a"".",	/* 15 */
      610 	  "Illegal driver attribute ""^a"".",		/* 16 */
      611 	  "Illegal control attribute ""^a"".",		/* 17 */
      612 	  "Illegal wait_time ""^a"".",		/* 18 */
      613 	  "Illegal banner type ""^a""."),
      614        2 brief_message char (20) var init (/* 1 */ "^a",	/* 2 */
      615 	  "Premature EOF.",				/* 3 - 4 */
      616 	  (2) (1)"^a",				/* 5 */
      617 	  "",					/* 6 */
      618 	  "",					/* 7 */
      619 	  "",					/* 8 */
      620 	  "",					/* 9 */
      621 	  "^d ^d",				/* 10 - 18 */
      622 	  (9) (1)"^a");
      623 
      624 
      625      dcl	TRACING			bit(1) aligned int static init("0"b);
      626 
      627 
  3     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     4 	/*							*/
  3     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  3     6 	/*							*/
  3     7 	/*      This include segment is used by compilers generated by the	*/
  3     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  3     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  3    10 	/* compares a chain of input tokens with token requirements		*/
  3    11 	/* specified in reductions.  This include segment declares the 	*/
  3    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  3    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  3    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  3    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  3    16 	/*							*/
  3    17 	/* S__t_a_t_u_s							*/
  3    18 	/*							*/
  3    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  3    20 	/*							*/
  3    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3    22 
  3    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  3    24 
  4     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  4     2 	
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     4 	/*							*/
  4     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  4     6 	/*							*/
  4     7 	/*      This include segment defines the structure of the token	*/
  4     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  4     9 	/* by the lex_string_ program.				*/
  4    10 	/*							*/
  4    11 	/* Status:						*/
  4    12 	/*							*/
  4    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  4    14 	/*							*/
  4    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4    16 	
  4    17 	
  4    18 	
  4    19 	
  4    20      dcl	
  4    21 	1 comment			aligned based (Pcomment),
  4    22 						/* descriptor for a comment.			*/
  4    23 	  2 group1		unaligned,
  4    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  4    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  4    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  4    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  4    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  4    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  4    30 	  2 group2		unaligned,
  4    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  4    32 	    3 S,					/* switches:				*/
  4    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  4    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  4    35 	      4 pad		bit(16),
  4    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  4    37 						/* body of comment.				*/
  4    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  4    39 	
  4    40      dcl	
  4    41 	1 stmt			aligned based (Pstmt),
  4    42 						/* descriptor for a statement.		*/
  4    43 	  2 group1		unaligned,
  4    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  4    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  4    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  4    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  4    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  4    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  4    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  4    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  4    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  4    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  4    54 	  2 group2		unaligned,
  4    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  4    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  4    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  4    58 						/* (the number includes this stmt.)		*/
  4    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  4    60 	    3 S,					/* switches:				*/
  4    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  4    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  4    63 	      4 pad		bit(34),
  4    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  4    65 						/* text of the statement.			*/
  4    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  4    67 	
  4    68      dcl	
  4    69 	1 token			aligned based (Ptoken),
  4    70 						/* descriptor for a token.			*/
  4    71 	  2 group1		unaligned,
  4    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  4    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  4    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  4    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  4    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  4    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  4    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  4    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  4    80 	  2 group2		unaligned,
  4    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  4    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  4    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  4    84 	    3 S,					/* switches:				*/
  4    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  4    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  4    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  4    88 						/* string (as doubled quotes on input.)		*/
  4    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  4    90 						/* string has been lexed into a token.		*/
  4    91 	      4 pad2		bit(32),
  4    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  4    93 						/* value of the token.			*/
  4    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  4    95 
  4    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  3    25 
  3    26 
  3    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3    28 
  3    29 
  3    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  3    31 						/* semantics of the tokens in the input list.	*/
  3    32 
  3    33      dcl						/*	automatic variables			*/
  3    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  3    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  3    36 						/* compared to.				*/
  3    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  3    38 						/* compared to.				*/
  3    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  3    40 						/* with reduction tokens are being compared to.	*/
  3    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  3    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  3    43 	CODE			fixed bin(35),	/* an error code.				*/
  3    44 	I			fixed bin,	/* a do-group index.			*/
  3    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  3    46 						/* number character string.			*/
  3    47 
  3    48      dcl						/*	based variables			*/
  3    49 	1 RED			aligned based (PRED),
  3    50 						/* descriptor for reduction tokens are being 	*/
  3    51 						/* compared to.				*/
  3    52 	  2 TOKEN_REQD		unaligned,
  3    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  3    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  3    55 						/* with this reduction.			*/
  3    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  3    57 						/* a token requirement descriptor.		*/
  3    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  3    59 						/*  -1 = relative token requirement function;	*/
  3    60 						/*       TYPE = index of the particular token	*/
  3    61 						/*	      function in the token_fcn array.	*/
  3    62 						/*   0 = built-in token requirement function;	*/
  3    63 						/*       TYPE = as defined below.		*/
  3    64 						/*  >0 = absolute token requirement:		*/
  3    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  3    66 						/*       TYPE = length(TOKEN_REQD);		*/
  3    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  3    68 						/*   1 = compile test to see if input token 	*/
  3    69 						/*       chain is exhausted (<no-token>).	*/
  3    70 						/*   2 = compile test for any token value	*/
  3    71 						/*       (<any-token>).			*/
  3    72 						/*   3 = compile test for a PL/I identifier	*/
  3    73 						/*       (<name>) of 32 or fewer characters.	*/
  3    74 						/*   4 = compile test for token which is a	*/
  3    75 						/*       <decimal-integer>.			*/
  3    76 						/*   5 = compile test for token which is a single	*/
  3    77 						/*       backspace character (<BS>).		*/
  3    78 						/*   6 = compile test for a token which is a	*/
  3    79 						/*       <quoted-string>.			*/
  3    80 
  3    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  3    82 						/* overlay for an absolute token requirement	*/
  3    83 						/* descriptor.				*/
  3    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  3    85 						/* absolute token string assoc w/ descriptor.	*/
  3    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  3    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  3    88 						/* absolute token string which token is reqd	*/
  3    89 						/* to match in order for tokens which are	*/
  3    90 						/* "current" on the list to match the reduction.	*/
  3    91 
  3    92      dcl						/*	builtin functions			*/
  3    93          (addr, max, null, search, substr, verify)
  3    94 				builtin;
  3    95 
  3    96      dcl						/*	entries				*/
  3    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  3    98 
  3    99      dcl						/*	static variables			*/
  3   100 	BACKSPACE			char(1) aligned int static init ("");
  3   101 
  3   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
      628 
      629 
      630      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
      631 
      632 
      633      dcl	1 REDUCTION (63)		unaligned based (addr (REDUCTIONS)),
      634 						/* object reductions.			*/
      635 	  2 TOKEN_REQD,
      636 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
      637 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
      638 
      639 	REDUCTIONS  (126)		fixed bin(17) unaligned internal static options(constant) initial (
      640 	         1,     2,	/*     1/  driver_attributes :                                                  */
      641 	         3,     6,	/*     2/  driver_wait_time : <legal_wait_time> ;                               */
      642 	         7,    10,	/*     3/  driver_wait_time : <any-token> ;                                     */
      643 	        11,    14,	/*     4/  banner_type : standard ;                                             */
      644 	        15,    18,	/*     5/  banner_type : brief ;                                                */
      645 	        19,    22,	/*     6/  banner_type : none ;                                                 */
      646 	        23,    26,	/*     7/  banner_type : <any-token> ;                                          */
      647 	        23,    25,	/*     8/  banner_type : <any-token>                                            */
      648 	        27,    30,	/*     9/  banner_bars : double ;                                               */
      649 	        31,    34,	/*    10/  banner_bars : single ;                                               */
      650 	        35,    38,	/*    11/  banner_bars : none ;                                                 */
      651 	        39,    42,	/*    12/  banner_bars : <any-token> ;                                          */
      652 	        39,    41,	/*    13/  banner_bars : <any-token>                                            */
      653 	        43,    44,	/*    14/  prt_control :                                                        */
      654 	        45,    48,	/*    15/  message : <quoted-string> ;                                          */
      655 	        49,    51,	/*    16/  message : <any-token>                                                */
      656 	        52,    55,	/*    17/  paper_length : <legal_paper_len> ;                                   */
      657 	        56,    59,	/*    18/  paper_length : <any-token> ;                                         */
      658 	        60,    63,	/*    19/  paper_width : <legal_paper_wdth> ;                                   */
      659 	        64,    67,	/*    20/  paper_width : <any-token> ;                                          */
      660 	        68,    71,	/*    21/  lines_per_inch : <legal_lpi> ;                                       */
      661 	        72,    75,	/*    22/  lines_per_inch : <any-token> ;                                       */
      662 	        76,    80,	/*    23/  line ( <legal_line_no> ) :                                           */
      663 	        81,    85,	/*    24/  line ( <any-token> ) :                                               */
      664 	        86,    87,	/*    25/  end ;                                                                */
      665 	        88,    89,	/*    26/  <any-token> :                                                        */
      666 	         9,     9,	/*    27/  <any-token>                                                          */
      667 	        90,    90,	/*    28/  <no-token>                                                           */
      668 	        91,    91,	/*    29/  <legal_chn_no>                                                       */
      669 	         9,     9,	/*    30/  <any-token>                                                          */
      670 	        90,    90,	/*    31/  <no-token>                                                           */
      671 	        92,    92,	/*    32/  ,                                                                    */
      672 	         6,     6,	/*    33/  ;                                                                    */
      673 	         9,     9,	/*    34/  <any-token>                                                          */
      674 	        90,    90,	/*    35/  <no-token>                                                           */
      675 	        93,    92,	/*    36/                                                                       */
      676 	        93,    92,	/*    37/                                                                       */
      677 	         6,     6,	/*    38/  ;                                                                    */
      678 	        93,    93,	/*    39/  ^                                                                    */
      679 	        94,    94,	/*    40/  meter                                                                */
      680 	        95,    95,	/*    41/  auto_go                                                              */
      681 	         9,     9,	/*    42/  <any-token>                                                          */
      682 	        90,    90,	/*    43/  <no-token>                                                           */
      683 	        92,    92,	/*    44/  ,                                                                    */
      684 	         6,     6,	/*    45/  ;                                                                    */
      685 	         9,     9,	/*    46/  <any-token>                                                          */
      686 	        90,    90,	/*    47/  <no-token>                                                           */
      687 	        96,    95,	/*    48/                                                                       */
      688 	        96,    95,	/*    49/                                                                       */
      689 	         6,     6,	/*    50/  ;                                                                    */
      690 	        93,    93,	/*    51/  ^                                                                    */
      691 	        96,    96,	/*    52/  auto_print                                                           */
      692 	        97,    97,	/*    53/  force_nep                                                            */
      693 	        98,    98,	/*    54/  force_esc                                                            */
      694 	        99,    99,	/*    55/  force_nsep                                                           */
      695 	       100,   100,	/*    56/  force_ctl_char                                                       */
      696 	         9,     9,	/*    57/  <any-token>                                                          */
      697 	        90,    90,	/*    58/  <no-token>                                                           */
      698 	        92,    92,	/*    59/  ,                                                                    */
      699 	         6,     6,	/*    60/  ;                                                                    */
      700 	         9,     9,	/*    61/  <any-token>                                                          */
      701 	        90,    90,	/*    62/  <no-token>                                                           */
      702 	       101,   100);	/*    63/                                                                       */
      703 
      704      dcl	1 TOKEN_REQUIREMENT (100)	unaligned based (addr (TOKEN_REQUIREMENTS)),
      705 						/* object token requirements.			*/
      706 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
      707 						/*  -1 = relative token requirement function;	*/
      708 						/*       TYPE = index of the particular token	*/
      709 						/*	      function in the token_fcn array.	*/
      710 						/*   0 = built-in token requirement function;	*/
      711 						/*       TYPE = as defined below.		*/
      712 						/*  >0 = absolute token requirement:		*/
      713 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
      714 						/*       TYPE = length(TOKEN_REQD);		*/
      715 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
      716 						/* function:				*/
      717 						/*   1 = compile test to see if input token 	*/
      718 						/*       chain is exhausted (<no-token>).	*/
      719 						/*   2 = compile test for any token value	*/
      720 						/*       (<any-token>).			*/
      721 						/*   3 = compile test for a PL/I identifier	*/
      722 						/*       (<name>) of 32 or fewer characters.	*/
      723 						/*   4 = compile test for token which is a	*/
      724 						/*       <decimal-integer>.			*/
      725 						/*   5 = compile test for token which is a single	*/
      726 						/*       backspace character (<BS>).		*/
      727 						/*   6 = compile test for a token which is a	*/
      728 						/*       <quoted-string>.			*/
      729 
      730 	TOKEN_REQUIREMENTS  (200)	fixed bin(17) unaligned internal static options(constant) initial (
      731 	         1,   17,      18,    1,      19,   16,      18,    1,      -1,    1,      35,    1,      19,   16,   
      732 	        18,    1,       0,    2,      35,    1,      36,   11,      18,    1,      47,    8,      35,    1,   
      733 	        36,   11,      18,    1,      55,    5,      35,    1,      36,   11,      18,    1,      60,    4,   
      734 	        35,    1,      36,   11,      18,    1,       0,    2,      35,    1,      64,   11,      18,    1,   
      735 	        75,    6,      35,    1,      64,   11,      18,    1,      81,    6,      35,    1,      64,   11,   
      736 	        18,    1,      60,    4,      35,    1,      64,   11,      18,    1,       0,    2,      35,    1,   
      737 	        87,   11,      18,    1,      98,    7,      18,    1,       0,    6,      35,    1,      98,    7,   
      738 	        18,    1,       0,    2,     105,   12,      18,    1,      -1,    2,      35,    1,     105,   12,   
      739 	        18,    1,       0,    2,      35,    1,     117,   11,      18,    1,      -1,    3,      35,    1,   
      740 	       117,   11,      18,    1,       0,    2,      35,    1,     128,   14,      18,    1,      -1,    4,   
      741 	        35,    1,     128,   14,      18,    1,       0,    2,      35,    1,     128,    4,     142,    1,   
      742 	        -1,    5,     143,    1,      18,    1,     128,    4,     142,    1,       0,    2,     143,    1,   
      743 	        18,    1,     144,    3,      35,    1,       0,    2,      18,    1,       0,    1,      -1,    6,   
      744 	       147,    1,     148,    1,     149,    5,     154,    7,     161,   10,     171,    9,     180,    9,   
      745 	       189,   10,     199,   14);
      746 
      747 
      748      dcl	TOKEN_STRINGS		char(212) aligned based (addr (TOKEN_STRING_ARRAYS)),
      749 						/* object token values.			*/
      750 	TOKEN_STRING_ARRAYS (3)	char(100) aligned internal static options(constant) initial (
      751 	     "driver_attributes:driver_wait_time;banner_typestandardbriefnonebanner_barsdoublesingleprt_controlmes",
      752 	     "sagepaper_lengthpaper_widthlines_per_inch()end,^meterauto_goauto_printforce_nepforce_escforce_nsepfo",
      753 	     "rce_ctl_char");
      754 
      755 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  5     6*     old history comments:
  5     7*      0) Created: April, 1974 by G. C. Dixon
  5     8*      1) Modified: Feb, 1975  by G. C. Dixon
  5     9*         a) support for Version 2.0 of reduction_compiler.
  5    10*      2) Modified: Feb, 1981  by G. C. Dixon
  5    11*         a) support for Version  2.2 of reduction_compiler
  5    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  5    13*                        reductions command.
  5    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  5    15*     install(86-03-17,MR12.0-1032):
  5    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  5    17*     implemented to avoid references through a null pointer.  The two
  5    18*     accepted uses are:
  5    19*     
  5    20*        / <no-token>               / ... / ... \
  5    21*                    A
  5    22*                    |
  5    23*           Pthis_token (points to top of push down stack)
  5    24*     
  5    25*     which checks to see if the push down stack is totally exhausted (ie,
  5    26*     Ptoken = null); and:
  5    27*     
  5    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  5    29*                           A
  5    30*                           |
  5    31*                 Pthis_token (points to top of push down stack)
  5    32*     
  5    33*     which checks to see whether SPECN is topmost on the push down stack
  5    34*     AND is the final token in the input list.
  5    35*                                                   END HISTORY COMMENTS */
  5    36 
  5    37 
  5    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    39 	/*									*/
  5    40 	/* NAME:  rdc_end_.incl.pl1							*/
  5    41 	/*									*/
  5    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  5    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  5    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  5    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  5    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  5    47 	/*									*/
  5    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    49 
  5    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  5    51 						/*   options(constant) because it is never set.	*/
  5    52 	NRED = 1;
  5    53 	go to RD_TEST_REDUCTION;
  5    54 
  5    55 RD_NEXT_REDUCTION:
  5    56 	NRED = NRED + 1;
  5    57 
  5    58 RD_TEST_REDUCTION:
  5    59 	PRED = addr(REDUCTION(NRED));
  5    60 	Ptoken = Pthis_token;
  5    61 
  5    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  5    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  5    64 	     if Ptoken = null then do;
  5    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  5    66 		     if TOKEN_REQD.TYPE = 1 then
  5    67 			go to RD_TEST_TOKEN(1);
  5    68 		go to RD_NEXT_REDUCTION;
  5    69 		end;
  5    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  5    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  5    72 
  5    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  5    74 						/* In push-down-language, there are 2 		*/
  5    75 						/*   interpretations of <no-token>.		*/
  5    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  5    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  5    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  5    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  5    80 			   RED.TOKEN_REQD.IFIRST = I &
  5    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  5    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  5    83 						/*  and is SPECN the final input token?"	*/
  5    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  5    85 						/* down language mode for <no-token>.		*/
  5    86 		else if Ptoken = null then
  5    87 		     go to RD_MATCH_NO_TOKEN;
  5    88 		go to RD_NEXT_REDUCTION;
  5    89 
  5    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  5    91 
  5    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  5    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  5    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  5    95 		     > 0 then
  5    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  5    97 			= 0 then
  5    98 			     go to RD_MATCH;
  5    99 		go to RD_NEXT_REDUCTION;
  5   100 
  5   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  5   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  5   103 		     go to RD_MATCH;
  5   104 		if token.S.quoted_string then
  5   105 		     go to RD_NEXT_REDUCTION;
  5   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  5   107 		if CODE = 0 then do;
  5   108 		     token.Nvalue = NUMBER;
  5   109 		     go to RD_MATCH;
  5   110 		     end;
  5   111 		go to RD_NEXT_REDUCTION;
  5   112 
  5   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  5   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  5   115 			go to RD_MATCH;
  5   116 		go to RD_NEXT_REDUCTION;
  5   117 
  5   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  5   119 		     go to RD_MATCH;
  5   120 		go to RD_NEXT_REDUCTION;
  5   121 		end;
  5   122 
  5   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  5   124 		if token.S.quoted_string then
  5   125 		     go to RD_NEXT_REDUCTION;
  5   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  5   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  5   128 		if token_value = TOKEN_REQD_VALUE then
  5   129 		     go to RD_MATCH;
  5   130 		go to RD_NEXT_REDUCTION;
  5   131 		end;
  5   132 
  5   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      755 
      756 
      757 	     else do;				/* relative syntax function.			*/
      758 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
      759 
      760 RD_TOKEN_FCN(1):	STOKEN_FCN = legal_wait_time();
      761 		go to RD_TEST_RESULT;
      762 RD_TOKEN_FCN(2):	STOKEN_FCN = legal_paper_len();
      763 		go to RD_TEST_RESULT;
      764 RD_TOKEN_FCN(3):	STOKEN_FCN = legal_paper_wdth();
      765 		go to RD_TEST_RESULT;
      766 RD_TOKEN_FCN(4):	STOKEN_FCN = legal_lpi();
      767 		go to RD_TEST_RESULT;
      768 RD_TOKEN_FCN(5):	STOKEN_FCN = legal_line_no();
      769 		go to RD_TEST_RESULT;
      770 RD_TOKEN_FCN(6):	STOKEN_FCN = legal_chn_no();
      771 		go to RD_TEST_RESULT;
      772 
      773 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
      774 		else go to RD_NEXT_REDUCTION;
      775 		end;
      776 
      777 RD_MATCH:      Ptoken = token.Pnext;
      778 RD_MATCH_NO_TOKEN:
      779 	     end;
      780 	Ptoken = Pthis_token;
      781 	go to RD_ACTION(NRED);
      782 
      783 
      784 RD_ACTION(1):					/* /					*/
      785 	call 					     LEX ( 2 );
      786 	NRED = 37;
      787 	go to RD_TEST_REDUCTION;			/* / driver_attr \                     		*/
      788 
      789 RD_ACTION(2):					/* /					*/
      790 						     prt_rqti.driver_wait_time = wait_time;
      791 	call 					     LEX ( 4 );
      792 	NRED = 1;
      793 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      794 
      795 RD_ACTION(3):					/* /					*/
      796 	call					     NEXT_STMT();
      797 	NRED = 1;
      798 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      799 
      800 RD_ACTION(4):					/* /					*/
      801 						     is_printer = "1"b;
      802 						     prt_rqti.banner_type = 1;
      803 	call 					     LEX ( 4 );
      804 	NRED = 1;
      805 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      806 
      807 RD_ACTION(5):					/* /					*/
      808 						     is_printer = "1"b;
      809 						     prt_rqti.banner_type = 2;
      810 	call 					     LEX ( 4 );
      811 	NRED = 1;
      812 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      813 
      814 RD_ACTION(6):					/* /					*/
      815 						     is_printer = "1"b;
      816 						     prt_rqti.banner_type = 0;
      817 	call 					     LEX ( 4 );
      818 	NRED = 1;
      819 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      820 
      821 RD_ACTION(7):					/* /					*/
      822 	call 					     LEX ( 2 );
      823 	call 					     ERROR ( 18 );
      824 	call					     NEXT_STMT();
      825 	NRED = 1;
      826 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      827 
      828 RD_ACTION(8):					/* /					*/
      829 	call 					     ERROR ( 4 );
      830 	call					     NEXT_STMT();
      831 	NRED = 1;
      832 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      833 
      834 RD_ACTION(9):					/* /					*/
      835 						     is_printer = "1"b;
      836 						     prt_rqti.banner_bars = 0;
      837 	call 					     LEX ( 4 );
      838 	NRED = 1;
      839 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      840 
      841 RD_ACTION(10):					/* /					*/
      842 						     is_printer = "1"b;
      843 						     prt_rqti.banner_bars = 1;
      844 	call 					     LEX ( 4 );
      845 	NRED = 1;
      846 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      847 
      848 RD_ACTION(11):					/* /					*/
      849 						     is_printer = "1"b;
      850 						     prt_rqti.banner_bars = 2;
      851 	call 					     LEX ( 4 );
      852 	NRED = 1;
      853 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      854 
      855 RD_ACTION(12):					/* /					*/
      856 	call 					     LEX ( 2 );
      857 	call 					     ERROR ( 14 );
      858 	call					     NEXT_STMT();
      859 	NRED = 1;
      860 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      861 
      862 RD_ACTION(13):					/* /					*/
      863 	call 					     ERROR ( 4 );
      864 	call					     NEXT_STMT();
      865 	NRED = 1;
      866 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      867 
      868 RD_ACTION(14):					/* /					*/
      869 						     is_printer = "1"b;
      870 	call 					     LEX ( 2 );
      871 	NRED = 49;
      872 	go to RD_TEST_REDUCTION;			/* / process_control_flags \           		*/
      873 
      874 RD_ACTION(15):					/* /					*/
      875 	call 					     LEX ( 2 );
      876 						     prt_rqti.opr_msg = token_value;
      877 						     is_printer = "1"b;
      878 	call 					     LEX ( 2 );
      879 	NRED = 1;
      880 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      881 
      882 RD_ACTION(16):					/* /					*/
      883 	call 					     ERROR ( 4 );
      884 	call					     NEXT_STMT();
      885 	NRED = 1;
      886 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      887 
      888 RD_ACTION(17):					/* /					*/
      889 						     prt_rqti.paper_length = paper_len;
      890 						     is_printer = "1"b;
      891 	call 					     LEX ( 4 );
      892 	NRED = 1;
      893 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      894 
      895 RD_ACTION(18):					/* /					*/
      896 	call					     NEXT_STMT();
      897 	NRED = 1;
      898 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      899 
      900 RD_ACTION(19):					/* /					*/
      901 						     prt_rqti.paper_width = paper_wdth;
      902 						     is_printer = "1"b;
      903 	call 					     LEX ( 4 );
      904 	NRED = 1;
      905 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      906 
      907 RD_ACTION(20):					/* /					*/
      908 	call					     NEXT_STMT();
      909 	NRED = 1;
      910 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      911 
      912 RD_ACTION(21):					/* /					*/
      913 						     prt_rqti.lines_per_inch = lpi;
      914 						     is_printer = "1"b;
      915 	call 					     LEX ( 4 );
      916 	NRED = 1;
      917 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      918 
      919 RD_ACTION(22):					/* /					*/
      920 	call					     NEXT_STMT();
      921 	NRED = 1;
      922 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      923 
      924 RD_ACTION(23):					/* /					*/
      925 						     is_printer = "1"b;
      926 	call 					     LEX ( 5 );
      927 	NRED = 29;
      928 	go to RD_TEST_REDUCTION;			/* / process_nos \                     		*/
      929 
      930 RD_ACTION(24):					/* /					*/
      931 	call					     NEXT_STMT();
      932 	NRED = 1;
      933 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      934 
      935 RD_ACTION(25):					/* /					*/
      936 	NRED = 36;
      937 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
      938 
      939 RD_ACTION(26):					/* /					*/
      940 	call 					     ERROR ( 1 );
      941 	call					     NEXT_STMT();
      942 	NRED = 1;
      943 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      944 
      945 RD_ACTION(27):					/* /					*/
      946 	call 					     ERROR ( 4 );
      947 	call					     NEXT_STMT();
      948 	NRED = 1;
      949 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      950 
      951 RD_ACTION(28):					/* /					*/
      952 	call 					     ERROR ( 2 );
      953 	NRED = 36;
      954 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
      955 
      956 RD_ACTION(29):					/* /					*/
      957 						     substr ( prt_rqti.channel_stops ( line_no ), chn_no, 1 ) = "1"b;
      958 	call 					     LEX ( 1 );
      959 	NRED = 32;
      960 	go to RD_TEST_REDUCTION;			/* / get_punct \                       		*/
      961 
      962 RD_ACTION(30):					/* /					*/
      963 	call					     NEXT_STMT();
      964 	NRED = 1;
      965 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      966 
      967 RD_ACTION(31):					/* /					*/
      968 	call 					     ERROR ( 2 );
      969 	NRED = 36;
      970 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
      971 
      972 RD_ACTION(32):					/* /					*/
      973 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      974 	NRED = 29;
      975 	go to RD_TEST_REDUCTION;			/* / process_nos \                     		*/
      976 
      977 RD_ACTION(33):					/* /					*/
      978 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
      979 	NRED = 1;
      980 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      981 
      982 RD_ACTION(34):					/* /					*/
      983 	call 					     ERROR ( 4 );
      984 	call					     NEXT_STMT();
      985 	NRED = 1;
      986 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      987 
      988 RD_ACTION(35):					/* /					*/
      989 	call 					     ERROR ( 2 );
      990 	NRED = 36;
      991 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
      992 
      993 RD_ACTION(36):					/* /					*/
      994 	return;					/* / RETURN	\			*/
      995 
      996 RD_ACTION(37):					/* /					*/
      997 						     ind = 1;
      998 						     string ( switches ( 0 ) ) = ""b;
      999 						     string ( switches ( 1 ) ) = ""b;
     1000 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     1001 
     1002 RD_ACTION(38):					/* /					*/
     1003 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1004 	NRED = 48;
     1005 	go to RD_TEST_REDUCTION;			/* / assign_switches \                 		*/
     1006 
     1007 RD_ACTION(39):					/* /					*/
     1008 						     ind = 1 -ind;
     1009 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1010 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     1011 
     1012 RD_ACTION(40):					/* /					*/
     1013 						     switches ( ind ) .meter = "1"b;
     1014 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1015 	NRED = 44;
     1016 	go to RD_TEST_REDUCTION;			/* / attpunct \                        		*/
     1017 
     1018 RD_ACTION(41):					/* /					*/
     1019 						     switches ( ind ) .auto_go = "1"b;
     1020 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1021 	NRED = 44;
     1022 	go to RD_TEST_REDUCTION;			/* / attpunct \                        		*/
     1023 
     1024 RD_ACTION(42):					/* /					*/
     1025 	call 					     ERROR ( 15 );
     1026 	call					     NEXT_STMT();
     1027 	NRED = 1;
     1028 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
     1029 
     1030 RD_ACTION(43):					/* /					*/
     1031 	call 					     ERROR ( 2 );
     1032 	NRED = 36;
     1033 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
     1034 
     1035 RD_ACTION(44):					/* /					*/
     1036 						     ind = 1;
     1037 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1038 	NRED = 38;
     1039 	go to RD_TEST_REDUCTION;			/* / driver_loop \                     		*/
     1040 
     1041 RD_ACTION(45):					/* /					*/
     1042 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1043 	NRED = 48;
     1044 	go to RD_TEST_REDUCTION;			/* / assign_switches \                 		*/
     1045 
     1046 RD_ACTION(46):					/* /					*/
     1047 	call 					     ERROR ( 4 );
     1048 	call					     NEXT_STMT();
     1049 	NRED = 1;
     1050 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
     1051 
     1052 RD_ACTION(47):					/* /					*/
     1053 	call 					     ERROR ( 2 );
     1054 	NRED = 36;
     1055 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
     1056 
     1057 RD_ACTION(48):					/* /					*/
     1058 						     string ( prt_rqti.rqti_switches ) = string ( switches ( 1 ) ) & ^ string ( switches ( 0 ) );
     1059 	NRED = 1;
     1060 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
     1061 
     1062 RD_ACTION(49):					/* /					*/
     1063 						     ind = 1;
     1064 						     string ( flags ( 0 ) ) = ""b;
     1065 						     string ( flags ( 1 ) ) = ""b;
     1066 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     1067 
     1068 RD_ACTION(50):					/* /					*/
     1069 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1070 	NRED = 63;
     1071 	go to RD_TEST_REDUCTION;			/* / assign_flags \                    		*/
     1072 
     1073 RD_ACTION(51):					/* /					*/
     1074 						     ind = 1 -ind;
     1075 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1076 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     1077 
     1078 RD_ACTION(52):					/* /					*/
     1079 						     flags ( ind ) .no_auto_print = "1"b;
     1080 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1081 	NRED = 59;
     1082 	go to RD_TEST_REDUCTION;			/* / flagpunct \                       		*/
     1083 
     1084 RD_ACTION(53):					/* /					*/
     1085 						     flags ( ind ) .force_nep = "1"b;
     1086 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1087 	NRED = 59;
     1088 	go to RD_TEST_REDUCTION;			/* / flagpunct \                       		*/
     1089 
     1090 RD_ACTION(54):					/* /					*/
     1091 						     flags ( ind ) .force_esc = "1"b;
     1092 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1093 	NRED = 59;
     1094 	go to RD_TEST_REDUCTION;			/* / flagpunct \                       		*/
     1095 
     1096 RD_ACTION(55):					/* /					*/
     1097 						     flags ( ind ) .force_nsep = "1"b;
     1098 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1099 	NRED = 59;
     1100 	go to RD_TEST_REDUCTION;			/* / flagpunct \                       		*/
     1101 
     1102 RD_ACTION(56):					/* /					*/
     1103 						     flags ( ind ) .force_ctl_char = "1"b;
     1104 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1105 	NRED = 59;
     1106 	go to RD_TEST_REDUCTION;			/* / flagpunct \                       		*/
     1107 
     1108 RD_ACTION(57):					/* /					*/
     1109 	call 					     ERROR ( 16 );
     1110 	call					     NEXT_STMT();
     1111 	NRED = 1;
     1112 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
     1113 
     1114 RD_ACTION(58):					/* /					*/
     1115 	call 					     ERROR ( 2 );
     1116 	NRED = 36;
     1117 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
     1118 
     1119 RD_ACTION(59):					/* /					*/
     1120 						     ind = 1;
     1121 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1122 	NRED = 50;
     1123 	go to RD_TEST_REDUCTION;			/* / flag_loop \                       		*/
     1124 
     1125 RD_ACTION(60):					/* /					*/
     1126 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1127 	NRED = 63;
     1128 	go to RD_TEST_REDUCTION;			/* / assign_flags \                    		*/
     1129 
     1130 RD_ACTION(61):					/* /					*/
     1131 	call 					     ERROR ( 4 );
     1132 	call					     NEXT_STMT();
     1133 	NRED = 1;
     1134 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
     1135 
     1136 RD_ACTION(62):					/* /					*/
     1137 	call 					     ERROR ( 2 );
     1138 	NRED = 36;
     1139 	go to RD_TEST_REDUCTION;			/* / end \                             		*/
     1140 
     1141 RD_ACTION(63):					/* /					*/
     1142 						     string ( prt_rqti.prt_flags ) = string ( flags ( 1 ) ) & ^ string ( flags ( 0 ) );
     1143 	NRED = 1;
     1144 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
     1145 
     1146 
     1147 	end SEMANTIC_ANALYSIS;
     1148 
     1149 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1150 
     1151      dcl	SPDL			bit(1) aligned init ("0"b);
     1152 						/* off: This compiler parses a non-PUSH DOWN	*/
     1153 						/*      LANGUAGE.				*/
     1154 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 	/*									*/
  6     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  6     6 	/*									*/
  6     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  6     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  6     9 	/* "current" token, Pthis_token.						*/
  6    10 	/*									*/
  6    11 	/* E__n_t_r_y:  LEX								*/
  6    12 	/*									*/
  6    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  6    14 	/* _n is its positive (or negative) input argument.				*/
  6    15 	/*									*/
  6    16 	/* U__s_a_g_e									*/
  6    17 	/*									*/
  6    18 	/*      call LEX(n);							*/
  6    19 	/*									*/
  6    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  6    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  6    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  6    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  6    24 	/*									*/
  6    25 	/* S__t_a_t_u_s									*/
  6    26 	/*									*/
  6    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  6    28 	/*									*/
  6    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    30 
  6    31 LEX:	procedure (n);
  6    32 
  6    33      dcl	n			fixed bin,
  6    34 	i			fixed bin;
  6    35 
  6    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  6    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  6    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  6    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  6    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  6    41 		end;
  6    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  6    43 						/*   running off end of token list.		*/
  6    44 	     end;
  6    45 	else					/* new "current" token precedes present one.	*/
  6    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  6    47 		Ptoken = token.Plast;
  6    48 		end;
  6    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  6    50 
  6    51 	end LEX;
  6    52 
  6    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1154 
     1155 
     1156 		/* START OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3      dcl	MERROR_SEVERITY		fixed bin init (0),	/* Severity of highest-severity error.		*/
  7     4 	SERROR_CONTROL		bit(2) init ("00"b),/* Global switches control error message format.	*/
  7     5 	SERROR_PRINTED (dimension (error_control_table,1))
  7     6 				bit(1) unaligned init ((dimension (error_control_table,1))(1)"0"b),
  7     7 						/* Array bit is on if corresponding error message	*/
  7     8 						/* in error_control_table has already been printed*/
  7     9 	MIN_PRINT_SEVERITY		fixed bin init (0), /* Mimimum severity message that will be printed	*/
  7    10 	PRINT_SEVERITY_CONTROL	bit(2) init ("11"b);/* Action if severity < MIN_PRINT_SEVERITY	*/
  7    11 
  7    12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    13 	/*									*/
  7    14 	/* N__a_m_e:  rdc_error_.incl.pl1							*/
  7    15 	/*									*/
  7    16 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  7    17 	/* It defines a procedure which the compilers can use to print error messages.  	*/
  7    18 	/*									*/
  7    19 	/* E__n_t_r_y:  ERROR								*/
  7    20 	/*									*/
  7    21 	/*      Given an error number, this procedure prints a corresponding error message.	*/
  7    22 	/* The message is stored in a compiler-defined error_control_table, along with an integer	*/
  7    23 	/* which specifies the severity level of the error, and a switch which specifies whether	*/
  7    24 	/* the source statement in which the error occurred (if any) should be printed after the	*/
  7    25 	/* error message.  The printing of the error message may be supressed for all messages	*/
  7    26 	/* having a severity less than a specified (MIN_PRINT_SEVERITY) value.  The ERROR	*/
  7    27 	/*  procedure calls the lex_error_ subroutine to perform the formatting and printing of	*/
  7    28 	/*  the error message.							*/
  7    29 	/*									*/
  7    30 	/* U__s_a_g_e									*/
  7    31 	/*									*/
  7    32 	/*      call ERROR (error_number);						*/
  7    33 	/*									*/
  7    34 	/* 1) error_number	is the index of one of the structures in the error_control_table	*/
  7    35 	/*		which defines the error message to be printed.			*/
  7    36 	/*									*/
  7    37 	/* N__o_t_e_s									*/
  7    38 	/*									*/
  7    39 	/*      The format of the error_control_table is shown below.			*/
  7    40 	/*									*/
  7    41 	/*   dcl	1 error_control_table (2)	aligned internal static,			*/
  7    42 	/*	  2 severity		fixed bin(17) unaligned init (2,3),		*/
  7    43 	/*	  2 Soutput_stmt		bit(1) unaligned initial ("0"b,"1"b),		*/
  7    44 	/*	  2 message		char(252) varying initial (			*/
  7    45 	/*		"The reduction source segment does not contain any reductions.",	*/
  7    46 	/*		"Reduction label  '^a'  is invalid."),				*/
  7    47 	/*	  2 brief_message		char(100) varying initial (			*/
  7    48 	/*		"", "'^a'");						*/
  7    49 	/*									*/
  7    50 	/* error_control_table is an array of structures, with one array element per error.	*/
  7    51 	/* Each structure contains: a severity level for the error; a switch which specifies	*/
  7    52 	/* whether the source statement being processed should be output after the error message;	*/
  7    53 	/* the long form of the error message text;  and the brief form of the error message text.*/
  7    54 	/* The dimension of the error_control_table array of structures, and the lengths of	*/
  7    55 	/* message (long message) and brief_message (brief message), are compiler-defined.	*/
  7    56 	/* structures and the lengths of the message and brief_message are compiler-defined.	*/
  7    57 	/* The only requirement is that the messages be 256 characters or less in length.	*/
  7    58 	/* (Remember that the longest character string which can be used in an initial attribute	*/
  7    59 	/* is 254 characters in length.)						*/
  7    60 	/*									*/
  7    61 	/*      The severity number causes the error message to be preceded by a herald which	*/
  7    62 	/* includes one of the following prefixes:					*/
  7    63 	/*									*/
  7    64 	/*       _s_e_v  _p_r_e_f_i_x 		  _e_x_p_l_a_n_a_t_i_o_n				*/
  7    65 	/*	0 = COMMENT		- this is a comment.			*/
  7    66 	/*	1 = WARNING		- a possible error has been detected.  The	*/
  7    67 	/*				  compiler will still generate an object segment.	*/
  7    68 	/*	2 = ERROR			- a probable error has been detected.  The	*/
  7    69 	/*				  compiler will still generate an object segment.	*/
  7    70 	/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
  7    71 	/*				  that no object segment will be generated.	*/
  7    72 	/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
  7    73 	/*				  the compiler or translator.  No object segment	*/
  7    74 	/*				  will be generated.			*/
  7    75 	/*									*/
  7    76 	/* Full error messages are of the form:						*/
  7    77 	/*									*/
  7    78 	/*	_p_r_e_f_i_x _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n OF LINE _m		*/
  7    79 	/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
  7    80 	/*	SOURCE:								*/
  7    81 	/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
  7    82 	/*									*/
  7    83 	/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
  7    84 	/* If the source statement has been printed in a previous error message, it is omitted.	*/
  7    85 	/*									*/
  7    86 	/*      The reduction compiler declares a bit string, SERROR_CONTROL, which controls the	*/
  7    87 	/* text of an error message.  The compiler may set this bit string, as shown below.	*/
  7    88 	/*									*/
  7    89 	/*   SERROR_CONTROL		_m_e_a_n_i_n_g						*/
  7    90 	/*	"00"b		the first time a particular error occurs, the long message	*/
  7    91 	/*			is printed; the brief message is used in subsequent	*/
  7    92 	/*			occurrences of that error.				*/
  7    93 	/*        "10"b or "11"b	the long error message is always used.			*/
  7    94 	/*	"01"b		the brief error message is always used.			*/
  7    95 	/* The initial value of SERROR_CONTROL is "00"b.					*/
  7    96 	/*									*/
  7    97 	/*      The reduction_compiler creates a declaration for SERROR_PRINTED, an array	*/
  7    98 	/* of switches (one per error).  The switch corresponding to a particular error is	*/
  7    99 	/* turned on whenever the error message is printed.  This allows lex_error_ to detect	*/
  7   100 	/* subsequent occurrences of that same error.					*/
  7   101 	/*									*/
  7   102 	/*      The reduction_compiler creates MERROR_SEVERITY, a fixed bin(17) integer		*/
  7   103 	/* in which the severity of the highest-severity error encountered is maintained.	*/
  7   104 	/* The compiler may reference this integer.					*/
  7   105 	/*									*/
  7   106 	/*      The reduction_compiler creates MIN_PRINT_SEVERITY, a fixed bin (17) integer	*/
  7   107 	/* which controls the printing of error messages by the ERROR procedure.		*/
  7   108 	/* Errors having a severity less than MIN_PRINT_SEVERITY will not cause lex_error_ to be	*/
  7   109 	/* and no error will be printed.  The behaviour of the ERROR procedure for such errors	*/
  7   110 	/* is controlled by the value of PRINT_SEVERITY_CONTROL, described below.		*/
  7   111 	/* The compiler may set the value of MIN_PRINT_SEVERITY; its initial value is 0.	*/
  7   112 
  7   113 	/*									*/
  7   114 	/*      The reduction_compiler declares a bit string, PRINT_SEVERITY_CONTROL, which 	*/
  7   115 	/* controls the updating of MERROR_SEVERITY and SERROR_PRINTED when the severity of an	*/
  7   116 	/* error is less than MIN_PRINT_SEVERITY.  In such cases, the lex_error_ procedure is not	*/
  7   117 	/* invoked, and the ERROR procedure must update these values as though lex_error_ were	*/
  7   118 	/* called.  The compiler may set this bit string, as shown below.			*/
  7   119 	/*									*/
  7   120 	/* PRINT_SEVERITY_CONTROL	_m_e_a_n_i_n_g						*/
  7   121 	/*	"00"b		update neither SERROR_PRINTED nor MERROR_SEVERITY.	*/
  7   122 	/*	"01"b		update SERROR_PRINTED to reflect the error.		*/
  7   123 	/*	"10"b		update MERROR_SEVERITY to reflect the error severity.	*/
  7   124 	/*	"11"b		update SERROR_PRINTED and MERROR_SEVERITY appropriately.	*/
  7   125 	/*The initial value of PRINT_SEVERITY_CONTROL is "11"b.				*/
  7   126 	/*									*/
  7   127 	/*      The ERROR procedure is simple to use, but it does limit the flexibility of the	*/
  7   128 	/* error message.  A compiler action routine can output more flexible error messages	*/
  7   129 	/* by calling lex_error_ directly.  See lex_error_ documentation for more details.	*/
  7   130 	/*									*/
  7   131 	/* S__t_a_t_u_s									*/
  7   132 	/*									*/
  7   133 	/* 0) Created:  April, 1974 by G. C. Dixon					*/
  7   134 	/* 1) Modified: April, 1982 by E. N. Kittlitz.  Added MIN_PRINT_SEVERITY, 		*/
  7   135 	/*		PRINT_SEVERITY_CONTROL.					*/
  7   136 	/*									*/
  7   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7   138 
  7   139 ERROR:	procedure (Nerror);
  7   140 
  7   141      dcl	Nerror			fixed bin;	/* Number of the error which was detected. (In)	*/
  7   142 
  7   143      dcl	Pstmt			ptr,
  7   144 	1 erring_token		aligned based (Perring_token) like token,
  7   145 	Perring_token		ptr,
  7   146 	erring_token_value		char(erring_token.Lvalue) based (erring_token.Pvalue);
  7   147 
  7   148      dcl 	(max, null)		builtin;
  7   149 
  7   150      dcl	lex_error_		entry options (variable);
  7   151 
  7   152 
  7   153 	if error_control_table.severity(Nerror) < MIN_PRINT_SEVERITY then do; /* don't print		*/
  7   154 	     if PRINT_SEVERITY_CONTROL & "1"b then	/* update MERROR_SEVERITY			*/
  7   155 		MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table.severity(Nerror));
  7   156 	     if PRINT_SEVERITY_CONTROL & "01"b then	/* update SERROR_PRINTED			*/
  7   157 		SERROR_PRINTED(Nerror) = "1"b;
  7   158 	     return;
  7   159 	end;
  7   160 	Perring_token = Pthis_token;			/* address the current erring_token.		*/
  7   161 	if error_control_table.Soutput_stmt(Nerror) then
  7   162 	     if Perring_token = null then
  7   163 		Pstmt = null;
  7   164 	     else
  7   165 		Pstmt = erring_token.Pstmt;		/* address the statement descriptor.		*/
  7   166 	else
  7   167 	     Pstmt = null;
  7   168 	if Perring_token = null then
  7   169 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  7   170 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  7   171 		(error_control_table.brief_message(Nerror)));
  7   172 	else
  7   173 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  7   174 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  7   175 		(error_control_table.brief_message(Nerror)), erring_token_value, erring_token_value, erring_token_value);
  7   176 
  7   177 	end ERROR;
  7   178 
  7   179 	/* END OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1156 
     1157 
     1158 		/* START OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     4 	/*							*/
  8     5 	/* N__a_m_e:  rdc_next_stmt_.incl.pl1				*/
  8     6 	/*							*/
  8     7 	/*      This include segment is used by compilers generated by the	*/
  8     8 	/* reduction_compiler.  It includes a procedure which shifts the	*/
  8     9 	/* compilation process to the next source statement.		*/
  8    10 	/*							*/
  8    11 	/* S__t_a_t_u_s							*/
  8    12 	/*							*/
  8    13 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  8    14 	/*							*/
  8    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8    16 
  8    17 
  8    18 NEXT_STMT:	procedure;			/* invoked to begin parsing the next statement of	*/
  8    19 						/* the input tokens.			*/
  8    20 
  8    21      dcl	null			builtin,
  8    22 	Ssearching		bit(1) aligned;
  8    23 
  8    24 	Ptoken = Pthis_token;			/* make sure these pointers are the same.	*/
  8    25 	Pstmt = token.Pstmt;			/* address "current" statement's descriptor.	*/
  8    26 	Ssearching = "1"b;				/* start scanning forward for next statement.	*/
  8    27 	do while (Ssearching & token.Pnext ^= null);
  8    28 	     Ptoken = token.Pnext;
  8    29 	     if token.Pstmt = Pstmt then;
  8    30 	     else Ssearching = "0"b;
  8    31 	     end;
  8    32 	if token.Pstmt = Pstmt then			/* if there is no next statement, and		*/
  8    33 	     if SPDL then				/*   in PUSH DOWN LANGUAGE mode, can't run off	*/
  8    34 		Ptoken = Ptoken;			/*   end of input list.			*/
  8    35 	     else Ptoken, Pthis_token = null;		/*   otherwise, input list exhausted.		*/
  8    36 	else Pthis_token = Ptoken;			/* normally, next statement exists and Ptoken	*/
  8    37 						/*   points to its 1st _n_o_n-__d_e_l_e_t_e_d token.	*/
  8    38 
  8    39 	end NEXT_STMT;
  8    40 
  8    41 	/* END OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
     1158 
     1159 
     1160 	end cv_prt_rqti;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/17/86  1458.7  cv_prt_rqti.pl1                   >spec>install>1032>cv_prt_rqti.pl1
253          1    07/27/84  2039.1  prt_rqti.incl.pl1                 >ldd>include>prt_rqti.incl.pl1
1-5          2    02/23/78  1629.0  rqti_header.incl.pl1              >ldd>include>rqti_header.incl.pl1
628          3    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
3-25         4    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
755          5    03/17/86  1404.9  rdc_end_.incl.pl1                 >spec>install>1032>rdc_end_.incl.pl1
1154         6    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
1156         7    08/15/83  1511.7  rdc_error_.incl.pl1               >ldd>include>rdc_error_.incl.pl1
1158         8    04/18/75  1242.4  rdc_next_stmt_.incl.pl1           >ldd>include>rdc_next_stmt_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APstmt                          000100 automatic       pointer                  dcl 171 set ref 354*
APtoken                         000102 automatic       pointer                  dcl 172 set ref 354* 363
BACKSPACE                       007250 constant        char(1)                  initial dcl 3-99 ref 5-113
BREAKS                          000240 automatic       varying char(128)        dcl 235 set ref 340* 342* 354*
CODE                            000577 automatic       fixed bin(35,0)          dcl 3-33 set ref 5-106* 5-107
DIRECTION                       000602 automatic       fixed bin(17,0)          initial dcl 630 set ref 5-62 630*
FORM                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 3-48 ref 5-65 5-70
                                                                                  5-123
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  unaligned dcl 3-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 5-126
I                               000600 automatic       fixed bin(17,0)          dcl 3-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  5-62* 5-63 5-79*
IFIRST                                 based           fixed bin(17,0)          level 3 packed unaligned dcl 3-48 ref 5-62 5-73 5-79
                                                                                  5-79
IGBREAKS                        000301 automatic       varying char(128)        dcl 236 set ref 341* 342* 354*
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 3-48 ref 5-62 5-73 5-79
L                         0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 3-48 ref 5-127
LEXCTL                          000342 automatic       varying char(128)        dcl 237 set ref 342* 354*
LEXDLM                          000403 automatic       varying char(128)        dcl 238 set ref 342* 354*
LTOKEN_REQD_VALUE               000566 automatic       fixed bin(18,0)          dcl 3-33 set ref 5-127* 5-128
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "token" dcl 4-68 in procedure
                                                                                  "cv_prt_rqti" ref 430 430 433 433 438 438 450 450
                                                                                  453 453 458 458 462 462 473 473 476 476 483 483
                                                                                  491 491 494 494 499 499 514 514 517 517 522 522
                                                                                  532 532 535 535 540 540 5-92 5-92 5-92 5-92 5-106
                                                                                  5-106 5-113 5-113 5-128 876
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "erring_token" dcl 7-143
                                                                                  in procedure "ERROR" ref 7-172 7-172 7-172 7-172
                                                                                  7-172 7-172
MERROR_SEVERITY                 000457 automatic       fixed bin(17,0)          initial dcl 7-3 set ref 388 7-3* 554* 573* 7-154*
                                                                                  7-154 7-168* 7-172*
MIN_PRINT_SEVERITY              000461 automatic       fixed bin(17,0)          initial dcl 7-3 set ref 7-3* 7-153
NRED                            000567 automatic       fixed bin(17,0)          dcl 3-33 set ref 5-52* 5-55* 5-55 5-58 781 786* 792*
                                                                                  797* 804* 811* 818* 825* 831* 838* 845* 852* 859*
                                                                                  865* 871* 879* 885* 892* 897* 904* 909* 916* 921*
                                                                                  927* 932* 935* 942* 948* 953* 959* 964* 969* 974*
                                                                                  979* 985* 990* 1004* 1015* 1021* 1027* 1032* 1038*
                                                                                  1043* 1049* 1054* 1059* 1070* 1081* 1087* 1093*
                                                                                  1099* 1105* 1111* 1116* 1122* 1127* 1133* 1138*
                                                                                  1143*
NUMBER                          000601 automatic       fixed bin(35,0)          dcl 3-33 set ref 5-106* 5-108
Nerror                                 parameter       fixed bin(17,0)          dcl 7-141 set ref 7-139 7-153 7-154 7-156 7-161
                                                                                  7-168* 7-168 7-168 7-168 7-168 7-172* 7-172 7-172
                                                                                  7-172 7-172
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 4-68 set ref 5-101
                                                                                  5-108*
PRED                            000570 automatic       pointer                  dcl 3-33 set ref 5-58* 5-62 5-62 5-73 5-73 5-79 5-79
                                                                                  5-79
PRINT_SEVERITY_CONTROL          000462 automatic       bit(2)                   initial unaligned dcl 7-3 set ref 7-3* 7-154 7-156
PTOKEN_REQD                     000572 automatic       pointer                  dcl 3-33 set ref 5-63* 5-65 5-65 5-70 5-71 5-123
                                                                                  5-126 5-127 758
PTOKEN_REQD_VALUE               000574 automatic       pointer                  dcl 3-33 set ref 5-126* 5-128
Perring_token                   000650 automatic       pointer                  dcl 7-143 set ref 7-160* 7-161 7-164 7-168 7-168*
                                                                                  7-172* 7-172 7-172 7-172 7-172 7-172 7-172 7-172
                                                                                  7-172 7-172
Plast                     2            based           pointer                  level 2 packed unaligned dcl 4-68 ref 6-45 6-47
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 4-68 ref 5-79 777 972
                                                                                  977 1002 1009 1014 1020 1037 1041 1068 1075 1080
                                                                                  1086 1092 1098 1104 1121 1125 6-39 6-40 8-27 8-28
Pstmt                           000646 automatic       pointer                  dcl 7-143 in procedure "ERROR" set ref 7-161* 7-164*
                                                                                  7-166* 7-168* 7-172*
Pstmt                     5            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 7-143 in procedure "ERROR" ref 7-164
Pstmt                     5            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 4-68 in procedure "cv_prt_rqti" ref 570 8-25
                                                                                  8-29 8-32
Pstmt                           000452 automatic       pointer                  dcl 4-40 in procedure "cv_prt_rqti" set ref 8-25*
                                                                                  8-29 8-32
Pthis_token                     000450 automatic       pointer                  dcl 3-23 set ref 363* 571 5-60 780 972 972* 977 977*
                                                                                  1002 1002* 1009 1009* 1014 1014* 1020 1020* 1037
                                                                                  1037* 1041 1041* 1068 1068* 1075 1075* 1080 1080*
                                                                                  1086 1086* 1092 1092* 1098 1098* 1104 1104* 1121
                                                                                  1121* 1125 1125* 6-36 6-49* 7-160 8-24 8-35* 8-36*
Ptoken                          000454 automatic       pointer                  dcl 4-68 set ref 430 430 430 433 433 433 438 438 438
                                                                                  450 450 450 453 453 453 458 458 458 462 462 462
                                                                                  473 473 473 476 476 476 483 483 483 491 491 491
                                                                                  494 494 494 499 499 499 514 514 514 517 517 517
                                                                                  522 522 522 532 532 532 535 535 535 540 540 540
                                                                                  570 5-60* 5-64 5-73 5-79 5-86 5-92 5-92 5-92 5-92
                                                                                  5-92 5-92 5-92 5-101 5-104 5-106 5-106 5-106 5-108
                                                                                  5-113 5-113 5-113 5-113 5-118 5-124 5-128 5-128
                                                                                  777* 777 780* 876 876 972* 977* 1002* 1009* 1014*
                                                                                  1020* 1037* 1041* 1068* 1075* 1080* 1086* 1092*
                                                                                  1098* 1104* 1121* 1125* 6-36* 6-37 6-39 6-40* 6-40
                                                                                  6-42* 6-45 6-47* 6-47 6-49 8-24* 8-25 8-27 8-28*
                                                                                  8-28 8-29 8-32 8-32* 8-32 8-35* 8-36
Pvalue                    3            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 7-143 in procedure "ERROR" ref 7-172 7-172
                                                                                  7-172
Pvalue                    3            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 4-68 in procedure "cv_prt_rqti" ref 430 433
                                                                                  438 450 453 458 462 473 476 483 491 494 499 514
                                                                                  517 522 532 535 540 5-92 5-92 5-106 5-113 5-128
                                                                                  876
RED                                    based           structure                level 1 dcl 3-48
REDUCTION                              based           structure                array level 1 packed unaligned dcl 633 set ref 5-58
REDUCTIONS                      001514 constant        fixed bin(17,0)          initial array unaligned dcl 633 set ref 5-58
S                        11            based           structure                level 3 packed unaligned dcl 4-68
SERROR_CONTROL                  000460 automatic       bit(2)                   initial unaligned dcl 7-3 set ref 275* 278* 7-3*
                                                                                  554* 573* 7-168* 7-172*
SERROR_PRINTED                  000461 automatic       bit(1)                   initial array unaligned dcl 7-3 set ref 372 375 378
                                                                                  381 381 7-3* 554* 573* 7-156* 7-168* 7-172*
SPDL                            000456 automatic       bit(1)                   initial dcl 1151 set ref 1151* 5-73 6-42 8-32
STOKEN_FCN                      000576 automatic       bit(1)                   dcl 3-33 set ref 760* 762* 764* 766* 768* 770* 773
Soutput_stmt              0(18) 000000 constant        bit(1)                   initial array level 2 packed unaligned dcl 581 ref
                                                                                  7-161
Ssearching                      000660 automatic       bit(1)                   dcl 8-21 set ref 8-26* 8-27 8-30*
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed unaligned dcl 3-48
                                                                                  in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 1 dcl 3-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 3-48
TOKEN_REQD_VALUE                       based           char                     unaligned dcl 3-48 ref 5-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed unaligned dcl 704 set ref 5-63
TOKEN_REQUIREMENTS              001350 constant        fixed bin(17,0)          initial array unaligned dcl 704 set ref 5-63
TOKEN_STRINGS                          based           char(212)                dcl 748 set ref 5-126
TOKEN_STRING_ARRAYS             001235 constant        char(100)                initial array dcl 748 set ref 5-126
TRACING                         000010 internal static bit(1)                   initial dcl 625 set ref 5-50* 5-50
TYPE                      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 3-48 ref 5-65 5-71 758
addr                                                   builtin function         dcl 3-92 ref 5-58 5-58 5-63 5-63 5-126 5-126
area_ptr                        000104 automatic       pointer                  dcl 173 set ref 289* 346* 347 354* 421 421*
arg                                    based           char                     unaligned dcl 200 set ref 266* 269* 275 275 278 278
arg_length                      000106 automatic       fixed bin(17,0)          dcl 174 set ref 259* 266 266 269 269 274* 275 275
                                                                                  278 278
arg_ptr                         000110 automatic       pointer                  dcl 175 set ref 259* 266 269 274* 275 275 278 278
auto_go                   0(01) 000230 automatic       bit(1)                   array level 2 packed unaligned dcl 196 set ref 1018*
banner_bars             122            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 329* 836* 843* 850*
banner_line             124            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 330*
banner_type             121            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 328* 375 802* 809* 816*
bitcount                        000112 automatic       fixed bin(24,0)          dcl 176 set ref 293* 301 401* 402* 403*
brief_message            33     000000 constant        varying char(20)         initial array level 2 dcl 581 ref 554 573 7-168
                                                                                  7-172
channel_stops           210            based           bit(16)                  array level 3 packed unaligned dcl 1-9 set ref 956*
chn_no                          000113 automatic       fixed bin(17,0)          dcl 177 set ref 514* 520 520 956
cleanup                         000232 stack reference condition                dcl 208 ref 291
clock                                                  builtin function         dcl 204 ref 322
code                            000114 automatic       fixed bin(35,0)          dcl 178 set ref 259* 260 262* 266* 267 269* 274* 275
                                                                                  281* 293* 296* 307* 310* 316* 317 346* 349* 354*
                                                                                  356 358* 391* 398* 402* 403 403* 415* 418* 421*
                                                                                  430* 431 450* 451 473* 474 491* 492 514* 515 532*
                                                                                  533
collate                                                builtin function         dcl 204 ref 340 340 341 341
com_err_                        000012 constant        entry                    external dcl 212 ref 262 269 296 310 349 358 390 403
cu_$arg_ptr                     000014 constant        entry                    external dcl 213 ref 259 274
cv_dec_check_                   000056 constant        entry                    external dcl 3-96 in procedure "SEMANTIC_ANALYSIS"
                                                                                  ref 5-106
cv_dec_check_                   000016 constant        entry                    external dcl 214 in procedure "cv_prt_rqti" ref 430
                                                                                  450 473 491 514 532
dimension                                              builtin function         dcl 204 ref 7-3 7-3
divide                                                 builtin function         dcl 204 ref 301
dname                           000115 automatic       char(168)                unaligned dcl 179 set ref 266* 293* 296* 303* 307*
                                                                                  310* 403*
driver_wait_time          5            based           fixed bin(17,0)          level 3 dcl 1-9 set ref 324* 789*
ename                           000167 automatic       char(32)                 unaligned dcl 180 set ref 266* 285 293* 296* 305
                                                                                  358* 390*
erring_token                           based           structure                level 1 dcl 7-143
erring_token_value                     based           char                     unaligned dcl 7-143 set ref 7-172* 7-172* 7-172*
error_control_table             000000 constant        structure                array level 1 dcl 581 ref 7-3 7-3
error_num                              parameter       fixed bin(17,0)          dcl 565 in procedure "statement_error" set ref 562
                                                                                  573* 573 573 573 573
error_num                              parameter       fixed bin(17,0)          dcl 550 in procedure "semant_error" set ref 547 554*
                                                                                  554 554 554 554
error_table_$badopt             000052 external static fixed bin(35,0)          dcl 247 ref 281
error_table_$translation_failed 000054 external static fixed bin(35,0)          dcl 249 set ref 390*
expand_pathname_$add_suffix     000020 constant        entry                    external dcl 215 ref 266
first_time                      000444 automatic       bit(1)                   initial dcl 239 set ref 239* 338 343*
flags                           000226 automatic       structure                array level 1 dcl 195 set ref 1064* 1065* 1141 1141
force_ctl_char            0(03) 000226 automatic       bit(1)                   array level 2 packed unaligned dcl 195 set ref 1102*
force_esc                 0(02) 000226 automatic       bit(1)                   array level 2 packed unaligned dcl 195 set ref 1090*
force_nep                 0(01) 000226 automatic       bit(1)                   array level 2 packed unaligned dcl 195 set ref 1084*
force_nsep                0(04) 000226 automatic       bit(1)                   array level 2 packed unaligned dcl 195 set ref 1096*
get_wdir_                       000036 constant        entry                    external dcl 222 ref 303
group2                    7            based           structure                level 2 packed unaligned dcl 4-68
hcs_$delentry_seg               000022 constant        entry                    external dcl 216 ref 391
hcs_$initiate_count             000024 constant        entry                    external dcl 217 ref 293
hcs_$make_seg                   000026 constant        entry                    external dcl 218 ref 307
hcs_$set_bc_seg                 000030 constant        entry                    external dcl 219 ref 402
hcs_$terminate_noname           000032 constant        entry                    external dcl 220 ref 415 418
hcs_$truncate_seg               000034 constant        entry                    external dcl 221 ref 316 398
header                                 based           structure                level 2 dcl 1-9
header_version            2            based           fixed bin(17,0)          level 3 dcl 1-9 set ref 323*
i                               000634 automatic       fixed bin(17,0)          dcl 6-33 set ref 6-39* 6-42 6-45*
ind                             000177 automatic       fixed bin(17,0)          dcl 181 set ref 996* 1007* 1007 1012 1018 1035*
                                                                                  1062* 1073* 1073 1078 1084 1090 1096 1102 1119*
is_printer                      000200 automatic       bit(1)                   dcl 182 set ref 366 800* 807* 814* 834* 841* 848*
                                                                                  868* 877* 890* 902* 914* 924*
len_ent                         000201 automatic       fixed bin(17,0)          dcl 183 set ref 285* 305
len_rqti                        000202 automatic       fixed bin(18,0)          dcl 184 set ref 397* 398* 400* 401
length                                                 builtin function         dcl 204 ref 285 305
lex_error_                      000060 constant        entry                    external dcl 7-150 in procedure "ERROR" ref 7-168
                                                                                  7-172
lex_error_                      000040 constant        entry                    external dcl 223 in procedure "cv_prt_rqti" ref 554
                                                                                  573
lex_string_$init_lex_delims     000042 constant        entry                    external dcl 224 ref 342
lex_string_$lex                 000044 constant        entry                    external dcl 227 ref 354
lfi                     200            based           structure                level 2 dcl 1-9
line_no                         000203 automatic       fixed bin(17,0)          dcl 185 set ref 491* 497 497 502 502 956
lines_per_inch          202            based           fixed bin(17,0)          level 4 dcl 1-9 set ref 333* 381 381 381* 912*
lpi                             000204 automatic       fixed bin(17,0)          dcl 186 set ref 473* 480 480 912
max                                                    builtin function         dcl 7-148 ref 7-154
max_line_no                     000205 automatic       fixed bin(17,0)          dcl 187 set ref 336* 372 372* 502 502*
me                              001613 constant        char(11)                 initial unaligned dcl 243 set ref 262* 269* 296*
                                                                                  310* 346* 349* 358* 390* 403*
message                   1     000000 constant        varying char(100)        initial array level 2 dcl 581 ref 554 573 7-168
                                                                                  7-172
meter                           000230 automatic       bit(1)                   array level 2 packed unaligned dcl 196 set ref 1012*
n                                      parameter       fixed bin(17,0)          dcl 6-33 ref 6-31 6-38 6-39 6-42 6-45
n_chars                         000206 automatic       fixed bin(21,0)          dcl 188 set ref 301* 354*
no_auto_print           125            based           bit(1)                   level 3 in structure "prt_rqti" packed unaligned
                                                                                  dcl 1-9 in procedure "cv_prt_rqti" set ref 334*
                                                                                  370* 370
no_auto_print                   000226 automatic       bit(1)                   array level 2 in structure "flags" packed unaligned
                                                                                  dcl 195 in procedure "cv_prt_rqti" set ref 1078*
null                                                   builtin function         dcl 204 in procedure "cv_prt_rqti" ref 287 288 289
                                                                                  294 308 347 392 415 418 421 554 554 554 554 6-37
                                                                                  6-39 6-42 6-45
null                                                   builtin function         dcl 7-148 in procedure "ERROR" ref 7-161 7-161 7-166
                                                                                  7-168
null                                                   builtin function         dcl 3-92 in procedure "SEMANTIC_ANALYSIS" ref 5-64
                                                                                  5-73 5-79 5-86
null                                                   builtin function         dcl 8-21 in procedure "NEXT_STMT" ref 8-27 8-35
opr_msg                  21            based           char(256)                level 2 dcl 1-9 set ref 327* 876*
paper_info              200            based           structure                level 3 dcl 1-9
paper_len                       000207 automatic       fixed bin(17,0)          dcl 189 set ref 430* 436 436 888
paper_length            200            based           fixed bin(17,0)          level 4 dcl 1-9 set ref 331* 372 372* 381 888*
paper_wdth                      000210 automatic       fixed bin(17,0)          dcl 190 set ref 450* 456 456 462 900
paper_width             201            based           fixed bin(17,0)          level 4 dcl 1-9 set ref 332* 378 900*
parm1                                  parameter       fixed bin(17,0)          dcl 551 set ref 547 554*
parm2                                  parameter       fixed bin(17,0)          dcl 552 set ref 547 554*
prt_flags               125            based           structure                level 2 dcl 1-9 set ref 1141*
prt_rqti                               based           structure                level 1 dcl 1-9 set ref 320* 400
prt_rqti_version_1                     constant        fixed bin(17,0)          initial dcl 1-54 ref 326
prt_rqtip                       000446 automatic       pointer                  dcl 1-7 set ref 288* 307* 308 316* 320 322 323 324
                                                                                  326 327 328 329 330 331 332 333 334 369 370 370
                                                                                  372 372 375 378 381 381 381 381 391* 392* 395 398*
                                                                                  400 402* 418 418* 789 802 809 816 836 843 850 876
                                                                                  888 900 912 956 1057 1141
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 4-68 ref 5-92 5-104
                                                                                  5-113 5-118 5-124
rqti_header                            based           structure                level 1 dcl 2-4 ref 397
rqti_header_version_1                  constant        fixed bin(17,0)          initial dcl 2-18 ref 323
rqti_name                       000211 automatic       char(32)                 unaligned dcl 191 set ref 305* 307* 310* 403*
rqti_switches             4            based           structure                level 2 in structure "rqti_header" dcl 2-4
                                                                                  in procedure "cv_prt_rqti"
rqti_switches             4            based           structure                level 3 in structure "prt_rqti" dcl 1-9 in procedure
                                                                                  "cv_prt_rqti" set ref 1057*
rtrim                                                  builtin function         dcl 204 ref 285
search                                                 builtin function         dcl 3-92 ref 5-92
severity                        000000 constant        fixed bin(17,0)          initial array level 2 packed unaligned dcl 581 ref
                                                                                  554 573 7-153 7-154 7-168 7-172
size                                                   builtin function         dcl 204 ref 397 400
sourcep                         000222 automatic       pointer                  dcl 192 set ref 287* 293* 294 354* 415 415*
stmt_ptr                        000554 automatic       pointer                  dcl 567 set ref 570* 573*
string                                                 builtin function         dcl 204 set ref 998* 999* 1057* 1057 1057 1064*
                                                                                  1065* 1141* 1141 1141
string1                                parameter       char                     unaligned dcl 566 set ref 562 573*
substr                                                 builtin function         dcl 204 in procedure "cv_prt_rqti" ref 305 340 340
                                                                                  341 341
substr                                                 builtin function         dcl 3-92 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  5-92 5-126 956*
switches                        000230 automatic       structure                array level 1 dcl 196 set ref 998* 999* 1057 1057
time_created                           based           fixed bin(71,0)          level 3 dcl 1-9 set ref 322*
token                                  based           structure                level 1 dcl 4-68
token_ptr                       000556 automatic       pointer                  dcl 568 set ref 571* 573*
token_value                            based           char                     unaligned dcl 4-68 set ref 430* 433* 438* 450* 453*
                                                                                  458* 462* 473* 476* 483* 491* 494* 499* 514* 517*
                                                                                  522* 532* 535* 540* 5-92 5-92 5-106* 5-113 5-128
                                                                                  876
translator_temp_$get_segment    000046 constant        entry                    external dcl 230 ref 346
translator_temp_$release_all_segments
                                000050 constant        entry                    external dcl 231 ref 421
type_code                 3            based           fixed bin(17,0)          level 3 dcl 1-9 set ref 369* 395
unspec                                                 builtin function         dcl 204 set ref 320*
verify                                                 builtin function         dcl 3-92 ref 5-92
version                  20            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 326*
wait_time                       000224 automatic       fixed bin(17,0)          dcl 193 set ref 532* 538 538 789

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Pcomment                               automatic       pointer                  dcl 4-20
comment                                based           structure                level 1 dcl 4-20
comment_value                          based           char                     unaligned dcl 4-20
error_table_$entlong                   external static fixed bin(35,0)          dcl 248
max                                                    builtin function         dcl 3-92
stmt                                   based           structure                level 1 dcl 4-40
stmt_value                             based           char                     unaligned dcl 4-40

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           006447 constant        entry                    internal dcl 7-139 ref 823 828 857 862 882 939 945
                                                                                  951 967 982 988 1024 1030 1046 1052 1108 1114 1130
                                                                                  1136
LEX                             006361 constant        entry                    internal dcl 6-31 ref 784 791 803 810 817 821 837
                                                                                  844 851 855 870 874 878 891 903 915 926 958
NEXT_STMT                       006760 constant        entry                    internal dcl 8-18 ref 795 824 830 858 864 884 895
                                                                                  907 919 930 941 947 962 984 1026 1048 1110 1132
RD_ACTION                       001136 constant        label                    array(63) dcl 784 ref 781
RD_MATCH                        005346 constant        label                    dcl 777 ref 5-90 5-92 5-101 5-109 5-113 5-118 5-128
                                                                                  773
RD_MATCH_NO_TOKEN               005351 constant        label                    dcl 778 ref 5-73 5-79 5-86
RD_NEXT_REDUCTION               005032 constant        label                    dcl 5-55 ref 5-68 5-84 5-88 5-99 5-104 5-111 5-116
                                                                                  5-120 5-124 5-130 774 1000 1010 1066 1076
RD_TEST_REDUCTION               005033 constant        label                    dcl 5-58 ref 5-53 787 793 798 805 812 819 826 832
                                                                                  839 846 853 860 866 872 880 886 893 898 905 910
                                                                                  917 922 928 933 937 943 949 954 960 965 970 975
                                                                                  980 986 991 1005 1016 1022 1028 1033 1039 1044
                                                                                  1050 1055 1060 1071 1082 1088 1094 1100 1106 1112
                                                                                  1117 1123 1128 1134 1139 1144
RD_TEST_RESULT                  005342 constant        label                    dcl 773 ref 761 763 765 767 769 771
RD_TEST_TOKEN                   001122 constant        label                    array(6) dcl 5-73 ref 5-65 5-71
RD_TOKEN_FCN                    001130 constant        label                    array(6) dcl 760 ref 758
SEMANTIC_ANALYSIS               005022 constant        entry                    internal dcl 3-30 ref 364
clean                           003507 constant        entry                    internal dcl 412 ref 291 312 350 359 407
cv_prt_rqti                     002035 constant        entry                    external dcl 166
error1                          002207 constant        label                    dcl 269 ref 282
error2                          002424 constant        label                    dcl 296
error3                          002546 constant        label                    dcl 310 ref 317
legal_chn_no                    004312 constant        entry                    internal dcl 511 ref 770
legal_line_no                   004170 constant        entry                    internal dcl 488 ref 768
legal_lpi                       004051 constant        entry                    internal dcl 470 ref 766
legal_paper_len                 003566 constant        entry                    internal dcl 427 ref 762
legal_paper_wdth                003705 constant        entry                    internal dcl 447 ref 764
legal_wait_time                 004431 constant        entry                    internal dcl 529 ref 760
semant_error                    004550 constant        entry                    internal dcl 547 ref 372 378 381
statement_error                 004671 constant        entry                    internal dcl 562 ref 433 438 453 458 462 476 483 494
                                                                                  499 517 522 535 540

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7526        7610    7251        7536
Length     10210    7251        62         363     255           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cv_prt_rqti                        1022 external procedure  is an external procedure.  
on unit on line 291                  64 on unit               
clean                                70 internal procedure  is called by several nonquick procedures.  
legal_paper_len                         internal procedure  shares stack frame of external procedure cv_prt_rqti.  
legal_paper_wdth                        internal procedure  shares stack frame of external procedure cv_prt_rqti.  
legal_lpi                               internal procedure  shares stack frame of external procedure cv_prt_rqti.  
legal_line_no                           internal procedure  shares stack frame of external procedure cv_prt_rqti.  
legal_chn_no                            internal procedure  shares stack frame of external procedure cv_prt_rqti.  
legal_wait_time                         internal procedure  shares stack frame of external procedure cv_prt_rqti.  
semant_error                            internal procedure  shares stack frame of external procedure cv_prt_rqti.  
statement_error                         internal procedure  shares stack frame of external procedure cv_prt_rqti.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure cv_prt_rqti.  
LEX                                     internal procedure  shares stack frame of external procedure cv_prt_rqti.  
ERROR                                   internal procedure  shares stack frame of external procedure cv_prt_rqti.  
NEXT_STMT                               internal procedure  shares stack frame of external procedure cv_prt_rqti.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 TRACING                     cv_prt_rqti

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_prt_rqti              000100 APstmt                      cv_prt_rqti
                         000102 APtoken                     cv_prt_rqti
                         000104 area_ptr                    cv_prt_rqti
                         000106 arg_length                  cv_prt_rqti
                         000110 arg_ptr                     cv_prt_rqti
                         000112 bitcount                    cv_prt_rqti
                         000113 chn_no                      cv_prt_rqti
                         000114 code                        cv_prt_rqti
                         000115 dname                       cv_prt_rqti
                         000167 ename                       cv_prt_rqti
                         000177 ind                         cv_prt_rqti
                         000200 is_printer                  cv_prt_rqti
                         000201 len_ent                     cv_prt_rqti
                         000202 len_rqti                    cv_prt_rqti
                         000203 line_no                     cv_prt_rqti
                         000204 lpi                         cv_prt_rqti
                         000205 max_line_no                 cv_prt_rqti
                         000206 n_chars                     cv_prt_rqti
                         000207 paper_len                   cv_prt_rqti
                         000210 paper_wdth                  cv_prt_rqti
                         000211 rqti_name                   cv_prt_rqti
                         000222 sourcep                     cv_prt_rqti
                         000224 wait_time                   cv_prt_rqti
                         000226 flags                       cv_prt_rqti
                         000230 switches                    cv_prt_rqti
                         000240 BREAKS                      cv_prt_rqti
                         000301 IGBREAKS                    cv_prt_rqti
                         000342 LEXCTL                      cv_prt_rqti
                         000403 LEXDLM                      cv_prt_rqti
                         000444 first_time                  cv_prt_rqti
                         000446 prt_rqtip                   cv_prt_rqti
                         000450 Pthis_token                 cv_prt_rqti
                         000452 Pstmt                       cv_prt_rqti
                         000454 Ptoken                      cv_prt_rqti
                         000456 SPDL                        cv_prt_rqti
                         000457 MERROR_SEVERITY             cv_prt_rqti
                         000460 SERROR_CONTROL              cv_prt_rqti
                         000461 MIN_PRINT_SEVERITY          cv_prt_rqti
                         000461 SERROR_PRINTED              cv_prt_rqti
                         000462 PRINT_SEVERITY_CONTROL      cv_prt_rqti
                         000554 stmt_ptr                    statement_error
                         000556 token_ptr                   statement_error
                         000566 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000567 NRED                        SEMANTIC_ANALYSIS
                         000570 PRED                        SEMANTIC_ANALYSIS
                         000572 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         000574 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000576 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         000577 CODE                        SEMANTIC_ANALYSIS
                         000600 I                           SEMANTIC_ANALYSIS
                         000601 NUMBER                      SEMANTIC_ANALYSIS
                         000602 DIRECTION                   SEMANTIC_ANALYSIS
                         000634 i                           LEX
                         000646 Pstmt                       ERROR
                         000650 Perring_token               ERROR
                         000660 Ssearching                  NEXT_STMT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            unpk_to_pk          call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              alloc_auto_adj      enable              shorten_stack       ext_entry           int_entry
clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_ptr                   cv_dec_check_                 cv_dec_check_
expand_pathname_$add_suffix   get_wdir_                     hcs_$delentry_seg             hcs_$initiate_count
hcs_$make_seg                 hcs_$set_bc_seg               hcs_$terminate_noname         hcs_$truncate_seg
lex_error_                    lex_error_                    lex_string_$init_lex_delims   lex_string_$lex
translator_temp_$get_segment  translator_temp_$release_all_segments

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$translation_failed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    166 002034       239 002042      1151 002044    7    3 002045       554 002077       259 002101       260 002120
    262 002122       263 002146       266 002147       267 002205       269 002207       271 002233       274 002234
    275 002253       278 002274       281 002311       282 002314       285 002315       287 002327       288 002331
    289 002332       291 002333       293 002355       294 002420       296 002424       298 002457       301 002460
    303 002464       305 002476       307 002503       308 002542       310 002546       312 002601       313 002605
    316 002606       317 002622       320 002624       322 002630       323 002632       324 002635       326 002637
    327 002641       328 002644       329 002646       330 002647       331 002650       332 002652       333 002654
    334 002656       336 002660       338 002661       340 002663       341 002705       342 002713       343 002775
    346 002776       347 003017       349 003023       350 003047       351 003053       354 003054       356 003170
    358 003172       359 003213       360 003217       363 003220       364 003222       366 003223       369 003226
    370 003231       372 003237       375 003261       378 003270       381 003304       388 003336       390 003341
    391 003362       392 003373       393 003375       395 003376       397 003401       398 003403       399 003416
    400 003417       401 003421       402 003424       403 003437       407 003501       408 003505       412 003506
    415 003514       418 003531       421 003547       424 003565       427 003566       430 003570       431 003616
    433 003620       434 003643       436 003646       438 003653       439 003676       441 003701       447 003705
    450 003707       451 003735       453 003737       454 003762       456 003765       458 003772       459 004015
    462 004020       464 004045       470 004051       473 004053       474 004101       476 004103       477 004126
    480 004131       483 004142       484 004165       488 004170       491 004172       492 004220       494 004222
    495 004245       497 004250       499 004255       500 004300       502 004303       505 004306       511 004312
    514 004314       515 004342       517 004344       518 004367       520 004372       522 004377       523 004422
    525 004425       529 004431       532 004433       533 004461       535 004463       536 004506       538 004511
    540 004516       541 004541       543 004544       547 004550       554 004552       558 004667       562 004671
    570 004702       571 004705       573 004707       577 005020    3   30 005022       630 005023    5   50 005025
 5   52 005030    5   53 005031    5   55 005032    5   58 005033    5   60 005036    5   62 005040    5   63 005064
 5   64 005067    5   65 005073    5   68 005103    5   70 005104    5   71 005110    5   73 005112    5   79 005131
 5   84 005142    5   86 005143    5   88 005147    5   90 005150    5   92 005151    5   99 005205    5  101 005206
 5  104 005211    5  106 005214    5  107 005240    5  108 005242    5  109 005245    5  111 005246    5  113 005247
 5  116 005263    5  118 005264    5  120 005270    5  123 005271    5  124 005272    5  126 005276    5  127 005303
 5  128 005307    5  130 005315       758 005316       760 005320       761 005322       762 005323       763 005325
    764 005326       765 005330       766 005331       767 005333       768 005334       769 005336       770 005337
    771 005341       773 005342       774 005345       777 005346       778 005351       780 005354       781 005356
    784 005360       786 005364       787 005366       789 005367       791 005372       792 005376       793 005400
    795 005401       797 005402       798 005404       800 005405       802 005407       803 005412       804 005416
    805 005420       807 005421       809 005423       810 005426       811 005432       812 005434       814 005435
    816 005437       817 005441       818 005445       819 005447       821 005450       823 005454       824 005460
    825 005461       826 005463       828 005464       830 005470       831 005471       832 005473       834 005474
    836 005476       837 005500       838 005504       839 005506       841 005507       843 005511       844 005514
    845 005520       846 005522       848 005523       850 005525       851 005530       852 005534       853 005536
    855 005537       857 005543       858 005547       859 005550       860 005552       862 005553       864 005557
    865 005560       866 005562       868 005563       870 005565       871 005571       872 005573       874 005574
    876 005600       877 005610       878 005612       879 005616       880 005620       882 005621       884 005625
    885 005626       886 005630       888 005631       890 005634       891 005636       892 005642       893 005644
    895 005645       897 005646       898 005650       900 005651       902 005654       903 005656       904 005662
    905 005664       907 005665       909 005666       910 005670       912 005671       914 005674       915 005676
    916 005702       917 005704       919 005705       921 005706       922 005710       924 005711       926 005713
    927 005717       928 005721       930 005722       932 005723       933 005725       935 005726       937 005730
    939 005731       941 005735       942 005736       943 005740       945 005741       947 005745       948 005746
    949 005750       951 005751       953 005755       954 005757       956 005760       958 005772       959 005776
    960 006000       962 006001       964 006002       965 006004       967 006005       969 006011       970 006013
    972 006014       974 006017       975 006021       977 006022       979 006025       980 006027       982 006030
    984 006034       985 006035       986 006037       988 006040       990 006044       991 006046       993 006047
    996 006050       998 006052       999 006053      1000 006054      1002 006055      1004 006060      1005 006062
   1007 006063      1009 006065      1010 006070      1012 006071      1014 006074      1015 006077      1016 006101
   1018 006102      1020 006105      1021 006110      1022 006112      1024 006113      1026 006117      1027 006120
   1028 006122      1030 006123      1032 006127      1033 006131      1035 006132      1037 006134      1038 006137
   1039 006141      1041 006142      1043 006145      1044 006147      1046 006150      1048 006154      1049 006155
   1050 006157      1052 006160      1054 006164      1055 006166      1057 006167      1059 006174      1060 006176
   1062 006177      1064 006201      1065 006202      1066 006203      1068 006204      1070 006207      1071 006211
   1073 006212      1075 006214      1076 006217      1078 006220      1080 006223      1081 006226      1082 006230
   1084 006231      1086 006234      1087 006237      1088 006241      1090 006242      1092 006245      1093 006250
   1094 006252      1096 006253      1098 006256      1099 006261      1100 006263      1102 006264      1104 006267
   1105 006272      1106 006274      1108 006275      1110 006301      1111 006302      1112 006304      1114 006305
   1116 006311      1117 006313      1119 006314      1121 006316      1122 006321      1123 006323      1125 006324
   1127 006327      1128 006331      1130 006332      1132 006336      1133 006337      1134 006341      1136 006342
   1138 006346      1139 006350      1141 006351      1143 006356      1144 006360    6   31 006361    6   36 006363
 6   37 006365    6   38 006372    6   39 006374    6   40 006407    6   41 006411    6   42 006413    6   44 006423
 6   45 006424    6   47 006437    6   48 006441    6   49 006444    6   51 006446    7  139 006447    7  153 006451
 7  154 006461    7  156 006470    7  158 006477    7  160 006500    7  161 006502    7  164 006515    7  166 006521
 7  168 006523    7  172 006627    7  177 006756    8   18 006760    8   24 006761    8   25 006763    8   26 006766
 8   27 006770    8   28 006776    8   29 007000    8   30 007005    8   31 007006    8   32 007007    8   35 007020
 8   36 007024    8   39 007025


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
