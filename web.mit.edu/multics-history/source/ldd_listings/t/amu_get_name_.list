	COMPILATION LISTING OF SEGMENT amu_get_name_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1918.78_Mon_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-12-09,Farley), approve(87-07-09,MCR7746),
       17*     audit(87-07-22,Fawcett), install(87-07-28,MR12.1-1049):
       18*     Copied external module get_ast_name_ into an internal proc called
       19*     get_ast_name, so that the current length of an sstnt.name could be
       20*     verified before copying the name.
       21*  2) change(87-01-16,Parisek), approve(87-07-09,MCR7746),
       22*     audit(87-07-22,Fawcett), install(87-07-28,MR12.1-1049):
       23*     Check translation_table for replaced segment (via "replace" request) and
       24*     return the new path instead of the old path.
       25*  3) change(87-06-22,Parisek), approve(87-07-09,MCR7746),
       26*     audit(87-07-22,Fawcett), install(87-07-28,MR12.1-1049):
       27*     Check for screech names on bound_xxx library names and call new
       28*     internal procedure "get_vtoc_pathname" to locate real library name.
       29*                                                   END HISTORY COMMENTS */
       30 
       31 
       32 amu_get_name_: proc (P_amu_info_ptr, P_segptr) returns (char (*));
       33 
       34 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       35 
       36 /* Modified 830830 to keep from scanning the static and symbol sections for the
       37*   offrel, thereby allways searching just text sections to resolve component
       38*   names... -E. A. Ranzenbach
       39*
       40*   Modified 12/9/83 by B. Braun to add entrypoint for_structure. This allosw "stack -as" to resolve names porperly.
       41*
       42*   Modified 09/28/84 by B. Braun to get rid of error messages in get_kstp routine.
       43*   Modified 10/04/84 by R. A. Fawcett to look at the slt directly for hardcore sega and look for others seg numbers when there is no kst_seg.
       44*   Modified 12/12/84 by B. Braun to fix bug in kst_name which caused it to ALWAYS fail.
       45*   Modified 01/18/85 by B. Braun to change kst_name to call amu_$kst_util_ entries.
       46*   Modified 01/18/85 by B. Braun to create entry get_l1dir_shortname and procedure of the same name.
       47*   Modified 01/24/85 by B. Braun to correct truncation of pathnames returned.
       48*   Modified 02/06/85 by B. Braun to correct bug for special casing the root ">" case.
       49*   Modified 02/08/85 by B. Braun to check init_segs when a dump isn't early but still using them.
       50**/
       51 
       52 /* Parameters */
       53 
       54 dcl  P_amu_info_ptr ptr,
       55      P_count fixed bin (24),
       56      P_ptr ptr,
       57      P_segptr ptr;
       58 
       59 /* Automatic */
       60 
       61 dcl  areap ptr;
       62 dcl  bitcnt fixed bin (24);
       63 dcl  bndsw bit (1);
       64 dcl  bmp ptr;
       65 dcl  1 branch aligned,				/* output structure from hcs_$status_ */
       66        2 type bit (2) unal,
       67        2 nnames fixed bin (15) unal,
       68        2 nrp bit (18) unal,
       69        2 dtm bit (36) unal,
       70        2 dtu bit (36) unal,
       71        2 mode bit (5) unal,
       72        2 pad bit (13) unal,
       73        2 rec fixed bin (17) unal;
       74 dcl  code fixed bin (35);
       75 dcl  dirname char (168);
       76 dcl  ename char (32);
       77 dcl  tdname char(168);	     
       78 dcl  tename char(32);
       79 dcl  genp ptr;
       80 dcl  1 hard_ptrs like hardcore_cur;
       81 dcl  key char (1);
       82 dcl  libx fixed bin;
       83 dcl  (ling, k, i, j, mblen, dl) fixed bin;
       84 dcl  namebuf char (168);
       85 dcl  new_sdw fixed bin (71);
       86 dcl  (nmp, nsdwp) ptr;
       87 dcl  offrel fixed bin (18);
       88 dcl  1 oi_area aligned like object_info;
       89 dcl  ptrtmp ptr;
       90 dcl  ret_ptr_sw bit (1);
       91 dcl  sblkp ptr;
       92 dcl  segno fixed bin;
       93 dcl  segptr ptr;					/* ptr to segment and offset in question */
       94 dcl  1 trans_space like translation;
       95 
       96 /* Based */
       97 
       98 dcl  var_str char (ling) based (ptrtmp);
       99 dcl  dnames (branch.nnames) char (32) aligned based (nmp);
      100 
      101 /* Internal Static */
      102 
      103 dcl  1 dinfo int static,				/* level one directory assosciative memory */
      104        2 ndir fixed bin init (0),
      105        2 l1dir (30),
      106          3 lg_name char (32),
      107          3 sht_name char (4);
      108 
      109 /* Conditions */
      110 
      111 dcl  zerodivide condition;
      112 
      113 /* External Static */
      114 
      115 dcl  amu_et_$null_sltp fixed bin (35) ext static;
      116 dcl  amu_et_$null_sltnt fixed bin (35) ext static;
      117 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      118 
      119 /* External Entries */
      120 
      121 dcl  amu_$dp_segno_to_name entry (ptr, fixed bin, char (*), fixed bin (35));
      122 dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
      123 dcl  amu_$fdump_translate_contiguous entry (ptr, ptr, ptr, fixed bin (35));
      124 dcl  amu_$resolve_virtual_addr entry (ptr, ptr, char (*), fixed bin, fixed bin (18), fixed bin (35));
      125 dcl  amu_$return_val_phcs_ok entry () returns (bit (1));
      126 dcl  amu_$search_path_get_object entry (ptr, fixed bin (35));
      127 dcl  amu_$search_path_set_object entry (ptr, fixed bin (35));
      128 dcl  amu_$translate_force_add entry (ptr, ptr, fixed bin (15), fixed bin (35));
      129 dcl  amu_$translate_get entry (ptr, fixed bin (15), ptr, fixed bin (35));
      130 dcl  amu_do_translation_ entry (ptr, fixed bin, ptr, fixed bin, fixed bin, fixed bin (35));
      131 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
      132 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      133 dcl  get_bound_seg_info_ entry (ptr, fixed bin (24), ptr, ptr, ptr, fixed bin (35));
      134 dcl  get_system_free_area_ entry (ptr);
      135 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
      136 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      137 dcl  hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      138 dcl  ioa_ entry () options (variable);
      139 dcl  ioa_$rsnnl entry options (variable);
      140 dcl  pathname_ entry (char (*), char (*)) returns (char (168));
      141 
      142 /* Builtins */
      143 
      144 dcl  (null, addr, addrel, baseno, divide, fixed, ptr, rel, substr, baseptr,
      145      rtrim, index, reverse, length, maxlength) builtin;
      146 
      147 	ret_ptr_sw, bndsw = "0"b;			/* set sw to break out component names and relative offsets */
      148 	go to common;
      149 
      150 get_ptr_count:
      151      entry (P_amu_info_ptr, P_segptr, P_ptr, P_count);
      152 	bndsw = "0"b;
      153 	ret_ptr_sw = "1"b;
      154 	goto common;
      155 
      156 no_comp:
      157      entry (P_amu_info_ptr, P_segptr) returns (char (*));
      158 	bndsw = "1"b;				/* set switch for no component breakout */
      159 	ret_ptr_sw = "0"b;
      160 	goto common;
      161 
      162 for_structure:
      163      entry (P_amu_info_ptr, a_pointer_rep) returns (char (*) varying);
      164 
      165 /* This is a kludge identical to get_name_$get_name_ except we get the pointer from the
      166*   string representation. */
      167 
      168 dcl  a_pointer_rep char (*) var;
      169 dcl  segname char (256) var;
      170 dcl  offset fixed bin (18);
      171 dcl  dnl fixed bin;
      172 dcl  replaced_path char(168);
      173 dcl  amu_get_name_ entry (ptr, ptr) returns (char (*));
      174 dcl  hcs_$fs_get_path_name entry (ptr, char(*), fixed bin, char(*), fixed bin(35));
      175 
      176 	code = 0;
      177 	segname = a_pointer_rep;			/* translate segname to a segno and offset        */
      178 	call amu_$resolve_virtual_addr (P_amu_info_ptr -> amu_info.sci_ptr, P_amu_info_ptr, (segname), segno, offset,
      179 	     code);
      180 	if code ^= 0 then return (segname);		/* don't get pathname */
      181 
      182 	return (segname || " " || rtrim (amu_get_name_ (P_amu_info_ptr, addrel (baseptr (segno), offset))));
      183 
      184 
      185 common:
      186 	amu_info_ptr = P_amu_info_ptr;
      187 	segptr = P_segptr;
      188 	genp = null ();
      189 	hardcore_cur_ptr = addr (hard_ptrs);		/* get pointers to interesting hc */
      190 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      191 	segno = fixed (baseno (segptr), 18);		/* Get segment number */
      192 	offrel = fixed (rel (segptr), 18);		/* Get offset */
      193 	mblen = 168;				/* preset return char length to 168 */
      194 	if segptr = null then do;
      195 	     if ^ret_ptr_sw then
      196 		return ("NULL POINTER");		/* if null ptr stop here */
      197 	     else do;
      198 		P_ptr = null ();
      199 		P_count = 0;
      200 		return;
      201 		end;
      202 	     end;
      203 
      204 	if hard_ptrs.sltntp = null then do;
      205 	     if ^ret_ptr_sw then
      206 		return ("Cannot get pointer to SST name table.");
      207 	     else do;
      208 		P_ptr = null ();
      209 		P_count = 0;
      210 		return;
      211 		end;
      212 	     end;
      213 
      214 	do i = 1 to translation_table.n_entries while (translation_table.segno (i) ^= segno);
      215 	end;
      216 	if translation_table.flags (i).replaced then do;
      217 	     call hcs_$fs_get_path_name ((translation_table.part1 (i).ptr), dirname, dnl, ename, code);
      218 	     replaced_path = rtrim(dirname) || ">" || rtrim(ename);
      219 	     return (replaced_path);
      220 	end;
      221 
      222 	if segno <= hardcore_info.hcs_count |		/* if a hardcore segment */
      223 	     amu_info.early_dump then do;		/* or its an early dump */
      224 	     if segno <= hardcore_info.hcs_count then	/* get name */
      225 		call get_sup_seg_slt (segno, dirname, ename, code);
      226 	     else call get_init_seg_slt (segno, dirname, ename, code);
      227 	     if code ^= 0 then do;
      228 		if ^ret_ptr_sw then
      229 		     return ("not known");
      230 		else do;
      231 		     P_ptr = null ();
      232 		     P_count = 0;
      233 		     return;
      234 		     end;
      235 		end;
      236 	     if bndsw then return (ename);
      237 	     if ^ret_ptr_sw then
      238 		if substr (ename, 1, 5) ^= "bound" then do;
      239 		     call ioa_$rsnnl ("^a|^o", ename, mblen, ename, fixed (rel (segptr)));
      240 		     return (ename);
      241 		     end;
      242 	     namebuf = ename;			/* copy for compatability */
      243 	     go to inithc;				/* initiate hardcore seg from ldd */
      244 	     end;
      245 	else do;					/* Non hardcore segment */
      246 	     if amu_info.type = SAVED_PROC_TYPE then do;
      247 		namebuf = "CANNOT GET NAME";
      248 		call amu_$dp_segno_to_name (amu_info_ptr, segno, namebuf, (0));
      249 		if substr (namebuf, 1, 1) = ">" then goto finish_name;
      250 		return (namebuf);
      251 		end;
      252 	     end;
      253 
      254 	nsdwp = addr (new_sdw);			/* get the sdw for segno */
      255 	call amu_do_translation_ (amu_info_ptr, 0, nsdwp, (segno * 2), 2, code);
      256 	astep =
      257 	     ptr (hard_ptrs.sstp,
      258 	     fixed (nsdwp -> sdw.add, 24) - fixed (hard_ptrs.sstp -> sst.ptwbase, 18) - hard_ptrs.sstp -> sst.astsize);
      259 						/* Compute Astep */
      260 
      261 /* attempt to ckeck validity of sst_names_ before calling get_ast_name */
      262 
      263 	if ^(hard_ptrs.sstntp -> sstnt.valid) then do;	/* chances are it is not valid. */
      264 	     namebuf = "CANNOT-GET-NAME";
      265 	     end;
      266 	else do;
      267 	     namebuf = "";
      268 
      269 	     on condition (zerodivide) namebuf = "CANNOT-COMPLETE-PATH";
      270 
      271 	     call get_ast_name (astep, hard_ptrs.sstp, hard_ptrs.sstntp, namebuf);
      272 	     revert condition (zerodivide);
      273 	     end;
      274 
      275 	call expand_pathname_ (rtrim(namebuf), tdname, tename, code);
      276 	if code ^= 0 then code = 0;
      277 	if substr (tename, 1, 4) = "!BBB" then
      278 	     if ((index (tename, "linker") = 0 & substr(tdname, 1, 4) ^= ">pdd" &
      279 	     substr(tdname, 1, 16) ^= ">process_dir_dir")) then do;
      280 		call get_vtoc_pathname;
      281 		if code ^= 0 then code = 0;
      282 	     end;
      283 
      284 	if rtrim (namebuf) = ">" then do;		/* special case the root */
      285 	     if ret_ptr_sw then do;
      286 		P_ptr = null ();
      287 		P_count = 0;
      288 		genp = null;			/* make sure ptr is null */
      289 		call hcs_$initiate_count (namebuf, "", "", bitcnt, 0, genp, code);
      290 		if genp = null then return;
      291 		P_ptr = genp;
      292 		P_count = bitcnt;
      293 		return;
      294 		end;
      295 	     return (namebuf);
      296 	     end;
      297 
      298 	if index (namebuf, "CANNOT") ^= 0
      299 	     | (index (reverse (namebuf), "!>") ^= 0 & substr (namebuf, 1, 16) ^= ">process_dir_dir") then
      300 	     if (amu_$return_val_phcs_ok () & get_kstp ()) then
      301 						/* if all this is true, go find name from kst */
      302 		call kst_name (segno, kstp);		/* find the name from kst, sets global namebuf */
      303 
      304 	if index (namebuf, "CANNOT") ^= 0 then do;	/* couldn't find in kst */
      305 	     call check_if_early_hardcore_seg (segno, dirname, ename, code);
      306 	     if code ^= 0 then do;
      307 		if index (namebuf, "CANNOT") ^= 1 then	/* have a partial path                            */
      308 		     goto finish_name;
      309 
      310 		if ^ret_ptr_sw then
      311 		     return ("CANNOT-GET-NAME");
      312 		else do;
      313 		     P_ptr = null ();
      314 		     P_count = 0;
      315 		     return;
      316 		     end;
      317 		end;
      318 	     if bndsw then return (ename);
      319 	     if ^ret_ptr_sw then
      320 		if substr (ename, 1, 5) ^= "bound" then do;
      321 		     call ioa_$rsnnl ("^a|^o", ename, mblen, ename, fixed (rel (segptr)));
      322 		     return (ename);
      323 		     end;
      324 	     namebuf = ename;			/* copy for compatability */
      325 	     go to inithc;				/* initiate hardcore seg from ldd */
      326 	     end;
      327 
      328 finish_name:
      329 	ename, dirname = "";
      330 	call get_l1dir_shortname (namebuf, dirname, ename, code);
      331 	if code = 0 then namebuf = pathname_ (dirname, ename);
      332 
      333 	if bndsw then return (namebuf);		/* no need to go further */
      334 	if substr (ename, 1, 6) = "CANNOT" then return (namebuf);
      335 	call expand_path_ (addr (namebuf), length (namebuf), addr (dirname), addr (ename), code);
      336 	if ^ret_ptr_sw then
      337 	     if substr (ename, 1, 5) ^= "bound" then do;
      338 		if (fixed (rel (segptr))) = 0 then
      339 		     return (namebuf);
      340 		else call ioa_$rsnnl ("^a|^o", namebuf, mblen, namebuf, fixed (rel (segptr)));
      341 		return (namebuf);
      342 		end;
      343 	if substr (dirname, 1, 4) = ">sl1" then do;	/* initiate hardcore segments from ldd for bind maps */
      344 inithc:
      345 	     call amu_$search_path_get_object (sl_info_p, code);
      346 	     if sl_info_p = null then			/* set default path */
      347 		call amu_$search_path_set_object (sl_info_p, code);
      348 	     if sl_info_p = null then do;
      349 		namebuf = "CANNOT-COMPLETE-PATH";
      350 		return (namebuf);
      351 		end;
      352 
      353 	     genp = null;
      354 	     do libx = 1 to sl_info.num_paths;
      355 		call hcs_$initiate_count (sl_info.paths (libx).pathname, ename, "", bitcnt, 0, genp, code);
      356 		if genp ^= null then goto exit_search;
      357 	     end;
      358 exit_search:
      359 	     if genp = null then
      360 		if ^ret_ptr_sw then return (namebuf);	/* cannot find in search dirs */
      361 
      362 	     end;
      363 	else do;
      364 	     genp = null;				/* make sure ptr is null */
      365 	     call hcs_$initiate_count (dirname, ename, "", bitcnt, 0, genp, code);
      366 	     if ^ret_ptr_sw then
      367 		if genp = null then return (namebuf);
      368 	     end;
      369 
      370 	if ret_ptr_sw then do;
      371 	     P_ptr = genp;
      372 	     P_count = bitcnt;
      373 	     if P_ptr = null then do;
      374 		call ioa_ ("^-^a not found. Cannot determine arguments.", namebuf);
      375 	     end;
      376 	     return;
      377 	     end;
      378 
      379 	oi_area.version_number = object_info_version_2;
      380 	call get_bound_seg_info_ (genp, bitcnt, addr (oi_area), bmp, sblkp, code);
      381 	if code ^= 0 then return (namebuf);		/* We now have a ptr to the bind map */
      382 	if (offrel * 36) > bitcnt then do;		/* offset is out of bounds */
      383 	     call ioa_$rsnnl ("^a|^o Offset OUT-OF-BOUNDS", namebuf, mblen, namebuf, offrel);
      384 	     go to trmnme;
      385 	     end;
      386 
      387 	do i = 1 to n_components;
      388 	     j = fixed (bindmap.component (i).text_start, 18);
      389 	     k = fixed (bindmap.component (i).text_lng, 18);
      390 	     if offrel >= j then
      391 		if offrel < j + k then do;		/* We found a match */
      392 		     ptrtmp = addrel (sblkp, bindmap.component (i).name_ptr);
      393 		     ling = fixed (bindmap.component (i).name_lng, 18);
      394 		     call ioa_$rsnnl ("^a$^a|^o", namebuf, mblen, namebuf, var_str, offrel - j);
      395 		     go to trmnme;			/* Go term segment */
      396 		     end;
      397 	end;
      398 
      399 	call ioa_$rsnnl ("^a|^o (not in text)", namebuf, namebuf, offrel);
      400 trmnme:
      401 	if genp ^= null () then call hcs_$terminate_noname (genp, code);
      402 	return (namebuf);
      403 
      404 amu_get_name_$get_l1dir_shortname:
      405      entry (P_segname, P_shortname, P_code);
      406 
      407 dcl  P_segname char (*);
      408 dcl  P_shortname char (*);
      409 dcl  P_code fixed bin (35);
      410 dcl  seg_name char (168);
      411 
      412 	seg_name = P_segname;
      413 	P_code, code = 0;
      414 	dirname, ename = "";
      415 	call get_l1dir_shortname (seg_name, dirname, ename, code);
      416 	if code = 0 then
      417 	     P_shortname = pathname_ (dirname, ename);
      418 	else do;
      419 	     P_shortname = seg_name;
      420 	     code = 0;
      421 	     end;
      422 
      423 	P_code = code;
      424 	return;
      425 
      426 check_if_early_hardcore_seg:
      427      proc (segno, dirname, ename, code);
      428 
      429 dcl  segno fixed bin;
      430 dcl  code fixed bin (35);
      431 dcl  (dirname, ename) char (*);
      432 
      433 dcl  1 pid aligned based,
      434        2 upper bit (18) unal,
      435        2 lower bit (18) unal;
      436 dcl  pid_ptr ptr;
      437 
      438 /*
      439*   If this is the Initializer process, then it's possible he is using early init segs. This happens in
      440*   dumps where it's past the "early dump" stage but not all the way up yet.
      441**/
      442 
      443 /* check if this is the initializer process by looking at the processid */
      444 
      445 	code = 0;
      446 	dirname, ename = "";
      447 	if amu_info.process_info_ptr = null () then do;	/* Can't look */
      448 	     code = error_table_$action_not_performed;
      449 	     return;
      450 	     end;
      451 
      452 	pid_ptr = addr (process_info.pid);
      453 	if pid_ptr -> pid.lower = "777777"b3 then	/* initializer ID				*/
      454 	     call get_init_seg_slt (segno, dirname, ename, code);
      455 
      456      end check_if_early_hardcore_seg;
      457 
      458 get_init_seg_slt:
      459      proc (seg_num, ret_dir, ret_name, code);
      460 dcl  seg_num fixed bin;
      461 dcl  ret_name char (*);
      462 dcl  ret_dir char (*);
      463 dcl  code fixed bin (35);
      464 dcl  dpath char (168) based (dpathp);
      465 dcl  dpathp ptr;
      466 	code = 0;
      467 	if hard_ptrs.sltp ^= null () then
      468 	     sltp = hard_ptrs.sltp;
      469 	else do;
      470 	     code = amu_et_$null_sltp;
      471 	     return;
      472 	     end;
      473 	if hard_ptrs.sltntp ^= null () then
      474 	     names_ptr = hard_ptrs.sltntp;
      475 	else do;
      476 	     call ioa_ ("get_init_seg_slt: No slt name segment");
      477 	     return;
      478 	     end;
      479 	if (seg_num < slt.first_init_seg) | (seg_num > slt.last_init_seg) then do;
      480 	     code = error_table_$action_not_performed;
      481 	     return;
      482 	     end;
      483 	sltep = addr (slt.seg (seg_num));
      484 	namep = addrel (names_ptr, slte.names_ptr);
      485 	ret_name = namep -> segnam.names (1).name;
      486 	if slte.branch_required then do;
      487 	     dpathp = addrel (names_ptr, slte.path_ptr);
      488 	     ret_dir = dpath;
      489 	     end;
      490 	else ret_dir = " ";
      491      end get_init_seg_slt;
      492 
      493 
      494 get_l1dir_shortname:
      495      proc (P_segname, P_dirname, P_ename, P_code);
      496 
      497 dcl  P_segname char (*);
      498 dcl  P_dirname char (*);
      499 dcl  P_ename char (*);
      500 dcl  P_code fixed bin (35);
      501 
      502 dcl  seg_path char (168);
      503 dcl  dirname char (168);
      504 dcl  ename char (32);
      505 dcl  l1dirname char (32);
      506 dcl  (idx, jdx) fixed bin;
      507 dcl  done bit (1);
      508 
      509 	seg_path = P_segname;
      510 	P_dirname, P_ename, dirname, ename = "";
      511 	P_code, code = 0;
      512 
      513 	if substr (seg_path, 1, 6) = "CANNOT" then do;
      514 	     P_ename, P_segname = seg_path;
      515 	     P_code = error_table_$action_not_performed;
      516 	     return;
      517 	     end;
      518 
      519 	if substr (seg_path, 1, 1) = ">" then do;	/* convert level 1 directories to short form */
      520 	     l1dirname = "";			/* set shortname to all blanks first */
      521 	     idx = index (substr (seg_path, 2), ">") - 1;
      522 	     if idx = 0 then
      523 		l1dirname = rtrim (substr (seg_path, 2));
      524 	     else l1dirname = substr (seg_path, 2, idx);
      525 
      526 	     if length (rtrim (l1dirname)) <= 4 then do;	/* Already a shortname just return it */
      527 		goto RETURN_IT;
      528 		end;
      529 
      530 	     done = "0"b;
      531 	     if ndir ^= 0 then do;			/*  if we have any dirs in static structure dinfo. */
      532 		do idx = 1 to ndir while (^done);
      533 		     if l1dir.lg_name (idx) = l1dirname then done = "1"b;
      534 		     if l1dir.sht_name (idx) = l1dirname then done = "1"b;
      535 		end;
      536 		end;
      537 	     if ^done then do;			/* did not find in static dinfo */
      538 		ndir = ndir + 1;			/* increment index */
      539 		l1dir.lg_name (ndir) = l1dirname;	/* set in long name */
      540 		l1dir.sht_name (ndir) = "";		/* initially set short name to blanks */
      541 		call get_system_free_area_ (areap);	/* get a place to store names */
      542 		call hcs_$status_ (">", l1dirname, 0, addr (branch), areap, code);
      543 		if code ^= 0 then goto ST_ERR;	/* if we get error, forget it */
      544 		if branch.nnames > 1 | branch.nrp ^= "0"b then do;
      545 		     nmp = ptr (areap, branch.nrp);	/*  form ptr to names */
      546 		     if substr (l1dirname, 1, 15) = "system_library_" then
      547 			if substr (l1dirname, 1, 16) ^= "system_library_1" then
      548 			     key = substr (l1dirname, 16, 1);
      549 						/* get cmp key for system librarys */
      550 			else key = substr (l1dirname, 1, 1);
      551 						/* use first letter of long name for others */
      552 		     else key = substr (l1dirname, 1, 1);
      553 						/* use first letter of long name for others */
      554 
      555 		     done = "0"b;			/* reset done condition */
      556 		     do idx = 1 to branch.nnames while (^done);
      557 			if substr (dnames (idx), 1, 1) = key then
      558 			     if length (rtrim (dnames (idx))) <= 4 then do;
      559 						/* found name meetin criteria */
      560 				l1dir.sht_name (ndir) = rtrim(dnames (idx));
      561 				done = "1"b;
      562 				end;
      563 		     end;
      564 		     end;
      565 ST_ERR:
      566 		idx = ndir + 1;			/* set correct index */
      567 		end;
      568 
      569 	     if l1dir.sht_name (idx - 1) ^= "" then do;	/* if short name is present */
      570 		dl = length (rtrim (l1dir.lg_name (idx - 1)));
      571 		jdx = length (rtrim (l1dir.sht_name (idx - 1)));
      572 		ling = (length (rtrim (seg_path)) - dl) + 1;
      573 		substr (seg_path, 2, jdx) = substr (l1dir.sht_name (idx - 1), 1, jdx);
      574 		substr (seg_path, jdx + 2) = substr (seg_path, dl + 2);
      575 		substr (seg_path, jdx + ling + 5) = "";
      576 		end;
      577 	     end;
      578 
      579 RETURN_IT:
      580 	call expand_pathname_ (seg_path, dirname, ename, code);
      581 	if code ^= 0 then dirname = seg_path;
      582 	P_dirname = dirname;
      583 	P_ename = ename;
      584 	P_code = code;
      585 
      586      end get_l1dir_shortname;
      587 
      588 get_sup_seg_slt:
      589      proc (seg_num, ret_dir, ret_name, code);
      590 dcl  code fixed bin (35);
      591 dcl  seg_num fixed bin;
      592 dcl  ret_name char (*);
      593 dcl  ret_dir char (*);
      594 dcl  dpath char (168) based (dpathp);
      595 dcl  dpathp ptr;
      596 	code = 0;
      597 	if hard_ptrs.sltp ^= null () then
      598 	     sltp = hard_ptrs.sltp;
      599 	else do;
      600 	     code = amu_et_$null_sltp;
      601 	     return;
      602 	     end;
      603 	if hard_ptrs.sltntp ^= null () then
      604 	     names_ptr = hard_ptrs.sltntp;
      605 	else do;
      606 	     code = amu_et_$null_sltnt;
      607 	     return;
      608 	     end;
      609 	if (seg_num < slt.first_sup_seg) | (seg_num > slt.last_sup_seg) then do;
      610 	     code = error_table_$action_not_performed;
      611 	     return;
      612 	     end;
      613 	sltep = addr (slt.seg (seg_num));
      614 	namep = addrel (names_ptr, slte.names_ptr);
      615 	ret_name = namep -> segnam.names (1).name;
      616 	if slte.branch_required then do;
      617 	     dpathp = addrel (names_ptr, slte.path_ptr);
      618 	     ret_dir = dpath;
      619 	     end;
      620 	else ret_dir = " ";
      621      end get_sup_seg_slt;
      622 
      623 
      624 get_kstp:
      625      proc returns (bit (1));
      626 	call amu_$translate_get (amu_info_ptr, hardcore_info.segno.kst, translation_ptr, code);
      627 
      628 	if translation_ptr = null then goto Trans_it;
      629 	if translation.flags.two_part then do;
      630 Trans_it:						/*             if amu_info.type ^= FDUMP_PROCESS_TYPE then return ("0"b); */
      631 	     translation_ptr = addr (trans_space);
      632 	     code = 0;
      633 	     call amu_$fdump_translate_contiguous (amu_info_ptr, baseptr (hardcore_info.segno.kst), translation_ptr,
      634 		code);
      635 	     if code ^= 0 then return ("0"b);
      636 
      637 	     call amu_$translate_force_add (amu_info_ptr, translation_ptr, hardcore_info.segno.kst, code);
      638 	     if code ^= 0 then return ("0"b);
      639 	     end;
      640 
      641 	kstp = translation.part1.ptr;
      642 	return ("1"b);
      643      end get_kstp;
      644 
      645 /* kst_name - internal procedure to find name of segment in kst of dump, from live system */
      646 
      647 kst_name:
      648      proc (P_segn, P_kstp);
      649 
      650 dcl  P_segn fixed bin;
      651 dcl  P_kstp ptr;
      652 
      653 dcl  segn fixed bin;
      654 dcl  uid_path (16) bit (36) aligned;
      655 dcl  code fixed bin (35);
      656 dcl  expanded_path char (168);
      657 dcl  amu_$kst_util_expand_uid_path entry (ptr, (16) bit (36) aligned, char (*), fixed bin (35));
      658 dcl  amu_$kst_util_segno_to_uid_path entry (ptr, fixed bin, (16) bit (36) aligned, fixed bin (35));
      659 
      660 	segn = P_segn;
      661 	kstp = P_kstp;				/* copy ptr for neater code */
      662 	code = 0;
      663 	expanded_path = "";
      664 	uid_path (*) = ""b;
      665 	if segn < kst.lowseg | segn > kst.highseg then return;
      666 						/* no point in using KST */
      667 	call amu_$kst_util_segno_to_uid_path (kstp, segn, uid_path, code);
      668 	if code ^= 0 then return;
      669 	call amu_$kst_util_expand_uid_path (kstp, uid_path, expanded_path, code);
      670 	if code ^= 0 then return;
      671 	namebuf = expanded_path;
      672 
      673      end kst_name;
      674 
      675 /* get_ast_name - internal procedure to find name of segment in sstnt of dump */
      676 
      677 get_ast_name:
      678      proc (a_astep, a_sstp, a_sstnp, retstr);
      679 
      680 dcl  (a_astep, a_sstp, a_sstnp) ptr;
      681 
      682 dcl  retstr char (*);
      683 
      684 	astep = a_astep;
      685 	sstp = a_sstp;
      686 	sstnp = a_sstnp;
      687 
      688 	if fixed (rel (astep), 18) < fixed (rel (sstp -> sst.astap), 18) then do;
      689 fail:
      690 	     retstr = "CANNOT GET PATHNAME";
      691 	     return;
      692 	     end;
      693 
      694 	if rel (astep) = rel (sstp -> sst.root_astep) then do;
      695 	     retstr = ">";
      696 	     return;
      697 	     end;
      698 
      699 	retstr = recurse (astep, length (retstr));
      700 	return;
      701 
      702 recurse:
      703 	proc (astep, namel) returns (char (*));
      704 
      705 dcl  (ptsi, ra) fixed bin;
      706 dcl  namel fixed bin;
      707 dcl  sstnt_idx fixed bin;
      708 dcl  astep ptr,
      709      name char (32) varying;
      710 
      711 	     ra = fixed (rel (astep), 18);		/* for ease */
      712 	     if ra < fixed (rel (sstp -> sst.astap), 18) then go to fail;
      713 	     do ptsi = 3 to 0 by -1 while (ra < sstnp -> sstnt.ast_offsets (ptsi));
      714 	     end;
      715 	     if ptsi < 0 then go to fail;
      716 
      717 	     if ptsi ^= fixed (astep -> aste.ptsi, 2) then go to fail;
      718 
      719 	     sstnt_idx =
      720 		divide (ra - sstnp -> sstnt.ast_offsets (ptsi), sstnp -> sstnt.ast_sizes (ptsi), 18, 0)
      721 		+ sstnp -> sstnt.ast_name_offsets (ptsi);
      722 
      723 	     if length (sstnp -> sstnt.names (sstnt_idx)) < 0
      724 		| length (sstnp -> sstnt.names (sstnt_idx)) > maxlength (name) then
      725 		name = "CANNOT-GET";		/* sstnt has garbage */
      726 
      727 	     else name = sstnp -> sstnt.names (sstnt_idx);
      728 
      729 	     if length (name) = 0 then name = "CANNOT-GET";
      730 
      731 	     if astep -> aste.par_astep = rel (sstp -> sst.root_astep) then do;
      732 		if length (name) >= namel then
      733 		     return ("");
      734 		else return (">" || name);
      735 		end;
      736 
      737 
      738 	     if namel = 1 then return (">");
      739 	     if length (name) >= namel then return (recurse (ptr (astep, astep -> aste.par_astep), namel - 1) || ">");
      740 
      741 	     return (recurse (ptr (astep, astep -> aste.par_astep), namel - length (name) - 1) || ">" || name);
      742 	end;
      743      end get_ast_name;
      744 
      745 get_vtoc_pathname: proc;
      746 
      747 /* get_vtoc_pathname extracted from Bernard Greenberg's 05/20/76 vtoc_pathname */
      748 
      749 dcl  nfsw bit (1) init ("0"b);
      750 dcl  (ioa_, ioa_$rsnnl) entry options (variable);
      751 dcl  1 local_vtoce like vtoce aligned;
      752 dcl  check_gate_access_ entry (char(*), ptr, fixed bin(35));
      753 dcl  phcs_$get_vtoce entry (fixed bin, fixed bin, ptr, fixed bin (35));
      754 dcl  pn char (168);
      755 dcl  vpn_cv_uid_path_$ent entry (ptr, char (*), bit (36), fixed bin (35));
      756 dcl  myname char (19) init ("amu_get_name_");
      757 dcl  (opvtx, ovtocx) fixed bin;
      758 
      759      vtocep = addr (local_vtoce);
      760      opvtx = astep->aste.pvtx;
      761      ovtocx = astep->aste.vtocx;
      762      call check_gate_access_ ("phcs_", null, code);
      763      if code ^= 0 then return;
      764      call phcs_$get_vtoce (opvtx, ovtocx, vtocep, code);
      765      if code ^= 0 then do;
      766 	call ioa_ ("^-^a: Error getting vtoce ^o on pvtx ^o.", myname, astep->aste.vtocx, astep->aste.pvtx);
      767 	return;
      768      end;
      769 
      770      if vtoce.uid = "0"b then do;
      771 	if nfsw then return;
      772 	call ioa_ ("^-^a: Error: Vtocx ^o on pvtx ^o is free.", myname, astep->aste.vtocx, astep->aste.pvtx);
      773           return;
      774      end;
      775 
      776      pn = "";
      777      call vpn_cv_uid_path_$ent (addr (vtoce.uid_path), pn, vtoce.uid, code);
      778      if code ^= 0 then
      779 	call ioa_ ("^-^a: Error: Cannot completely convert uid path", myname);
      780      call ioa_$rsnnl ("^a", namebuf, 0, pn);
      781      return;
      782 end get_vtoc_pathname;
      783 
  1     1 /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  1     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  1     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  1     4 
  1     5 dcl  vtocep ptr;
  1     6 
  1     7 dcl 1 vtoce based (vtocep) aligned,
  1     8 
  1     9 
  1    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  1    11 
  1    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  1    13 
  1    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  1    16     2 records bit (9),				/* number of records used by the seg in second storage */
  1    17     2 pad2 bit (9),
  1    18 
  1    19     2 dtu bit (36),					/* date and time segment was last used */
  1    20 
  1    21     2 dtm bit (36),					/* date and time segment was last modified */
  1    22 
  1    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    24     2 deciduous bit (1),				/* true if hc_sdw */
  1    25     2 nid bit (1),					/* no incremental dump switch */
  1    26     2 dnzp bit (1),					/* Dont null zero pages */
  1    27     2 gtpd bit (1),					/* Global transparent paging device */
  1    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  1    29     2 damaged bit (1),				/* TRUE if contents damaged */
  1    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  1    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  1    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  1    33     2 pad3 bit (8),
  1    34     2 dirsw bit (1),				/* directory switch */
  1    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  1    36     2 pad4 bit (16)) unaligned,			/* not used */
  1    37 
  1    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  1    39 
  1    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    41 
  1    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    43 
  1    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  1    45 
  1    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  1    47 
  1    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  1    49 
  1    50 
  1    51 
  1    52 
  1    53 
  1    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  1    55 
  1    56     2 pad6 (10) bit (36),				/* not used */
  1    57 
  1    58     2 ncd bit (1),					/* no complete dump switch */
  1    59     2 pad7 bit (17),
  1    60     2 pad8 bit (18),
  1    61 
  1    62     2 dtd bit (36),					/* date-time-dumped */
  1    63 
  1    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  1    65 
  1    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  1    67 
  1    68 
  1    69 
  1    70 
  1    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  1    72 
  1    73     2 primary_name char (32),				/* primary name of the segment */
  1    74 
  1    75     2 time_created bit (36),				/* time the segment was created */
  1    76 
  1    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  1    78 
  1    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  1    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  1    81 
  1    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  1    83 
  1    84     2 access_class bit (72),				/* access class in branch */
  1    85     2 perm_flags aligned,
  1    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  1    87       3 pad9 bit (35) unal,
  1    88     2 owner bit (36);				/* pvid of this volume */
  1    89 
  1    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  1    91 
  1    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  1    93     2 pad1 bit (7*36),
  1    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    95     2 pad2 bit (184*36);
  1    96 
  1    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      784 
      785 
  2     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     7*     Add support for subvolumes.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  2    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  2    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  2    14 
  2    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  2    16 
  2    17 dcl  dtp ptr,
  2    18      dtep ptr,
  2    19      lvep ptr;
  2    20 
  2    21      
  2    22 
  2    23 dcl 1 dt based (dtp) aligned,
  2    24 
  2    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  2    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  2    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  2    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  2    29     2 version fixed bin init (1),
  2    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  2    31     2 pad (2) bit (36),
  2    32     2 array (0 refer (dt.max_n_entries)) like dte,
  2    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  2    34 
  2    35 dcl 1 dte based (dtep) aligned,
  2    36     2 drive_name char (8),				/* device name */
  2    37     (2 device_type fixed bin (8),			/* device type */
  2    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  2    39     2 known bit (1),				/* TRUE if label has been read and checked */
  2    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  2    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  2    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  2    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  2    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  2    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  2    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  2    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  2    48     2 is_sub_vol bit (1),
  2    49     2 pad bit (3),
  2    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  2    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  2    52     2 sv_num  fixed bin unal,				/* this sv number */
  2    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  2    54     2 sv_name   char (2) aligned,
  2    55     2 pvid bit (36),				/* physical volume ID */
  2    56     2 pvname char (32);				/* Physical volume name. */
  2    57 
  2    58 dcl 1 lve based (lvep) aligned,
  2    59     2 lvid bit (36),				/* logical volume ID */
  2    60     (2 used bit (1),				/* TRUE if entry used */
  2    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  2    62     2 public bit (1),				/* TRUE for public vol */
  2    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  2    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  2    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  2    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  2    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  2    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  2    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  2    70     2 pad bit (26)) unal,
  2    71     2 lvname char (32),				/* Logical volume name */
  2    72     2 min_access_class bit (72),			/* Security stuff */
  2    73     2 max_access_class bit (72);			/* .. */
  2    74 
  2    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      786 
      787 
  3     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  3     2 
  3     3 /* This structure contains information about the hardcore supervisor address
  3     4*   space for an address translation. */
  3     5 
  3     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  3     7 
  3     8     2 pointers,					/* assorted pointers to various useful items */
  3     9       3 slt aligned,				/* SLT */
  3    10         4 fptr pointer unaligned,			/* address in foreign address space */
  3    11         4 lptr pointer unaligned,			/* location in local address space */
  3    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  3    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  3    14 
  3    15       3 sst aligned like hardcore_info.slt,		/* SST */
  3    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  3    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  3    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  3    19 
  3    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  3    21       3 prds fixed bin (15),				/* segno of PRDS */
  3    22       3 dseg fixed bin (15),				/* DSEG */
  3    23       3 pds fixed bin (15),				/* PDS */
  3    24       3 kst fixed bin (15),				/* KST */
  3    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  3    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  3    27 
  3    28     2 apt,					/* information about the APT */
  3    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  3    30       3 local_ptr pointer unaligned,
  3    31       3 count fixed bin,				/* number of APTEs */
  3    32       3 size fixed bin,				/* size of a single APTE */
  3    33 
  3    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  3    35 
  3    36     2 pad1 fixed bin;
  3    37 
  3    38 dcl hardcore_cur_ptr ptr;
  3    39 
  3    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  3    41     2 sltp ptr,
  3    42     2 sltntp ptr,
  3    43     2 defp ptr,
  3    44     2 sstp ptr,
  3    45     2 tc_datap ptr,
  3    46     2 sstntp ptr,
  3    47     2 uptp ptr;
  3    48 	
  3    49     
  3    50 
  3    51 
  3    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      788 
      789 
  4     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  4     2 
  4     3 dcl 1 amu_info aligned based (amu_info_ptr),
  4     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  4     5     2 flags aligned,
  4     6       3 early_dump bit(1) unal,
  4     7       3 pad  bit(35) unal,
  4     8     2 type fixed bin unal,				/* One of the types below */
  4     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  4    10     2 chain,					/* a chain of all the amu_info's which exist */
  4    11       3 prev pointer unaligned,
  4    12       3 next pointer unaligned,
  4    13 
  4    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  4    15 
  4    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  4    17 						/*   SEE: amu_translation.incl.pl1 */
  4    18     2 fdump_info_ptr pointer, 			
  4    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  4    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  4    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  4    22 						/* See: amu_old_uid_table			*/
  4    23 	
  4    24 
  4    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  4    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  4    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  4    28 						/*   SEE: amu_copy_info.incl.pl1 */
  4    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  4    30 						/*   SEE: amu_process_info.incl.pl1 */
  4    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  4    32 
  4    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  4    34 
  4    35     2 error_info,					/* various info about how amu_error_ is to behave */
  4    36       3 error_flags aligned,
  4    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  4    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  4    39         4 pad bit (34) unaligned,
  4    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  4    41     2 definitions_info_ptr ptr;
  4    42 
  4    43 dcl  amu_area area based (amu_info.area_ptr);
  4    44 
  4    45 dcl  amu_info_ptr pointer;
  4    46 
  4    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  4    48      FDUMP_PROCESS_TYPE	init (1038),
  4    49      ONLINE_TYPE		init (1039),
  4    50      ONLINE_PROCESS_TYPE	init (1040),
  4    51      NETWORK_FDUMP_TYPE	init (1041),
  4    52      NETWORK_ONLINE_TYPE	init (1042),
  4    53      SAVED_PROC_TYPE	init (1043),
  4    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  4    55 
  4    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  4    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  4    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  4    59 
  4    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  4    61 
  4    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      790 
      791 
  5     1 /*	BEGIN INCLUDE FILE amu_translation.incl.pl1	*/
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(87-01-16,Parisek), approve(87-07-16,MCR7746),
  5     7*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
  5     8*     Added the "replaced" field to record whether a segment was replaced by
  5     9*     another segment via the "replace" request.
  5    10*                                                   END HISTORY COMMENTS */
  5    11 
  5    12 
  5    13 dcl 1 translation_table aligned based (amu_info.translation_table_ptr),
  5    14     2 n_entries fixed bin,
  5    15     2 max_entries fixed bin,
  5    16 
  5    17     2 valid_array aligned,				/* one bit for each valid segno */
  5    18       3 valid (0 : 4095) bit (1) unaligned,
  5    19     2 used_array aligned,				/* one bit for each existing translation */
  5    20       3 used (0 : 4095) bit (1) unaligned,
  5    21 
  5    22     2 array (alloc_translation_table_max_entries refer (translation_table.max_entries)) like translation;
  5    23 
  5    24 dcl 1 translation aligned based (translation_ptr),	/* a single translation */
  5    25     2 segno fixed bin (18) unsigned unaligned,		/* foreign segno for this translation */
  5    26     2 flags unaligned,
  5    27       3 two_part bit (1) unaligned,			/* segment is in two pieces -- from an FDUMP */
  5    28       3 in_dump bit (1) unaligned,			/* segment is part of an FDUMP image */
  5    29       3 in_temp_seg bit (1) unaligned,			/* segment is a copy at the base of a temp segment */
  5    30       3 in_perm_seg bit (1) unaligned,			/* segment is in the file system */
  5    31       3 in_dp_dir bit (1) unaligned,
  5    32       3 replaced bit (1) unaligned,
  5    33       3 pad bit (12) unaligned,
  5    34     2 part1,					/* pointer to first (possibly only) part of segment */
  5    35       3 ptr pointer unaligned,
  5    36       3 lth fixed bin (19),
  5    37     2 part2 like translation.part1;
  5    38 
  5    39 dcl  alloc_translation_table_max_entries fixed bin;
  5    40 dcl  translation_ptr pointer;
  5    41 
  5    42 /*	END INCLUDE FILE amu_translation.incl.pl1	*/
      792 
      793 
  6     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  6     2 
  6     3 /* Template for an AST entry. Length = 12 words. */
  6     4 
  6     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  6     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  6     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  6     8 
  6     9 dcl  astep ptr;
  6    10 
  6    11 dcl 1 aste based (astep) aligned,
  6    12 
  6    13     (2 fp bit (18),					/* forward  used list rel pointer */
  6    14     2 bp bit (18),					/* backward used list rel pointer */
  6    15 
  6    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  6    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  6    18 
  6    19     2 strp bit (18),				/* rel pointer to process trailer */
  6    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  6    21 
  6    22     2 uid bit (36),					/* segment unique id */
  6    23 
  6    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  6    25     2 pvtx fixed bin (8),				/* physical volume table index */
  6    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  6    27 
  6    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  6    29     2 init bit (1),					/* used bit - insure 1 lap */
  6    30     2 gtus bit (1),					/* global transparent usage switch */
  6    31     2 gtms bit (1),					/* global transparent modified switch */
  6    32     2 hc bit (1),					/* hard core segment */
  6    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  6    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  6    35     2 write_access_on bit (1),			/* any sdw allows write access */
  6    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  6    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  6    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  6    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  6    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  6    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  6    42     2 pad1 bit (2),					/* OO */
  6    43     2 dius bit (1),					/* dumper in use switch */
  6    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  6    45     2 dmpr_pad bit (1),
  6    46     2 ehs bit (1),					/* entry hold switch */
  6    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  6    48     2 dirsw bit (1),				/* directory switch */
  6    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  6    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  6    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  6    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  6    53 
  6    54     2 dtu bit (36),					/* date and time segment last used */
  6    55 
  6    56     2 dtm bit (36),					/* date and time segment last modified */
  6    57 
  6    58 
  6    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  6    60 
  6    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  6    62 
  6    63     2 csl bit (9),					/* current segment length in 1024 words units */
  6    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  6    65     2 fms bit (1),					/* file modified switch */
  6    66     2 npfs bit (1),					/* no page fault switch */
  6    67     2 gtpd bit (1),					/* global transparent paging device switch */
  6    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  6    69     2 per_process bit (1),				/* use master quota for this entry */
  6    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  6    71     2 pad2 bit (2),
  6    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  6    73     2 np bit (9),					/* number of pages in core */
  6    74 
  6    75 
  6    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  6    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  6    78     2 damaged bit (1),				/* PC declared segment unusable */
  6    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  6    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  6    81     2 pad3 bit (6),					/* OOOOOOOOO */
  6    82     2 ptsi bit (2),					/* page table size index */
  6    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  6    84 
  6    85 
  6    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  6    87 
  6    88 
  6    89 dcl 1 aste_part aligned based (astep),
  6    90 
  6    91     2 one bit (36) unaligned,				/* fp and bp */
  6    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  6    93     2 three bit (8) unaligned;			/* ptsi and marker */
  6    94 
  6    95 
  6    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  6    97     2 pad1 bit (8*36),
  6    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  6    99     2 pad2 bit (3*36);
  6   100 
  6   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      794 
      795 
  7     1 	/* BEGIN INCLUDE SEGMENT ... bind_map.incl.pl1 Michael J. Spier, 4/29/71  */
  7     2 	/* last modified  April, 1972 by M. Weaver */
  7     3 
  7     4 declare	1 bindmap aligned based(bmp),
  7     5 
  7     6 	2 dcl_version fixed bin,		/* version number of this structure = 1 */
  7     7 	2 n_components fixed bin,		/* number of entries in this array */
  7     8 	2 component(0 refer(bindmap.n_components)) aligned,
  7     9 	  3 name,				/* objectname of component object */
  7    10 	    4 name_ptr bit(18) unaligned,	/* pointer to name string */
  7    11 	    4 name_lng bit(18) unaligned,	/* length of name string */
  7    12 	  3 comp_name char(8) aligned,	/* name of component's compiler */
  7    13 	  3 text_start bit(18) unaligned,	/* text section relocation counter */
  7    14 	  3 text_lng bit(18) unaligned,	/* length of text section */
  7    15 	  3 stat_start bit(18) unaligned,	/* internal static relocation counter */
  7    16 	  3 stat_lng bit(18) unaligned,	/* length of internal static */
  7    17 	  3 symb_start bit(18) unaligned,	/* symbol section relocation counter */
  7    18 	  3 symb_lng bit(18) unaligned,	/* length of symbol section */
  7    19 	  3 defblock_ptr bit(18) unaligned,	/* pointer to components definition block */
  7    20 	  3 n_blocks bit(18) unaligned,	/* number of symbol blocks the component has */
  7    21 	2 bf_name aligned,			/* name of bindfile */
  7    22 	  3 bf_name_ptr bit(18) unaligned,	/* pointer to name string */
  7    23 	  3 bf_name_lng bit(18) unaligned,	/* length of name string */
  7    24 	2 bf_date_up char(24),		/* date updated in archive */
  7    25 	2 bf_date_mod char(24);		/* date last modified */
  7    26 
  7    27 /* END INCLUDE SEGMENT ... bind_map.incl.pl1 */
      796 
      797 
  8     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  8     2 
  8     3 
  8     4 /* Template for an entry. Length = 38 words */
  8     5 
  8     6 dcl  ep ptr;
  8     7 
  8     8 dcl 1 entry based (ep) aligned,
  8     9 
  8    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  8    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  8    12 
  8    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  8    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  8    15 
  8    16     2 uid bit (36),					/* unique id of entry */
  8    17 
  8    18     2 dtem bit (36),				/* date-time entry modified */
  8    19 
  8    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  8    21     2 pad0 bit (17),
  8    22     2 nnames fixed bin (17),				/* number of names for this entry */
  8    23 
  8    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  8    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  8    26 
  8    27     2 author,					/* user who created branch */
  8    28       3 pers_rp bit (18),				/* name of user who created branch */
  8    29       3 proj_rp bit (18),				/* project of user who created branch */
  8    30 
  8    31       3 tag char (1),				/* tag of user who created branch */
  8    32       3 pad1 char (3),
  8    33 
  8    34     2 primary_name bit (504),				/* first name on name list */
  8    35 
  8    36     2 dtd bit (36),					/* date time dumped */
  8    37 
  8    38     2 pad2 bit (36),
  8    39 
  8    40 
  8    41 /* the declarations below are for branch only */
  8    42 
  8    43 
  8    44     2 pvid bit (36),				/* physical volume id */
  8    45 
  8    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  8    47     2 pad3 bit (18),
  8    48 
  8    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  8    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  8    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  8    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  8    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  8    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  8    55     2 audit_flag bit (1),				/* segment must be audited for security */
  8    56     2 security_oosw bit (1),				/* security out of service switch */
  8    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  8    58     2 master_dir bit (1),				/* TRUE for master directory */
  8    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  8    60     2 pad4 bit (11),
  8    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  8    62 
  8    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  8    64 
  8    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  8    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  8    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  8    68 
  8    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  8    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  8    71 
  8    72     2 bc_author,					/* user who last set the bit count */
  8    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  8    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  8    75 
  8    76       3 tag char (1),				/* tag of user who set the bit count */
  8    77       3 pad5 bit (2),
  8    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  8    79 
  8    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  8    81 
  8    82     2 pad6 bit (36),
  8    83 
  8    84     2 checksum bit (36),				/* checksum from dtd */
  8    85 
  8    86     2 owner bit (36);				/* uid of containing directory */
  8    87 
  8    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      798 
      799 
  9     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  9     2 /* Modified 8/74 for NSS */
  9     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  9     4 /* Modified 3/82 BIM for change pclock */
  9     5 /* format: style3 */
  9     6 
  9     7 /* Template for the directory header. Length = 64 words. */
  9     8 
  9     9 dcl  dp ptr;
  9    10 
  9    11 dcl 1 dir based (dp) aligned,
  9    12 
  9    13    2 modify bit (36),				/* Process ID of last modifier */
  9    14    2 type bit (18) unaligned,			/* type of object = dir header */
  9    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  9    16     2 dtc (3),					/* date-time checked by salvager array */
  9    17       3 date bit (36),				/* the date */
  9    18       3 error bit (36),				/* what errors were discovered */
  9    19 
  9    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  9    21 
  9    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  9    23 
  9    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  9    25 
  9    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  9    27 
  9    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  9    29     2 version_number fixed bin (17),			/* version number of header */
  9    30 
  9    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  9    32     2 pad2 bit (18),
  9    33 
  9    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  9    35     2 pad3 bit (18),
  9    36 
  9    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  9    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  9    39 
  9    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  9    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  9    42 
  9    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  9    44     2 dir_count fixed bin (17),			/* number of directory branches */
  9    45 
  9    46     2 lcount fixed bin (17),				/* number of links */
  9    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  9    48 
  9    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  9    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  9    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  9    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  9    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  9    54     2 pad4 bit (14),
  9    55 
  9    56     2 iacl_count (0:7),
  9    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  9    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  9    59 
  9    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  9    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  9    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  9    63 
  9    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  9    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  9    66 
  9    67     2 htsize fixed bin (17),				/* size of hash table */
  9    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  9    69 
  9    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  9    71     2 pad6 fixed bin (17),
  9    72 
  9    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  9    74     2 pad7 bit (18)) unaligned,
  9    75 
  9    76     2 dts bit (36),					/* date-time directory last salvaged */
  9    77 
  9    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  9    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  9    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  9    81     2 checksum bit (36),				/* checksummed from uid on */
  9    82     2 owner bit (36);				/* uid of parent dir */
  9    83 
  9    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  9    85 
  9    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      800 
      801 
 10     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
 10     2 
 10     3 /* Template for names of branches or links. Length = 14 words. */
 10     4 
 10     5 dcl np ptr;
 10     6 
 10     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
 10     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
 10     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
 10    10 
 10    11     2 type bit (18) unaligned,			/* type = dir name */
 10    12     2 size fixed bin (17) unaligned,			/* size of dir name */
 10    13 
 10    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
 10    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
 10    16 
 10    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
 10    18     2 pad3 bit (18) unal,
 10    19 
 10    20     2 name char(32) aligned,
 10    21 
 10    22     2 checksum bit (36),				/* checksum from entry_rp */
 10    23 
 10    24     2 owner bit (36);				/* uid of entry */
 10    25 
 10    26 
 10    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      802 
      803 
 11     1 /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
 11     2 
 11     3 /*
 11     4*Modified March 1976 by R. Bratt 
 11     5*Modified November 1984 to remove hdr, Keith Loepere. */
 11     6 
 11     7 
 11     8 /****^  HISTORY COMMENTS:
 11     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
 11    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
 11    11*     Add warning on use of kste.entryp.
 11    12*                                                   END HISTORY COMMENTS */
 11    13 
 11    14 
 11    15 dcl  pds$kstp ext ptr,
 11    16     (kstp, kstep) ptr;
 11    17 
 11    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
 11    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
 11    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
 11    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
 11    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
 11    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
 11    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
 11    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
 11    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
 11    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
 11    28     2 template bit (1) unaligned,			/* this is a template kst if set */
 11    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
 11    30     2 unused_2 bit (9) unaligned,
 11    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
 11    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
 11    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
 11    34     2 end_of_kst bit (36);
 11    35 
 11    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
 11    37     2 fp bit (18) unaligned,				/* forward rel pointer */
 11    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
 11    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
 11    40     2 entryp ptr unaligned,				/* branch pointer */
 11    41 						/* See WARNING below for requirements to use entryp. */
 11    42     2 uid bit (36) aligned,				/* unique identifier */
 11    43     2 access_information unaligned,
 11    44       3 dtbm bit (36),				/* date time branch modified */
 11    45       3 extended_access bit (33),			/* extended access from the branch */
 11    46       3 access bit (3),				/* rew */
 11    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
 11    48     2 pad1 bit (3) unaligned,
 11    49     2 flags unaligned,
 11    50       3 dirsw bit (1),				/* directory switch */
 11    51       3 allow_write bit (1),				/* set if initiated with write permission */
 11    52       3 priv_init bit (1),				/* privileged initiation */
 11    53       3 tms bit (1),				/* transparent modification switch */
 11    54       3 tus bit (1),				/* transparent usage switch */
 11    55       3 tpd bit (1),				/* transparent paging device switch */
 11    56       3 audit bit (1),				/* audit switch */
 11    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
 11    58       3 pad bit (3),
 11    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
 11    60 
 11    61 
 11    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    63 /*							       */
 11    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
 11    65 /* entry associated with the kst entry, you must first validate its value    */
 11    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
 11    67 /* the containing directory.  The containing directory must remain locked    */
 11    68 /* during the entire period when kste.entryp and the directory entry are     */
 11    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
 11    70 /* longer be used to get a pointer to the entry within the unlocked	       */
 11    71 /* directory since the dir entry could have been moved within the directory  */
 11    72 /* by another processor.					       */
 11    73 /*							       */
 11    74 /* If you only need a pointer to the directory containing the associated     */
 11    75 /* dir entry (but not to the dir entry itself), you can use:	       */
 11    76 /*    pointer (kste.entryp, 0)				       */
 11    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
 11    78 /*							       */
 11    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11    80 
 11    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      804 
      805 
 12     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
 12     2*coded February 8, 1972 by Michael J. Spier	*/
 12     3 /* modified May 26, 1972 by M. Weaver */
 12     4 /* modified 15 April, 1975 by M. Weaver */
 12     5 
 12     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
 12     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
 12     8 	2 textp pointer,			/* pointer to beginning of text section */
 12     9 	2 defp pointer,			/* pointer to beginning of definition section */
 12    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
 12    11 	2 statp pointer,			/* pointer to beginning of static section */
 12    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
 12    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
 12    14 	2 tlng fixed bin,			/* length in words of text section */
 12    15 	2 dlng fixed bin,			/* length in words of definition section */
 12    16 	2 llng fixed bin,			/* length in words of linkage section */
 12    17 	2 ilng fixed bin,			/* length in words of static section */
 12    18 	2 slng fixed bin,			/* length in words of symbol section */
 12    19 	2 blng fixed bin,			/* length in words of break map */
 12    20 	2 format,				/* word containing bit flags about object type */
 12    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
 12    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
 12    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
 12    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
 12    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
 12    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
 12    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
 12    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
 12    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
 12    30 	  3 pad bit(27) unaligned,
 12    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
 12    32 	2 textlinkp pointer,		/* ptr to first link in text */
 12    33 
 12    34 	/* LIMIT OF BRIEF STRUCTURE */
 12    35 
 12    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
 12    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
 12    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
 12    39 	2 cvers aligned,			/* generator version name in printable char string form */
 12    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
 12    41 	  3 length bit(18) unaligned,		/* length of name in characters */
 12    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
 12    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
 12    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
 12    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
 12    46 
 12    47 	/* LIMIT OF DISPLAY STRUCTURE */
 12    48 
 12    49 	2 rel_text pointer,			/* pointer to text section relocation info */
 12    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
 12    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
 12    52 	2 rel_static pointer,		/* pointer to static section relocation info */
 12    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
 12    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
 12    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
 12    56 					/* currently not used by system */
 12    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
 12    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
 12    59 
 12    60 declare	object_info_version_2 fixed bin int static init(2);
 12    61 
 12    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      806 
      807 
 13     1 /*	BEGIN INCLUDE FILE amu_process_info.incl.pl1	*/
 13     2 
 13     3 /* This structure describes information about a single process in an address
 13     4*   translation. It is only relevant for translations involving the online system
 13     5*   or an FDUMP. */
 13     6 
 13     7 dcl 1 process_info aligned based (amu_info.process_info_ptr), /* information about a single process */
 13     8     2 pid bit (36) aligned,				/* process_id of this process */
 13     9     2 address_map_ptr pointer unaligned,		/* pointer to address map */
 13    10     2 idx fixed bin,				/* index of process in FDUMP, or apte index if online */
 13    11     2 state fixed bin,				/* state, from the APTE -- only good for FDUMP */
 13    12 
 13    13     2 dbr fixed bin (71),				/* DBR of this process */
 13    14 
 13    15     2 apte aligned, 				/* pointer to this process's APTE */
 13    16       3 foreign_ptr pointer unaligned,
 13    17       3 local_ptr pointer unaligned,
 13    18     2 prds aligned like process_info.apte, 		/* and PRDS, IFF it has one (is running) -- volatile */
 13    19     2 dseg aligned like process_info.apte, 		/* DSEG -- These values must be constantly recalculated */
 13    20     2 pds aligned like process_info.apte,		/* PDS --- for an online process, if phcs transparency */
 13    21     2 kst aligned like process_info.apte,		/* KST --- is not in use. */
 13    22 
 13    23     2 dump_segx,					/* index of first and last seg belonging to this */
 13    24       3 first fixed bin,				/* process in bos_dump.seg_array, or zero if none */
 13    25       3 last fixed bin,				/* this information is only valid for a process in a dump */
 13    26 
 13    27     2 pad1 fixed bin;
 13    28 
 13    29 /*	END INCLUDE FILE amu_process_info.incl.pl1	*/
      808 
      809 
 14     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
 14     2 
 14     3 dcl  sdwp ptr;
 14     4 
 14     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
 14     6 
 14     7    (2 add bit (24),					/* main memory address of page table */
 14     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
 14     9     2 df bit (1),					/* directed fault bit (0 => fault) */
 14    10     2 df_no bit (2),				/* directed fault number */
 14    11 
 14    12     2 pad1 bit (1),
 14    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
 14    14     2 access,					/* access bits */
 14    15       3 read bit (1),				/* read permission bit */
 14    16       3 execute bit (1),				/* execute permission bit */
 14    17       3 write bit (1),				/* write permission bit */
 14    18       3 privileged bit (1),				/* privileged bit */
 14    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
 14    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
 14    21     2 cache bit (1),				/* cache enable bit */
 14    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
 14    23 
 14    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
 14    25 
 14    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      810 
      811 
 15     1 /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
 15     2 
 15     3      
 15     4 
 15     5 /****^  HISTORY COMMENTS:
 15     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
 15     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
 15     8*     Modified to add INITIATED_SEGS type.
 15     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
 15    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
 15    11*     Added uid to sl_info structure.
 15    12*                                                   END HISTORY COMMENTS */
 15    13 
 15    14 
 15    15 declare 1 sl_info	      aligned based (sl_info_p),
 15    16 	     2 version	      fixed binary,		/* Must be 1 */
 15    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
 15    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
 15    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
 15    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
 15    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
 15    22 	       3 type	      fixed binary,		/* Type of search path */
 15    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
 15    24 	       3 uid	      bit (36),		/* Unique ID */
 15    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
 15    26 
 15    27      declare sl_info_num_paths      fixed binary;
 15    28      declare sl_info_p	      pointer;
 15    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
 15    30 
 15    31 /* Keyword Types */
 15    32 
 15    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
 15    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
 15    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
 15    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
 15    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
 15    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
 15    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
 15    40 
 15    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
      812 
      813 
 16     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
 16     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
 16     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
 16     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
 16     5 
 16     6 dcl  sst_seg$ external;
 16     7 dcl  sstp ptr;
 16     8 
 16     9 dcl 1 sst based (sstp) aligned,
 16    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
 16    11 
 16    12 /* SST HEADER */
 16    13 
 16    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
 16    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
 16    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
 16    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
 16    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
 16    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
 16    20 
 16    21     2 ptl bit (36),					/* global page table loop lock */
 16    22     2 astl bit (36),				/* global ast allocation block lock */
 16    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
 16    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
 16    25     2 nused fixed bin,				/* number of pages on used list */
 16    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
 16    27     2 tfreep ptr,					/* pointer to first trailer on free list */
 16    28 
 16    29     2 astap ptr,					/* aste array pointer */
 16    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
 16    31     2 astsize fixed bin,				/* size of an AST entry */
 16    32     2 cmesize fixed bin,				/* size of a CME entry */
 16    33     2 root_astep ptr,				/* pointer to the root AST entry */
 16    34 
 16    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
 16    36     2 level (0:3),					/* per-list information about ASTE's */
 16    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
 16    38 
 16    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
 16    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
 16    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
 16    42     2 strsize fixed bin,				/* Trailer size in words. */
 16    43 
 16    44 /* CORE MAP HEADER */
 16    45 
 16    46     2 cmp ptr,					/* pointer to start of core map */
 16    47     2 usedp bit (18),				/* pointer to first used core block */
 16    48     2 wtct fixed bin,				/* count of pages being written */
 16    49 
 16    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
 16    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
 16    52 						/* MISC */
 16    53 
 16    54     2 double_write fixed bin,				/* trigger for store through scheme */
 16    55 						/* 0 = no double writes,
 16    56*						   1 = all non-pd pages get written,
 16    57*						   2 = all directories get written */
 16    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
 16    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
 16    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
 16    61 
 16    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
 16    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
 16    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
 16    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
 16    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
 16    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
 16    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
 16    69 
 16    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
 16    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
 16    72 
 16    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
 16    74 
 16    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
 16    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
 16    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
 16    78 
 16    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
 16    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
 16    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
 16    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
 16    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
 16    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
 16    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
 16    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
 16    87 
 16    88 
 16    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
 16    90 
 16    91     2 steps fixed bin,				/* number of steps taken around used list */
 16    92     2 needc fixed bin,				/* number of times core page needed */
 16    93     2 ceiling fixed bin,				/* number of times ceiling hit */
 16    94     2 ctwait fixed bin,				/* number of times write counter was full */
 16    95     2 wired fixed bin,				/* number of pages wired by pc */
 16    96     2 laps fixed bin,				/* number of times around used list */
 16    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
 16    98     2 skipu fixed bin,				/* because of being used */
 16    99 
 16   100     2 skipm fixed bin,				/* because of being modified */
 16   101     2 skipos fixed bin,				/* because out of service */
 16   102     2 aused fixed bin,				/* number of AST entries on used list */
 16   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
 16   104     2 deact_count fixed bin,				/* count of deactivations */
 16   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
 16   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
 16   107 
 16   108     2 reads (8) fixed bin,				/* number of reads for each did */
 16   109     2 writes (8) fixed bin,				/* number of writes for each did */
 16   110 
 16   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
 16   112     2 loop_locks fixed bin,				/* count of times locked PTL */
 16   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
 16   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
 16   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
 16   116     2 total_sf fixed bin,				/* total number of seg_faults */
 16   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
 16   118     2 post_list_size fixed bin,
 16   119     2 post_purgings fixed bin,			/* total number of post-purgings */
 16   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
 16   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
 16   122     2 pre_page_list_size fixed bin,
 16   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
 16   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
 16   125 
 16   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
 16   127 
 16   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
 16   129 
 16   130 /* MAIN MEMORY USAGE INFORMATION */
 16   131 
 16   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
 16   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
 16   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
 16   135     2 recopies fixed bin,				/* number of times recopied because modified */
 16   136     2 first_core_block fixed bin,			/* core map index for first block of core */
 16   137     2 last_core_block fixed bin,			/* core map index for last block of core */
 16   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
 16   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
 16   140 
 16   141 /*  AST METERS  */
 16   142 
 16   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
 16   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
 16   145 
 16   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
 16   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
 16   148     2 asearches fixed bin,				/* count of full searches made */
 16   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
 16   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
 16   151     2 acost fixed bin,				/* cumulative cost of deactivations */
 16   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
 16   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
 16   154 
 16   155     2 alaps fixed bin,				/* lap counter for AST list */
 16   156     2 updates fixed bin,				/* calls to updateb */
 16   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
 16   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
 16   159     2 total_bf fixed bin,				/* count of bound faults */
 16   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
 16   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
 16   162 
 16   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
 16   164 
 16   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
 16   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
 16   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
 16   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
 16   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
 16   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
 16   171 
 16   172 /* PRE-PAGE METERS */
 16   173 
 16   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
 16   175 
 16   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
 16   177 
 16   178 
 16   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
 16   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
 16   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
 16   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
 16   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
 16   184     2 claim_passed_used fixed bin,			/* Times used page seen */
 16   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
 16   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
 16   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
 16   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
 16   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
 16   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
 16   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
 16   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
 16   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
 16   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
 16   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
 16   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
 16   197     2 good_sgms fixed bin,				/* Seg moves that completed */
 16   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
 16   199     2 activations fixed bin,				/* total count of activations */
 16   200     2 dir_activations fixed bin,			/* count of directory activations */
 16   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
 16   202     2 hedge_writes fixed bin,				/* call in core flush writes */
 16   203     2 evict_recover_data,				/* see evict_page.alm */
 16   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
 16   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
 16   206 
 16   207 /* Data for metering force_write facility 08/19/78 */
 16   208 
 16   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
 16   210     2 force_pwrites fixed bin,			/* Mod pages so written */
 16   211     2 fw_none fixed bin,				/* Force write wrote none */
 16   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
 16   213 
 16   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
 16   215     2 pf_unlock_ptl_meterings fixed bin,
 16   216 
 16   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
 16   218     2 backup_activations fixed bin (35),		/* activations for backup */
 16   219     2 metering_flags aligned,				/* small chunks of misc. information */
 16   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
 16   221       3 pad bit (35) unal,
 16   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
 16   223 
 16   224 /* METERS FOR STACK TRUNCATION */
 16   225 
 16   226     2 (stk_truncate_should_didnt,			/* counts */
 16   227        stk_truncate_should_did,
 16   228        stk_truncate_shouldnt_didnt,
 16   229        stk_truncate_shouldnt_did) fixed bin (35),
 16   230     2 stk_pages_truncated fixed bin (35),
 16   231     2 stk_pages_truncated_in_core fixed bin (35),
 16   232 
 16   233 /* SUPPORT FOR PC SEGMOVES */
 16   234 
 16   235     2 segmove_lock aligned,
 16   236       3 pid bit (36) aligned,
 16   237       3 event bit (36) aligned,
 16   238       3 notify bit (1) aligned,
 16   239     2 segmove_io_limit fixed bin, /* max read aheads */
 16   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
 16   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
 16   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
 16   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
 16   244 
 16   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
 16   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
 16   247     2 segmove_vtocx fixed bin,			/* ditto */
 16   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
 16   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
 16   250 
 16   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
 16   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
 16   253     2 trace_sw aligned,				/* tracing control flags */
 16   254       3 pad_trace bit (32) unaligned,
 16   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
 16   256       3 tty_trace bit (1) unaligned,
 16   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
 16   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
 16   259     2 new_pages fixed bin,				/* newly created pages */
 16   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
 16   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
 16   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
 16   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
 16   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
 16   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
 16   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
 16   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
 16   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
 16   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
 16   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
 16   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
 16   272 
 16   273 /* END INCLUDE FILE sst.incl.pl1 */
      814 
      815 
 17     1 /* Begin include file sstnt.incl.pl1   */
 17     2 
 17     3 /* Created 10/03/74 by Bernard Greenberg */
 17     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
 17     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
 17     6 
 17     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
 17     8 
 17     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
 17    10 
 17    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
 17    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
 17    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
 17    14     2 nentries fixed bin,				/* number of entries in the sstnt */
 17    15     2 pad1 (5) fixed bin,
 17    16 
 17    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
 17    18      ast_name_offsets,				/* Starting index for names at each level */
 17    19      ast_offsets,					/* Starting rel addr of each AST region */
 17    20      pad2) (0 : 3) fixed bin,
 17    21 
 17    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
 17    23 
 17    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
 17    25 
 17    26 dcl  nm_astep ptr;					/* astep to be used */
 17    27 
 17    28 /* End include file sstnt.incl.pl1 */
      816 
      817 
 18     1 /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
 18     2 
 18     3 /* Declarations for Segment Loading Table header and array.
 18     4*
 18     5*   Used by Initialization and MST Checker subroutines */
 18     6 
 18     7 dcl sltp ptr,					/* pointer to base of SLT segment */
 18     8     names_ptr ptr,					/* pointer to base of SLT names segment */
 18     9     namep ptr,					/* pointer to segment name list block */
 18    10     pathp ptr,					/* pointer to segment's directory path name */
 18    11     aclp ptr;					/* pointer to acl structure */
 18    12 
 18    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
 18    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
 18    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
 18    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
 18    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
 18    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
 18    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
 18    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
 18    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
 18    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
 18    23 
 18    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
 18    25 
 18    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
 18    27 	2 pad bit (18) unal,
 18    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
 18    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
 18    30 
 18    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
 18    32 	2 count fixed bin (17),			/* number of segment names in this block */
 18    33 	2 names (50 refer (segnam.count)),		/* segment name array */
 18    34 	  3 hp bit (18) unal,			/* hash thread pointer */
 18    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
 18    36 	  3 pad bit (5) unal,
 18    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
 18    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
 18    39 
 18    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
 18    41 	2 size fixed bin (17),			/* length of pathname */
 18    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
 18    43 	2 acls fixed bin;				/* ACL list starts here */
 18    44 
 18    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
 18    46 	2 count fixed bin,				/* number of entries in acl list */
 18    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
 18    48 	  3 userid char (32),			/* user specification */
 18    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
 18    50 	  3 pad bit (36) aligned,
 18    51 	  3 code fixed bin;
 18    52 
 18    53 
 18    54 /* END INCLUDE FILE slt.incl.pl1 */
      818 
      819 
 19     1 /* BEGIN INCLUDE FILE slte.incl.pl1 */
 19     2 /* Declaration for Segment Loading Table Entry structure.
 19     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
 19     4 /* modified 5/4/76 by Noel I. Morris	*/
 19     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
 19     6 /* format: style3 */
 19     7 
 19     8 dcl	sltep		ptr;
 19     9 
 19    10 dcl	1 slte_uns	based (sltep) aligned,
 19    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
 19    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
 19    13 /**** End of word 1 */
 19    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
 19    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
 19    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
 19    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
 19    18 	  2 layout_seg	bit (1),			/* mailbox & such */
 19    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
 19    20 	  2 pad1		bit (3),			/* unused */
 19    21 	  2 wired		bit (1),			/* segment is wired if ON */
 19    22 	  2 paged		bit (1),			/* segment is paged if ON */
 19    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
 19    24 	  2 pad3		bit (2),
 19    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
 19    26 /**** End of 1st half of word 2 */
 19    27 	  2 pad4		bit (3),
 19    28 	  2 branch_required bit (1),			/* path name supplied if ON */
 19    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
 19    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
 19    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
 19    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
 19    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
 19    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
 19    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
 19    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
 19    37 /***** End of word 2 */
 19    38 	  2 pad5		bit (6),
 19    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
 19    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
 19    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
 19    42 /***** End of word 3 */
 19    43 	  2 pad7		bit (3),
 19    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
 19    45 	  2 bit_count	fixed bin (24) uns
 19    46 	  )		unaligned;		/* bitcount of segment */
 19    47 
 19    48 dcl	1 slte		based (sltep) aligned,
 19    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
 19    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
 19    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
 19    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
 19    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
 19    54 	  2 firmware_seg    bit (1),
 19    55 	  2 layout_seg      bit (1),
 19    56 	  2 breakpointable  bit (1),
 19    57 	  2 pad2		bit (3),
 19    58 	  2 wired		bit (1),			/* segment is wired if ON */
 19    59 	  2 paged		bit (1),			/* segment is paged if ON */
 19    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
 19    61 	  2 pad3		bit (2),
 19    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
 19    63 	  2 pad4		bit (3),
 19    64 	  2 branch_required bit (1),			/* path name supplied if ON */
 19    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
 19    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
 19    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
 19    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
 19    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
 19    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
 19    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
 19    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
 19    73 	  2 pad5		bit (6),
 19    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
 19    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
 19    76 	  2 segno		bit (18),			/* text/link segment number */
 19    77 	  2 pad6		bit (3),
 19    78 	  2 max_length	bit (9),			/* maximum length for segment */
 19    79 	  2 bit_count	bit (24)
 19    80 	  )		unaligned;		/* bitcount of segment */
 19    81 
 19    82 /* END INCLUDE FILE slte.incl.pl1 */
      820 
      821 
 20     1 /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
 20     2 
 20     3 
 20     4 /* The physical volume table (PVT) is a wired-down table.
 20     5*   It has one entry for each spindle present, be it for
 20     6*   Storage System or "I/O" use.
 20     7**/
 20     8 
 20     9      dcl	   pvt$		      ext,
 20    10 	   pvtp		      ptr;
 20    11 
 20    12 
 20    13      dcl	   1 pvt		      based (pvtp) aligned,
 20    14 
 20    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
 20    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
 20    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
 20    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
 20    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
 20    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
 20    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
 20    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
 20    23 
 20    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
 20    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
 20    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
 20    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
 20    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
 20    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
 20    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
 20    31 
 20    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
 20    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
 20    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
 20    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 20    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
 20    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
 20    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
 20    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
 20    40 
 20    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
 20    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
 20    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
 20    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
 20    45 
 20    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
 20    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
 20    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
 20    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
 20    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
 20    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
 20    52 	     2 pad (2) bit (36) aligned,
 20    53 
 20    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
 20    55 
 20    56 
 20    57 
 20    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
      822 
      823 
 21     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 21     2 
 21     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
 21     4 
 21     5 /****^  HISTORY COMMENTS:
 21     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
 21     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 21     8*     Add the support for subvolumes
 21     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
 21    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
 21    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
 21    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 21    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 21    14*     Added inconsistent_dbm bit for determining the status of volume
 21    15*     dumper bit maps.
 21    16*                                                   END HISTORY COMMENTS */
 21    17 
 21    18      dcl	   pvt$array	      aligned external;
 21    19      dcl	   pvt$max_n_entries      fixed bin external;
 21    20 
 21    21      dcl	   pvt_arrayp	      ptr;
 21    22      dcl	   pvtep		      ptr;
 21    23 
 21    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
 21    25 
 21    26      dcl	   1 pvte		      based (pvtep) aligned,
 21    27 
 21    28 	     2 pvid	      bit (36),		/* physical volume ID */
 21    29 
 21    30 	     2 lvid	      bit (36),		/* logical volume ID */
 21    31 
 21    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
 21    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
 21    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
 21    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
 21    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
 21    37 	     2 pad3	      bit (2) unaligned,
 21    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
 21    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
 21    40 
 21    41 
 21    42 
 21    43 	     2 devname	      char (4),		/* device name */
 21    44 
 21    45 	     (2 device_type	      fixed bin (8),	/* device type */
 21    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
 21    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
 21    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
 21    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
 21    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
 21    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
 21    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
 21    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
 21    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
 21    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
 21    56 	     2 scav_check_address
 21    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
 21    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
 21    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
 21    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
 21    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
 21    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
 21    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
 21    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
 21    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
 21    66 
 21    67 
 21    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
 21    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
 21    70 
 21    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
 21    72 
 21    73 	     2 nleft	      fixed bin (17),	/* number of records left */
 21    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
 21    75 
 21    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
 21    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
 21    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
 21    79 	     2 records_per_cyl    fixed bin,
 21    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
 21    81 	     2 sv_name            char (2) aligned,
 21    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
 21    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
 21    84 
 21    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
 21    86 	     2 pad2	      bit (18) unaligned,
 21    87 
 21    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
 21    89 
 21    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
 21    91 
 21    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
 21    93 
 21    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
 21    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
 21    96 
 21    97 
 21    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
 21    99 
 21   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
 21   101 
 21   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
 21   103 
 21   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
 21   105 
 21   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
 21   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
 21   108 
 21   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
 21   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
 21   111 
 21   112 
 21   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
 21   114 	   VOLMAP_ASYNC_READ      init (1),
 21   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
 21   116 
 21   117 
 21   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      824 
      825 
      826      end amu_get_name_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1918.7  amu_get_name_.pl1                 >udd>sm>ds>w>ml>amu_get_name_.pl1
784          1    10/04/83  1205.1  vtoce.incl.pl1                    >ldd>incl>vtoce.incl.pl1
786          2    07/24/86  2151.9  disk_table.incl.pl1               >ldd>incl>disk_table.incl.pl1
788          3    11/20/84  0954.8  amu_hardcore_info.incl.pl1        >ldd>incl>amu_hardcore_info.incl.pl1
790          4    11/20/84  0956.1  amu_info.incl.pl1                 >ldd>incl>amu_info.incl.pl1
792          5    07/28/87  1043.5  amu_translation.incl.pl1          >ldd>incl>amu_translation.incl.pl1
794          6    01/30/85  1623.9  aste.incl.pl1                     >ldd>incl>aste.incl.pl1
796          7    09/18/74  1800.9  bind_map.incl.pl1                 >ldd>incl>bind_map.incl.pl1
798          8    04/29/76  1200.6  dir_entry.incl.pl1                >ldd>incl>dir_entry.incl.pl1
800          9    05/24/82  1105.0  dir_header.incl.pl1               >ldd>incl>dir_header.incl.pl1
802         10    11/02/76  1514.7  dir_name.incl.pl1                 >ldd>incl>dir_name.incl.pl1
804         11    09/18/86  1408.1  kst.incl.pl1                      >ldd>incl>kst.incl.pl1
806         12    08/05/77  1122.5  object_info.incl.pl1              >ldd>incl>object_info.incl.pl1
808         13    11/20/84  0956.2  amu_process_info.incl.pl1         >ldd>incl>amu_process_info.incl.pl1
810         14    09/14/76  0859.8  sdw.incl.pl1                      >ldd>incl>sdw.incl.pl1
812         15    02/18/88  2123.8  sl_info.incl.pl1                  >ldd>incl>sl_info.incl.pl1
814         16    01/30/85  1623.9  sst.incl.pl1                      >ldd>incl>sst.incl.pl1
816         17    11/02/84  1012.2  sstnt.incl.pl1                    >ldd>incl>sstnt.incl.pl1
818         18    05/24/82  1105.0  slt.incl.pl1                      >ldd>incl>slt.incl.pl1
820         19    07/11/84  1037.3  slte.incl.pl1                     >ldd>incl>slte.incl.pl1
822         20    05/27/82  1625.8  pvt.incl.pl1                      >ldd>incl>pvt.incl.pl1
824         21    07/21/88  2136.0  pvte.incl.pl1                     >ldd>incl>pvte.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_amu_info_ptr                         parameter       pointer                  dcl 54 set ref 32 150 156 162 178 178* 182* 185
P_code                                 parameter       fixed bin(35,0)          dcl 500 in procedure "get_l1dir_shortname" set ref
                                                                                  494 511* 515* 584*
P_code                                 parameter       fixed bin(35,0)          dcl 409 in procedure "amu_get_name_" set ref 404
                                                                                  413* 423*
P_count                                parameter       fixed bin(24,0)          dcl 54 set ref 150 199* 209* 232* 287* 292* 314*
                                                                                  372*
P_dirname                              parameter       char                     packed unaligned dcl 498 set ref 494 510* 582*
P_ename                                parameter       char                     packed unaligned dcl 499 set ref 494 510* 514* 583*
P_kstp                                 parameter       pointer                  dcl 651 ref 647 661
P_ptr                                  parameter       pointer                  dcl 54 set ref 150 198* 208* 231* 286* 291* 313*
                                                                                  371* 373
P_segn                                 parameter       fixed bin(17,0)          dcl 650 ref 647 660
P_segname                              parameter       char                     packed unaligned dcl 497 in procedure
                                                                                  "get_l1dir_shortname" set ref 494 509 514*
P_segname                              parameter       char                     packed unaligned dcl 407 in procedure
                                                                                  "amu_get_name_" ref 404 412
P_segptr                               parameter       pointer                  dcl 54 ref 32 150 156 187
P_shortname                            parameter       char                     packed unaligned dcl 408 set ref 404 416* 419*
SAVED_PROC_TYPE                        constant        fixed bin(17,0)          initial dcl 4-47 ref 246
a_astep                                parameter       pointer                  dcl 680 ref 677 684
a_pointer_rep                          parameter       varying char             dcl 168 ref 162 177
a_sstnp                                parameter       pointer                  dcl 680 ref 677 686
a_sstp                                 parameter       pointer                  dcl 680 ref 677 685
add                                    based           bit(24)                  level 2 packed packed unaligned dcl 14-5 ref 256
addr                                                   builtin function         dcl 144 ref 189 254 335 335 335 335 335 335 380 380
                                                                                  452 483 542 542 613 630 759 777 777
addrel                                                 builtin function         dcl 144 ref 182 182 392 484 487 614 617
amu_$dp_segno_to_name           000436 constant        entry                    external dcl 121 ref 248
amu_$fdump_translate_contiguous 000442 constant        entry                    external dcl 123 ref 633
amu_$hardcore_info_set_cur_ptrs 000440 constant        entry                    external dcl 122 ref 190
amu_$kst_util_expand_uid_path   000512 constant        entry                    external dcl 657 ref 669
amu_$kst_util_segno_to_uid_path 000514 constant        entry                    external dcl 658 ref 667
amu_$resolve_virtual_addr       000444 constant        entry                    external dcl 124 ref 178
amu_$return_val_phcs_ok         000446 constant        entry                    external dcl 125 ref 298
amu_$search_path_get_object     000450 constant        entry                    external dcl 126 ref 344
amu_$search_path_set_object     000452 constant        entry                    external dcl 127 ref 346
amu_$translate_force_add        000454 constant        entry                    external dcl 128 ref 637
amu_$translate_get              000456 constant        entry                    external dcl 129 ref 626
amu_do_translation_             000460 constant        entry                    external dcl 130 ref 255
amu_et_$null_sltnt              000432 external static fixed bin(35,0)          dcl 116 ref 606
amu_et_$null_sltp               000430 external static fixed bin(35,0)          dcl 115 ref 470 600
amu_get_name_                   000506 constant        entry                    external dcl 173 ref 182
amu_info                               based           structure                level 1 dcl 4-3
amu_info_ptr                    000742 automatic       pointer                  dcl 4-45 set ref 185* 190* 214 214 216 217 222 222
                                                                                  224 246 248* 255* 447 452 626* 626 633* 633 633
                                                                                  637* 637
apte                      6            based           structure                level 2 dcl 13-7
areap                           000100 automatic       pointer                  dcl 61 set ref 541* 542* 545
array                   346            based           structure                array level 2 dcl 5-13
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 17-11 ref 719
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 17-11 ref 713 719
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 17-11 ref 719
astap                    30            based           pointer                  level 2 dcl 16-9 ref 688 712
aste                                   based           structure                level 1 dcl 6-11
astep                           000746 automatic       pointer                  dcl 6-9 in procedure "amu_get_name_" set ref 256*
                                                                                  271* 684* 688 694 699* 760 761 766 766 772 772
astep                                  parameter       pointer                  dcl 708 in procedure "recurse" ref 702 711 717 731
                                                                                  739 739 739 739 741 741 741 741
astsize                  33            based           fixed bin(17,0)          level 2 dcl 16-9 ref 256
baseno                                                 builtin function         dcl 144 ref 191
baseptr                                                builtin function         dcl 144 ref 182 182 633 633
bindmap                                based           structure                level 1 dcl 7-4
bitcnt                          000102 automatic       fixed bin(24,0)          dcl 62 set ref 289* 292 355* 365* 372 380* 382
bmp                             000104 automatic       pointer                  dcl 64 set ref 380* 387 388 389 392 393
bndsw                           000103 automatic       bit(1)                   packed unaligned dcl 63 set ref 147* 152* 158* 236
                                                                                  318 333
branch                          000106 automatic       structure                level 1 dcl 65 set ref 542 542
branch_required           1(21)        based           bit(1)                   level 2 packed packed unaligned dcl 19-48 ref 486
                                                                                  616
check_gate_access_              000522 constant        entry                    external dcl 752 ref 762
code                                   parameter       fixed bin(35,0)          dcl 590 in procedure "get_sup_seg_slt" set ref 588
                                                                                  596* 600* 606* 610*
code                                   parameter       fixed bin(35,0)          dcl 430 in procedure "check_if_early_hardcore_seg"
                                                                                  set ref 426 445* 448* 453*
code                                   parameter       fixed bin(35,0)          dcl 463 in procedure "get_init_seg_slt" set ref 458
                                                                                  466* 470* 480*
code                            000112 automatic       fixed bin(35,0)          dcl 74 in procedure "amu_get_name_" set ref 176*
                                                                                  178* 180 217* 224* 226* 227 255* 275* 276 276* 281
                                                                                  281* 289* 305* 306 330* 331 335* 344* 346* 355*
                                                                                  365* 380* 381 400* 413* 415* 416 420* 423 511*
                                                                                  542* 543 579* 581 584 626* 632* 633* 635 637* 638
                                                                                  762* 763 764* 765 777* 778
code                            001257 automatic       fixed bin(35,0)          dcl 655 in procedure "kst_name" set ref 662* 667*
                                                                                  668 669* 670
component                 2            based           structure                array level 2 dcl 7-4
dinfo                           000010 internal static structure                level 1 unaligned dcl 103
dirname                         001074 automatic       char(168)                packed unaligned dcl 503 in procedure
                                                                                  "get_l1dir_shortname" set ref 510* 579* 581* 582
dirname                                parameter       char                     packed unaligned dcl 431 in procedure
                                                                                  "check_if_early_hardcore_seg" set ref 426 446*
                                                                                  453*
dirname                         000113 automatic       char(168)                packed unaligned dcl 75 in procedure "amu_get_name_"
                                                                                  set ref 217* 218 224* 226* 305* 328* 330* 331* 335
                                                                                  335 343 365* 414* 415* 416*
divide                                                 builtin function         dcl 144 ref 719
dl                              000307 automatic       fixed bin(17,0)          dcl 83 set ref 570* 572 574
dnames                                 based           char(32)                 array dcl 99 ref 557 557 560
dnl                             000610 automatic       fixed bin(17,0)          dcl 171 set ref 217*
done                            001170 automatic       bit(1)                   packed unaligned dcl 507 set ref 530* 532 533* 534*
                                                                                  537 555* 556 561*
dpath                                  based           char(168)                packed unaligned dcl 594 in procedure
                                                                                  "get_sup_seg_slt" ref 618
dpath                                  based           char(168)                packed unaligned dcl 464 in procedure
                                                                                  "get_init_seg_slt" ref 488
dpathp                          001220 automatic       pointer                  dcl 595 in procedure "get_sup_seg_slt" set ref 617*
                                                                                  618
dpathp                          001012 automatic       pointer                  dcl 465 in procedure "get_init_seg_slt" set ref 487*
                                                                                  488
dte                                    based           structure                level 1 dcl 2-35
early_dump                2            based           bit(1)                   level 3 packed packed unaligned dcl 4-3 ref 222
ename                           000165 automatic       char(32)                 packed unaligned dcl 76 in procedure "amu_get_name_"
                                                                                  set ref 217* 218 224* 226* 236 237 239* 239* 240
                                                                                  242 305* 318 319 321* 321* 322 324 328* 330* 331*
                                                                                  334 335 335 336 355* 365* 414* 415* 416*
ename                           001146 automatic       char(32)                 packed unaligned dcl 504 in procedure
                                                                                  "get_l1dir_shortname" set ref 510* 579* 583
ename                                  parameter       char                     packed unaligned dcl 431 in procedure
                                                                                  "check_if_early_hardcore_seg" set ref 426 446*
                                                                                  453*
error_info               26            based           structure                level 2 dcl 4-3
error_table_$action_not_performed
                                000434 external static fixed bin(35,0)          dcl 117 ref 448 480 515 610
expand_path_                    000462 constant        entry                    external dcl 131 ref 335
expand_pathname_                000464 constant        entry                    external dcl 132 ref 275 579
expanded_path                   001260 automatic       char(168)                packed unaligned dcl 656 set ref 663* 669* 671
first_init_seg            5            based           fixed bin(18,0)          level 2 dcl 18-13 ref 479
first_sup_seg             3            based           fixed bin(18,0)          level 2 dcl 18-13 ref 609
fixed                                                  builtin function         dcl 144 ref 191 192 239 239 256 256 321 321 338 340
                                                                                  340 388 389 393 688 688 711 712 717
flags                   346(18)        based           structure                array level 3 in structure "translation_table"
                                                                                  packed packed unaligned dcl 5-13 in procedure
                                                                                  "amu_get_name_"
flags                     2            based           structure                level 2 in structure "amu_info" dcl 4-3 in procedure
                                                                                  "amu_get_name_"
flags                     0(18)        based           structure                level 2 in structure "translation" packed packed
                                                                                  unaligned dcl 5-24 in procedure "amu_get_name_"
genp                            000260 automatic       pointer                  dcl 79 set ref 188* 288* 289* 290 291 353* 355* 356
                                                                                  358 364* 365* 366 371 380* 400 400*
get_bound_seg_info_             000466 constant        entry                    external dcl 133 ref 380
get_system_free_area_           000470 constant        entry                    external dcl 134 ref 541
hard_ptrs                       000262 automatic       structure                level 1 unaligned dcl 80 set ref 189
hardcore_cur                           based           structure                level 1 unaligned dcl 3-40
hardcore_cur_ptr                000740 automatic       pointer                  dcl 3-38 set ref 189* 190*
hardcore_info                          based           structure                level 1 dcl 3-6
hardcore_info_ptr        16            based           pointer                  level 2 dcl 4-3 ref 222 224 626 633 633 637
hcs_$fs_get_path_name           000510 constant        entry                    external dcl 174 ref 217
hcs_$initiate_count             000472 constant        entry                    external dcl 135 ref 289 355 365
hcs_$status_                    000476 constant        entry                    external dcl 137 ref 542
hcs_$terminate_noname           000474 constant        entry                    external dcl 136 ref 400
hcs_count                30            based           fixed bin(17,0)          level 2 dcl 3-6 ref 222 224
highseg                   1            based           fixed bin(17,0)          level 2 dcl 11-18 ref 665
i                               000304 automatic       fixed bin(17,0)          dcl 83 set ref 214* 214* 216 217 387* 388 389 392
                                                                                  393*
idx                             001166 automatic       fixed bin(17,0)          dcl 506 set ref 521* 522 524 532* 533 534* 556* 557
                                                                                  557 560* 565* 569 570 571 573
index                                                  builtin function         dcl 144 ref 277 298 298 304 307 521
ioa_                            000516 constant        entry                    external dcl 750 in procedure "get_vtoc_pathname"
                                                                                  ref 766 772 778
ioa_                            000500 constant        entry                    external dcl 138 in procedure "amu_get_name_" ref
                                                                                  374 476
ioa_$rsnnl                      000520 constant        entry                    external dcl 750 in procedure "get_vtoc_pathname"
                                                                                  ref 780
ioa_$rsnnl                      000502 constant        entry                    external dcl 139 in procedure "amu_get_name_" ref
                                                                                  239 321 340 383 394 399
j                               000305 automatic       fixed bin(17,0)          dcl 83 set ref 388* 390 390 394
jdx                             001167 automatic       fixed bin(17,0)          dcl 506 set ref 571* 573 573 574 575
k                               000303 automatic       fixed bin(17,0)          dcl 83 set ref 389* 390
key                             000300 automatic       char(1)                  packed unaligned dcl 81 set ref 546* 550* 552* 557
kst                      21            based           fixed bin(15,0)          level 3 in structure "hardcore_info" dcl 3-6
                                                                                  in procedure "amu_get_name_" set ref 626* 633 633
                                                                                  637*
kst                                    based           structure                level 1 dcl 11-18 in procedure "amu_get_name_"
kste                                   based           structure                level 1 dcl 11-36
kstp                            000750 automatic       pointer                  dcl 11-15 set ref 298* 641* 661* 665 665 667* 669*
l1dir                     1     000010 internal static structure                array level 2 packed packed unaligned dcl 103
l1dirname                       001156 automatic       char(32)                 packed unaligned dcl 505 set ref 520* 522* 524* 526
                                                                                  533 534 539 542* 546 546 546 550 552
last_init_seg             6            based           fixed bin(18,0)          level 2 dcl 18-13 ref 479
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 18-13 ref 609
length                                                 builtin function         dcl 144 ref 335 335 526 557 570 571 572 699 699 723
                                                                                  723 729 732 739 741
lg_name                   1     000010 internal static char(32)                 array level 3 packed packed unaligned dcl 103 set
                                                                                  ref 533 539* 570
libx                            000301 automatic       fixed bin(17,0)          dcl 82 set ref 354* 355*
ling                            000302 automatic       fixed bin(17,0)          dcl 83 set ref 393* 394 394 572* 575
local_vtoce                     001351 automatic       structure                level 1 dcl 751 set ref 759
lower                     0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 433 ref 453
lowseg                                 based           fixed bin(17,0)          level 2 dcl 11-18 ref 665
lve                                    based           structure                level 1 dcl 2-58
maxlength                                              builtin function         dcl 144 ref 723
mblen                           000306 automatic       fixed bin(17,0)          dcl 83 set ref 193* 239* 321* 340* 383* 394*
myname                          001723 automatic       char(19)                 initial packed unaligned dcl 756 set ref 756* 766*
                                                                                  772* 778*
n_components              1            based           fixed bin(17,0)          level 2 dcl 7-4 ref 387
n_entries                              based           fixed bin(17,0)          level 2 dcl 5-13 ref 214
name                      2            based           char(32)                 array level 3 in structure "segnam" packed packed
                                                                                  unaligned dcl 18-31 in procedure "amu_get_name_"
                                                                                  ref 485 615
name                      2            based           structure                array level 3 in structure "bindmap" dcl 7-4
                                                                                  in procedure "amu_get_name_"
name                            000103 automatic       varying char(32)         dcl 708 in procedure "recurse" set ref 723 723* 727*
                                                                                  729 729* 732 734 739 741 741
name_lng                  2(18)        based           bit(18)                  array level 4 packed packed unaligned dcl 7-4 ref
                                                                                  393
name_ptr                  2            based           bit(18)                  array level 4 packed packed unaligned dcl 7-4 ref
                                                                                  392
namebuf                         000310 automatic       char(168)                packed unaligned dcl 84 set ref 242* 247* 248* 249
                                                                                  250 264* 267* 269* 271* 275 275 284 289* 295 298
                                                                                  298 298 304 307 324* 330* 331* 333 334 335 335 335
                                                                                  335 338 340* 340* 341 349* 350 358 366 374* 381
                                                                                  383* 383* 394* 394* 399* 399* 402 671* 780*
namel                                  parameter       fixed bin(17,0)          dcl 706 ref 702 732 738 739 739 741
namep                           000764 automatic       pointer                  dcl 18-7 set ref 484* 485 614* 615
names                    30            based           varying char(32)         array level 2 in structure "sstnt" dcl 17-11
                                                                                  in procedure "amu_get_name_" ref 723 723 727
names                     1            based           structure                array level 2 in structure "segnam" dcl 18-31
                                                                                  in procedure "amu_get_name_"
names_ptr                       000762 automatic       pointer                  dcl 18-7 in procedure "amu_get_name_" set ref 473*
                                                                                  484 487 603* 614 617
names_ptr                              based           bit(18)                  level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 19-48 in procedure "amu_get_name_" ref 484 614
ndir                            000010 internal static fixed bin(17,0)          initial level 2 dcl 103 set ref 531 532 538* 538 539
                                                                                  540 560 565
new_sdw                         000362 automatic       fixed bin(71,0)          dcl 85 set ref 254
nfsw                            001350 automatic       bit(1)                   initial packed unaligned dcl 749 set ref 749* 771
nmp                             000364 automatic       pointer                  dcl 86 set ref 545* 557 557 560
nnames                    0(02) 000106 automatic       fixed bin(15,0)          level 2 packed packed unaligned dcl 65 set ref 544
                                                                                  556
nrp                       0(18) 000106 automatic       bit(18)                  level 2 packed packed unaligned dcl 65 set ref 544
                                                                                  545
nsdwp                           000366 automatic       pointer                  dcl 86 set ref 254* 255* 256
null                                                   builtin function         dcl 144 ref 188 194 198 204 208 231 286 288 290 313
                                                                                  346 348 353 356 358 364 366 373 400 447 467 473
                                                                                  597 603 628 762 762
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 15-15 ref 354
object_info                            based           structure                level 1 dcl 12-6
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 12-60 ref 379
offrel                          000370 automatic       fixed bin(18,0)          dcl 87 set ref 192* 382 383* 390 390 394 399*
offset                          000607 automatic       fixed bin(18,0)          dcl 170 set ref 178* 182 182
oi_area                         000372 automatic       structure                level 1 dcl 88 set ref 380 380
opvtx                           001730 automatic       fixed bin(17,0)          dcl 757 set ref 760* 764*
ovtocx                          001731 automatic       fixed bin(17,0)          dcl 757 set ref 761* 764*
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-11 ref 731 739
                                                                                  739 741 741
part1                   347            based           structure                array level 3 in structure "translation_table"
                                                                                  dcl 5-13 in procedure "amu_get_name_"
part1                     1     000472 automatic       structure                level 2 in structure "trans_space" unaligned dcl 94
                                                                                  in procedure "amu_get_name_"
part1                     1            based           structure                level 2 in structure "translation" dcl 5-24
                                                                                  in procedure "amu_get_name_"
path_ptr                  0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 19-48 ref 487
                                                                                  617
pathname                 17            based           char(168)                array level 3 packed packed unaligned dcl 15-15 set
                                                                                  ref 355*
pathname_                       000504 constant        entry                    external dcl 140 ref 331 416
paths                    14            based           structure                array level 2 dcl 15-15
phcs_$get_vtoce                 000524 constant        entry                    external dcl 753 ref 764
pid                                    based           bit(36)                  level 2 in structure "process_info" dcl 13-7
                                                                                  in procedure "amu_get_name_" set ref 452
pid                                    based           structure                level 1 dcl 433 in procedure
                                                                                  "check_if_early_hardcore_seg"
pid_ptr                         001002 automatic       pointer                  dcl 436 set ref 452* 453
pn                              001651 automatic       char(168)                packed unaligned dcl 754 set ref 776* 777* 780*
pointers                               based           structure                level 2 dcl 3-6
process_info                           based           structure                level 1 dcl 13-7
process_info_ptr         22            based           pointer                  level 2 dcl 4-3 ref 447 452
ptr                                                    builtin function         dcl 144 in procedure "amu_get_name_" ref 256 545 739
                                                                                  739 741 741
ptr                     347            based           pointer                  array level 4 in structure "translation_table"
                                                                                  packed packed unaligned dcl 5-13 in procedure
                                                                                  "amu_get_name_" ref 217
ptr                       1            based           pointer                  level 3 in structure "translation" packed packed
                                                                                  unaligned dcl 5-24 in procedure "amu_get_name_"
                                                                                  ref 641
ptrtmp                          000460 automatic       pointer                  dcl 89 set ref 392* 394
ptsi                     13(28)        based           bit(2)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 6-11 in procedure "amu_get_name_" ref 717
ptsi                            000100 automatic       fixed bin(17,0)          dcl 705 in procedure "recurse" set ref 713* 713* 715
                                                                                  717 719 719 719
ptwbase                  25            based           fixed bin(24,0)          level 2 dcl 16-9 ref 256
pvte                                   based           structure                level 1 dcl 21-26
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 6-11 set ref 760
                                                                                  766* 772*
ra                              000101 automatic       fixed bin(17,0)          dcl 705 set ref 711* 712 713 719
rel                                                    builtin function         dcl 144 ref 192 239 239 321 321 338 340 340 688 688
                                                                                  694 694 711 712 731
replaced                346(23)        based           bit(1)                   array level 4 packed packed unaligned dcl 5-13 ref
                                                                                  216
replaced_path                   000611 automatic       char(168)                packed unaligned dcl 172 set ref 218* 219
ret_dir                                parameter       char                     packed unaligned dcl 462 in procedure
                                                                                  "get_init_seg_slt" set ref 458 488* 490*
ret_dir                                parameter       char                     packed unaligned dcl 593 in procedure
                                                                                  "get_sup_seg_slt" set ref 588 618* 620*
ret_name                               parameter       char                     packed unaligned dcl 592 in procedure
                                                                                  "get_sup_seg_slt" set ref 588 615*
ret_name                               parameter       char                     packed unaligned dcl 461 in procedure
                                                                                  "get_init_seg_slt" set ref 458 485*
ret_ptr_sw                      000462 automatic       bit(1)                   packed unaligned dcl 90 set ref 147* 153* 159* 195
                                                                                  205 228 237 285 310 319 336 358 366 370
retstr                                 parameter       char                     packed unaligned dcl 682 set ref 677 689* 695* 699*
                                                                                  699 699
reverse                                                builtin function         dcl 144 ref 298
root_astep               36            based           pointer                  level 2 dcl 16-9 ref 694 731
rtrim                                                  builtin function         dcl 144 ref 182 218 218 275 275 284 522 526 557 560
                                                                                  570 571 572
sblkp                           000464 automatic       pointer                  dcl 91 set ref 380* 392
sci_ptr                  30            based           pointer                  level 3 dcl 4-3 set ref 178*
sdw                                    based           structure                level 1 dcl 14-5
seg                      10            based           structure                array level 2 dcl 18-13 set ref 483 613
seg_name                        000663 automatic       char(168)                packed unaligned dcl 410 set ref 412* 415* 419
seg_num                                parameter       fixed bin(17,0)          dcl 591 in procedure "get_sup_seg_slt" ref 588 609
                                                                                  609 613
seg_num                                parameter       fixed bin(17,0)          dcl 460 in procedure "get_init_seg_slt" ref 458 479
                                                                                  479 483
seg_path                        001022 automatic       char(168)                packed unaligned dcl 502 set ref 509* 513 514 519
                                                                                  521 522 524 572 573* 574* 574 575* 579* 581
segn                            001236 automatic       fixed bin(17,0)          dcl 653 set ref 660* 665 665 667*
segnam                                 based           structure                level 1 dcl 18-31
segname                         000506 automatic       varying char(256)        dcl 169 set ref 177* 178 180 182
segno                   346            based           fixed bin(18,0)          array level 3 in structure "translation_table"
                                                                                  packed packed unsigned unaligned dcl 5-13
                                                                                  in procedure "amu_get_name_" ref 214
segno                                  parameter       fixed bin(17,0)          dcl 429 in procedure "check_if_early_hardcore_seg"
                                                                                  set ref 426 453*
segno                           000466 automatic       fixed bin(17,0)          dcl 92 in procedure "amu_get_name_" set ref 178* 182
                                                                                  182 191* 214 222 224 224* 226* 248* 255 298* 305*
segno                    16            based           structure                level 2 in structure "hardcore_info" dcl 3-6
                                                                                  in procedure "amu_get_name_"
segptr                          000470 automatic       pointer                  dcl 93 set ref 187* 191 192 194 239 239 321 321 338
                                                                                  340 340
sht_name                 11     000010 internal static char(4)                  array level 3 packed packed unaligned dcl 103 set
                                                                                  ref 534 540* 560* 569 571 573
sl_info                                based           structure                level 1 dcl 15-15
sl_info_p                       000752 automatic       pointer                  dcl 15-28 set ref 344* 346 346* 348 354 355
slt                                    based           structure                level 1 dcl 18-13 in procedure "amu_get_name_"
slt                                    based           structure                level 3 in structure "hardcore_info" dcl 3-6
                                                                                  in procedure "amu_get_name_"
slte                                   based           structure                level 1 dcl 19-48
sltep                           000766 automatic       pointer                  dcl 19-8 set ref 483* 484 486 487 613* 614 616 617
sltntp                    2     000262 automatic       pointer                  level 2 dcl 80 set ref 204 473 473 603 603
sltp                            000760 automatic       pointer                  dcl 18-7 in procedure "amu_get_name_" set ref 467*
                                                                                  479 479 483 597* 609 609 613
sltp                            000262 automatic       pointer                  level 2 in structure "hard_ptrs" dcl 80 in procedure
                                                                                  "amu_get_name_" set ref 467 467 597 597
sst                                    based           structure                level 1 dcl 16-9
sstnp                           000756 automatic       pointer                  dcl 17-9 set ref 686* 713 719 719 719 723 723 727
sstnt                                  based           structure                level 1 dcl 17-11
sstnt_idx                       000102 automatic       fixed bin(17,0)          dcl 707 set ref 719* 723 723 727
sstntp                   12     000262 automatic       pointer                  level 2 dcl 80 set ref 263 271*
sstp                            000754 automatic       pointer                  dcl 16-7 in procedure "amu_get_name_" set ref 685*
                                                                                  688 694 712 731
sstp                      6     000262 automatic       pointer                  level 2 in structure "hard_ptrs" dcl 80 in procedure
                                                                                  "amu_get_name_" set ref 256 256 256 271*
substr                                                 builtin function         dcl 144 set ref 237 249 277 277 277 298 319 334 336
                                                                                  343 513 519 521 522 524 546 546 546 550 552 557
                                                                                  573* 573 574* 574 575*
tdname                          000175 automatic       char(168)                packed unaligned dcl 77 set ref 275* 277 277
tename                          000247 automatic       char(32)                 packed unaligned dcl 78 set ref 275* 277 277
text_lng                  5(18)        based           bit(18)                  array level 3 packed packed unaligned dcl 7-4 ref
                                                                                  389
text_start                5            based           bit(18)                  array level 3 packed packed unaligned dcl 7-4 ref
                                                                                  388
trans_space                     000472 automatic       structure                level 1 unaligned dcl 94 set ref 630
translation                            based           structure                level 1 dcl 5-24
translation_ptr                 000744 automatic       pointer                  dcl 5-40 set ref 626* 628 629 630* 633* 637* 641
translation_table                      based           structure                level 1 dcl 5-13
translation_table_ptr
                         12            based           pointer                  level 2 dcl 4-3 ref 214 214 216 217
two_part                  0(18)        based           bit(1)                   level 3 packed packed unaligned dcl 5-24 ref 629
type                      3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-3 ref 246
uid                       1            based           bit(36)                  level 2 packed packed unaligned dcl 1-7 set ref 770
                                                                                  777*
uid_path                        001237 automatic       bit(36)                  array dcl 654 in procedure "kst_name" set ref 664*
                                                                                  667* 669*
uid_path                240            based           bit(36)                  array level 2 in structure "vtoce" packed packed
                                                                                  unaligned dcl 1-7 in procedure "amu_get_name_" set
                                                                                  ref 777 777
valid                                  based           bit(1)                   level 2 dcl 17-11 ref 263
var_str                                based           char                     packed unaligned dcl 98 set ref 394*
version_number                  000372 automatic       fixed bin(17,0)          level 2 dcl 88 set ref 379*
vpn_cv_uid_path_$ent            000526 constant        entry                    external dcl 755 ref 777
vtoce                                  based           structure                level 1 dcl 1-7
vtocep                          000736 automatic       pointer                  dcl 1-5 set ref 759* 764* 770 777 777 777
vtocx                     4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-11 set ref 761
                                                                                  766* 772*
zerodivide                      000500 stack reference condition                dcl 111 ref 269 272

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_PATH                          internal static fixed bin(17,0)          initial dcl 15-33
AMU_INFO_VERSION                       internal static char(8)                  initial packed unaligned dcl 4-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial packed unaligned dcl 4-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial packed unaligned dcl 4-58
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 4-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 4-47
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 15-38
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 4-47
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 15-39
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 4-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 4-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 4-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 4-47
PDIR_SUFFIX                            internal static char(4)                  initial packed unaligned dcl 4-60
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 15-37
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 15-35
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 15-34
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 21-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 21-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 21-113
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 15-36
aclp                                   automatic       pointer                  dcl 18-7
acls                                   based           structure                level 1 dcl 18-45
alloc_translation_table_max_entries    automatic       fixed bin(17,0)          dcl 5-39
amu_area                               based           area(1024)               dcl 4-43
asta                                   based           bit(432)                 array dcl 6-86
aste_part                              based           structure                level 1 dcl 6-89
dir                                    based           structure                level 1 dcl 9-11
dp                                     automatic       pointer                  dcl 9-9
dt                                     based           structure                level 1 dcl 2-23
dtep                                   automatic       pointer                  dcl 2-17
dtp                                    automatic       pointer                  dcl 2-17
entry                                  based           structure                level 1 dcl 8-8
ep                                     automatic       pointer                  dcl 8-6
kstep                                  automatic       pointer                  dcl 11-15
lvep                                   automatic       pointer                  dcl 2-17
name_seg                               based           structure                level 1 dcl 18-26
names                                  based           structure                level 1 dcl 10-7
nm_astep                               automatic       pointer                  dcl 17-26
np                                     automatic       pointer                  dcl 10-5
path                                   based           structure                level 1 dcl 18-40
pathp                                  automatic       pointer                  dcl 18-7
pds$kstp                               external static pointer                  dcl 11-15
ptsi_a                                 automatic       fixed bin(17,0)          dcl 17-24
pvt                                    based           structure                level 1 dcl 20-13
pvt$                                   external static fixed bin(17,0)          dcl 20-9
pvt$array                              external static fixed bin(17,0)          dcl 21-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 21-19
pvt_array                              based           structure                array level 1 dcl 21-24
pvt_arrayp                             automatic       pointer                  dcl 21-21
pvtep                                  automatic       pointer                  dcl 21-22
pvtp                                   automatic       pointer                  dcl 20-9
sdwa                                   based           structure                array level 1 dcl 14-24
sdwp                                   automatic       pointer                  dcl 14-3
seg_aste                               based           structure                level 1 dcl 6-96
seg_vtoce                              based           structure                level 1 dcl 1-92
sl_info_num_paths                      automatic       fixed bin(17,0)          dcl 15-27
sl_info_version_1                      internal static fixed bin(17,0)          initial dcl 15-29
slte_uns                               based           structure                level 1 dcl 19-10
sst_names_$                            external static fixed bin(17,0)          dcl 17-7
sst_seg$                               external static fixed bin(17,0)          dcl 16-6
sstnmx                                 automatic       fixed bin(17,0)          dcl 17-24
version_number_2                       internal static fixed bin(17,0)          initial dcl 9-84
vtoce_parts                            based           bit(2304)                array dcl 1-90

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_IT                       004724 constant        label                    dcl 579 ref 527
ST_ERR                          004601 constant        label                    dcl 565 ref 543
Trans_it                        005144 constant        label                    dcl 630 ref 628
amu_get_name_                   000274 constant        entry                    external dcl 32
amu_get_name_$get_l1dir_shortname
                                003611 constant        entry                    external dcl 404
check_if_early_hardcore_seg     003730 constant        entry                    internal dcl 426 ref 305
common                          000625 constant        label                    dcl 185 ref 148 154 160
exit_search                     003056 constant        label                    dcl 358 ref 356
fail                            005404 constant        label                    dcl 689 ref 712 715 717
finish_name                     002376 constant        label                    dcl 328 ref 249 307
for_structure                   000347 constant        entry                    external dcl 162
get_ast_name                    005351 constant        entry                    internal dcl 677 ref 271
get_init_seg_slt                004026 constant        entry                    internal dcl 458 ref 226 453
get_kstp                        005114 constant        entry                    internal dcl 624 ref 298
get_l1dir_shortname             004160 constant        entry                    internal dcl 494 ref 330 415
get_ptr_count                   000313 constant        entry                    external dcl 150
get_sup_seg_slt                 004773 constant        entry                    internal dcl 588 ref 224
get_vtoc_pathname               006035 constant        entry                    internal dcl 745 ref 280
inithc                          002702 constant        label                    dcl 344 ref 243 325
kst_name                        005242 constant        entry                    internal dcl 647 ref 298
no_comp                         000330 constant        entry                    external dcl 156
recurse                         005464 constant        entry                    internal dcl 702 ref 699 739 741
trmnme                          003540 constant        label                    dcl 400 ref 384 395

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7134        7664    6434        7144
Length     10516    6434       530         616     477         420

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amu_get_name_                      1292 external procedure  is an external procedure.  
on unit on line 269                  64 on unit               
check_if_early_hardcore_seg             internal procedure  shares stack frame of external procedure amu_get_name_.  
get_init_seg_slt                        internal procedure  shares stack frame of external procedure amu_get_name_.  
get_l1dir_shortname                     internal procedure  shares stack frame of external procedure amu_get_name_.  
get_sup_seg_slt                         internal procedure  shares stack frame of external procedure amu_get_name_.  
get_kstp                                internal procedure  shares stack frame of external procedure amu_get_name_.  
kst_name                                internal procedure  shares stack frame of external procedure amu_get_name_.  
get_ast_name                            internal procedure  shares stack frame of external procedure amu_get_name_.  
recurse                             102 internal procedure  uses returns(char(*)) or returns(bit(*)).  
get_vtoc_pathname                       internal procedure  shares stack frame of external procedure amu_get_name_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dinfo                       amu_get_name_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
amu_get_name_            000100 areap                       amu_get_name_
                         000102 bitcnt                      amu_get_name_
                         000103 bndsw                       amu_get_name_
                         000104 bmp                         amu_get_name_
                         000106 branch                      amu_get_name_
                         000112 code                        amu_get_name_
                         000113 dirname                     amu_get_name_
                         000165 ename                       amu_get_name_
                         000175 tdname                      amu_get_name_
                         000247 tename                      amu_get_name_
                         000260 genp                        amu_get_name_
                         000262 hard_ptrs                   amu_get_name_
                         000300 key                         amu_get_name_
                         000301 libx                        amu_get_name_
                         000302 ling                        amu_get_name_
                         000303 k                           amu_get_name_
                         000304 i                           amu_get_name_
                         000305 j                           amu_get_name_
                         000306 mblen                       amu_get_name_
                         000307 dl                          amu_get_name_
                         000310 namebuf                     amu_get_name_
                         000362 new_sdw                     amu_get_name_
                         000364 nmp                         amu_get_name_
                         000366 nsdwp                       amu_get_name_
                         000370 offrel                      amu_get_name_
                         000372 oi_area                     amu_get_name_
                         000460 ptrtmp                      amu_get_name_
                         000462 ret_ptr_sw                  amu_get_name_
                         000464 sblkp                       amu_get_name_
                         000466 segno                       amu_get_name_
                         000470 segptr                      amu_get_name_
                         000472 trans_space                 amu_get_name_
                         000506 segname                     amu_get_name_
                         000607 offset                      amu_get_name_
                         000610 dnl                         amu_get_name_
                         000611 replaced_path               amu_get_name_
                         000663 seg_name                    amu_get_name_
                         000736 vtocep                      amu_get_name_
                         000740 hardcore_cur_ptr            amu_get_name_
                         000742 amu_info_ptr                amu_get_name_
                         000744 translation_ptr             amu_get_name_
                         000746 astep                       amu_get_name_
                         000750 kstp                        amu_get_name_
                         000752 sl_info_p                   amu_get_name_
                         000754 sstp                        amu_get_name_
                         000756 sstnp                       amu_get_name_
                         000760 sltp                        amu_get_name_
                         000762 names_ptr                   amu_get_name_
                         000764 namep                       amu_get_name_
                         000766 sltep                       amu_get_name_
                         001002 pid_ptr                     check_if_early_hardcore_seg
                         001012 dpathp                      get_init_seg_slt
                         001022 seg_path                    get_l1dir_shortname
                         001074 dirname                     get_l1dir_shortname
                         001146 ename                       get_l1dir_shortname
                         001156 l1dirname                   get_l1dir_shortname
                         001166 idx                         get_l1dir_shortname
                         001167 jdx                         get_l1dir_shortname
                         001170 done                        get_l1dir_shortname
                         001220 dpathp                      get_sup_seg_slt
                         001236 segn                        kst_name
                         001237 uid_path                    kst_name
                         001257 code                        kst_name
                         001260 expanded_path               kst_name
                         001350 nfsw                        get_vtoc_pathname
                         001351 local_vtoce                 get_vtoc_pathname
                         001651 pn                          get_vtoc_pathname
                         001723 myname                      get_vtoc_pathname
                         001730 opvtx                       get_vtoc_pathname
                         001731 ovtocx                      get_vtoc_pathname
recurse                  000100 ptsi                        recurse
                         000101 ra                          recurse
                         000102 sstnt_idx                   recurse
                         000103 name                        recurse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc
return_mac          tra_ext_1           signal_op           enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      set_chars_eis       index_chars_eis     return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$dp_segno_to_name         amu_$fdump_translate_contiguous
amu_$hardcore_info_set_cur_ptrs                             amu_$kst_util_expand_uid_path
amu_$kst_util_segno_to_uid_path                             amu_$resolve_virtual_addr     amu_$return_val_phcs_ok
amu_$search_path_get_object   amu_$search_path_set_object   amu_$translate_force_add      amu_$translate_get
amu_do_translation_           amu_get_name_                 check_gate_access_            expand_path_
expand_pathname_              get_bound_seg_info_           get_system_free_area_         hcs_$fs_get_path_name
hcs_$initiate_count           hcs_$status_                  hcs_$terminate_noname         ioa_
ioa_                          ioa_$rsnnl                    ioa_$rsnnl                    pathname_
phcs_$get_vtoce               vpn_cv_uid_path_$ent

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$null_sltnt            amu_et_$null_sltp             error_table_$action_not_performed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000270       147 000303       148 000305       150 000306       152 000322       153 000323       154 000325
    156 000326       158 000337       159 000341       160 000342       162 000343       176 000363       177 000364
    178 000376       180 000444       182 000477       185 000625       187 000631       188 000634       189 000636
    190 000640       191 000651       192 000655       193 000660       194 000662       195 000666       198 000720
    199 000723       200 000724       204 000735       205 000741       208 000773       209 000776       210 000777
    214 001010       215 001030       216 001032       217 001042       218 001075       219 001147       222 001200
    224 001207       226 001215       227 001220       228 001222       231 001254       232 001257       233 001260
    236 001271       237 001323       239 001332       240 001367       242 001417       243 001422       246 001423
    247 001427       248 001432       249 001460       250 001464       254 001514       255 001516       256 001545
    263 001557       264 001561       265 001564       267 001565       269 001570       271 001611       272 001633
    275 001634       276 001701       277 001705       280 001726       281 001727       284 001732       285 001750
    286 001752       287 001755       288 001756       289 001757       290 002020       291 002035       292 002040
    293 002042       295 002053       298 002103       304 002151       305 002160       306 002163       307 002165
    310 002175       313 002227       314 002232       315 002233       318 002244       319 002276       321 002305
    322 002342       324 002372       325 002375       328 002376       330 002404       331 002407       333 002431
    334 002463       335 002520       336 002547       338 002556       340 002612       341 002647       343 002677
    344 002702       346 002713       348 002730       349 002734       350 002737       353 002767       354 002771
    355 003001       356 003050       357 003054       358 003056       362 003114       364 003115       365 003117
    366 003161       370 003217       371 003221       372 003224       373 003226       374 003232       376 003252
    379 003263       380 003265       381 003310       382 003342       383 003346       384 003401       387 003402
    388 003413       389 003421       390 003424       392 003434       393 003441       394 003444       395 003507
    397 003510       399 003512       400 003540       402 003555       404 003605       412 003633       413 003641
    414 003643       415 003651       416 003654       419 003705       420 003713       423 003714       424 003716
    826 003727       426 003730       445 003746       446 003750       447 003761       448 003766       449 003771
    452 003772       453 003774       456 004025       458 004026       466 004044       467 004046       470 004055
    471 004060       473 004061       476 004070       477 004104       479 004105       480 004113       481 004116
    483 004117       484 004122       485 004127       486 004134       487 004137       488 004144       489 004151
    490 004152       491 004157       494 004160       509 004203       510 004211       511 004231       513 004233
    514 004237       515 004252       516 004255       519 004256       520 004262       521 004265       522 004275
    524 004313       526 004316       527 004331       530 004332       531 004333       532 004336       533 004347
    534 004361       535 004370       537 004372       538 004374       539 004376       540 004404       541 004406
    542 004414       543 004455       544 004457       545 004472       546 004476       550 004512       552 004516
    555 004521       556 004522       557 004533       560 004562       561 004575       563 004577       565 004601
    569 004605       570 004617       571 004632       572 004645       573 004661       574 004670       575 004711
    579 004724       581 004750       582 004755       583 004763       584 004770       586 004772       588 004773
    596 005011       597 005013       600 005022       601 005025       603 005026       606 005035       607 005040
    609 005041       610 005047       611 005052       613 005053       614 005056       615 005063       616 005070
    617 005073       618 005100       619 005105       620 005106       621 005113       624 005114       626 005116
    628 005135       629 005141       630 005144       632 005146       633 005147       635 005172       637 005202
    638 005221       641 005231       642 005234       647 005242       660 005244       661 005246       662 005251
    663 005252       664 005255       665 005266       667 005275       668 005312       669 005315       670 005342
    671 005345       673 005350       677 005351       684 005362       685 005366       686 005371       688 005374
    689 005404       691 005412       694 005413       695 005416       696 005423       699 005424       700 005461
    702 005463       711 005471       712 005477       713 005510       714 005522       715 005525       717 005532
    719 005545       723 005555       727 005571       729 005600       731 005607       732 005621       734 005634
    738 005654       739 005667       741 005746       745 006035       749 006036       756 006037       759 006042
    760 006044       761 006051       762 006055       763 006102       764 006105       765 006122       766 006124
    767 006161       770 006162       771 006165       772 006170       773 006225       776 006226       777 006231
    778 006260       780 006302       781 006331


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
