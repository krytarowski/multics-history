	COMPILATION LISTING OF SEGMENT heals_mos_edac_reports_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/30/87  1325.1 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(87-10-21,Martinson), approve(87-10-21,MCR7751),
       12*     audit(87-11-20,Fawcett), install(87-11-30,MR12.2-1006):
       13*     Fix size condition error in heals_report mos_edac_error.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 
       17 /* heals_mos_edac_reports_ produces the edac error
       18*   report using edit_mos_rscr_ for formating purposes.
       19*   Coded by A. Downing July 1976. */
       20 /* Modified 12/26/76 by A. Downing to change error header. */
       21 /* Modified Feb. 1979 by A. Downing for
       22*   several bug fixes and code cleaning for MR7.0 */
       23 
       24 heals_mos_edac_reports_: proc (datap, code);
  1     1 /* heals_arg_info.incl.pl1 contains the declaration
  1     2*   of the argument structure passed between heals releated utilities.
  1     3*   Created January 1976 by A. R. Downing */
  1     4 dcl 1 heals_arg_info aligned,
  1     5     2 iocbp ptr,
  1     6     2 report_iocbp ptr,
  1     7     2 err_nb fixed bin (35),
  1     8     2 info_selection bit (72) unal,
  1     9     2 report_name char (64) varying,
  1    10     2 heals_log_path_name char (168),			/* path name of the heals log */
  1    11     2 system_id char (32) varying,
  1    12     2 installation_id char (32) varying,
  1    13     2 from_seq fixed bin (35),			/* beginning seq_num */
  1    14     2 to_seq fixed bin (35),				/* ending seq_num */
  1    15     2 from_time fixed bin (71),			/* beginning of desired time period */
  1    16     2 to_time fixed bin (71);				/* end of desired time period */
  1    17 						/* end heals_arg_info. */
       25 
       26 dcl  datap ptr;
       27 dcl 1 arg_info like heals_arg_info aligned based (datap);
       28 dcl  code fixed bin (35);
       29 dcl  act_len fixed bin (21);
       30 dcl  error_table_$end_of_info ext static fixed bin (35);
       31 dcl  error_rate pic "zzzzz9v.99" aligned init (5.0);
       32 dcl  descrip char (100) varying;
       33 dcl  buffer char (2048) aligned;
       34 dcl  buf_p ptr init (null ());
       35 dcl  clock_ entry returns (fixed bin (71));
       36 dcl (ioa_$ioa_switch, com_err_) entry options (variable);
       37 dcl  edit_mos_rscr_ entry (ptr, char (*) varying);
       38 dcl  date_time_ entry (fixed bin (71), char (*));
       39 dcl  hphcs_$set_mos_polling_time entry (fixed bin);
       40 dcl  iox_$close entry (ptr, fixed bin (35));
       41 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       42 dcl (t1, t2, runtime) char (16) init ("");
       43 dcl  bin_clock fixed bin (71) init (clock_ ());
       44 dcl  one_hour fixed bin (71) int static init (3600000000);	/* in micro seconds */
       45 dcl  size condition;
       46 dcl  alloc_count fixed bin init (0);
       47 dcl  msg_count fixed bin (21) init (0);
       48 dcl  first_data_line fixed bin init (7);
       49 dcl  line_count fixed bin init (0);
       50 dcl  max_lines fixed bin init (50);
       51 dcl  polling_interval fixed bin init (0);
       52 dcl  bit_default_polling_interval int static bit(36) init ("101"b);
       53 dcl  default_polling_interval int static fixed bin init (5);
       54 dcl  read_polling_interval bit (1) init ("0"b);
       55 dcl  use_equals bit (1) aligned init ("0"b);
       56 dcl (p, first_info_p, refer_p, thread_end_p) ptr init (null ());
       57 dcl 1 counter_info based (p),
       58     2 descrip char (40) varying,
       59     2 time fixed bin (71),
       60     2 seq_num fixed bin (35),
       61     2 count fixed bin (35),
       62     2 error_average fixed dec (8, 2),
       63     2 next_info_p ptr,
       64     2 data dim (heals_message.data_size) bit (36) aligned;
       65 dcl  counter_area area (16384);
       66 dcl  cleanup condition;
       67 dcl  area condition;
       68 dcl  linkage_error condition;
       69 dcl (addr, after, before, bin, empty, index, length, null) builtin;
       70 
       71 	call date_time_ (bin_clock, runtime);
       72 	call date_time_ ((arg_info.from_time), t1);
       73 	call date_time_ ((arg_info.to_time), t2);
       74 	arg_info.err_nb = -1;
       75 	counter_area = empty ();			/* reset it for allocations */
       76 	buf_p = addr (buffer);
       77 	on cleanup call clean_up;
       78 	on area begin;
       79 dcl  error_table_$noalloc ext static fixed bin (35);
       80 	  call com_err_ (error_table_$noalloc, "heals_mos_edac_reports_",
       81 	    "internal area overflow:
       82 run mos_edac_error report for a shorter time period for complete error listing.");
       83 	  go to done;				/* print what we got anyway */
       84 	end;
       85 
       86 	if arg_info.report_iocbp = null () then do;
       87 	  call com_err_ (0, "heals_mos_edac_reports_",
       88 	    "report stream is not open.");
       89 	  arg_info.err_nb = -1;
       90 	  go to done;
       91 	end;
       92 	call iox_$read_record (arg_info.iocbp, addr (buffer), length (buffer), act_len, code);
       93 	if code ^= 0 then
       94 	  if code ^= error_table_$end_of_info then do;
       95 read_error:
       96 	    call com_err_ (code, "heals_mos_edac_reports_", "error reading heals_log.");
       97 	    call clean_up;
       98 	    return;
       99 	  end;
      100 	  else go to done;
      101 	else;
      102 	heals_message_p = addr (buffer);
      103 scan_loop: do while ("1"b);
      104 	  if index (heals_message.text, "mos_memory_check") > 0 |
      105 	  (use_equals & heals_message.text = "=") then
      106 use_message:  do;
      107 	    use_equals = "1"b;			/* still process = records */
      108 	    if index (heals_message.text, "MOS polling") > 0 then do;
      109 	      read_polling_interval = "1"b;		/* we have the interval record */
      110 	      on size begin;
      111 	        call com_err_ (0, "heals_mos_edac_reports_",
      112 		"heals_log message #^d has an invalid time interval value, ^d is assumed.",
      113 		heals_message.seq_num, default_polling_interval);
      114 	        heals_message.data (1) = bit_default_polling_interval;
      115 	        polling_interval = default_polling_interval;
      116 	      end;
      117 (size):	      polling_interval = bin (before (after (heals_message.text, "MOS polling time "), " minutes"));
      118 	      revert size;
      119 	      go to message_used;
      120 	    end;
      121 	    if ^read_polling_interval then do;
      122 	      polling_interval = -1;			/* for reading interval */
      123 	      on linkage_error go to skip_hphcs_call;	/* incase not enough access */
      124 	      call hphcs_$set_mos_polling_time (polling_interval);
      125 skip_hphcs_call:
      126 	      revert linkage_error;			/* reset */
      127 	    end;
      128 	    if polling_interval < 1 then polling_interval = default_polling_interval;
      129 	    p, refer_p = null ();
      130 check_allocations:
      131 	    do p = first_info_p repeat (p -> next_info_p) while (p ^= null ());
      132 	      if heals_message.data (1) = p -> counter_info.data (1) &
      133 	      heals_message.data (2) = p -> counter_info.data (2) then
      134 	        if after (heals_message.text, "mos_memory_check:") = p -> counter_info.descrip then
      135 		if heals_message.time - one_hour <= p -> counter_info.time then do;
      136 		  p -> count =
      137 		    p -> count + heals_message.tally;
      138 		  p -> counter_info.time = heals_message.time;
      139 		  p -> counter_info.seq_num = heals_message.seq_num;
      140 		  p -> error_average = p -> error_average +
      141 		    (polling_interval * heals_message.tally);
      142 		  go to was_allocated;
      143 		end;
      144 	      thread_end_p = p;
      145 	    end;
      146 						/* if we are here, must allocate new counter */
      147 	    allocate counter_info in (counter_area) set (p);
      148 	    if first_info_p = null () then do;
      149 	      first_info_p = p;
      150 	      thread_end_p = p;
      151 	    end;
      152 	    else thread_end_p -> next_info_p = p;	/* link chain */
      153 	    alloc_count = alloc_count + 1;
      154 (stringsize):
      155 	    p -> counter_info.descrip =
      156 	      after (heals_message.text, "mos_memory_check:");
      157 	    p -> counter_info.data = heals_message.data;
      158 	    p -> count = heals_message.tally;
      159 	    p -> counter_info.time = heals_message.time;
      160 	    p -> counter_info.seq_num = heals_message.seq_num;
      161 	    p -> error_average =
      162 	      p -> count * polling_interval;
      163 	    p -> next_info_p = null ();
      164 was_allocated:
      165 message_used:
      166 	  end use_message;
      167 	  else use_equals = "0"b;
      168 	  call iox_$read_record (arg_info.iocbp, addr (buffer), length (buffer), act_len, code);
      169 	  if code ^= 0 then
      170 	    if code ^= error_table_$end_of_info then go to read_error;
      171 	    else go to done;
      172 	  else;
      173 	  if heals_message.time > arg_info.to_time then go to done;
      174 get_record:
      175 end_scan_loop: end scan_loop;
      176 done:
      177 	if alloc_count = 0 then
      178 	  call ioa_$ioa_switch (arg_info.report_iocbp,
      179 	  "^|MOS_EDAC_ERROR_REPORT:^5xfrom^x^16a^5xto^x^16a
      180 HEALS RUN OF ^16a^xON^xSYSTEM^x^a^/
      181 ^- There were no mos_edac errors during the report period.",
      182 	  t1, t2, runtime, arg_info.system_id);
      183 
      184 	do p = first_info_p repeat (p -> next_info_p) while (p ^= null ());
      185 	  if p -> counter_info.count > 1 then
      186 	    p -> counter_info.error_average =
      187 	    p -> counter_info.error_average / p -> counter_info.count;
      188 	  error_rate = p -> counter_info.error_average;	/* to get as picture */
      189 	  call edit_mos_rscr_ (addr (p -> counter_info.data (1)), descrip);
      190 	  call print_msg;				/* to actually print out the messages */
      191 	end;
      192 	arg_info.err_nb = 0;
      193 	call ioa_$ioa_switch (arg_info.report_iocbp, "^/END: MOS_EDAC_ERROR_REPORT");
      194 	call clean_up;
      195 clean_up:	proc;
      196 	  if arg_info.iocbp ^= null () then
      197 	    call iox_$close (arg_info.iocbp, code);
      198 	  counter_area = empty ();
      199 	  return;
      200 	end clean_up;
      201 	return;
      202 						/*  */
      203 print_msg: proc;					/* procedure to write edac messages to report. */
      204 	  if msg_count = 0 | line_count >= max_lines then do;
      205 	    call ioa_$ioa_switch (arg_info.report_iocbp,
      206 	      "^|MOS_EDAC_ERROR_REPORT:^5xfrom^x^16a^5xto^x^16a
      207 HEALS RUN OF ^16a^xON^xSYSTEM^x^a^/",
      208 	      t1, t2, runtime, arg_info.system_id);
      209 	    call ioa_$ioa_switch (arg_info.report_iocbp,
      210 	      "^7xLAST ERROR^11xTALLY^2xAVERAGE^4xSYSTEM CONTROLLER REGISTER
      211 LOG_NUM^xDATE^8xTIME^11xMINUTES
      212 ^36x/ERROR^/");
      213 	    line_count = first_data_line;
      214 	  end;
      215 	  call date_time_ (p -> counter_info.time, t1);
      216 	  call ioa_$ioa_switch (arg_info.report_iocbp,
      217 	    "^x^6d^x^16a^4x^5d^9a^5x^w^x^w",
      218 	    p -> counter_info.seq_num, t1, p -> counter_info.count,
      219 	    error_rate, p -> counter_info.data (1), p -> counter_info.data (2));
      220 	  call ioa_$ioa_switch
      221 	    (arg_info.report_iocbp, "^4x^a^x^a^/",
      222 	    p -> counter_info.descrip, descrip);
      223 	  msg_count = msg_count + 1;
      224 	  line_count = line_count + 3;
      225 	  return;
      226 	end print_msg;
      227 
      228 /* 
      229*   include files
      230**/
      231 
  2     1 /* Begin include file ...... scr.incl.pl1
  2     2*   modified 5/75 by Noel I. Morris
  2     3*   modified 10/81 by M.R. Jordan for 64K chip, M64 memory 
  2     4*   modified '83 to make values constant */
  2     5 
  2     6 /* This include file is to be used in conjunction with pmut$rscr and pmut$sscr.
  2     7*   Wherever possible the terms in the processor manual are used in the declaration. */
  2     8 
  2     9 dcl (SC_MR init (0),				/* SC Mode Register */
  2    10      SC_CFG init (1),				/* SC Configuration Switches */
  2    11      SC_MSK init (2),				/* SC Interrupt Mask */
  2    12      SC_IC init (3),				/* SC Interrupt Cells */
  2    13      SC_ETC init (4),				/* SC Elapsed Time Clock */
  2    14      SC_SU init (6)) fixed bin (6) static options (constant); /* SU Mode Register */
  2    15 
  2    16 
  2    17 dcl  scrp ptr;					/* pointer to SC data */
  2    18 
  2    19 dcl 1 scr_cfg1 based (scrp) aligned,			/* configuration data for 6000 SC */
  2    20 
  2    21    (2 mode_a bit (3),				/* 000 => on-line
  2    22*						   001 => test mode
  2    23*						   010 => off-line */
  2    24     2 bdry_a bit (3),				/* 000 => 32K, 001 => 64K, etc */
  2    25     2 mode_b bit (3),				/* see mode_a */
  2    26     2 bdry_b bit (3),				/* see bdry_a */
  2    27     2 int bit (1),					/* 1 => stores are internally interlaced */
  2    28     2 lwr bit (1),					/* 1 => store B is low */
  2    29     2 addr_offset bit (2),				/* 00 => no offset, 01 => 32K offset, etc. */
  2    30     2 port_no bit (4),				/* requester's port number */
  2    31     2 port_enable (0:7) bit (2),			/* 00 => port disabled
  2    32*						   01 => port under program control
  2    33*						   11 => port enabled */
  2    34     2 pima (4) bit (9)) unaligned;			/* program interrupt mask assignments
  2    35*						   000 => unassigned
  2    36*						   400 => assigned to port 0
  2    37*						   200 => assigned to port 1
  2    38*						   .
  2    39*						   .
  2    40*						   .
  2    41*						   002 => assigned to port 7
  2    42*						   001 => assigned to maint. panel */
  2    43 
  2    44 
  2    45 dcl 1 scr_cfg2 based (scrp) aligned,			/* configuration data for 4MW SCU */
  2    46 
  2    47    (2 mask_a_assign bit (9),				/* interrupt mask "A" port assignment
  2    48*						   400 => assigned to port 0
  2    49*						   .
  2    50*						   .
  2    51*						   002 => assigned to port 7
  2    52*						   001 => mask off */
  2    53     2 size bit (3),					/* size of lower store */
  2    54     2 a_online bit (1),				/* 1 => store A online */
  2    55     2 a1_online bit (1),				/* 1 => store A1 online */
  2    56     2 b_online bit (1),				/* 1 => store B online */
  2    57     2 b1_online bit (1),				/* 1 => store B1 online */
  2    58     2 port_no bit (4),				/* requester's port number */
  2    59     2 pad1 bit (1),
  2    60     2 mode bit (1),					/* 1 => programmable mode */
  2    61     2 nea_enabled bit (1),				/* 1 => non-existent address logic enabled */
  2    62     2 nea bit (7),					/* 001 => 32K, 002 => 64K, 003 => 96K, etc. */
  2    63     2 int bit (1),					/* 1 => stores are internally interlaced */
  2    64     2 lwr bit (1),					/* 1 => store B is low */
  2    65     2 port_mask_0_3 bit (4),				/* 1 => corresponding port enabled */
  2    66 
  2    67     2 mask_b_assign bit (9),				/* interrupt mask "B" port assignment */
  2    68     2 pad2 bit (12),
  2    69     2 cyclic_prior bit (7),				/* cyclic port priority switches */
  2    70     2 pad3 bit (4),
  2    71     2 port_mask_4_7 bit (4)) unal;			/* 1 => corresponding port enabled */
  2    72 
  2    73 
  2    74 dcl 1 scr_mr based (scrp) aligned,			/* SC mode register */
  2    75 
  2    76    (2 pad1 bit (50),
  2    77     2 identification bit (4),				/* 0000 => 8034, 8035
  2    78*						   0001 => 6000 SC
  2    79*						   0010 => 4MW SCU */
  2    80     2 TS_strobe_margin bit (2),			/* 00 => normal timing
  2    81*						   01 => slow timing
  2    82*						   10 => inhibit strobe
  2    83*						   11 => fast timing */
  2    84     2 G0_strobe_margin bit (2),
  2    85     2 ANSWER_strobe_margin bit (2),
  2    86     2 DA_strobe_margin bit (2),
  2    87     2 EOC_strobe_margin bit (2),
  2    88     2 PLUS_5_VOLT_margin bit (2),			/* 00 => normal voltage
  2    89*						   01 => -5%
  2    90*						   10 => normal voltage
  2    91*						   11 => +5% */
  2    92     2 parity_override bit (1),			/* 1 => SU forced to accept data with incorrect parity */
  2    93     2 parity_disable bit (1),				/* 1 => disable data and ZAC parity checking */
  2    94     2 store_IA_disable bit (1),			/* 1 => disable illegal action indication */
  2    95     2 ZAC_parity_error bit (1),			/* 1 => cause ZAC parity error */
  2    96     2 SGR_accepted bit (1),				/* 1 => SGR command accepted by SC */
  2    97     2 pad2 bit (1)) unal;
  2    98 
  2    99 
  2   100 dcl 1 scr_msk based (scrp) aligned,			/* SC mask register */
  2   101 
  2   102    (2 interrupt_mask_1 bit (16),			/* mask bits for interrupts 0 thru 15 */
  2   103     2 pad1 bit (16),
  2   104     2 port_mask_1 bit (4),				/* mask bits for ports 0 thru 3 */
  2   105 
  2   106     2 interrupt_mask_2 bit (16),			/* mask bits for interrupts 16 thru 31 */
  2   107     2 pad2 bit (16),
  2   108     2 port_mask_2 bit (4)) unal;			/* mask bits for ports 4 thru 7 */
  2   109 
  2   110 
  2   111 dcl 1 scr_su based (scrp) aligned,			/* store unit mode register */
  2   112 
  2   113    (2 pad1 bit (36),
  2   114     2 ZAC_line bit (6),				/* EDAC mode only - address field */
  2   115     2 syndrome bit (8),				/* EDAC mode only - failure syndrome */
  2   116     2 identification bit (4),				/* 0000 => High Speed Core Model AA1
  2   117*						   0001 => High Speed Core Model AA3
  2   118*						   0011 => 4K, 16 pin chip, MOS memory, M32 boards
  2   119*						   0100 => 1K chip MOS memory with EDAC enabled
  2   120*						   1010 => 64K, 16 pin chip, MOS memory, M64 boards
  2   121*						   1011 => 16K, 16 pin chip, MOS memory, M264 boards
  2   122*						   1100 => 1K chip MOS memory with EDAC disabled
  2   123*						   1110 => 16K, 16 pin chip, MOS memory, M128 boards
  2   124*						   1111 => 4K, 22 pin chip MOS memory, M16 boards */
  2   125     2 EDAC_disabled bit (1),				/* 1 => correction disabled but detection still enabled */
  2   126     2 pad2 bit (4),
  2   127     2 MINUS_5_VOLT_margin bit (2),
  2   128     2 PLUS_5_VOLT_margin bit (2),
  2   129     2 spare_margin bit (2),
  2   130     2 PLUS_19_VOLT_margin bit (2),
  2   131     2 pad3 bit (1),
  2   132     2 SENSE_strobe_margin bit (2),			/* core only */
  2   133     2 pad4 bit (1),
  2   134     2 maint_functions_enabled bit (1)) unal;		/* 1 => maintenance functions enabled */
  2   135 
  2   136 /* End of include file ...... scr.incl.pl1 */
  2   137 
      232 
  3     1 /* begin heals_message.incl.pl1 */
  3     2 /* Produced March 1976 by A. Downing. */
  3     3 dcl 1 heals_message based (heals_message_p) aligned,
  3     4     2 tally fixed bin (35),
  3     5     2 rest_of_record aligned,
  3     6       3 seq_num fixed bin (35),			/* Sequence number of this message. */
  3     7       3 time fixed bin (71) unal,			/* Time message logged at */
  3     8       3 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  3     9       3 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  3    10       3 data_size fixed bin (11) unal,			/* Size of binary data */
  3    11       3 data_code fixed bin (11) unal,			/* format type code */
  3    12       3 pad bit (60) unal,
  3    13       3 text char (0 refer (heals_message.text_len)),	/* Text of expanded message - kept in ASCII. */
  3    14       3 data (0 refer (heals_message.data_size)) bit (36);	/* Binary data area */
  3    15 dcl  heals_message_p ptr;
  3    16 						/* end heals_message.incl.pl1 */
      233 
      234         end heals_mos_edac_reports_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/30/87  1323.6  heals_mos_edac_reports_.pl1       >spec>install>1006>heals_mos_edac_reports_.pl1
25           1    11/02/76  1752.0  heals_arg_info.incl.pl1           >ldd>include>heals_arg_info.incl.pl1
232          2    08/17/83  1135.7  scr.incl.pl1                      >ldd>include>scr.incl.pl1
233          3    10/25/77  1258.3  heals_message.incl.pl1            >ldd>include>heals_message.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
act_len                         000232 automatic       fixed bin(21,0)          dcl 29 set ref 92* 168*
addr                                                   builtin function         dcl 69 ref 76 92 92 102 168 168 189 189
after                                                  builtin function         dcl 69 ref 117 132 154
alloc_count                     001316 automatic       fixed bin(17,0)          initial dcl 46 set ref 46* 153* 153 176
area                            041344 stack reference condition                dcl 67 ref 78
arg_info                               based           structure                level 1 dcl 27
before                                                 builtin function         dcl 69 ref 117
bin                                                    builtin function         dcl 69 ref 117
bin_clock                       001306 automatic       fixed bin(71,0)          initial dcl 43 set ref 43* 71*
bit_default_polling_interval           constant        bit(36)                  initial unaligned dcl 52 ref 114
buf_p                           001270 automatic       pointer                  initial dcl 34 set ref 34* 76*
buffer                          000270 automatic       char(2048)               dcl 33 set ref 76 92 92 92 92 102 168 168 168 168
cleanup                         041336 stack reference condition                dcl 66 ref 77
clock_                          000014 constant        entry                    external dcl 35 ref 43
code                                   parameter       fixed bin(35,0)          dcl 28 set ref 24 92* 93 93 95* 168* 169 169 196*
com_err_                        000020 constant        entry                    external dcl 36 ref 80 87 95 111
count                    17            based           fixed bin(35,0)          level 2 dcl 57 set ref 136* 136 158* 161 185 185
                                                                                  216*
counter_area                    001336 automatic       area(16384)              dcl 65 set ref 65* 75* 147 198*
counter_info                           based           structure                level 1 unaligned dcl 57 set ref 147
data                     26            based           bit(36)                  array level 2 in structure "counter_info" dcl 57
                                                                                  in procedure "heals_mos_edac_reports_" set ref 132
                                                                                  132 157* 189 189 216* 216*
data                                   based           bit(36)                  array level 3 in structure "heals_message" dcl 3-3
                                                                                  in procedure "heals_mos_edac_reports_" set ref
                                                                                  114* 132 132 157
data_size                 4(24)        based           fixed bin(11,0)          level 3 packed unaligned dcl 3-3 ref 147 157 157
datap                                  parameter       pointer                  dcl 26 ref 24 72 73 74 86 89 92 168 173 176 176 192
                                                                                  193 196 196 205 205 209 216 220
date_time_                      000024 constant        entry                    external dcl 38 ref 71 72 73 215
default_polling_interval        000010 internal static fixed bin(17,0)          initial dcl 53 set ref 111* 115 128
descrip                                based           varying char(40)         level 2 in structure "counter_info" dcl 57
                                                                                  in procedure "heals_mos_edac_reports_" set ref 132
                                                                                  154* 220*
descrip                         000236 automatic       varying char(100)        dcl 32 in procedure "heals_mos_edac_reports_" set
                                                                                  ref 189* 220*
edit_mos_rscr_                  000022 constant        entry                    external dcl 37 ref 189
empty                                                  builtin function         dcl 69 ref 65 75 198
err_nb                    4            based           fixed bin(35,0)          level 2 dcl 27 set ref 74* 89* 192*
error_average            20            based           fixed dec(8,2)           level 2 dcl 57 set ref 140* 140 161* 185* 185 188
error_rate                      000233 automatic       picture(9)               initial dcl 31 set ref 31* 188* 216*
error_table_$end_of_info        000012 external static fixed bin(35,0)          dcl 30 ref 93 169
error_table_$noalloc            000034 external static fixed bin(35,0)          dcl 79 set ref 80*
first_data_line                 001320 automatic       fixed bin(17,0)          initial dcl 48 set ref 48* 213
first_info_p                    001330 automatic       pointer                  initial dcl 56 set ref 56* 130 148 149* 184
from_time               126            based           fixed bin(71,0)          level 2 dcl 27 ref 72
heals_arg_info                  000100 automatic       structure                level 1 dcl 1-4
heals_message                          based           structure                level 1 dcl 3-3
heals_message_p                 041360 automatic       pointer                  dcl 3-15 set ref 102* 104 104 108 111 114 117 132
                                                                                  132 132 132 136 138 139 140 147 154 157 157 158
                                                                                  159 160 173
hphcs_$set_mos_polling_time     000026 constant        entry                    external dcl 39 ref 124
index                                                  builtin function         dcl 69 ref 104 108
ioa_$ioa_switch                 000016 constant        entry                    external dcl 36 ref 176 193 205 209 216 220
iocbp                                  based           pointer                  level 2 dcl 27 set ref 92* 168* 196 196*
iox_$close                      000030 constant        entry                    external dcl 40 ref 196
iox_$read_record                000032 constant        entry                    external dcl 41 ref 92 168
length                                                 builtin function         dcl 69 ref 92 92 168 168
line_count                      001321 automatic       fixed bin(17,0)          initial dcl 49 set ref 49* 204 213* 224* 224
linkage_error                   041352 stack reference condition                dcl 68 ref 123 125
max_lines                       001322 automatic       fixed bin(17,0)          initial dcl 50 set ref 50* 204
msg_count                       001317 automatic       fixed bin(21,0)          initial dcl 47 set ref 47* 204 223* 223
next_info_p              24            based           pointer                  level 2 dcl 57 set ref 145 152* 163* 191
null                                                   builtin function         dcl 69 ref 34 56 56 56 56 86 129 130 148 163 184 196
one_hour                        000000 constant        fixed bin(71,0)          initial dcl 44 ref 132
p                               001326 automatic       pointer                  initial dcl 56 set ref 56* 129* 130* 130* 132 132
                                                                                  132 132 136 136 138 139 140 140 144* 145 147* 149
                                                                                  150 152 154 157 158 159 160 161 161 163 184* 184*
                                                                                  185 185 185 185 188 189 189* 191 215 216 216 216
                                                                                  216 220
polling_interval                001323 automatic       fixed bin(17,0)          initial dcl 51 set ref 51* 115* 117* 122* 124* 128
                                                                                  128* 140 161
read_polling_interval           001324 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 109* 121
refer_p                         001332 automatic       pointer                  initial dcl 56 set ref 56* 129*
report_iocbp              2            based           pointer                  level 2 dcl 27 set ref 86 176* 193* 205* 209* 216*
                                                                                  220*
rest_of_record            1            based           structure                level 2 dcl 3-3
runtime                         001302 automatic       char(16)                 initial unaligned dcl 42 set ref 42* 71* 176* 205*
seq_num                   1            based           fixed bin(35,0)          level 3 in structure "heals_message" dcl 3-3
                                                                                  in procedure "heals_mos_edac_reports_" set ref
                                                                                  111* 139 160
seq_num                  16            based           fixed bin(35,0)          level 2 in structure "counter_info" dcl 57
                                                                                  in procedure "heals_mos_edac_reports_" set ref
                                                                                  139* 160* 216*
size                            001310 stack reference condition                dcl 45 ref 110 118
system_id               102            based           varying char(32)         level 2 dcl 27 set ref 176* 205*
t1                              001272 automatic       char(16)                 initial unaligned dcl 42 set ref 42* 72* 176* 205*
                                                                                  215* 216*
t2                              001276 automatic       char(16)                 initial unaligned dcl 42 set ref 42* 73* 176* 205*
tally                                  based           fixed bin(35,0)          level 2 dcl 3-3 ref 136 140 158
text                      7            based           char                     level 3 dcl 3-3 ref 104 104 108 117 132 154
text_len                  4(12)        based           fixed bin(11,0)          level 3 packed unaligned dcl 3-3 ref 104 104 108 114
                                                                                  117 132 132 132 154 157 157
thread_end_p                    001334 automatic       pointer                  initial dcl 56 set ref 56* 144* 150* 152
time                      2            based           fixed bin(71,0)          level 3 in structure "heals_message" packed
                                                                                  unaligned dcl 3-3 in procedure
                                                                                  "heals_mos_edac_reports_" ref 132 138 159 173
time                     14            based           fixed bin(71,0)          level 2 in structure "counter_info" dcl 57
                                                                                  in procedure "heals_mos_edac_reports_" set ref 132
                                                                                  138* 159* 215*
to_time                 130            based           fixed bin(71,0)          level 2 dcl 27 ref 73 173
use_equals                      001325 automatic       bit(1)                   initial dcl 55 set ref 55* 104 107* 167*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SC_CFG                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_ETC                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_IC                                  internal static fixed bin(6,0)           initial dcl 2-9
SC_MR                                  internal static fixed bin(6,0)           initial dcl 2-9
SC_MSK                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_SU                                  internal static fixed bin(6,0)           initial dcl 2-9
scr_cfg1                               based           structure                level 1 dcl 2-19
scr_cfg2                               based           structure                level 1 dcl 2-45
scr_mr                                 based           structure                level 1 dcl 2-74
scr_msk                                based           structure                level 1 dcl 2-100
scr_su                                 based           structure                level 1 dcl 2-111
scrp                                   automatic       pointer                  dcl 2-17

NAMES DECLARED BY EXPLICIT CONTEXT.
check_allocations               001170 constant        label                    dcl 130
clean_up                        001717 constant        entry                    internal dcl 195 ref 77 97 194
done                            001516 constant        label                    dcl 176 ref 83 90 93 171 173
end_scan_loop                   001515 constant        label                    dcl 174
get_record                      001515 constant        label                    dcl 174
heals_mos_edac_reports_         000314 constant        entry                    external dcl 24
message_used                    001444 constant        label                    dcl 164 ref 119
print_msg                       001750 constant        entry                    internal dcl 203 ref 190
read_error                      000662 constant        label                    dcl 95 ref 169
scan_loop                       000724 constant        label                    dcl 103
skip_hphcs_call                 001155 constant        label                    dcl 125 ref 123
use_message                     000747 constant        label                    dcl 104
was_allocated                   001444 constant        label                    dcl 164 ref 142

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2416        2454    2223        2426
Length      2726    2223        36         236     173           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
heals_mos_edac_reports_           17482 external procedure  is an external procedure.  
on unit on line 77                   64 on unit               
on unit on line 78                  110 on unit               
on unit on line 110                 112 on unit               
on unit on line 123                  64 on unit               
clean_up                             70 internal procedure  is called by several nonquick procedures.  
print_msg                               internal procedure  shares stack frame of external procedure heals_mos_edac_reports_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 default_polling_interval    heals_mos_edac_reports_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
heals_mos_edac_reports_  000100 heals_arg_info              heals_mos_edac_reports_
                         000232 act_len                     heals_mos_edac_reports_
                         000233 error_rate                  heals_mos_edac_reports_
                         000236 descrip                     heals_mos_edac_reports_
                         000270 buffer                      heals_mos_edac_reports_
                         001270 buf_p                       heals_mos_edac_reports_
                         001272 t1                          heals_mos_edac_reports_
                         001276 t2                          heals_mos_edac_reports_
                         001302 runtime                     heals_mos_edac_reports_
                         001306 bin_clock                   heals_mos_edac_reports_
                         001316 alloc_count                 heals_mos_edac_reports_
                         001317 msg_count                   heals_mos_edac_reports_
                         001320 first_data_line             heals_mos_edac_reports_
                         001321 line_count                  heals_mos_edac_reports_
                         001322 max_lines                   heals_mos_edac_reports_
                         001323 polling_interval            heals_mos_edac_reports_
                         001324 read_polling_interval       heals_mos_edac_reports_
                         001325 use_equals                  heals_mos_edac_reports_
                         001326 p                           heals_mos_edac_reports_
                         001330 first_info_p                heals_mos_edac_reports_
                         001332 refer_p                     heals_mos_edac_reports_
                         001334 thread_end_p                heals_mos_edac_reports_
                         001336 counter_area                heals_mos_edac_reports_
                         041360 heals_message_p             heals_mos_edac_reports_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
enable_op           ext_entry           int_entry           size_check_fx2      signal_stringsize   set_chars_eis
index_chars_eis     real_to_real_truncatany_to_any_truncate_divide_fx1          op_alloc_           op_empty_
index_before_cs     index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      date_time_                    edit_mos_rscr_
hphcs_$set_mos_polling_time   ioa_$ioa_switch               iox_$close                    iox_$read_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$noalloc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000310        31 000321        34 000325        42 000327        43 000340        46 000347        47 000350
     48 000351        49 000353        50 000354        51 000356        54 000357        55 000360        56 000361
     65 000366        71 000371        72 000407        73 000433        74 000457        75 000464        76 000467
     77 000471        78 000513        80 000527        83 000555        86 000560        87 000567        89 000621
     90 000626        92 000627        93 000654        95 000662        97 000714        98 000720       102 000721
    104 000724       107 000747       108 000751       109 000760       110 000762       111 000776       114 001040
    115 001052       116 001055       117 001056       118 001120       119 001121       121 001122       122 001124
    123 001126       124 001145       125 001155       128 001157       129 001165       130 001170       132 001176
    136 001244       138 001250       139 001252       140 001254       142 001306       144 001307       145 001310
    147 001313       148 001325       149 001331       150 001332       151 001333       152 001334       153 001336
    154 001337       157 001367       158 001417       159 001421       160 001425       161 001427       163 001442
    164 001444       167 001445       168 001446       169 001475       171 001503       173 001504       174 001515
    176 001516       184 001563       185 001572       188 001630       189 001635       190 001656       191 001657
    192 001663       193 001667       194 001711       201 001715       195 001716       196 001724       198 001743
    199 001747       203 001750       204 001752       205 001757       209 002021       213 002046       215 002050
    216 002067       220 002147       223 002207       224 002210       225 002212


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
