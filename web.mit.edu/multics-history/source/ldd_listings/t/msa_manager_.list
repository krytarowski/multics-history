	COMPILATION LISTING OF SEGMENT msa_manager_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/17/85  0948.9 mst Tue
	    Options: optimize map single_symbol_list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       11 	/*									*/
       12 	/* N__a_m_e:  msa_manager_							*/
       13 	/*									*/
       14 	/*      A multi-segment area (MSA) is logically an infinite area in which PL/I type	*/
       15 	/* allocations may be performed.  Physically, it is a multi-segment file (MSF) whose	*/
       16 	/* segments each contain a header used by the msa_manager_, and an allocation area.	*/
       17 	/* Each of these segments is called a single-segment area (SSA).			*/
       18 	/*									*/
       19 	/*      This procedure creates, terminates, truncates, and deletes multi-segment areas	*/
       20 	/* (MSA's); handles "area" conditions signalled for the single-segment areas (SSA's)	*/
       21 	/* which make up an MSA; and re-initiates an MSA which has been terminated so that it may	*/
       22 	/* be used, perhaps in a different process.					*/
       23 	/*									*/
       24 	/*      Two entry points are also provided to get and release system MSA's created and	*/
       25 	/* managed in the caller's process directory.					*/
       26 	/*									*/
       27 	/*      The current version of alloc_, the Multics program which performs allocations	*/
       28 	/* when a PL/I allocate statement is encountered, does not pass any information about	*/
       29 	/* an allocation failure when it signals "area".  Because msa_manager_ requires a	*/
       30 	/* pointer to the SSA in which the allocation failed, and because msa_manager_		*/
       31 	/* must be able to tell the allocation program to reattempt the failing allocation in	*/
       32 	/* another SSA, some information must be passed when "area" is signalled.  The		*/
       33 	/* smart_alloc_ subroutine may be used as an intermediary between the PL/I allocate	*/
       34 	/* statement and alloc_.  It will pass the information msa_manager_ needs when "area"	*/
       35 	/* is signalled, and it will allow msa_manager_ to change the area in which the allocation*/
       36 	/* is to be reattempted.  (See Notes below for a description of the information structure	*/
       37 	/* which msa_manager_ expects when "area" is signalled.  See the description of the	*/
       38 	/* smart_alloc_ subroutine to learn how to tell PL/I to invoke smart_alloc_ to execute	*/
       39 	/* an allocate statement.)							*/
       40 	/*									*/
       41 	/*      Using smart_alloc_ in all programs, here is a typical usage sequence for an MSA:	*/
       42 	/* 1) The control program of a subsystem (the program invoked before any allocations	*/
       43 	/*    are to be performed, and which does not return until all allocations have been	*/
       44 	/*    performed) creates an MSA, consisting initially of a single segment, an SSA.	*/
       45 	/*    The control program references the MSA through an pointer to the current 		*/
       46 	/*    SSA of the MSA.  This pointer is called the MSA pointer.  It may be allocated in	*/
       47 	/*    the control program's automatic or static storage, or it may optionally be	*/
       48 	/*    allocated in the header of the first SSA of the MSA, and referenced by the control	*/
       49 	/*    program as a based MSA pointer. For example,				*/
       50 	/*									*/
       51 	/*   	dcl	msa_ptr ptr based (Pmsa_ptr);					*/
       52 	/*									*/
       53 
       54 	/* 2) The control program also establishes msa_manager_$area_handler as its "area"	*/
       55 	/*    condition handler.							*/
       56 	/* 3) The control program may then perform allocations in the MSA, using the PL/I allocate*/
       57 	/*    statement, or it may pass the MSA pointer (not a dummy variable, or some other copy	*/
       58 	/*    of this pointer, but the pointer itself) to one or more other subprograms to allow	*/
       59 	/*    them to perform allocations in the MSA.					*/
       60 	/* 4) When an allocation cannot be performed because the first SSA is full, then	*/
       61 	/*    smart_alloc_ signals the "area" condition, passing an information structure to the	*/
       62 	/*    "area" condition handler, which is msa_manager_$area_handler.			*/
       63 	/* 5) msa_manager_$area_handler converts the SSA, a single-segment file (SSF), into a	*/
       64 	/*    multi-segment file (MSF), consisting of the original SSA, plus a new SSA.		*/
       65 	/*    It updates the pointer in the information structure passed by smart_alloc_ to point	*/
       66 	/*    to this new SSA, and it also updates the control program's MSA pointer to point	*/
       67 	/*    to this new SSA.							*/
       68 	/* 6) On return from the handler, smart_alloc_ then reattempts the allocation in the new	*/
       69 	/*    SSA.								*/
       70 	/* 7) When this new SSA fills up, the "area" condition is signalled again.  This time,	*/
       71 	/*    msa_manager_$area_handler attempts to perform the allocaton in each of the	*/
       72 	/*    existing SSA's, before appending a new SSA to the MSA.  In this way, the MSA grows	*/
       73 	/*    only when necessary, taking advantage of any space freed in existing SSA's 	*/
       74 	/*    whenever possible.							*/
       75 	/* 8) Finally, when the control program has finished using the MSA, it may delete it,	*/
       76 	/*    truncate it to zero length for later use, or terminate it for later re-initiation	*/
       77 	/*    (perhaps in another process).						*/
       78 	/*									*/
       79 	/* E__n_t_r_y:  msa_manager_$make							*/
       80 	/*									*/
       81 	/*      This entry point creates a new MSA in the directory specified by the caller.	*/
       82 	/* If an MSA of the same name already exists in that directory, nd_handler_ is invoked	*/
       83 	/* to ask the user whether the existing MSA should be deleted.  If the user answers "no",	*/
       84 	/* then an error code of error_table_$namedup is returned.				*/
       85 	/*									*/
       86 	/* U__s_a_g_e									*/
       87 	/*									*/
       88 	/*      dcl  msa_manager_$make entry (char(*), char(*), ptr, fixed bin(35),		*/
       89 	/*	   ptr, fixed bin(35);						*/
       90 	/*									*/
       91 	/*      call msa_manager_$make (directory, entry, Pareap, Luser, Puser, code);		*/
       92 	/*									*/
       93 	/* 1) directory	is the path name of the directory in which the MSA is to be created.	*/
       94 	/*		(In)							*/
       95 	/* 2) entry	is the entry name of the MSA to be created.  If this name is a null	*/
       96 	/*		character string, then the final entry name of the directory path	*/
       97 	/*		is used as the entry name of the MSA. (In)			*/
       98 	/* 3) Pareap	points to the MSA pointer for the MSA which was created.		*/
       99 	/*		If Pareap is a null pointer on input, then it will point to an MSA	*/
      100 	/*		pointer created in the header of the first SSA of the MSA. (Out)	*/
      101 	/*		Otherwise, Pareap points to an MSA pointer defined by the caller. (In)*/
      102 	/* 4) Luser	is the length (in words) of a user-defined region which is to be	*/
      103 	/*		created in the header of the first SSA of the MSA.  The caller may	*/
      104 	/*		use this region to store base pointers to an information structure	*/
      105 	/*		contained in the MSA, to store identifying information, etc.  The	*/
      106 	/*		region is guaranteed to begin on a double-word boundary.  If a	*/
      107 	/*		length of 0 is specified, then no user-defined region is created. (In)*/
      108 	/* 5) Puser	points to the Luser words of the user-defined region in the		*/
      109 	/*		header of the first SSA. (Out)				*/
      110 	/* 6) code	may be one of the following status codes. (Out)			*/
      111 
      112 	/*    error_table_$namedup							*/
      113 	/*		the MSA already exists, and the user did not want to delete it.	*/
      114 	/*									*/
      115 	/*    error_table_$dirseg							*/
      116 	/*		_d_i_r_e_c_t_o_r_y>_e_n_t_r_y identifies a directory.  msa_manager_$make cannot	*/
      117 	/*		delete directories in order to create an MSA.			*/
      118 	/*									*/
      119 	/*		Any status code returned by hcs_$append_branchx, hcs_$initiate, or	*/
      120 	/*		hcs_$set_bc_seg.						*/
      121 	/*									*/
      122 	/* E__n_t_r_y:  msa_manager_$area_handler						*/
      123 	/*									*/
      124 	/*      This entry point acts as a condition handler for the "area" condition which	*/
      125 	/* is signalled when an allocation fails in one of the SSA's of an MSA.  It expects	*/
      126 	/* to receive an information structure from the program which signalled "area".  From	*/
      127 	/* this structure, it gets a pointer to the area segment in which the allocation failed.	*/
      128 	/* It examines the header of the segment containing this area to insure that it is an 	*/
      129 	/* SSA.  If it is not an SSA, or if no information structure is passed to the		*/
      130 	/* handler, then it passes the "area" condition on to a handler defined by the caller 	*/
      131 	/* at an earlier point in the user's stack.					*/
      132 	/*      If the area is an SSA, then the area handler changes both the area pointer in the	*/
      133 	/* information structure and the control program's MSA pointer to point to another SSA	*/
      134 	/* in the MSA, if one exists, and returns to the allocation program so that the allocation*/
      135 	/* can be reattempted in this new SSA.						*/
      136 	/*      If the allocation also fails in this SSA, then the allocation program will	*/
      137 	/* signal the "area" condition again, and the area handler will return a pointer to the	*/
      138 	/* next SSA in the MSA.  This process continues until the allocation succeeds, or	*/
      139 	/* until the allocation has failed in each SSA of the MSA.				*/
      140 	/*      If the allocation has failed in each of the existing SSA's, then a new SSA is 	*/
      141 	/* appended to the MSA, and the allocation is reattempted.				*/
      142 	/*      If the allocation fails in this new SSA (which is completely empty), or if	*/
      143 	/* an error occurs while appending a new SSA to the MSA, then the allocation		*/
      144 	/* will never succeed, and the "area_handler_error_" condition is signalled, passing the	*/
      145 	/* signal information structure shown in the Notes below.				*/
      146 	/*      If the "area_handler_error_" condition handler returns, then the original	*/
      147 	/* "area" condition is passed on to a handler defined earlier in the user's stack.	*/
      148 	/*									*/
      149 	/* U__s_a_g_e									*/
      150 	/*									*/
      151 	/*      dcl  msa_manager_$area_handler entry (ptr, char(*), ptr, ptr, bit(1) aligned);	*/
      152 	/*									*/
      153 	/*      call msa_manager_$area_handler (Pmc, condition, Pwc_mc, Pinfo, continue_sw);	*/
      154 	/*									*/
      155 	/* 1) Pmc		points to hardware state information. (Ignored)			*/
      156 	/*      Given a pointer to an MSA pointer, this entry deletes the MSA which		*/
      157 	/* is pointed to.								*/
      158 	/*		be "area". (In)						*/
      159 	/* 3) Pwc_mc	points to wall crossing state information. (Ignored)		*/
      160 	/* 4) Pinfo	points to the allocation program's information structure. 		*/
      161 	/*		(See N__o_t_e_s below.) (In)					*/
      162 	/* 5) continue_sw	is "0"b. (In)						*/
      163 	/*		is "1"b if the "area" condition is to be passed on to another handler.*/
      164 	/*		(Out)							*/
      165 	/*									*/
      166 	/* E__n_t_r_y:  msa_manager_$delete						*/
      167 	/*									*/
      168 	/*      This entry deletes an existing MSA, given a pointer to the MSA's pointer.	*/
      169 
      170 	/* U__s_a_g_e									*/
      171 	/*									*/
      172 	/*      dcl  msa_manager_$delete entry (ptr, fixed bin(35));			*/
      173 	/*									*/
      174 	/*      call msa_manager_$delete (Pareap, code);					*/
      175 	/*									*/
      176 	/* 1) Pareap	points to the MSA pointer of the MSA to be deleted. (In)		*/
      177 	/* 2) code	may be any status code returned by hcs_$fs_get_path_name, by	*/
      178 	/*		hcs_$delentry_seg, or by delete_$path. (Out)			*/
      179 	/*									*/
      180 	/* E__n_t_r_y:  msa_manager_$truncate						*/
      181 	/*									*/
      182 	/*      Given a pointer to an MSA pointer, this entry terminates the SSA's		*/
      183 	/* of the MSA, deletes all but the first SSA of the MSA, truncates this SSA, and stores	*/
      184 	/* it as a single-segment file (SSF).  The entry point is useful for commands which 	*/
      185 	/* must use the same specifically-named MSA during each of their invocations, because it	*/
      186 	/* eliminates the overhead of creating an entirely new MSA in successive invocations.	*/
      187 	/*									*/
      188 	/* U__s_a_g_e									*/
      189 	/*									*/
      190 	/*      dcl  msa_manager_$truncate entry (ptr, fixed bin(35));			*/
      191 	/*									*/
      192 	/*      call msa_manager_$truncate (Pareap, code);				*/
      193 	/*									*/
      194 	/* 1) Pareap	points to the MSA pointer of the MSA to be truncated. (In)		*/
      195 	/* 2) code	may be any status code returned from hcs_$fs_get_path_name, from	*/
      196 	/*		hcs_$set_bc_seg, hcs_$truncate_seg, hcs_$terminate_seg, or		*/
      197 	/*		unmake_msf_. (Out)						*/
      198 	/*									*/
      199 	/* E__n_t_r_y:  msa_manager_$terminate						*/
      200 	/*									*/
      201 	/*      Given a pointer to an MSA pointer, this entry terminates the SSA's of		*/
      202 	/* the MSA.  As some later time (eg, in another process), these SSA's 		*/
      203 	/* can be re-initiated (with the same segment numbers, of course) to allow use of the	*/
      204 	/* data stored in the MSA, or to allow further data storage.  All of the data stored in	*/
      205 	/* the MSA at the time of termination is preserved.				*/
      206 	/*									*/
      207 	/* U__s_a_g_e									*/
      208 	/*									*/
      209 	/*      dcl  msa_manager_$terminate entry (ptr, fixed bin(35));			*/
      210 	/*									*/
      211 	/*      call msa_manager_$terminate (Pareap, code);				*/
      212 	/*									*/
      213 	/* 1) Pareap	points to the MSA pointer of the MSA to be terminated. (In)		*/
      214 	/* 2) code	may be any code returned from hcs_$terminate_seg. (Out)		*/
      215 	/*									*/
      216 	/* E__n_t_r_y:  msa_manager_$initiate						*/
      217 	/*									*/
      218 	/*      This entry point re-initiates an MSA which has been terminated.  Each SSA segment	*/
      219 	/* in the MSA is re-initiated with the same segment number it had at its creation in	*/
      220 	/* order to preserve the value of any pointers stored in the MSA.			*/
      221 
      222 	/* U__s_a_g_e									*/
      223 	/*									*/
      224 	/*      dcl  msa_manager_$initiate entry (char(*), char(*), ptr, fixed bin(35),		*/
      225 	/*	   ptr, fixed bin(35));						*/
      226 	/*									*/
      227 	/*      call msa_manager_$initiate (directory, entry, Pareap, Luser, Puser, code);	*/
      228 	/*									*/
      229 	/* 1) directory	is the path name of the directory which contains the MSA to be	*/
      230 	/*		initiated. (In)						*/
      231 	/* 2) entry	is the entry name of the MSA to be initiated.  If this name is a null	*/
      232 	/*		character string, then the final entry name of the directory path	*/
      233 	/*		is used as the entry name of the MSA. (In)			*/
      234 	/* 3) Pareap	points to the MSA pointer for the MSA which was initiated.		*/
      235 	/*		If Pareap is a null pointer on input, then it will point to an MSA	*/
      236 	/*		pointer created in the header of the first SSA of the MSA. (Out)	*/
      237 	/*		Otherwise, Pareap points to an MSA pointer defined by the caller. (In)*/
      238 	/* 4) Luser	is the length (in words) of the user-defined region is the header of	*/
      239 	/*		the first SSA of the MSA, if one exists;  or 0, if no user-defined	*/
      240 	/*		region exists. (Out)					*/
      241 	/* 5) Puser	points to the user-defined region in the header of the first	*/
      242 	/*		SSA of the MSA, if one exists;  or is a null pointer, if no 	*/
      243 	/*		user-defined region exists.					*/
      244 	/* 6) code	is one of the following status codes. (Out)			*/
      245 	/*									*/
      246 	/*    error_table_$invalidsegno						*/
      247 	/*		One of the SSA's of the MSA could not be re-initiated because	*/
      248 	/*		another segment in the user's process was already initiated with the	*/
      249 	/*		segment number which that MSA was initiated with originally. 	*/
      250 	/*		Pareap points to the base of the segment which must be terminated.	*/
      251 	/*		The initiation may be re-attempted without prior termination, once	*/
      252 	/*		this segment has been terminated.				*/
      253 	/*									*/
      254 	/*    error_table_$moderr							*/
      255 	/*		The user does not have write access to one of the SSA's of the MSA.	*/
      256 	/*		Pareap points to the base of the SSA segment to which write access	*/
      257 	/*		must be given.  The initiation may be reattempted without prior	*/
      258 	/*		termination, once write access has been set.			*/
      259 	/*									*/
      260 	/*    error_table_$noentry							*/
      261 	/*		The MSA to be re-initiated was not found, or the first SSA of this	*/
      262 	/*		MSA was not found.						*/
      263 	/*									*/
      264 	/*    error_table_$dirseg							*/
      265 	/*		_d_i_r_e_c_t_o_r_y>_e_n_t_r_y is a directory, not an MSA.  It cannot be initiated.	*/
      266 	/*									*/
      267 	/*									*/
      268 	/*    error_table_$seg_not_found						*/
      269 	/*		An SSA, other than the first SSA of the MSA, was discovered to be	*/
      270 	/* 		missing.  A new SSA is created to replace the old SSA, but some	*/
      271 	/*		data may be missing.  The MSA has been fully re-initiated.		*/
      272 	/*									*/
      273 	/*		Any error code from hcs_$fs_get_mode, from hcs_$set_bc_seg,		*/
      274 	/*		from hcs_$append_branchx, or from hcs_$initiate.			*/
      275 	/*									*/
      276 	/*    error_table_$improper_data_format						*/
      277 	/*		An attempt was made to re-initiate an MSA whichdidn't contain	*/
      278 	/*		the identifier string in its header.  The assumption is that the	*/
      279 	/*		segment is _n_o_t an MSA.					*/
      280 	/*									*/
      281 
      282 	/* E__n_t_r_y:  msa_manager_$make_special						*/
      283 	/*									*/
      284 	/*      This entry point is like msa_manager_$make, except that the caller may specify	*/
      285 	/* a lower bound on the segment numbers used to initiate the SSA's of the MSA.  If this	*/
      286 	/* lower bound is high enough (eg, 400 or 440), then no problem should occur in 	*/
      287 	/* re-initiating a terminated MSA.						*/
      288 	/*									*/
      289 	/* U__s_a_g_e									*/
      290 	/*									*/
      291 	/*      dcl  msa_manager_$make_special entry (fixed bin, char(*), char(*), ptr,		*/
      292 	/*	   fixed bin(35), ptr, fixed bin(35));					*/
      293 	/*									*/
      294 	/*      call msa_manager_$make_special (min_seg_no, directory, entry, Pareap, Luser,	*/
      295 	/* Puser, code);								*/
      296 	/*									*/
      297 	/* 1) min_seg_no	is the minimum segment number SSA's may be initiated with. (In)	*/
      298 	/* 2) - 7)	are the same as for msa_manager_$make.				*/
      299 	/*									*/
      300 	/* E__n_t_r_y:  get_system_msa_$get_system_msa_					*/
      301 	/*									*/
      302 	/*      This entry point returns with the caller's MSA pointer pointing to a		*/
      303 	/* system MSA maintained in the user's process directory.  This MSA will exist for the	*/
      304 	/* life of the user's process, and is reserved for the exclusive use of the calling	*/
      305 	/* program and its subprograms.						*/
      306 	/*									*/
      307 	/*      Entries in the process directory named system_multi_segment_area__r._n, where	*/
      308 	/* _r is the current ring number and _n is an integer.  Any system MSA's which exist when	*/
      309 	/* this entry point is called are examined to see if they are in use.  The MSA pointer	*/
      310 	/* will point to the first unused MSA on return, or to a new system MSA if no		*/
      311 	/* unused system MSA's are found.						*/
      312 	/*									*/
      313 	/*      After the control program is through with the MSA, it should call		*/
      314 	/* release_system_msa_ to truncate the MSA and make it available to other programs.	*/
      315 	/*									*/
      316 	/* U__s_a_g_e									*/
      317 	/*									*/
      318 	/*      dcl  get_system_msa_ entry (ptr, fixed bin(35), ptr);			*/
      319 	/*									*/
      320 	/*      call get_system_msa_ (Pareap, Luser, Puser);				*/
      321 	/*									*/
      322 	/* 1) - 3)	are the same as for msa_manager_$make.				*/
      323 	/*									*/
      324 	/* E__n_t_r_y:  release_system_msa_$release_system_msa_				*/
      325 	/*									*/
      326 	/*      This entry point truncates a system MSA, and releases it for use by other	*/
      327 	/* programs.								*/
      328 	/*									*/
      329 	/* U__s_a_g_e									*/
      330 	/*									*/
      331 	/*      dcl  release_system_msa_ entry (ptr, fixed bin(35));			*/
      332 	/*									*/
      333 	/*      call release_system_msa_ (Pareap, code);					*/
      334 	/*									*/
      335 	/* 1) - 2)	same as for msa_manager_$truncate.				*/
      336 
      337 	/* N__o_t_e_s									*/
      338 	/*									*/
      339 	/*      The information structure which must be passed to msa_manager_$area_handler	*/
      340 	/* is as follows:								*/
      341 	/*									*/
      342 	/*  dcl 1 area_info		aligned,						*/
      343 	/*	2 length		fixed bin,					*/
      344 	/*	2 version		fixed bin,					*/
      345 	/*	2 action_flags	aligned,						*/
      346 	/*	  3 cant_restart	bit(1) unal,					*/
      347 	/*	  3 default_restart bit(1) unal,					*/
      348 	/*	2 info_string	char(256) varying aligned,				*/
      349 	/*	2 status_code	fixed bin(35),					*/
      350 	/*	2 Parea		ptr,						*/
      351 	/*	2 space		fixed bin(35),					*/
      352 	/*	2 signal_id	bit(70) aligned;					*/
      353 	/*									*/
      354 	/* 1) length	(Ignored)							*/
      355 	/* 2) version	must be 1.						*/
      356 	/* 3) cant_restart	must be "0"b.						*/
      357 	/* 4) default_restart							*/
      358 	/*		(Ignored)							*/
      359 	/* 5) info_string	(Ignored)							*/
      360 	/* 6) status_code	(Ignored)							*/
      361 	/* 7) Parea	points to the area in which the allocation failed. (In)		*/
      362 	/*		points to the area in which the allocation is to be reattempted. (Out)*/
      363 	/* 8) space	is the amount of space being allocated in the MSA. (Ignored)	*/
      364 	/* 9) signal_id	is an identifier supplied by unique_bits_ which changes for each	*/
      365 	/*		different allocation, but which remains constant during all 	*/
      366 	/*		attempts to recover from a failure in performing the same allocation.	*/
      367 	/*		(In)							*/
      368 	/*									*/
      369 	/*      The following information structure is passed by msa_manager_$area_handler when	*/
      370 	/* it signals the "area_handler_error_" condition.  This condition is signalled if	*/
      371 	/* an error occurs while appending an empty SSA to the MSA, or if an allocation fails in	*/
      372 	/* an empty SSA.  Under both of these conditions, the allocation can never succeed.	*/
      373 	/*									*/
      374 	/*  dcl 1 area_error_info	aligned,						*/
      375 	/*	2 length		fixed bin,					*/
      376 	/*	2 version		fixed bin init(0),					*/
      377 	/*	2 action_flags	aligned,						*/
      378 	/*	  3 cant_restart	bit(1) unal init ("1"b),				*/
      379 	/*	  3 default_restart bit(1) unal init ("0"b),				*/
      380 	/*	2 info_string	char(256) varying aligned,				*/
      381 	/*	2 status_code	fixed bin(35);					*/
      382 	/*									*/
      383 	/* 1) length	is the length of the area_error_info structure.			*/
      384 	/* 2) version	is the version number of this structure (= 1).			*/
      385 	/* 3) cant_restart	is on, specifying that the handler for the "area_handler_error_"	*/
      386 	/*		cannot return to msa_manager_$area_handler.			*/
      387 	/* 4) default_restart							*/
      388 	/*		is off, specifying that the handler for the "area_handler_error_"	*/
      389 	/*		must take positive action.					*/
      390 	/* 5) info_string	is an error message which indicates the cause of the signal.	*/
      391 	/* 6) status_code	is a status code which indicates the cause of the signal.		*/
      392 	/*								          */
      393 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      394 
      395 
      396 /****^  HISTORY COMMENTS:
      397*  1) change(73-02-01,GDixon), approve(), audit(), install():
      398*     Initially created.
      399*  2) change(73-04-01,GDixon), approve(), audit(), install():
      400*     add the make_special entry point.
      401*  3) change(73-07-01,GDixon), approve(), audit(), install():
      402*      a) expect standard header in condition info structure.
      403*      b) make msa_manager_ work in multiple rings.
      404*      c) allow creation of MSA pointer in header of first SSA.
      405*  4) change(74-06-01,PKelley), approve(), audit(), install():
      406*      a) Changed to not store SSA segment numbers as bit count of the SSA.
      407*         Segment numbers are now derived from a pointer stored within each SSA.
      408*         Bit counts of SSAs are now set to 64 K bits.
      409*      b) Fixed bug which when re-initiating an MSA resulted in erroneous report
      410*         of SSA component missing and subsequent creation of an extra SSA.
      411*  5) change(74-07-01,PKelley), approve(), audit(), install():
      412*     Improved consistency of msa_manager_ by refusing to re-initialize an
      413*     existing SSA if the MSA identifying string was not found in its header.
      414*  6) change(79-08-01,GDixon), approve(), audit(), install():
      415*     Changed to allow 256K SSA when attempting to allocate space larger than
      416*     63K.  64K SSAs continue to be used as a normal rule.  Bit count of each
      417*     ssa is set to its size (64K or 256K), and size now stored in SSA header
      418*     for each SSA.
      419*  7) change(80-05-01,Texada), approve(), audit(), install():
      420*     Changed to set the bit count of SSA's when allocated to preclude premature
      421*     reuse.  Changed to use active_all_rings_data$max_segno as limit for
      422*     segment numbers.
      423*  8) change(85-11-24,GDixon), approve(85-12-11,MCR7315),
      424*     audit(85-12-12,Martinson), install(85-12-16,MR12.0-1001):
      425*     Changed the release_system_msa_ and msa_manager_$truncate entrypoints to
      426*     properly truncate and set bit counts on MSA's which are being truncated to
      427*     SSAs.  Prior to the change, component 0 of the MSA was converted to an SSA
      428*     without being truncated or having its bit count set to 0.  This prevented
      429*     system MSAs from being reused; successive calls to get_system_msa_ always
      430*     created a new MSA, and cluttered up the process directory with unusable
      431*     MSA segments.
      432*                                                   END HISTORY COMMENTS */
      433 
      434 
      435 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      436 
      437 
      438 msa_manager_:	procedure;
      439 
      440 
      441      dcl						/*	parameters			*/
      442 	Pmc			ptr,		/* ptr to machine conditions for area handler.	*/
      443 	cond			char(*),		/* name of signalled condition for area handler.	*/
      444 	Pwc_mc			ptr,		/* ptr to wall crossing machine conditions.	*/
      445 	Pinfo			ptr,		/* ptr to "area" condition information str.(In)	*/
      446 	Scont			bit(1) aligned,	/* non-zero if system to continue looking for a	*/
      447 						/* handler for the "area" condition.		*/
      448 	ANstart			fixed bin,	/* minimum segment number SSA's may be initiated	*/
      449 						/* with. (In)				*/
      450 	Adirectory		char(*),		/* directory part of MSA pathname. (In)		*/
      451 	Aentry			char(*),		/* entry part of MSA pathname. (In)		*/
      452 	Pareap			ptr,		/* ptr to user's area ptr. (In)		*/
      453 	Luser			fixed bin(35),	/* length of user's region in first SSA header.	*/
      454 						/* (In/Out)				*/
      455 	Puser			ptr,		/* ptr to user's region in first SSA header. (Out)*/
      456 	Acode			fixed bin(35);	/* a status code. (Out)			*/
      457 
      458      dcl						/*	automatic variables			*/
      459 	Pold_ssa			ptr,		/* ptr to previous SSA in MSA chain.		*/
      460 	Ldirectory		fixed bin,	/* length of non-blank part of _d_i_r_e_c_t_o_r_y	*/
      461 	Nstart			fixed bin,	/* min seg no SSA's may be initiated with.	*/
      462 	Pssa			ptr,		/* ptr to current SSA.			*/
      463 	1 area_error_info		aligned,		/* "area_handler_error_" information structure.	*/
      464 	  2 length		fixed bin,	/* length of this structure (in words).		*/
      465 	  2 version		fixed bin,	/* version of this structure (1)		*/
      466 	  2 action_flags		aligned,
      467 	    3 cant_restart		bit(1) unal,	/* condition is not restartable.		*/
      468 	    3 default_restart	bit(1) unal,	/* therefore, there is no default restart.	*/
      469 	    3 pad			bit(34) unal,
      470 	  2 info_string		char(256) varying aligned,
      471 						/* a meaningful info string.			*/
      472 	  2 status_code		fixed bin(35),	/* a meaningful status code.			*/
      473 	bit_count			fixed bin(24),	/* bit count attribute of SSA.		*/
      474 	code			fixed bin(35),	/* a status code.				*/
      475 	directory			char(168) aligned,	/* a directory pathname.			*/
      476 	e			fixed bin,	/* entry point indicator.			*/
      477 	entry			char(32) aligned,	/* name of an entry in a directory.		*/
      478 	error			label local,	/* return point from int subroutines when an	*/
      479 						/* error occurs.				*/
      480 	i			fixed bin (35),	/* a do group index.			*/
      481 	mode			fixed bin(5),	/* user's access to SSA segment.		*/
      482 	msa_count			fixed bin(35),	/* one less than the number of SSA's in MSA chain.*/
      483 	rings (3)			fixed bin(6),	/* ring brackets				*/
      484 	type			fixed bin(2),	/* type of MSA which was found by status:	*/
      485 						/*   0 => MSA does not exist.			*/
      486 						/*   1 => MSA is a single SSA.		*/
      487 						/*   2 => MSA is a directory. (ERROR CONDITION)	*/
      488 						/*   3 => MSA is an msf containing segments,	*/
      489 						/*        each of which is an SSA.		*/
      490 	validation_level		fixed bin(6);	/* a saved validation level.			*/
      491 	
      492      dcl						/*	based variables			*/
      493 	areap			ptr based (Pareap),
      494 						/* the control program's MSA pointer.		*/
      495 	1 area_info		based (Pinfo),	/* "area" condition information structure.	*/
      496 	  2 length		fixed bin,	/* length of this structure (in words).		*/
      497 	  2 version		fixed bin,	/* version of this structure (must be 1).	*/
      498 	  2 action_flags		aligned,
      499 	    3 cant_restart		bit(1) unal,	/* "area" handler cannot return (should never be).*/
      500 	    3 default_restart	bit(1) unal,	/* "area" handler can return without doing	*/
      501 						/* anything (should never be).		*/
      502 	  2 info_string		char(256) varying aligned,
      503 						/* a meaningful info string.			*/
      504 	  2 status_code		fixed bin(35),	/* a meaningful status code.			*/
      505 	  2 Parea			ptr,		/* ptr to full area (In); ptr to new area (Out)	*/
      506 	  2 space			fixed bin(35),	/* amount of space which must be allocated. (In)	*/
      507 	  2 signal_id		bit(70) aligned,	/* id associated with this signalled area cond.	*/
      508 						/* this allocation. (In)			*/
      509 	1 ssa			based (Pssa),	/* header for an SSA (single segment area).	*/
      510 	  2 id,					/* id's used for searching for space in msa	*/
      511 	    3 string		char(8) aligned,	/* id, initialized to "msa_" for identifying MSA's*/
      512 	    3 new_ssa		bit(70) aligned,	/* signal id which caused SSA to be created.	*/
      513 	    3 last_signal		bit(70) aligned,	/* id of last signal to look for space in ssa	*/
      514 	  2 Parea			ptr,		/* ptr to the area in this SSA.		*/
      515 	  2 Pfirst		ptr,		/* ptr to first SSA of this MSA chain.		*/
      516 	  2 Pnext			ptr,		/* ptr to next SSA of this MSA chain.		*/
      517 	  2 Pareap		ptr,		/* ptr to user's area ptr.			*/
      518 	  2 Puser			ptr,		/* ptr to user region in this header.		*/
      519 	  2 Pcur_area		ptr,		/* (possibly) the MSA pointer.		*/
      520 	  2 Luser			fixed bin(35),	/* length of user region in this header.	*/
      521 	  2 Nseg			fixed bin(35),	/* MSA # of this SSA in MSA chain (0 to n).	*/
      522 	  2 Nstart		fixed bin,	/* 0 or minimum seg no which new SSA's may have.	*/
      523 	  2 area_size		fixed bin(19);	/* size of this SSA (64K or sys_info$max_seg_size)*/
      524 		
      525      dcl						/*	builtin functions			*/
      526          (addr, baseptr, divide, fixed, length, mod, null, ptr, rel, size, substr)
      527 				builtin;
      528 
      529      dcl						/*	function and subroutine entries	*/
      530 	area_			entry (fixed bin(35), ptr),
      531 	backup_name_		entry (char(*) aligned) returns (char(32)),
      532 	convert_binary_integer_$decimal_string
      533 				entry (fixed bin(35)) returns (char(12) varying),
      534 	cu_$level_get		entry returns (fixed bin(6)),
      535 	cu_$level_set		entry (fixed bin(6)),
      536 	delete_$path		entry (char(*) aligned, char(*) aligned, bit(6) aligned, char(*) aligned,
      537 				       fixed bin(35)),
      538 	expand_path_		entry (ptr, fixed bin, ptr, ptr, fixed bin(35)),
      539 	get_pdir_			entry returns (char(168) aligned),
      540 	get_group_id_$tag_star	entry returns (char(32) aligned),
      541 	get_ring_			entry returns (fixed bin(35)),
      542 	hcs_$append_branchx		entry (char(*) aligned, char(*) aligned, fixed bin(5), (3) fixed bin(6),
      543 				       char(*) aligned, fixed bin(1), fixed bin(1), fixed bin(24),
      544 				       fixed bin(35)),
      545 	hcs_$delentry_seg		entry (ptr, fixed bin(35)),
      546 	hcs_$fs_get_mode		entry (ptr, fixed bin(5), fixed bin(35)),
      547 	hcs_$fs_get_path_name	entry (ptr, char(*) aligned, fixed bin, char(*) aligned, fixed bin(35)),
      548 	hcs_$get_link_target	entry (char(*), char(*), char(*) aligned, char(*) aligned, fixed bin(35)),
      549 	hcs_$get_ring_brackets	entry (char(*) aligned, char(*) aligned, (3) fixed bin(6), fixed bin(35)),
      550 	hcs_$initiate		entry (char(*) aligned, char(*) aligned, char(*) aligned, fixed bin(1),
      551 				       fixed bin(2), ptr, fixed bin(35)),
      552 	hcs_$set_bc		entry (char(*) aligned, char(*) aligned, fixed bin(24), fixed bin(35)),
      553 	hcs_$set_bc_seg		entry (ptr, fixed bin(24), fixed bin(35)),
      554 	hcs_$status_minf		entry (char(*) aligned, char(*) aligned, fixed bin(1), fixed bin(2),
      555 				       fixed bin(24), fixed bin(35)),
      556 	hcs_$terminate_seg		entry (ptr, fixed bin(1), fixed bin(35)),
      557 	hcs_$truncate_seg		entry (ptr, fixed bin, fixed bin(35)),
      558 	make_msf_			entry (char(*) aligned, char(*) aligned, (3) fixed bin(6),
      559 				       fixed bin(35)),
      560 	nd_handler_		entry (char(*) aligned, char(*) aligned, char(*) aligned, fixed bin(35)),
      561 	signal_			entry (char(*), ptr, ptr),
      562 	unmake_msf_		entry (char(*) aligned, char(*) aligned, bit(1) aligned, (3) fixed bin(6),
      563 				       fixed bin(35));
      564 
      565      dcl						/*	static variables			*/
      566          (active_all_rings_data_$max_segno,
      567           error_table_$dirseg,
      568 	error_table_$improper_data_format,
      569 	error_table_$invalidsegno,
      570 	error_table_$moderr,
      571 	error_table_$namedup,
      572 	error_table_$noalloc,
      573 	error_table_$noentry,
      574 	error_table_$seg_not_found,
      575 	error_table_$segknown)	fixed bin(35) ext static,
      576 	small_ssa_size		fixed bin(35) int static options(constant) init (65536),
      577 	sys_info$max_seg_size	fixed bin(35) ext static;
      578 
      579 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      580 
      581 /**/
      582 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      583 
      584 area_handler:	entry (Pmc, cond, Pwc_mc, Pinfo, Scont);
      585 
      586 	if Pinfo = null then do;			/* if we weren't signalled by a smart allocater	*/
      587 pass_on:	     Scont = "1"b;				/* then there's not much we can do. Pass condition*/
      588 	     return;				/* on to next handler.			*/
      589 	     end;
      590 	if area_info.version ^= 1 then		/* we can only handle a version 1 structure.	*/
      591 	     go to pass_on;
      592 	if area_info.cant_restart then		/* if we cannot restart the allocation, then this	*/
      593 	     go to pass_on;				/* signal is not for us.			*/
      594 	Pssa = ptr (area_info.Parea, 0);		/* get ptr to SSA containing area in which the	*/
      595 						/* allocation failed.			*/
      596 	if ssa.id.string ^= "msa_" then		/* if this isn't an MSA, pass condition on.	*/
      597 	     go to pass_on;
      598 
      599 	ssa.id.last_signal = area_info.signal_id;	/* indicate that there's no space in this SSA for	*/
      600 						/* the allocation causing this signal.		*/
      601 	if ssa.id.new_ssa = area_info.signal_id then do;	/* if the allocation couldn't be performed in	*/
      602 						/* an empty SSA, then it will never fit.	*/
      603 	     area_error_info.status_code = error_table_$noalloc;
      604 	     area_error_info.info_string = "msa_manager_$area_handler:  the allocation is too large to fit in the MSA.";
      605 	     go to signal;
      606 	     end;
      607 
      608 	do Pssa = Pssa repeat (ssa.Pnext) while (ssa.Pnext ^= null);
      609 	     if ssa.id.last_signal ^= area_info.signal_id then
      610 		if area_info.space <= ssa.area_size - 1024 then
      611 		     go to return_area;		/* look through SSA's which follow this full SSA	*/
      612 						/*   in MSA chain to find one in which the alloc.	*/
      613 	     					/*   has not yet been tried.  Return this area.	*/
      614 		else 				/* However, if SSA is a small (64K) SSA and space */
      615 						/*   required is more than 63K, skip this area.	*/
      616 		     ssa.id.last_signal = area_info.signal_id;
      617 	     end;
      618 
      619 	if ssa.id.last_signal = area_info.signal_id then	/* if alloc already tried in last SSA of chain,	*/
      620 						/* & if alloc also tried in first SSA of chain,	*/
      621 						/* then append a new SSA, and return its area.	*/
      622 	     if ssa.Pfirst -> ssa.id.last_signal = area_info.signal_id then do;
      623 		error = signal_error;
      624 		if area_info.space <= small_ssa_size - 1024 then
      625 		     call append (small_ssa_size);
      626 		else call append (sys_info$max_seg_size);
      627 		end;
      628 	     else					/* otherwise, go back to first SSA in MSA chain	*/
      629 		Pssa = ssa.Pfirst;			/* and try the allocation in SSA's which precede	*/
      630 						/* first SSA in which alloc was tried.		*/
      631 return_area:
      632 	area_info.Parea,
      633 	ssa.Pareap -> areap = ssa.Parea;		/* return ptr to SSA's area we found, and set	*/
      634 	return;					/* user's area ptr to point to this SSA area, too	*/
      635 signal_error:					/* a fatal error occurred appending an empty SSA	*/
      636 	area_error_info.pad = "0"b;			/* to the MSA.				*/
      637 	area_error_info.status_code = code;
      638 	area_error_info.info_string = "msa_manager_$area_handler:  error appending an SSA to the MSA  " ||
      639 	     directory || ".";
      640 signal:	area_error_info.default_restart = "0"b;
      641 	area_error_info.cant_restart = "1"b;
      642 	area_error_info.version = 1;
      643 	area_error_info.length = size (area_error_info);
      644 	call signal_ ("area_handler_error_", null, addr (area_error_info));
      645 	go to pass_on;
      646 
      647 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      648 
      649 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      650 
      651 
      652 make_special:	entry (ANstart, Adirectory, Aentry, Pareap, Luser, Puser, Acode);
      653 						/* create an MSA in which all SSA's are initiated	*/
      654 	Nstart = ANstart;				/* with segment numbers greater than ANstart	*/
      655 	go to common;				/* to simplify their re-initiation.		*/
      656 
      657 
      658 make:		entry (Adirectory, Aentry, Pareap, Luser, Puser, Acode);
      659 						/* create an MSA.				*/
      660 
      661 	Nstart = 0;				/* initiate SSA's in MSA with any segment no.	*/
      662 common:	Acode = 0;				/* clear error code.			*/
      663 	error = return_code;			/* return any error code encountered.		*/
      664 	if Aentry = "" then do;			/* copy arguments for use by internal subroutines	*/
      665 	     call expand_path_ (addr(Adirectory), length (Adirectory), addr(directory), addr(entry), code);
      666 	     if code ^= 0 then
      667 		go to error;
      668 	     end;
      669 	else do;
      670 	     directory = Adirectory;
      671 	     entry = Aentry;
      672 	     end;
      673 	call status;				/* find out about _d_i_r_e_c_t_o_r_y>_e_n_t_r_y.		*/
      674 	go to make(type);				/* process according to type of dir entry.	*/
      675 
      676 make(1):
      677 make(3):	call nd_handler_ ("msa_manager_", directory, entry, code);
      678 	if code ^= 0 then do;
      679 	     Acode = error_table_$namedup;
      680 	     return;
      681 	     end;
      682 
      683 make(0):	rings(1), rings(2), rings(3) = cu_$level_get();	/* set ring brackets of v,v,v on SSA.		*/
      684 	call make_seg (Nstart, rings);		/* create first SSA of MSA chain.		*/
      685 	call initialize (Pssa, Pareap, Puser, Luser, 0, Nstart, "1"b, small_ssa_size);
      686 	return;					/* initialize this SSA, and return to caller.	*/
      687 
      688 make(2):	Acode = error_table_$dirseg;			/* a directory with name of MSA already exists.	*/
      689 	return;					/* complain to caller.			*/
      690 
      691 return_code:					/* return to user with an error code.		*/
      692 	Acode = code;
      693 	return;
      694 
      695 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      696 
      697 
      698 /**/
      699 
      700 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      701 
      702 
      703 initiate:		entry (Adirectory, Aentry, Pareap, Luser, Puser, Acode);
      704 						/* initiate an existing MSA.			*/
      705 
      706 	Acode = 0;
      707 	error = return_code;			/* return any error codes which are encountered.	*/
      708 	msa_count = 0;				/* initialize count (minus 1) of SSA's in MSA.	*/
      709 	call hcs_$get_link_target (Adirectory, Aentry, directory, entry, code);
      710 	if code ^= 0 then				/* copy arguments for use by internal subroutines	*/
      711 	     go to error;				/* chasing links while we're at it.		*/
      712 	call status;				/* find out about _d_i_r_e_c_t_o_r_y>_e_n_t_r_y.		*/
      713 	go to init(type);
      714 
      715 init(1):						/* MSA consists of a single SSA.		*/
      716 	call re_initiate;				/* Re-initiate and initialize it.		*/
      717 	call initialize (Pssa, Pareap, Puser, Luser, 0, 0, "0"b, small_ssa_size);
      718 	return;
      719 
      720 init(3):	do Ldirectory = 168  to 1 by -1 while (substr (directory, Ldirectory, 1) = " ");
      721 	     end;					/* construct path of MSA's directory.		*/
      722 	substr (directory, Ldirectory+1) = ">" || entry;
      723 	entry = "0";
      724 	call status;				/* find out about first SSA of MSA.		*/
      725 	go to init_1st_ssa(type);
      726 
      727 init_1st_ssa(1):					/* first SSA of MSA exists.			*/
      728 	call re_initiate;				/* re-initiate it with proper segment number.	*/
      729 	call initialize (Pssa, Pareap, Puser, Luser, 0, 0, "0"b, small_ssa_size);
      730 						/* initialize the SSA.			*/
      731 	Nstart = ssa.Nstart;			/* get value of min seg no SSA's can have.	*/
      732 	call hcs_$get_ring_brackets (directory, entry, rings, code);
      733 	if code ^= 0 then				/* get ring brackets of SSA's in case we have	*/
      734 	     go to error;				/* to remake any missing ones.		*/
      735 
      736 	do i = 1 to msa_count;			/* if initiating an MSA, initiate SSA's which	*/
      737 						/* follow the first SSA in the MSA chain.	*/
      738 	     entry = convert_binary_integer_$decimal_string (i);
      739 	     call status;				/* get name of, and find out about next SSA.	*/
      740 	     Pold_ssa = Pssa;			/* save ptr to current SSA, for fwd chaining.	*/
      741 	     go to init_ssa(type);
      742 
      743 init_ssa(0):   call make_seg (Nstart, rings);		/* next SSA doesn't exist. Make it.		*/
      744 	     Acode = error_table_$seg_not_found;	/* report the error to the user, but continue.	*/
      745 	     go to initialize_;
      746 
      747 init_ssa(1):   call re_initiate;			/* next SSA does exist. Re-initiate it.		*/
      748 initialize_:   call initialize (Pold_ssa->ssa.Pfirst, Pareap, null, 0, i, Nstart, "0"b, small_ssa_size);
      749 						/* initialize the SSA.			*/
      750 	     Pold_ssa->ssa.Pnext = Pssa;		/* chain SSA to previous SSA.			*/
      751 	     end;
      752 	return;
      753 
      754 init(0):						/* MSA doesn't exist.			*/
      755 init_1st_ssa(0):					/* first SSA of MSA doesn't exist.		*/
      756 	Acode = error_table_$noentry;			/* Cannot re-initiate MSA.			*/
      757 	return;
      758 
      759 init(2):
      760 init_ssa(2):
      761 init_ssa(3):
      762 init_1st_ssa(2):
      763 init_1st_ssa(3):
      764 	Acode = error_table_$dirseg;			/* complain to user about unexpected dir's/msa's	*/
      765 	return;
      766 
      767 
      768 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      769 
      770 
      771 /**/
      772 
      773 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      774 
      775 
      776 get_system_msa_:	entry (Pareap, Luser, Puser);		/* get a system multi-segment area of your own.	*/
      777 
      778 	rings(1), rings(2), rings(3) = get_ring_();	/* look for system MSA in the current ring.	*/
      779 	directory = get_pdir_();
      780 	entry = "system_multi_segment_area_" ||
      781 	     convert_binary_integer_$decimal_string (fixed (rings(1), 35));
      782 						/* make them per-ring data bases, like		*/
      783 						/* system_free_4.00, ...			*/
      784 	error = get_another;			/* keep trying if an error occurs.		*/
      785 
      786 	do while ("1"b);				/* when I say "keep trying", I mean it.		*/
      787 	     entry = backup_name_ (entry);		/* tack ".1" onto entry, or change ".1" to ".2",..*/
      788 	     call status;				/* see if it already exists.			*/
      789 	     go to gsa(type);
      790 
      791 gsa(0):	     call make_seg (0, rings);		/* it doesn't. make and initialize it.		*/
      792 	     go to gsa_0;
      793 
      794 gsa(1):	     if bit_count > 0 then			/* if found a SSA, but it's in use, then	*/
      795 		go to get_another;			/* get another one.				*/
      796 	     call re_initiate;			/* otherwise, initiate this one.		*/
      797 	     ssa.id.string = "";			/* force complete reinitialization in next step.	*/
      798 gsa_0:	     call initialize (Pssa, Pareap, Puser, Luser, 0, 0, "1"b, small_ssa_size);
      799 						/* initialize the SSA.			*/
      800 	     return;
      801 gsa(2):
      802 gsa(3):
      803 get_another:   end;
      804 
      805 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      806 
      807 
      808 /**/
      809 
      810 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      811 
      812 
      813 release_system_msa_:entry (Pareap, Acode);		/* give MSA back to the system.		*/
      814 
      815 	e = 4;					/* don't tell anyone, but this is 		*/
      816 	go to common2;				/* msa_manager_$truncate, for now.		*/
      817 
      818 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      819 
      820 
      821 delete:		entry (Pareap, Acode);		/* delete MSA for ever and ever.		*/
      822 
      823 	e = 3;
      824 	go to common2;
      825 
      826 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      827 
      828 
      829 truncate:		entry (Pareap, Acode);		/* truncate MSA into a 0-length SSA.		*/
      830 
      831 	e = 4;
      832 	go to common2;
      833 
      834 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      835 
      836 
      837 terminate:	entry (Pareap, Acode);		/* terminate MSA, but leave it intact for use in	*/
      838 						/* another process.				*/
      839 	e = 5;
      840 
      841 
      842 common2:	Pssa = ptr(areap,0)->ssa.Pfirst;		/* start with first SSA of MSA chain.		*/
      843 	areap = null;				/* clear user's area ptr to avoid errors.	*/
      844 	go to do(e);				/* do remaining work by entry point.		*/
      845 
      846 do(3):						/* for delete, truncate, and release_system_area	*/
      847 do(4):	if ssa.Pnext = null then do;			/* if MSA has only 1 SSA, then special case it	*/
      848 	     go to end_ssa(e);
      849 
      850 end_ssa(3):					/* delete SSA.				*/
      851 	     call hcs_$delentry_seg (Pssa, Acode);
      852 	     return;
      853 
      854 end_ssa(4):					/* truncate SSA.				*/
      855 	     call hcs_$set_bc_seg (Pssa, 0, Acode);	/* zero bit count to mark it as free.		*/
      856 	     if Acode ^= 0 then
      857 	          return;
      858 	     call hcs_$truncate_seg (Pssa, 0, Acode);
      859 	     call hcs_$terminate_seg (Pssa, 0b, Acode);	/* now terminate the SSA.			*/
      860 	     return;
      861 	     end;
      862 
      863 	else do;					/* process multi-SSA MSA's here.		*/
      864 	     call hcs_$fs_get_path_name (Pssa, directory, Ldirectory, entry, Acode);
      865 	     if Acode ^= 0 then			/* get path name of first SSA in MSA chain.	*/
      866 	          return;
      867 	     call hcs_$get_ring_brackets (directory, entry, rings, Acode);
      868 	     if Acode ^= 0 then			/* get ring brackets of 1st SSA in MSA.		*/
      869 		return;
      870 	     do i = Ldirectory to 1 by -1 while (substr (directory, i, 1) ^= ">");
      871 		end;				/* get path name of MSA directory.		*/
      872 	     entry = substr (directory, fixed (i, 17) + 1);
      873 	     substr (directory, fixed (i, 17)) = "";
      874 	     go to end_msa(e);
      875 
      876 end_msa(3):					/* delete MSA.				*/
      877 	     call delete_$path (directory, entry, "100111"b, entry, Acode);
      878 	     return;
      879 
      880 end_msa(4):					/* make MSA into zero-length SSA.		*/
      881 	     validation_level = cu_$level_get();	/* save the current validation level.		*/
      882 	     call cu_$level_set (rings(1));		/* switch to the validation level in which the	*/
      883 	     					/* MSA was created, so unmake_msf_ will work.	*/
      884 	     call unmake_msf_ (directory, entry, "0"b, rings, Acode);
      885 	     call cu_$level_set (validation_level);	/* reset validation level, before error check	*/
      886 	     if Acode ^= 0 then
      887 	          return;
      888 	     go to end_ssa(4);			/* Now terminate the SSA's of the MSA.		*/
      889 	     end;
      890 
      891 do(5):						/* terminate MSA's SSA segments.		*/
      892 	do Pssa = Pssa repeat (Pold_ssa) while (Pssa ^= null);
      893 	     Pold_ssa = ssa.Pnext;
      894 	     call hcs_$terminate_seg (Pssa, 0b, Acode);
      895 	     if Acode ^= 0 then
      896 		return;
      897 	     end;
      898 	return;
      899 
      900 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      901 
      902 
      903 /**/
      904 
      905 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      906 
      907 
      908 append:	procedure (ssa_size);			/* append an SSA onto MSA chain.		*/
      909 
      910      dcl	ssa_size			fixed bin(35);
      911 	
      912 	call hcs_$fs_get_path_name (Pssa, directory, Ldirectory, entry, code);
      913 	if code ^= 0 then				/* assuming we're currently dealing with last msa	*/
      914 	     go to error;				/* on MSA chain, get its path name.		*/
      915 	call hcs_$get_ring_brackets (directory, entry, rings, code);
      916 	if code ^= 0 then				/* get the ring brackets of SSA for later use.	*/
      917 	     go to error;
      918 	if ssa.Nseg = 0 then do;			/* if our MSA is an SSA, then make it an MSA.	*/
      919 	     substr (directory, Ldirectory+1) = ">" || entry;
      920 						/* put path of MSA directory into _d_i_r_e_c_t_o_r_y.	*/
      921 	     validation_level = cu_$level_get();	/* save the current validation level.		*/
      922 	     call cu_$level_set (rings(1));		/* change validation level to ring in which	*/
      923 						/* first SSA of MSA was created so make_msf_ will	*/
      924 						/* work properly.				*/
      925 	     call make_msf_ (directory, "", rings, code);
      926 						/* convert SSF to MSF containing our 1st SSA.	*/
      927 	     call cu_$level_set (validation_level);	/* reset our validation level, before error check	*/
      928 	     if code ^= 0 then
      929 	     	go to error;
      930 	     end;
      931 
      932 	entry = convert_binary_integer_$decimal_string (ssa.Nseg+1);
      933 						/* get entryname of new SSA to be appended.	*/
      934 	Pold_ssa = Pssa;				/* save ptr to current SSA for fwd chaining	*/
      935 	Nstart = ssa.Nstart;
      936 	call make_seg (Nstart, rings);		/* make and initialize new SSA.		*/
      937 	call initialize (Pold_ssa->ssa.Pfirst, Pold_ssa->ssa.Pareap, null, 0, Pold_ssa->ssa.Nseg+1, Nstart, "1"b, ssa_size);
      938 	ssa.id.new_ssa = area_info.signal_id;		/* indicate new SSA created for the current alloc	*/
      939 	Pold_ssa->ssa.Pnext = Pssa;
      940 
      941 						/* update MSA directory's msf_indicator count.	*/
      942 	call hcs_$set_bc (directory, "", fixed (ssa.Nseg+1, 24), code);
      943 	if code ^= 0 then
      944 	     go to error;
      945 
      946 	end append;
      947 
      948 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      949 
      950 
      951 /**/
      952 
      953 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      954 
      955 
      956 initialize:
      957 	procedure (Pfirst, Pareap, Puser, Luser, Nseg, Nstart, Nsw, ssa_size);
      958 						/* initialize an SSA.			*/
      959 
      960      dcl						/*	parameters			*/
      961 	Pfirst			ptr,		/* ptr to first SSA in MSA chain.		*/
      962 	Pareap			ptr,		/* ptr to user's area ptr.			*/
      963 	Puser			ptr,		/* ptr to user area at head of SSA.		*/
      964 	Luser			fixed bin(35),	/* length of user area at head of SSA.		*/
      965 	Nseg			fixed bin(35),	/* MSA # of this SSA in MSA chain.		*/
      966 	Nstart			fixed bin,	/* min seg # which an SSA can be initiated with.	*/
      967 	Nsw			bit(1) aligned,	/* ON if we've created it and now initializing.	*/
      968 						/* OFF if we're re-initializing existing SSA.	*/
      969 	ssa_size			fixed bin(35);	/* size of segment used for new SSA.  Can be	*/
      970 						/*   either 64K or sys_info$max_seg_size.	*/
      971 
      972 
      973 	if ssa.id.string = "msa_" then		/* if this SSA has already been initialized,	*/
      974 	     Luser = ssa.Luser;			/* save user header info; don't call area_	*/
      975 	else do;					/* otherwise, reinitialize from top to bottom	*/
      976 	     if ^Nsw then do;			/* unless we aren't creating it, then report	*/
      977 		code = error_table_$improper_data_format;/* it as an illegal attempt to initialize.	*/
      978 		Pareap, Puser = null;		/* zap any pointers.			*/
      979 		Luser = 0;			/* return no traces.			*/
      980 		go to error;			/* It probably isn't an MSA to begin with.	*/
      981 		end;
      982 	     ssa.id.string = "msa_";			/* start with the id.			*/
      983 	     ssa.Parea = ptr (Pssa, divide (size(ssa)+Luser+7, 8, 35, 0) * 8);
      984 						/* make SSA's area reside on mod 8 boundary.	*/
      985 	     ssa.area_size = ssa_size;
      986 	     call area_ (ssa_size - fixed(rel(ssa.Parea),35), ssa.Parea);
      987 						/* initialize the SSA's area.			*/
      988 	     if Luser = 0 then			/* if no user header region is required,	*/
      989 		ssa.Puser = null;			/* forget about it.				*/
      990 	     else					/* otherwise, get ptr to it.			*/
      991 		ssa.Puser = ptr (Pssa, size(ssa));	/* size(ssa) should always = 0 mod 2 so that	*/
      992 						/* user header is always doubleword aligned.	*/
      993 	     ssa.Luser = Luser;			/* remember size of user region in SSA header.	*/
      994 	     ssa.Nstart = Nstart;			/* remember min seg #.			*/
      995 	     end;
      996 	ssa.Pfirst = Pfirst;			/* initialize rest of SSA's header.		*/
      997 	ssa.Pnext = null;				/* SSA is always last on any MSA chain.		*/
      998 	if Pareap = null then			/* if pointer to MSA pointer is null, then	*/
      999 	     Pareap = addr (ssa.Pcur_area);		/* create an MSA pointer in the header of this SSA*/
     1000 	ssa.Pareap = Pareap;			/* remember where MSA pointer is.		*/
     1001 	ssa.Nseg = Nseg;				/* store MSA # of this SSA in the MSA chain.	*/
     1002 	ssa.id.new_ssa,				/* init signal id's in this new SSA.		*/
     1003 	ssa.id.last_signal = "0"b;
     1004 
     1005 	Puser = ssa.Puser;				/* return ptr to user region of SSA header.	*/
     1006 	Pareap->areap = ssa.Parea;			/* make user's area pointer point to SSA's area.	*/
     1007 	call hcs_$set_bc_seg (Pssa, fixed ( (ssa.area_size * 36), 24), code);
     1008 						/* set the bit count to prevent premature re-use*/
     1009 	end initialize;
     1010 
     1011 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1012 
     1013 
     1014 /**/
     1015 
     1016 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1017 
     1018 
     1019 re_initiate:	procedure;			/* initiate an SSA, validating mode 	 	*/
     1020 
     1021      dcl						/*	parameter				*/
     1022 	Sseg			fixed bin(1);	/* reserved segment number switch.		*/
     1023 
     1024      dcl	Psave			ptr;		/* a pointer temporary			*/
     1025 
     1026 
     1027 	Pssa = null;				/* start out with null ptr			*/
     1028 	Sseg = 0;					/* don't know reserved segno at this point	*/
     1029 	Psave = Pareap;				/* just to keep it around			*/
     1030 						/* initiate SSA, possibly with reserved segno 	*/
     1031 						/* stored as initial value of Pssa.		*/
     1032 re_init:	call hcs_$initiate (directory, entry, "", Sseg, 0, Pssa, code);
     1033 	if (code ^= 0 & code ^= error_table_$segknown) then
     1034 	     go to error;
     1035 	if ssa.id.string = "msa_" then
     1036 	if Pssa ^= ptr ( ssa.Parea, 0) then do;		/* do we have the right ptr value?		*/
     1037 	     Pareap = ptr ( ssa.Parea, 0);
     1038 	     call hcs_$terminate_seg ( Pssa, 0b, code);
     1039 						/* terminate it, so we can use proper segno	*/
     1040 	     if code ^= 0 then
     1041 		go to error;			/* whoops					*/
     1042 	     Sseg = 1;				/* initiate with reserved segno		*/
     1043 	     Pssa = Pareap;				/* this is the segno we want			*/
     1044 	     go to re_init;				/* and try it again				*/
     1045 	     end;
     1046 	call hcs_$fs_get_mode (Pssa, mode, code);	/* get user's access to this SSA.		*/
     1047 	if code ^= 0 then
     1048 	     go to error;
     1049 	if mod (mode, 4) = 0 then do;			/* if user doesn't have write access, complain	*/
     1050 	     code = error_table_$moderr;
     1051 	     go to error;
     1052 	     end;
     1053 	call hcs_$set_bc_seg (Pssa, fixed ( (ssa.area_size * 36), 24), code);
     1054 	if code ^= 0 then
     1055 	     go to error;
     1056 	Pareap = Psave;				/* restore pointer to MSA pointer.		*/
     1057 
     1058 	end re_initiate;
     1059 
     1060 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1061 
     1062 
     1063 /**/
     1064 
     1065 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1066 
     1067 
     1068 make_seg:	procedure (Nstart, rings);			/* make a new SSA segment.			*/
     1069 
     1070      dcl	Nstart			fixed bin,	/* min seg # SSA can be initiated with.		*/
     1071 	i			fixed bin,	/* do loop index.				*/
     1072 	rings (3)			fixed bin(6);	/* ring brackets to be put on new SSA.		*/
     1073 
     1074 	validation_level = cu_$level_get();		/* save the current validation level.		*/
     1075 	call cu_$level_set (rings(1));		/* switch validation level to ring in which	*/
     1076 						/* SSA is to be created, so that correct initial	*/
     1077 						/* ACL for segments is placed on SSA.		*/
     1078 	call hcs_$append_branchx (directory, entry, 01011b, rings, get_group_id_$tag_star(), 0, 0, 0, code);
     1079 						/* create the SSA segment.			*/
     1080 	if code ^= 0 then do;			/* if creation failed, process the error.	*/
     1081 	     call cu_$level_set (validation_level);
     1082 	     go to error;
     1083 	     end;
     1084 
     1085 	if Nstart = 0 then				/* if a high segment number is unnecessary,	*/
     1086 	     call hcs_$initiate (directory, entry, "", 0, 0, Pssa, code);
     1087 	else do;					/* otherwise, keep trying to initiate the SSA	*/
     1088 	     Pssa = null;				/* with a seg no > Nstart until we succeed.	*/
     1089 	     do i = Nstart to active_all_rings_data_$max_segno while (Pssa = null);	
     1090 						/* starting with min seg #, keep incrementing	*/
     1091 		Pssa = baseptr (i);			/* seg # until we succeed in initiating ssa	*/
     1092 		call hcs_$initiate (directory, entry, "", 1, 0, Pssa, code);
     1093 		if code = error_table_$invalidsegno then do;
     1094 		   call cu_$level_set (validation_level); /* return to our validation level.		*/
     1095 		   goto error;
     1096 		   end;
     1097 		if code ^= 0 then Pssa = null;
     1098 
     1099 		end;
     1100 	     end;
     1101 	call cu_$level_set (validation_level);		/* return to our validation level.		*/
     1102 	if Pssa = null then				/* No matter which way segment was created, if it	*/
     1103 	     go to error;				/* couldn't be initiated, complain to caller.	*/
     1104 
     1105 	call hcs_$set_bc_seg (Pssa, fixed ( (ssa.area_size * 36), 24), code);
     1106 	if code ^= 0 then
     1107 	     go to error;				/* possible re-initiation of the MSA later.	*/
     1108 	end make_seg;
     1109 
     1110 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1111 /**/
     1112 
     1113 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1114 
     1115 
     1116 status:		procedure;			/* get status info for an MSA or SSA segment	*/
     1117 
     1118 	call hcs_$status_minf (directory, entry, 1, type, bit_count, code);
     1119 	if code ^= 0 then				/* get status info.				*/
     1120 	     if code = error_table_$noentry then do;	/* suppress entry not found errors.		*/
     1121 		type = 0;
     1122 		return;
     1123 		end;
     1124 	     else
     1125 		go to error;			/* report other errors to user.		*/
     1126 	if type = 2 then				/* set type code properly for an MSA.		*/
     1127 	     if bit_count > 0 then do;
     1128 		type = 3;
     1129 		msa_count = bit_count - 1;		/* bit count is number of SSA's, however,	*/
     1130 		end;				/* msa count starts at 0.			*/
     1131 
     1132 	end status;
     1133 
     1134 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1135 
     1136 
     1137 	end msa_manager_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/16/85  1658.5  msa_manager_.pl1                  >spec>install>1001>msa_manager_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

ANstart                                parameter       fixed bin(17,0)          dcl 441 ref 652 654
Acode                                  parameter       fixed bin(35,0)          dcl 441 set ref 652 658 662* 679* 688* 691* 703 706*
                                                                                  744* 754* 759* 813 821 829 837 850* 854* 856 858*
                                                                                  859* 864* 865 867* 868 876* 884* 886 894* 895
Adirectory                             parameter       char                     unaligned dcl 441 set ref 652 658 665 665 665 665
                                                                                  670 703 709*
Aentry                                 parameter       char                     unaligned dcl 441 set ref 652 658 664 671 703 709*
Ldirectory                      000102 automatic       fixed bin(17,0)          dcl 458 set ref 720* 720* 722 864* 870 912* 919
Luser                    22            based           fixed bin(35,0)          level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 973 993*
Luser                                  parameter       fixed bin(35,0)          dcl 441 in procedure "msa_manager_" set ref 652 658
                                                                                  685* 703 717* 729* 776 798*
Luser                                  parameter       fixed bin(35,0)          dcl 960 in procedure "initialize" set ref 956 973*
                                                                                  979* 983 988 993
Nseg                     23            based           fixed bin(35,0)          level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 918 932 937 942 942 1001*
Nseg                                   parameter       fixed bin(35,0)          dcl 960 in procedure "initialize" ref 956 1001
Nstart                   24            based           fixed bin(17,0)          level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 731 935 994*
Nstart                          000103 automatic       fixed bin(17,0)          dcl 458 in procedure "msa_manager_" set ref 654*
                                                                                  661* 684* 685* 731* 743* 748* 935* 936* 937*
Nstart                                 parameter       fixed bin(17,0)          dcl 960 in procedure "initialize" ref 956 994
Nstart                                 parameter       fixed bin(17,0)          dcl 1070 in procedure "make_seg" ref 1068 1085 1089
Nsw                                    parameter       bit(1)                   dcl 960 ref 956 976
Parea                     6            based           pointer                  level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 631 983* 986 986* 1006 1035
                                                                                  1037
Parea                   106            based           pointer                  level 2 in structure "area_info" dcl 492
                                                                                  in procedure "msa_manager_" set ref 594 631*
Pareap                   14            based           pointer                  level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 631 937* 1000*
Pareap                                 parameter       pointer                  dcl 960 in procedure "initialize" set ref 956 978*
                                                                                  998 998* 1000 1006
Pareap                                 parameter       pointer                  dcl 441 in procedure "msa_manager_" set ref 652 658
                                                                                  685* 703 717* 729* 748* 776 798* 813 821 829 837
                                                                                  842 843 1029 1037* 1043 1056*
Pcur_area                20            based           pointer                  level 2 dcl 492 set ref 998
Pfirst                   10            based           pointer                  level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 619 628 748* 842 937* 996*
Pfirst                                 parameter       pointer                  dcl 960 in procedure "initialize" ref 956 996
Pinfo                                  parameter       pointer                  dcl 441 ref 584 586 590 592 594 599 601 609 609 614
                                                                                  619 619 624 631 938
Pmc                                    parameter       pointer                  dcl 441 ref 584
Pnext                    12            based           pointer                  level 2 dcl 492 set ref 608 617 750* 846 893 939*
                                                                                  997*
Pold_ssa                        000100 automatic       pointer                  dcl 458 set ref 740* 748 750 893* 897 934* 937 937
                                                                                  937 939
Psave                           000362 automatic       pointer                  dcl 1024 set ref 1029* 1056
Pssa                            000104 automatic       pointer                  dcl 458 set ref 594* 596 599 601 608* 608 608* 609
                                                                                  609 614* 617 619 619 628* 628 631 631 685* 717*
                                                                                  729* 731 740 750 797 798* 842* 846 850* 854* 858*
                                                                                  859* 864* 891* 891 891* 893 894* 912* 918 932 934
                                                                                  935 938 939 942 942 973 973 982 983 983 983 985
                                                                                  986 986 988 990 990 990 993 994 996 997 998 1000
                                                                                  1001 1002 1002 1005 1006 1007* 1007 1007 1027*
                                                                                  1032* 1035 1035 1035 1037 1038* 1043* 1046* 1053*
                                                                                  1053 1053 1085* 1088* 1089 1091* 1092* 1097* 1102
                                                                                  1105* 1105 1105
Puser                    16            based           pointer                  level 2 in structure "ssa" dcl 492 in procedure
                                                                                  "msa_manager_" set ref 988* 990* 1005
Puser                                  parameter       pointer                  dcl 960 in procedure "initialize" set ref 956 978*
                                                                                  1005*
Puser                                  parameter       pointer                  dcl 441 in procedure "msa_manager_" set ref 652 658
                                                                                  685* 703 717* 729* 776 798*
Pwc_mc                                 parameter       pointer                  dcl 441 ref 584
Scont                                  parameter       bit(1)                   dcl 441 set ref 584 587*
Sseg                            000360 automatic       fixed bin(1,0)           dcl 1021 set ref 1028* 1032* 1042*
action_flags              2     000106 automatic       structure                level 2 in structure "area_error_info" dcl 458
                                                                                  in procedure "msa_manager_"
action_flags              2            based           structure                level 2 in structure "area_info" dcl 492
                                                                                  in procedure "msa_manager_"
active_all_rings_data_$max_segno
                                000074 external static fixed bin(35,0)          dcl 565 ref 1089
addr                                                   builtin function         dcl 525 ref 644 644 665 665 665 665 665 665 998
append                          002237 constant        entry                    internal dcl 908 ref 624 626
area_                           000010 constant        entry                    external dcl 529 ref 986
area_error_info                 000106 automatic       structure                level 1 dcl 458 set ref 643 644 644
area_handler                    000167 constant        entry                    external dcl 584
area_info                              based           structure                level 1 unaligned dcl 492
area_size                25            based           fixed bin(19,0)          level 2 dcl 492 set ref 609 985* 1007 1007 1053 1053
                                                                                  1105 1105
areap                                  based           pointer                  dcl 492 set ref 631* 842 843* 1006*
backup_name_                    000012 constant        entry                    external dcl 529 ref 787
baseptr                                                builtin function         dcl 525 ref 1091
bit_count                       000213 automatic       fixed bin(24,0)          dcl 458 set ref 794 1118* 1126 1129
cant_restart              2     000106 automatic       bit(1)                   level 3 in structure "area_error_info" packed
                                                                                  unaligned dcl 458 in procedure "msa_manager_" set
                                                                                  ref 641*
cant_restart              2            based           bit(1)                   level 3 in structure "area_info" packed unaligned
                                                                                  dcl 492 in procedure "msa_manager_" ref 592
code                            000214 automatic       fixed bin(35,0)          dcl 458 set ref 637 665* 666 676* 678 691 709* 710
                                                                                  732* 733 912* 913 915* 916 925* 928 942* 943 977*
                                                                                  1007* 1032* 1033 1033 1038* 1040 1046* 1047 1050*
                                                                                  1053* 1054 1078* 1080 1085* 1092* 1093 1097 1105*
                                                                                  1106 1118* 1119 1119
common                          000564 constant        label                    dcl 662 set ref 655
common2                         001650 constant        label                    dcl 842 ref 816 824 832
cond                                   parameter       char                     unaligned dcl 441 ref 584
convert_binary_integer_$decimal_string
                                000014 constant        entry                    external dcl 529 ref 738 780 932
cu_$level_get                   000016 constant        entry                    external dcl 529 ref 683 880 921 1074
cu_$level_set                   000020 constant        entry                    external dcl 529 ref 882 885 922 927 1075 1081 1094
                                                                                  1101
default_restart           2(01) 000106 automatic       bit(1)                   level 3 packed unaligned dcl 458 set ref 640*
delete                          001576 constant        entry                    external dcl 821
delete_$path                    000022 constant        entry                    external dcl 529 ref 876
directory                       000215 automatic       char(168)                dcl 458 set ref 638 665 665 670* 676* 709* 720 722*
                                                                                  732* 779* 864* 867* 870 872 873* 876* 884* 912*
                                                                                  915* 919* 925* 942* 1032* 1078* 1085* 1092* 1118*
divide                                                 builtin function         dcl 525 ref 983
do                              000024 constant        label                    array(3:5) dcl 846 ref 844
e                               000267 automatic       fixed bin(17,0)          dcl 458 set ref 815* 823* 831* 839* 844 848 874
end_msa                         000031 constant        label                    array(3:4) dcl 876 ref 874
end_ssa                         000027 constant        label                    array(3:4) dcl 850 ref 848 888
entry                           000270 automatic       char(32)                 dcl 458 set ref 665 665 671* 676* 709* 722 723* 732*
                                                                                  738* 780* 787* 787* 864* 867* 872* 876* 876* 884*
                                                                                  912* 915* 919 932* 1032* 1078* 1085* 1092* 1118*
error                           000300 automatic       label variable           local dcl 458 set ref 623* 663* 666 707* 710 733
                                                                                  784* 913 916 928 943 980 1033 1040 1047 1051 1054
                                                                                  1082 1095 1102 1106 1119
error_table_$dirseg             000076 external static fixed bin(35,0)          dcl 565 ref 688 759
error_table_$improper_data_format
                                000100 external static fixed bin(35,0)          dcl 565 ref 977
error_table_$invalidsegno       000102 external static fixed bin(35,0)          dcl 565 ref 1093
error_table_$moderr             000104 external static fixed bin(35,0)          dcl 565 ref 1050
error_table_$namedup            000106 external static fixed bin(35,0)          dcl 565 ref 679
error_table_$noalloc            000110 external static fixed bin(35,0)          dcl 565 ref 603
error_table_$noentry            000112 external static fixed bin(35,0)          dcl 565 ref 754 1119
error_table_$seg_not_found      000114 external static fixed bin(35,0)          dcl 565 ref 744
error_table_$segknown           000116 external static fixed bin(35,0)          dcl 565 ref 1033
expand_path_                    000024 constant        entry                    external dcl 529 ref 665
fixed                                                  builtin function         dcl 525 ref 780 780 872 873 942 942 986 1007 1007
                                                                                  1053 1053 1105 1105
get_another                     001551 constant        label                    dcl 801 ref 784 794
get_group_id_$tag_star          000030 constant        entry                    external dcl 529 ref 1078 1078
get_pdir_                       000026 constant        entry                    external dcl 529 ref 779
get_ring_                       000032 constant        entry                    external dcl 529 ref 778
get_system_msa_                 001367 constant        entry                    external dcl 776
gsa                             000020 constant        label                    array(0:3) dcl 791 ref 789
gsa_0                           001520 constant        label                    dcl 798 ref 792
hcs_$append_branchx             000034 constant        entry                    external dcl 529 ref 1078
hcs_$delentry_seg               000036 constant        entry                    external dcl 529 ref 850
hcs_$fs_get_mode                000040 constant        entry                    external dcl 529 ref 1046
hcs_$fs_get_path_name           000042 constant        entry                    external dcl 529 ref 864 912
hcs_$get_link_target            000044 constant        entry                    external dcl 529 ref 709
hcs_$get_ring_brackets          000046 constant        entry                    external dcl 529 ref 732 867 915
hcs_$initiate                   000050 constant        entry                    external dcl 529 ref 1032 1085 1092
hcs_$set_bc                     000052 constant        entry                    external dcl 529 ref 942
hcs_$set_bc_seg                 000054 constant        entry                    external dcl 529 ref 854 1007 1053 1105
hcs_$status_minf                000056 constant        entry                    external dcl 529 ref 1118
hcs_$terminate_seg              000060 constant        entry                    external dcl 529 ref 859 894 1038
hcs_$truncate_seg               000062 constant        entry                    external dcl 529 ref 858
i                               000304 automatic       fixed bin(35,0)          dcl 458 in procedure "msa_manager_" set ref 736*
                                                                                  738* 748* 870* 870* 872 873
i                               000372 automatic       fixed bin(17,0)          dcl 1070 in procedure "make_seg" set ref 1089* 1091*
id                                     based           structure                level 2 unaligned dcl 492
info_string               3     000106 automatic       varying char(256)        level 2 dcl 458 set ref 604* 638*
init                            000004 constant        label                    array(0:3) dcl 715 ref 713
init_1st_ssa                    000010 constant        label                    array(0:3) dcl 727 ref 725
init_ssa                        000014 constant        label                    array(0:3) dcl 743 ref 741
initialize                      002564 constant        entry                    internal dcl 956 ref 685 717 729 748 798 937
initialize_                     001310 constant        label                    dcl 748 ref 745
initiate                        000774 constant        entry                    external dcl 703
last_signal               4            based           bit(70)                  level 3 dcl 492 set ref 599* 609 614* 619 619 1002*
length                                                 builtin function         dcl 525 in procedure "msa_manager_" ref 665 665
length                          000106 automatic       fixed bin(17,0)          level 2 in structure "area_error_info" dcl 458
                                                                                  in procedure "msa_manager_" set ref 643*
make                            000534 constant        entry                    external dcl 658
make                            000000 constant        label                    array(0:3) dcl 676 in procedure "msa_manager_" ref
                                                                                  674
make_msf_                       000064 constant        entry                    external dcl 529 ref 925
make_seg                        003160 constant        entry                    internal dcl 1068 ref 684 743 791 936
make_special                    000473 constant        entry                    external dcl 652
mod                                                    builtin function         dcl 525 ref 1049
mode                            000305 automatic       fixed bin(5,0)           dcl 458 set ref 1046* 1049
msa_count                       000306 automatic       fixed bin(35,0)          dcl 458 set ref 708* 736 1129*
msa_manager_                    000154 constant        entry                    external dcl 438
nd_handler_                     000066 constant        entry                    external dcl 529 ref 676
new_ssa                   2            based           bit(70)                  level 3 dcl 492 set ref 601 938* 1002*
null                                                   builtin function         dcl 525 ref 586 608 644 644 748 748 843 846 891 937
                                                                                  937 978 988 997 998 1027 1088 1089 1097 1102
pad                       2(02) 000106 automatic       bit(34)                  level 3 packed unaligned dcl 458 set ref 635*
pass_on                         000207 constant        label                    dcl 587 ref 590 592 596 645
ptr                                                    builtin function         dcl 525 ref 594 842 983 990 1035 1037
re_init                         002770 constant        label                    dcl 1032 ref 1044
re_initiate                     002761 constant        entry                    internal dcl 1019 ref 715 727 747 796
rel                                                    builtin function         dcl 525 ref 986
release_system_msa_             001557 constant        entry                    external dcl 813
return_area                     000362 constant        label                    dcl 631 ref 609
return_code                     000767 constant        label                    dcl 691 ref 663 707
rings                           000307 automatic       fixed bin(6,0)           array dcl 458 in procedure "msa_manager_" set ref
                                                                                  683* 683* 683* 684* 732* 743* 778* 778* 778* 780
                                                                                  780 791* 867* 882* 884* 915* 922* 925* 936*
rings                                  parameter       fixed bin(6,0)           array dcl 1070 in procedure "make_seg" set ref 1068
                                                                                  1075* 1078*
signal                          000421 constant        label                    dcl 640 ref 605
signal_                         000070 constant        entry                    external dcl 529 ref 644
signal_error                    000373 constant        label                    dcl 635 set ref 623
signal_id               111            based           bit(70)                  level 2 dcl 492 ref 599 601 609 614 619 619 938
size                                                   builtin function         dcl 525 ref 643 983 990
small_ssa_size                  000033 constant        fixed bin(35,0)          initial dcl 565 set ref 624 624* 685* 717* 729* 748*
                                                                                  798*
space                   110            based           fixed bin(35,0)          level 2 dcl 492 ref 609 624
ssa                                    based           structure                level 1 unaligned dcl 492 set ref 983 990
ssa_size                               parameter       fixed bin(35,0)          dcl 910 in procedure "append" set ref 908 937*
ssa_size                               parameter       fixed bin(35,0)          dcl 960 in procedure "initialize" ref 956 985 986
status                          003515 constant        entry                    internal dcl 1116 ref 673 712 724 739 788
status_code             104     000106 automatic       fixed bin(35,0)          level 2 dcl 458 set ref 603* 637*
string                                 based           char(8)                  level 3 dcl 492 set ref 596 797* 973 982* 1035
substr                                                 builtin function         dcl 525 set ref 720 722* 870 872 873* 919*
sys_info$max_seg_size           000120 external static fixed bin(35,0)          dcl 565 set ref 626*
terminate                       001634 constant        entry                    external dcl 837
truncate                        001615 constant        entry                    external dcl 829
type                            000312 automatic       fixed bin(2,0)           dcl 458 set ref 674 713 725 741 789 1118* 1121* 1126
                                                                                  1128*
unmake_msf_                     000072 constant        entry                    external dcl 529 ref 884
validation_level                000313 automatic       fixed bin(6,0)           dcl 458 set ref 880* 885* 921* 927* 1074* 1081*
                                                                                  1094* 1101*
version                   1            based           fixed bin(17,0)          level 2 in structure "area_info" dcl 492
                                                                                  in procedure "msa_manager_" ref 590
version                   1     000106 automatic       fixed bin(17,0)          level 2 in structure "area_error_info" dcl 458
                                                                                  in procedure "msa_manager_" set ref 642*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4350        4472    3631        4360
Length      4774    3631       122         266     516           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
msa_manager_                        516 external procedure  is an external procedure.  
append                                  internal procedure  shares stack frame of external procedure msa_manager_.  
initialize                              internal procedure  shares stack frame of external procedure msa_manager_.  
re_initiate                             internal procedure  shares stack frame of external procedure msa_manager_.  
make_seg                                internal procedure  shares stack frame of external procedure msa_manager_.  
status                                  internal procedure  shares stack frame of external procedure msa_manager_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
msa_manager_             000100 Pold_ssa                    msa_manager_
                         000102 Ldirectory                  msa_manager_
                         000103 Nstart                      msa_manager_
                         000104 Pssa                        msa_manager_
                         000106 area_error_info             msa_manager_
                         000213 bit_count                   msa_manager_
                         000214 code                        msa_manager_
                         000215 directory                   msa_manager_
                         000267 e                           msa_manager_
                         000270 entry                       msa_manager_
                         000300 error                       msa_manager_
                         000304 i                           msa_manager_
                         000305 mode                        msa_manager_
                         000306 msa_count                   msa_manager_
                         000307 rings                       msa_manager_
                         000312 type                        msa_manager_
                         000313 validation_level            msa_manager_
                         000360 Sseg                        re_initiate
                         000362 Psave                       re_initiate
                         000372 i                           make_seg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return              mod_fx1
shorten_stack       ext_entry           ext_entry_desc      divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_                         backup_name_                  convert_binary_integer_$decimal_string
cu_$level_get                 cu_$level_set                 delete_$path                  expand_path_
get_group_id_$tag_star        get_pdir_                     get_ring_                     hcs_$append_branchx
hcs_$delentry_seg             hcs_$fs_get_mode              hcs_$fs_get_path_name         hcs_$get_link_target
hcs_$get_ring_brackets        hcs_$initiate                 hcs_$set_bc                   hcs_$set_bc_seg
hcs_$status_minf              hcs_$terminate_seg            hcs_$truncate_seg             make_msf_
nd_handler_                   signal_                       unmake_msf_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data_$max_segno                            error_table_$dirseg
error_table_$improper_data_format                           error_table_$invalidsegno     error_table_$moderr
error_table_$namedup          error_table_$noalloc          error_table_$noentry          error_table_$seg_not_found
error_table_$segknown         sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    438 000153       584 000161       586 000202       587 000207       588 000212       590 000213       592 000220
    594 000223       596 000225       599 000234       601 000240       603 000246       604 000250       605 000255
    608 000256       609 000265       614 000302       617 000306       619 000311       623 000331       624 000334
    626 000351       627 000360       628 000361       631 000362       634 000372       635 000373       637 000375
    638 000377       640 000421       641 000424       642 000426       643 000430       644 000432       645 000464
    652 000465       654 000522       655 000525       658 000526       661 000563       662 000564       663 000565
    664 000570       665 000602       666 000634       668 000637       670 000640       671 000650       673 000654
    674 000655       676 000657       678 000710       679 000712       680 000715       683 000716       684 000731
    685 000733       686 000762       688 000763       689 000766       691 000767       693 000771       703 000772
    706 001023       707 001024       708 001027       709 001030       710 001061       712 001064       713 001065
    715 001067       717 001070       718 001120       720 001121       721 001133       722 001136       723 001155
    724 001161       725 001162       727 001164       729 001165       731 001215       732 001220       733 001245
    736 001250       738 001257       739 001274       740 001275       741 001277       743 001301       744 001303
    745 001306       747 001307       748 001310       750 001342       751 001345       752 001352       754 001353
    757 001356       759 001357       765 001362       776 001363       778 001403       779 001416       780 001425
    784 001455       786 001461       787 001462       788 001502       789 001503       791 001505       792 001510
    794 001511       796 001513       797 001514       798 001520       800 001550       801 001551       813 001552
    815 001571       816 001573       821 001574       823 001610       824 001612       829 001613       831 001627
    832 001631       837 001632       839 001646       842 001650       843 001655       844 001657       846 001661
    848 001664       850 001665       852 001676       854 001677       856 001713       858 001715       859 001731
    860 001745       864 001746       865 001777       867 002001       868 002026       870 002030       871 002041
    872 002046       873 002055       874 002065       876 002067       878 002121       880 002122       882 002131
    884 002140       885 002173       886 002202       888 002204       891 002205       893 002212       894 002215
    895 002231       897 002233       898 002236       908 002237       912 002241       913 002272       915 002275
    916 002322       918 002325       919 002330       921 002347       922 002357       925 002366       927 002413
    928 002422       932 002425       934 002447       935 002451       936 002453       937 002455       938 002514
    939 002524       942 002526       943 002560       946 002563       956 002564       973 002566       976 002601
    977 002604       978 002607       979 002612       980 002613       982 002614       983 002620       985 002633
    986 002637       988 002661       990 002670       993 002674       994 002677       996 002701       997 002706
    998 002711      1000 002717      1001 002723      1002 002726      1005 002733      1006 002735      1007 002741
   1009 002760      1019 002761      1027 002762      1028 002764      1029 002765      1032 002770      1033 003032
   1035 003040      1037 003056      1038 003060      1040 003074      1042 003077      1043 003101      1044 003104
   1046 003105      1047 003120      1049 003123      1050 003127      1051 003132      1053 003133      1054 003152
   1056 003155      1058 003157      1068 003160      1074 003162      1075 003171      1078 003201      1080 003265
   1081 003267      1082 003276      1085 003277      1088 003346      1089 003350      1091 003365      1092 003371
   1093 003435      1094 003441      1095 003447      1097 003450      1099 003454      1101 003456      1102 003465
   1105 003472      1106 003511      1108 003514      1116 003515      1118 003516      1119 003555      1121 003563
   1122 003564      1126 003565      1128 003572      1129 003574      1132 003577


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
