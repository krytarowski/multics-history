	COMPILATION LISTING OF SEGMENT azm_verify_dump_ams_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/28/87  0932.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(87-07-09,Parisek), approve(87-07-09,MCR7746),
       13*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
       14*     Changed references of BOS CPU to Bootload CPU.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 azm_verify_dump_ams_: proc (P_amu_info_ptr, do_sdws, do_ptws, P_code);
       19 
       20 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       21 
       22 /* Routine to verify that the contents of the Associative Memories  stored
       23*   at the time of the dump match the appropriate entries in the dseg of
       24*   the process defined by dump.dbr.
       25*   This code was taken from ol_dumps display_am_$validate_am_btld and modified
       26*   to work with analyze_multics (azm).
       27*   Sept 1982 by Rich Coppola.
       28*
       29*   Modified July 84 by B. Braun to add knowledge of unpaged_page_tables.
       30*   Modified Sept 84 by B. Braun to add knowledge of int_unpaged_page_tables.
       31**/
       32 
       33 dcl  P_amu_info_ptr ptr;
       34 
       35 
       36 dcl  (do_sdws, do_ptws) bit (1);
       37 dcl  P_code fixed bin (35);
       38 
       39 
       40 /* Automatic */
       41 
       42 dcl  (i, j, idx, process_idx) fixed bin;
       43 dcl  af_sw bit (1) init ("0"b);			/* "1"b => used as an AF */
       44 dcl  nregs fixed bin;
       45 dcl  dump_dbr fixed bin (24);
       46 dcl  code fixed bin (35);
       47 dcl  DPS8xxM bit (1);
       48 dcl  RETURN_VAL bit (1) init ("0"b);
       49 dcl  (found_mismatch_sdw, found_mismatch_ptw) bit (1) init ("0"b);
       50 dcl  (found_dup_entry_sdw, found_dup_entry_ptw) bit (1) init ("0"b);
       51 dcl  changed_process_idx bit (1) init ("0"b);
       52 dcl  tsptw_mask bit (36) init ("777777000100"b3);
       53 dcl  tdsdw_mask bit (72) init ("777777777770777777777777"b3);
       54 dcl  dup_entry (0:63) bit (1) unal;
       55 dcl  (sdw_regs_ptr, sdw_ptrs_ptr, ptw_regs_ptr, ptw_ptrs_ptr) ptr;
       56 dcl  (reg_ptr, ptr_ptr, temp_ptr) ptr;
       57 dcl  (tdsegp, tasdwp, taptwp, sptp, dsegp) ptr;
       58 dcl  flag_string char (7);
       59 dcl  usage_string char (8);
       60 dcl  1 hard_ptr_space like hardcore_cur;
       61 
       62 /* Based */
       63 
       64 dcl  last_three_sets bit (48 * 36) based;
       65 dcl  1 sdw_regs (0:63) aligned like amsdwreg based (sdw_regs_ptr);
       66 dcl  1 sdw_ptrs (0:63) aligned like amsdwptr based (sdw_ptrs_ptr);
       67 dcl  1 ptw_regs (0:63) aligned like amptwreg based (ptw_regs_ptr);
       68 dcl  1 ptw_ptrs (0:63) aligned like amptwptr based (ptw_ptrs_ptr);
       69 dcl  tdsdw bit (72) based (tdsegp);
       70 dcl  tasdw bit (72) based (tasdwp);
       71 dcl  tsptw bit (36) based (sptp);
       72 dcl  taptw bit (36) based (taptwp);
       73 
       74 /* Static */
       75 
       76 /* External */
       77 
       78 dcl  ioa_ entry options (variable);
       79 dcl  ioa_$rsnnl entry options (variable);
       80 dcl  amu_et_$null_sstp fixed bin(35) ext static;
       81 dcl  amu_$fdump_mpt_temp_change_idx entry (ptr, fixed bin);
       82 dcl  amu_$fdump_mpt_revert_idx entry (ptr);
       83 dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
       84 dcl  amu_$return_val_idx_from_dbr entry (ptr, fixed bin (24)) returns (fixed bin);
       85 dcl  amu_$do_translation_hunt_ptr entry (ptr, ptr, ptr, fixed bin (35));
       86 dcl  amu_et_$npdx_dbr fixed bin (35) external static;
       87 
       88 dcl  any_other condition;
       89 dcl  (addr, addrel, baseptr, bin, 
       90       binary, divide, fixed, null,
       91       pointer, ptr, substr)		builtin;
       92 
       93 
       94     go to COMMON;
       95 
       96 azm_verify_dump_ams_$af: entry (P_amu_info_ptr, do_sdws, do_ptws, P_code) returns (bit (1));
       97 
       98     af_sw = "1"b;
       99 
      100 COMMON:	
      101 
      102     on condition (any_other) begin;
      103        if changed_process_idx then call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      104        changed_process_idx = "0"b;
      105        go to done;
      106        end;
      107 
      108     call set_up;
      109     if code ^= 0 then go to done;
      110 
      111     if do_sdws then do;				/* verify the SDWAM */
      112        call verify_am_sdw;			/* check for duplicate entries */
      113        do idx = 0 to nregs;			/* cycle thru ass mem */
      114 	if sdw_ptrs (idx).valid then do;	/* only for valid entries */
      115 	   tdsegp = addrel (dsegp, (bin (sdw_ptrs (idx).pointer, 15) * 2));
      116 	   tasdwp = addr (sdw_regs (idx));
      117 	   if (tdsdw & tdsdw_mask) ^= tasdw then do;
      118 	      found_mismatch_sdw = "1"b;
      119 	      if af_sw = "0"b then do;
      120 	         call ioa_ ("^/Mis-Match between SDWAM and dseg on Bootload CPU;^/");
      121 		call ioa_ (" ADDRESS^2xRINGS^2xBOUND^2xREWPUGC^4xCL F/E USAGE-CT SEG # SEG_NAME");
      122 		reg_ptr = addr (sdw_regs (idx));
      123 		ptr_ptr = addr (sdw_ptrs (idx));
      124 		call display_mismatch_sdw (reg_ptr, ptr_ptr);
      125 		call display_dseg_entry (tdsegp);
      126 		end;
      127 	       end;
      128 	    end;
      129 	 end;
      130         end;
      131 
      132 check_ptws: 
      133 
      134     if do_ptws then do;
      135        call verify_am_ptw;			/* check for duplicate entries */
      136 
      137        do idx = 0 to nregs;
      138 	if ptw_ptrs (idx).valid then do;
      139 	   sdwp = addr (dsegp -> sdwa (bin (ptw_ptrs (idx).pointer, 15)));
      140 	   call get_ptp(sdwp, upt_ptr, sstp, ptp);
      141 	   sptp = addrel (ptp, (divide (binary (ptw_ptrs (idx).pageno, 12), 16, 12, 0)));
      142 	   taptwp = addr (ptw_regs (idx));
      143 	   if (tsptw & tsptw_mask) ^= taptw then do;
      144 					/* found a bad one */
      145 	       found_mismatch_ptw = "1"b;
      146 	       if af_sw = "0"b then do;
      147 		call ioa_ ("^/Mis-Match between PTWAM and page table on Bootload CPU;^/");
      148 		call ioa_ (" ADDRESS^3xM^2xF/E USAGE_CT SEG # PAGE");
      149 		reg_ptr = addr (ptw_regs (idx));
      150 		ptr_ptr = addr (ptw_ptrs (idx));
      151 		call display_mismatch_ptw (reg_ptr, ptr_ptr);
      152 		call display_sst_entry (sptp);
      153 		end;
      154 	       end;
      155 	    end;
      156 	 end;
      157         end;
      158 
      159 done:
      160 
      161     if (found_mismatch_sdw | found_mismatch_ptw | found_dup_entry_sdw | found_dup_entry_ptw) then do;
      162        RETURN_VAL = "1"b;
      163        go to RET;
      164        end;
      165 
      166     if ^af_sw then
      167        call ioa_ ("No mis-matches or duplicate entries found in^[ SDWAM^]^[ or^]^[ PTWAM^].", do_sdws,
      168 	(do_sdws & do_ptws), do_ptws);
      169        RETURN_VAL = "0"b;
      170 	
      171 RET:
      172        if changed_process_idx then call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      173        P_code = code;
      174        if af_sw then return (RETURN_VAL);
      175        return;					/* logical end */
      176 
      177 
      178 
      179 display_dseg_entry:
      180      proc (dseg_entp);
      181 dcl  dseg_entp ptr;
      182 dcl  flag_string char (7);
      183 dcl  1 dseg_ent based (dseg_entp),
      184        (
      185        2 addr bit (24),
      186        2 ring1 bit (3),
      187        2 ring2 bit (3),
      188        2 ring3 bit (3),
      189        2 pad1 bit (4),
      190        2 bounds bit (14),
      191        2 rd bit (1),
      192        2 ex bit (1),
      193        2 wrt bit (1),
      194        2 priv bit (1),
      195        2 unp bit (1),
      196        2 ebs bit (1),
      197        2 cache bit (1),
      198        2 cl bit (14)
      199        ) unal;
      200 
      201 
      202 	call ioa_$rsnnl ("^[R^; ^]^[E^; ^]^[W^; ^]^[P^; ^]^[U^; ^]^[G^; ^]^[C^; ^]", flag_string, (0),
      203 						/* generate the REWPUGC string */
      204 	     dseg_ent.rd, dseg_ent.ex, dseg_ent.wrt, dseg_ent.priv, dseg_ent.unp, dseg_ent.ebs, dseg_ent.cache);
      205 
      206 	call ioa_ ("^8o^2x^1.3b,^1.3b,^1.3b ^6o^2x^7a ^[^5o^]^-(dseg entry)", binary (dseg_ent.addr, 24),
      207 	     dseg_ent.ring1, dseg_ent.ring2, dseg_ent.ring3, binary ((dseg_ent.bounds || "0000"b), 18), flag_string,
      208 	     ((^dseg_ent.ebs) & dseg_ent.ex), binary (dseg_ent.cl, 14));
      209 	return;
      210      end display_dseg_entry;
      211 
      212 
      213 display_mismatch_ptw:
      214      proc (a_ptw_reg_ptr, a_ptw_ptr_ptr);
      215 dcl  (a_ptw_reg_ptr, a_ptw_ptr_ptr) ptr;
      216 dcl  1 a_ptw_reg aligned like amptwreg based (a_ptw_reg_ptr);
      217 dcl  1 a_ptw_ptr aligned like amptwptr based (a_ptw_ptr_ptr);
      218 
      219 
      220 	if ^DPS8xxM then
      221 	     call ioa_$rsnnl ("^6x^2d", usage_string, (0), binary (a_ptw_ptr.usage, 4));
      222 
      223 	else call ioa_$rsnnl ("^2x^6b", usage_string, (0), a_ptw_ptr.usage);
      224 
      225 	call ioa_ ("^8o^2x^[yes^;no ^]^2x^[F^;E^]^2x^8a ^5o ^4o", binary ((a_ptw_reg.addr || "000000"b), 24),
      226 	     a_ptw_reg.modif, a_ptw_ptr.valid, usage_string, binary (a_ptw_ptr.pointer, 15),
      227 	     divide (binary (a_ptw_ptr.pageno, 12), 16, 12, 0));
      228 	return;
      229      end display_mismatch_ptw;
      230 
      231 
      232 display_mismatch_sdw:
      233      proc (a_sdw_reg_ptr, a_sdw_ptr_ptr);
      234 dcl  (a_sdw_reg_ptr, a_sdw_ptr_ptr) ptr;
      235 dcl  1 a_sdw_reg aligned like amsdwreg based (a_sdw_reg_ptr);
      236 dcl  1 a_sdw_ptr aligned like amsdwptr based (a_sdw_ptr_ptr);
      237 
      238 
      239 
      240 	call ioa_$rsnnl ("^[R^; ^]^[E^; ^]^[W^; ^]^[P^; ^]^[U^; ^]^[G^; ^]^[C^; ^]", flag_string, (0),
      241 						/* generate the REWPUGC string */
      242 	     a_sdw_reg.read, a_sdw_reg.execute, a_sdw_reg.write, a_sdw_reg.privileged, a_sdw_reg.unpaged,
      243 	     a_sdw_reg.entry_bound_sw, a_sdw_reg.cache);
      244 
      245 	if ^DPS8xxM then
      246 	     call ioa_$rsnnl ("^6x^2d", usage_string, (0), binary (a_sdw_ptr.usage, 4));
      247 
      248 	else call ioa_$rsnnl ("^2x^6b", usage_string, (0), a_sdw_ptr.usage);
      249 
      250 	call ioa_ ("^8o^2x^1.3b,^1.3b,^1.3b ^6o^2x^7a ^[^5o^;^s^4x-^]^2x^[F^;E^]^2x^8a ^5o",
      251 	     binary (a_sdw_reg.addr, 24), a_sdw_reg.r1, a_sdw_reg.r2, a_sdw_reg.r3,
      252 	     binary ((a_sdw_reg.bound || "0000"b), 18), flag_string, ((^a_sdw_reg.entry_bound_sw) & a_sdw_reg.execute),
      253 						/* skip next if there is none */
      254 	     binary (a_sdw_reg.cl, 14), a_sdw_ptr.valid, usage_string, binary (a_sdw_ptr.pointer, 15));
      255 	return;
      256      end display_mismatch_sdw;
      257 
      258 
      259 display_sst_entry:
      260      proc (a_ptp);
      261 
      262 dcl  a_ptp ptr;
      263 dcl  1 page_wd based (a_ptp),
      264        (
      265        2 addr bit (18),
      266        2 padd1 bit (11),
      267        2 modifd bit (1),
      268        2 padd2 bit (6) unal
      269        );
      270 
      271 	call ioa_ ("^8o^2x^[yes^;no ^]^2x(page table in memory)", binary ((page_wd.addr || "000000"b), 24),
      272 	     page_wd.modifd);
      273 
      274 	return;
      275      end display_sst_entry;
      276 
      277 
      278 get_ptp:  proc(sdwp, upt_ptr, sstp, ptp);
      279 
      280 /* This procedure determines the page table pointer. */
      281 
      282 /* parameters */
      283 
      284 dcl ptp ptr;
      285 dcl sdwp ptr;
      286 dcl sstp ptr;
      287 dcl upt_ptr ptr;
      288 
      289 /* automatic */
      290 
      291 dcl relative_offset fixed bin(26);
      292 dcl sdw_add fixed bin(26);
      293 
      294     sdw_add = fixed(sdwp->sdw.add,26);
      295 
      296     if upt_ptr = null() then
      297        ptp = ptr (sstp, fixed (sdw.add, 24) - fixed (sst.ptwbase, 18));
      298 
      299     else if (sdw_add > upt.upt_absloc & sdw_add < upt.upt_last_loc) then do;
      300        /* found in unpaged_page_table */
      301        relative_offset = sdw_add - upt.upt_absloc;
      302        ptp = addrel(upt_ptr, relative_offset);  
      303        end;
      304 
      305     else if (sdw_add > upt.iupt_absloc & sdw_add < upt.iupt_last_loc) then do;
      306        /* found in int_unpaged_page_table */
      307        relative_offset = sdw_add - upt.iupt_absloc;
      308        ptp = addrel(upt_ptr, relative_offset);  
      309        end;
      310 
      311     else do;
      312        /* found in sst_seg */
      313        relative_offset = sdw_add - upt.sst_absloc;
      314        ptp = addrel(sstp, relative_offset);        
      315        end;
      316 
      317 end get_ptp;
      318 
      319 set_up:
      320      proc;
      321 
      322 	amu_info_ptr = P_amu_info_ptr;
      323 	P_code, code = 0;
      324 	process_idx = -1;
      325 	dumpptr = fdump_info.dump_seg_ptr (0);
      326 	dump_dbr = fixed (substr (dump.dbr, 1, 24), 24);
      327 	ptw_regs_ptr = addr (dump.amptwregs);
      328 	ptw_ptrs_ptr = addr (dump.amptwptrs);
      329 	sdw_regs_ptr = addr (dump.amsdwregs);
      330 	sdw_ptrs_ptr = addr (dump.amsdwptrs);
      331 	process_idx = amu_$return_val_idx_from_dbr (amu_info_ptr, dump_dbr);
      332 	if process_idx = -1 then do;
      333 	     code = amu_et_$npdx_dbr;		/* cant set process index with this dbr */
      334 	     return;
      335 	     end;
      336 
      337 	call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, process_idx);
      338 	changed_process_idx = "1"b;			/* remember */
      339 	hardcore_cur_ptr = addr (hard_ptr_space);	/* get pointers to interesting hc */
      340 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      341 	sstp = hardcore_cur.sstp;
      342 	upt_ptr = hardcore_cur.uptp;
      343 
      344 	call amu_$do_translation_hunt_ptr (amu_info_ptr, pointer (baseptr (hardcore_info.dseg), 0), dsegp, code);
      345 						/* get a pointer to the DSEG */
      346 	if code ^= 0 then do;
      347 	   if ^af_sw then
      348 	     call ioa_ ("Cannot get ptr to dseg from dbr ^8o.", dump_dbr);
      349 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      350 	     P_code = code;
      351 	     return;
      352 	     end;
      353 
      354 	temp_ptr = addrel (ptw_regs_ptr, 16);		/* base to 2'nd set of regs */
      355 	if temp_ptr -> last_three_sets = "0"b then do;	/* if second set is zero then */
      356 	     nregs = 15;				/* AMs are from a l68 */
      357 	     DPS8xxM = "0"b;
      358 	     end;
      359 	else do;					/* No, they are from a DPS8M */
      360 	     nregs = 63;
      361 	     DPS8xxM = "1"b;
      362 	     end;
      363 	return;
      364      end set_up;
      365 
      366 
      367 verify_am_ptw:
      368      proc;
      369 
      370 	if sstp = null () then do;
      371 	   if ^af_sw then
      372 	     call ioa_ ("No sst, cannot verify PTWAM.");
      373 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      374 	     code = amu_et_$null_sstp;
      375 	     return;
      376 	     end;
      377 
      378 	dup_entry (*) = "0"b;
      379 
      380 	do i = 0 to nregs - 1;
      381 	     do j = i + 1 to nregs;
      382 		if (ptw_ptrs (i).valid & ptw_ptrs (j).valid) then do;
      383 		     if ptw_regs (i).addr = ptw_regs (j).addr then do;
      384 			dup_entry (i) = "1"b;
      385 			dup_entry (j) = "1"b;
      386 			end;
      387 
      388 		     else if ptw_ptrs (i).usage = ptw_ptrs (j).usage then do;
      389 			if ^DPS8xxM then do;	/* if its not a dps8 */
      390 			     dup_entry (i) = "1"b;
      391 			     dup_entry (j) = "1"b;
      392 			     end;
      393 			end;
      394 
      395 		     else if (ptw_ptrs (i).pointer = ptw_ptrs (j).pointer)
      396 			     & (ptw_ptrs (i).pageno = ptw_ptrs (j).pageno) then do;
      397 			dup_entry (i) = "1"b;
      398 			dup_entry (j) = "1"b;
      399 			end;
      400 
      401 		     if (dup_entry (i) & dup_entry (j)) then do;
      402 			if ptw_regs (i).addr = ptw_regs (j).addr then
      403 			     if ptw_ptrs (i).pointer ^= ptw_ptrs (j).pointer then do;
      404 				if DPS8xxM then go to cancel_dup_ptw;
      405 				if ptw_ptrs (i).usage ^= ptw_ptrs (j).usage then do;
      406 cancel_dup_ptw:
      407 				     dup_entry (i), dup_entry (j) = "0"b;
      408 				     end;
      409 				end;
      410 			end;
      411 
      412 
      413 
      414 		     if (dup_entry (i) & dup_entry (j)) then do;
      415 			found_dup_entry_ptw = "1"b;
      416 			if af_sw then return;
      417 			call ioa_ ("^/Possible duplicate entry in PTW associative memory for CPU;^/");
      418 			call ioa_ (" ADDRESS^3xM^2xF/E USAGE_CT SEG # PAGE");
      419 			reg_ptr = addr (ptw_regs (i));
      420 			ptr_ptr = addr (ptw_ptrs (i));
      421 
      422 			call display_mismatch_ptw (reg_ptr, ptr_ptr);
      423 			reg_ptr = addr (ptw_regs (j));
      424 			ptr_ptr = addr (ptw_ptrs (j));
      425 			call display_mismatch_ptw (reg_ptr, ptr_ptr);
      426 			end;
      427 		     end;
      428 	     end;
      429 	end;
      430 	return;
      431      end verify_am_ptw;
      432 
      433 
      434 verify_am_sdw:
      435      proc;
      436 
      437 
      438 	dup_entry (*) = "0"b;
      439 	found_dup_entry_sdw = "0"b;
      440 	do i = 0 to nregs - 1;
      441 	     do j = i + 1 to nregs;
      442 		if (sdw_ptrs (i).valid & sdw_ptrs (j).valid) then do;
      443 
      444 		     if sdw_regs (i).addr = sdw_regs (j).addr then do;
      445 			dup_entry (i) = "1"b;
      446 			dup_entry (j) = "1"b;
      447 			end;
      448 
      449 		     else if sdw_ptrs (i).pointer = sdw_ptrs (j).pointer then do;
      450 			dup_entry (i) = "1"b;
      451 			dup_entry (j) = "1"b;
      452 		end;
      453 
      454 		     else if sdw_ptrs (i).usage = sdw_ptrs (j).usage then do;
      455 			if ^DPS8xxM then do;	/* if its not a dps8 */
      456 			     dup_entry (i) = "1"b;	/* for dps8 it is LRU not usage ctr */
      457 			     dup_entry (j) = "1"b;
      458 			     end;
      459 			end;
      460 
      461 
      462 		     if (dup_entry (i) & dup_entry (j)) then do;
      463 			if sdw_regs (i).addr = sdw_regs (j).addr then
      464 			     if sdw_regs (i).bound = sdw_regs (j).bound then
      465 				if (sdw_regs (i).r2 & sdw_regs (i).r3) ^= (sdw_regs (j).r2 & sdw_regs (j).r3) then
      466 				     if sdw_ptrs (i).pointer ^= sdw_ptrs (j).pointer then do;
      467 					if DPS8xxM then go to cancel_dup_sdw;
      468 					if sdw_ptrs (i).usage ^= sdw_ptrs (j).usage then do;
      469 cancel_dup_sdw:
      470 					     dup_entry (i), dup_entry (j) = "0"b;
      471 					     end;
      472 					end;
      473 			end;
      474 
      475 
      476 		     if (dup_entry (i) & dup_entry (j)) then do;
      477 			found_dup_entry_sdw = "1"b;
      478 			if af_sw then return;
      479 			call ioa_ ("^/Possible duplicate entry in SDW associative memory for CPU;^/");
      480 			call ioa_ (" ADDRESS^2xRINGS^2xBOUND^2xREWPUGC^4xCL F/E USAGE-CT SEG # SEG_NAME");
      481 			reg_ptr = addr (sdw_regs (i));
      482 			ptr_ptr = addr (sdw_ptrs (i));
      483 			call display_mismatch_sdw (reg_ptr, ptr_ptr);
      484 			reg_ptr = addr (sdw_regs (j));
      485 			ptr_ptr = addr (sdw_ptrs (j));
      486 			call display_mismatch_sdw (reg_ptr, ptr_ptr);
      487 			end;
      488 		     end;
      489 	     end;
      490 	end;
      491 	return;
      492      end verify_am_sdw;
      493 
  1     1 /*	BEGIN INCLUDE FILE amu_fdump_info.incl.pl1	*/
  1     2 
  1     3 dcl 1 fdump_info aligned based (amu_info.fdump_info_ptr),
  1     4     2 version char (8),
  1     5     2 ref_count fixed bin,				/* number of initiations */
  1     6 
  1     7     2 erf_name char (32),				/* ERF name for this dump */
  1     8     2 dump_dname char (168),				/* location of the dump */
  1     9     2 dump_ename char (32),				/* ename of component zero */
  1    10     2 system_id char (8),				/* the system_id of this erf */
  1    11     2 version_id char (8),				/* the version id of this erf */
  1    12     2 dump_seg_0_uid bit (36) aligned,			/* for determining EQ-ness and gullibility checking */
  1    13 
  1    14     2 n_dump_segs fixed bin,				/* number of real segs in the dump */
  1    15     2 copy_block_ptr pointer, 			/* pointer to chain of temp segment blocks */
  1    16 
  1    17     2 dump_seg_ptr (0:31) pointer,			/* pointer and length arrays */
  1    18     2 dump_seg_lth (0:31) fixed bin (18),
  1    19 
  1    20     2 fdump_process_table_ptr pointer;			/* pointer to array describing processes */
  1    21 
  1    22 
  1    23 dcl 1 fdump_process_table aligned based (fdump_info.fdump_process_table_ptr),
  1    24     2 size fixed bin,				/* number of entries */
  1    25 
  1    26     2 array (0:alloc_fdump_process_table_size - 1 refer (fdump_process_table.size)) like fp_table;
  1    27 
  1    28 dcl 1 fp_table based (fp_table_ptr),
  1    29       2 first_seg fixed bin,
  1    30       2 last_seg fixed bin,
  1    31       2 process_info_ptr pointer unaligned,		/* pointer to process_info structure, if filled in */
  1    32       2 dmp_seg_indx fixed bin,			/* dump seg index where process can be found */
  1    33       2 dmp_seg_offset fixed bin (24),			/* offset in the segment refered to by dmp_seg_indx where process starts */
  1    34       2 cpu_name char (1),
  1    35       2 dbr fixed bin (24),				/* address portion of DBR */
  1    36       2 apte_offset fixed bin (18);
  1    37 
  1    38 dcl fp_table_ptr ptr;
  1    39 
  1    40 dcl  alloc_fdump_process_table_size fixed bin;
  1    41 
  1    42 dcl  AMU_FDUMP_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_erf1");
  1    43 dcl  AMU_FDUMP_INFO_VERSION char (8) internal static options (constant) init ("amu_erf1");
  1    44 
  1    45 /*	END INCLUDE FILE amu_fdump_info.incl.pl1	*/
      494 
      495 
  2     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  2     2 
  2     3 /* This structure contains information about the hardcore supervisor address
  2     4*   space for an address translation. */
  2     5 
  2     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  2     7 
  2     8     2 pointers,					/* assorted pointers to various useful items */
  2     9       3 slt aligned,				/* SLT */
  2    10         4 fptr pointer unaligned,			/* address in foreign address space */
  2    11         4 lptr pointer unaligned,			/* location in local address space */
  2    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  2    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  2    14 
  2    15       3 sst aligned like hardcore_info.slt,		/* SST */
  2    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  2    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  2    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  2    19 
  2    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  2    21       3 prds fixed bin (15),				/* segno of PRDS */
  2    22       3 dseg fixed bin (15),				/* DSEG */
  2    23       3 pds fixed bin (15),				/* PDS */
  2    24       3 kst fixed bin (15),				/* KST */
  2    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  2    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  2    27 
  2    28     2 apt,					/* information about the APT */
  2    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  2    30       3 local_ptr pointer unaligned,
  2    31       3 count fixed bin,				/* number of APTEs */
  2    32       3 size fixed bin,				/* size of a single APTE */
  2    33 
  2    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  2    35 
  2    36     2 pad1 fixed bin;
  2    37 
  2    38 dcl hardcore_cur_ptr ptr;
  2    39 
  2    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  2    41     2 sltp ptr,
  2    42     2 sltntp ptr,
  2    43     2 defp ptr,
  2    44     2 sstp ptr,
  2    45     2 tc_datap ptr,
  2    46     2 sstntp ptr,
  2    47     2 uptp ptr;
  2    48 	
  2    49     
  2    50 
  2    51 
  2    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      496 
      497 
  3     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  3     2 
  3     3 dcl 1 amu_info aligned based (amu_info_ptr),
  3     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  3     5     2 flags aligned,
  3     6       3 early_dump bit(1) unal,
  3     7       3 pad  bit(35) unal,
  3     8     2 type fixed bin unal,				/* One of the types below */
  3     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  3    10     2 chain,					/* a chain of all the amu_info's which exist */
  3    11       3 prev pointer unaligned,
  3    12       3 next pointer unaligned,
  3    13 
  3    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  3    15 
  3    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  3    17 						/*   SEE: amu_translation.incl.pl1 */
  3    18     2 fdump_info_ptr pointer, 			
  3    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  3    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  3    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  3    22 						/* See: amu_old_uid_table			*/
  3    23 	
  3    24 
  3    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  3    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  3    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  3    28 						/*   SEE: amu_copy_info.incl.pl1 */
  3    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  3    30 						/*   SEE: amu_process_info.incl.pl1 */
  3    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  3    32 
  3    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  3    34 
  3    35     2 error_info,					/* various info about how amu_error_ is to behave */
  3    36       3 error_flags aligned,
  3    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  3    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  3    39         4 pad bit (34) unaligned,
  3    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  3    41     2 definitions_info_ptr ptr;
  3    42 
  3    43 dcl  amu_area area based (amu_info.area_ptr);
  3    44 
  3    45 dcl  amu_info_ptr pointer;
  3    46 
  3    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  3    48      FDUMP_PROCESS_TYPE	init (1038),
  3    49      ONLINE_TYPE		init (1039),
  3    50      ONLINE_PROCESS_TYPE	init (1040),
  3    51      NETWORK_FDUMP_TYPE	init (1041),
  3    52      NETWORK_ONLINE_TYPE	init (1042),
  3    53      SAVED_PROC_TYPE	init (1043),
  3    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  3    55 
  3    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  3    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  3    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  3    59 
  3    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  3    61 
  3    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      498 
      499 
  4     1 
  4     2 /* BEGIN INCLUDE FILE ... assoc_mem.incl.pl1 ... Last modified 1 March 1973 */
  4     3 
  4     4 dcl 1 amptwreg aligned based,				/* Associative Memory page table word register */
  4     5    (2 addr bit (18),				/* upper 18 bits of 24 bit core address of page */
  4     6     2 pad1 bit (11),
  4     7     2 modif bit (1),				/* page has been modified bit */
  4     8     2 pad2 bit (6)) unaligned;
  4     9 
  4    10 
  4    11 dcl 1 amptwptr aligned based,				/* Associative Memory page table word pointer */
  4    12    (2 pointer bit (15),				/* effective segment number */
  4    13     2 pageno bit (12),				/* page number to which this ptw refers */
  4    14     2 valid bit (1),				/* 1 => this register contains valid information */
  4    15     2 amptwptr_pad bit (4),
  4    16     2 usage bit (4)) unaligned;			/* relative usage, "1111"b is most recent */
  4    17 
  4    18 
  4    19 dcl 1 amsdwreg aligned based,				/* Associative Memory segment descriptor word register */
  4    20    (2 addr bit (24),				/* core address of page table or segment */
  4    21     2 r1 bit (3),					/* read/write ring bracket */
  4    22     2 r2 bit (3),					/* read/execute bracket */
  4    23     2 r3 bit (3),					/* call bracket  */
  4    24     2 pad1 bit (3),
  4    25 
  4    26     2 pad2 bit (1),
  4    27     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  4    28     2 read bit (1),					/* read permission bit */
  4    29     2 execute bit (1),				/* execute permission bit */
  4    30     2 write bit (1),				/* write permission bit */
  4    31     2 privileged bit (1),				/* privileged mode bit */
  4    32     2 unpaged bit (1),				/* 1 =>  addr is base address of segment */
  4    33     2 entry_bound_sw bit (1),				/* 0 => cl is checked by hardware */
  4    34     2 cache bit (1),				/* segment is encacheable */
  4    35     2 cl bit (14)) unaligned;				/* entry bound */
  4    36 
  4    37 
  4    38 dcl 1 amsdwptr aligned based,				/* Associative Memory segment descriptor word pointer */
  4    39    (2 pointer bit (15),				/* effective segment number */
  4    40     2 pad1 bit (12),
  4    41     2 valid bit (1),				/* 1 => this register contains valid information */
  4    42     2 pad2 bit (4),
  4    43     2 usage bit (4)) unaligned;			/* relative usage,."1111"b is most recently used */
  4    44 
  4    45 /* END INCLUDE FILE ... assoc_mem.incl.pl1 ... */
      500 
      501 
  5     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  5     2 
  5     3 /* Template for an AST entry. Length = 12 words. */
  5     4 
  5     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  5     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  5     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  5     8 
  5     9 dcl  astep ptr;
  5    10 
  5    11 dcl 1 aste based (astep) aligned,
  5    12 
  5    13     (2 fp bit (18),					/* forward  used list rel pointer */
  5    14     2 bp bit (18),					/* backward used list rel pointer */
  5    15 
  5    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  5    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  5    18 
  5    19     2 strp bit (18),				/* rel pointer to process trailer */
  5    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  5    21 
  5    22     2 uid bit (36),					/* segment unique id */
  5    23 
  5    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  5    25     2 pvtx fixed bin (8),				/* physical volume table index */
  5    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  5    27 
  5    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  5    29     2 init bit (1),					/* used bit - insure 1 lap */
  5    30     2 gtus bit (1),					/* global transparent usage switch */
  5    31     2 gtms bit (1),					/* global transparent modified switch */
  5    32     2 hc bit (1),					/* hard core segment */
  5    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  5    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  5    35     2 write_access_on bit (1),			/* any sdw allows write access */
  5    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  5    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  5    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  5    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  5    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  5    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  5    42     2 pad1 bit (2),					/* OO */
  5    43     2 dius bit (1),					/* dumper in use switch */
  5    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  5    45     2 dmpr_pad bit (1),
  5    46     2 ehs bit (1),					/* entry hold switch */
  5    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  5    48     2 dirsw bit (1),				/* directory switch */
  5    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  5    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  5    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  5    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  5    53 
  5    54     2 dtu bit (36),					/* date and time segment last used */
  5    55 
  5    56     2 dtm bit (36),					/* date and time segment last modified */
  5    57 
  5    58 
  5    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  5    60 
  5    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  5    62 
  5    63     2 csl bit (9),					/* current segment length in 1024 words units */
  5    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  5    65     2 fms bit (1),					/* file modified switch */
  5    66     2 npfs bit (1),					/* no page fault switch */
  5    67     2 gtpd bit (1),					/* global transparent paging device switch */
  5    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  5    69     2 per_process bit (1),				/* use master quota for this entry */
  5    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  5    71     2 pad2 bit (2),
  5    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  5    73     2 np bit (9),					/* number of pages in core */
  5    74 
  5    75 
  5    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  5    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  5    78     2 damaged bit (1),				/* PC declared segment unusable */
  5    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  5    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  5    81     2 pad3 bit (6),					/* OOOOOOOOO */
  5    82     2 ptsi bit (2),					/* page table size index */
  5    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  5    84 
  5    85 
  5    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  5    87 
  5    88 
  5    89 dcl 1 aste_part aligned based (astep),
  5    90 
  5    91     2 one bit (36) unaligned,				/* fp and bp */
  5    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  5    93     2 three bit (8) unaligned;			/* ptsi and marker */
  5    94 
  5    95 
  5    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  5    97     2 pad1 bit (8*36),
  5    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  5    99     2 pad2 bit (3*36);
  5   100 
  5   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      502 
      503 
  6     1 /* BEGIN INCLUDE FILE ... bos_dump.incl.pl1 ... */
  6     2 /* Modified 1 September 1976 */
  6     3 /* Modified 11/11/80 by J. A. Bush for the DPS8/70M CPU */
  6     4 /* Modified 6/12/81 by Rich Coppola to extend the dps8 extended fault reg to 
  6     5*   15 bits  */
  6     6 /* Modified 02/23/81, W. Olin Sibert, to describe old and new FDUMP styles */
  6     7 
  6     8 
  6     9 dcl  dumpptr ptr;					/* pointer to following structure */
  6    10 
  6    11 dcl 1 dump based (dumpptr) aligned,			/* header of dump by fdump */
  6    12     2 dump_header aligned like dump_header,
  6    13 
  6    14     2 segs (1008),					/* segment array */
  6    15       3 segno bit (18) unal,				/* segment number */
  6    16       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  6    17 
  6    18     2 amptwregs (0 : 63) bit (36),			/* assoc. mem. page table word regs */
  6    19     2 amptwptrs (0 : 63) bit (36),			/* assoc. mem. page table word pointers */
  6    20     2 amsdwregs (0 : 63) bit (72),			/* assoc. mem. segment descriptor word registers */
  6    21     2 amsdwptrs (0 : 63) bit (36),			/* assoc. mem. segment descriptor word pointers */
  6    22 
  6    23     2 ouhist (0 : 63) bit (72), 			/* operations unit history registers */
  6    24     2 cuhist (0 : 63) bit (72), 			/* control unit history registers */
  6    25     2 duhist (0 : 63) bit (72), 			/* decimal unit history registers */
  6    26     2 auhist (0 : 63) bit (72), 			/* appending unit history registers */
  6    27 
  6    28     2 prs (0 : 7) ptr,				/* pointer registers */
  6    29 
  6    30     2 regs aligned like dump_registers, 		/* assorted machine registers */
  6    31 
  6    32     2 low_order_port bit (3), 			/* from which clock is read */
  6    33     2 pad4 bit (36),
  6    34     2 mctime fixed bin (52),				/* time conditions were taken */
  6    35     2 pad5 (0 : 3) bit (36),
  6    36 
  6    37     2 misc_registers like dump_misc_registers,		/* Assorted registers & processor data */
  6    38 
  6    39     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  6    40 
  6    41     2 coreblocks (0 : 7),
  6    42       3 num_first bit (18) unal,			/* first addr in coreblock */
  6    43       3 num_blocks bit (18) unal,			/* number of blocks used */
  6    44     2 pad7 (112) fixed bin;
  6    45 
  6    46 
  6    47 dcl 1 dump_header aligned based,			/* Standard header for FDUMP */
  6    48     2 words_dumped fixed bin (35),			/* total words in dump */
  6    49     2 valid bit (1),				/* = 1 if there is a 6180 dump to be had */
  6    50     2 time fixed bin (71),				/* time of dump */
  6    51     2 erfno fixed bin (18),				/* Error Report Form Number */
  6    52     2 num_segs fixed bin,				/* number of segments dumped */
  6    53     2 valid_355 bit (1),				/* = 1 if there is a dn355 dump to be had */
  6    54     2 dumped_355s bit (4),				/* indicates which 355s were dumped */
  6    55     2 time_355 fixed bin (71),			/* time of 355 dump */
  6    56     2 version fixed bin,				/* currently 2 */
  6    57     2 pad0 (5) fixed bin;				/* pad0 to 16 words */
  6    58 
  6    59 dcl 1 dump_registers aligned based,			/* Standard (SREG) arrangement of registers in dump */
  6    60    (2 x (0 : 7) bit (18),				/* index registers */
  6    61     2 a bit (36),					/* the a register */
  6    62     2 q bit (36),					/* the q register */
  6    63     2 e bit (8),					/* the e register */
  6    64     2 pad2 bit (28),				/* pad */
  6    65     2 t bit (27),					/* timer register */
  6    66     2 pad3 bit (6), 				/* pad */
  6    67     2 ralr bit (3)) unaligned;			/* ring alarm register */
  6    68 
  6    69 dcl 1 dump_misc_registers aligned based,
  6    70     2 scu (0 : 7) bit (36),				/* from store control unit instr. */
  6    71     2 mcm (0 : 7) bit (72),				/* memory controller masks every 64 K */
  6    72     2 dbr bit (72), 				/* descriptor segment base register */
  6    73     2 intrpts bit (36),				/* interrupts */
  6    74     2 bar bit (36), 				/* base address register */
  6    75     2 modereg bit (36),				/* mode register */
  6    76     2 cmodereg bit (36),				/* cache mode register */
  6    77     2 faultreg bit (36),				/* fault register */
  6    78     2 ext_fault_reg bit (15) unaligned,			/* DPS8 extended fault register */
  6    79     2 pad6 bit (21) unaligned;
  6    80     
  6    81     
  6    82 
  6    83 dcl 1 v1_dump aligned based (dumpptr),			/* Old version of FDUMP (pre March, 1981) */
  6    84     2 dump_header aligned like dump_header,
  6    85 
  6    86     2 segs (688),					/* segment array */
  6    87       3 segno bit (18) unal,				/* segment number */
  6    88       3 length bit (18) unal, 			/* length of segment in sector sized blocks */
  6    89 
  6    90     2 amsdwregs (0 : 15) bit (72),			/* assoc. mem. segment descriptor word registers */
  6    91     2 amsdwptrs (0 : 15) bit (36),			/* assoc. mem. segment descriptor word pointers */
  6    92     2 amptwregs (0 : 15) bit (36),			/* assoc. mem. page table word regs */
  6    93     2 amptwptrs (0 : 15) bit (36),			/* assoc. mem. page table word pointers */
  6    94     2 pad1 (0 : 15) bit (36),
  6    95 
  6    96     2 ouhist (0 : 15) bit (72), 			/* operations unit history registers */
  6    97     2 cuhist (0 : 15) bit (72), 			/* control unit history registers */
  6    98     2 auhist (0 : 15) bit (72), 			/* appending unit history registers */
  6    99     2 duhist (0 : 15) bit (72), 			/* decimal unit history registers */
  6   100 
  6   101     2 prs (0 : 7) ptr,				/* pointer registers */
  6   102 
  6   103     2 regs aligned like dump_registers, 		/* assorted machine registers */
  6   104 
  6   105     2 mctime fixed bin (52),				/* time conditions were taken */
  6   106     2 pad4 (0 : 5) bit (36),
  6   107 
  6   108     2 misc_registers aligned like dump_misc_registers,	/* Assorted registers */
  6   109 
  6   110     2 pad5 bit (36),
  6   111     2 ptrlen (0 : 7) bit (36),			/* pointers and lengths for EIS */
  6   112     2 pad6 (15) bit (36),
  6   113     2 low_order_port bit (3), 			/* from which clock was read */
  6   114 
  6   115     2 coreblocks (0 : 7),
  6   116       3 num_first bit (18) unal,			/* first addr in coreblock */
  6   117       3 num_blocks bit (18) unal;			/* number of blocks used */
  6   118 
  6   119 
  6   120 dcl  DUMP_VERSION_1 fixed bin internal static options (constant) init (1);
  6   121 dcl  DUMP_VERSION_2 fixed bin internal static options (constant) init (2);
  6   122 
  6   123 /* END INCLUDE FILE ... bos_dump.incl.pl1 ... */
      504 
      505 
  7     1 /* BEGIN INCLUDE FILE  ptw.incl.pl1  ---  09/13/74 for nss */
  7     2 
  7     3 dcl  ptp ptr;					/* pointer to either page table or page table word */
  7     4 
  7     5 dcl 1 ptw based (ptp) aligned,			/* page table word */
  7     6 
  7     7     (2 add bit (18),				/* address of page, type of which is defined by add_type */
  7     8     2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  7     9     2 first bit (1),				/* the page has not yet been written out */
  7    10     2 processed bit (1),				/* temporary used during post-purging and error signalling */
  7    11     2 pad1 bit (1),
  7    12     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  7    13     2 phu bit (1),					/* page has been used bit */
  7    14     2 phm1 bit (1),					/* Cumulative OR of hardware phm's */
  7    15     2 nypd bit (1),					/* must be moved to paging device */
  7    16     2 phm bit (1),					/* page has been modified bit */
  7    17     2 phu1 bit (1),					/* page has been used in the quantum */
  7    18     2 wired bit (1),				/* page is to remain in core */
  7    19     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  7    20     2 df bit (1),					/* directed fault if this is 0 (page not in core) */
  7    21     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  7    22 
  7    23 dcl 1 ptwa (0:255) based (ptp) aligned like ptw;		/* page table */
  7    24 
  7    25 dcl  ptwa_bits (0:255) based (ptp) bit (36) aligned;	/* page table array as raw bits */
  7    26 
  7    27 dcl 1 mptw based (ptp) aligned,			/* page table word while page is not in core */
  7    28     2 devadd bit (22) unaligned,			/* device address where page resides */
  7    29     2 pad bit (14) unaligned;
  7    30 
  7    31 dcl 1 mptwa (0 : 1) based (ptp) aligned,		/* page table while pages are not in core */
  7    32     2 devadd bit (22) unaligned,			/* device address where page resides */
  7    33     2 pad bit (14) unaligned;
  7    34 
  7    35 dcl 1 atptw based (ptp) aligned,			/* PL/I has problems on overlay-def based */
  7    36     2 add bit (18) unal,
  7    37     2 (core, disk, pd, reserved) bit (1) unal,		/* address types */
  7    38     2 pad bit (14) unal;
  7    39 
  7    40 dcl 1 atptwa (0:255) based (ptp) aligned like atptw;
  7    41 
  7    42 /* END INCLUDE FILE  ptw.incl.pl1 */
      506 
      507 
  8     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  8     2 
  8     3 dcl  sdwp ptr;
  8     4 
  8     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  8     6 
  8     7    (2 add bit (24),					/* main memory address of page table */
  8     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  8     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  8    10     2 df_no bit (2),				/* directed fault number */
  8    11 
  8    12     2 pad1 bit (1),
  8    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  8    14     2 access,					/* access bits */
  8    15       3 read bit (1),				/* read permission bit */
  8    16       3 execute bit (1),				/* execute permission bit */
  8    17       3 write bit (1),				/* write permission bit */
  8    18       3 privileged bit (1),				/* privileged bit */
  8    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  8    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  8    21     2 cache bit (1),				/* cache enable bit */
  8    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  8    23 
  8    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  8    25 
  8    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      508 
      509 
  9     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  9     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  9     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  9     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  9     5 
  9     6 dcl  sst_seg$ external;
  9     7 dcl  sstp ptr;
  9     8 
  9     9 dcl 1 sst based (sstp) aligned,
  9    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  9    11 
  9    12 /* SST HEADER */
  9    13 
  9    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  9    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  9    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  9    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  9    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  9    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  9    20 
  9    21     2 ptl bit (36),					/* global page table loop lock */
  9    22     2 astl bit (36),				/* global ast allocation block lock */
  9    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  9    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  9    25     2 nused fixed bin,				/* number of pages on used list */
  9    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  9    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  9    28 
  9    29     2 astap ptr,					/* aste array pointer */
  9    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  9    31     2 astsize fixed bin,				/* size of an AST entry */
  9    32     2 cmesize fixed bin,				/* size of a CME entry */
  9    33     2 root_astep ptr,				/* pointer to the root AST entry */
  9    34 
  9    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  9    36     2 level (0:3),					/* per-list information about ASTE's */
  9    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  9    38 
  9    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  9    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  9    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  9    42     2 strsize fixed bin,				/* Trailer size in words. */
  9    43 
  9    44 /* CORE MAP HEADER */
  9    45 
  9    46     2 cmp ptr,					/* pointer to start of core map */
  9    47     2 usedp bit (18),				/* pointer to first used core block */
  9    48     2 wtct fixed bin,				/* count of pages being written */
  9    49 
  9    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  9    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  9    52 						/* MISC */
  9    53 
  9    54     2 double_write fixed bin,				/* trigger for store through scheme */
  9    55 						/* 0 = no double writes,
  9    56*						   1 = all non-pd pages get written,
  9    57*						   2 = all directories get written */
  9    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  9    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  9    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  9    61 
  9    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  9    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  9    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  9    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  9    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  9    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  9    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  9    69 
  9    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  9    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  9    72 
  9    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  9    74 
  9    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  9    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  9    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  9    78 
  9    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  9    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  9    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  9    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  9    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  9    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  9    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  9    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  9    87 
  9    88 
  9    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  9    90 
  9    91     2 steps fixed bin,				/* number of steps taken around used list */
  9    92     2 needc fixed bin,				/* number of times core page needed */
  9    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  9    94     2 ctwait fixed bin,				/* number of times write counter was full */
  9    95     2 wired fixed bin,				/* number of pages wired by pc */
  9    96     2 laps fixed bin,				/* number of times around used list */
  9    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  9    98     2 skipu fixed bin,				/* because of being used */
  9    99 
  9   100     2 skipm fixed bin,				/* because of being modified */
  9   101     2 skipos fixed bin,				/* because out of service */
  9   102     2 aused fixed bin,				/* number of AST entries on used list */
  9   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  9   104     2 deact_count fixed bin,				/* count of deactivations */
  9   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  9   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  9   107 
  9   108     2 reads (8) fixed bin,				/* number of reads for each did */
  9   109     2 writes (8) fixed bin,				/* number of writes for each did */
  9   110 
  9   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  9   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  9   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  9   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  9   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  9   116     2 total_sf fixed bin,				/* total number of seg_faults */
  9   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  9   118     2 post_list_size fixed bin,
  9   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  9   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  9   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  9   122     2 pre_page_list_size fixed bin,
  9   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  9   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  9   125 
  9   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  9   127 
  9   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  9   129 
  9   130 /* MAIN MEMORY USAGE INFORMATION */
  9   131 
  9   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  9   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  9   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  9   135     2 recopies fixed bin,				/* number of times recopied because modified */
  9   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  9   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  9   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  9   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  9   140 
  9   141 /*  AST METERS  */
  9   142 
  9   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  9   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  9   145 
  9   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  9   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  9   148     2 asearches fixed bin,				/* count of full searches made */
  9   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  9   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  9   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  9   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  9   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  9   154 
  9   155     2 alaps fixed bin,				/* lap counter for AST list */
  9   156     2 updates fixed bin,				/* calls to updateb */
  9   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  9   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  9   159     2 total_bf fixed bin,				/* count of bound faults */
  9   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  9   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  9   162 
  9   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  9   164 
  9   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  9   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  9   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  9   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  9   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  9   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  9   171 
  9   172 /* PRE-PAGE METERS */
  9   173 
  9   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  9   175 
  9   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  9   177 
  9   178 
  9   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  9   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  9   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  9   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  9   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  9   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  9   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  9   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  9   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  9   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  9   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  9   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  9   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  9   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  9   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  9   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  9   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  9   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  9   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  9   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  9   199     2 activations fixed bin,				/* total count of activations */
  9   200     2 dir_activations fixed bin,			/* count of directory activations */
  9   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  9   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  9   203     2 evict_recover_data,				/* see evict_page.alm */
  9   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  9   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  9   206 
  9   207 /* Data for metering force_write facility 08/19/78 */
  9   208 
  9   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  9   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  9   211     2 fw_none fixed bin,				/* Force write wrote none */
  9   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  9   213 
  9   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  9   215     2 pf_unlock_ptl_meterings fixed bin,
  9   216 
  9   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  9   218     2 backup_activations fixed bin (35),		/* activations for backup */
  9   219     2 metering_flags aligned,				/* small chunks of misc. information */
  9   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  9   221       3 pad bit (35) unal,
  9   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  9   223 
  9   224 /* METERS FOR STACK TRUNCATION */
  9   225 
  9   226     2 (stk_truncate_should_didnt,			/* counts */
  9   227        stk_truncate_should_did,
  9   228        stk_truncate_shouldnt_didnt,
  9   229        stk_truncate_shouldnt_did) fixed bin (35),
  9   230     2 stk_pages_truncated fixed bin (35),
  9   231     2 stk_pages_truncated_in_core fixed bin (35),
  9   232 
  9   233 /* SUPPORT FOR PC SEGMOVES */
  9   234 
  9   235     2 segmove_lock aligned,
  9   236       3 pid bit (36) aligned,
  9   237       3 event bit (36) aligned,
  9   238       3 notify bit (1) aligned,
  9   239     2 segmove_io_limit fixed bin, /* max read aheads */
  9   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  9   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  9   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  9   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  9   244 
  9   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  9   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  9   247     2 segmove_vtocx fixed bin,			/* ditto */
  9   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  9   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  9   250 
  9   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  9   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  9   253     2 trace_sw aligned,				/* tracing control flags */
  9   254       3 pad_trace bit (32) unaligned,
  9   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  9   256       3 tty_trace bit (1) unaligned,
  9   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  9   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  9   259     2 new_pages fixed bin,				/* newly created pages */
  9   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  9   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  9   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  9   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  9   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  9   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  9   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  9   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  9   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  9   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  9   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  9   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  9   272 
  9   273 /* END INCLUDE FILE sst.incl.pl1 */
      510 
      511 
 10     1 /* BEGIN include file unpaged_page_tables.incl.pl1 */
 10     2 
 10     3 /* This include file describes the segments unpaged_page_tables and
 10     4*int_unpaged_page_tables.  These segments contain the page tables for
 10     5*segments that are paged and wired, those segments previously called
 10     6*unpaged.
 10     7*
 10     8*Written September 15, 1983 by Keith Loepere. */
 10     9 
 10    10 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
 10    11 
 10    12 dcl  upt_ptr		        ptr;
 10    13 dcl  1 upt		        aligned based (upt_ptr),
 10    14        2 sst_absloc		        fixed bin (26),	/* for dump analyzers */
 10    15        2 sst_last_loc	        fixed bin (26),
 10    16        2 upt_absloc		        fixed bin (26),
 10    17        2 upt_last_loc	        fixed bin (26),
 10    18        2 iupt_absloc	        fixed bin (26),
 10    19        2 iupt_last_loc	        fixed bin (26),
 10    20 
 10    21        2 current_length	        fixed bin,		/* number of words currently used */
 10    22        2 max_length		        fixed bin,		/* max number of words in memory allocated */
 10    23        2 first_entry	        like upt_entry;
 10    24 
 10    25 dcl  upt_entry_ptr		        ptr;
 10    26 dcl  1 upt_entry		        aligned based (upt_entry_ptr),
 10    27        2 size		        fixed bin,		/* number of page table words allocated */
 10    28        2 segno		        fixed bin,		/* of hardcore segment */
 10    29        2 ptws		        (0 refer (upt_entry.size)) bit (36) aligned;
 10    30 
 10    31 /* END include file unpaged_page_tables.incl.pl1 */
      512 
      513 
      514      end azm_verify_dump_ams_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/28/87  0930.0  azm_verify_dump_ams_.pl1          >spec>install>MR12.1-1049>azm_verify_dump_ams_.pl1
494          1    09/22/83  1102.5  amu_fdump_info.incl.pl1           >ldd>include>amu_fdump_info.incl.pl1
496          2    11/20/84  0854.8  amu_hardcore_info.incl.pl1        >ldd>include>amu_hardcore_info.incl.pl1
498          3    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
500          4    08/12/81  2025.7  assoc_mem.incl.pl1                >ldd>include>assoc_mem.incl.pl1
502          5    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
504          6    08/12/81  2025.8  bos_dump.incl.pl1                 >ldd>include>bos_dump.incl.pl1
506          7    05/03/78  1422.1  ptw.incl.pl1                      >ldd>include>ptw.incl.pl1
508          8    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
510          9    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
512         10    07/11/84  0937.3  unpaged_page_tables.incl.pl1      >ldd>include>unpaged_page_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DPS8xxM                         000110 automatic       bit(1)                   unaligned dcl 47 set ref 220 245 357* 361* 389 404
                                                                                  455 467
P_amu_info_ptr                         parameter       pointer                  dcl 33 ref 18 96 322
P_code                                 parameter       fixed bin(35,0)          dcl 37 set ref 18 96 173* 323* 350*
RETURN_VAL                      000111 automatic       bit(1)                   initial unaligned dcl 48 set ref 48* 162* 169* 174
a_ptp                                  parameter       pointer                  dcl 262 ref 259 271 271 271
a_ptw_ptr                              based           structure                level 1 dcl 217
a_ptw_ptr_ptr                          parameter       pointer                  dcl 215 ref 213 220 220 223 225 225 225 225 225
a_ptw_reg                              based           structure                level 1 dcl 216
a_ptw_reg_ptr                          parameter       pointer                  dcl 215 ref 213 225 225 225
a_sdw_ptr                              based           structure                level 1 dcl 236
a_sdw_ptr_ptr                          parameter       pointer                  dcl 234 ref 232 245 245 248 250 250 250
a_sdw_reg                              based           structure                level 1 dcl 235
a_sdw_reg_ptr                          parameter       pointer                  dcl 234 ref 232 240 240 240 240 240 240 240 250 250
                                                                                  250 250 250 250 250 250 250 250 250
add                                    based           bit(24)                  level 2 packed unaligned dcl 8-5 ref 294 296
addr                                   based           bit(18)                  array level 2 in structure "ptw_regs" packed
                                                                                  unaligned dcl 67 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 383 383 402 402
addr                                   based           bit(24)                  level 2 in structure "a_sdw_reg" packed unaligned
                                                                                  dcl 235 in procedure "display_mismatch_sdw" ref
                                                                                  250 250
addr                                                   builtin function         dcl 89 in procedure "azm_verify_dump_ams_" ref 116
                                                                                  122 123 139 142 149 150 327 328 329 330 339 419
                                                                                  420 423 424 481 482 484 485
addr                                   based           bit(24)                  level 2 in structure "dseg_ent" packed unaligned
                                                                                  dcl 183 in procedure "display_dseg_entry" ref 206
                                                                                  206
addr                                   based           bit(18)                  level 2 in structure "a_ptw_reg" packed unaligned
                                                                                  dcl 216 in procedure "display_mismatch_ptw" ref
                                                                                  225 225
addr                                   based           bit(24)                  array level 2 in structure "sdw_regs" packed
                                                                                  unaligned dcl 65 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 444 444 463 463
addr                                   based           bit(18)                  level 2 in structure "page_wd" packed unaligned
                                                                                  dcl 263 in procedure "display_sst_entry" ref 271
                                                                                  271
addrel                                                 builtin function         dcl 89 ref 115 141 302 308 314 354
af_sw                           000104 automatic       bit(1)                   initial unaligned dcl 43 set ref 43* 98* 119 146 166
                                                                                  174 347 371 416 478
amptwptr                               based           structure                level 1 dcl 4-11
amptwptrs              2100            based           bit(36)                  array level 2 dcl 6-11 set ref 328
amptwreg                               based           structure                level 1 dcl 4-4
amptwregs              2000            based           bit(36)                  array level 2 dcl 6-11 set ref 327
amsdwptr                               based           structure                level 1 dcl 4-38
amsdwptrs              2400            based           bit(36)                  array level 2 dcl 6-11 set ref 330
amsdwreg                               based           structure                level 1 dcl 4-19
amsdwregs              2200            based           bit(72)                  array level 2 dcl 6-11 set ref 329
amu_$do_translation_hunt_ptr    000026 constant        entry                    external dcl 85 ref 344
amu_$fdump_mpt_revert_idx       000020 constant        entry                    external dcl 82 ref 103 171 349 373
amu_$fdump_mpt_temp_change_idx  000016 constant        entry                    external dcl 81 ref 337
amu_$hardcore_info_set_cur_ptrs 000022 constant        entry                    external dcl 83 ref 340
amu_$return_val_idx_from_dbr    000024 constant        entry                    external dcl 84 ref 331
amu_et_$npdx_dbr                000030 external static fixed bin(35,0)          dcl 86 ref 333
amu_et_$null_sstp               000014 external static fixed bin(35,0)          dcl 80 ref 374
amu_info                               based           structure                level 1 dcl 3-3
amu_info_ptr                    000206 automatic       pointer                  dcl 3-45 set ref 103* 171* 322* 325 331* 337* 340*
                                                                                  344* 344 344 349* 373*
any_other                       000176 stack reference condition                dcl 88 ref 100
atptw                                  based           structure                level 1 dcl 7-35
baseptr                                                builtin function         dcl 89 ref 344 344
bin                                                    builtin function         dcl 89 ref 115 139
binary                                                 builtin function         dcl 89 ref 141 206 206 206 206 206 206 220 220 225
                                                                                  225 225 225 225 225 245 245 250 250 250 250 250
                                                                                  250 250 250 271 271
bound                     1(01)        based           bit(14)                  level 2 in structure "a_sdw_reg" packed unaligned
                                                                                  dcl 235 in procedure "display_mismatch_sdw" ref
                                                                                  250 250
bound                     1(01)        based           bit(14)                  array level 2 in structure "sdw_regs" packed
                                                                                  unaligned dcl 65 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 463 463
bounds                    1(01)        based           bit(14)                  level 2 packed unaligned dcl 183 ref 206 206
cache                     1(21)        based           bit(1)                   level 2 in structure "a_sdw_reg" packed unaligned
                                                                                  dcl 235 in procedure "display_mismatch_sdw" set
                                                                                  ref 240*
cache                     1(21)        based           bit(1)                   level 2 in structure "dseg_ent" packed unaligned
                                                                                  dcl 183 in procedure "display_dseg_entry" set ref
                                                                                  202*
changed_process_idx             000116 automatic       bit(1)                   initial unaligned dcl 51 set ref 51* 103 104* 171
                                                                                  338*
cl                        1(22)        based           bit(14)                  level 2 in structure "a_sdw_reg" packed unaligned
                                                                                  dcl 235 in procedure "display_mismatch_sdw" ref
                                                                                  250 250
cl                        1(22)        based           bit(14)                  level 2 in structure "dseg_ent" packed unaligned
                                                                                  dcl 183 in procedure "display_dseg_entry" ref 206
                                                                                  206
code                            000107 automatic       fixed bin(35,0)          dcl 46 set ref 109 173 323* 333* 344* 346 350 374*
dbr                    3570            based           bit(72)                  level 3 dcl 6-11 ref 326
divide                                                 builtin function         dcl 89 ref 141 225 225
do_ptws                                parameter       bit(1)                   unaligned dcl 36 set ref 18 96 132 166 166*
do_sdws                                parameter       bit(1)                   unaligned dcl 36 set ref 18 96 111 166* 166
dseg                     17            based           fixed bin(15,0)          level 3 dcl 2-6 ref 344 344
dseg_ent                               based           structure                level 1 packed unaligned dcl 183
dseg_entp                              parameter       pointer                  dcl 181 ref 179 202 202 202 202 202 202 202 206 206
                                                                                  206 206 206 206 206 206 206 206 206
dsegp                           000152 automatic       pointer                  dcl 57 set ref 115 139 344*
dump                                   based           structure                level 1 dcl 6-11
dump_dbr                        000106 automatic       fixed bin(24,0)          dcl 45 set ref 326* 331* 347*
dump_header                            based           structure                level 1 dcl 6-47
dump_misc_registers                    based           structure                level 1 dcl 6-69
dump_registers                         based           structure                level 1 dcl 6-59
dump_seg_ptr            106            based           pointer                  array level 2 dcl 1-3 ref 325
dumpptr                         000210 automatic       pointer                  dcl 6-9 set ref 325* 326 327 328 329 330
dup_entry                       000122 automatic       bit(1)                   array unaligned dcl 54 set ref 378* 384* 385* 390*
                                                                                  391* 397* 398* 401 401 406* 406* 414 414 438* 445*
                                                                                  446* 450* 451* 456* 457* 462 462 469* 469* 476 476
ebs                       1(20)        based           bit(1)                   level 2 packed unaligned dcl 183 set ref 202* 206
entry_bound_sw            1(20)        based           bit(1)                   level 2 packed unaligned dcl 235 set ref 240* 250
ex                        1(16)        based           bit(1)                   level 2 packed unaligned dcl 183 set ref 202* 206
execute                   1(16)        based           bit(1)                   level 2 packed unaligned dcl 235 set ref 240* 250
fdump_info                             based           structure                level 1 dcl 1-3
fdump_info_ptr           14            based           pointer                  level 2 dcl 3-3 ref 325
fixed                                                  builtin function         dcl 89 ref 294 296 296 326
flag_string                     000234 automatic       char(7)                  unaligned dcl 182 in procedure "display_dseg_entry"
                                                                                  set ref 202* 206*
flag_string                     000154 automatic       char(7)                  unaligned dcl 58 in procedure "azm_verify_dump_ams_"
                                                                                  set ref 240* 250*
found_dup_entry_ptw             000115 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 159 415*
found_dup_entry_sdw             000114 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 159 439* 477*
found_mismatch_ptw              000113 automatic       bit(1)                   initial unaligned dcl 49 set ref 49* 145* 159
found_mismatch_sdw              000112 automatic       bit(1)                   initial unaligned dcl 49 set ref 49* 118* 159
fp_table                               based           structure                level 1 unaligned dcl 1-28
hard_ptr_space                  000160 automatic       structure                level 1 unaligned dcl 60 set ref 339
hardcore_cur                           based           structure                level 1 unaligned dcl 2-40
hardcore_cur_ptr                000204 automatic       pointer                  dcl 2-38 set ref 339* 340* 341 342
hardcore_info                          based           structure                level 1 dcl 2-6
hardcore_info_ptr        16            based           pointer                  level 2 dcl 3-3 ref 344 344
i                               000100 automatic       fixed bin(17,0)          dcl 42 set ref 380* 381 382 383 384 388 390 395 395
                                                                                  397 401 402 402 405 406 414 419 420* 440* 441 442
                                                                                  444 445 449 450 454 456 462 463 463 463 463 463
                                                                                  468 469 476 481 482*
idx                             000102 automatic       fixed bin(17,0)          dcl 42 set ref 113* 114 115 116 122 123* 137* 138
                                                                                  139 141 142 149 150*
ioa_                            000010 constant        entry                    external dcl 78 ref 120 121 147 148 166 206 225 250
                                                                                  271 347 371 417 418 479 480
ioa_$rsnnl                      000012 constant        entry                    external dcl 79 ref 202 220 223 240 245 248
iupt_absloc               4            based           fixed bin(26,0)          level 2 dcl 10-13 ref 305 307
iupt_last_loc             5            based           fixed bin(26,0)          level 2 dcl 10-13 ref 305
j                               000101 automatic       fixed bin(17,0)          dcl 42 set ref 381* 382 383 385 388 391 395 395 398
                                                                                  401 402 402 405 406 414 423 424* 441* 442 444 446
                                                                                  449 451 454 457 462 463 463 463 463 463 468 469
                                                                                  476 484 485*
last_three_sets                        based           bit(1728)                unaligned dcl 64 ref 355
misc_registers         3540            based           structure                level 2 dcl 6-11
modif                     0(29)        based           bit(1)                   level 2 packed unaligned dcl 216 set ref 225*
modifd                    0(29)        based           bit(1)                   level 2 packed unaligned dcl 263 set ref 271*
nregs                           000105 automatic       fixed bin(17,0)          dcl 44 set ref 113 137 356* 360* 380 381 440 441
null                                                   builtin function         dcl 89 ref 296 370
page_wd                                based           structure                level 1 packed unaligned dcl 263
pageno                    0(15)        based           bit(12)                  level 2 in structure "a_ptw_ptr" packed unaligned
                                                                                  dcl 217 in procedure "display_mismatch_ptw" ref
                                                                                  225 225
pageno                    0(15)        based           bit(12)                  array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 68 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 141 395 395
pointer                                                builtin function         dcl 89 in procedure "azm_verify_dump_ams_" ref 344
                                                                                  344
pointer                                based           bit(15)                  array level 2 in structure "sdw_ptrs" packed
                                                                                  unaligned dcl 66 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 115 449 449 463 463
pointer                                based           bit(15)                  level 2 in structure "a_sdw_ptr" packed unaligned
                                                                                  dcl 236 in procedure "display_mismatch_sdw" ref
                                                                                  250 250
pointer                                based           bit(15)                  array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 68 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 139 395 395 402 402
pointer                                based           bit(15)                  level 2 in structure "a_ptw_ptr" packed unaligned
                                                                                  dcl 217 in procedure "display_mismatch_ptw" ref
                                                                                  225 225
pointers                               based           structure                level 2 dcl 2-6
priv                      1(18)        based           bit(1)                   level 2 packed unaligned dcl 183 set ref 202*
privileged                1(18)        based           bit(1)                   level 2 packed unaligned dcl 235 set ref 240*
process_idx                     000103 automatic       fixed bin(17,0)          dcl 42 set ref 324* 331* 332 337*
ptp                                    parameter       pointer                  dcl 284 in procedure "get_ptp" set ref 278 296* 302*
                                                                                  308* 314*
ptp                             000212 automatic       pointer                  dcl 7-3 in procedure "azm_verify_dump_ams_" set ref
                                                                                  140* 141
ptr                                                    builtin function         dcl 89 ref 296
ptr_ptr                         000136 automatic       pointer                  dcl 56 set ref 123* 124* 150* 151* 420* 422* 424*
                                                                                  425* 482* 483* 485* 486*
ptw                                    based           structure                level 1 dcl 7-5
ptw_ptrs                               based           structure                array level 1 dcl 68 set ref 150 420 424
ptw_ptrs_ptr                    000132 automatic       pointer                  dcl 55 set ref 138 139 141 150 328* 382 382 388 388
                                                                                  395 395 395 395 402 402 405 405 420 424
ptw_regs                               based           structure                array level 1 dcl 67 set ref 142 149 419 423
ptw_regs_ptr                    000130 automatic       pointer                  dcl 55 set ref 142 149 327* 354 383 383 402 402 419
                                                                                  423
ptwbase                  25            based           fixed bin(24,0)          level 2 dcl 9-9 ref 296
r1                        0(24)        based           bit(3)                   level 2 packed unaligned dcl 235 set ref 250*
r2                        0(27)        based           bit(3)                   level 2 in structure "a_sdw_reg" packed unaligned
                                                                                  dcl 235 in procedure "display_mismatch_sdw" set
                                                                                  ref 250*
r2                        0(27)        based           bit(3)                   array level 2 in structure "sdw_regs" packed
                                                                                  unaligned dcl 65 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 463 463
r3                        0(30)        based           bit(3)                   level 2 in structure "a_sdw_reg" packed unaligned
                                                                                  dcl 235 in procedure "display_mismatch_sdw" set
                                                                                  ref 250*
r3                        0(30)        based           bit(3)                   array level 2 in structure "sdw_regs" packed
                                                                                  unaligned dcl 65 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 463 463
rd                        1(15)        based           bit(1)                   level 2 packed unaligned dcl 183 set ref 202*
read                      1(15)        based           bit(1)                   level 2 packed unaligned dcl 235 set ref 240*
reg_ptr                         000134 automatic       pointer                  dcl 56 set ref 122* 124* 149* 151* 419* 422* 423*
                                                                                  425* 481* 483* 484* 486*
relative_offset                 000266 automatic       fixed bin(26,0)          dcl 291 set ref 301* 302 307* 308 313* 314
ring1                     0(24)        based           bit(3)                   level 2 packed unaligned dcl 183 set ref 206*
ring2                     0(27)        based           bit(3)                   level 2 packed unaligned dcl 183 set ref 206*
ring3                     0(30)        based           bit(3)                   level 2 packed unaligned dcl 183 set ref 206*
sdw                                    based           structure                level 1 dcl 8-5
sdw_add                         000267 automatic       fixed bin(26,0)          dcl 292 set ref 294* 299 299 301 305 305 307 313
sdw_ptrs                               based           structure                array level 1 dcl 66 set ref 123 482 485
sdw_ptrs_ptr                    000126 automatic       pointer                  dcl 55 set ref 114 115 123 330* 442 442 449 449 454
                                                                                  454 463 463 468 468 482 485
sdw_regs                               based           structure                array level 1 dcl 65 set ref 116 122 481 484
sdw_regs_ptr                    000124 automatic       pointer                  dcl 55 set ref 116 122 329* 444 444 463 463 463 463
                                                                                  463 463 463 463 481 484
sdwa                                   based           structure                array level 1 dcl 8-24 set ref 139
sdwp                            000214 automatic       pointer                  dcl 8-3 in procedure "azm_verify_dump_ams_" set ref
                                                                                  139* 140* 296
sdwp                                   parameter       pointer                  dcl 285 in procedure "get_ptp" ref 278 294
segno                    16            based           structure                level 2 dcl 2-6
slt                                    based           structure                level 3 dcl 2-6
sptp                            000150 automatic       pointer                  dcl 57 set ref 141* 143 152*
sst                                    based           structure                level 1 dcl 9-9
sst_absloc                             based           fixed bin(26,0)          level 2 dcl 10-13 ref 313
sstp                                   parameter       pointer                  dcl 286 in procedure "get_ptp" ref 278 296 314
sstp                            000216 automatic       pointer                  dcl 9-7 in procedure "azm_verify_dump_ams_" set ref
                                                                                  140* 296 341* 370
sstp                      6            based           pointer                  level 2 in structure "hardcore_cur" dcl 2-40
                                                                                  in procedure "azm_verify_dump_ams_" ref 341
substr                                                 builtin function         dcl 89 ref 326
taptw                                  based           bit(36)                  unaligned dcl 72 ref 143
taptwp                          000146 automatic       pointer                  dcl 57 set ref 142* 143
tasdw                                  based           bit(72)                  unaligned dcl 70 ref 117
tasdwp                          000144 automatic       pointer                  dcl 57 set ref 116* 117
tdsdw                                  based           bit(72)                  unaligned dcl 69 ref 117
tdsdw_mask                      000120 automatic       bit(72)                  initial unaligned dcl 53 set ref 53* 117
tdsegp                          000142 automatic       pointer                  dcl 57 set ref 115* 117 125*
temp_ptr                        000140 automatic       pointer                  dcl 56 set ref 354* 355
tsptw                                  based           bit(36)                  unaligned dcl 71 ref 143
tsptw_mask                      000117 automatic       bit(36)                  initial unaligned dcl 52 set ref 52* 143
unp                       1(19)        based           bit(1)                   level 2 packed unaligned dcl 183 set ref 202*
unpaged                   1(19)        based           bit(1)                   level 2 packed unaligned dcl 235 set ref 240*
upt                                    based           structure                level 1 dcl 10-13
upt_absloc                2            based           fixed bin(26,0)          level 2 dcl 10-13 ref 299 301
upt_entry                              based           structure                level 1 dcl 10-26
upt_last_loc              3            based           fixed bin(26,0)          level 2 dcl 10-13 ref 299
upt_ptr                                parameter       pointer                  dcl 287 in procedure "get_ptp" ref 278 296 302 308
upt_ptr                         000220 automatic       pointer                  dcl 10-12 in procedure "azm_verify_dump_ams_" set
                                                                                  ref 140* 299 299 301 305 305 307 313 342*
uptp                     14            based           pointer                  level 2 dcl 2-40 ref 342
usage                     0(32)        based           bit(4)                   level 2 in structure "a_sdw_ptr" packed unaligned
                                                                                  dcl 236 in procedure "display_mismatch_sdw" set
                                                                                  ref 245 245 248*
usage                     0(32)        based           bit(4)                   level 2 in structure "a_ptw_ptr" packed unaligned
                                                                                  dcl 217 in procedure "display_mismatch_ptw" set
                                                                                  ref 220 220 223*
usage                     0(32)        based           bit(4)                   array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 68 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 388 388 405 405
usage                     0(32)        based           bit(4)                   array level 2 in structure "sdw_ptrs" packed
                                                                                  unaligned dcl 66 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 454 454 468 468
usage_string                    000156 automatic       char(8)                  unaligned dcl 59 set ref 220* 223* 225* 245* 248*
                                                                                  250*
valid                     0(27)        based           bit(1)                   level 2 in structure "a_ptw_ptr" packed unaligned
                                                                                  dcl 217 in procedure "display_mismatch_ptw" set
                                                                                  ref 225*
valid                     0(27)        based           bit(1)                   array level 2 in structure "ptw_ptrs" packed
                                                                                  unaligned dcl 68 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 138 382 382
valid                     0(27)        based           bit(1)                   level 2 in structure "a_sdw_ptr" packed unaligned
                                                                                  dcl 236 in procedure "display_mismatch_sdw" set
                                                                                  ref 250*
valid                     0(27)        based           bit(1)                   array level 2 in structure "sdw_ptrs" packed
                                                                                  unaligned dcl 66 in procedure
                                                                                  "azm_verify_dump_ams_" set ref 114 442 442
write                     1(17)        based           bit(1)                   level 2 packed unaligned dcl 235 set ref 240*
wrt                       1(17)        based           bit(1)                   level 2 packed unaligned dcl 183 set ref 202*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_FDUMP_INFO_VERSION                 internal static char(8)                  initial unaligned dcl 1-43
AMU_FDUMP_INFO_VERSION_1               internal static char(8)                  initial unaligned dcl 1-42
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 3-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 3-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 3-58
DUMP_VERSION_1                         internal static fixed bin(17,0)          initial dcl 6-120
DUMP_VERSION_2                         internal static fixed bin(17,0)          initial dcl 6-121
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 3-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 3-47
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 3-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 3-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 3-47
alloc_fdump_process_table_size         automatic       fixed bin(17,0)          dcl 1-40
amu_area                               based           area(1024)               dcl 3-43
asta                                   based           bit(432)                 array dcl 5-86
aste                                   based           structure                level 1 dcl 5-11
aste_part                              based           structure                level 1 dcl 5-89
astep                                  automatic       pointer                  dcl 5-9
atptwa                                 based           structure                array level 1 dcl 7-40
fdump_process_table                    based           structure                level 1 dcl 1-23
fp_table_ptr                           automatic       pointer                  dcl 1-38
mptw                                   based           structure                level 1 dcl 7-27
mptwa                                  based           structure                array level 1 dcl 7-31
ptwa                                   based           structure                array level 1 dcl 7-23
ptwa_bits                              based           bit(36)                  array dcl 7-25
seg_aste                               based           structure                level 1 dcl 5-96
sst_seg$                               external static fixed bin(17,0)          dcl 9-6
upt_entry_ptr                          automatic       pointer                  dcl 10-25
v1_dump                                based           structure                level 1 dcl 6-83

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000427 constant        label                    dcl 100 ref 94
RET                             001005 constant        label                    dcl 171 ref 163
azm_verify_dump_ams_            000400 constant        entry                    external dcl 18
azm_verify_dump_ams_$af         000416 constant        entry                    external dcl 96
cancel_dup_ptw                  002561 constant        label                    dcl 406 ref 404
cancel_dup_sdw                  003100 constant        label                    dcl 469 ref 467
check_ptws                      000601 constant        label                    dcl 132
display_dseg_entry              001045 constant        entry                    internal dcl 179 ref 125
display_mismatch_ptw            001264 constant        entry                    internal dcl 213 ref 151 422 425
display_mismatch_sdw            001453 constant        entry                    internal dcl 232 ref 124 483 486
display_sst_entry               002002 constant        entry                    internal dcl 259 ref 152
done                            000724 constant        label                    dcl 159 ref 105 109
get_ptp                         002044 constant        entry                    internal dcl 278 ref 140
set_up                          002130 constant        entry                    internal dcl 319 ref 108
verify_am_ptw                   002341 constant        entry                    internal dcl 367 ref 135
verify_am_sdw                   002657 constant        entry                    internal dcl 434 ref 112

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3420        3452    3234        3430
Length      4052    3234        32         363     163           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_verify_dump_ams_                653 external procedure  is an external procedure.  
on unit on line 100                  68 on unit               
display_dseg_entry                      internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
display_mismatch_ptw                    internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
display_mismatch_sdw                    internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
display_sst_entry                       internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
get_ptp                                 internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
set_up                                  internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
verify_am_ptw                           internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  
verify_am_sdw                           internal procedure  shares stack frame of external procedure azm_verify_dump_ams_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_verify_dump_ams_     000100 i                           azm_verify_dump_ams_
                         000101 j                           azm_verify_dump_ams_
                         000102 idx                         azm_verify_dump_ams_
                         000103 process_idx                 azm_verify_dump_ams_
                         000104 af_sw                       azm_verify_dump_ams_
                         000105 nregs                       azm_verify_dump_ams_
                         000106 dump_dbr                    azm_verify_dump_ams_
                         000107 code                        azm_verify_dump_ams_
                         000110 DPS8xxM                     azm_verify_dump_ams_
                         000111 RETURN_VAL                  azm_verify_dump_ams_
                         000112 found_mismatch_sdw          azm_verify_dump_ams_
                         000113 found_mismatch_ptw          azm_verify_dump_ams_
                         000114 found_dup_entry_sdw         azm_verify_dump_ams_
                         000115 found_dup_entry_ptw         azm_verify_dump_ams_
                         000116 changed_process_idx         azm_verify_dump_ams_
                         000117 tsptw_mask                  azm_verify_dump_ams_
                         000120 tdsdw_mask                  azm_verify_dump_ams_
                         000122 dup_entry                   azm_verify_dump_ams_
                         000124 sdw_regs_ptr                azm_verify_dump_ams_
                         000126 sdw_ptrs_ptr                azm_verify_dump_ams_
                         000130 ptw_regs_ptr                azm_verify_dump_ams_
                         000132 ptw_ptrs_ptr                azm_verify_dump_ams_
                         000134 reg_ptr                     azm_verify_dump_ams_
                         000136 ptr_ptr                     azm_verify_dump_ams_
                         000140 temp_ptr                    azm_verify_dump_ams_
                         000142 tdsegp                      azm_verify_dump_ams_
                         000144 tasdwp                      azm_verify_dump_ams_
                         000146 taptwp                      azm_verify_dump_ams_
                         000150 sptp                        azm_verify_dump_ams_
                         000152 dsegp                       azm_verify_dump_ams_
                         000154 flag_string                 azm_verify_dump_ams_
                         000156 usage_string                azm_verify_dump_ams_
                         000160 hard_ptr_space              azm_verify_dump_ams_
                         000204 hardcore_cur_ptr            azm_verify_dump_ams_
                         000206 amu_info_ptr                azm_verify_dump_ams_
                         000210 dumpptr                     azm_verify_dump_ams_
                         000212 ptp                         azm_verify_dump_ams_
                         000214 sdwp                        azm_verify_dump_ams_
                         000216 sstp                        azm_verify_dump_ams_
                         000220 upt_ptr                     azm_verify_dump_ams_
                         000234 flag_string                 display_dseg_entry
                         000266 relative_offset             get_ptp
                         000267 sdw_add                     get_ptp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           signal_op           enable_op
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$do_translation_hunt_ptr  amu_$fdump_mpt_revert_idx     amu_$fdump_mpt_temp_change_idx
amu_$hardcore_info_set_cur_ptrs                             amu_$return_val_idx_from_dbr  ioa_
ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$npdx_dbr              amu_et_$null_sstp




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000356        48 000357        49 000360        50 000362        51 000364        52 000365        53 000367
     18 000373        94 000410        96 000411        98 000425       100 000427       103 000443       104 000454
    105 000456       108 000461       109 000462       111 000464       112 000472       113 000473       114 000501
    115 000504       116 000512       117 000516       118 000530       119 000532       120 000534       121 000550
    122 000564       123 000570       124 000573       125 000575       129 000577       132 000601       135 000607
    137 000610       138 000617       139 000622       140 000627       141 000631       142 000641       143 000643
    145 000655       146 000657       147 000661       148 000675       149 000711       150 000714       151 000716
    152 000720       156 000722       159 000724       162 000734       163 000736       166 000737       169 001004
    171 001005       173 001016       174 001021       175 001036       179 001045       202 001047       206 001143
    209 001263       213 001264       220 001266       223 001325       225 001361       228 001452       232 001453
    240 001455       245 001551       248 001611       250 001645       255 002001       259 002002       271 002004
    274 002043       278 002044       294 002046       296 002052       299 002071       301 002077       302 002101
    303 002105       305 002106       307 002112       308 002114       309 002120       313 002121       314 002123
    317 002127       319 002130       322 002131       323 002135       324 002137       325 002141       326 002144
    327 002147       328 002151       329 002153       330 002155       331 002157       332 002172       333 002175
    334 002200       337 002201       338 002212       339 002214       340 002216       341 002227       342 002232
    344 002235       346 002262       347 002264       349 002306       350 002315       351 002320       354 002321
    355 002324       356 002330       357 002332       358 002333       360 002334       361 002336       363 002340
    367 002341       370 002342       371 002346       373 002364       374 002373       375 002376       378 002377
    380 002412       381 002421       382 002431       383 002440       384 002451       385 002454       386 002457
    388 002460       389 002467       390 002471       391 002474       393 002477       395 002500       397 002520
    398 002523       401 002526       402 002536       404 002550       405 002552       406 002561       414 002567
    415 002577       416 002601       417 002604       418 002620       419 002634       420 002637       422 002641
    423 002643       424 002646       425 002650       428 002652       429 002654       430 002656       434 002657
    438 002660       439 002672       440 002673       441 002703       442 002713       444 002722       445 002740
    446 002743       447 002747       449 002750       450 002760       451 002763       452 002766       454 002767
    455 002776       456 003000       457 003003       462 003006       463 003016       467 003067       468 003071
    469 003100       476 003106       477 003116       478 003120       479 003123       480 003137       481 003153
    482 003157       483 003162       484 003164       485 003170       486 003173       489 003175       490 003177
    491 003201


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
