	COMPILATION LISTING OF SEGMENT mexp
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1542.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 mexp: proc;
       12 
       13 /* This program is a simple macro expander for alm type programs. */
       14 
       15 
       16 dcl (char_count, next) fixed bin (21),
       17      bit_count fixed bin (24),
       18      code fixed bin (35),
       19      entry_no fixed bin (21),
       20      based_2_chars char (2) based,
       21      1 dummy_dcl based,
       22      2 pad char (3),
       23      2 fourth_char char (1),
       24      WHITE char (2) static init ("	 "),
       25      TERM char (2) static init (";
       26 "),
       27      ENDS char (4) static init ("();
       28 "),
       29      WHITE_TERM char (4) static init ("	 ;
       30 "),
       31     (last_macro, old_free) ptr,
       32     (i, j) fixed bin (21),
       33     (unique_generator, unique_generator1) fixed bin init (0),
       34      unique_changed bit (1) aligned init ("0"b),
       35      discard fixed bin,
       36      vc char (12) var,
       37      convert_binary_integer_$octal_string entry (fixed bin) returns (char (12) var),
       38      get_wdir_ entry () returns (char (168) aligned),
       39      convert_binary_integer_$decimal_string entry (fixed bin) returns (char (12) var),
       40      cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin),
       41      path char (168) aligned,
       42      dirname char (168),
       43      ename char (32),
       44      sname char (32) var,
       45     (ilp, outp, olp, mbp, bp (32)) ptr,
       46      c char (1) aligned,
       47      hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35)),
       48      hcs_$fs_move_seg entry (ptr, ptr, fixed bin, fixed bin (35)),
       49     (addr, substr, ptr, unspec, index, divide, null, addrel, baseno, baseptr, length, min) builtin,
       50      expand_path_ ext entry (ptr, fixed bin, ptr, ptr, fixed bin (35)),
       51      com_err_ ext entry options (variable),
       52      find_include_file_$initiate_count entry (char (*), ptr, char (*) aligned, fixed bin (24), ptr, fixed bin (35)),
       53      hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin, ptr, fixed bin (35)),
       54      hcs_$delentry_seg entry (ptr, fixed bin (35)),
       55      line_no fixed bin,
       56     (nargs, arg_len) fixed bin,
       57     (no_exargs, no_ifargs) fixed bin,
       58      my_name char (4) aligned static init ("mexp"),
       59      cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35)),
       60      cu_$arg_count entry returns (fixed bin),
       61      dirname_p char (168),
       62     (ename2, ename_p) char (32),
       63      arg char (arg_len) based (arg_ptr),
       64      input_arg (0: 9) char (32) var init ((10) (1)""),
       65      no_input_args fixed bin,
       66      targ char (128) var,
       67     (arg_ptr, fp) ptr,
       68      QUOTE char (1) aligned static init (""""),
       69      ol char (max_char_count) aligned based (olp),
       70      max_char_count fixed bin (21),
       71      sys_info$max_seg_size ext static fixed bin (35),
       72      hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
       73      hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
       74      hcs_$terminate_noname entry (ptr, fixed bin (35)),
       75      COMMA_NL char (2) static init (",
       76 "),
       77      NL char (1) static init ("
       78 "),
       79      TAB char (1) static init ("	");
       80 dcl  type_NORMAL fixed bin static options (constant) init (1);
       81 dcl  type_PREV_UNIQUE fixed bin static options (constant) init (2);
       82 dcl  type_UNIQUE fixed bin static options (constant) init (3);
       83 dcl  type_NEXT_UNIQUE fixed bin static options (constant) init (4);
       84 dcl  type_ITERATE fixed bin static options (constant) init (5);
       85 dcl  type_OPEN fixed bin static options (constant) init (6);
       86 dcl  type_CLOSE fixed bin static options (constant) init (7);
       87 dcl  type_COMMAND_ARGNO fixed bin static options (constant) init (8);
       88 dcl  type_SPEC_UNIQUE fixed bin static options (constant) init (9);
       89 dcl  type_COMMAND_ARG fixed bin static options (constant) init (10);
       90 dcl  type_LENGTH fixed bin static options (constant) init (11);
       91 dcl  type_NARGS fixed bin static options (constant) init (12);
       92 dcl  type_NITER fixed bin static options (constant) init (13);
       93 dcl  type_ENDM fixed bin static options (constant) init (14);
       94 
       95 /* Based */
       96 
       97 
       98 
       99 /*  */
      100 
      101 /* Scan the argument(s) and create necessary buffers, etc. */
      102 
      103 
      104 	max_char_count = sys_info$max_seg_size*4;
      105 	nargs = cu_$arg_count ();			/* get the number of arguments given */
      106 	no_input_args = min (10, nargs-1);		/* get the number of additional arguments */
      107 	if nargs < 1 then do;			/* wrong usage, give correct */
      108 USAGE:	     call com_err_ (0, (my_name), "Usage: mexp name (looks for name.mexp)");
      109 	     return;
      110 	end;
      111 
      112 	call cu_$arg_ptr (1, arg_ptr, arg_len, code);	/* get the arg */
      113 	if code ^= 0 | arg_len = 0 then goto USAGE;
      114 
      115 	call expand_path_ (arg_ptr, arg_len, addr (dirname), addr (ename), code);
      116 	if code ^= 0 then goto USAGE;
      117 
      118 	j = index (ename, " ");			/* search for end of name, see if ends with ".mexp" */
      119 	if j > 0 then if j < 27 then if substr (ename, j-5, 5) ^= ".mexp" then do;
      120 		     substr (ename, j, 5) = ".mexp";	/* if doesn't end in ".mexp", make sure it does */
      121 		     j = j + 5;
      122 		end;
      123 	sname = substr (ename, 1, j-6);		/* get primary component of name */
      124 
      125 	call hcs_$initiate_count (dirname, ename, "", bit_count, 0, ilp, code); /* get pointer to source */
      126 	if ilp = null then do;
      127 	     call com_err_ (code, (my_name), "^a>^a", dirname, ename);
      128 	     return;
      129 	end;
      130 
      131 	ename2 = sname || ".alm";			/* get name of output segment */
      132 
      133 	call hcs_$make_seg (get_wdir_ (), ename2, "", 01011b, outp, code);
      134 	if outp = null then goto USAGE;
      135 
      136 	char_count = divide (bit_count, 9, 17, 0);	/* get number of chars in source */
      137 
      138 /* Now create the two temporary segments needed */
      139 
      140 	call hcs_$make_seg ("", "mexp.temp", "", 01011b, fp, code);
      141 	if fp = null then goto USAGE;
      142 	call hcs_$truncate_seg (fp, 0, code);
      143 	if code ^= 0 then goto USAGE;
      144 	call hcs_$make_seg ("", ename2, "", 01011b, olp, code);
      145 	if olp = null then goto USAGE;
      146 	call hcs_$make_seg ("", "macro_buffers.mexp", "", 01011b, mbp, code);
      147 	if mbp = null then goto USAGE;
      148 
      149 	do i = 2 to 32;
      150 	     bp (i) = addrel (mbp, (i-2)*1024);
      151 	end;
      152 
      153 	if nargs > 11 then call com_err_ (0, (my_name), "Only first 10 arguments will be accepted.");
      154 	do i = 0 to no_input_args-1;
      155 	     call cu_$arg_ptr (i+2, arg_ptr, arg_len, code);
      156 	     if code ^= 0 then goto NOMOREARGS;
      157 	     input_arg (i) = arg;
      158 	end;
      159 NOMOREARGS:
      160 						/*  */
      161 
      162 /* Now expand the input text.  This is done by expanding the data pointed to by
      163*   bp (level) ... which is done by a (recursive) call to scan_buffer. */
      164 
      165 
      166 	old_free = ptr (fp, 0);			/* initialize pointer to macro table */
      167 	last_macro = null;				/* set up for reverse chain of macros */
      168 	line_no = 0;				/* initialize line number counter */
      169 	next = 1;					/* initialize output character index */
      170 	if ilp -> based_2_chars = "%;" then ilp = addr (ilp -> dummy_dcl.fourth_char); /* BUG */
      171 	bp (1) = ilp;				/* first buffer load is input text */
      172 
      173 	call scan_buffer (1, char_count);		/* this will do all the work */
      174 ERROR:
      175 	call hcs_$fs_move_seg (olp, outp, 1, code);	/* copy the data into the segment */
      176 	if code ^= 0 then do;			/* some trouble */
      177 	     call com_err_ (code, (my_name), "Copying segment from process directory.");
      178 	     call com_err_ (0, (my_name), "Segment is in process directory with name ^a.", ename2);
      179 	     call hcs_$set_bc_seg (olp, (next-1)*9, code);
      180 	     if code ^= 0 then call com_err_ (code, (my_name), "Setting bit count on ^a.", ename2);
      181 	     return;
      182 	end;
      183 	call hcs_$set_bc_seg (outp, (next-1)*9, code);
      184 	if code ^= 0 then call com_err_ (code, (my_name), "Setting bit count on ^a.", ename2);
      185 	call hcs_$delentry_seg (olp, code);		/* delete the temp */
      186 	call hcs_$delentry_seg (fp, code);
      187 	call hcs_$delentry_seg (mbp, code);
      188 	call hcs_$terminate_noname (ilp, code);
      189 	call hcs_$terminate_noname (outp, code);
      190 	return;
      191 
      192 /*  */
      193 
      194 /* SCAN_BUFFER   This is the main work program of mexp. It scans the text pointed to by
      195*   bp (level) and places output into the output temporary. Any buffers
      196*   which are used for macro expansion along the way are expanded and
      197*   hence output into the output segment with a recursive call to SCAN_BUFFER */
      198 
      199 scan_buffer: proc (a_level, a_size);
      200 
      201 dcl (a_level, a_size) fixed bin (21);
      202 
      203 dcl (nparens, i, ci, start, stop, j, iterate, macro_len) fixed bin (21),
      204      found_number bit (1) aligned,
      205      si fixed bin (21),
      206      pfree ptr,
      207      save_free fixed bin (21),
      208      val fixed bin,
      209      filling_buffer bit (1),
      210      t fixed bin (21),
      211      type fixed bin,
      212     (nargs, level) fixed bin,
      213     (nchars, arg_start, len_op, start_name, len1, len, nextb, ia) fixed bin (21),
      214      ml char (macro_len) based (mp),
      215      ob char (max_char_count) based (obp),
      216      il char (nchars) based (tp),
      217     (end_index, ntimes) fixed bin (21),
      218      match bit (1) aligned,
      219     (lab_start, lab_end, op_start, op_end, var_start, var_end, mstart) fixed bin (21),
      220      opcode char (32) aligned,
      221      iterate_arg_no fixed bin (21),
      222      save_start fixed bin (21),
      223     (obp, mp, p, tp) ptr;
      224 
      225 dcl 1 ifargs (0: 99) aligned,
      226     2 start fixed bin (21),
      227     2 len fixed bin (21);
      228 
      229 dcl 1 exargs (0: 99) aligned,
      230     2 start fixed bin (21),
      231     2 len fixed bin (21);
      232 
      233 dcl 1 args (0: 99) aligned,
      234     2 start fixed bin (21),
      235     2 len fixed bin (21);
      236 
      237 dcl 1 macro based (pfree) aligned,
      238     2 next_macro ptr unal,
      239     2 segno fixed bin,
      240     2 num_entries fixed bin,
      241     2 name char (32) var,
      242     2 entry (1),
      243       3 type fixed bin,
      244       3 value_1 fixed bin,
      245       3 value_2 fixed bin,
      246       3 first_char fixed bin (21),
      247       3 n_chars fixed bin (21);
      248 
      249 
      250 	     stop = 0;				/* initialize end of line index */
      251 	     nchars = a_size;			/* copy length of buffer to work on */
      252 	     level = a_level;			/* copy recursion depth */
      253 	     if level > 32 then do;			/* too much recursion ... */
      254 		call com_err_ (0, "mexp", "Maximum recursion exceeded.");
      255 		goto ERROR;
      256 	     end;
      257 
      258 	     tp = bp (level);			/* copy pointer to text to expand and copy */
      259 	     obp = bp (level+1);			/* get pointer to output buffer if needed */
      260 	     nextb = 1;				/* next available char position in output buffer */
      261 	     filling_buffer = "0"b;			/* indicates we are not using output buffer (yet) */
      262 GETLINE:
      263 
      264 	     call skip_to_next_line;			/* get bounds of next line */
      265 	     if stop > nchars then do;		/* all done, see if some thing in output buffer */
      266 		if filling_buffer then call scan_buffer (level+1, nextb-1); /* clean out the output buffer */
      267 		return;
      268 	     end;
      269 
      270 	     if stop = start then do;			/* blank line, just copy NL */
      271 copy_terminator:
      272 		if filling_buffer then do;
      273 		     substr (ob, nextb, 1) = substr (il, stop, 1);
      274 		     nextb = nextb + 1;
      275 		end;
      276 		else do;
      277 		     substr (ol, next, 1) = substr (il, stop, 1); /* may also be a ";" */
      278 		     next = next + 1;
      279 		end;
      280 		goto GETLINE;
      281 	     end;
      282 
      283 	     lab_start, op_start, var_start = -1;	/* initialize starting indexes as flags */
      284 	     ci = start;				/* initialize scanning index */
      285 	     call sob;				/* skip over blanks */
      286 
      287 
      288 	     arg_start = ci;			/* remember where the scan started */
      289 
      290 /* The first search is special cased because of label possibilities */
      291 
      292 check_char:
      293 	     c = substr (il, ci, 1);			/* pick up the next character of the line */
      294 
      295 	     if c = ":" then do;			/* we've come across a label */
      296 		lab_start = arg_start;		/* set index to start of the label */
      297 		lab_end = ci;			/* set index to end of label */
      298 		if ci = arg_start then goto syn;	/* check for initial : */
      299 		ci = ci + 1;			/* skip over the : */
      300 		goto scan_opcode;			/* look for an opcode */
      301 	     end;
      302 
      303 	     if c = " " | c = TAB then do;		/* if we've come to white space we just scanned an opcode */
      304 		op_start = arg_start;		/* set the index to the start of the opcode */
      305 		op_end = ci-1;			/* and the index to the end of the opcode */
      306 		len_op = op_end - op_start + 1;
      307 		opcode = substr (il, op_start, len_op);
      308 		goto scan_var;			/* scan the variables field */
      309 	     end;
      310 
      311 	     if c = NL | c = ";" then do;		/* we've come to the end of the line */
      312 		if ci ^= arg_start then do;		/* if opcode was given, remember it */
      313 		     op_start = arg_start;
      314 		     op_end = ci-1;
      315 		     len_op = op_end - op_start + 1;
      316 		     opcode = substr (il, op_start, len_op);
      317 		end;
      318 		goto output_current_line;		/* go clean up the current line */
      319 	     end;
      320 
      321 	     if c = QUOTE then do;			/* we came across a comment */
      322 		if ci ^= arg_start then do;
      323 syn:		     call com_err_ (0, (my_name), "Unexpected syntax in line ^d", line_no);
      324 		     call com_err_ (0, (my_name), "line is: ^/^a", substr (il, start, stop-start+1));
      325 		     call copy_line;
      326 		     goto GETLINE;
      327 		end;
      328 		goto output_current_line;
      329 	     end;
      330 
      331 	     ci = ci + 1;				/* scan to the next character */
      332 	     goto check_char;
      333 
      334 /*  */
      335 
      336 scan_opcode:
      337 	     call sob;				/* skip over blanks and tabs */
      338 	     if substr (il, ci, 1) = QUOTE then goto output_current_line; /* check for a comment */
      339 
      340 	     op_start = ci;				/* save start of the opcode */
      341 	     call soc;				/* skip over non-white characters */
      342 	     op_end = ci-1;				/* save end of the opcode */
      343 	     if ci > stop then op_end = op_end - 1;	/* if last thing on line was opcode, don't copy term */
      344 	     len_op = op_end - op_start + 1;		/* get length of opcode */
      345 	     opcode = substr (il, op_start, len_op);	/* get the opcode */
      346 
      347 scan_var:
      348 	     call sob;				/* skip over blanks again */
      349 	     if opcode = "acc" | opcode = "aci" | opcode = "bci" then do; /* special case these opcodes */
      350 		c = substr (il, ci, 1);		/* get quoting character used by ACC or ACI */
      351 		t = index (substr (il, ci+1, stop-ci), c)-1; /* look for matching char */
      352 		if t < 0 then goto output_current_line; /* really was comment */
      353 		else i = ci+1+t;			/* index of matching char */
      354 		var_start = ci;			/* treat char string as variable field */
      355 		var_end = i;
      356 		ci = i+1;
      357 		goto output_current_line;		/* search for a comment */
      358 	     end;
      359 	     var_start = ci;			/* save start of variable field */
      360 	     call soc;				/* skip over non-white characters */
      361 	     var_end = ci-1;			/* save last char of variable field */
      362 	     if ci > stop then var_end = var_end - 1;
      363 
      364 
      365 /*  */
      366 
      367 output_current_line:
      368 
      369 	     if op_start > 0 then do;			/* see if an opcode was given */
      370 
      371 /* See if the opcode is some special pseudo-op */
      372 
      373 		if opcode = "ife" | opcode = "ine" | opcode = "ifarg" | opcode = "ifint" | opcode = "inint" then do;
      374 		     j = index (substr (il, stop), "ifend"); /* search for end of conditional data */
      375 		     if j <= 0 then do;		/* bad use of pseudo-op */
      376 BAD_PSEUDO:		call com_err_ (0, (my_name), "Bad use of ^a at line ^d.", opcode, line_no);
      377 			return;
      378 		     end;
      379 		     end_index = stop + j;		/* save position of ifend */
      380 		     if var_start < 0 then goto BAD_PSEUDO; /* must have args for INE and IFE */
      381 		     call scan_args (ifargs, no_ifargs, var_start, var_end-var_start+1);
      382 		     targ = substr (il, ifargs (1).start, ifargs (1).len);
      383 		     if opcode = "ifarg" then do;	/* conditional expansion on input arg */
      384 			match = "0"b;		/* default is no match */
      385 			do ia = 1 to no_input_args while (match = "0"b); /* search all input args */
      386 			     if targ = input_arg (ia-1) then match = "1"b;
      387 			end;
      388 		     end;
      389 		     else if opcode = "ifint" | opcode = "inint" then do;
      390 			discard = cv_dec_check_ ((targ), code); /* check for decimal number */
      391 			match = (code = 0);		/* match if arg is decimal integer */
      392 			if opcode = "inint" then match = ^match;
      393 		     end;
      394 		     else do;
      395 			if targ = substr (il, ifargs (2).start, ifargs (2).len) then
      396 			match = "1"b; else match = ""b;
      397 			if opcode = "ine" then match = ^match; /* inverse meaning for INE case */
      398 		     end;
      399 		     ntimes = 1;			/* we join the dup code so ... */
      400 INE_JOIN:
      401 		     if lab_start > 0 then do;	/* don't leave off label */
      402 			len1 = lab_end -lab_start + 1;
      403 			substr (ob, nextb, len1) = substr (il, lab_start, len1);
      404 			nextb = nextb + len1;
      405 		     end;
      406 		     filling_buffer = "1"b;
      407 GET_ANOTHER_LINE:	     call skip_to_next_line;		/* scan another line */
      408 		     if stop > end_index then do;	/* if the new line includes the ifend ... */
      409 			ntimes = ntimes - 1;	/* decrement number of passes through */
      410 			if ntimes > 0 then do;	/* only for dup case */
      411 			     stop = save_start;	/* go back */
      412 			     goto GET_ANOTHER_LINE;
      413 			end;
      414 			if match then do;
      415 			     len1 = end_index-start-1;
      416 			     call copy_line_len;
      417 			end;
      418 			if substr (il, end_index+4, 5) = "_exit" & level > 1 & match then do;
      419 			     if filling_buffer then call scan_buffer (level+1, nextb-1);
      420 			     return;
      421 			end;
      422 			goto GETLINE;		/* and start with next normal line */
      423 		     end;
      424 		     else do;			/* one of the lines to be expanded conditionally */
      425 			if match then call copy_line;
      426 			goto GET_ANOTHER_LINE;
      427 		     end;
      428 		end;
      429 
      430 		if opcode = "dup" then do;
      431 		     j = index (substr (il, stop), "dupend"); /* search for end of dup */
      432 		     if j < 0 then goto BAD_PSEUDO;
      433 		     if var_start < 0 then goto BAD_PSEUDO;
      434 		     save_start = stop;
      435 		     match = "1"b;			/* for later join with INE/IFE code */
      436 		     end_index = stop + j;
      437 		     ntimes = cv_dec_check_ (substr (il, var_start, var_end-var_start+1), code);
      438 		     if code ^= 0 then goto BAD_PSEUDO;
      439 		     goto INE_JOIN;
      440 		end;
      441 
      442 		if opcode = "&include" then do;	/* an include file was specified */
      443 		     call copy_line_quoted;		/* print out macro line as a comment */
      444 		     if var_start < 0 then goto BAD_MACRO_FILE; /* no file name, bad style */
      445 		     path = substr (il, var_start, var_end-var_start+1) || ".incl.mexp"; /* get pathname */
      446 		     call find_include_file_$initiate_count ("mexp", tp, path, bit_count, mp, code);
      447 		     if mp = null then do;		/* couldn't get pointer to macro file */
      448 			call com_err_ (code, (my_name), "Could not get pointer to include file ^a", path);
      449 			goto BAD_MACRO_FILE;
      450 		     end;
      451 		     call build_macros (mp, bit_count); /* place macros in macro directory */
      452 		     goto GETLINE;
      453 		end;
      454 
      455 		if opcode = "&macros" then do;	/* a macro segment was specified */
      456 		     call copy_line_quoted;		/* print out macro line as a comment */
      457 		     if var_start < 0 then goto nopath; /* if no macro file given, use default */
      458 		     path = substr (il, var_start, var_end-var_start+1); /* get pathname */
      459 		     if path = "&system" then do;
      460 nopath:			dirname_p = ">system_library_tools"; /* use system standard macro segment */
      461 			ename_p = "mexp_system_macros";
      462 		     end;
      463 		     else do;			/* not system macros */
      464 			call expand_path_ (addr (path), var_end-var_start+1, addr (dirname_p), addr (ename_p), code);
      465 			if code ^= 0 then do;	/* something screwed up in pathname */
      466 BAD_MACRO_FILE:		     call com_err_ (code, (my_name), "Bad syntax in macro pathname on line ^d", line_no);
      467 			     goto GETLINE;
      468 			end;
      469 		     end;
      470 		     call hcs_$initiate_count (dirname_p, ename_p, "", bit_count, 0, mp, code); /* get pointer to macro file */
      471 		     if mp = null then do;		/* couldn't get pointer to macro file */
      472 			call com_err_ (code, (my_name), "Could not get pointer to macro file ^a>^a", dirname_p, ename_p);
      473 			goto BAD_MACRO_FILE;
      474 		     end;
      475 		     call build_macros (mp, bit_count); /* place macros in macro directory */
      476 		     goto GETLINE;
      477 		end;
      478 
      479 		if opcode = "&macro" then do;		/* a macro was given within the text of this program */
      480 		     j = index (substr (il, stop), "&end"); /* search for matching "&end" */
      481 		     if j < 1 then do;		/* bad macro definition */
      482 			call com_err_ (0, (my_name), "Bad macro definition starting at line ^d.", line_no);
      483 			return;
      484 		     end;
      485 		     macro_len = j+stop+3;
      486 		     substr (ol, next, 1) = QUOTE;	/* comment out macro def */
      487 		     next = next + 1;
      488 		     start_name = var_start;
      489 		     len1 = var_end-var_start+1;
      490 		     pfree = old_free;		/* restore free index (restored earlier) */
      491 		     call build_macro (ilp, stop, len1, start_name); /* leaves stop pointing to end of macro def */
      492 		     old_free = pfree;		/* save free index (used later) */
      493 		     do i = start to stop - 1;	/* scan over all characters of the macro definition */
      494 			c = substr (il, i, 1);	/* get current character */
      495 			substr (ol, next, 1) = c;	/* copy it into the output segment */
      496 			next = next + 1;
      497 			if c = NL | c = ";" then do;	/* follow all NL's and ;'s with a " */
      498 			     substr (ol, next, 1) = QUOTE;
      499 			     next = next+1;
      500 			     if level = 1 then if c = NL then line_no = line_no + 1;
      501 			end;
      502 		     end;
      503 		     if level = 1 then line_no = line_no - 1; /* first line was counted twice, so ... */
      504 		     goto copy_terminator;
      505 		end;
      506 
      507 /* See if the opcode is a macro name */
      508 
      509 		do pfree = last_macro repeat macro.next_macro while (pfree ^= null);
      510 		     if macro.name = opcode then do;	/* we have found a macro to expand */
      511 
      512 			if filling_buffer then do;	/* must fisrt clean out what's in the buffer */
      513 			     call scan_buffer (level+1, nextb-1);
      514 			     filling_buffer = "0"b;
      515 			     nextb = 1;
      516 			end;
      517 			mp = baseptr (macro.segno);	/* get pointer to macro segment to use */
      518 
      519 /* Write out the macro line preceded with a comment character */
      520 
      521 			if lab_start > 0 then do;	/* if a label was given on the macro, don't comment it out */
      522 			     len1 = lab_end - lab_start + 1;
      523 			     substr (ob, nextb, len1) = substr (il, lab_start, len1);
      524 			     nextb = nextb + len1;
      525 			end;
      526 
      527 			call copy_line_quoted;	/* copy the macro line as a comment */
      528 			if unique_changed then do;	/* did we use it last macro? */
      529 			     unique_generator1 = unique_generator1 + 1;
      530 			     unique_changed = ""b;
      531 			end;
      532 
      533 /* Now pick off any args from the input source, save pointers to them */
      534 
      535 			if var_start > 0 then do;	/* if args were given ... */
      536 			     call scan_args (args, nargs, var_start, var_end-var_start+1);
      537 			end;
      538 			else do;			/* no args to macro */
      539 			     do i = 0 to 99;
      540 				args (i).len = 0;
      541 			     end;
      542 			     nargs = 0;
      543 			end;
      544 			if lab_start > 0 then do;
      545 			     args.len (0) = lab_end-lab_start;
      546 			     args.start (0) = lab_start;
      547 			end;
      548 			else args.len (0) = 0;
      549 			iterate = 0;		/* in case &x is used and iteration isn't */
      550 
      551 /* Now copy expanded text into file */
      552 
      553 			do entry_no = 1 to macro.num_entries;
      554 			     len = macro.entry (entry_no).n_chars; /* get size of element */
      555 			     if len > 0 then do;
      556 				substr (ob, nextb, len) = substr (ml, macro.entry (entry_no).first_char, len);
      557 				nextb = nextb + len;
      558 			     end;
      559 			     val = macro.entry (entry_no).value_1; /* extract value for this type of element */
      560 			     type = macro.entry (entry_no).type; /* also extract type of element */
      561 			     if type = type_UNIQUE then do; /* "u" expansion */
      562 				unique_generator = unique_generator + 1;
      563 				i = unique_generator; /* get value for symbol */
      564 UNIQUE:				substr (ob, nextb, 3) = "..."; /* generate unique symbol */
      565 UNIQUE1:				nextb = nextb + 3;
      566 				vc = convert_binary_integer_$octal_string (i + 1e27b); /* convert to char */
      567 				substr (ob, nextb, 5) = substr (vc, 6, 5);
      568 				nextb = nextb + 5;
      569 			     end;
      570 			     else if type = type_PREV_UNIQUE then do; /* "p" expansion" */
      571 				i = unique_generator; /* get value for symbol */
      572 				goto UNIQUE;
      573 			     end;
      574 			     else if type = type_NEXT_UNIQUE then do; /* "n" expansion */
      575 				i = unique_generator + 1;
      576 				goto UNIQUE;
      577 			     end;
      578 			     else if type = type_SPEC_UNIQUE then do; /* "U" expansion */
      579 				i = unique_generator1;
      580 				substr (ob, nextb, 3) = ".._"; /* this "_" used to be "!" */
      581 				unique_changed = "1"b;
      582 				goto UNIQUE1;
      583 			     end;
      584 			     else if type = type_ITERATE then do; /* 5 indicates &i */
      585 				len = exargs (iterate).len;
      586 				if len > 0 then do;
      587 				     substr (ob, nextb, len) = substr (il, exargs (iterate).start, len);
      588 				     nextb = nextb + len;
      589 				end;
      590 			     end;
      591 			     else if type = type_COMMAND_ARGNO then do; /* &x */
      592 				val = iterate;
      593 PUTNUM:				vc = convert_binary_integer_$decimal_string (val);
      594 				i = length (vc);
      595 				substr (ob, nextb, i) = vc;
      596 				nextb = nextb+i;
      597 			     end;
      598 			     else if type = type_COMMAND_ARG then do; /* A_n */
      599 				len = length (input_arg (val-1));
      600 				substr (ob, nextb, len) = input_arg (val-1);
      601 				nextb = nextb + len;
      602 			     end;
      603 			     else if type = type_NORMAL then do; /* normal argument expansion */
      604 				if val <= nargs then do;
      605 				     len = args.len (val);
      606 				     substr (ob, nextb, len) = substr (il, args.start (val), len);
      607 				     nextb = nextb + len;
      608 				end;
      609 			     end;
      610 			     else if type = type_CLOSE then do; /* &) */
      611 				iterate = iterate + 1; /* another iteration complete */
      612 				entry_no = save_free;
      613 				goto ANY_ARGS_Q;
      614 			     end;
      615 			     else if type = type_OPEN then do; /* &( */
      616 				save_free = entry_no;
      617 				iterate_arg_no = val;
      618 				iterate = 1;
      619 				i = args (iterate_arg_no).len;
      620 				if i > 0 then do;
      621 				     j = args (iterate_arg_no).start;
      622 				     call scan_args (exargs, no_exargs, j, i);
      623 				end;
      624 				else no_exargs = 0;
      625 ANY_ARGS_Q:			if no_exargs < iterate then do;
      626 				     entry_no = macro.entry (save_free).value_2;
      627 				end;
      628 			     end;
      629 			     else if type = type_LENGTH then do;
      630 				val = args (val).len;
      631 				goto PUTNUM;
      632 			     end;
      633 			     else if type = type_NARGS then do;
      634 				val = nargs;
      635 				go to PUTNUM;
      636 			     end;
      637 			     else if type = type_NITER then do;
      638 				val = no_exargs;
      639 				go to PUTNUM;
      640 			     end;
      641 			     else if type ^= type_ENDM then do; /* internal error in mexp */
      642 				call com_err_ (0, (my_name), "Mexp internal error");
      643 				goto ERROR;
      644 			     end;
      645 			end;
      646 			call scan_buffer (level+1, nextb-1); /* scan newly expanded macro for more macros */
      647 			nextb = 1;
      648 			goto GETLINE;		/* get next line of text */
      649 		     end;
      650 
      651 		end;
      652 
      653 /* No macros match, just copy given line */
      654 
      655 	     end;
      656 
      657 	     call copy_line;			/* copy the line into the output text */
      658 	     goto GETLINE;
      659 
      660 /*  */
      661 
      662 /* The following routine parses a string and picks off arguments */
      663 
      664 scan_args:     proc (array, no_args, firstx, count);
      665 
      666 dcl 1 array (0: 99) aligned,
      667     2 first fixed bin (21),
      668     2 size fixed bin (21);
      669 
      670 dcl
      671      c2 char (2) aligned;
      672 
      673 dcl  no_args fixed bin,
      674     (firstx, count, arg_start, i, last) fixed bin (21);
      675 
      676 		do i = 0 to 99;
      677 		     array (i).size = 0;
      678 		end;
      679 		arg_start, ci = firstx;
      680 		last = ci + count - 1;
      681 		no_args = 0;
      682 GET_ANOTHER_ARG:
      683 		c2 = substr (il, ci-1, 2);
      684 		if c2 = COMMA_NL | c2 = ", " | c2 = ",	" | c2 = ",""" then do; /* continue on next line */
      685 		     call skip_to_next_line;
      686 		     if stop > nchars then return;
      687 		     call copy_line_quoted;		/* comment out the arguments */
      688 		     t = verify (substr (il, start, stop-start+1), WHITE)-1; /* skip white space */
      689 		     if t < 0 then ci = stop+1;
      690 		     else ci = start + t;
      691 		     arg_start = ci;		/* save start of variable field */
      692 		     call soc;			/* skip to end of variable field */
      693 		     if stop = ci-1 then last = ci-2;
      694 		     else last = ci-1;
      695 		     ci = arg_start;
      696 		     goto GET_ANOTHER_ARG;
      697 		end;
      698 
      699 		else if substr (il, ci, 1) = "(" then do; /* watch out for args with parens */
      700 		     nparens = 1;			/* skip till no more parens at this level */
      701 		     do ci = ci+1 to last while (nparens > 0);
      702 			if substr (il, ci, 1) = "(" then nparens = nparens + 1;
      703 			else if substr (il, ci, 1) = ")" then nparens = nparens - 1;
      704 		     end;
      705 		     if nparens > 0 then do;
      706 			call com_err_ (0, (my_name), "Unbalanced parentheses at line ^d", line_no);
      707 			return;
      708 		     end;
      709 
      710 		     no_args = no_args + 1;
      711 		     array.first (no_args) = arg_start+1; /* copy information about where the arg is */
      712 		     array.size (no_args) = ci - arg_start - 2;
      713 		     goto NEXT_ARG;
      714 		end;
      715 
      716 		else do;				/* argument didn' start with paren */
      717 		     t = index (substr (il, ci, last-ci+1), ",")-1;
      718 		     if t < 0 then ci = last + 1;
      719 		     else ci = ci + t;
      720 
      721 		     no_args = no_args + 1;
      722 		     array.first (no_args) = arg_start;
      723 		     array.size (no_args) = ci - arg_start;
      724 NEXT_ARG:		     ci, arg_start = ci+1;
      725 		     if arg_start <= last+1 then goto GET_ANOTHER_ARG;
      726 		end;
      727 		return;
      728 
      729 
      730 	     end scan_args;
      731 						/*  */
      732 
      733 /* The following procedure is used to extract the macro definitions found in the
      734*   macro file pointed to by mp. */
      735 
      736 build_macros:  proc (mp, bit_count);
      737 
      738 dcl  mp ptr, bit_count fixed bin (24);
      739 
      740 /* Scan the macro source file extracting information about the macros
      741*   and puting the information into the temporary segment pointed to by fp */
      742 
      743 		macro_len = divide (bit_count, 9, 17, 0);
      744 		pfree = old_free;			/* index to next free word of the free segment */
      745 		ci = 1;				/* points to current character being scanned */
      746 
      747 ANOTHER_MACRO:
      748 		len = 100;
      749 		j = index (substr (ml, ci), "&macro")-1;
      750 		if j < 0 then do;			/* no more, all done with this macro seg */
      751 		     old_free = pfree;
      752 		     return;
      753 		end;
      754 
      755 		mstart = j+ci;			/* get start of macro definition */
      756 		t = verify (substr (ml, mstart+6), WHITE)-1;
      757 		if t < 0 then goto BAD_MACRO_DEF;
      758 		start_name = mstart+6+t;
      759 		t = search (substr (ml, start_name), WHITE_TERM)-1;
      760 		if t < 0 then goto BAD_MACRO_DEF;
      761 		ci = start_name + t;
      762 		len = ci - start_name;		/* get length of macro name */
      763 		call build_macro (mp, ci, len, start_name);
      764 		goto ANOTHER_MACRO;			/* process another macro */
      765 
      766 BAD_MACRO_DEF:	call com_err_ (0, (my_name), "Bad macro defintion at line ^d.", line_no);
      767 		return;
      768 
      769 	     end build_macros;
      770 
      771 /*  */
      772 /* The following procedure is used to enter a single macro into the macro table */
      773 
      774 build_macro:   proc (mp, ci, len, start_name);
      775 
      776 dcl  mp ptr, ci fixed bin (21), len fixed bin (21), start_name fixed bin (21);
      777 
      778 dcl  ml char (macro_len) based (mp) aligned;
      779 dcl  tfree ptr;
      780 
      781 dcl  start fixed bin (21);
      782 dcl  in_iteration fixed bin;
      783 
      784 
      785 		in_iteration = 0;
      786 
      787 		tfree = pfree;			/* remember where this macro started */
      788 		macro.name = substr (ml, start_name, len);
      789 
      790 		macro.segno = bin (baseno (mp));	/* save segment number in macro structure */
      791 
      792 /* Now generate sub-structure */
      793 
      794 		t = search (substr (ml, ci), TERM)-1;
      795 		if t < 0 then goto BAD_MACRO_DEF;
      796 		ci = ci + t;
      797 
      798 		do entry_no = 1 by 1;		/* iterate until macro defined */
      799 		     start = ci+1;			/* get start of the current element */
      800 		     do ci = start to macro_len while (substr (ml, ci, 1) ^= "&");
      801 		     end;				/* skip to next special character */
      802 		     if ci >= macro_len then do;
      803 			ci = macro_len;		/* leave ci pointing to end of macro */
      804 			goto FIN_MACRO;
      805 		     end;
      806 
      807 		     macro.entry (entry_no).first_char = start;
      808 		     macro.entry (entry_no).n_chars = ci-start;
      809 
      810 		     c = substr (ml, ci+1, 1);	/* copy next character -- might by argument number */
      811 		     si = 1;			/* indicates where to start scan */
      812 		     call get_numeric_value;
      813 		     if found_number then do;
      814 			type = type_NORMAL;		/* normal arg expansion */
      815 			macro.entry (entry_no).value_1 = i;
      816 			ci = ci-1;
      817 		     end;
      818 		     else if c = "p" then type = type_PREV_UNIQUE; /* predecessor */
      819 		     else if c = "u" then type = type_UNIQUE; /* unique number */
      820 		     else if c = "n" then type = type_NEXT_UNIQUE; /* next unique */
      821 		     else if c = "i" then do;
      822 			if in_iteration > 0 then do;
      823 			     type = type_ITERATE;
      824 			end;
      825 			else do;
      826 			     call com_err_ (0, (my_name), """&i"" occured outside of iteration bounds in macro ^a", macro.name);
      827 			     goto FIN_MACRO;
      828 			end;
      829 		     end;
      830 		     else if c = "(" then do;		/* start of iteration */
      831 			save_free = entry_no;
      832 			si = 2;
      833 			call get_numeric_value;
      834 			if i = 0 then i = 1;
      835 			type = type_OPEN;
      836 			macro.entry (entry_no).value_1 = i;
      837 			if in_iteration > 0 then do;	/* warn against recursive iteration */
      838 			     call com_err_ (0, (my_name), "Illegal recursive iteration in macro ^a", macro.name);
      839 			     goto FIN_MACRO;
      840 			end;
      841 			else in_iteration = 1;
      842 		     end;
      843 		     else if c = ")" then do;		/* end of iteration */
      844 			in_iteration = in_iteration - 1;
      845 			if in_iteration < 0 then goto bad_iter;
      846 			type = type_CLOSE;
      847 			macro.entry (entry_no).value_1 = save_free;
      848 			macro.entry (save_free).value_2 = entry_no;
      849 		     end;
      850 		     else if c = "x" then type = type_COMMAND_ARGNO;
      851 		     else if c = "U" then type = type_SPEC_UNIQUE;
      852 		     else if c = "A" then do;		/* &A0, ... &A9 */
      853 			si = 2;
      854 			call get_numeric_value;
      855 			type = type_COMMAND_ARG;
      856 			macro.entry (entry_no).value_1 = i;
      857 		     end;
      858 		     else if c = "l" then do;
      859 			si = 2;
      860 			call get_numeric_value;
      861 			if i = 0 then i = 1;
      862 			type = type_LENGTH;
      863 			macro.entry (entry_no).value_1 = i;
      864 		     end;
      865 		     else if c = "K" then type = type_NARGS;
      866 		     else if c = "k" then type = type_NITER;
      867 
      868 		     else if substr (ml, ci, 4) = "&end" then do; /* end of macro */
      869 			t = search (substr (ml, ci), TERM)-1;
      870 			if t < 0 then ci = macro_len + 1;
      871 			else ci = ci + t;
      872 			goto FIN_MACRO;
      873 		     end;
      874 
      875 		     else do;			/* unexpected control */
      876 BAD_MACRO_DEF:		call com_err_ (0, (my_name), "Bad macro definition within macro ^a", macro.name);
      877 			t = index (substr (ml, ci), "&end")-1;
      878 			if t < 0 then ci = macro_len+1;
      879 			else ci = ci + t;
      880 		     end;
      881 
      882 		     macro.entry (entry_no).type = type;
      883 		     ci = ci + 1;
      884 
      885 		end;
      886 
      887 
      888 FIN_MACRO:
      889 		if in_iteration ^= 0 then do;
      890 bad_iter:		     call com_err_ (0, (my_name), "Unbalanced iteration within macro ^a", macro.name);
      891 		end;
      892 		macro.entry (entry_no).type = type_ENDM; /* indicates end of macro */
      893 		macro.num_entries = entry_no;
      894 		macro.next_macro = last_macro;	/* fill in pointer to previous macro structure */
      895 		last_macro = tfree;
      896 		pfree = addr (macro.entry (entry_no+1)); /* save pointer to where next macro goes */
      897 		return;
      898 
      899 
      900 get_numeric_value:	proc;
      901 
      902 dcl  c char (1) aligned;
      903 
      904 		     i = 0;			/* initialize return value */
      905 		     found_number = "0"b;
      906 		     do ci = ci to ci+2;
      907 			c = substr (ml, ci+si, 1);
      908 			if c < "0" then return;
      909 			if c > "9" then return;
      910 			found_number = "1"b;
      911 			i = i*10 + bin (unspec (c), 9) - 48;
      912 		     end;
      913 
      914 		end;
      915 
      916 	     end build_macro;
      917 
      918 /*  */
      919 
      920 copy_line_quoted: proc;
      921 
      922 dcl  tx fixed bin;
      923 
      924 		if filling_buffer then do;
      925 		     substr (ob, nextb, 1) = QUOTE;
      926 		     nextb = nextb + 1;
      927 		end;
      928 		else do;
      929 		     substr (ol, next, 1) = QUOTE;
      930 		     next = next + 1;
      931 		end;
      932 txl:		tx = index (substr (il, start, stop-start), ";");
      933 		if tx ^= 0 then do;
      934 		     if filling_buffer then do;
      935 			substr (ob, nextb, tx+1) = substr (il, start, tx) || QUOTE;
      936 			nextb = nextb + tx+1;
      937 			start = start + tx;
      938 		     end;
      939 		     else do;
      940 			substr (ol, next, tx+1) = substr (il, start, tx) || QUOTE;
      941 			next = next + tx+1;
      942 			start = start + tx;
      943 		     end;
      944 		     go to txl;
      945 		end;
      946 
      947 copy_line:	entry;
      948 
      949 		len1 = stop - start + 1;
      950 copy_line_len:	entry;
      951 
      952 		if filling_buffer then do;
      953 		     substr (ob, nextb, len1) = substr (il, start, len1);
      954 		     nextb = nextb + len1;
      955 		end;
      956 		else do;
      957 		     substr (ol, next, len1) = substr (il, start, len1);
      958 		     next = next + len1;
      959 		end;
      960 		return;
      961 
      962 
      963 	     end;
      964 
      965 skip_to_next_line: proc;
      966 
      967 		start = stop+1;			/* get start of next line */
      968 dcl  nparens fixed bin;
      969 
      970 		nparens = 0;
      971 		stop = start;
      972 more:		t = search (substr (il, stop), ENDS)-1;
      973 		if t < 0 then do;
      974 		     stop = nchars + 1;
      975 		     return;
      976 		end;
      977 		stop = stop + t;
      978 		if substr (il, stop, 1) = "(" then nparens = nparens + 1;
      979 		else if substr (il, stop, 1) = ")" then nparens = nparens - 1;
      980 		else if substr (il, stop, 1) = ";" & nparens > 0 then; /* ignore ";" unless outside "()" */
      981 		else do;
      982 		     if level = 1 & substr (il, stop, 1) = NL then line_no = line_no + 1;
      983 		     return;
      984 		end;
      985 		stop = stop + 1;
      986 		go to more;
      987 
      988 	     end;
      989 						/*  */
      990 sob:	     proc;
      991 
      992 		t = verify (substr (il, ci, stop-ci+1), WHITE)-1;
      993 		if t < 0 then goto output_current_line;
      994 		ci = ci + t;
      995 		return;
      996 
      997 	     end;
      998 soc:	     proc;
      999 
     1000 dcl  nparens fixed bin;
     1001 
     1002 		nparens = 0;
     1003 more:		t = search (substr (il, ci, stop-ci+1), "()	 """)-1;
     1004 		if t < 0 then do;
     1005 		     ci = stop+1;
     1006 		     return;
     1007 		end;
     1008 		ci = ci + t;
     1009 		c = substr (il, ci, 1);
     1010 		if c = "(" then nparens = nparens + 1;
     1011 		else if c = ")" then nparens = nparens - 1;
     1012 		else if nparens = 0 then return;
     1013 		ci = ci + 1;
     1014 		goto more;
     1015 
     1016 	     end;
     1017 	end scan_buffer;
     1018 
     1019      end mexp;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1455.8  mexp.pl1                          >dumps>old>recomp>mexp.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COMMA_NL                               constant        char(2)                  initial unaligned dcl 16 ref 684
ENDS                            000001 constant        char(4)                  initial unaligned dcl 16 ref 972
NL                                     constant        char(1)                  initial unaligned dcl 16 ref 311 497 500 982
QUOTE                           007760 constant        char(1)                  initial dcl 16 ref 321 338 486 498 925 929 935 940
TAB                                    constant        char(1)                  initial unaligned dcl 16 ref 303
TERM                                   constant        char(2)                  initial unaligned dcl 16 ref 794 869
WHITE                                  constant        char(2)                  initial unaligned dcl 16 ref 688 756 992
WHITE_TERM                      000000 constant        char(4)                  initial unaligned dcl 16 ref 759
a_level                                parameter       fixed bin(21,0)          dcl 201 ref 199 252
a_size                                 parameter       fixed bin(21,0)          dcl 201 ref 199 251
addr                                                   builtin function         dcl 16 ref 115 115 115 115 170 464 464 464 464 464
                                                                                  464 896
addrel                                                 builtin function         dcl 16 ref 150
arg                                    based           char                     unaligned dcl 16 ref 157
arg_len                         000405 automatic       fixed bin(17,0)          dcl 16 set ref 112* 113 115* 155* 157
arg_ptr                         000676 automatic       pointer                  dcl 16 set ref 112* 115* 155* 157
arg_start                       001331 automatic       fixed bin(21,0)          dcl 673 in procedure "scan_args" set ref 679* 691*
                                                                                  695 711 712 722 723 724* 725
arg_start                       000124 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 288* 296
                                                                                  298 304 312 313 322
args                            001006 automatic       structure                array level 1 dcl 233 set ref 536*
array                                  parameter       structure                array level 1 dcl 666 set ref 664
based_2_chars                          based           char(2)                  unaligned dcl 16 ref 170
baseno                                                 builtin function         dcl 16 ref 790
baseptr                                                builtin function         dcl 16 ref 517
bit_count                              parameter       fixed bin(24,0)          dcl 738 in procedure "build_macros" ref 736 743
bit_count                       000102 automatic       fixed bin(24,0)          dcl 16 in procedure "mexp" set ref 125* 136 446*
                                                                                  451* 470* 475*
bp                              000302 automatic       pointer                  array dcl 16 set ref 150* 171* 258 259
c                               000402 automatic       char(1)                  dcl 16 in procedure "mexp" set ref 292* 295 303 303
                                                                                  311 311 321 350* 351 494* 495 497 497 500 810* 818
                                                                                  819 820 821 830 843 850 851 852 858 865 866 1009*
                                                                                  1010 1011
c                               001366 automatic       char(1)                  dcl 902 in procedure "get_numeric_value" set ref
                                                                                  907* 908 909 911
c2                              001330 automatic       char(2)                  dcl 670 set ref 682* 684 684 684 684
char_count                      000100 automatic       fixed bin(21,0)          dcl 16 set ref 136* 173*
ci                              000102 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 284* 288
                                                                                  292 297 298 299* 299 305 312 314 322 331* 331 338
                                                                                  340 342 343 350 351 351 353 354 356* 359 361 362
                                                                                  679* 680 682 689* 690* 691 693 693 694 695* 699
                                                                                  701* 701* 702 703* 712 717 717 718* 719* 719 723
                                                                                  724 724* 745* 749 755 761* 762 763* 992 992 994*
                                                                                  994 1003 1003 1005* 1008* 1008 1009 1013* 1013
ci                                     parameter       fixed bin(21,0)          dcl 776 in procedure "build_macro" set ref 774 794
                                                                                  796* 796 799 800* 800* 802 803* 808 810 816* 816
                                                                                  868 869 870* 871* 871 877 878* 879* 879 883* 883
                                                                                  906* 906 906* 907*
code                            000103 automatic       fixed bin(35,0)          dcl 16 set ref 112* 113 115* 116 125* 127* 133* 140*
                                                                                  142* 143 144* 146* 155* 156 174* 176 177* 179* 180
                                                                                  180* 183* 184 184* 185* 186* 187* 188* 189* 390*
                                                                                  391 437* 438 446* 448* 464* 465 466* 470* 472*
com_err_                        000026 constant        entry                    external dcl 16 ref 108 127 153 177 178 180 184 254
                                                                                  323 324 376 448 466 472 482 642 706 766 826 838
                                                                                  876 890
convert_binary_integer_$decimal_string
                                000014 constant        entry                    external dcl 16 ref 593
convert_binary_integer_$octal_string
                                000010 constant        entry                    external dcl 16 ref 566
count                                  parameter       fixed bin(21,0)          dcl 673 ref 664 680
cu_$arg_count                   000040 constant        entry                    external dcl 16 ref 105
cu_$arg_ptr                     000036 constant        entry                    external dcl 16 ref 112 155
cv_dec_check_                   000016 constant        entry                    external dcl 16 ref 390 437
dirname                         000176 automatic       char(168)                unaligned dcl 16 set ref 115 115 125* 127*
dirname_p                       000410 automatic       char(168)                unaligned dcl 16 set ref 460* 464 464 470* 472*
discard                         000117 automatic       fixed bin(17,0)          dcl 16 set ref 390*
divide                                                 builtin function         dcl 16 ref 136 743
dummy_dcl                              based           structure                level 1 packed unaligned dcl 16
ename                           000250 automatic       char(32)                 unaligned dcl 16 set ref 115 115 118 119 120* 123
                                                                                  125* 127*
ename2                          000462 automatic       char(32)                 unaligned dcl 16 set ref 131* 133* 144* 178* 180*
                                                                                  184*
ename_p                         000472 automatic       char(32)                 unaligned dcl 16 set ref 461* 464 464 470* 472*
end_index                       000133 automatic       fixed bin(21,0)          dcl 203 set ref 379* 408 415 418 436*
entry                    14            based           structure                array level 2 dcl 237 set ref 896
entry_no                        000104 automatic       fixed bin(21,0)          dcl 16 set ref 553* 554 556 559 560 612* 616 626*
                                                                                  798* 807 808 815 831 836 847 848 856 863 882* 892
                                                                                  893 896
exargs                          000476 automatic       structure                array level 1 dcl 229 set ref 622*
expand_path_                    000024 constant        entry                    external dcl 16 ref 115 464
filling_buffer                  000116 automatic       bit(1)                   unaligned dcl 203 set ref 261* 266 271 406* 419 512
                                                                                  514* 924 934 952
find_include_file_$initiate_count
                                000030 constant        entry                    external dcl 16 ref 446
first                                  parameter       fixed bin(21,0)          array level 2 dcl 666 set ref 711* 722*
first_char               17            based           fixed bin(21,0)          array level 3 dcl 237 set ref 556 807*
firstx                                 parameter       fixed bin(21,0)          dcl 673 ref 664 679
found_number                    000110 automatic       bit(1)                   dcl 203 set ref 813 905* 910*
fourth_char               0(27)        based           char(1)                  level 2 packed unaligned dcl 16 set ref 170
fp                              000700 automatic       pointer                  dcl 16 set ref 140* 141 142* 159 186*
get_wdir_                       000012 constant        entry                    external dcl 16 ref 133 133
hcs_$delentry_seg               000034 constant        entry                    external dcl 16 ref 185 186 187
hcs_$fs_move_seg                000022 constant        entry                    external dcl 16 ref 174
hcs_$initiate_count             000032 constant        entry                    external dcl 16 ref 125 470
hcs_$make_seg                   000044 constant        entry                    external dcl 16 ref 133 140 144 146
hcs_$set_bc_seg                 000020 constant        entry                    external dcl 16 ref 179 183
hcs_$terminate_noname           000050 constant        entry                    external dcl 16 ref 188 189
hcs_$truncate_seg               000046 constant        entry                    external dcl 16 ref 142
i                               001332 automatic       fixed bin(21,0)          dcl 673 in procedure "scan_args" set ref 676* 677*
i                               000112 automatic       fixed bin(21,0)          dcl 16 in procedure "mexp" set ref 149* 150 150*
                                                                                  154* 155 157*
i                               000101 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 353* 355
                                                                                  356 493* 494* 539* 540* 563* 566 571* 575* 579*
                                                                                  594* 595 596 619* 620 622* 815 834 834* 836 856
                                                                                  861 861* 863 904* 911* 911
ia                              000132 automatic       fixed bin(21,0)          dcl 203 set ref 385* 386*
ifargs                          000166 automatic       structure                array level 1 dcl 225 set ref 381*
il                                     based           char                     unaligned dcl 203 ref 273 277 292 307 316 324 324
                                                                                  338 345 350 351 374 382 395 403 418 431 437 437
                                                                                  445 458 480 494 523 587 606 682 688 699 702 703
                                                                                  717 932 935 940 953 957 972 978 979 980 982 992
                                                                                  1003 1009
ilp                             000272 automatic       pointer                  dcl 16 set ref 125* 126 170 170* 170 171 188* 491*
in_iteration                    001355 automatic       fixed bin(17,0)          dcl 782 set ref 785* 822 837 841* 844* 844 845 888
index                                                  builtin function         dcl 16 ref 118 351 374 431 480 717 749 877 932
input_arg                       000502 automatic       varying char(32)         initial array dcl 16 set ref 16* 157* 386 599 600
iterate                         000106 automatic       fixed bin(21,0)          dcl 203 set ref 549* 585 587 592 611* 611 618* 625
iterate_arg_no                  000155 automatic       fixed bin(21,0)          dcl 203 set ref 617* 619 621
j                               000105 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 374* 375
                                                                                  379 431* 432 436 480* 481 485 621* 622* 749* 750
                                                                                  755
j                               000113 automatic       fixed bin(21,0)          dcl 16 in procedure "mexp" set ref 118* 119 119 119
                                                                                  120 121* 121 123
lab_end                         000137 automatic       fixed bin(21,0)          dcl 203 set ref 297* 402 522 545
lab_start                       000136 automatic       fixed bin(21,0)          dcl 203 set ref 283* 296* 400 402 403 521 522 523
                                                                                  544 545 546
last                            001333 automatic       fixed bin(21,0)          dcl 673 set ref 680* 693* 694* 701 717 718 725
last_macro                      000106 automatic       pointer                  dcl 16 set ref 167* 509 894 895*
len                                    parameter       fixed bin(21,0)          dcl 776 in procedure "build_macro" ref 774 788
len                       1     000166 automatic       fixed bin(21,0)          array level 2 in structure "ifargs" dcl 225
                                                                                  in procedure "scan_buffer" set ref 382 395
len                             000130 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 554* 555
                                                                                  556 556 557 585* 586 587 587 588 599* 600 601 605*
                                                                                  606 606 607 747* 762* 763*
len                       1     000476 automatic       fixed bin(21,0)          array level 2 in structure "exargs" dcl 229
                                                                                  in procedure "scan_buffer" set ref 585
len                       1     001006 automatic       fixed bin(21,0)          array level 2 in structure "args" dcl 233
                                                                                  in procedure "scan_buffer" set ref 540* 545* 548*
                                                                                  605 619 630
len1                            000127 automatic       fixed bin(21,0)          dcl 203 set ref 402* 403 403 404 415* 489* 491* 522*
                                                                                  523 523 524 949* 953 953 954 957 957 958
len_op                          000125 automatic       fixed bin(21,0)          dcl 203 set ref 306* 307 315* 316 344* 345
length                                                 builtin function         dcl 16 ref 594 599
level                           000122 automatic       fixed bin(17,0)          dcl 203 set ref 252* 253 258 259 266 418 419 500 503
                                                                                  513 646 982
line_no                         000403 automatic       fixed bin(17,0)          dcl 16 set ref 168* 323* 376* 466* 482* 500* 500
                                                                                  503* 503 706* 766* 982* 982
macro                                  based           structure                level 1 dcl 237
macro_len                       000107 automatic       fixed bin(21,0)          dcl 203 set ref 485* 556 743* 749 756 759 788 794
                                                                                  800 800 802 803 810 868 869 870 877 878 907
match                           000135 automatic       bit(1)                   dcl 203 set ref 384* 385 386* 391* 392* 392 395*
                                                                                  396* 397* 397 414 418 425 435*
max_char_count                  000702 automatic       fixed bin(21,0)          dcl 16 set ref 104* 273 277 403 486 495 498 523 556
                                                                                  564 567 580 587 595 600 606 925 929 935 940 953
                                                                                  957
mbp                             000300 automatic       pointer                  dcl 16 set ref 146* 147 150 187*
min                                                    builtin function         dcl 16 ref 106
ml                                     based           char                     unaligned dcl 203 in procedure "scan_buffer" ref 556
                                                                                  749 756 759
ml                                     based           char                     dcl 778 in procedure "build_macro" ref 788 794 800
                                                                                  810 868 869 877 907
mp                                     parameter       pointer                  dcl 776 in procedure "build_macro" ref 774 788 790
                                                                                  794 800 810 868 869 877 907
mp                                     parameter       pointer                  dcl 738 in procedure "build_macros" set ref 736 763*
mp                              000162 automatic       pointer                  dcl 203 in procedure "scan_buffer" set ref 446* 447
                                                                                  451* 470* 471 475* 517* 556 749 756 759
mstart                          000144 automatic       fixed bin(21,0)          dcl 203 set ref 755* 756 758
my_name                         000113 constant        char(4)                  initial dcl 16 ref 108 127 153 177 178 180 184 323
                                                                                  324 376 448 466 472 482 642 706 766 826 838 876
                                                                                  890
n_chars                  20            based           fixed bin(21,0)          array level 3 dcl 237 set ref 554 808*
name                      3            based           varying char(32)         level 2 dcl 237 set ref 510 788* 826* 838* 876* 890*
nargs                           000121 automatic       fixed bin(17,0)          dcl 203 in procedure "scan_buffer" set ref 536* 542*
                                                                                  604 634
nargs                           000404 automatic       fixed bin(17,0)          dcl 16 in procedure "mexp" set ref 105* 106 107 153
nchars                          000123 automatic       fixed bin(21,0)          dcl 203 set ref 251* 265 273 277 292 307 316 324 324
                                                                                  338 345 350 351 374 382 395 403 418 431 437 437
                                                                                  445 458 480 494 523 587 606 682 686 688 699 702
                                                                                  703 717 932 935 940 953 957 972 974 978 979 980
                                                                                  982 992 1003 1009
next                            000101 automatic       fixed bin(21,0)          dcl 16 set ref 169* 179 183 277 278* 278 486 487*
                                                                                  487 495 496* 496 498 499* 499 929 930* 930 940
                                                                                  941* 941 957 958* 958
next_macro                             based           pointer                  level 2 packed unaligned dcl 237 set ref 651 894*
nextb                           000131 automatic       fixed bin(21,0)          dcl 203 set ref 260* 266 273 274* 274 403 404* 404
                                                                                  419 513 515* 523 524* 524 556 557* 557 564 565*
                                                                                  565 567 568* 568 580 587 588* 588 595 596* 596 600
                                                                                  601* 601 606 607* 607 646 647* 925 926* 926 935
                                                                                  936* 936 953 954* 954
no_args                                parameter       fixed bin(17,0)          dcl 673 set ref 664 681* 710* 710 711 712 721* 721
                                                                                  722 723
no_exargs                       000406 automatic       fixed bin(17,0)          dcl 16 set ref 622* 624* 625 638
no_ifargs                       000407 automatic       fixed bin(17,0)          dcl 16 set ref 381*
no_input_args                   000634 automatic       fixed bin(17,0)          dcl 16 set ref 106* 154 385
nparens                         000100 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 700* 701
                                                                                  702* 702 703* 703 705
nparens                         001406 automatic       fixed bin(17,0)          dcl 968 in procedure "skip_to_next_line" set ref
                                                                                  970* 978* 978 979* 979 980
nparens                         001424 automatic       fixed bin(17,0)          dcl 1000 in procedure "soc" set ref 1002* 1010* 1010
                                                                                  1011* 1011 1012
ntimes                          000134 automatic       fixed bin(21,0)          dcl 203 set ref 399* 409* 409 410 437*
null                                                   builtin function         dcl 16 ref 126 134 141 145 147 167 447 471 509
num_entries               2            based           fixed bin(17,0)          level 2 dcl 237 set ref 553 893*
ob                                     based           char                     unaligned dcl 203 set ref 273* 403* 523* 556* 564*
                                                                                  567* 580* 587* 595* 600* 606* 925* 935* 953*
obp                             000160 automatic       pointer                  dcl 203 set ref 259* 273 403 523 556 564 567 580 587
                                                                                  595 600 606 925 935 953
ol                                     based           char                     dcl 16 set ref 277* 486* 495* 498* 929* 940* 957*
old_free                        000110 automatic       pointer                  dcl 16 set ref 159* 490 492* 744 751*
olp                             000276 automatic       pointer                  dcl 16 set ref 144* 145 174* 179* 185* 277 486 495
                                                                                  498 929 940 957
op_end                          000141 automatic       fixed bin(21,0)          dcl 203 set ref 305* 306 314* 315 342* 343* 343 344
op_start                        000140 automatic       fixed bin(21,0)          dcl 203 set ref 283* 304* 306 307 313* 315 316 340*
                                                                                  344 345 367
opcode                          000145 automatic       char(32)                 dcl 203 set ref 307* 316* 345* 349 349 349 373 373
                                                                                  373 373 373 376* 383 389 389 392 397 430 442 455
                                                                                  479 510
outp                            000274 automatic       pointer                  dcl 16 set ref 133* 134 174* 183* 189*
path                            000124 automatic       char(168)                dcl 16 set ref 445* 446* 448* 458* 459 464 464
pfree                           000112 automatic       pointer                  dcl 203 set ref 490* 492 509* 509* 510 517 553 554
                                                                                  556 559 560 626* 651 744* 751 787 788 790 807 808
                                                                                  815 826 836 838 847 848 856 863 876 882 890 892
                                                                                  893 894 896* 896
ptr                                                    builtin function         dcl 16 ref 159
save_free                       000114 automatic       fixed bin(21,0)          dcl 203 set ref 612 616* 626 831* 847 848
save_start                      000156 automatic       fixed bin(21,0)          dcl 203 set ref 411 434*
segno                     1            based           fixed bin(17,0)          level 2 dcl 237 set ref 517 790*
si                              000111 automatic       fixed bin(21,0)          dcl 203 set ref 811* 832* 853* 859* 907
size                      1            parameter       fixed bin(21,0)          array level 2 dcl 666 set ref 677* 712* 723*
sname                           000260 automatic       varying char(32)         dcl 16 set ref 123* 131
start                           000166 automatic       fixed bin(21,0)          array level 2 in structure "ifargs" dcl 225
                                                                                  in procedure "scan_buffer" set ref 382 395
start                           001354 automatic       fixed bin(21,0)          dcl 781 in procedure "build_macro" set ref 799* 800
                                                                                  807 808
start                           000103 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 270 284
                                                                                  324 324 324 324 415 493 688 688 690 932 932 935
                                                                                  937* 937 940 942* 942 949 953 957 967* 971
start                           000476 automatic       fixed bin(21,0)          array level 2 in structure "exargs" dcl 229
                                                                                  in procedure "scan_buffer" set ref 587
start                           001006 automatic       fixed bin(21,0)          array level 2 in structure "args" dcl 233
                                                                                  in procedure "scan_buffer" set ref 546* 606 621
start_name                      000126 automatic       fixed bin(21,0)          dcl 203 in procedure "scan_buffer" set ref 488* 491*
                                                                                  758* 759 761 762 763*
start_name                             parameter       fixed bin(21,0)          dcl 776 in procedure "build_macro" ref 774 788
stop                            000104 automatic       fixed bin(21,0)          dcl 203 set ref 250* 265 270 273 277 324 324 343 351
                                                                                  362 374 379 408 411* 431 434 436 480 485 491* 493
                                                                                  686 688 689 693 932 949 967 971* 972 974* 977* 977
                                                                                  978 979 980 982 985* 985 992 1003 1005
substr                                                 builtin function         dcl 16 set ref 119 120* 123 273* 273 277* 277 292
                                                                                  307 316 324 324 338 345 350 351 374 382 395 403*
                                                                                  403 418 431 437 437 445 458 480 486* 494 495* 498*
                                                                                  523* 523 556* 556 564* 567* 567 580* 587* 587 595*
                                                                                  600* 606* 606 682 688 699 702 703 717 749 756 759
                                                                                  788 794 800 810 868 869 877 907 925* 929* 932 935*
                                                                                  935 940* 940 953* 953 957* 957 972 978 979 980 982
                                                                                  992 1003 1009
sys_info$max_seg_size           000042 external static fixed bin(35,0)          dcl 16 ref 104
t                               000117 automatic       fixed bin(21,0)          dcl 203 set ref 351* 352 353 688* 689 690 717* 718
                                                                                  719 756* 757 758 759* 760 761 794* 795 796 869*
                                                                                  870 871 877* 878 879 972* 973 977 992* 993 994
                                                                                  1003* 1004 1008
targ                            000635 automatic       varying char(128)        dcl 16 set ref 382* 386 390 395
tfree                           001352 automatic       pointer                  dcl 779 set ref 787* 895
tp                              000164 automatic       pointer                  dcl 203 set ref 258* 273 277 292 307 316 324 324 338
                                                                                  345 350 351 374 382 395 403 418 431 437 437 445
                                                                                  446* 458 480 494 523 587 606 682 688 699 702 703
                                                                                  717 932 935 940 953 957 972 978 979 980 982 992
                                                                                  1003 1009
tx                              001376 automatic       fixed bin(17,0)          dcl 922 set ref 932* 933 935 935 936 937 940 940 941
                                                                                  942
type                     14            based           fixed bin(17,0)          array level 3 in structure "macro" dcl 237
                                                                                  in procedure "scan_buffer" set ref 560 882* 892*
type                            000120 automatic       fixed bin(17,0)          dcl 203 in procedure "scan_buffer" set ref 560* 561
                                                                                  570 574 578 584 591 598 603 610 615 629 633 637
                                                                                  641 814* 818* 819* 820* 823* 835* 846* 850* 851*
                                                                                  855* 862* 865* 866* 882
type_CLOSE                             constant        fixed bin(17,0)          initial dcl 86 ref 610 846
type_COMMAND_ARG                       constant        fixed bin(17,0)          initial dcl 89 ref 598 855
type_COMMAND_ARGNO                     constant        fixed bin(17,0)          initial dcl 87 ref 591 850
type_ENDM                              constant        fixed bin(17,0)          initial dcl 93 ref 641 892
type_ITERATE                           constant        fixed bin(17,0)          initial dcl 84 ref 584 823
type_LENGTH                            constant        fixed bin(17,0)          initial dcl 90 ref 629 862
type_NARGS                             constant        fixed bin(17,0)          initial dcl 91 ref 633 865
type_NEXT_UNIQUE                       constant        fixed bin(17,0)          initial dcl 83 ref 574 820
type_NITER                             constant        fixed bin(17,0)          initial dcl 92 ref 637 866
type_NORMAL                            constant        fixed bin(17,0)          initial dcl 80 ref 603 814
type_OPEN                              constant        fixed bin(17,0)          initial dcl 85 ref 615 835
type_PREV_UNIQUE                       constant        fixed bin(17,0)          initial dcl 81 ref 570 818
type_SPEC_UNIQUE                       constant        fixed bin(17,0)          initial dcl 88 ref 578 851
type_UNIQUE                            constant        fixed bin(17,0)          initial dcl 82 ref 561 819
unique_changed                  000116 automatic       bit(1)                   initial dcl 16 set ref 16* 528 530* 581*
unique_generator                000114 automatic       fixed bin(17,0)          initial dcl 16 set ref 16* 562* 562 563 571 575
unique_generator1               000115 automatic       fixed bin(17,0)          initial dcl 16 set ref 16* 529* 529 579
unspec                                                 builtin function         dcl 16 ref 911
val                             000115 automatic       fixed bin(17,0)          dcl 203 set ref 559* 592* 593* 599 600 604 605 606
                                                                                  617 630* 630 634* 638*
value_1                  15            based           fixed bin(17,0)          array level 3 dcl 237 set ref 559 815* 836* 847*
                                                                                  856* 863*
value_2                  16            based           fixed bin(17,0)          array level 3 dcl 237 set ref 626 848*
var_end                         000143 automatic       fixed bin(21,0)          dcl 203 set ref 355* 361* 362* 362 381 437 437 445
                                                                                  458 464 489 536
var_start                       000142 automatic       fixed bin(21,0)          dcl 203 set ref 283* 354* 359* 380 381* 381 433 437
                                                                                  437 437 437 444 445 445 457 458 458 464 488 489
                                                                                  535 536* 536
vc                              000120 automatic       varying char(12)         dcl 16 set ref 566* 567 593* 594 595

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
p                                      automatic       pointer                  dcl 203

NAMES DECLARED BY EXPLICIT CONTEXT.
ANOTHER_MACRO                   005074 constant        label                    dcl 747 ref 764
ANY_ARGS_Q                      004436 constant        label                    dcl 625 ref 613
BAD_MACRO_DEF                   005733 constant        label                    dcl 876 in procedure "build_macro" ref 795
BAD_MACRO_DEF                   005211 constant        label                    dcl 766 in procedure "build_macros" ref 757 760
BAD_MACRO_FILE                  003374 constant        label                    dcl 466 ref 444 449 473
BAD_PSEUDO                      002471 constant        label                    dcl 376 ref 380 432 433 438
ERROR                           001420 constant        label                    dcl 174 ref 255 643
FIN_MACRO                       006032 constant        label                    dcl 888 ref 804 827 839 872
GETLINE                         002010 constant        label                    dcl 262 ref 280 326 422 452 467 476 648 658
GET_ANOTHER_ARG                 004606 constant        label                    dcl 682 ref 696 725
GET_ANOTHER_LINE                002754 constant        label                    dcl 407 ref 412 426
INE_JOIN                        002727 constant        label                    dcl 400 ref 439
NEXT_ARG                        005051 constant        label                    dcl 724 ref 713
NOMOREARGS                      001365 constant        label                    dcl 159 ref 156
PUTNUM                          004275 constant        label                    dcl 593 ref 631 635 639
UNIQUE                          004154 constant        label                    dcl 564 ref 572 576
UNIQUE1                         004161 constant        label                    dcl 565 ref 582
USAGE                           000505 constant        label                    dcl 108 ref 113 116 134 141 143 145 147
bad_iter                        006034 constant        label                    dcl 890 ref 845
build_macro                     005246 constant        entry                    internal dcl 774 ref 491 763
build_macros                    005062 constant        entry                    internal dcl 736 ref 451 475
check_char                      002076 constant        label                    dcl 292 ref 332
copy_line                       006312 constant        entry                    internal dcl 947 ref 325 425 657
copy_line_len                   006320 constant        entry                    internal dcl 950 ref 416
copy_line_quoted                006161 constant        entry                    internal dcl 920 ref 443 456 527 687
copy_terminator                 002040 constant        label                    dcl 271 ref 504
get_numeric_value               006110 constant        entry                    internal dcl 900 ref 812 833 854 860
mexp                            000436 constant        entry                    external dcl 11
more                            006475 constant        label                    dcl 1003 in procedure "soc" ref 1014
more                            006366 constant        label                    dcl 972 in procedure "skip_to_next_line" ref 986
nopath                          003331 constant        label                    dcl 460 ref 457
output_current_line             002423 constant        label                    dcl 367 ref 318 328 338 352 357 993
scan_args                       004562 constant        entry                    internal dcl 664 ref 381 536 622
scan_buffer                     001730 constant        entry                    internal dcl 199 ref 173 266 419 513 646
scan_opcode                     002303 constant        label                    dcl 336 ref 300
scan_var                        002336 constant        label                    dcl 347 ref 308
skip_to_next_line               006360 constant        entry                    internal dcl 965 ref 262 407 685
sob                             006451 constant        entry                    internal dcl 990 ref 285 336 347
soc                             006473 constant        entry                    internal dcl 998 ref 341 360 692
syn                             002172 constant        label                    dcl 323 ref 298
txl                             006202 constant        label                    dcl 932 ref 944

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 790 911
search                                                 builtin function         ref 759 794 869 972 1003
verify                                                 builtin function         ref 688 756 992

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10212       10264    7764       10222
Length     10476    7764        52         175     226           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mexp                                603 external procedure  is an external procedure.  
scan_buffer                        1015 internal procedure  calls itself recursively.  
scan_args                               internal procedure  shares stack frame of internal procedure scan_buffer.  
build_macros                            internal procedure  shares stack frame of internal procedure scan_buffer.  
build_macro                             internal procedure  shares stack frame of internal procedure scan_buffer.  
get_numeric_value                       internal procedure  shares stack frame of internal procedure scan_buffer.  
copy_line_quoted                        internal procedure  shares stack frame of internal procedure scan_buffer.  
skip_to_next_line                       internal procedure  shares stack frame of internal procedure scan_buffer.  
sob                                     internal procedure  shares stack frame of internal procedure scan_buffer.  
soc                                     internal procedure  shares stack frame of internal procedure scan_buffer.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mexp                     000100 char_count                  mexp
                         000101 next                        mexp
                         000102 bit_count                   mexp
                         000103 code                        mexp
                         000104 entry_no                    mexp
                         000106 last_macro                  mexp
                         000110 old_free                    mexp
                         000112 i                           mexp
                         000113 j                           mexp
                         000114 unique_generator            mexp
                         000115 unique_generator1           mexp
                         000116 unique_changed              mexp
                         000117 discard                     mexp
                         000120 vc                          mexp
                         000124 path                        mexp
                         000176 dirname                     mexp
                         000250 ename                       mexp
                         000260 sname                       mexp
                         000272 ilp                         mexp
                         000274 outp                        mexp
                         000276 olp                         mexp
                         000300 mbp                         mexp
                         000302 bp                          mexp
                         000402 c                           mexp
                         000403 line_no                     mexp
                         000404 nargs                       mexp
                         000405 arg_len                     mexp
                         000406 no_exargs                   mexp
                         000407 no_ifargs                   mexp
                         000410 dirname_p                   mexp
                         000462 ename2                      mexp
                         000472 ename_p                     mexp
                         000502 input_arg                   mexp
                         000634 no_input_args               mexp
                         000635 targ                        mexp
                         000676 arg_ptr                     mexp
                         000700 fp                          mexp
                         000702 max_char_count              mexp
scan_buffer              000100 nparens                     scan_buffer
                         000101 i                           scan_buffer
                         000102 ci                          scan_buffer
                         000103 start                       scan_buffer
                         000104 stop                        scan_buffer
                         000105 j                           scan_buffer
                         000106 iterate                     scan_buffer
                         000107 macro_len                   scan_buffer
                         000110 found_number                scan_buffer
                         000111 si                          scan_buffer
                         000112 pfree                       scan_buffer
                         000114 save_free                   scan_buffer
                         000115 val                         scan_buffer
                         000116 filling_buffer              scan_buffer
                         000117 t                           scan_buffer
                         000120 type                        scan_buffer
                         000121 nargs                       scan_buffer
                         000122 level                       scan_buffer
                         000123 nchars                      scan_buffer
                         000124 arg_start                   scan_buffer
                         000125 len_op                      scan_buffer
                         000126 start_name                  scan_buffer
                         000127 len1                        scan_buffer
                         000130 len                         scan_buffer
                         000131 nextb                       scan_buffer
                         000132 ia                          scan_buffer
                         000133 end_index                   scan_buffer
                         000134 ntimes                      scan_buffer
                         000135 match                       scan_buffer
                         000136 lab_start                   scan_buffer
                         000137 lab_end                     scan_buffer
                         000140 op_start                    scan_buffer
                         000141 op_end                      scan_buffer
                         000142 var_start                   scan_buffer
                         000143 var_end                     scan_buffer
                         000144 mstart                      scan_buffer
                         000145 opcode                      scan_buffer
                         000155 iterate_arg_no              scan_buffer
                         000156 save_start                  scan_buffer
                         000160 obp                         scan_buffer
                         000162 mp                          scan_buffer
                         000164 tp                          scan_buffer
                         000166 ifargs                      scan_buffer
                         000476 exargs                      scan_buffer
                         001006 args                        scan_buffer
                         001330 c2                          scan_args
                         001331 arg_start                   scan_args
                         001332 i                           scan_args
                         001333 last                        scan_args
                         001352 tfree                       build_macro
                         001354 start                       build_macro
                         001355 in_iteration                build_macro
                         001366 c                           get_numeric_value
                         001376 tx                          copy_line_quoted
                         001406 nparens                     skip_to_next_line
                         001424 nparens                     soc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_e_as              alloc_cs            call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              fl2_to_fx1          tra_ext             shorten_stack       ext_entry
int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_binary_integer_$decimal_string
convert_binary_integer_$octal_string                        cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 expand_path_                  find_include_file_$initiate_count
get_wdir_                     hcs_$delentry_seg             hcs_$fs_move_seg              hcs_$initiate_count
hcs_$make_seg                 hcs_$set_bc_seg               hcs_$terminate_noname         hcs_$truncate_seg

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000435        16 000443       104 000462       105 000466       106 000474       107 000502       108 000505
    109 000534       112 000535       113 000554       115 000560       116 000603       118 000605       119 000616
    120 000625       121 000630       123 000632       125 000643       126 000705       127 000711       128 000746
    131 000747       133 000765       134 001037       136 001043       140 001046       141 001111       142 001115
    143 001131       144 001133       145 001171       146 001175       147 001241       149 001245       150 001252
    151 001262       153 001264       154 001316       155 001325       156 001344       157 001346       158 001363
    159 001365       167 001367       168 001371       169 001372       170 001374       171 001405       173 001407
    174 001420       176 001437       177 001441       178 001467       179 001522       180 001541       181 001575
    183 001576       184 001615       185 001651       186 001662       187 001673       188 001704       189 001715
    190 001726       199 001727       250 001735       251 001736       252 001741       253 001743       254 001745
    255 001773       258 001776       259 002002       260 002005       261 002007       262 002010       265 002011
    266 002014       267 002035       270 002036       271 002040       273 002042       274 002051       275 002052
    277 002053       278 002063       280 002064       283 002065       284 002071       285 002073       288 002074
    292 002076       295 002105       296 002110       297 002112       298 002114       299 002116       300 002117
    303 002120       304 002124       305 002126       306 002131       307 002134       308 002140       311 002141
    312 002145       313 002150       314 002152       315 002155       316 002160       318 002164       321 002165
    322 002167       323 002172       324 002225       325 002275       326 002277       328 002300       331 002301
    332 002302       336 002303       338 002304       340 002312       341 002314       342 002315       343 002320
    344 002325       345 002331       347 002336       349 002337       350 002353       351 002362       352 002374
    353 002375       354 002401       355 002403       356 002405       357 002407       359 002410       360 002412
    361 002413       362 002416       367 002423       373 002425       374 002451       375 002470       376 002471
    377 002531       379 002532       380 002534       381 002536       382 002557       383 002572       384 002576
    385 002577       386 002610       387 002623       388 002625       389 002626       390 002636       391 002667
    392 002674       393 002702       395 002703       396 002715       397 002716       399 002725       400 002727
    402 002731       403 002735       404 002750       406 002752       407 002754       408 002755       409 002760
    410 002762       411 002764       412 002766       414 002767       415 002771       416 002775       418 002776
    419 003011       420 003031       422 003032       425 003033       426 003036       430 003037       431 003043
    432 003062       433 003063       434 003065       435 003067       436 003071       437 003073       438 003132
    439 003136       442 003137       443 003143       444 003144       445 003146       446 003173       447 003232
    448 003236       449 003271       451 003272       452 003303       455 003304       456 003310       457 003311
    458 003313       459 003325       460 003331       461 003335       462 003340       464 003341       465 003371
    466 003374       467 003427       470 003430       471 003472       472 003476       473 003535       475 003536
    476 003547       479 003550       480 003554       481 003573       482 003575       483 003631       485 003632
    486 003635       487 003643       488 003644       489 003646       490 003652       491 003654       492 003670
    493 003673       494 003703       495 003711       496 003716       497 003717       498 003724       499 003730
    500 003731       502 003737       503 003741       504 003747       509 003750       510 003757       512 003765
    513 003767       514 004006       515 004007       517 004011       521 004016       522 004020       523 004024
    524 004037       527 004041       528 004042       529 004045       530 004046       535 004047       536 004051
    537 004057       539 004060       540 004064       541 004066       542 004070       544 004071       545 004073
    546 004076       547 004100       548 004101       549 004102       553 004103       554 004115       555 004122
    556 004123       557 004137       559 004141       560 004145       561 004147       562 004151       563 004152
    564 004154       565 004161       566 004163       567 004202       568 004210       569 004212       570 004213
    571 004215       572 004217       574 004220       575 004222       576 004225       578 004226       579 004230
    580 004232       581 004237       582 004241       584 004242       585 004244       586 004251       587 004252
    588 004266       590 004270       591 004271       592 004273       593 004275       594 004307       595 004312
    596 004320       597 004321       598 004322       599 004324       600 004331       601 004340       602 004341
    603 004342       604 004344       605 004347       606 004353       607 004366       609 004370       610 004371
    611 004373       612 004374       613 004376       615 004377       616 004401       617 004403       618 004405
    619 004407       620 004414       621 004415       622 004420       623 004434       624 004435       625 004436
    626 004442       628 004447       629 004450       630 004452       631 004456       633 004457       634 004461
    635 004463       637 004464       638 004466       639 004470       641 004471       642 004473       643 004525
    645 004530       646 004533       647 004552       648 004554       651 004555       657 004560       658 004561
    664 004562       676 004564       677 004570       678 004574       679 004576       680 004602       681 004605
    682 004606       684 004614       685 004625       686 004626       687 004632       688 004633       689 004651
    690 004656       691 004660       692 004661       693 004662       694 004672       695 004675       696 004677
    699 004700       700 004705       701 004707       702 004717       703 004731       704 004735       705 004737
    706 004741       707 004775       710 004776       711 005000       712 005006       713 005013       717 005014
    718 005030       719 005035       721 005036       722 005040       723 005045       724 005051       725 005055
    727 005061       736 005062       743 005064       744 005067       745 005072       747 005074       749 005076
    750 005116       751 005117       752 005122       755 005123       756 005125       757 005145       758 005146
    759 005150       760 005166       761 005167       762 005171       763 005173       764 005210       766 005211
    767 005245       774 005246       785 005250       787 005251       788 005253       790 005266       794 005272
    795 005311       796 005312       798 005313       799 005316       800 005322       801 005340       802 005342
    803 005344       804 005346       807 005347       808 005356       810 005361       811 005370       812 005372
    813 005373       814 005375       815 005377       816 005406       817 005411       818 005412       819 005421
    820 005426       821 005433       822 005435       823 005437       824 005441       826 005442       827 005476
    829 005477       830 005500       831 005502       832 005504       833 005506       834 005507       835 005513
    836 005515       837 005524       838 005526       839 005561       841 005562       842 005564       843 005565
    844 005567       845 005571       846 005573       847 005575       848 005603       849 005607       850 005610
    851 005615       852 005622       853 005624       854 005626       855 005627       856 005631       857 005640
    858 005641       859 005643       860 005645       861 005646       862 005652       863 005654       864 005663
    865 005664       866 005671       868 005676       869 005706       870 005724       871 005731       872 005732
    876 005733       877 005767       878 006011       879 006016       882 006017       883 006026       885 006030
    888 006032       890 006034       892 006070       893 006077       894 006101       895 006103       896 006105
    897 006107       900 006110       904 006111       905 006112       906 006113       907 006125       908 006134
    909 006140       910 006144       911 006146       912 006156       914 006160       920 006161       924 006162
    925 006164       926 006171       927 006172       929 006173       930 006201       932 006202       933 006217
    934 006220       935 006222       936 006245       937 006252       938 006254       940 006255       941 006301
    942 006306       944 006310       947 006311       949 006313       950 006317       952 006321       953 006323
    954 006336       955 006340       957 006341       958 006355       960 006357       965 006360       967 006361
    970 006364       971 006365       972 006366       973 006406       974 006407       975 006412       977 006413
    978 006414       979 006425       980 006432       982 006437       983 006446       985 006447       986 006450
    990 006451       992 006452       993 006470       994 006471       995 006472       998 006473      1002 006474
   1003 006475      1004 006513      1005 006514      1006 006517      1008 006520      1009 006521      1010 006527
   1011 006534      1012 006541      1013 006544      1014 006545


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
