	COMPILATION LISTING OF SEGMENT lib_descriptor_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0854.3 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       12 	/*									*/
       13 	/* NAME:  lib_descriptor_							*/
       14 	/*									*/
       15 	/*     THis procedure interfaces between the various library maintenance tools and the	*/
       16 	/* library status gathering subroutines by mapping user-supplied (or default) library	*/
       17 	/* names into the pathnames of library directories or archives to be searched.  It 	*/
       18 	/* also provides a pre-defined, per-library search procedure to find library entries.	*/
       19 	/*									*/
       20 	/* ENTRIES:  $info, $map, $print, $fetch, $cleanup				*/
       21 	/*									*/
       22 	/*      These entries are provided to support the five basic library maintenance tools,	*/
       23 	/* library_info, library_map, library_print, library_fetch, and library_cleanup.  All	*/
       24 	/* perform the same basic function of gathering library status;  however, this status	*/
       25 	/* gathering operation often differs in depth of search, cross-referencing, default info	*/
       26 	/* returned, etc between the different library tools.				*/
       27 	/*									*/
       28 	/* ENTRIES:  $name, $set_name							*/
       29 	/*									*/
       30 	/*      These entries return and set the name of the library descriptor which is used	*/
       31 	/* by default to do the name mapping, etc.  The initial default value is the		*/
       32 	/* multics_libraries_ library descriptor.					*/
       33 	/*									*/
       34 	/* ENTRY:  $default_values	 						*/
       35 	/*									*/
       36 	/*      This entry returns information about the default library names and search names	*/
       37 	/* which are used by the various library tools.					*/
       38 	/*									*/
       39 	/* ENTRIES:  $libraries, $validate_library					*/
       40 	/*									*/
       41 	/*      These entries return information about the libraries defined in a given library	*/
       42 	/* descriptor, and validate the correctness of library names with respect to a given	*/
       43 	/* library descriptor.							*/
       44 	/*									*/
       45 	/* STATUS									*/
       46 	/*									*/
       47 	/* 0) Created on:   March 1, 1975  by  G. C. Dixon				*/
       48 	/* 1) Modified on:  May 25, 1976   by  G. C. Dixon				*/
       49 	/*    a) Use new library descriptor format provided by library_descriptor_compiler,	*/
       50 	/*       Version 3.0.							*/
       51 	/* 2) Modified on:  January 18, 1984 by Jim Lippard to add n_found			*/
       52 	/*									*/
       53 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       54 
       55 lib_descriptor_:	procedure;
       56 
       57 
       58      dcl						/*	parameters			*/
       59 	Adescriptor		char(168) varying;	/* name of a library descriptor. (In/Out)	*/
  1     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures for the arrays of library names and search*/
  1     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  1     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  1    10 	/* to the lib_descriptor_ subroutine.						*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  1    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  1    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  1    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  1    18 	/*									*/
  1    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    20 
  1    21 
  1    22      dcl	1 library			aligned based (Plibrary),
  1    23 						/* a structure containing names of libraries to	*/
  1    24 						/*   be searched.				*/
  1    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  1    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  1    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  1    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  1    30 						/*     this library name.			*/
  1    31 
  1    32      dcl	1 starname		aligned based (Pstarname),
  1    33 						/* a structure containing names of library entries*/
  1    34 						/*   being searched for.			*/
  1    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  1    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  1    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  1    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    39 						/*     this starname.			*/
  1    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  1    41 
  1    42      dcl	1 exclude			aligned based (Pexclude),
  1    43 						/* a structure containing names of library entries*/
  1    44 						/*   being excluded from the search.		*/
  1    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  1    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  1    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  1    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    49 						/*     this exclude.			*/
  1    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  1    51 
  1    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       60 
       61      dcl	1 bad_library		based (Pbad_library),
       62 	  2 N			fixed bin,
       63 	  2 group (0 refer (bad_library.N))
       64 				like library.group,
       65 	Pbad_library		ptr,
       66 	ASrequirements		bit(72) aligned,	/* requirement switches. (In)			*/
       67 	AScontrol			bit(36) aligned,	/* control switches. (In)			*/
       68 	Parea			ptr,		/* ptr to area in which status tree is to be	*/
       69 						/*    allocated. (In)			*/
       70 	Acommand			fixed bin,	/* index of a command using the descriptor. (In)	*/
       71 	Acommand_name		char(32),		/* name of command using the descriptor. (Out)	*/
       72 	ASunsupported		bit(1) unal,	/* on if command is not supported by the 	*/
       73 						/*    specified descriptor. (Out)		*/
       74 	Ptree			ptr,		/* ptr to status tree. (Out)			*/
       75 	progress			fixed bin,	/* integer identifying progress of search. (Out)	*/
       76 	Acode			fixed bin(35);	/* a status code. (Out)			*/
       77 
       78      dcl						/*	automatic variables			*/
       79 	Nnodes			fixed bin,	/* = dimension (root node array of status tree)	*/
       80 	Pnodes			ptr,		/* = addr (root node array of status tree)	*/
       81 	Prt			ptr,		/* = addr (rt).				*/
       82 	Sfound			bit(1) aligned,
       83 						/* switch:  on if library found.		*/
       84 	code			fixed bin(35),	/* a status code.				*/
       85          (i, j, k)			fixed bin;	/* do group indices.			*/
       86 
       87      dcl	1 command_info		aligned,		/* info passed to search routine		*/
       88 	  2 command		fixed bin,	/* index of command referencing descriptor.	*/
       89 	  2 n_found		fixed bin;	/* number of entries found			*/
       90 
       91      dcl						/* 	based variables			*/
       92 	area			area based (Parea),	/* an allocation area.			*/
       93 	1 rt			like root based (Prt);
       94 						/* overlay for a root.			*/
       95 
       96 
       97      dcl						/*	builtin functions			*/
       98          (addr, addrel, dimension, length, min, null, substr)
       99 				builtin;
      100 
      101 
      102      dcl						/*	entries				*/
      103 	cu_$decode_entry_value	entry (entry, ptr, ptr),
      104 	cv_entry_			entry (char(*), ptr, fixed bin(35)) returns (entry),
      105 	lib_free_node_$array	entry (ptr),
      106 	lib_get_tree_$root_array	entry (fixed bin, ptr, ptr, fixed bin(35)),
      107 	lib_get_tree_$root_array_info entry (ptr, fixed bin, fixed bin(35)),
      108 	lib_get_tree_$lib_root_node	entry (ptr, fixed bin, char(168) varying, char(65) varying, ptr, ptr,
      109 				       bit(72) aligned, bit(36) aligned, ptr,
      110 				       entry, ptr, ptr, fixed bin, fixed bin(35)),
      111 	match_star_name_		entry (char(*), char(*), fixed bin(35));
      112 
      113      dcl						/*	static variables			*/
      114 	1 defaultP		aligned like P int static,
      115 						/* pointers to the aggregates of the default	*/
      116 						/*    library descriptor.			*/
      117          (error_table_$name_not_found,
      118 	error_table_$noarg,
      119 	error_table_$nomatch,
      120 	error_table_$out_of_bounds,
      121 	error_table_$process_stopped,
      122 	error_table_$request_not_recognized,
      123 	error_table_$unimplemented_version)
      124 				fixed bin(35) ext static,
      125 	first_call		bit(1) aligned int static init ("1"b),
      126 						/* switch:  on if lib_descriptor_ has not been	*/
      127 						/*    referenced in this process before.	*/
      128 	multics_libraries_$descriptor	fixed bin ext static,
      129 						/* first word of the initial default library	*/
      130 						/*    descriptor.				*/
      131 	1 zero_names		int static options(constant),
      132 						/* an empty name structure.			*/
      133 	  2 N			fixed bin init(0);
      134 
      135 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      136 
      137 
      138 info:	entry	(Adescriptor, Plibrary, Pstarname, Pexclude, ASrequirements, AScontrol, Parea, Ptree,
      139 		 progress, Acode);
      140 
      141 	command_info.command = library_info;
      142 	go to common;
      143 
      144 
      145 map:	entry	(Adescriptor, Plibrary, Pstarname, Pexclude, ASrequirements, AScontrol, Parea, Ptree,
      146 		 progress, Acode);
      147 
      148 	command_info.command = library_map;
      149 	go to common;
      150 
      151 
      152 print:	entry 	(Adescriptor, Plibrary, Pstarname, Pexclude, ASrequirements, AScontrol, Parea, Ptree,
      153 		 progress, Acode);
      154 
      155 	command_info.command = library_print;
      156 	go to common;
      157 
      158 
      159 fetch:	entry     (Adescriptor, Plibrary, Pstarname, Pexclude, ASrequirements, AScontrol, Parea, Ptree,
      160 		 progress, Acode);
      161 
      162 	command_info.command = library_fetch;
      163 	go to common;
      164 
      165 
      166 cleanup:	entry	(Adescriptor, Plibrary, Pstarname, Pexclude, ASrequirements, AScontrol, Parea, Ptree,
      167 		 progress, Acode);
      168 
      169 	command_info.command = library_cleanup;
      170 	go to common;
      171 
      172 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      173 	/*									*/
      174 	/* _p_r_o_g_r_e_s_s								*/
      175 	/*									*/
      176 	/* 1) If the user has specified a descriptor, then get a pointer to it and its aggregates.*/
      177 	/*    Otherwise, get pointers to the default descriptor's aggregates, and return the	*/
      178 	/*    name of the default descriptor.						*/
      179 	/* 2) See if the command is supported by this descriptor.  If not, return an error code.	*/
      180 	/* 3) See if the user supplied any library names.  If not, address the default library	*/
      181 	/*    names specified by the descriptor for this command.  If none in descriptor either,	*/
      182 	/*    return an error code.							*/
      183 	/* 4) Repeat step 3 for star names used to search for library entries.		*/
      184 	/* 5) Allocate an array of root nodes for the status tree which is big enough to hold _a_l_l	*/
      185 	/*    of the roots defined by this descriptor.  This will handle the maximum possible	*/
      186 	/*    case.								*/
      187 	/* 6) Compare the library names with the names of defined roots.  When a match is found,	*/
      188 	/*    fill in a status tree root node for that root, and look for library entries in the	*/
      189 	/*    root which match the search name(s).  If no matching library entries are found,	*/
      190 	/*    remove the root from the root node array.					*/
      191 	/* 7) If the root node array of the status tree is empty after all roots identified	*/
      192 	/*    by the library names have been searched, then free the root node array and return	*/
      193 	/*    an error code.  Otherwise, return a pointer to the status tree.			*/
      194 	/*									*/
      195 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      196 
      197 common:	Ptree = null;				/* initialize return arguments.		*/
      198 	command_info.n_found = 0;
      199 
      200 	progress = 1;				/* find descriptor.				*/
      201 	call find_descriptor (Adescriptor, P, Acode);	/* note that Acode is initialized here.		*/
      202 	if Acode ^= 0 then return;
      203 
      204 	progress = 2;				/* see if command supported.			*/
      205 	if command_default_values.N < command then go to unsupported;
      206 	if command_default_values(command).S.unsupported then do;
      207 unsupported:   Acode = error_table_$request_not_recognized;
      208 	     return;
      209 	     end;
      210 
      211 	progress = 3;				/* address library names.			*/
      212 	if library.N < 1 then do;
      213 	     Plibrary_names = addrel (P.descriptor, command_default_values(command).library_names.O);
      214 	     Plibrary = addr(library_names.N);
      215 	     end;
      216 	if library.N < 1 then do;
      217 	     Acode = error_table_$noarg;
      218 	     return;
      219 	     end;
      220 
      221 	progress = 4;				/* address the search names.			*/
      222 	if starname.N < 1 then do;
      223 	     Psearch_names = addrel (P.descriptor, command_default_values(command).search_names.O);
      224 	     Pstarname = addr(search_names.N);
      225 	     end;
      226 	if starname.N < 1 then do;
      227 	     Acode = error_table_$noarg;
      228 	     return;
      229 	     end;
      230 
      231 	progress = 5;				/* allocate the root nodes of the status tree.	*/
      232 	call lib_get_tree_$root_array (roots.N, Parea, Pnodes, Acode);
      233 	if Acode ^= 0 then
      234 	     return;
      235 
      236 	progress = 6;				/* find library entries in roots matching library	*/
      237 	Sfound = "0"b;				/*    names.				*/
      238 	do k = 1 to roots.N;
      239 	     Proot_names = addrel (P.descriptor, roots.root(k).name.O);
      240 	     do i = 1 to root_names.N;
      241 		do j = 1 to library.N;
      242 		     go to match (library(j).C);
      243 
      244 match(0):		     if root_names.root_name(i) = library(j).V then go to match_found;
      245 		     go to no_match;
      246 
      247 match(1):		     call match_star_name_ (root_names.root_name(i), library(j).V, code);
      248 		     if code = 0 then go to match_found;
      249 
      250 no_match:		     end;
      251 		end;
      252 	     go to next_name;
      253 
      254 match(2):
      255 match_found:   Sfound = "1"b;
      256 	     Prt = addr(roots.root(k));
      257 	     call lib_get_tree_$lib_root_node (Proot_names, rt.type, rt.path, rt.search_proc_name, Pstarname,
      258 		Pexclude, ASrequirements, AScontrol, Parea, rt.search_proc, addr(command_info),
      259 		Pnodes, roots.N, code);
      260 	     if code = error_table_$process_stopped then do;
      261 		code = 0;
      262 		go to stop_searching;
      263 		end;
      264 	     else if code ^= 0 then
      265 		Acode = code;			/* return last bad error to caller.		*/
      266 next_name:     end;
      267 stop_searching:
      268 	call lib_get_tree_$root_array_info (Pnodes, Nnodes, code);
      269 	if (Nnodes > 0) | Sfound then do;		/* find out about resultant status tree.	*/
      270 	     if Acode = 0 then 			/* return any code from tree except nomatch.	*/
      271 		if code ^= error_table_$nomatch then
      272 		     Acode = code;
      273 	     Ptree = Pnodes;			/* if non-empty, return tree, with any code rec'd	*/
      274 	     return;				/*    while getting tree, to caller.		*/
      275 	     end;
      276 
      277 	progress = 7;				/* tree empty.  Tell user why and return.	*/
      278 	if Acode = 0 then
      279 	     if code ^= 0 then
      280 		Acode = code;			/* return lib_get_tree_'s reason for empty tree.	*/
      281 	     else
      282 		Acode = error_table_$nomatch;
      283 	call lib_free_node_$array (Pnodes);		/* free up Dnodes.				*/
      284 	return;
      285 
      286 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      287 
      288 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      289 
      290 
      291 name:	entry	(Adescriptor);
      292 
      293 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      294 	/*									*/
      295 	/* This entry point returns the name of the current default library descriptor.		*/
      296 	/*									*/
      297 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      298 
      299 
      300 	if first_call then call find_descriptor ("", P, code);
      301 	else P.descriptor = defaultP.descriptor;
      302 	Adescriptor = descriptor.name;
      303 	return;
      304 
      305 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      306 
      307 
      308 set_name:	entry	(Adescriptor, Acode);
      309 
      310 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      311 	/*									*/
      312 	/* This entry point sets the name of the default library descriptor.			*/
      313 	/*									*/
      314 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      315 
      316 
      317 	if Adescriptor = "" then first_call = "1"b;	/* if returning to the initial default descriptor,*/
      318 						/*    re-initialize default descriptor values.	*/
      319 	call find_descriptor (Adescriptor, P, Acode);
      320 	if Acode = 0 then
      321 	     defaultP = P;
      322 	return;
      323 
      324 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      325 
      326 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      327 
      328 
      329 default_values:	entry    (Adescriptor, Acommand, Acommand_name, ASunsupported, Plibrary, Pstarname, Pexclude,
      330 			progress, Acode);
      331 
      332 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      333 	/*									*/
      334 	/* This entry point expects as input either:  1) the index of a library command; or 	*/
      335 	/* 2) the name of a library command.  If a name is given, it converts the name to an	*/
      336 	/* index.  If the index is valid, the entry point returns the following information about	*/
      337 	/* the command:  the name of the command;  a switch indicating whether or not the	*/
      338 	/* command is supported by the specified (or default) library descriptor;  and the	*/
      339 	/* default library names and search names associated with the command (if any).  If the	*/
      340 	/* index is invalid, or if the specified library descriptor cannot be located, it returns	*/
      341 	/* a non-zero error code.							*/
      342 	/*									*/
      343 	/* _p_r_o_g_r_e_s_s								*/
      344 	/*									*/
      345 	/* 0) Validate the command index (if given), or convert the command name to a command	*/
      346 	/*    index.								*/
      347 	/* 1) If the user specified a library descriptor, then get a pointer to it and its	*/
      348 	/*    aggregates.  Otherwise, get pointers to the default descriptor's aggregates.	*/
      349 	/* 2) Report whether or not the command is supported.				*/
      350 	/* 3) If supported, return any default values for library names and search names.	*/
      351 	/*									*/
      352 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      353 
      354 
      355 	ASunsupported = "1"b;			/* initialize output values.			*/
      356 	Plibrary = addr(zero_names);
      357 	Pstarname = addr(zero_names);
      358 	Acode = 0;
      359 
      360 	progress = 0;				/* progress command index.			*/
      361 	if Acommand < 1 then do;			/* a command name was given.  Convert it to an	*/
      362 						/*    index.				*/
      363 	     do i = 1 to dimension (command_name,1) while (command_name(i) ^= Acommand_name);
      364 		end;
      365 	     if i > dimension (command_name,1) then do;
      366 		do i = 1 to dimension (command_abbrev,1) while (command_abbrev(i) ^= Acommand_name);
      367 		     end;
      368 		if i > dimension (command_abbrev,1) then go to bad_command_name;
      369 		Acommand_name = command_name(i);	/* return full command name in place of abbrev.	*/
      370 		end;
      371 	     command_info.command = i;
      372 	     Acommand = i;
      373 	     end;
      374 	else do;					/* validate the command index.		*/
      375 	     if Acommand > dimension (command_name,1) then go to bad_command_index;
      376 	     command_info.command = Acommand;
      377 	     Acommand_name = command_name(command_info.command);	/* return the command name.			*/
      378 	     end;
      379 
      380 	progress = 1;				/* find the descriptor.			*/
      381 	call find_descriptor (Adescriptor, P, Acode);
      382 	if Acode ^= 0 then return;
      383 
      384 	progress = 2;				/* report whether or not command supported.	*/
      385 	if command_default_values.N < command_info.command then do;
      386 	     ASunsupported = "1"b;			/* an old library descriptor doesn't include this	*/
      387 	     return;				/*    command.  Command is unsupported.		*/
      388 	     end;
      389 	ASunsupported = command_default_values(command_info.command).S.unsupported;
      390 	if ASunsupported then return;			/* no more to do for an unsupported command.	*/
      391 
      392 	progress = 3;				/* report on any default values.		*/
      393 	Plibrary_names = addrel (P.descriptor, command_default_values(command_info.command).library_names.O);
      394 	Plibrary = addr (library_names.N);
      395 	Psearch_names = addrel (P.descriptor, command_default_values(command_info.command).search_names.O);
      396 	Pstarname = addr (search_names.N);
      397 	return;
      398 
      399 bad_command_index:
      400 	Acode = error_table_$out_of_bounds;		/* no such command index as being asked for.	*/
      401 	return;
      402 
      403 bad_command_name:
      404 	Acode = error_table_$name_not_found;
      405 	return;
      406 
      407 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      408 
      409 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      410 
      411 
      412 libraries:	entry    (Adescriptor, Plibrary, ASrequirements, Parea, Ptree, progress, Acode);
      413 
      414 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      415 	/*									*/
      416 	/* This entry point expects as input an array of library names.  It returns as output an	*/
      417 	/* array of library root nodes (suitable for printing by the lib_output_node_ subroutine) */
      418 	/* for the libraries in the library descriptor which match the specified library names.	*/
      419 	/* If no library names are given, an error is returned.				*/
      420 	/*									*/
      421 	/* _p_r_o_g_r_e_s_s								*/
      422 	/*									*/
      423 	/* 1) If the user specified a library descriptor, then get a pointer to it and its	*/
      424 	/*    aggregates.  Otherwise, get pointers to the default descriptor's aggregates.	*/
      425 	/* 3) Make sure caller specified some library names, and overlay these names.		*/
      426 	/* 5) Allocate an array of root nodes big enough to hold all of the roots defined in the	*/
      427 	/*    descriptor being referenced.  This is a guaranteed fit.			*/
      428 	/* 6) Compare the library names with the names of the defined roots.  When a match is	*/
      429 	/*    found, fill in a root node for that root.  					*/
      430 	/* 7) If no matching roots are found, free the array of root nodes and return an error.	*/
      431 	/*									*/
      432 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      433 
      434 
      435 	Ptree = null;				/* initialize output argument.		*/
      436 	progress = 1;				/* find the descriptor.			*/
      437 	call find_descriptor (Adescriptor, P, Acode);
      438 	if Acode ^= 0 then return;
      439 
      440 	progress = 3;				/* check for and overlay library names.		*/
      441 	if library.N <= 0 then do;
      442 	     Acode = error_table_$noarg;
      443 	     return;
      444 	     end;
      445 
      446 	progress = 5;				/* allocate array of root nodes big enough for	*/
      447 						/*    all roots defined by this descriptor.	*/
      448 	call lib_get_tree_$root_array (roots.N, Parea, Pnodes, Acode);
      449 	if Acode ^= 0 then return;
      450 
      451 	progress = 6;				/* find/output root nodes for matching roots.	*/
      452 	do k = 1 to roots.N;
      453 	     Proot_names = addrel (P.descriptor, roots.root(k).name.O);
      454 	     do i = 1 to root_names.N;
      455 		do j = 1 to library.N;
      456 		     go to match_lib (library(j).C);
      457 
      458 match_lib (0):	     if root_names.root_name(i) = library(j).V then go to match_found_lib;
      459 		     go to no_match_lib;
      460 
      461 match_lib (1):	     call match_star_name_ (root_names.root_name(i), library(j).V, code);
      462 		     if code = 0 then go to match_found_lib;
      463 
      464 no_match_lib:	     end;
      465 		end;
      466 	    go to next_name_lib;
      467 
      468 match_lib (2):
      469 match_found_lib:
      470 	     Prt = addr(roots.root(k));
      471 	     call lib_get_tree_$lib_root_node (Proot_names, rt.type, rt.path, rt.search_proc_name, addr(zero_names),
      472 		addr(zero_names), ASrequirements, "0"b, Parea, null_search_proc, addr(command_info.command),
      473 		Pnodes, roots.N, code);
      474 	     if code = error_table_$process_stopped then do;
      475 		code = 0;
      476 		go to stop_searching_lib;
      477 		end;
      478 	     else if code ^= 0 then
      479 		Acode = code;			/* return last bad error to caller.		*/
      480 next_name_lib: end;
      481 stop_searching_lib:
      482 
      483 	call lib_get_tree_$root_array_info (Pnodes, Nnodes, code);
      484 	progress = 7;
      485 	if Nnodes = 0 then do;			/* no matching root definitions found. ERROR	*/
      486 	     Acode = error_table_$nomatch;
      487 	     call lib_free_node_$array (Pnodes);
      488 	     end;
      489 	else
      490 	     Ptree = Pnodes;
      491 	return;
      492 
      493 null_search_proc:	procedure;			/* Null search procedure which does nothing.	*/
      494 
      495 	end null_search_proc;
      496 
      497 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      498 
      499 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      500 
      501 
      502 validate_library:	entry (Adescriptor, Plibrary, Pbad_library, Acode);
      503 
      504 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      505 	/*									*/
      506 	/* This entry point expects as input an array of library names and an empty library	*/
      507 	/* name array of the same size.  It returns as output in the empty array the names from	*/
      508 	/* the input array that do not match any library name defined in the given library	*/
      509 	/* descriptor.  If no library names are input, an error is returned.			*/
      510 	/*									*/
      511 	/* _p_r_o_g_r_e_s_s								*/
      512 	/*									*/
      513 	/* 1) If the user specified a library descirptor, then get a pointer to it and its	*/
      514 	/*    aggregates.  Otherwise, get pointers to the default descriptor's aggregates.	*/
      515 	/* 3) Make sure the caller specified some library names.				*/
      516 	/* 6) Copy all of the caller's names to the bad_library array.  Compare the names in	*/
      517 	/*    this array with the valid library names from the descriptor, and REMOVE input	*/
      518 	/*    library names from bad_library when they match a valid library name.		*/
      519 	/*									*/
      520 	/* NOTES									*/
      521 	/*									*/
      522 	/* A non-zero error code is returned ONLY IF the specified descriptor cannot be located,	*/
      523 	/* or if no library names were given as input.					*/
      524 	/*									*/
      525 	/* A zero code is returned otherwise.  If there are bad library names, bad_library.N will	*/
      526 	/* be greater than 0 on output.						*/
      527 	/*									*/
      528 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      529 
      530 
      531 	bad_library.N = 0;				/* initialize output argument.		*/
      532 
      533 	call find_descriptor (Adescriptor, P, Acode);	/* find the descriptor.			*/
      534 	if Acode ^= 0 then return;
      535 
      536 	if library.N <= 0 then do;			/* check for library names given as input.	*/
      537 	     Acode = error_table_$noarg;
      538 	     return;
      539 	     end;
      540 
      541 	Pbad_library -> library = library;		/* copy all input library names to bad_library.	*/
      542  
      543 	do k = 1 to roots.N while (bad_library.N > 0);	/* compare input names with valid library names.	*/
      544 	     Proot_names = addrel (P.descriptor, roots.root(k).name.O);
      545 	     do j = bad_library.N to 1 by -1;
      546 		Sfound = "0"b;
      547 		do i = 1 to root_names.N while (^Sfound);
      548 		     go to match_valid (bad_library(j).C);
      549 
      550 match_valid (0):	     if root_names.root_name(i) = bad_library(j).V then Sfound = "1"b;
      551 		     go to end_match_valid;
      552 
      553 match_valid (1):	     call match_star_name_ (root_names.root_name(i), bad_library(j).V, code);
      554 		     if code = 0 then Sfound = "1"b;
      555 		     go to end_match_valid;
      556 
      557 match_valid (2):	     Sfound = "1"b;
      558 
      559 end_match_valid:	     end;
      560 
      561 		if Sfound then do;
      562 		     do i = j+1 to bad_library.N;
      563 			bad_library(i-1).V = bad_library(i).V;
      564 			bad_library(i-1).C = bad_library(i).C;
      565 			end;
      566 		     bad_library.N = bad_library.N - 1;
      567 		     end;
      568 		end;
      569 	     end;
      570 	return;
      571 
      572 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      573 
      574 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      575 
      576 
      577 find_descriptor:	procedure (Adescriptor, P1, code);
      578 
      579      dcl						/*	parameters			*/
      580 	Adescriptor		char(168) varying,	/* descriptor to be found. (In)		*/
      581 						/*    If Adescriptor = "", then name of		*/
      582 						/*    default descriptor. (Out)		*/
      583 	1 P1			aligned like P,	/* descriptor pointer structure to be filled in.	*/
      584 						/*    (Out)				*/
      585 	code			fixed bin(35);	/* a status code. (Out)			*/
      586 
      587      dcl	E			entry variable,	/* an entry variable temp.			*/
      588 	P_me			ptr,		/* a pointer temp.				*/
      589 	i			fixed bin;
      590 
      591      dcl						/*	based variable			*/
      592 	1 descriptor1		aligned like descriptor based (P1.descriptor);
      593 
      594 
      595 	if first_call then do;			/* first call.  Initialize default descriptor ptr.*/
      596 	     P1.descriptor = addr (multics_libraries_$descriptor);
      597 	     defaultP.descriptor = P1.descriptor;
      598 	     defaultP.command_default_values = addrel(P1.descriptor, descriptor1.command_default_values.O);
      599 	     defaultP.roots = addrel(P1.descriptor, descriptor1.roots.O);
      600 	     first_call = "0"b;
      601 	     end;
      602 
      603 	if Adescriptor = "" then do;			/* use default descriptor, and return its name.	*/
      604 	     P1 = defaultP;
      605 	     Adescriptor = descriptor1.name;
      606 	     code = 0;
      607 	     end;
      608 	else do;					/* use user-specified descriptor.		*/
      609 	     call cu_$decode_entry_value (lib_descriptor_, P_me, null);
      610 	     i = verify (reverse (Adescriptor), " ");
      611 	     i = length(Adescriptor) - (i-1);
      612 	     if search (Adescriptor, "<>") > 0 then
      613 		E = cv_entry_ (substr(Adescriptor,1,i) || "|descriptor", P_me, code);
      614 	     else E = cv_entry_ (substr(Adescriptor,1,i) || "$descriptor", P_me, code);
      615 	     call cu_$decode_entry_value (E, P1.descriptor, null);
      616 	     if code ^= 0 then P1.descriptor = null;
      617 	     else if descriptor1.version ^= Vdescriptor_2 then do;
      618 		code = error_table_$unimplemented_version;
      619 		P1.descriptor = null;
      620 		end;
      621 	     else do;
      622 		P1.command_default_values = addrel(P1.descriptor, descriptor1.command_default_values.O);
      623 		P1.roots = addrel(P1.descriptor, descriptor1.roots.O);
      624 		code = 0;				/* ignore superfluous errors.			*/
      625 		end;
      626 	     end;
      627 
      628 	end find_descriptor;
      629 
      630 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      631 
  2     1 /* START OF:	lib_descriptor_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_descriptor_.incl.pl1						*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the structures which are included in the library	*/
  2     8 	/* descriptor segments used as data bases by Multics library maintenance tools.		*/
  2     9 	/*									*/
  2    10 	/* S__t_a_t_u_s									*/
  2    11 	/*									*/
  2    12 	/* 0) Created by:  G. C. Dixon  in  April, 1974.					*/
  2    13 	/* 1) Modified by: G. C. Dixon  in  May, 1976.					*/
  2    14 	/*									*/
  2    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    16 
  2    17      dcl	1 descriptor		aligned based (P.descriptor),
  2    18 						/* structure which defines the location within	*/
  2    19 						/*   the descriptor of description aggregates.	*/
  2    20 	  2 version		fixed bin,	/*    version number of this descriptor. (= 2)	*/
  2    21 	  2 name			char(32),		/*    name of this descriptor.		*/
  2    22 	  2 command_default_values,			/*    aggregate:  default values to be used for	*/
  2    23 						/*       commands which reference the descriptor.	*/
  2    24 	    3 O			fixed bin(19),	/*       offset of aggregate from P.descriptor.	*/
  2    25 	  2 roots,				/*    aggregate:  root nodes of the library.	*/
  2    26 	    3 O			fixed bin(19);	/*       offset of aggregate from P.descriptor.	*/
  2    27      dcl	Vdescriptor_2		fixed bin int static options(constant) init (2);
  2    28 
  2    29      dcl	1 command_default_values 	based (P.command_default_values),
  2    30 						/* array of structures which defines the	*/
  2    31 						/*    default values which are applied to	*/
  2    32 						/*    each command which uses the library	*/
  2    33 						/*    descriptor.  There is one array element	*/
  2    34 						/*    for each command.			*/
  2    35 	  2 N			fixed bin,	/* count of commands.			*/
  2    36 	  2 group (0 refer (command_default_values.N)),	/* array of structures.			*/
  2    37 	    3 S			unaligned,	/*    switches:				*/
  2    38 	      4 unsupported		bit(1),		/*       on if the command described by this	*/
  2    39 						/*          element of the array of structures is	*/
  2    40 						/*          _n_o_t supported by this descriptor.	*/
  2    41 	    3 library_names,			/*    names of the default libraries which are to	*/
  2    42 						/*       be used for this command, if the user	*/
  2    43 						/*       omits the library name.		*/
  2    44 	      4 O			fixed bin(19),	/*       offset of the names structure.		*/
  2    45 	    3 search_names,				/*    star names which identify the library	*/
  2    46 						/*       entries to be search for, if the user	*/
  2    47 						/*       omits the search name.		*/
  2    48 	      4 O			fixed bin(19);	/*       offset of the names structure.		*/
  2    49 
  2    50      dcl	1 library_names		based (Plibrary_names),
  2    51 						/* array of default library names for one command.*/
  2    52 	  2 N			fixed bin,	/*   count of names.			*/
  2    53 	  2 group (0 refer (library_names.N)),		/*   array of names.			*/
  2    54 	    3 V			char(32) aligned,	/*     a name.				*/
  2    55 	    3 C			fixed bin(35);	/*     code from check_star_name_$entry for name.	*/
  2    56 
  2    57      dcl	1 search_names		based (Psearch_names),
  2    58 						/* array of default search names for one command.	*/
  2    59 	  2 N			fixed bin,	/*   count of names.			*/
  2    60 	  2 group (0 refer (search_names.N)),		/*   array of names.			*/
  2    61 	    3 V			char(32) aligned,	/*     a name.				*/
  2    62 	    3 C			fixed bin(35);	/*     code from check_star_name_$entry for name.	*/
  2    63  
  3     1 /* START OF:	lib_commands_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_commands_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the names of all commands which use library 	*/
  3     8 	/* descriptor segments.  These descriptor segments are the data base of the Multics	*/
  3     9 	/* library maintenance tools.  As such, the commands are referred to collectively as	*/
  3    10 	/* library descriptor commands.  The include segment also defines the command index value	*/
  3    11 	/* associated with each command.  This is used to index into some of the arrays of the	*/
  3    12 	/* library descriptor.							*/
  3    13 	/*									*/
  3    14 	/* S__t_a_t_u_s									*/
  3    15 	/*									*/
  3    16 	/* 0) Created by:  G. C. Dixon  in  January, 1975					*/
  3    17 	/*									*/
  3    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    19 
  3    20 
  3    21      dcl	library_info		fixed bin int static init (1),
  3    22 	library_map		fixed bin int static init (2),
  3    23 	library_print		fixed bin int static init (3),
  3    24 	library_fetch		fixed bin int static init (4),
  3    25 	library_cleanup		fixed bin int static init (5);
  3    26 						/* index into command_default_values of info	*/
  3    27 						/*    structure for commands which reference the	*/
  3    28 						/*    library descriptor.			*/
  3    29      dcl	command_name (5)		char(16) varying int static options(constant) init (
  3    30 				     "library_info", "library_map", "library_print",
  3    31 				     "library_fetch", "library_cleanup"),
  3    32 	command_abbrev (5)		char(4) varying int static options(constant) init (
  3    33 				     "li", "lm", "lpr", "lf", "lcln");
  3    34 						/* names and abbreviations of lib maint. commands.*/
  3    35 
  3    36 /* END OF:	lib_commands_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    64 
  2    65 
  2    66      dcl	1 roots			based (P.roots),	/* array of structures, each structure of which	*/
  2    67 						/*    defines the names, absolute path name, type,*/
  2    68 						/*    and search procedure for a root of the	*/
  2    69 						/*    library defined by this descriptor.	*/
  2    70 	  2 N			fixed bin,	/* count of roots				*/
  2    71 	  2 root (0 refer (roots.N)),			/* array of roots.				*/
  2    72 	    3 name,				/*    names by which this root may be referenced.	*/
  2    73 	      4 O			fixed bin(19),	/*       offset of name array.		*/
  2    74 	    3 path		char(168) varying,	/*    absolute path name of the root directory or	*/
  2    75 						/*       archive segment.			*/
  2    76 	    3 type		fixed bin,	/*    type of root.  2 = directory, 4 = archive.	*/
  2    77 	    3 search_proc_name	char(65) varying,	/*    name of procedure used to search root.	*/
  2    78 	    3 search_proc		entry (ptr, char(168) varying, ptr, bit(72) aligned, bit(36) aligned,
  2    79  				       fixed bin, fixed bin, ptr, entry,
  2    80 				       ptr, ptr, fixed bin(35)) variable;
  2    81 						/*    entry point of the program which knows how	*/
  2    82 						/*       to search for library entries in this 	*/
  2    83 						/*       root.				*/
  2    84 
  2    85      dcl	1 root_names		based (Proot_names),
  2    86 						/* array of root names for one root.		*/
  2    87 	  2 N			fixed bin,	/*     count of names.			*/
  2    88 	  2 root_name (0 refer (root_names.N))		/*     array of names.			*/
  2    89 	 			char(32);
  2    90 
  2    91      dcl	1 P			aligned,		/* structure containing pointers to the aggregates*/
  2    92 						/*    defined above.			*/
  2    93 	  2 descriptor		ptr,
  2    94 	  2 command_default_values	ptr,
  2    95 	  2 roots			ptr,
  2    96 	Plibrary_names		ptr,
  2    97 	Psearch_names		ptr,
  2    98 	Proot_names		ptr;
  2    99 
  2   100 /* END OF:	lib_descriptor_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      632 
      633 
      634 	end lib_descriptor_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0750.0  lib_descriptor_.pl1               >special_ldd>on>6588>lib_descriptor_.pl1
60           1    02/15/84  0754.6  lib_based_args_.incl.pl1          >special_ldd>on>6588>lib_based_args_.incl.pl1
632          2    02/28/77  1409.3  lib_descriptor_.incl.pl1          >ldd>include>lib_descriptor_.incl.pl1
2-64         3    02/28/77  1409.3  lib_commands_.incl.pl1            >ldd>include>lib_commands_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AScontrol                              parameter       bit(36)                  dcl 61 set ref 138 145 152 159 166 257*
ASrequirements                         parameter       bit(72)                  dcl 61 set ref 138 145 152 159 166 257* 412 471*
ASunsupported                          parameter       bit(1)                   unaligned dcl 61 set ref 329 355* 386* 389* 390
Acode                                  parameter       fixed bin(35,0)          dcl 61 set ref 138 145 152 159 166 201* 202 207*
                                                                                  217* 227* 232* 233 264* 270 270* 278 278* 281* 308
                                                                                  319* 320 329 358* 381* 382 399* 403* 412 437* 438
                                                                                  442* 448* 449 478* 486* 502 533* 534 537*
Acommand                               parameter       fixed bin(17,0)          dcl 61 set ref 329 361 372* 375 376
Acommand_name                          parameter       char(32)                 unaligned dcl 61 set ref 329 363 366 369* 377*
Adescriptor                            parameter       varying char(168)        dcl 58 in procedure "lib_descriptor_" set ref 138
                                                                                  145 152 159 166 201* 291 302* 308 317 319* 329
                                                                                  381* 412 437* 502 533*
Adescriptor                            parameter       varying char(168)        dcl 579 in procedure "find_descriptor" set ref 577
                                                                                  603 605* 610 611 612 612 614
C                        11            based           fixed bin(35,0)          array level 3 in structure "bad_library" dcl 61
                                                                                  in procedure "lib_descriptor_" set ref 548 564*
                                                                                  564
C                        11            based           fixed bin(35,0)          array level 3 in structure "library" dcl 1-22
                                                                                  in procedure "lib_descriptor_" set ref 242 456
E                               000172 automatic       entry variable           dcl 587 set ref 612* 614* 615*
N                                      based           fixed bin(17,0)          level 2 in structure "root_names" dcl 2-85
                                                                                  in procedure "lib_descriptor_" ref 240 454 547
N                                      based           fixed bin(17,0)          level 2 in structure "command_default_values"
                                                                                  dcl 2-29 in procedure "lib_descriptor_" ref 205
                                                                                  385
N                                      based           fixed bin(17,0)          level 2 in structure "library" dcl 1-22 in procedure
                                                                                  "lib_descriptor_" set ref 212 216 241 441 455 536
                                                                                  541
N                                      based           fixed bin(17,0)          level 2 in structure "starname" dcl 1-32
                                                                                  in procedure "lib_descriptor_" ref 222 226
N                                      based           fixed bin(17,0)          level 2 in structure "bad_library" dcl 61
                                                                                  in procedure "lib_descriptor_" set ref 531* 543
                                                                                  545 562 566* 566
N                                      based           fixed bin(17,0)          level 2 in structure "search_names" dcl 2-57
                                                                                  in procedure "lib_descriptor_" set ref 224 396
N                                      based           fixed bin(17,0)          level 2 in structure "roots" dcl 2-66 in procedure
                                                                                  "lib_descriptor_" set ref 232* 238 257* 448* 452
                                                                                  471* 543
N                                      based           fixed bin(17,0)          level 2 in structure "library_names" dcl 2-50
                                                                                  in procedure "lib_descriptor_" set ref 214 394
Nnodes                          000100 automatic       fixed bin(17,0)          dcl 78 set ref 267* 269 481* 485
O                        12            based           fixed bin(19,0)          level 3 in structure "descriptor1" dcl 591
                                                                                  in procedure "find_descriptor" ref 599 623
O                        11            based           fixed bin(19,0)          level 3 in structure "descriptor1" dcl 591
                                                                                  in procedure "find_descriptor" ref 598 622
O                         3            based           fixed bin(19,0)          array level 4 in structure "command_default_values"
                                                                                  dcl 2-29 in procedure "lib_descriptor_" ref 223
                                                                                  395
O                         2            based           fixed bin(19,0)          array level 4 in structure "command_default_values"
                                                                                  dcl 2-29 in procedure "lib_descriptor_" ref 213
                                                                                  393
O                         2            based           fixed bin(19,0)          array level 4 in structure "roots" dcl 2-66
                                                                                  in procedure "lib_descriptor_" set ref 239 453 544
P                               000116 automatic       structure                level 1 dcl 2-91 set ref 201* 300* 319* 320 381*
                                                                                  437* 533*
P1                                     parameter       structure                level 1 dcl 579 set ref 577 604*
P_me                            000176 automatic       pointer                  dcl 587 set ref 609* 612* 614*
Parea                                  parameter       pointer                  dcl 61 set ref 138 145 152 159 166 232* 257* 412
                                                                                  448* 471*
Pbad_library                           parameter       pointer                  dcl 61 ref 502 531 541 543 545 548 550 553 562 563
                                                                                  563 564 564 566 566
Pexclude                               parameter       pointer                  dcl 1-50 set ref 138 145 152 159 166 257* 329
Plibrary                               parameter       pointer                  dcl 1-29 set ref 138 145 152 159 166 212 214* 216
                                                                                  241 242 244 247 329 356* 394* 412 441 455 456 458
                                                                                  461 502 536 541
Plibrary_names                  000124 automatic       pointer                  dcl 2-91 set ref 213* 214 393* 394
Pnodes                          000102 automatic       pointer                  dcl 78 set ref 232* 257* 267* 273 283* 448* 471*
                                                                                  481* 487* 489
Proot_names                     000130 automatic       pointer                  dcl 2-91 set ref 239* 240 244 247 257* 453* 454 458
                                                                                  461 471* 544* 547 550 553
Prt                             000104 automatic       pointer                  dcl 78 set ref 256* 257 257 257 257 468* 471 471 471
Psearch_names                   000126 automatic       pointer                  dcl 2-91 set ref 223* 224 395* 396
Pstarname                              parameter       pointer                  dcl 1-40 set ref 138 145 152 159 166 222 224* 226
                                                                                  257* 329 357* 396*
Ptree                                  parameter       pointer                  dcl 61 set ref 138 145 152 159 166 197* 273* 412
                                                                                  435* 489*
S                         1            based           structure                array level 3 packed unaligned dcl 2-29
Sfound                          000106 automatic       bit(1)                   dcl 78 set ref 237* 254* 269 546* 547 550* 554* 557*
                                                                                  561
V                         1            based           char(32)                 array level 3 in structure "library" packed
                                                                                  unaligned dcl 1-22 in procedure "lib_descriptor_"
                                                                                  set ref 244 247* 458 461*
V                         1            based           char(32)                 array level 3 in structure "bad_library" packed
                                                                                  unaligned dcl 61 in procedure "lib_descriptor_"
                                                                                  set ref 550 553* 563* 563
Vdescriptor_2                          constant        fixed bin(17,0)          initial dcl 2-27 ref 617
addr                                                   builtin function         dcl 97 ref 214 224 256 257 257 356 357 394 396 468
                                                                                  471 471 471 471 471 471 596
addrel                                                 builtin function         dcl 97 ref 213 223 239 393 395 453 544 598 599 622
                                                                                  623
bad_library                            based           structure                level 1 unaligned dcl 61
code                                   parameter       fixed bin(35,0)          dcl 579 in procedure "find_descriptor" set ref 577
                                                                                  606* 612* 614* 616 618* 624*
code                            000107 automatic       fixed bin(35,0)          dcl 78 in procedure "lib_descriptor_" set ref 247*
                                                                                  248 257* 260 261* 264 264 267* 270 270 278 278
                                                                                  300* 461* 462 471* 474 475* 478 478 481* 553* 554
command                         000114 automatic       fixed bin(17,0)          level 2 dcl 87 set ref 141* 148* 155* 162* 169* 205
                                                                                  206 213 223 371* 376* 377 385 389 393 395 471 471
command_abbrev                  000012 constant        varying char(4)          initial array dcl 3-29 ref 366 366 368
command_default_values
                          2     000010 internal static pointer                  level 2 in structure "defaultP" dcl 113 in procedure
                                                                                  "lib_descriptor_" set ref 598*
command_default_values                 based           structure                level 1 unaligned dcl 2-29 in procedure
                                                                                  "lib_descriptor_"
command_default_values
                          2     000116 automatic       pointer                  level 2 in structure "P" dcl 2-91 in procedure
                                                                                  "lib_descriptor_" set ref 205 206 213 223 385 389
                                                                                  393 395
command_default_values
                         11            based           structure                level 2 in structure "descriptor1" dcl 591
                                                                                  in procedure "find_descriptor"
command_default_values
                          2            parameter       pointer                  level 2 in structure "P1" dcl 579 in procedure
                                                                                  "find_descriptor" set ref 622*
command_info                    000114 automatic       structure                level 1 dcl 87 set ref 257 257
command_name                    000024 constant        varying char(16)         initial array dcl 3-29 ref 363 363 365 369 375 377
cu_$decode_entry_value          000020 constant        entry                    external dcl 102 ref 609 615
cv_entry_                       000022 constant        entry                    external dcl 102 ref 612 614
defaultP                        000010 internal static structure                level 1 dcl 113 set ref 320* 604
descriptor                      000116 automatic       pointer                  level 2 in structure "P" dcl 2-91 in procedure
                                                                                  "lib_descriptor_" set ref 213 223 239 301* 302 393
                                                                                  395 453 544
descriptor                             based           structure                level 1 dcl 2-17 in procedure "lib_descriptor_"
descriptor                             parameter       pointer                  level 2 in structure "P1" dcl 579 in procedure
                                                                                  "find_descriptor" set ref 596* 597 598 598 599 599
                                                                                  605 615* 616* 617 619* 622 622 623 623
descriptor                      000010 internal static pointer                  level 2 in structure "defaultP" dcl 113 in procedure
                                                                                  "lib_descriptor_" set ref 301 597*
descriptor1                            based           structure                level 1 dcl 591
dimension                                              builtin function         dcl 97 ref 363 365 366 368 375
error_table_$name_not_found     000036 external static fixed bin(35,0)          dcl 113 ref 403
error_table_$noarg              000040 external static fixed bin(35,0)          dcl 113 ref 217 227 442 537
error_table_$nomatch            000042 external static fixed bin(35,0)          dcl 113 ref 270 281 486
error_table_$out_of_bounds      000044 external static fixed bin(35,0)          dcl 113 ref 399
error_table_$process_stopped    000046 external static fixed bin(35,0)          dcl 113 ref 260 474
error_table_$request_not_recognized
                                000050 external static fixed bin(35,0)          dcl 113 ref 207
error_table_$unimplemented_version
                                000052 external static fixed bin(35,0)          dcl 113 ref 618
first_call                      000016 internal static bit(1)                   initial dcl 113 set ref 300 317* 595 600*
group                     1            based           structure                array level 2 in structure "bad_library" unaligned
                                                                                  dcl 61 in procedure "lib_descriptor_"
group                     1            based           structure                array level 2 in structure "library" dcl 1-22
                                                                                  in procedure "lib_descriptor_"
group                     1            based           structure                array level 2 in structure "command_default_values"
                                                                                  unaligned dcl 2-29 in procedure "lib_descriptor_"
i                               000110 automatic       fixed bin(17,0)          dcl 78 in procedure "lib_descriptor_" set ref 240*
                                                                                  244 247* 363* 363* 365 366* 366* 368 369 371 372
                                                                                  454* 458 461* 547* 550 553* 562* 563 563 564 564*
i                               000200 automatic       fixed bin(17,0)          dcl 587 in procedure "find_descriptor" set ref 610*
                                                                                  611* 611 612 614
j                               000111 automatic       fixed bin(17,0)          dcl 78 set ref 241* 242 244 247* 455* 456 458 461*
                                                                                  545* 548 550 553 562*
k                               000112 automatic       fixed bin(17,0)          dcl 78 set ref 238* 239 256* 452* 453 468* 543* 544*
length                                                 builtin function         dcl 97 ref 611
lib_free_node_$array            000024 constant        entry                    external dcl 102 ref 283 487
lib_get_tree_$lib_root_node     000032 constant        entry                    external dcl 102 ref 257 471
lib_get_tree_$root_array        000026 constant        entry                    external dcl 102 ref 232 448
lib_get_tree_$root_array_info   000030 constant        entry                    external dcl 102 ref 267 481
library                                based           structure                level 1 dcl 1-22 set ref 541* 541
library_cleanup                        constant        fixed bin(17,0)          initial dcl 3-21 ref 169
library_fetch                          constant        fixed bin(17,0)          initial dcl 3-21 ref 162
library_info                           constant        fixed bin(17,0)          initial dcl 3-21 ref 141
library_map                            constant        fixed bin(17,0)          initial dcl 3-21 ref 148
library_names                          based           structure                level 1 unaligned dcl 2-50 in procedure
                                                                                  "lib_descriptor_"
library_names             2            based           structure                array level 3 in structure "command_default_values"
                                                                                  unaligned dcl 2-29 in procedure "lib_descriptor_"
library_print                          constant        fixed bin(17,0)          initial dcl 3-21 ref 155
match_star_name_                000034 constant        entry                    external dcl 102 ref 247 461 553
multics_libraries_$descriptor   000054 external static fixed bin(17,0)          dcl 113 set ref 596
n_found                   1     000114 automatic       fixed bin(17,0)          level 2 dcl 87 set ref 198*
name                      1            based           char(32)                 level 2 in structure "descriptor1" dcl 591
                                                                                  in procedure "find_descriptor" ref 605
name                      2            based           structure                array level 3 in structure "roots" unaligned
                                                                                  dcl 2-66 in procedure "lib_descriptor_"
name                      1            based           char(32)                 level 2 in structure "descriptor" dcl 2-17
                                                                                  in procedure "lib_descriptor_" ref 302
null                                                   builtin function         dcl 97 ref 197 435 609 609 615 615 616 619
path                      1            based           varying char(168)        level 2 dcl 91 set ref 257* 471*
progress                               parameter       fixed bin(17,0)          dcl 61 set ref 138 145 152 159 166 200* 204* 211*
                                                                                  221* 231* 236* 277* 329 360* 380* 384* 392* 412
                                                                                  436* 440* 446* 451* 484*
root                      2            based           structure                array level 2 unaligned dcl 2-66 set ref 256 468
root_name                 1            based           char(32)                 array level 2 packed unaligned dcl 2-85 set ref 244
                                                                                  247* 458 461* 550 553*
root_names                             based           structure                level 1 unaligned dcl 2-85
roots                                  based           structure                level 1 unaligned dcl 2-66 in procedure
                                                                                  "lib_descriptor_"
roots                     4     000010 internal static pointer                  level 2 in structure "defaultP" dcl 113 in procedure
                                                                                  "lib_descriptor_" set ref 599*
roots                    12            based           structure                level 2 in structure "descriptor1" dcl 591
                                                                                  in procedure "find_descriptor"
roots                     4     000116 automatic       pointer                  level 2 in structure "P" dcl 2-91 in procedure
                                                                                  "lib_descriptor_" set ref 232 238 239 256 257 448
                                                                                  452 453 468 471 543 544
roots                     4            parameter       pointer                  level 2 in structure "P1" dcl 579 in procedure
                                                                                  "find_descriptor" set ref 623*
rt                                     based           structure                level 1 unaligned dcl 91
search_names                           based           structure                level 1 unaligned dcl 2-57 in procedure
                                                                                  "lib_descriptor_"
search_names              3            based           structure                array level 3 in structure "command_default_values"
                                                                                  unaligned dcl 2-29 in procedure "lib_descriptor_"
search_proc             100            based           entry variable           level 2 dcl 91 set ref 257*
search_proc_name         55            based           varying char(65)         level 2 dcl 91 set ref 257* 471*
starname                               based           structure                level 1 dcl 1-32
substr                                                 builtin function         dcl 97 ref 612 614
type                     54            based           fixed bin(17,0)          level 2 dcl 91 set ref 257* 471*
unsupported               1            based           bit(1)                   array level 4 packed unaligned dcl 2-29 ref 206 389
version                                based           fixed bin(17,0)          level 2 dcl 591 ref 617
zero_names                      000000 constant        structure                level 1 unaligned dcl 113 set ref 356 357 471 471
                                                                                  471 471

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
area                                   based           area(1024)               dcl 91
exclude                                based           structure                level 1 dcl 1-42
min                                                    builtin function         dcl 97

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_command_index               001313 constant        label                    dcl 399 ref 375
bad_command_name                001317 constant        label                    dcl 403 ref 368
cleanup                         000277 constant        entry                    external dcl 166
common                          000330 constant        label                    dcl 197 ref 142 149 156 163 170
default_values                  001065 constant        entry                    external dcl 329
end_match_valid                 002104 constant        label                    dcl 559 ref 551 555
fetch                           000244 constant        entry                    external dcl 159
find_descriptor                 002162 constant        entry                    internal dcl 577 ref 201 300 319 381 437 533
info                            000123 constant        entry                    external dcl 138
lib_descriptor_                 000105 constant        entry                    external dcl 55 ref 609 609
libraries                       001331 constant        entry                    external dcl 412
map                             000156 constant        entry                    external dcl 145
match                           000001 constant        label                    array(0:2) dcl 244 ref 242
match_found                     000610 constant        label                    dcl 254 set ref 244 248
match_found_lib                 001546 constant        label                    dcl 468 ref 458 462
match_lib                       000004 constant        label                    array(0:2) dcl 458 ref 456
match_valid                     000007 constant        label                    array(0:2) dcl 550 ref 548
name                            000755 constant        entry                    external dcl 291
next_name                       000674 constant        label                    dcl 266 ref 252
next_name_lib                   001640 constant        label                    dcl 480 ref 466
no_match                        000603 constant        label                    dcl 250 ref 245
no_match_lib                    001541 constant        label                    dcl 464 ref 459
null_search_proc                002154 constant        entry                    internal dcl 493 ref 471 471
print                           000211 constant        entry                    external dcl 152
set_name                        001010 constant        entry                    external dcl 308
stop_searching                  000676 constant        label                    dcl 267 ref 262
stop_searching_lib              001642 constant        label                    dcl 481 ref 476
unsupported                     000365 constant        label                    dcl 207 ref 205
validate_library                001703 constant        entry                    external dcl 502

NAMES DECLARED BY CONTEXT OR IMPLICATION.
reverse                                                builtin function         ref 610
search                                                 builtin function         ref 612
verify                                                 builtin function         ref 610

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3216        3274    2700        3226
Length      3606    2700        56         275     315          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_descriptor_                     270 external procedure  is an external procedure.  
null_search_proc                     64 internal procedure  is assigned to an entry variable.  
find_descriptor                         internal procedure  shares stack frame of external procedure lib_descriptor_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 defaultP                    lib_descriptor_
000016 first_call                  lib_descriptor_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_descriptor_          000100 Nnodes                      lib_descriptor_
                         000102 Pnodes                      lib_descriptor_
                         000104 Prt                         lib_descriptor_
                         000106 Sfound                      lib_descriptor_
                         000107 code                        lib_descriptor_
                         000110 i                           lib_descriptor_
                         000111 j                           lib_descriptor_
                         000112 k                           lib_descriptor_
                         000114 command_info                lib_descriptor_
                         000116 P                           lib_descriptor_
                         000124 Plibrary_names              lib_descriptor_
                         000126 Psearch_names               lib_descriptor_
                         000130 Proot_names                 lib_descriptor_
                         000172 E                           find_descriptor
                         000176 P_me                        find_descriptor
                         000200 i                           find_descriptor

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$decode_entry_value        cv_entry_                     lib_free_node_$array          lib_get_tree_$lib_root_node
lib_get_tree_$root_array      lib_get_tree_$root_array_info match_star_name_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$name_not_found   error_table_$noarg            error_table_$nomatch          error_table_$out_of_bounds
error_table_$process_stopped  error_table_$request_not_recognized
error_table_$unimplemented_version                          multics_libraries_$descriptor




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     55 000104       138 000112       141 000151       142 000153       145 000154       148 000204       149 000206
    152 000207       155 000237       156 000241       159 000242       162 000272       163 000274       166 000275
    169 000325       170 000327       197 000330       198 000332       200 000333       201 000335       202 000350
    204 000352       205 000354       206 000357       207 000365       208 000370       211 000371       212 000373
    213 000377       214 000405       216 000407       217 000413       218 000416       221 000417       222 000421
    223 000425       224 000433       226 000435       227 000441       228 000444       231 000445       232 000447
    233 000464       236 000466       237 000470       238 000471       239 000501       240 000507       241 000517
    242 000527       244 000534       245 000547       247 000550       248 000601       250 000603       251 000605
    252 000607       254 000610       256 000612       257 000617       260 000663       261 000667       262 000670
    264 000671       266 000674       267 000676       269 000711       270 000715       273 000724       274 000726
    277 000727       278 000731       281 000737       283 000742       284 000751       291 000752       300 000762
    301 000771       302 000773       303 001003       308 001004       317 001020       319 001032       320 001044
    322 001055       329 001056       355 001105       356 001112       357 001114       358 001116       360 001117
    361 001120       363 001123       364 001142       365 001144       366 001147       367 001166       368 001170
    369 001173       371 001203       372 001205       373 001207       375 001210       376 001212       377 001213
    380 001222       381 001224       382 001236       384 001240       385 001242       386 001245       387 001252
    389 001253       390 001264       392 001270       393 001272       394 001302       395 001304       396 001310
    397 001312       399 001313       401 001316       403 001317       405 001322       412 001323       435 001353
    436 001355       437 001357       438 001372       440 001374       441 001376       442 001401       443 001404
    446 001405       448 001407       449 001424       451 001426       452 001430       453 001437       454 001445
    455 001455       456 001465       458 001472       459 001505       461 001506       462 001537       464 001541
    465 001543       466 001545       468 001546       471 001553       474 001627       475 001633       476 001634
    478 001635       480 001640       481 001642       484 001655       485 001657       486 001661       487 001664
    488 001672       489 001673       491 001675       502 001676       531 001715       533 001720       534 001732
    536 001734       537 001737       538 001742       541 001743       543 001755       544 001771       545 002000
    546 002005       547 002006       548 002017       550 002026       551 002043       553 002044       554 002075
    555 002101       557 002102       559 002104       561 002106       562 002110       563 002123       564 002134
    565 002137       566 002141       568 002145       569 002150       570 002152       493 002153       495 002161
    577 002162       595 002164       596 002167       597 002171       598 002172       599 002176       600 002201
    603 002202       604 002210       605 002217       606 002226       607 002227       609 002230       610 002250
    611 002265       612 002272       614 002350       615 002413       616 002432       617 002440       618 002444
    619 002447       620 002451       622 002452       623 002457       624 002464       628 002465


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
