	COMPILATION LISTING OF SEGMENT display_cpu_error
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/13/85  1115.1 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       12 
       13 /* DISPLAY_CPU_ERROR: Command to display MCs and hregs from CPU errors from
       14*   the syserr log */
       15 
       16 /* Written Oct 1982 by Rich Coppola */
       17 /* Most of this program was borrowed from the mos_edac_summary command. */
       18 /*
       19*   Modified Jan 1984 by Paul Farley to add checking for other syserr entry
       20*   types (Currently hardware_fault and verify_lock), which is defined by
       21*   display_cpu_error_binary_defs.  This is being implemented by using three
       22*   new control arguments "-all", "-match" and "-exclude".  The default will
       23*   be to only examine the hardware_fault entries.
       24*   Modified 1985-02-21, EJ Sharpe: use syserr_fault_msg.incl.pl1, use date_time_$format
       25**/
       26 
       27 display_cpu_error:
       28      proc;
       29 
       30 /* Automatic */
       31 
       32 dcl  CPU_TAGS char (16) int static options (constant) init ("ABCDEFGHabcdefgh");
       33 
       34 dcl  arg char (arg_len) based (arg_ptr);		/* A command argument */
       35 dcl  arg_copy char (15) varying;			/* Temp copy of an argument */
       36 dcl  arg_count fixed bin;				/* The number of arguments */
       37 dcl  arg_len fixed bin;				/* Length of an argument */
       38 dcl  arg_list_ptr ptr;				/* Pointer to commands argument list */
       39 dcl  arg_no fixed bin init (1);			/* For scanning argument list */
       40 dcl  arg_ptr ptr;					/* Pointer to an argument */
       41 dcl  argc fixed bin;				/* for getting cpu args */
       42 dcl  def_idx fixed bin;				/* binary_def index */
       43 
       44 dcl  code fixed bin (35);				/* Standard system status code */
       45 dcl  cpu_cnt fixed bin init (0);			/* Number of CPUs requested */
       46 
       47 dcl  expand_sw bit (1) init ("0"b);			/* Set if user just wants hregs interpreted */
       48 
       49 dcl  for_arg char (for_len) based (for_ptr);		/* This is the -for argument */
       50 dcl  for_len fixed bin;				/* Saved length of -for argument */
       51 dcl  for_ptr ptr;					/* Saved pointer to the -for argument */
       52 dcl  for_sw bit (1) init ("0"b);			/* Set if -for used */
       53 dcl  for_time fixed bin (71);				/* Time specified on -for */
       54 dcl  from_sw bit (1) init ("0"b);			/* Set if -from used */
       55 dcl  from_time fixed bin (71);			/* Time specified on -from */
       56 
       57 dcl  scan_text bit (1) init ("0"b);			/* Set if -match used */
       58 dcl  match_sw bit (1) init ("0"b);			/* Set if -match used */
       59 dcl  exclude_sw bit (1) init ("0"b);			/* Set if -exclude used */
       60 
       61 dcl  hr_switches bit (5);
       62 dcl  mask bit (36) aligned init ("0"b);			/* Mask of significant bits in status word */
       63 dcl  more_args bit (1);				/* Set while there are more arguments to scan */
       64 dcl  area_ptr ptr init (null);			/* Free area pointer */
       65 dcl  free_area area based (area_ptr);			/* Free area for allocating strings */
       66 dcl  msg_seq fixed bin (35);				/* Sequence number */
       67 dcl  msg_time fixed bin (71);				/* Time of syserr message */
       68 
       69 dcl  only_scu bit (1) init ("0"b);			/* 1 => don't display hregs */
       70 dcl  open_status bit (36) aligned;			/* Code from syserr_log_util_$open */
       71 dcl  plural_sw bit (1);
       72 dcl  ptr_array (1) ptr;				/* An array of pointers as required by get_temp_segment_ */
       73 dcl  (print_cnt, read_cnt) fixed bin init (-1);
       74 
       75 dcl  segs_allocated bit (1) init ("0"b);		/* Set after work segments created */
       76 dcl  tab_cnt fixed bin init (0);			/* Number of seperate status found */
       77 dcl  thread_sw bit (1) init ("1"b);			/* Set to thread hregs */
       78 dcl  (tm1, tm2) char (24);				/* Used to call date_time_ */
       79 dcl  to_sw bit (1) init ("0"b);			/* Set if -to used */
       80 dcl  to_time fixed bin (71);				/* Time specified on -to */
       81 
       82 dcl  workp ptr;					/* Pointer to work segment */
       83 dcl  1 work aligned based (workp),			/* Declaration of work segment */
       84        2 cpureq (8) char (1),				/* Table of requested CPUs */
       85        2 buffer (500) bit (36) aligned;			/* Syserr messages are read here */
       86 
       87 dcl  ctext char (512);				/* Text of current message */
       88 dcl  ctextl fixed bin;				/* Length of current message */
       89 dcl  1 string_data based,				/* Data for match or exclude */
       90        2 first ptr,					/* Pointer to first string */
       91        2 last ptr,					/* Pointer to last string */
       92        2 count fixed bin init (0);			/* Number of strings in list */
       93 
       94 dcl  1 match_data like string_data automatic;		/* List of match strings */
       95 dcl  1 exclude_data like string_data automatic;		/* List of exclude strings */
       96 
       97 dcl  1 str aligned based,				/* Structure allocated for each string */
       98        2 next ptr init (null),			/* Pointer to next in list */
       99        2 len fixed bin init (arg_len),			/* Length of messaage */
      100        2 data char (arg_len refer (str.len));		/* The string */
      101 
      102 /* Constants */
      103 
      104 dcl  name char (17) int static options (constant) init ("display_cpu_error");
      105 						/* Name of procedure */
      106 
      107 /* External entries */
      108 
      109 dcl  com_err_ entry options (variable);
      110 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
      111 dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
      112 dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
      113 dcl  cu_$arg_list_ptr entry (ptr);
      114 dcl  cu_$arg_count entry (fixed bin);
      115 dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
      116 dcl  cv_bin_$oct entry (fixed bin, char (12));
      117 dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
      118 dcl  db_print entry (ptr, char (*) aligned, ptr, char (*), fixed bin, fixed bin, ptr, fixed bin, fixed bin);
      119 dcl  error_table_$end_of_info ext fixed bin (35);
      120 dcl  error_table_$badopt ext fixed bin (35);
      121 dcl  get_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
      122 dcl  hran_$hranl entry (ptr, ptr, bit (1));
      123 dcl  hran_$no_thread entry (ptr, ptr, bit (5));
      124 dcl  ioa_ entry options (variable);
      125 dcl  ioa_$rsnnl entry () options (variable);
      126 dcl  iox_$user_output ptr ext;
      127 dcl  print_syserr_msg_$open_err entry (bit (36) aligned, char (*), fixed bin (35));
      128 dcl  release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
      129 dcl  get_system_free_area_ entry returns (ptr);
      130 dcl  syserr_log_util_$open entry (bit (36) aligned, fixed bin (35));
      131 dcl  syserr_log_util_$read entry (ptr, fixed bin, fixed bin, fixed bin (35));
      132 dcl  syserr_log_util_$close entry (fixed bin (35));
      133 dcl  syserr_log_util_$search entry (fixed bin (71), fixed bin (71), fixed bin (35), fixed bin (35));
      134 
      135 dcl  cleanup condition;
      136 
      137 dcl  (length, fixed, addr, addrel, baseptr, substr, null, hbound, lbound, bin, index, rtrim, unspec, verify) builtin;
      138 
      139 
      140 /* Initialization */
      141 
      142 	on cleanup call clean_up;
      143 
      144 	call get_temp_segments_ (name, ptr_array, code);	/* Get a work segment */
      145 	if code ^= 0 then do;
      146 	     call com_err_ (code, name, "Can't get temp segment");
      147 	     go to done;
      148 	     end;
      149 	segs_allocated = "1"b;			/* Recpuber that they are allocated */
      150 	workp = ptr_array (1);			/* Copy pointer to my segment */
      151 
      152 	call cu_$arg_list_ptr (arg_list_ptr);		/* Need pointer to argument list */
      153 	call cu_$arg_count (arg_count);		/* And the length */
      154 	more_args = (arg_count > 0);			/* Set if args to scan */
      155 	call scan_args;				/* Scan the argument list */
      156 
      157 	call syserr_log_util_$open (open_status, code);	/* Open the syserr log */
      158 	if code ^= 0 | substr (open_status, 1, 2) ^= "11"b then do;
      159 						/* If error */
      160 	     call print_syserr_msg_$open_err (open_status, name, code);
      161 	     if code ^= 0 then go to done;		/* Not recoverable */
      162 	     end;
      163 
      164 	if ^from_sw then do;			/* No -from, so start at beginning */
      165 	     call syserr_log_util_$search (0, msg_time, msg_seq, code);
      166 	     if code ^= 0 then do;
      167 		call com_err_ (code, name, "Can't find first message in log.");
      168 		go to done;
      169 		end;
      170 	     from_time = msg_time;			/* Official starting time */
      171 	     end;
      172 	else do;					/* -from used, find right message */
      173 	     call syserr_log_util_$search (from_time, msg_time, msg_seq, code);
      174 	     if code ^= 0 then do;
      175 		call com_err_ (code, name, "Locating first message requested.");
      176 		go to done;
      177 		end;
      178 	     end;
      179 
      180 	if for_sw then do;				/* Now can compute -for limit */
      181 	     call convert_date_to_binary_$relative (for_arg, to_time, from_time, code);
      182 	     if code ^= 0 then do;
      183 		call com_err_ (code, name, "-for ^a", for_arg);
      184 		go to done;
      185 		end;
      186 	     to_sw = "1"b;				/* Now, just as if -to was specified */
      187 	     end;
      188 	if ^to_sw then to_time = from_time;		/* Initialize last message time */
      189 
      190 	syserr_msgp = addr (work.buffer);		/* Read here */
      191 
      192 
      193 	call print_header;
      194 
      195 /* Loop thru the file */
      196 	read_cnt = 0;
      197 loop:
      198 	call syserr_log_util_$read (syserr_msgp, hbound (buffer, 1), (0), code);
      199 	if code ^= 0 then do;
      200 	     if code = error_table_$end_of_info then go to done;
      201 	     call com_err_ (code, name, "Reading syserr log");
      202 	     go to done;
      203 	     end;
      204 
      205 	read_cnt = read_cnt + 1;
      206 	if to_sw then do;				/* If time limit */
      207 	     if syserr_msg.time > to_time then go to done;
      208 	     end;
      209 	else to_time = syserr_msg.time;		/* Save last message time */
      210 
      211 	if scan_text then do;
      212 	     do def_idx = lbound (display_cpu_error_binary_defs, 1) to hbound (display_cpu_error_binary_defs, 1);
      213 		if display_cpu_error_binary_defs (def_idx) = syserr_msg.data_code then goto continue_check;
      214 	     end;
      215 	     goto loop;				/* wrong type */
      216 
      217 continue_check:
      218 	     if syserr_msg.data_size <= 0 then goto loop; /* no binary data */
      219 	     ctextl = syserr_msg.text_len;		/* Save length */
      220 	     substr (ctext, 1, ctextl) = syserr_msg.text; /* Save data */
      221 	     if match_sw
      222 	     then					/* If matching strings */
      223 		if ^match_string (addr (match_data)) then goto loop;
      224 	     if exclude_sw
      225 	     then					/* If excluding by string */
      226 		if match_string (addr (exclude_data)) then goto loop;
      227 	     call print_it;
      228 	     goto loop;
      229 	     end;					/* DEFAULT */
      230 	if syserr_msg.data_code = SB_hw_fault & syserr_msg.data_size > 0 then call print_it;
      231 	go to loop;
      232 
      233 /* End of log reached */
      234 
      235 /* End of command */
      236 
      237 done:
      238 	if print_cnt = 0 then do;			/* if no messages printed */
      239 	     if read_cnt = 0 then plural_sw = "1"b;
      240 	     call com_err_ (0, name, "No messages matched criteria given. ^d message^v(s ^) read.", read_cnt, plural_sw)
      241 		;
      242 	     end;
      243 
      244 
      245 	call clean_up;
      246 	return;
      247 
      248 miss_err:
      249 	call com_err_ (0, name, "Argument required after ^a.", arg_copy);
      250 	goto done;
      251 
      252 /* Procedure to scan the argument list */
      253 
      254 scan_args:
      255      proc;
      256 
      257 	do while (more_args);			/* Do while thins to look at */
      258 	     call get_arg;
      259 	     if arg = "-from" | arg = "-fm" then do;	/* Start time */
      260 		from_sw = "1"b;
      261 		call time_arg (from_time);
      262 		end;
      263 	     else if arg = "-to" then do;		/* Ending time */
      264 		to_sw = "1"b;
      265 		call time_arg (to_time);
      266 		end;
      267 	     else if arg = "-for" then do;		/* Time limit */
      268 		for_sw = "1"b;
      269 		call time_arg (for_time);		/* For syntax checking only */
      270 		for_len = arg_len;			/* Save pointer to this argument */
      271 		for_ptr = arg_ptr;
      272 		end;
      273 	     else if arg = "-expand" | arg = "-exp" then do;
      274 		thread_sw = "0"b;
      275 		expand_sw = "1"b;
      276 		end;
      277 	     else if arg = "-nothread" then thread_sw = "0"b;
      278 	     else if arg = "-mc" then only_scu = "1"b;
      279 	     else if arg = "-cpu" then do;		/* List of CPUs */
      280 		if ^more_args then do;		/* Need more args */
      281 no_cpu:
      282 		     call com_err_ (0, name, "Argument missing after -cpu");
      283 		     go to done;
      284 		     end;
      285 		call get_arg;
      286 		if verify (arg, CPU_TAGS) ^= 0 then do;
      287 new_cpu:
      288 		     call com_err_ (0, name, "Invalid CPU Tag(s) ^a", arg);
      289 		     return;
      290 		     end;
      291 
      292 		if arg_len > 8 then do;
      293 		     call com_err_ (0, name, "Too many CPUs specified (^a).", arg);
      294 		     return;
      295 		     end;
      296 
      297 		do argc = 1 to arg_len;
      298 		     work.cpureq (argc) = substr (arg, argc, 1);
      299 		     cpu_cnt = cpu_cnt + 1;		/* Count CPU found */
      300 		end;
      301 		end;
      302 
      303 	     else if arg = "-all" | arg = "-a" then scan_text = "1"b;
      304 						/* scan all valid syserr types. */
      305 	     else if arg = "-match" then do;
      306 		call string_check (addr (match_data));	/* Add to match string */
      307 		match_sw = "1"b;
      308 		scan_text = "1"b;
      309 		end;
      310 
      311 	     else if arg = "-exclude" | arg = "-ex" then do;
      312 		call string_check (addr (exclude_data));/* Add to exclude list */
      313 		exclude_sw = "1"b;
      314 		scan_text = "1"b;
      315 		end;
      316 
      317 	     else do;				/* Bad arg */
      318 		call com_err_ (error_table_$badopt, name, "^a", arg);
      319 		go to done;
      320 		end;
      321 	end;
      322 
      323 	if to_sw & for_sw then do;			/* Conflict */
      324 	     call com_err_ (0, name, "Conflicting arguments: -to and -for");
      325 	     go to done;
      326 	     end;
      327 
      328 	return;
      329 
      330      end scan_args;
      331 
      332 /* Procedure to return the next argument from command line */
      333 
      334 get_arg:
      335      proc;
      336 
      337 	call cu_$arg_ptr_rel (arg_no, arg_ptr, arg_len, code, arg_list_ptr);
      338 	if code ^= 0 then do;			/* Should never happen */
      339 	     call com_err_ (code, name, "Arg ^d", arg_no);
      340 	     go to done;
      341 	     end;
      342 	arg_no = arg_no + 1;			/* For next call */
      343 	more_args = (arg_no <= arg_count);
      344 	return;
      345 
      346 put_arg:
      347      entry;					/* Entry to return argument after scanning too far */
      348 	arg_no = arg_no - 1;
      349 	more_args = (arg_no <= arg_count);
      350 	return;
      351 
      352      end get_arg;
      353 
      354 /* Procedure to convert a time argument */
      355 
      356 time_arg:
      357      proc (t);
      358 
      359 dcl  arg_copy char (10) var;				/* Save copy of arg here */
      360 dcl  t fixed bin (71);				/* The time to ouput */
      361 
      362 
      363 	arg_copy = arg;
      364 	if ^more_args then do;			/* Must be more */
      365 	     call com_err_ (0, name, "Argument required after ^a.", arg_copy);
      366 	     go to done;
      367 	     end;
      368 	call get_arg;
      369 	call convert_date_to_binary_ (arg, t, code);
      370 	if code ^= 0 then do;
      371 	     call com_err_ (code, name, "^a ^a", arg_copy, arg);
      372 	     go to done;
      373 	     end;
      374 
      375 	return;
      376 
      377      end time_arg;
      378 
      379 /* Procedure to add a string to list of strings */
      380 
      381 string_check:
      382      proc (p);
      383 
      384 dcl  p ptr;					/* Pointer to header block */
      385 dcl  1 sdata like string_data based (p);		/* The header block */
      386 dcl  link ptr;					/* A temp pointer */
      387 
      388 	arg_copy = arg;				/* Save copy of control argument */
      389 	if ^more_args then go to miss_err;		/* Another argument is needed */
      390 	call get_arg;				/* So get it */
      391 	if area_ptr = null then area_ptr = get_system_free_area_ ();
      392 						/* If this is first allocate */
      393 scheck:
      394 	allocate str in (free_area) set (link);
      395 	if sdata.count = 0
      396 	then sdata.first = link;			/* If first in chain */
      397 	else sdata.last -> str.next = link;		/* If not first, add to chain */
      398 	sdata.last = link;				/* This is last in chain */
      399 	sdata.count = sdata.count + 1;		/* Count it */
      400 	link -> str.data = arg;			/* Copy the real string */
      401 	if ^more_args then return;			/* If no more args, then all done here */
      402 	call get_arg;				/* Get next arg */
      403 	if substr (arg, 1, 1) ^= "-" then go to scheck;	/* If not control arg, treat as string */
      404 	call put_arg;				/* Return argument so next user can get it */
      405 	return;
      406 
      407      end string_check;
      408 
      409 /* Procedure to match a string */
      410 
      411 match_string:
      412      proc (p) returns (bit (1) aligned);
      413 
      414 dcl  (p, q) ptr;
      415 dcl  1 mdata like string_data based (p);		/* String list structure */
      416 
      417 	if mdata.count = 0 then return ("0"b);		/* Return no if list empty */
      418 	q = mdata.first;				/* Get first in list */
      419 	do while (q ^= null);			/* Do until end */
      420 	     if index (substr (ctext, 1, ctextl), q -> str.data) ^= 0 then return ("1"b);
      421 	     q = q -> str.next;
      422 	end;
      423 
      424 	return ("0"b);				/* No match */
      425 
      426      end match_string;
      427 
      428 /* Procedure to print a cpu error entry */
      429 
      430 print_it:
      431      proc;
      432 
      433 dcl  PRS (0:7) ptr aligned;
      434 dcl  cpu char (1);
      435 dcl  cpu_tag (8) char (1) init ("a", "b", "c", "d", "e", "f", "g", "h");
      436 dcl  error_msg char (100) aligned;
      437 dcl  found bit (1);
      438 dcl  hr_ptr ptr;
      439 dcl  tcpu char (1);
      440 dcl  (i, j) fixed bin;
      441 
      442 	found = "0"b;
      443 	fmsgp = addr (syserr_msg.data);
      444 	scup = addr (mach_cond.scu);
      445 	hr_ptr = addr (fault_msg.hist_reg);
      446 	i = index (syserr_msg.text, " CPU ");
      447 	if i = 0 then do;
      448 	     if cpu_cnt = 0 then goto p_data;		/* any CPU */
      449 	     i = fixed (scu.cpu_no, 17) + 1;
      450 	     cpu = cpu_tag (i);
      451 	     do j = 1 to cpu_cnt while (found = "0"b);
      452 		if cpu = work.cpureq (j) then found = "1"b;
      453 	     end;
      454 	     if ^found then return;			/* This cpu not in list */
      455 	     goto p_data;
      456 	     end;
      457 	tcpu = substr (syserr_msg.text, i + 5, 1);
      458 	cpu = cpu_tag (index ("ABCDEFGH", tcpu));
      459 	if cpu_cnt > 0
      460 	then do j = 1 to cpu_cnt while (found = "0"b);
      461 	     if cpu = work.cpureq (j) then found = "1"b;
      462 	end;
      463 
      464 	if cpu_cnt > 0
      465 	then if ^found then return;			/*  don't count this one */
      466 
      467 p_data:						/* found one, print it */
      468 	call ioa_ ("^/^a ^d^/^a", date_time_$format ("date_time", (syserr_msg.time), "", ""), syserr_msg.seq_num,
      469 	     syserr_msg.text);
      470 	unspec (PRS) = unspec (mach_cond.prs);
      471 	call ioa_ ("^/Pointer Registers:^-^12p  ^12p  ^12p  ^12p^/^2-^12p  ^12p  ^12p  ^12p", PRS);
      472 	call ioa_ (
      473 	     "^/Index Registers:^-x0: ^6.3b x1: ^6.3b x2: ^6.3b x3: ^6.3b^/^2-x4: ^6.3b x5: ^6.3b x6: ^6.3b x7: ^6.3b",
      474 	     mach_cond.x);
      475 	call ioa_ ("^2-A: ^w Q: ^w EXP: ^3.3b^/^2-Timer: ^9.3b Ring Alarm Reg: ^.3b^/", mach_cond.a, mach_cond.q,
      476 	     "0"b || mach_cond.e, mach_cond.t, mach_cond.ralr);
      477 	if mach_cond.mask ^= "0"b
      478 	then call ioa_ ("Memory Controller Mask: ^12.3b ^12.3b", substr (mach_cond.mask, 1, 36),
      479 		substr (mach_cond.mask, 37, 36));
      480 	if mach_cond.errcode ^= 0 then do;
      481 	     call convert_status_code_ ((mach_cond.errcode), (""), error_msg);
      482 	     call ioa_ ("MC.ERRCODE:^/^a", rtrim (error_msg));
      483 	     end;
      484 
      485 	call ioa_ ("MC Fault Time: ^a  (^18.3b)",
      486 	     date_time_$format ("date_time", fixed (mach_cond.fault_time, 71), "", ""), mach_cond.fault_time);
      487 	call interpret_fault_reg ((mach_cond.fault_reg));
      488 	if mach_cond.cpu_type ^= 0
      489 	then if mach_cond.ext_fault_reg ^= "0"b then call interpret_ext_fault_reg ((mach_cond.ext_fault_reg));
      490 	if scu.mif then call ioa_ ("EIS Info:^-^w ^w ^w ^w^/^-^w ^w ^w ^w", mach_cond.eis_info);
      491 
      492 	call ioa_ ("^/SCU Data:^2-^w ^w ^w ^w^/^2-^w ^w ^w ^w^/", mach_cond.scu);
      493 	call interp_scu (scup);
      494 	print_cnt = print_cnt + 1;
      495 	if only_scu = "1"b then return;
      496 
      497 	hr_switches = expand_sw || "1"b || "1"b || "1"b || "1"b;
      498 	call ioa_ ("^/History Register Data:^/");
      499 	if thread_sw
      500 	then call hran_$hranl (hr_ptr, null, "0"b);
      501 	else call hran_$no_thread (hr_ptr, null, hr_switches);
      502 
      503 	return;
      504 
      505      end print_it;
      506 
      507 
      508 /* Procedure to print the header line */
      509 
      510 print_header:
      511      proc;
      512 
      513 
      514 	tm1 = date_time_$format ("date_time", from_time, "", "");
      515 						/* Starting time is easy */
      516 
      517 	if to_sw
      518 	then tm2 = date_time_$format ("date_time", to_time, "", "");
      519 						/* Stop time is easy if given */
      520 	else do;					/* Otherwise get last message  */
      521 	     call syserr_log_util_$search (-1, msg_time, msg_seq, code);
      522 						/* Search to eof */
      523 	     if code ^= 0 then do;			/* Should not fail */
      524 log_err:
      525 		call com_err_ (code, name, "From syserr_log_util_$search.");
      526 		return;
      527 		end;
      528 
      529 	     tm2 = date_time_$format ("date_time", msg_time, "", "");
      530 						/* Edit time */
      531 	     call syserr_log_util_$search (from_time, msg_time, msg_seq, code);
      532 						/* Back to first msg */
      533 	     if code ^= 0 then go to log_err;
      534 	     end;
      535 
      536 	call ioa_ ("^/Syserr log from ^a to ^a", tm1, tm2);
      537 	print_cnt = 0;
      538 	return;
      539 
      540      end print_header;
      541 
      542 
      543 
      544 /* Cleanup handler */
      545 
      546 clean_up:
      547      proc;
      548 
      549 	call syserr_log_util_$close (code);
      550 
      551 	if segs_allocated then do;
      552 	     segs_allocated = "0"b;
      553 	     call release_temp_segments_ (name, ptr_array, code);
      554 	     end;
      555 	return;
      556 
      557      end clean_up;
      558 
      559 /* Internal procedure to print fault reg data */
      560 
      561 interpret_fault_reg:
      562      proc (fault_reg);
      563 
      564 dcl  fault_reg bit (36);
      565 dcl  (fault_no, break) fixed bin;
      566 dcl  1 illeg_acts based (addr (fault_reg)),
      567        (
      568        2 pad bit (16),
      569        2 IA (4) bit (4),
      570        2 pad1 bit (4)
      571        ) unal;
      572 dcl  port_name (4) char (3) int static options (constant) init ("A: ", "B: ", "C: ", "D: ");
      573 
      574 dcl  (line1, line2) char (80) varying;
      575 dcl  (line1_sw, line2_sw) bit (1) init ("0"b);
      576 
      577 dcl  FAULT_TYPES (36) char (15) var int static options (constant)
      578 	init ("ILL OP", "ILL MOD", "ILL SLV", "ILL PROC", "NEM", "OOB", "WRT INH", "PROC PAR-UPR", "PROC PAR-LWR",
      579 	"$CON A", "$CON B", "$CON C", "$CON D", "ONC (DA ERR1)", "ONC (DA ERR2)", "", "", "", "", "", "", "", "", "",
      580 	"", "", "", "", "", "", "", "", "CACHE-PAR DIR", "CACHE-PAR STR", "CACHE-PAR IA", "CACHE-PAR BLK");
      581 
      582 
      583 dcl  SC_IA_TYPES (1:15) char (42) var int static options (constant)
      584 	init ("Unassigned (01)", "Non-existent Address (02)", "Stop on Condition (03)", "Unassigned (04)",
      585 	"Data Parity, Store to SC (05)", "Data Parity in Store (06)", "Data Parity in Store AND Store to SC (07)",
      586 	"Not Control (10)", "Port Not Enabled (11)", "Illegal Command (12)", "Store Not Ready ( 13)",
      587 	"ZAC Parity, Active Module to SC (14)", "Data Parity, Active Module to SC (15)", "ZAC Parity, SC to Store (16)",
      588 	"Data Parity, SC to Store (17)");
      589 
      590 
      591 	if fault_reg = "0"b then return;
      592 
      593 
      594 	line1, line2 = "";
      595 
      596 	do fault_no = 1 to 15;
      597 	     if substr (fault_reg, fault_no, 1) = "1"b then do;
      598 		line1 = line1 || FAULT_TYPES (fault_no) || ", ";
      599 		line1_sw = "1"b;
      600 		end;
      601 	end;
      602 
      603 	break = 0;
      604 	do fault_no = 1 to 4 while (break = 0);		/* do IAs now */
      605 	     if IA (fault_no) then do;
      606 		line2 = "Ilegal Action on CPU Port " || port_name (fault_no);
      607 		line2 = line2 || SC_IA_TYPES (bin (IA (fault_no), 4)) || ", ";
      608 		line2_sw = "1"b;
      609 		break = 1;
      610 		end;
      611 	end;
      612 
      613 	do fault_no = 33 to 36;
      614 	     if substr (fault_reg, fault_no, 1) = "1"b then do;
      615 		line1 = line1 || FAULT_TYPES (fault_no) || ", ";
      616 		line1_sw = "1"b;
      617 		end;
      618 	end;
      619 
      620 	if line1_sw
      621 	then					/* remove trailing comma & space */
      622 	     line1 = substr (line1, 1, (length (line1) - 2));
      623 	if line2_sw then line2 = substr (line2, 1, (length (line2) - 2));
      624 
      625 	call ioa_ ("^/Fault Register:^-^w^[  (^a)^;^s^]^[^/^18t(^a)^]", fault_reg, line1_sw, line1, line2_sw, line2);
      626 
      627 	return;
      628 
      629 
      630 interpret_ext_fault_reg:
      631      entry (ext_fault_reg);
      632 
      633 dcl  ext_fault_reg bit (15);
      634 dcl  indx fixed bin;
      635 
      636 dcl  EXT_FAULT_TYPES (15) char (39) var int static options (constant)
      637 	init ("Bffr. Ovflw - Port A", "Bffr. Ovflw - Port B", "Bffr. Ovflw - Port C", "Bffr. Ovflw - Port D",
      638 	"Bffr. Ovflw - Primary Dir", "Write Notify Parity Error on ANY Port", "Dup. Dir. LVL 0 Parity Error",
      639 	"Dup. Dir. LVL 1 Parity Error", "Dup. Dir. LVL 2 Parity Error", "Dup. Dir. LVL 3 Parity Error",
      640 	"Dup. Dir. Multi Match Error", "PTW Ass. Mem. Parity Error", "PTW Ass. Mem. Match Error",
      641 	"SDW Ass. Mem. Parity Error", "SDW Ass. Mem. Match Error");
      642 
      643 
      644 	line1 = "";
      645 	do indx = 1 to 15;
      646 	     if substr (ext_fault_reg, indx, 1) = "1"b then line1 = line1 || EXT_FAULT_TYPES (indx) || ", ";
      647 	end;
      648 
      649 	if line1 ^= "" then do;
      650 	     line1 = substr (line1, 1, (length (line1) - 2));
      651 	     call ioa_ ("^/DPS8 Extended Fault Register: ^5.3b^/^32t(^a)", ext_fault_reg, line1);
      652 	     end;
      653 
      654 
      655 	return;
      656 
      657 
      658      end interpret_fault_reg;
      659 
      660 
      661 
      662 interp_scu:
      663      proc (scup);
      664 
      665 dcl  at_by_wd char (2);
      666 dcl  cpul (0:7) char (1) int static options (constant) init ("a", "b", "c", "d", "e", "f", "g", "h");
      667 dcl  cvbinbuf char (12);
      668 dcl  flt_bf char (24) varying;
      669 dcl  flt_ln char (100);
      670 dcl  fltdtab (0:35) bit (1) based (byptr) unaligned;
      671 dcl  iocbp ptr;
      672 dcl  scup ptr;					/* pointer to SCU Data */
      673 dcl  TAG_ptr ptr;					/* pointer to tag table */
      674 dcl  1 TAG (64) based (TAG_ptr),
      675        2 code char (4) unal,
      676        2 pad bit (8) unal,
      677        2 chain bit (1);
      678 
      679 dcl  tag_prt bit (1) init ("0"b);
      680 dcl  tag_ char (4) init ("");
      681 dcl  (lnpos, flt_lng, inst6, i, j) fixed bin;
      682 dcl  (byptr, refptr) ptr;
      683 dcl  tsrpr bit (1);
      684 
      685 dcl  1 scud based (scup) aligned,
      686        2 wd0 unaligned,				/* :: */
      687          3 prr bit (3),				/* Procedure Ring Register */
      688          3 psr bit (15),				/* Procedure Segment Register */
      689          3 apust bit (18),				/* APU Status */
      690        2 wd1 unaligned,				/* :: */
      691          3 fid bit (20),				/* fault/interrupt data */
      692          3 ill_act_lns bit (4),			/* Illegal Action Lines */
      693          3 ill_act_chan bit (3),			/* Illegal Action Channel (Port) */
      694          3 con_chan bit (3),				/* Connect Channel (Port) */
      695          3 fi bit (6),				/* Fault/Interrupt Vector Address */
      696        2 wd2 unaligned,				/* :: */
      697          3 trr bit (3),				/* Temporary Ring Register */
      698          3 tsr bit (15),				/* Temporary Segment Register */
      699          3 mbz bit (9),				/* :: */
      700          3 cpu bit (3),				/* Processor Number */
      701          3 tmd bit (6),				/* :: */
      702        2 wd3 fixed bin (35),				/* :: */
      703        2 wd4 unaligned,				/* :: */
      704          3 ict bit (18),				/* Instruction Counter */
      705          3 ir bit (18),				/* Indicator Register */
      706        2 wd5 unaligned,				/* :: */
      707          3 ca bit (18),				/* Computed Address */
      708          3 cus bit (12),				/* CU Status */
      709          3 ct_hold bit (6),				/* remember mod field */
      710        2 wd6 fixed bin (35),				/* Even Instruction */
      711        2 wd7 fixed bin (35);				/* Odd Instruction */
      712 
      713 /* Constants */
      714 
      715 dcl  ill_act (0:15) char (37) varying int static options (constant)
      716 	init ("...", "Unassigned", "Non Existent Address", "Fault on Condition", "Unassigned",
      717 	"Data Parity (Store -> SCU)", "Data Parity in Store", "Data Parity (Store -> SCU & in Store)", "Not Control",
      718 	"Port Not Enabled", "Illegal Command", "Store Not Ready", "ZAC Parity (Processor -> SCU)",
      719 	"Data Parity (Processor -> SCU)", "ZAC parity (SCU -> Store)", "Data Parity (SCU -> Store)");
      720 
      721 dcl  indrs (18:31) char (4) varying int static options (constant)
      722 	init ("zero", "neg", "cary", "ovfl", "eovf", "eufl", "oflm", "tro", "par", "parm", "^bar", "tru", "mif", "abs");
      723 
      724 dcl  APU (18:32) char (6) varying int static options (constant)
      725 	init ("priv", "xsf", "sdwamm", "sd-on", "ptwamm", "pt-on", "pi-ap", "dsptw", "sdwnp", "sdwp", "ptw", "ptw2",
      726 	"fap", "fanp", "fabs");
      727 
      728 dcl  CU (18:29) char (3) varying int static options (constant)
      729 	init ("rf", "rpt", "rd", "rl", "pot", "pon", "xde", "xdo", "itp", "rfi", "its", "fif");
      730 
      731 dcl  g1and7flts (5) bit (6) int static options (constant) unaligned init ("01"b3, "11"b3, "21"b3, "31"b3, "37"b3);
      732 
      733 dcl  grp1flt (0:19) char (24) varying int static options (constant)
      734 	init ("Illegal Ring Order", "Not in Execute Bracket", "Execute Bit off", "Not In Read Bracket", "Read Bit Off",
      735 	"Not In Write Bracket", "Write Bit Off", "Not A Gate", "Not In Call Bracket", "Outward Call",
      736 	"Bad Outward Call", "Inward Return", "Cross Ring Transfer", "Ring Alarm", "Associative Memory",
      737 	"Out of Segment Bounds", "Processor Parity Upper", "Processor Parity Lower", "SC To Proc. Seq. Error 1",
      738 	"SC To Proc. Seq. Error 2");
      739 
      740 dcl  grp2flt (0:6) char (24) varying int static options (constant)
      741 	init ("Illegal Segment Number", "Illegal Op Code", "Illegal Address & Mod", "Illegal Slave Procedure",
      742 	"Illegal Procedure", "Non Existent Address", "Out Of Bounds");
      743 
      744 dcl  flt_int_typ (0:63) char (24) varying int static options (constant)
      745 	init ("...", "Shutdown", "...", "Store", "Bulk Store 0 Term", "MME 1", "...", "Fault Tag 1", "IOM 0 Overhead",
      746 	"Timer Runout", "IOM 1 Overhead", "Command", "IOM 2 Overhead", "Derail", "IOM 3 Overhead", "Lockup",
      747 	"IOM 0 Terminate Ch 40-77", "Connect", "IOM 1 Terminate Ch 40-77", "Parity", "Bulk Store 1 Term",
      748 	"Illegal Procedure", "...", "Op Not Complete", "IOM 0 Terminate", "Startup", "IOM 1 Terminate", "Overflow",
      749 	"IOM 2 Terminate", "Divide Check", "IOM 3 Terminate", "Execute", "IOM 0 Marker Ch 40-77", "(DF0) Segment",
      750 	"IOM 1 Marker Ch 40-77", "(DF1) Page", "...", "Directed Fault 2", "...", "Directed Fault 3", "IOM 0 Marker",
      751 	"Access Violation", "IOM 1 Marker", "MME 2", "IOM 2 Marker", "MME 3", "IOM 3 Marker", "MME 4", "...",
      752 	"(FT2) Linkage", "...", "Fault Tag 3", "...", "...", "...", "...", "IOM 0 Special", "...", "IOM 1 Special",
      753 	"...", "IOM 2 Special", "...", "IOM 3 Special", "Trouble");
      754 
      755 dcl  TAG_table (8) char (40) int static options (constant) init (
      756 						/* tag table */
      757 	"     au   qu   du   ic   al   ql   dl   ", "x0   x1   x2   x3   x4   x5   x6   x7   ",
      758 	"n*  aau* aqu* ailtg ic* aal* aql* ailtg ", "0*  a1*  a2*  a3*  a4*  a5*  a6*  a7*  a",
      759 	"fi   itp  iltg its  sd   scr  f2   f3   ", "ci   i    sc   ad   di   dic aid   idc a",
      760 	"*n   *au  *qu  iltg *ic  *al  *ql  iltg ", "*0   *1   *2   *3   *4   *5   *6   *7   ");
      761 
      762 
      763 
      764 	flt_ln, flt_bf = "";
      765 	tsrpr = "0"b;
      766 	flt_bf = flt_int_typ (fixed (scud.wd1.fi, 6));
      767 	if substr (flt_bf, 1, 3) = "..."
      768 	then call ioa_ ("^/Fault/Interrupt (^o), Undefined", fixed (scud.wd1.fi, 6));
      769 	else do;
      770 	     flt_lng = length (flt_int_typ (fixed (scud.wd1.fi, 6)));
      771 	     substr (flt_ln, 1, flt_lng) = substr (flt_bf, 1, flt_lng);
      772 	     byptr = addrel (scup, 1);
      773 	     if fltdtab (35) = "1"b then do;
      774 		substr (flt_ln, flt_lng + 2, 5) = "Fault";
      775 		lnpos = flt_lng + 8;
      776 		do i = 1 to hbound (g1and7flts, 1);	/*  If grp 1 or 7 faults, don't print out tsr|ca */
      777 		     if scud.wd1.fi = g1and7flts (i) then tsrpr = "1"b;
      778 		end;
      779 		end;
      780 	     else do;
      781 		substr (flt_ln, flt_lng + 2, 9) = "Interrupt";
      782 		lnpos = flt_lng + 12;
      783 		tsrpr = "1"b;			/* don't print out tsr|ca for interrupts */
      784 		end;
      785 	     flt_lng = fixed (scud.wd1.fi, 6);
      786 	     call cv_bin_$oct (flt_lng, cvbinbuf);
      787 	     substr (flt_ln, lnpos, 4) = "(" || substr (cvbinbuf, 11, 2) || ")";
      788 	     lnpos = lnpos + 4;
      789 	     j = lnpos;
      790 	     do i = 0 to hbound (grp1flt, 1);
      791 		if fltdtab (i) then do;
      792 		     if substr (flt_ln, 1, 5) = "Store" | substr (flt_ln, 1, 12) = "Illegal Proc"
      793 		     then if i <= 6
      794 			then call ioa_$rsnnl ("^a, ^a", flt_ln, j, flt_ln, grp2flt (i));
      795 			else ;
      796 		     else call ioa_$rsnnl ("^a, ^a", flt_ln, j, flt_ln, grp1flt (i));
      797 		     end;
      798 	     end;
      799 	     call ioa_ ("^a", flt_ln);
      800 	     end;
      801 	if ill_act_lns ^= "0"b then do;		/* display illegal action lines if present */
      802 	     call ioa_ ("Illegal Action Code (^o) - ^a", fixed (scud.wd1.ill_act_lns, 4),
      803 		ill_act (fixed (scud.wd1.ill_act_lns, 4)));
      804 	     end;
      805 	if tsrpr
      806 	then at_by_wd = "At";			/* if not printing tsr */
      807 	else at_by_wd = "By";
      808 	byptr = addrel (baseptr (fixed (scud.wd0.psr, 18)), fixed (scud.wd4.ict, 18));
      809 	if ^tsrpr then refptr = addrel (baseptr (fixed (scud.wd2.tsr, 18)), fixed (scud.wd5.ca, 18));
      810 	call ioa_ ("^a: ^p", at_by_wd, byptr);
      811 	if ^tsrpr
      812 	then					/* if we want to print out tsr|ca */
      813 	     call ioa_ ("Referencing: ^p", refptr);
      814 	call ioa_ ("On: cpu ^a (#^o)", cpul (fixed (scud.wd2.cpu, 3)), fixed (scud.wd2.cpu, 3));
      815 	flt_ln = "";
      816 	byptr = addr (scud.wd4);			/* display Indicator register if any bits present */
      817 	do i = lbound (indrs, 1) to hbound (indrs, 1);
      818 	     if fltdtab (i) then call ioa_$rsnnl ("^a ^a,", flt_ln, j, flt_ln, indrs (i));
      819 	end;
      820 	if flt_ln ^= "" then do;
      821 	     substr (flt_ln, j, 1) = " ";
      822 	     call ioa_ ("Indicators: ^a", flt_ln);
      823 	     flt_ln = "";
      824 	     end;
      825 	byptr = addr (scud.wd0);			/* display interpreted APU status if any bits present */
      826 	do i = lbound (APU, 1) to hbound (APU, 1);
      827 	     if fltdtab (i) then call ioa_$rsnnl ("^a ^a,", flt_ln, j, flt_ln, APU (i));
      828 	end;
      829 	if flt_ln ^= "" then do;
      830 	     substr (flt_ln, j, 1) = " ";
      831 	     call ioa_ ("APU Status: ^a", flt_ln);
      832 	     flt_ln = "";
      833 	     end;
      834 	byptr = addr (scud.wd5);			/* display interprted CU status if any bits present */
      835 	do i = lbound (CU, 1) to hbound (CU, 1);
      836 	     if fltdtab (i) then call ioa_$rsnnl ("^a ^a,", flt_ln, j, flt_ln, CU (i));
      837 	end;
      838 
      839 	TAG_ptr = addr (TAG_table);
      840 	i = fixed (wd5.ct_hold);
      841 
      842 	if i ^= 0 then do;
      843 	     tag_ = TAG.code (i + 1);
      844 	     tag_prt = "1"b;
      845 	     end;
      846 
      847 	if (flt_ln ^= "") | (tag_ ^= "") then do;
      848 	     substr (flt_ln, j, 1) = " ";
      849 	     call ioa_ ("CU Status:  ^a  ^[^/CT Hold: ^a^]", flt_ln, tag_prt, tag_);
      850 	     end;
      851 
      852 	iocbp = iox_$user_output;
      853 	call ioa_ ("Instructions: ");			/* display Instructions (words 6 & 7) */
      854 	call db_print (iocbp, iocbp -> iocb.name, addr (scud.wd6), "i", inst6, 1, null, 0, 0);
      855 
      856 	call db_print (iocbp, iocbp -> iocb.name, addr (scud.wd7), "i", inst6 + 1, 1, null, 0, 0);
      857 	return;
      858 
      859      end interp_scu;
      860 
  1     1 /* Begin include file ..... syserr_message.incl.pl1 */
  1     2 
  1     3 /* Format of a syserr message */
  1     4 
  1     5 /* Created October 1975 by Larry Johnson */
  1     6 
  1     7 dcl  syserr_msgp ptr;				/* Base for include file */
  1     8 
  1     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  1    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  1    11     2 time fixed bin (71) unal,			/* Time message logged at */
  1    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  1    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  1    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  1    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  1    16     2 pad bit (60) unal,				/* RESERVED! */
  1    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  1    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  1    19 
  1    20 
  1    21 /* End include file ..... syserr_message.incl.pl1 */
      861 
      862 
  2     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  2     2 
  2     3 /* This include file has an ALM version, keep 'em in sync. */
  2     4 
  2     5 /* format: off */
  2     6 
  2     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  2     8*   to be examined by display_cpu_error. */
  2     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  2    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  2    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  2    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  2    13*		also changed some codes to "SB_unused_NN" - see line comments */
  2    14 
  2    15 /* In the future, these will be the only constants needed in this include
  2    16*file.  They are the binary data class strings for messages in the new format
  2    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  2    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  2    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  2    20 
  2    21 dcl (						/* include file name */
  2    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  2    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  2    24 SB_mos_data_class		init ("mos"),		/* scr */
  2    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  2    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  2    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  2    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  2    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  2    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  2    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  2    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  2    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  2    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  2    35 ) static internal char (16) varying options (constant);
  2    36 
  2    37 
  2    38 /************************
  2    39*Once the syserr$binary is replaced with something that takes real data classes
  2    40*and all system modules and tools are upgraded to use the new interface, the
  2    41*rest of this include file may be discarded.
  2    42*************************/
  2    43 
  2    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  2    45*   extended at any time. */
  2    46 
  2    47 dcl (
  2    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  2    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  2    50 SB_io_err		init (3),		SBL_io_err	init (5),
  2    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  2    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  2    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  2    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  2    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  2    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  2    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  2    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  2    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  2    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  2    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  2    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  2    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  2    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  2    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  2    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  2    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  2    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  2    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  2    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  2    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  2    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  2    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  2    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  2    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  2    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  2    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  2    78   ) internal static options (constant) fixed bin;
  2    79 
  2    80 
  2    81 /* The following array is a mapping of the old syserr$binary codes into the
  2    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  2    83*the binary data codes stored in the wired syserr log (see above) into the data
  2    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  2    85*is also used by syserr_log_util_ to translate the data classes back into the
  2    86*corresponding binary code (for tools not yet upgraded to deal with the new
  2    87*format log messages). */
  2    88 
  2    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  2    90 	init (	"io_status",		/* 1 */
  2    91 		"hwfault",		/* 2 */
  2    92 		"io_status",		/* 3 */
  2    93 		"unused_4",		/* 4 */
  2    94 		"mos",			/* 5 */
  2    95 
  2    96 		"unused_6",		/* 6 */
  2    97 		"unused_7",		/* 7 */
  2    98 		"unused_8",		/* 8 */
  2    99 		"unused_9",		/* 9 */ 
  2   100 		"unused_10",		/* 10 */
  2   101 
  2   102 		"segdamage",		/* 11 */
  2   103 		"unused_12",		/* 12 */
  2   104 		"segdamage",		/* 13 */
  2   105 		"unused_14",		/* 14 */
  2   106 		"unused_15",		/* 15 */
  2   107 
  2   108 		"segdamage",		/* 16 */
  2   109 		"voldamage",		/* 17 */
  2   110 		"unused_18",		/* 18 */
  2   111 		"mdc_del_uidpath",		/* 19 */
  2   112 		"io_status",		/* 20 */
  2   113 
  2   114 		"mmdam",			/* 21 */
  2   115 		"hwfault",		/* 22 */
  2   116 		"io_status",		/* 23 */
  2   117 		"mpc_poll",		/* 24 */
  2   118 		"fnp_poll",		/* 25 */
  2   119 
  2   120 		"config_deck",		/* 26 */
  2   121 		"vtoce",			/* 27 */
  2   122 		"access_audit",		/* 28 */
  2   123 		"unused_29",		/* 29 */
  2   124 		"unused_30",		/* 30 */
  2   125 		"unused_31",		/* 31 */
  2   126 		"unused_32",		/* 32 */
  2   127 		"unused_33",		/* 33 */
  2   128 		"unused_34",		/* 34 */
  2   129 		"ibm3270_mde",		/* 35 */
  2   130 		"unused_36"		/* 36 */
  2   131 	);
  2   132 
  2   133 
  2   134 /* format: on */
  2   135 
  2   136 /* These constants are used by various tools which analyze syserr messages and
  2   137*still call the old interface "syserr_log_util_". */
  2   138 
  2   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  2   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  2   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  2   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  2   143 
  2   144      dcl	   display_cpu_error_binary_defs (2) init (
  2   145 			      2,			/** SB_hw_fault */
  2   146 			      22			/** SB_verify_lock */
  2   147 			      ) internal static options (constant) fixed bin;
  2   148 
  2   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      863 
      864 
  3     1 
  3     2 /* Begin include file ...... syserr_fault_msg.incl.pl1
  3     3*	Modified 1985-02-21, EJ Sharpe: changed mach_cond to be "like mc"
  3     4*	Modified 8/12/76 by Noel I. Morris	*/
  3     5 
  3     6 
  3     7 /* This include file defines the format of the syserr message
  3     8*   generated on faults handled by various modules.
  3     9*NOTE: program must also include "mc". */
  3    10 
  3    11 dcl  fmsgp ptr;					/* pointer to structure */
  3    12 
  3    13 dcl 1 fault_msg based (fmsgp) aligned,
  3    14     2 mach_cond like mc,				/* machine conditions */
  3    15     2 hist_reg (0:127) bit (36);			/* history registers */
  3    16 		/* someday the hist_reg should be increased to 256 wds to accomodate all DPS8 data */
  3    17 
  3    18 /* End of include file ...... syserr_fault_msg.incl.pl1 */
  3    19 
      865 
      866 
  4     1 /*  */
  4     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  4     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  4     4 /* Modified 07/07/76 by Morris for fault register data */
  4     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  4     6 /* Modified '82 to make values constant */
  4     7 
  4     8 /* words 0-15 pointer registers */
  4     9 
  4    10 dcl  mcp ptr;
  4    11 
  4    12 dcl 1 mc based (mcp) aligned,
  4    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  4    14    (2 regs,					/* registers */
  4    15       3 x (0:7) bit (18),				/* index registers */
  4    16       3 a bit (36),					/* accumulator */
  4    17       3 q bit (36),					/* q-register */
  4    18       3 e bit (8),					/* exponent */
  4    19       3 pad1 bit (28),
  4    20       3 t bit (27),					/* timer register */
  4    21       3 pad2 bit (6),
  4    22       3 ralr bit (3),				/* ring alarm register */
  4    23 
  4    24     2 scu (0:7) bit (36),
  4    25 
  4    26     2 mask bit (72),				/* mem controller mask at time of fault */
  4    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  4    28     2 errcode fixed bin (35),				/* fault handler's error code */
  4    29     2 fim_temp,
  4    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  4    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  4    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  4    33     2 fault_reg bit (36),				/* fault register */
  4    34     2 pad2 bit (1),
  4    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  4    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  4    37     2 fault_time bit (54),				/* time of fault */
  4    38 
  4    39     2 eis_info (0:7) bit (36)) unaligned;
  4    40 
  4    41 
  4    42 dcl (apx fixed bin init (0),
  4    43      abx fixed bin init (1),
  4    44      bpx fixed bin init (2),
  4    45      bbx fixed bin init (3),
  4    46      lpx fixed bin init (4),
  4    47      lbx fixed bin init (5),
  4    48      spx fixed bin init (6),
  4    49      sbx fixed bin init (7)) internal static options (constant);
  4    50 
  4    51 
  4    52 
  4    53 
  4    54 dcl  scup ptr;
  4    55 
  4    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  4    57 
  4    58 
  4    59 /*	WORD (0)		*/
  4    60 
  4    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  4    62       3 prr bit (3),				/* procedure ring register */
  4    63       3 psr bit (15),				/* procedure segment register */
  4    64       3 p bit (1),					/* procedure privileged bit */
  4    65 
  4    66     2 apu,					/* APPENDING UNIT STATUS */
  4    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  4    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  4    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  4    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  4    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  4    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  4    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  4    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  4    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  4    76       3 ptw bit (1),				/* Fetch of PTW */
  4    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  4    78       3 fap bit (1),				/* Fetch of final address paged */
  4    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  4    80       3 fabs bit (1),				/* Fetch of final address absolute */
  4    81 
  4    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  4    83 
  4    84 
  4    85 /*	WORD (1)		*/
  4    86 
  4    87     2 fd,						/* FAULT  DATA */
  4    88       3 iro bit (1),				/* illegal ring order */
  4    89       3 oeb bit (1),				/* out of execute bracket */
  4    90       3 e_off bit (1),				/* no execute */
  4    91       3 orb bit (1),				/* out of read bracket */
  4    92       3 r_off bit (1),				/* no read */
  4    93       3 owb bit (1),				/* out of write bracket */
  4    94       3 w_off bit (1),				/* no write */
  4    95       3 no_ga bit (1),				/* not a gate */
  4    96       3 ocb bit (1),				/* out of call bracket */
  4    97       3 ocall bit (1),				/* outward call */
  4    98       3 boc bit (1),				/* bad outward call */
  4    99       3 inret bit (1),				/* inward return */
  4   100       3 crt bit (1),				/* cross ring transfer */
  4   101       3 ralr bit (1),				/* ring alarm register */
  4   102       3 am_er bit (1),				/* associative memory fault */
  4   103       3 oosb bit (1),				/* out of segment bounds */
  4   104       3 paru bit (1),				/* processor parity upper */
  4   105       3 parl bit (1),				/* processor parity lower */
  4   106       3 onc_1 bit (1),				/* op not complete type 1 */
  4   107       3 onc_2 bit (1),				/* op not complete type 2 */
  4   108 
  4   109     2 port_stat,					/* PORT  STATUS */
  4   110       3 ial bit (4),				/* illegal action lines */
  4   111       3 iac bit (3),				/* illegal action channel */
  4   112       3 con_chan bit (3),				/* connect channel */
  4   113 
  4   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  4   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  4   116 
  4   117 
  4   118 /*	WORD (2)		*/
  4   119 
  4   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  4   121       3 trr bit (3),				/* temporary ring register */
  4   122       3 tsr bit (15),				/* temporary segment register */
  4   123 
  4   124     2 pad2 bit (9),
  4   125 
  4   126     2 cpu_no bit (3),				/* CPU number */
  4   127 
  4   128     2 delta bit (6),				/* tally modification DELTA */
  4   129 
  4   130 
  4   131 /*	WORD (3)		*/
  4   132 
  4   133     2 word3 bit (18),
  4   134 
  4   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  4   136       3 tsna,					/* Word 1 status */
  4   137         4 prn bit (3),				/* Word 1  PR  number */
  4   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  4   139       3 tsnb,					/* Word 2  status */
  4   140         4 prn bit (3),				/* Word 2  PR  number */
  4   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  4   142       3 tsnc,					/* Word 3  status */
  4   143         4 prn bit (3),				/* Word 3  PR  number */
  4   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  4   145 
  4   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  4   147 
  4   148 
  4   149 /* 	WORD (4)		*/
  4   150 
  4   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  4   152 
  4   153     2 ir,						/* INDICATOR  REGISTERS */
  4   154       3 zero bit (1),				/* zero indicator */
  4   155       3 neg bit (1),				/* negative indicator */
  4   156       3 carry bit (1),				/* carryry indicator */
  4   157       3 ovfl bit (1),				/* overflow indicator */
  4   158       3 eovf bit (1),				/* eponent overflow */
  4   159       3 eufl bit (1),				/* exponent underflow */
  4   160       3 oflm bit (1),				/* overflow mask */
  4   161       3 tro bit (1),				/* tally runout */
  4   162       3 par bit (1),				/* parity error */
  4   163       3 parm bit (1),				/* parity mask */
  4   164       3 bm bit (1),					/* ^bar mode */
  4   165       3 tru bit (1),				/* truncation mode */
  4   166       3 mif bit (1),				/* multi-word instruction mode */
  4   167       3 abs bit (1),				/* absolute mode */
  4   168       3 hex bit (1),				/* hexadecimal exponent mode */
  4   169       3 pad bit (3),
  4   170 
  4   171 
  4   172 /*	WORD (5)		*/
  4   173 
  4   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  4   175 
  4   176     2 cu,						/* CONTROL UNIT STATUS */
  4   177       3 rf bit (1),					/* on first cycle of repeat instr */
  4   178       3 rpt bit (1),				/* repeat instruction */
  4   179       3 rd bit (1),					/* repeat double instruction */
  4   180       3 rl bit (1),					/* repeat link instruciton */
  4   181       3 pot bit (1),				/* IT  modification */
  4   182       3 pon bit (1),				/* return type instruction */
  4   183       3 xde bit (1),				/* XDE from Even location */
  4   184       3 xdo bit (1),				/* XDE from Odd  location */
  4   185       3 poa bit (1),				/* operation preparation */
  4   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  4   187       3 its bit (1),				/* ITS modification */
  4   188       3 if bit (1),					/* fault occured during instruction fetch */
  4   189 
  4   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  4   191 
  4   192 
  4   193 /*	WORDS (6,7)	*/
  4   194 
  4   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  4   196 
  4   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  4   198 
  4   199 
  4   200 
  4   201 
  4   202 
  4   203 
  4   204 /*	ALTERNATE   SCU  DECLARATION		*/
  4   205 
  4   206 
  4   207 dcl 1 scux based (scup) aligned,
  4   208 
  4   209    (2 pad0 bit (36),
  4   210 
  4   211     2 fd,						/* GROUP II  FAULT DATA */
  4   212       3 isn bit (1),				/* illegal segment number */
  4   213       3 ioc bit (1),				/* illegal op  code  */
  4   214       3 ia_am bit (1),				/* illegal address - modifier */
  4   215       3 isp bit (1),				/* illegal slave  procedure */
  4   216       3 ipr bit (1),				/* illegal procedure */
  4   217       3 nea bit (1),				/* non existent address */
  4   218       3 oobb bit (1),				/* out of bounds */
  4   219       3 pad bit (29),
  4   220 
  4   221     2 pad2 bit (36),
  4   222 
  4   223     2 pad3a bit (18),
  4   224 
  4   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  4   226       3 prn bit (3),				/* PR  number */
  4   227       3 prv bit (1),				/* PR  valid bit */
  4   228 
  4   229     2 pad3b bit (6)) unaligned,
  4   230 
  4   231     2 pad45 (0:1) bit (36),
  4   232 
  4   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  4   234 
  4   235 
  4   236 
  4   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      867 
      868 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      869 
      870 
      871 
      872      end display_cpu_error;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/13/85  1018.4  display_cpu_error.pl1             >spec>on>41-11>display_cpu_error.pl1
861          1    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
863          2    03/12/85  1556.6  syserr_binary_def.incl.pl1        >spec>on>41-11>syserr_binary_def.incl.pl1
865          3    03/12/85  1556.6  syserr_fault_msg.incl.pl1         >spec>on>41-11>syserr_fault_msg.incl.pl1
867          4    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
869          5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APU                             001346 constant        varying char(6)          initial array dcl 724 set ref 826 826 827*
CPU_TAGS                        002771 constant        char(16)                 initial unaligned dcl 32 ref 286
CU                              001316 constant        varying char(3)          initial array dcl 728 set ref 835 835 836*
EXT_FAULT_TYPES                 001742 constant        varying char(39)         initial array dcl 636 ref 646
FAULT_TYPES                     002473 constant        varying char(15)         initial array dcl 577 ref 598 615
IA                        0(16)        based           bit(4)                   array level 2 packed unaligned dcl 566 ref 605 607
PRS                             000516 automatic       pointer                  array dcl 433 set ref 470* 471*
SB_hw_fault                            constant        fixed bin(17,0)          initial dcl 2-47 ref 230
SC_IA_TYPES                     002207 constant        varying char(42)         initial array dcl 583 ref 607
TAG                                    based           structure                array level 1 packed unaligned dcl 674
TAG_ptr                         000754 automatic       pointer                  dcl 673 set ref 839* 843
TAG_table                       000000 constant        char(40)                 initial array unaligned dcl 755 set ref 839
a                        24            based           bit(36)                  level 4 packed unaligned dcl 3-13 set ref 475*
addr                                                   builtin function         dcl 137 ref 190 221 221 224 224 306 306 312 312 443
                                                                                  444 445 605 607 816 825 834 839 854 854 856 856
addrel                                                 builtin function         dcl 137 ref 772 808 809
area_ptr                        000144 automatic       pointer                  initial dcl 64 set ref 64* 391 391* 393
arg                                    based           char                     unaligned dcl 34 set ref 259 259 263 267 273 273 277
                                                                                  278 279 286 287* 293* 298 303 303 305 311 311 318*
                                                                                  363 369* 371* 388 400 403
arg_copy                        000464 automatic       varying char(10)         dcl 359 in procedure "time_arg" set ref 363* 365*
                                                                                  371*
arg_copy                        000100 automatic       varying char(15)         dcl 35 in procedure "display_cpu_error" set ref 248*
                                                                                  388*
arg_count                       000105 automatic       fixed bin(17,0)          dcl 36 set ref 153* 154 343 349
arg_len                         000106 automatic       fixed bin(17,0)          dcl 37 set ref 259 259 263 267 270 273 273 277 278
                                                                                  279 286 287 287 292 293 293 297 298 303 303 305
                                                                                  311 311 318 318 337* 363 369 369 371 371 388 393
                                                                                  393 393 400 403
arg_list_ptr                    000110 automatic       pointer                  dcl 38 set ref 152* 337*
arg_no                          000112 automatic       fixed bin(17,0)          initial dcl 39 set ref 39* 337* 339* 342* 342 343
                                                                                  348* 348 349
arg_ptr                         000114 automatic       pointer                  dcl 40 set ref 259 259 263 267 271 273 273 277 278
                                                                                  279 286 287 293 298 303 303 305 311 311 318 337*
                                                                                  363 369 371 388 400 403
argc                            000116 automatic       fixed bin(17,0)          dcl 41 set ref 297* 298 298*
at_by_wd                        000706 automatic       char(2)                  unaligned dcl 665 set ref 805* 807* 810*
baseptr                                                builtin function         dcl 137 ref 808 809
bin                                                    builtin function         dcl 137 ref 607
break                           000621 automatic       fixed bin(17,0)          dcl 565 set ref 603* 604 609*
buffer                   10            based           bit(36)                  array level 2 dcl 83 set ref 190 197 197
byptr                           000766 automatic       pointer                  dcl 682 set ref 772* 773 791 808* 810* 816* 818 825*
                                                                                  827 834* 836
ca                        5            based           bit(18)                  level 3 packed unaligned dcl 685 set ref 809
cleanup                         000424 stack reference condition                dcl 135 ref 142
code                                   based           char(4)                  array level 2 in structure "TAG" packed unaligned
                                                                                  dcl 674 in procedure "interp_scu" ref 843
code                            000120 automatic       fixed bin(35,0)          dcl 44 in procedure "display_cpu_error" set ref 144*
                                                                                  145 146* 157* 158 160* 161 165* 166 167* 173* 174
                                                                                  175* 181* 182 183* 197* 199 200 201* 337* 338 339*
                                                                                  369* 370 371* 521* 523 524* 531* 533 549* 553*
com_err_                        000010 constant        entry                    external dcl 109 ref 146 167 175 183 201 240 248 281
                                                                                  287 293 318 324 339 365 371 524
convert_date_to_binary_         000012 constant        entry                    external dcl 110 ref 369
convert_date_to_binary_$relative
                                000014 constant        entry                    external dcl 111 ref 181
convert_status_code_            000016 constant        entry                    external dcl 112 ref 481
count                     4     000416 automatic       fixed bin(17,0)          initial level 2 in structure "exclude_data" dcl 95
                                                                                  in procedure "display_cpu_error" set ref 95*
count                     4            based           fixed bin(17,0)          initial level 2 in structure "sdata" dcl 385
                                                                                  in procedure "string_check" set ref 395 399* 399
count                     4     000410 automatic       fixed bin(17,0)          initial level 2 in structure "match_data" dcl 94
                                                                                  in procedure "display_cpu_error" set ref 94*
count                     4            based           fixed bin(17,0)          initial level 2 in structure "mdata" dcl 415
                                                                                  in procedure "match_string" ref 417
cpu                       2(27)        based           bit(3)                   level 3 in structure "scud" packed unaligned dcl 685
                                                                                  in procedure "interp_scu" ref 814 814 814
cpu                             000536 automatic       char(1)                  unaligned dcl 434 in procedure "print_it" set ref
                                                                                  450* 452 458* 461
cpu_cnt                         000121 automatic       fixed bin(17,0)          initial dcl 45 set ref 45* 299* 299 448 451 459 459
                                                                                  464
cpu_no                    2(27)        based           bit(3)                   level 2 packed unaligned dcl 4-56 ref 449
cpu_tag                         000540 automatic       char(1)                  initial array unaligned dcl 435 set ref 435* 435*
                                                                                  435* 435* 435* 435* 435* 435* 450 458
cpu_type                 46(01)        based           fixed bin(2,0)           level 3 packed unsigned unaligned dcl 3-13 ref 488
cpul                            001740 constant        char(1)                  initial array unaligned dcl 666 set ref 814*
cpureq                                 based           char(1)                  array level 2 dcl 83 set ref 298* 452 461
ct_hold                   5(30)        based           bit(6)                   level 3 packed unaligned dcl 685 set ref 840
ctext                           000206 automatic       char(512)                unaligned dcl 87 set ref 220* 420
ctextl                          000406 automatic       fixed bin(17,0)          dcl 88 set ref 219* 220 420
cu_$arg_count                   000022 constant        entry                    external dcl 114 ref 153
cu_$arg_list_ptr                000020 constant        entry                    external dcl 113 ref 152
cu_$arg_ptr_rel                 000024 constant        entry                    external dcl 115 ref 337
cv_bin_$oct                     000026 constant        entry                    external dcl 116 ref 786
cvbinbuf                        000707 automatic       char(12)                 unaligned dcl 667 set ref 786* 787
data                                   based           bit(36)                  array level 2 in structure "syserr_msg" dcl 1-9
                                                                                  in procedure "display_cpu_error" set ref 443
data                      3            based           char                     level 2 in structure "str" dcl 97 in procedure
                                                                                  "display_cpu_error" set ref 400* 420
data_code                 4            based           fixed bin(11,0)          level 2 packed unaligned dcl 1-9 ref 213 230
data_size                 3(24)        based           fixed bin(11,0)          level 2 packed unaligned dcl 1-9 ref 217 230
date_time_$format               000030 constant        entry                    external dcl 117 ref 467 485 514 517 529
db_print                        000032 constant        entry                    external dcl 118 ref 854 856
def_idx                         000117 automatic       fixed bin(17,0)          dcl 42 set ref 212* 213*
display_cpu_error_binary_defs   002762 constant        fixed bin(17,0)          initial array dcl 2-144 ref 212 212 213
e                        26            based           bit(8)                   level 4 packed unaligned dcl 3-13 ref 475
eis_info                 50            based           bit(36)                  array level 3 packed unaligned dcl 3-13 set ref 490*
errcode                  43            based           fixed bin(35,0)          level 3 packed unaligned dcl 3-13 ref 480 481
error_msg                       000542 automatic       char(100)                dcl 436 set ref 481* 482 482
error_table_$badopt             000036 external static fixed bin(35,0)          dcl 120 set ref 318*
error_table_$end_of_info        000034 external static fixed bin(35,0)          dcl 119 ref 200
exclude_data                    000416 automatic       structure                level 1 unaligned dcl 95 set ref 224 224 312 312
exclude_sw                      000140 automatic       bit(1)                   initial unaligned dcl 59 set ref 59* 224 313*
expand_sw                       000122 automatic       bit(1)                   initial unaligned dcl 47 set ref 47* 275* 497
ext_fault_reg                          parameter       bit(15)                  unaligned dcl 633 in procedure "interpret_fault_reg"
                                                                                  set ref 630 646 651*
ext_fault_reg            46(03)        based           bit(15)                  level 3 in structure "fault_msg" packed unaligned
                                                                                  dcl 3-13 in procedure "display_cpu_error" ref 488
                                                                                  488
fault_msg                              based           structure                level 1 dcl 3-13
fault_no                        000620 automatic       fixed bin(17,0)          dcl 565 set ref 596* 597 598* 604* 605 606 607* 613*
                                                                                  614 615*
fault_reg                45            based           bit(36)                  level 3 in structure "fault_msg" packed unaligned
                                                                                  dcl 3-13 in procedure "display_cpu_error" ref 487
fault_reg                              parameter       bit(36)                  unaligned dcl 564 in procedure "interpret_fault_reg"
                                                                                  set ref 561 591 597 605 607 614 625*
fault_time               46(18)        based           bit(54)                  level 3 packed unaligned dcl 3-13 set ref 485 485
                                                                                  485*
fi                        1(30)        based           bit(6)                   level 3 packed unaligned dcl 685 ref 766 767 767 770
                                                                                  777 785
first                                  based           pointer                  level 2 in structure "sdata" dcl 385 in procedure
                                                                                  "string_check" set ref 395*
first                                  based           pointer                  level 2 in structure "mdata" dcl 415 in procedure
                                                                                  "match_string" ref 418
fixed                                                  builtin function         dcl 137 ref 449 485 485 766 767 767 770 785 802 802
                                                                                  802 808 808 809 809 814 814 814 840
flt_bf                          000712 automatic       varying char(24)         dcl 668 set ref 764* 766* 767 771
flt_int_typ                     000120 constant        varying char(24)         initial array dcl 744 ref 766 770
flt_ln                          000721 automatic       char(100)                unaligned dcl 669 set ref 764* 771* 774* 781* 787*
                                                                                  792 792 792* 792* 796* 796* 799* 815* 818* 818*
                                                                                  820 821* 822* 823* 827* 827* 829 830* 831* 832*
                                                                                  836* 836* 847 848* 849*
flt_lng                         000761 automatic       fixed bin(17,0)          dcl 681 set ref 770* 771 771 774 775 781 782 785*
                                                                                  786*
fltdtab                                based           bit(1)                   array unaligned dcl 670 ref 773 791 818 827 836
fmsgp                           000434 automatic       pointer                  dcl 3-11 set ref 443* 444 445 470 472 475 475 475
                                                                                  475 475 477 477 477 477 477 480 481 485 485 485
                                                                                  487 488 488 488 490 492
for_arg                                based           char                     unaligned dcl 49 set ref 181* 183*
for_len                         000123 automatic       fixed bin(17,0)          dcl 50 set ref 181 181 183 183 270*
for_ptr                         000124 automatic       pointer                  dcl 51 set ref 181 183 271*
for_sw                          000126 automatic       bit(1)                   initial unaligned dcl 52 set ref 52* 180 268* 323
for_time                        000130 automatic       fixed bin(71,0)          dcl 53 set ref 269*
found                           000573 automatic       bit(1)                   unaligned dcl 437 set ref 442* 451 452* 454 459 461*
                                                                                  464
free_area                              based           area(1024)               dcl 65 ref 393
from_sw                         000132 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 164 260*
from_time                       000134 automatic       fixed bin(71,0)          dcl 55 set ref 170* 173* 181* 188 261* 514* 531*
g1and7flts                      001315 constant        bit(6)                   initial array unaligned dcl 731 ref 776 777
get_system_free_area_           000060 constant        entry                    external dcl 129 ref 391
get_temp_segments_              000040 constant        entry                    external dcl 121 ref 144
grp1flt                         001101 constant        varying char(24)         initial array dcl 733 set ref 790 796*
grp2flt                         001020 constant        varying char(24)         initial array dcl 740 set ref 792*
hbound                                                 builtin function         dcl 137 ref 197 197 212 776 790 817 826 835
hist_reg                 60            based           bit(36)                  array level 2 dcl 3-13 set ref 445
hr_ptr                          000574 automatic       pointer                  dcl 438 set ref 445* 499* 501*
hr_switches                     000141 automatic       bit(5)                   unaligned dcl 61 set ref 497* 501*
hran_$hranl                     000042 constant        entry                    external dcl 122 ref 499
hran_$no_thread                 000044 constant        entry                    external dcl 123 ref 501
i                               000577 automatic       fixed bin(17,0)          dcl 440 in procedure "print_it" set ref 446* 447
                                                                                  449* 450 457
i                               000763 automatic       fixed bin(17,0)          dcl 681 in procedure "interp_scu" set ref 776* 777*
                                                                                  790* 791 792 792 796* 817* 818 818* 826* 827 827*
                                                                                  835* 836 836* 840* 842 843
ict                       4            based           bit(18)                  level 3 packed unaligned dcl 685 set ref 808
ill_act                         001457 constant        varying char(37)         initial array dcl 715 set ref 802*
ill_act_lns               1(20)        based           bit(4)                   level 3 packed unaligned dcl 685 ref 801 802 802 802
illeg_acts                             based           structure                level 1 packed unaligned dcl 566
index                                                  builtin function         dcl 137 ref 420 446 458
indrs                           001423 constant        varying char(4)          initial array dcl 721 set ref 817 817 818*
indx                            000676 automatic       fixed bin(17,0)          dcl 634 set ref 645* 646 646*
inst6                           000762 automatic       fixed bin(17,0)          dcl 681 set ref 854* 856
ioa_                            000046 constant        entry                    external dcl 124 ref 467 471 472 475 477 482 485 490
                                                                                  492 498 536 625 651 767 799 802 810 811 814 822
                                                                                  831 849 853
ioa_$rsnnl                      000050 constant        entry                    external dcl 125 ref 792 796 818 827 836
iocb                                   based           structure                level 1 dcl 5-6
iocbp                           000752 automatic       pointer                  dcl 671 set ref 852* 854* 854 856* 856
iox_$user_output                000052 external static pointer                  dcl 126 ref 852
ir                        4(18)        based           structure                level 2 packed unaligned dcl 4-56
j                               000764 automatic       fixed bin(17,0)          dcl 681 in procedure "interp_scu" set ref 789* 792*
                                                                                  796* 818* 821 827* 830 836* 848
j                               000600 automatic       fixed bin(17,0)          dcl 440 in procedure "print_it" set ref 451* 452*
                                                                                  459* 461*
last                      2            based           pointer                  level 2 dcl 385 set ref 397 398*
lbound                                                 builtin function         dcl 137 ref 212 817 826 835
len                       2            based           fixed bin(17,0)          initial level 2 dcl 97 set ref 393* 393* 400 420
length                                                 builtin function         dcl 137 ref 620 623 650 770
line1                           000622 automatic       varying char(80)         dcl 574 set ref 594* 598* 598 615* 615 620* 620 620
                                                                                  625* 644* 646* 646 649 650* 650 650 651*
line1_sw                        000674 automatic       bit(1)                   initial unaligned dcl 575 set ref 575* 599* 616* 620
                                                                                  625*
line2                           000647 automatic       varying char(80)         dcl 574 set ref 594* 606* 607* 607 623* 623 623 625*
line2_sw                        000675 automatic       bit(1)                   initial unaligned dcl 575 set ref 575* 608* 623 625*
link                            000476 automatic       pointer                  dcl 386 set ref 393* 395 397 398 400
lnpos                           000760 automatic       fixed bin(17,0)          dcl 681 set ref 775* 782* 787 788* 788 789
mach_cond                              based           structure                level 2 dcl 3-13
mask                            000142 automatic       bit(36)                  initial dcl 62 in procedure "display_cpu_error" set
                                                                                  ref 62*
mask                     40            based           bit(72)                  level 3 in structure "fault_msg" packed unaligned
                                                                                  dcl 3-13 in procedure "display_cpu_error" ref 477
                                                                                  477 477 477 477
match_data                      000410 automatic       structure                level 1 unaligned dcl 94 set ref 221 221 306 306
match_sw                        000137 automatic       bit(1)                   initial unaligned dcl 58 set ref 58* 221 307*
mc                                     based           structure                level 1 dcl 4-12
mdata                                  based           structure                level 1 unaligned dcl 415
mif                       4(30)        based           bit(1)                   level 3 packed unaligned dcl 4-56 ref 490
more_args                       000143 automatic       bit(1)                   unaligned dcl 63 set ref 154* 257 280 343* 349* 364
                                                                                  389 401
msg_seq                         000146 automatic       fixed bin(35,0)          dcl 66 set ref 165* 173* 521* 531*
msg_time                        000150 automatic       fixed bin(71,0)          dcl 67 set ref 165* 170 173* 521* 529* 531*
name                            002764 constant        char(17)                 initial unaligned dcl 104 in procedure
                                                                                  "display_cpu_error" set ref 144* 146* 160* 167*
                                                                                  175* 183* 201* 240* 248* 281* 287* 293* 318* 324*
                                                                                  339* 365* 371* 524* 553*
name                      1            based           char(32)                 level 2 in structure "iocb" dcl 5-6 in procedure
                                                                                  "display_cpu_error" set ref 854* 856*
next                                   based           pointer                  initial level 2 dcl 97 set ref 393* 397* 421
null                                                   builtin function         dcl 137 ref 64 391 393 419 499 499 501 501 854 854
                                                                                  856 856
only_scu                        000152 automatic       bit(1)                   initial unaligned dcl 69 set ref 69* 278* 495
open_status                     000153 automatic       bit(36)                  dcl 70 set ref 157* 158 160*
p                                      parameter       pointer                  dcl 414 in procedure "match_string" ref 411 417 418
p                                      parameter       pointer                  dcl 384 in procedure "string_check" ref 381 395 395
                                                                                  397 398 399 399
plural_sw                       000154 automatic       bit(1)                   unaligned dcl 71 set ref 239* 240*
port_name                       002757 constant        char(3)                  initial array unaligned dcl 572 ref 606
print_cnt                       000160 automatic       fixed bin(17,0)          initial dcl 73 set ref 73* 237 494* 494 537*
print_syserr_msg_$open_err      000054 constant        entry                    external dcl 127 ref 160
prs                                    based           pointer                  array level 3 dcl 3-13 ref 470
psr                       0(03)        based           bit(15)                  level 3 packed unaligned dcl 685 set ref 808
ptr_array                       000156 automatic       pointer                  array dcl 72 set ref 144* 150 553*
q                        25            based           bit(36)                  level 4 in structure "fault_msg" packed unaligned
                                                                                  dcl 3-13 in procedure "display_cpu_error" set ref
                                                                                  475*
q                               000506 automatic       pointer                  dcl 414 in procedure "match_string" set ref 418* 419
                                                                                  420 421* 421
ralr                     27(33)        based           bit(3)                   level 4 packed unaligned dcl 3-13 set ref 475*
read_cnt                        000161 automatic       fixed bin(17,0)          initial dcl 73 set ref 73* 196* 205* 205 239 240*
refptr                          000770 automatic       pointer                  dcl 682 set ref 809* 811*
regs                     20            based           structure                level 3 packed unaligned dcl 3-13
release_temp_segments_          000056 constant        entry                    external dcl 128 ref 553
rtrim                                                  builtin function         dcl 137 ref 482 482
scan_text                       000136 automatic       bit(1)                   initial unaligned dcl 57 set ref 57* 211 303* 308*
                                                                                  314*
scu                                    based           structure                level 1 dcl 4-56 in procedure "display_cpu_error"
scu                      30            based           bit(36)                  array level 3 in structure "fault_msg" packed
                                                                                  unaligned dcl 3-13 in procedure
                                                                                  "display_cpu_error" set ref 444 492*
scud                                   based           structure                level 1 dcl 685
scup                            000436 automatic       pointer                  dcl 4-54 in procedure "display_cpu_error" set ref
                                                                                  444* 449 490 493*
scup                                   parameter       pointer                  dcl 672 in procedure "interp_scu" ref 662 766 767
                                                                                  767 770 772 777 785 801 802 802 802 808 808 809
                                                                                  809 814 814 814 816 825 834 840 854 854 856 856
sdata                                  based           structure                level 1 unaligned dcl 385
segs_allocated                  000162 automatic       bit(1)                   initial unaligned dcl 75 set ref 75* 149* 551 552*
seq_num                                based           fixed bin(35,0)          level 2 dcl 1-9 set ref 467*
str                                    based           structure                level 1 dcl 97 set ref 393
string_data                            based           structure                level 1 unaligned dcl 89
substr                                                 builtin function         dcl 137 set ref 158 220* 298 403 420 457 477 477 477
                                                                                  477 597 614 620 623 646 650 767 771* 771 774* 781*
                                                                                  787* 787 792 792 821* 830* 848*
syserr_log_util_$close          000066 constant        entry                    external dcl 132 ref 549
syserr_log_util_$open           000062 constant        entry                    external dcl 130 ref 157
syserr_log_util_$read           000064 constant        entry                    external dcl 131 ref 197
syserr_log_util_$search         000070 constant        entry                    external dcl 133 ref 165 173 521 531
syserr_msg                             based           structure                level 1 dcl 1-9
syserr_msgp                     000432 automatic       pointer                  dcl 1-7 set ref 190* 197* 207 209 213 217 219 220
                                                                                  230 230 443 446 457 467 467 467
t                                      parameter       fixed bin(71,0)          dcl 360 in procedure "time_arg" set ref 356 369*
t                        27            based           bit(27)                  level 4 in structure "fault_msg" packed unaligned
                                                                                  dcl 3-13 in procedure "display_cpu_error" set ref
                                                                                  475*
tab_cnt                         000163 automatic       fixed bin(17,0)          initial dcl 76 set ref 76*
tag_                            000757 automatic       char(4)                  initial unaligned dcl 680 set ref 680* 843* 847 849*
tag_prt                         000756 automatic       bit(1)                   initial unaligned dcl 679 set ref 679* 844* 849*
tcpu                            000576 automatic       char(1)                  unaligned dcl 439 set ref 457* 458
text                      6            based           char                     level 2 dcl 1-9 set ref 220 446 457 467*
text_len                  3(12)        based           fixed bin(11,0)          level 2 packed unaligned dcl 1-9 ref 219 220 443 446
                                                                                  457 467 467
thread_sw                       000164 automatic       bit(1)                   initial unaligned dcl 77 set ref 77* 274* 277* 499
time                      1            based           fixed bin(71,0)          level 2 packed unaligned dcl 1-9 ref 207 209 467
tm1                             000165 automatic       char(24)                 unaligned dcl 78 set ref 514* 536*
tm2                             000173 automatic       char(24)                 unaligned dcl 78 set ref 517* 529* 536*
to_sw                           000201 automatic       bit(1)                   initial unaligned dcl 79 set ref 79* 186* 188 206
                                                                                  264* 323 517
to_time                         000202 automatic       fixed bin(71,0)          dcl 80 set ref 181* 188* 207 209* 265* 517*
tsr                       2(03)        based           bit(15)                  level 3 packed unaligned dcl 685 ref 809
tsrpr                           000772 automatic       bit(1)                   unaligned dcl 683 set ref 765* 777* 783* 805 809 811
unspec                                                 builtin function         dcl 137 set ref 470* 470
verify                                                 builtin function         dcl 137 ref 286
wd0                                    based           structure                level 2 packed unaligned dcl 685 set ref 825
wd1                       1            based           structure                level 2 packed unaligned dcl 685
wd2                       2            based           structure                level 2 packed unaligned dcl 685
wd4                       4            based           structure                level 2 packed unaligned dcl 685 set ref 816
wd5                       5            based           structure                level 2 packed unaligned dcl 685 set ref 834
wd6                       6            based           fixed bin(35,0)          level 2 dcl 685 set ref 854 854
wd7                       7            based           fixed bin(35,0)          level 2 dcl 685 set ref 856 856
work                                   based           structure                level 1 dcl 83
workp                           000204 automatic       pointer                  dcl 82 set ref 150* 190 197 197 298 452 461
x                        20            based           bit(18)                  array level 4 packed unaligned dcl 3-13 set ref 472*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 2-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 2-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 2-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 2-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 2-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 2-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 2-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 2-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 2-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 2-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 2-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 2-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 2-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 2-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 2-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 2-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 2-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 2-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 2-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 2-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 2-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 2-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 2-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 2-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 2-21
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 2-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 2-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 2-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 2-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 2-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 2-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 2-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 2-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 2-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 2-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 2-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 2-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 2-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 2-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 2-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 2-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 2-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 2-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 2-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 2-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 2-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 2-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 2-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 2-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 2-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 2-47
abx                                    internal static fixed bin(17,0)          initial dcl 4-42
apx                                    internal static fixed bin(17,0)          initial dcl 4-42
bbx                                    internal static fixed bin(17,0)          initial dcl 4-42
bpx                                    internal static fixed bin(17,0)          initial dcl 4-42
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51
lbx                                    internal static fixed bin(17,0)          initial dcl 4-42
lpx                                    internal static fixed bin(17,0)          initial dcl 4-42
mcp                                    automatic       pointer                  dcl 4-10
sbx                                    internal static fixed bin(17,0)          initial dcl 4-42
scux                                   based           structure                level 1 dcl 4-207
spx                                    internal static fixed bin(17,0)          initial dcl 4-42
syserr_binary_address_damage_mask      internal static bit(36)                  initial unaligned dcl 2-142
syserr_binary_mos_mask                 internal static bit(36)                  initial unaligned dcl 2-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial unaligned dcl 2-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial unaligned dcl 2-141

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        007124 constant        entry                    internal dcl 546 ref 142 245
continue_check                  004414 constant        label                    dcl 217 ref 213
display_cpu_error               003643 constant        entry                    external dcl 27
done                            004466 constant        label                    dcl 237 ref 147 161 168 176 184 200 202 207 250 283
                                                                                  319 325 340 366 372
get_arg                         005222 constant        entry                    internal dcl 334 ref 258 285 368 390 402
interp_scu                      007666 constant        entry                    internal dcl 662 ref 493
interpret_ext_fault_reg         007543 constant        entry                    internal dcl 630 ref 488
interpret_fault_reg             007173 constant        entry                    internal dcl 561 ref 487
log_err                         006772 constant        label                    dcl 524 ref 533
loop                            004304 constant        label                    dcl 197 ref 215 217 221 224 228 231
match_string                    005557 constant        entry                    internal dcl 411 ref 221 224
miss_err                        004536 constant        label                    dcl 248 ref 389
new_cpu                         004744 constant        label                    dcl 287
no_cpu                          004701 constant        label                    dcl 281
p_data                          006032 constant        label                    dcl 467 ref 448 455
print_header                    006645 constant        entry                    internal dcl 510 ref 193
print_it                        005620 constant        entry                    internal dcl 430 ref 227 230
put_arg                         005302 constant        entry                    internal dcl 346 ref 404
scan_args                       004570 constant        entry                    internal dcl 254 ref 155
scheck                          005502 constant        label                    dcl 393 ref 403
string_check                    005451 constant        entry                    internal dcl 381 ref 306 312
time_arg                        005312 constant        entry                    internal dcl 356 ref 261 265 269

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12016       12110   11472       12026
Length     12472   11472        72         345     324           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
display_cpu_error                  1064 external procedure  is an external procedure.  
on unit on line 142                  64 on unit               
scan_args                               internal procedure  shares stack frame of external procedure display_cpu_error.  
get_arg                                 internal procedure  shares stack frame of external procedure display_cpu_error.  
time_arg                                internal procedure  shares stack frame of external procedure display_cpu_error.  
string_check                            internal procedure  shares stack frame of external procedure display_cpu_error.  
match_string                            internal procedure  shares stack frame of external procedure display_cpu_error.  
print_it                                internal procedure  shares stack frame of external procedure display_cpu_error.  
print_header                            internal procedure  shares stack frame of external procedure display_cpu_error.  
clean_up                             82 internal procedure  is called by several nonquick procedures.  
interpret_fault_reg                     internal procedure  shares stack frame of external procedure display_cpu_error.  
interp_scu                              internal procedure  shares stack frame of external procedure display_cpu_error.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
display_cpu_error        000100 arg_copy                    display_cpu_error
                         000105 arg_count                   display_cpu_error
                         000106 arg_len                     display_cpu_error
                         000110 arg_list_ptr                display_cpu_error
                         000112 arg_no                      display_cpu_error
                         000114 arg_ptr                     display_cpu_error
                         000116 argc                        display_cpu_error
                         000117 def_idx                     display_cpu_error
                         000120 code                        display_cpu_error
                         000121 cpu_cnt                     display_cpu_error
                         000122 expand_sw                   display_cpu_error
                         000123 for_len                     display_cpu_error
                         000124 for_ptr                     display_cpu_error
                         000126 for_sw                      display_cpu_error
                         000130 for_time                    display_cpu_error
                         000132 from_sw                     display_cpu_error
                         000134 from_time                   display_cpu_error
                         000136 scan_text                   display_cpu_error
                         000137 match_sw                    display_cpu_error
                         000140 exclude_sw                  display_cpu_error
                         000141 hr_switches                 display_cpu_error
                         000142 mask                        display_cpu_error
                         000143 more_args                   display_cpu_error
                         000144 area_ptr                    display_cpu_error
                         000146 msg_seq                     display_cpu_error
                         000150 msg_time                    display_cpu_error
                         000152 only_scu                    display_cpu_error
                         000153 open_status                 display_cpu_error
                         000154 plural_sw                   display_cpu_error
                         000156 ptr_array                   display_cpu_error
                         000160 print_cnt                   display_cpu_error
                         000161 read_cnt                    display_cpu_error
                         000162 segs_allocated              display_cpu_error
                         000163 tab_cnt                     display_cpu_error
                         000164 thread_sw                   display_cpu_error
                         000165 tm1                         display_cpu_error
                         000173 tm2                         display_cpu_error
                         000201 to_sw                       display_cpu_error
                         000202 to_time                     display_cpu_error
                         000204 workp                       display_cpu_error
                         000206 ctext                       display_cpu_error
                         000406 ctextl                      display_cpu_error
                         000410 match_data                  display_cpu_error
                         000416 exclude_data                display_cpu_error
                         000432 syserr_msgp                 display_cpu_error
                         000434 fmsgp                       display_cpu_error
                         000436 scup                        display_cpu_error
                         000464 arg_copy                    time_arg
                         000476 link                        string_check
                         000506 q                           match_string
                         000516 PRS                         print_it
                         000536 cpu                         print_it
                         000540 cpu_tag                     print_it
                         000542 error_msg                   print_it
                         000573 found                       print_it
                         000574 hr_ptr                      print_it
                         000576 tcpu                        print_it
                         000577 i                           print_it
                         000600 j                           print_it
                         000620 fault_no                    interpret_fault_reg
                         000621 break                       interpret_fault_reg
                         000622 line1                       interpret_fault_reg
                         000647 line2                       interpret_fault_reg
                         000674 line1_sw                    interpret_fault_reg
                         000675 line2_sw                    interpret_fault_reg
                         000676 indx                        interpret_fault_reg
                         000706 at_by_wd                    interp_scu
                         000707 cvbinbuf                    interp_scu
                         000712 flt_bf                      interp_scu
                         000721 flt_ln                      interp_scu
                         000752 iocbp                       interp_scu
                         000754 TAG_ptr                     interp_scu
                         000756 tag_prt                     interp_scu
                         000757 tag_                        interp_scu
                         000760 lnpos                       interp_scu
                         000761 flt_lng                     interp_scu
                         000762 inst6                       interp_scu
                         000763 i                           interp_scu
                         000764 j                           interp_scu
                         000766 byptr                       interp_scu
                         000770 refptr                      interp_scu
                         000772 tsrpr                       interp_scu

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_le_a              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              enable              shorten_stack       ext_entry
int_entry           set_cs_eis          index_cs_eis        alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_date_to_binary_       convert_date_to_binary_$relative
convert_status_code_          cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel
cv_bin_$oct                   date_time_$format             db_print                      get_system_free_area_
get_temp_segments_            hran_$hranl                   hran_$no_thread               ioa_
ioa_$rsnnl                    print_syserr_msg_$open_err    release_temp_segments_        syserr_log_util_$close
syserr_log_util_$open         syserr_log_util_$read         syserr_log_util_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$end_of_info      iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 003642        39 003650        45 003652        47 003653        52 003654        54 003655        57 003656
     58 003657        59 003660        62 003661        64 003662        69 003664        73 003665        75 003670
     76 003671        77 003672        79 003674        94 003675        95 003676       142 003677       144 003721
    145 003742       146 003744       147 003773       149 003774       150 003776       152 004000       153 004007
    154 004016       155 004021       157 004022       158 004033       160 004041       161 004062       164 004064
    165 004066       166 004105       167 004107       168 004133       170 004134       171 004136       173 004137
    174 004154       175 004156       176 004202       180 004203       181 004205       182 004234       183 004236
    184 004270       186 004271       188 004273       190 004277       193 004302       196 004303       197 004304
    199 004324       200 004326       201 004331       202 004354       205 004355       206 004356       207 004360
    208 004366       209 004367       211 004374       212 004376       213 004403       214 004411       215 004413
    217 004414       219 004420       220 004424       221 004430       224 004441       227 004452       228 004453
    230 004454       231 004465       237 004466       239 004470       240 004474       245 004531       246 004535
    248 004536       250 004567       254 004570       257 004571       258 004574       259 004575       260 004607
    261 004611       262 004613       263 004614       264 004620       265 004622       266 004624       267 004625
    268 004631       269 004633       270 004635       271 004637       272 004641       273 004642       274 004652
    275 004653       276 004655       277 004656       278 004664       279 004673       280 004677       281 004701
    283 004726       285 004727       286 004730       287 004744       289 005003       292 005004       293 005007
    294 005042       297 005043       298 005051       299 005060       300 005061       301 005063       303 005064
    305 005077       306 005103       307 005107       308 005111       309 005112       311 005113       312 005123
    313 005127       314 005131       315 005132       318 005133       319 005165       321 005166       323 005167
    324 005173       325 005220       328 005221       334 005222       337 005223       338 005242       339 005244
    340 005273       342 005274       343 005275       344 005301       346 005302       348 005303       349 005305
    350 005311       356 005312       363 005314       364 005325       365 005327       366 005360       368 005361
    369 005362       370 005407       371 005411       372 005447       375 005450       381 005451       388 005453
    389 005464       390 005466       391 005467       393 005502       395 005520       397 005527       398 005530
    399 005533       400 005536       401 005544       402 005547       403 005550       404 005555       405 005556
    411 005557       417 005561       418 005567       419 005571       420 005576       421 005612       422 005614
    424 005615       430 005620       435 005621       442 005672       443 005673       444 005703       445 005705
    446 005707       447 005721       448 005722       449 005724       450 005731       451 005735       452 005747
    453 005755       454 005757       455 005762       457 005763       458 005767       459 006003       461 006015
    462 006023       464 006025       467 006032       470 006133       471 006137       472 006157       475 006200
    477 006246       480 006302       481 006305       482 006323       483 006366       485 006367       487 006457
    488 006464       490 006500       492 006525       493 006546       494 006550       495 006551       497 006555
    498 006571       499 006605       501 006627       503 006644       510 006645       514 006646       517 006706
    521 006751       523 006770       524 006772       526 007016       529 007017       531 007057       533 007074
    536 007076       537 007121       538 007122       546 007123       549 007131       551 007140       552 007143
    553 007144       555 007165       575 007167       561 007173       591 007176       594 007205       596 007207
    597 007215       598 007223       599 007262       601 007265       603 007267       604 007270       605 007277
    606 007311       607 007330       608 007372       609 007375       611 007377       613 007401       614 007407
    615 007415       616 007454       618 007457       620 007461       623 007472       625 007503       627 007542
    630 007543       644 007546       645 007547       646 007555       647 007622       649 007625       650 007632
    651 007640       655 007665       662 007666       679 007670       680 007671       764 007673       765 007677
    766 007700       767 007716       770 007747       771 007751       772 007754       773 007756       774 007762
    775 007765       776 007767       777 007775       778 010007       779 010011       781 010012       782 010015
    783 010017       785 010021       786 010027       787 010040       788 010054       789 010056       790 010060
    791 010065       792 010072       795 010142       796 010143       798 010177       799 010201       801 010220
    802 010227       805 010261       807 010266       808 010270       809 010305       810 010325       811 010350
    814 010375       815 010441       816 010444       817 010451       818 010457       819 010520       820 010522
    821 010526       822 010532       823 010555       825 010560       826 010564       827 010571       828 010632
    829 010634       830 010640       831 010644       832 010667       834 010672       835 010677       836 010705
    837 010746       839 010750       840 010752       842 010760       843 010762       844 010766       847 010770
    848 011001       849 011005       852 011035       853 011041       854 011057       856 011141       857 011226


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
