	COMPILATION LISTING OF SEGMENT format_log_message_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/15/85  1109.1 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 format_log_message_:
        7      procedure ();
        8 
        9 /* *	FORMAT_LOG_MESSAGE_
       10*   *
       11*   *	This is the procedure for formatting the text portion of sys log 
       12*   *	messages.  It must be used in conjunction with expand_log_message_ 
       13*   *	to handle binary messages. Formatting log messages requires a
       14*   *	log_message_format structure; this must be created by calling
       15*   *	format_log_message_$init, and, when finished, freed by a call
       16*   *	to format_log_message_$free. This log_message_format structure
       17*   *	is then used (never modified) in all calls to
       18*   *	format_log_message_$format, and expand_log_message_$format. 
       19*   *	Additionally, some user-supplied binary message formatting
       20*   *	routines may want to be aware of its contents and follow the
       21*   *	appropriate rules if they do any fancy formatting.
       22*   *
       23*   *      1984-07-04, W. Olin Sibert: Initial coding
       24*   *      1984-12-03, BIM: Fixed to respect equal_sw.
       25*   *      1984-12-05, WOS: Added support for processing expansions.
       26*   *      1984-12-11, BIM: Allowed LONG date and time strings.
       27*   *	1984-12-20, WOS: Changed to make continuation_indent user-settable
       28*   *      1984-12-26, BIM: Changed to make continuation_indent -1 mean "default" and zero ZERO.
       29*   *      1985-01-21, BIM: Changed not to == if data is mismatched and there
       30*   *         is expansion.
       31*   *      1985-02-02, WOS: Changed to adjust message times for time zone and date header check.
       32*   *	1985-03-14, Steve Herbst: Fixed boundary condition bug causing 2 newline characters in a row.
       33*   */
       34 
       35 declare	P_log_message_format_ptr pointer parameter;
       36 declare	P_log_message_ptr pointer parameter;
       37 declare	P_prev_message_ptr pointer parameter;
       38 declare   P_expansion char (*) varying parameter;
       39 declare	P_buffer char (*) varying parameter;
       40 declare	P_code fixed bin (35);
       41 
       42 declare	system_area_ptr pointer;
       43 declare	system_area area based (system_area_ptr);
       44 
       45 declare	own_log_message_format bit (1) aligned;
       46 declare	message_prefix char (200) varying;
       47 declare	prev_message_ptr pointer;
       48 declare   total_lines fixed bin;
       49 
       50 declare   time_defaults_$zone_delta fixed bin (71) external static;
       51 
       52 declare   date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) varying);
       53 declare   date_time_$valid_format entry (char (*), fixed bin, fixed bin (35));
       54 declare	get_system_free_area_ entry () returns (pointer);
       55 declare   ioa_$rsnnl entry options (variable);
       56 
       57 declare	MIN_LINE_LTH init (40) fixed bin internal static options (constant);
       58 declare	NEWLINE char (1) unaligned internal static options (constant) init ("
       59 ");
       60 
       61 declare  (addr, clock, divide, hbound, index, lbound, length, maxlength, min, null, reverse, search, substr, unspec) builtin;
       62 
       63 /* */
       64 
       65 format_log_message_$init:
       66      entry (P_log_message_format_ptr);
       67 
       68           system_area_ptr = get_system_free_area_ ();
       69           allocate log_message_format in (system_area) set (log_message_format_ptr);
       70 
       71           unspec (log_message_format) = ""b;
       72           log_message_format.area_ptr = system_area_ptr;
       73           log_message_format.caller = "<<not-set>>";
       74           log_message_format.line_lth = 132;                /* Assume a line-printer page */
       75           log_message_format.indentation = 0;
       76           log_message_format.continuation_indent = -1;
       77           log_message_format.equal_sw = "0"b;
       78           log_message_format.error_sw = "1"b;               /* Report errors by default */
       79           log_message_format.prefix = "";
       80           log_message_format.number_format = "^7d";
       81           log_message_format.time_format = "iso_time";      /* HH:MM:SS by default */
       82           log_message_format.date_format = "^9999yc-^my-^dm  ^da  ^za";
       83 
       84           call format_log_message_$adjust (log_message_format_ptr, (0)); /* Guaranteed to work, we supplied the formats */
       85 
       86           P_log_message_format_ptr = log_message_format_ptr;
       87           return;
       88 
       89 
       90 
       91 format_log_message_$adjust:
       92      entry (P_log_message_format_ptr, P_code);
       93 
       94           log_message_format_ptr = P_log_message_format_ptr;
       95 
       96           P_code = 0;                                       /* Assume it worked, to begin with */
       97 
       98           call adjust_log_message_format ();
       99 
      100           return;
      101 
      102 /*  */
      103 
      104 adjust_log_message_format:
      105      procedure ();
      106 
      107 declare   time_string char (40) varying;
      108 declare   result char (80) varying;
      109 declare   base_time fixed bin (71);
      110 declare   test_time fixed bin (71);
      111 declare   base_string char (50) varying;
      112 declare   test_string char (50) varying;
      113 declare   test_idx fixed bin;
      114 declare   DATE_MODULUS (4) fixed bin (52) internal static options (constant) init
      115          (1f6, 60f6, 3600f6, 86400f6);                      /* In Microseconds: One second, minute, hour, or day */
      116 
      117 
      118 
      119 /* First, see whether there is supposed to be a date break string, and 
      120*   set it appropriately */
      121 
      122           if (log_message_format.date_format ^= "") then do;
      123                call date_time_$valid_format ((log_message_format.date_format), (0), P_code);
      124                if (P_code ^= 0) then                        /* Forget it */
      125                     return;
      126 
      127                call ioa_$rsnnl ("^/^[^^^dx^;^s^]^va^a^/", log_message_format.date_ioa_string, (0),
      128                     (log_message_format.indentation ^= 0),
      129                     log_message_format.indentation,
      130                     length (log_message_format.prefix),
      131                     log_message_format.prefix,
      132                     "^a");                                  /* This is where the date result is inserted */
      133 
      134 /* This block of code determines when the "date" line should be printed-- 
      135*   it is printed each time it would differ between two adjacent messages,
      136*   and we test to see whether that happens when the second, minute, hour,
      137*   or actual day is the breakpoint. */
      138 
      139                base_time = 0;                               /* Start out at zero, find where it differs */
      140                base_string = date_time_$format ((log_message_format.date_format), base_time, "", "");
      141                test_string = base_string;                   /* Break the loop when these differ */
      142                log_message_format.date_modulus = 0;
      143 
      144                do test_idx = lbound (DATE_MODULUS, 1) to hbound (DATE_MODULUS, 1)
      145                          while (test_string = base_string);
      146 
      147                     log_message_format.date_modulus = DATE_MODULUS (test_idx);
      148                     test_time = base_time + DATE_MODULUS (test_idx);
      149                     test_string = date_time_$format ((log_message_format.date_format), test_time, "", "");
      150                     end;
      151                end;
      152           else log_message_format.date_ioa_string = "";
      153 
      154 /* Next, figure out the max length of the time string (via a kludge, because 
      155*   there is no date_time_ mechanism for it yet), and save the result. */
      156 
      157           if (log_message_format.time_format ^= "") then do;
      158                call date_time_$valid_format ((log_message_format.time_format), (0), P_code);
      159                if (P_code ^= 0) then                        /* Forget it */
      160                     return;
      161 
      162                time_string = date_time_$format ((log_message_format.time_format), (clock ()), "", "");
      163                end;
      164           else time_string = "";
      165 
      166 /* Construct the ioa_ string used for messages */
      167 
      168           call ioa_$rsnnl ("^[^^^dx^;^s^]^va^[^a ^;^s^^s^]^[^a ^;^s^^s^]^a^a",
      169                log_message_format.message_ioa_string, (0),
      170                (log_message_format.indentation ^= 0),       /* Insert only if there is an indentation */
      171                log_message_format.indentation,              /* Inserted as ^23x */
      172                length (log_message_format.prefix),          /* Inserted as literal text */
      173                log_message_format.prefix,                   /* Inserted only if there is a prefix defined */
      174                (time_string ^= ""),                         /* Create this field only if there is a time format */
      175                "^a",                                        /* Time: Result from date_time_$format put here */
      176                (log_message_format.number_format ^= ""),    /* Create this field only if there is a number format */
      177                log_message_format.number_format,            /* Message number: Straight ioa_ format */
      178                "^2d",                                       /* Severity: Always included */
      179                "^x");                                       /* A space always before the message text */
      180 
      181 /* Try it out with reasonable inputs, to see how long it will be */
      182 
      183           call ioa_$rsnnl (log_message_format.message_ioa_string, result, (0),
      184                time_string, 1, 99);
      185           log_message_format.prefix_lth = length (result);  /* This is the length of the prefix, without the message */
      186 
      187           if (log_message_format.line_lth = 0) then         /* Apply a default? */
      188                log_message_format.line_lth = 132;
      189           else if (log_message_format.line_lth < MIN_LINE_LTH) then
      190                log_message_format.line_lth = MIN_LINE_LTH;
      191 
      192 /* Continuation indent is chosen to allow at least a reasonable number of 
      193*   characters in the continuation lines, without overflowing the specified
      194*   line length. It is, however, the caller's responsibility not to overflow
      195*   the first line by specifying too large a prefix and indentation. And, of
      196*   course, if the caller supplies his own continuation_indent, all bets are
      197*   off (we interpret negative numbers to mean "default". */
      198    
      199 	if (log_message_format.continuation_indent >= 0) then
      200 	     log_message_format.real_continuation_indent = log_message_format.continuation_indent;
      201 
      202           else if ((length (result) + MIN_LINE_LTH) > log_message_format.line_lth) then
      203                log_message_format.real_continuation_indent = log_message_format.line_lth - MIN_LINE_LTH;
      204 
      205           else log_message_format.real_continuation_indent = length (result);
      206 
      207           return;
      208           end adjust_log_message_format;
      209 
      210 /*  */
      211 
      212 format_log_message_$free:
      213      entry (P_log_message_format_ptr);
      214 
      215 	log_message_format_ptr = P_log_message_format_ptr;
      216 
      217 	if (log_message_format_ptr = null ()) then return;
      218 
      219 	P_log_message_format_ptr = null ();
      220 
      221 	system_area_ptr = log_message_format.area_ptr;
      222 	free log_message_format in (system_area);
      223 
      224 	return;
      225 
      226 /* */
      227 
      228 format_log_message_$format:
      229      entry (P_log_message_format_ptr, P_log_message_ptr, P_prev_message_ptr, P_expansion, P_buffer, P_code);
      230 
      231           log_message_format_ptr = P_log_message_format_ptr;
      232           log_message_ptr = P_log_message_ptr;
      233           prev_message_ptr = P_prev_message_ptr;
      234           P_code = 0;
      235 
      236           own_log_message_format = "0"b;
      237           if (log_message_format_ptr = null ()) then do;
      238                own_log_message_format = "1"b;
      239                call format_log_message_$init (log_message_format_ptr);
      240                end;
      241 
      242           call format_message_prefix ();
      243 
      244           if (^format_duplicate_message ()) then do;
      245                call format_message ("0"b);
      246 
      247                if (length (P_expansion) > 0) then
      248                     call format_message ("1"b);
      249                end;
      250 
      251           if own_log_message_format then
      252                call format_log_message_$free (log_message_format_ptr);
      253 
      254           return;
      255 
      256 /*  */
      257 
      258 format_message_prefix:
      259      procedure ();
      260 
      261 declare   time_string char (100) varying;
      262 declare   date_string char (200) varying;
      263 declare   include_date bit (1) aligned;
      264 declare   this_date fixed bin (30);
      265 declare   previous_date fixed bin (30);
      266 
      267 
      268 
      269 /* Get the character representation of message time, if we're to insert it */
      270 
      271           if (length (log_message_format.time_format) > 0) then
      272                time_string = date_time_$format ((log_message_format.time_format), (log_message.time), "", "");
      273           else time_string = "";
      274 
      275           call ioa_$rsnnl (log_message_format.message_ioa_string, message_prefix, (0),
      276                time_string, log_message.sequence, log_message.severity);
      277 
      278           if (length (log_message_format.date_format) = 0) then
      279                include_date = "0"b;
      280           else if (prev_message_ptr = null ()) then
      281                include_date = "1"b;
      282           else do;
      283                this_date = divide ((log_message.time - time_defaults_$zone_delta),
      284                     log_message_format.date_modulus, 34, 0);
      285                previous_date = divide ((prev_message_ptr -> log_message.time - time_defaults_$zone_delta),
      286                     log_message_format.date_modulus, 34, 0);
      287                include_date = (this_date ^= previous_date);
      288                end;
      289 
      290           if include_date then do;
      291                date_string = date_time_$format ((log_message_format.date_format), (log_message.time), "", "");
      292                call ioa_$rsnnl (log_message_format.date_ioa_string, date_string, (0), (date_string));
      293                                                             /* date_string passed by value because it is read & written */
      294                message_prefix = date_string || message_prefix; /* And insert the date at the front */
      295                end;
      296 
      297           return;
      298           end format_message_prefix;
      299 
      300 /*  */
      301 
      302 format_duplicate_message:
      303      procedure () returns (bit (1) aligned);
      304 
      305           if (prev_message_ptr = null ()) then
      306                return ("0"b);
      307 
      308 	if ^log_message_format.equal_sw
      309 	then return ("0"b);
      310 
      311           if (log_message.text_lth ^= prev_message_ptr -> log_message.text_lth) then
      312                return ("0"b);
      313 
      314           if (log_message.text ^= prev_message_ptr -> log_message.text) then
      315                return ("0"b);
      316 
      317 	if (length (P_expansion) > 0) then do; /* If there is any expansion present, assume that all the fields become interesting */
      318 	     if (log_message.process_id ^= prev_message_ptr -> log_message.process_id)
      319 		then return ("0"b);
      320 	     if (log_message.data_class_lth ^= prev_message_ptr -> log_message.data_class_lth)
      321 	          then return ("0"b);
      322 	     if (log_message.data_lth ^= prev_message_ptr -> log_message.data_lth)
      323 		then return ("0"b);
      324 
      325 	     if (log_message.data_class ^= prev_message_ptr -> log_message.data_class)
      326 		then return ("0"b);
      327 
      328 	     if (log_message.data_lth > 0)
      329 		then if (unspec (log_message.data) ^= unspec (prev_message_ptr -> log_message.data)) then
      330 		return ("0"b);
      331 	end;
      332 
      333           P_buffer = message_prefix;
      334           P_buffer = P_buffer || "==";
      335           P_buffer = P_buffer || NEWLINE;
      336 
      337           return ("1"b);
      338           end;
      339 
      340 /*  */
      341 
      342 format_message:
      343      procedure (P_add_expansion);
      344 
      345 declare   P_add_expansion bit (1) aligned parameter;        /* Whether we are processing text or expansion */
      346 
      347 declare   text_ptr pointer;                                 /* Pointer to text portion of message, for ease of use */
      348 declare   text_used fixed bin;                              /* Amount of message text used by previous lines of message */
      349 declare   text_lth fixed bin;                               /* Total length of message text */
      350 declare   line_lth fixed bin;                               /* Length of the "line"-- portion of this message that will */
      351                                                             /* be placed into the output buffer-- adjusted for breaking */
      352 declare   breaking_lth fixed bin;                           /* Number of chars at end of line to consider looking for */
      353                                                             /* place to break this line of the message-- we don't scan */
      354                                                             /* the entire line in order to avoid a real short piece */
      355                                                             /* immediately followed by a very long one. Never more */
      356                                                             /* than half the line length, and never more than MAX_BREAK */
      357 
      358 declare 1 text unaligned based (text_ptr),
      359           2 used char (text_used),
      360           2 line,
      361             3 before char (line_lth),
      362             3 after char (breaking_lth);
      363 
      364 declare   prefix_lth fixed bin;                             /* Length of string preceding text of message: starts out */
      365                                                             /* as length of previously formatted prefix (which may */
      366                                                             /* contain newlines), and is set to real_continuation_indent */
      367                                                             /* for the second through last lines */
      368 
      369 declare   output_ptr pointer;                               /* Pointer to varying output string overlay */
      370 declare   output_line_lth fixed bin;                        /* Max length of current output line (adjusted for prefix) */
      371 declare   output_used fixed bin;                            /* Number of characters used in output */
      372 declare   output_max_lth fixed bin;                         /* Max size of output buffer */
      373 
      374 declare   continuation_line bit (1) aligned;                /* Set for second through last output lines */
      375 declare 1 output aligned based (output_ptr),                /* Overlay for varying string output buffer */
      376           2 lth fixed bin,
      377           2 used char (0 refer (output.lth)) unaligned,
      378           2 prefix char (prefix_lth) unaligned,
      379           2 text_line char (line_lth) unaligned,
      380           2 newline char (1) unaligned;
      381 
      382 declare   nl_idx fixed bin;                                 /* Used to find intentional line breaks in message */
      383 declare   max_breaking_lth fixed bin;                       /* Used to calculate maximum value for breaking_lth */
      384 declare   break_idx fixed bin;                              /* Used to find a good place to break the line */
      385 declare   break_char char (1) unaligned;                    /* Temporary copy of char at which line is broken */
      386 
      387 declare   text_remaining bit (1) aligned;                   /* Used to simulate DO ... UNTIL */
      388 
      389 declare   MAX_BREAKING_LTH fixed bin internal static options (constant) init (20);
      390 declare   ALL_BREAK_CHARS char (12) unaligned internal static options (constant) init ("([{}]) .,;:|");
      391 declare   BREAK_BEFORE_CHARS char (3) unaligned internal static options (constant) init ("([{");
      392 
      393 /* */
      394 
      395           prefix_lth = length (message_prefix);
      396           output_line_lth = log_message_format.line_lth - log_message_format.prefix_lth;
      397                                                             /* Must use raw prefix length, not the one that may */
      398                                                             /* include newlines and the date stamp */
      399 
      400           output_ptr = addr (P_buffer);                     /* Collect our output buffer */
      401           output_max_lth = maxlength (P_buffer);
      402 
      403           text_used = 0;
      404           breaking_lth = 0;
      405 
      406           if ^P_add_expansion then do;                      /* We are processing the message text this time, so */
      407                text_lth = length (log_message.text);        /* we start out by emptying the buffer and filling */
      408                text_ptr = addr (log_message.text);          /* it up with the prefix, and then the text. */
      409 
      410                output.lth = 0;                              /* Empty the buffer */
      411                output_used = 0;
      412                continuation_line = "0"b;                    /* The first line is NOT a continuation line */
      413                total_lines = 0;                             /* And we haven't formatted any lines already */
      414                end;
      415 
      416           else do;                                          /* Otherwise, we are just appending the expansion */
      417                text_lth = length (P_expansion);
      418                text_ptr = addr (substr (P_expansion, 1, 1));
      419 
      420                output_used = output.lth;                    /* See how much we've used already */
      421                continuation_line = "1"b;                    /* All lines are continuations, for the expansion */
      422                end;
      423 
      424           text_remaining = "1"b;                            /* Start the loop off right */
      425 
      426           do total_lines = (total_lines + 1) by 1 while (text_remaining);
      427                line_lth = text_lth - length (text.used);
      428                nl_idx = index (text.line.before, NEWLINE);
      429                if (nl_idx > 0) then
      430                     line_lth = nl_idx - 1;
      431 
      432                if continuation_line then do;                /* Set possibly different values for continuation lines */
      433                     prefix_lth = log_message_format.real_continuation_indent;
      434                     output_line_lth = log_message_format.line_lth - prefix_lth;
      435                     end;
      436 
      437                if (length (text.line.before) > output_line_lth) then do;
      438                     nl_idx = 0;                             /* Stop skipping of the final newline this time around */
      439                     line_lth = output_line_lth;             /* Set to maximum allowed */
      440                     max_breaking_lth = divide (length (text.line.before), 2, 17, 0);
      441 
      442                     breaking_lth = min (max_breaking_lth, MAX_BREAKING_LTH); /* Until now, this has been zero */
      443                     line_lth = line_lth - breaking_lth;     /* Adjust down -- line.before and line.after are now same */
      444                     break_idx = search (reverse (text.line.after), ALL_BREAK_CHARS); /* as line.before was previously */
      445 
      446                     if (break_idx = 0) then do;             /* No good choice for break character found */
      447                          line_lth = line_lth + breaking_lth; /* Set line length back to what it was before, and */
      448                          breaking_lth = 0;                  /* break arbitrarily at end of line */
      449                          end;
      450 
      451                     else do;
      452                          break_idx = 1 + (length (text.line.after) - break_idx); /* Convert back to forward origin */
      453                          line_lth = line_lth + break_idx;   /* Move the before/after break to include the break char */
      454                          breaking_lth = breaking_lth - break_idx;
      455 
      456                          break_char = substr (text.line.before, length (text.line.before), 1);
      457                          if (index (BREAK_BEFORE_CHARS, break_char) ^= 0) then do;
      458                               line_lth = line_lth - 1;      /* If it's one of these, move back a character */
      459                               breaking_lth = breaking_lth + 1; /* so we can include this "opening" break in the next */
      460                               end;                          /* line of the message */
      461 
      462                          breaking_lth = 0;                  /* Now, eliminate the rest of the line, putting it back */
      463                          end;                               /* for inclusion in the next output line */
      464                     end;                                    /* After this, breaking_lth is always zero */
      465 
      466                output_used = output.lth + length (output.prefix) + length (output.text_line) + length (output.newline);
      467                if (output_used > output_max_lth) then do;   /* Buffer has overflowed. Truncate at previous line */
      468                     return;
      469                     end;
      470 
      471                if continuation_line then                    /* For continuation lines, just insert a blank prefix */
      472                     output.prefix = "";                     /* to supply the indentation; otherwise, insert the */
      473                else output.prefix = message_prefix;         /* real prefix, including date and other info */
      474 
      475                output.text_line = text.line.before;
      476                output.newline = NEWLINE;
      477                output.lth = output_used;                    /* Update varying string length value */
      478 
      479 	     if substr (output.used, output.lth - 1, 2) = NEWLINE || NEWLINE then
      480 		output.lth = output.lth - 1;		/* prevent blank line in output */
      481 
      482                text_used = text_used + length (text.line.before);
      483 
      484                if (nl_idx > 0) then                         /* Skip embedded newlines */
      485                     text_used = text_used + 1;
      486 
      487                if (text_used >= text_lth) then              /* Stop the loop */
      488                     text_remaining = "0"b;
      489 
      490                continuation_line = "1"b;                    /* All remaining lines are continuations */
      491                end;                                         /* of loop through message */
      492 
      493           return;
      494           end format_message;
      495 
      496  /* BEGIN INCLUDE FILE ... log_message_format.incl.pl1 ... 84-07-03 ... W. Olin Sibert */
  1     2 
  1     3 declare 1 log_message_format            aligned based (log_message_format_ptr),
  1     4           2 caller                      char (32) unaligned, /* Caller name to use when printing error messages */
  1     5           2 line_lth                    fixed bin,          /* Max length of output lines; longer messages are folded */
  1     6           2 indentation                 fixed bin,          /* Number of spaces at beginning of each output line */
  1     7           2 equal_sw                    bit (1) aligned,    /* Whether to suppress messages with identical text */
  1     8           2 error_sw                    bit (1) aligned,    /* Whether to print error messages via com_err_ */
  1     9           2 prefix                      char (40) varying,  /* Prefix for printing messages */
  1    10           2 number_format               char (20) varying,  /* ioa_ format for printing message numbers */
  1    11           2 time_format                 char (40) varying,  /* date_time_$format string for message times */
  1    12           2 date_format                 char (40) varying,  /* date_time_$format string for when date changes */
  1    13           2 continuation_indent	fixed bin,	/* If >= zero, value for continuation lines */
  1    14 						/* Otherwise, lined up under the text by default */
  1    15 
  1    16           2 pad (59)                    bit (36) aligned,
  1    17 
  1    18 /* ONLY format_log_message_$adjust ever changes the values below */
  1    19 
  1    20           2 internal_info               aligned,            /* Internal info, set by $adjust-- DO NOT CHANGE */
  1    21             3 area_ptr                  pointer,            /* Where this structure is allocated */
  1    22             3 date_ioa_string           char (100) varying, /* Format for date breaks,if any */
  1    23             3 message_ioa_string        char (100) varying, /* Format for first lines of messages */
  1    24             3 real_continuation_indent  fixed bin,          /* Indentation for continuation lines */
  1    25             3 prefix_lth                fixed bin,          /* Length of indent + prefix + time + sequence + severity */
  1    26             3 date_modulus              fixed bin (36),     /* Modulus for checking whether dates are equal */
  1    27 
  1    28           2 end                         fixed bin;
  1    29 
  1    30 declare   log_message_format_ptr pointer;
  1    31 
  1    32 /* END INCLUDE FILE ... log_message_format.incl.pl1 */
      496 
      497  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  2     2 
  2     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  2     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  2     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  2     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  2     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  2     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  2     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  2    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  2    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  2    12 
  2    13 declare 1 log_message         aligned based (log_message_ptr),
  2    14           2 header            aligned like log_message_header,
  2    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  2    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  2    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  2    18 
  2    19 declare   log_message_ptr pointer;
  2    20 declare   log_message_text_lth fixed bin;
  2    21 declare   log_message_data_class_lth fixed bin;
  2    22 declare   log_message_data_lth fixed bin;
  2    23 
  2    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      497 
      498 
      499           end format_log_message_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/85  1105.2  format_log_message_.pl1           >spec>on>bound_log_tools_.pbf>format_log_message_.pl1
496          1    01/21/85  0912.2  log_message_format.incl.pl1       >ldd>include>log_message_format.incl.pl1
497          2    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALL_BREAK_CHARS                 000001 constant        char(12)                 initial unaligned dcl 390 ref 444
BREAK_BEFORE_CHARS              000000 constant        char(3)                  initial unaligned dcl 391 ref 457
DATE_MODULUS                    000004 constant        fixed bin(52,0)          initial array dcl 114 ref 144 144 147 148
MAX_BREAKING_LTH                       constant        fixed bin(17,0)          initial dcl 389 ref 442
MIN_LINE_LTH                           constant        fixed bin(17,0)          initial dcl 57 ref 189 189 202 202
NEWLINE                         002516 constant        char(1)                  initial unaligned dcl 58 ref 335 428 476 479 479
P_add_expansion                        parameter       bit(1)                   dcl 345 ref 342 406
P_buffer                               parameter       varying char             dcl 39 set ref 228 333* 334* 334 335* 335 400 401
P_code                                 parameter       fixed bin(35,0)          dcl 40 set ref 91 96* 123* 124 158* 159 228 234*
P_expansion                            parameter       varying char             dcl 38 set ref 228 247 317 417 418
P_log_message_format_ptr               parameter       pointer                  dcl 35 set ref 65 86* 91 94 212 215 219* 228 231
P_log_message_ptr                      parameter       pointer                  dcl 36 ref 228 232
P_prev_message_ptr                     parameter       pointer                  dcl 37 ref 228 233
addr                                                   builtin function         dcl 61 ref 400 408 418
after                                  based           char                     level 3 packed unaligned dcl 358 ref 444 452
area_ptr                160            based           pointer                  level 3 dcl 1-3 set ref 72* 221
base_string                     000252 automatic       varying char(50)         dcl 111 set ref 140* 141 144
base_time                       000246 automatic       fixed bin(71,0)          dcl 109 set ref 139* 140* 148
before                                 based           char                     level 3 packed unaligned dcl 358 ref 428 437 440 456
                                                                                  456 475 482
break_char                      000473 automatic       char(1)                  unaligned dcl 385 set ref 456* 457
break_idx                       000472 automatic       fixed bin(17,0)          dcl 384 set ref 444* 446 452* 452 453 454
breaking_lth                    000457 automatic       fixed bin(17,0)          dcl 352 set ref 404* 442* 443 444 447 448* 452 454*
                                                                                  454 459* 459 462*
caller                                 based           char(32)                 level 2 packed unaligned dcl 1-3 set ref 73*
clock                                                  builtin function         dcl 61 ref 162
continuation_indent      63            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 76* 199 199
continuation_line               000467 automatic       bit(1)                   dcl 374 set ref 412* 421* 432 471 490*
data                                   based           bit(36)                  array level 2 dcl 2-13 ref 328 328
data_class                             based           char                     level 2 packed unaligned dcl 2-13 ref 325 325
data_class_lth            2(09)        based           fixed bin(9,0)           level 3 packed unsigned unaligned dcl 2-13 ref 320
                                                                                  320 325 325 328 328
data_lth                  4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 2-13 ref 322 322 328
                                                                                  328 328
date_format              50            based           varying char(40)         level 2 dcl 1-3 set ref 82* 122 123 140 149 278 291
date_ioa_string         162            based           varying char(100)        level 3 dcl 1-3 set ref 127* 152* 292*
date_modulus            250            based           fixed bin(36,0)          level 3 dcl 1-3 set ref 142* 147* 283 285
date_string                     000350 automatic       varying char(200)        dcl 262 set ref 291* 292* 292 294
date_time_$format               000012 constant        entry                    external dcl 52 ref 140 149 162 271 291
date_time_$valid_format         000014 constant        entry                    external dcl 53 ref 123 158
divide                                                 builtin function         dcl 61 ref 283 285 440
equal_sw                 12            based           bit(1)                   level 2 dcl 1-3 set ref 77* 308
error_sw                 13            based           bit(1)                   level 2 dcl 1-3 set ref 78*
get_system_free_area_           000016 constant        entry                    external dcl 54 ref 68
hbound                                                 builtin function         dcl 61 ref 144
header                                 based           structure                level 2 dcl 2-13
include_date                    000433 automatic       bit(1)                   dcl 263 set ref 278* 280* 287* 290
indentation              11            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 75* 127 127* 168 168*
index                                                  builtin function         dcl 61 ref 428 457
internal_info           160            based           structure                level 2 dcl 1-3
ioa_$rsnnl                      000020 constant        entry                    external dcl 55 ref 127 168 183 275 292
lbound                                                 builtin function         dcl 61 ref 144
length                                                 builtin function         dcl 61 ref 127 127 168 168 185 202 205 247 271 278
                                                                                  317 395 407 417 427 437 440 452 456 466 466 466
                                                                                  482
line                                   based           structure                level 2 packed unaligned dcl 358
line_lth                 10            based           fixed bin(17,0)          level 2 in structure "log_message_format" dcl 1-3
                                                                                  in procedure "format_log_message_" set ref 74* 187
                                                                                  187* 189 189* 202 202 396 434
line_lth                        000456 automatic       fixed bin(17,0)          dcl 350 in procedure "format_message" set ref 427*
                                                                                  428 429* 437 439* 440 443* 443 444 447* 447 452
                                                                                  453* 453 456 456 458* 458 466 466 475 475 476 482
log_message                            based           structure                level 1 dcl 2-13
log_message_format                     based           structure                level 1 dcl 1-3 set ref 69 71* 222
log_message_format_ptr          000172 automatic       pointer                  dcl 1-30 set ref 69* 71 72 73 74 75 76 77 78 79 80
                                                                                  81 82 84* 86 94* 122 123 127 127 127 127 127 127
                                                                                  140 142 147 149 152 157 158 162 168 168 168 168
                                                                                  168 168 168 168 183 185 187 187 189 189 199 199
                                                                                  199 202 202 202 205 215* 217 221 222 231* 237 239*
                                                                                  251* 271 271 275 278 283 285 291 292 308 396 396
                                                                                  433 434
log_message_header                     based           structure                level 1 dcl 2-3
log_message_ptr                 000174 automatic       pointer                  dcl 2-19 set ref 232* 271 275 275 283 291 311 314
                                                                                  318 320 322 325 328 328 407 408
lth                                    based           fixed bin(17,0)          level 2 dcl 375 set ref 410* 420 466 466 466 466 471
                                                                                  473 475 476 477* 479 479 479* 479
max_breaking_lth                000471 automatic       fixed bin(17,0)          dcl 383 set ref 440* 442
maxlength                                              builtin function         dcl 61 ref 401
message_ioa_string      214            based           varying char(100)        level 3 dcl 1-3 set ref 168* 183* 275*
message_prefix                  000103 automatic       varying char(200)        dcl 46 set ref 275* 294* 294 333 395 473
min                                                    builtin function         dcl 61 ref 442
newline                                based           char(1)                  level 2 packed unaligned dcl 375 set ref 466 476*
nl_idx                          000470 automatic       fixed bin(17,0)          dcl 382 set ref 428* 429 429 438* 484
null                                                   builtin function         dcl 61 ref 217 219 237 280 305
number_format            27            based           varying char(20)         level 2 dcl 1-3 set ref 80* 168 168*
output                                 based           structure                level 1 dcl 375
output_line_lth                 000464 automatic       fixed bin(17,0)          dcl 370 set ref 396* 434* 437 439
output_max_lth                  000466 automatic       fixed bin(17,0)          dcl 372 set ref 401* 467
output_ptr                      000462 automatic       pointer                  dcl 369 set ref 400* 410 420 466 466 466 466 471 473
                                                                                  475 476 477 479 479 479 479
output_used                     000465 automatic       fixed bin(17,0)          dcl 371 set ref 411* 420* 466* 467 477
own_log_message_format          000102 automatic       bit(1)                   dcl 45 set ref 236* 238* 251
prefix                   14            based           varying char(40)         level 2 in structure "log_message_format" dcl 1-3
                                                                                  in procedure "format_log_message_" set ref 79* 127
                                                                                  127 127* 168 168 168*
prefix                                 based           char                     level 2 in structure "output" packed unaligned
                                                                                  dcl 375 in procedure "format_message" set ref 466
                                                                                  471* 473*
prefix_lth              247            based           fixed bin(17,0)          level 3 in structure "log_message_format" dcl 1-3
                                                                                  in procedure "format_log_message_" set ref 185*
                                                                                  396
prefix_lth                      000460 automatic       fixed bin(17,0)          dcl 364 in procedure "format_message" set ref 395*
                                                                                  433* 434 466 466 466 471 473 475 476
prev_message_ptr                000166 automatic       pointer                  dcl 47 set ref 233* 280 285 305 311 314 318 320 322
                                                                                  325 328
previous_date                   000435 automatic       fixed bin(30,0)          dcl 265 set ref 285* 287
process_id                5            based           bit(36)                  level 3 dcl 2-13 ref 318 318
real_continuation_indent
                        246            based           fixed bin(17,0)          level 3 dcl 1-3 set ref 199* 202* 205* 433
result                          000221 automatic       varying char(80)         dcl 108 set ref 183* 185 202 205
reverse                                                builtin function         dcl 61 ref 444
search                                                 builtin function         dcl 61 ref 444
sequence                  1            based           fixed bin(35,0)          level 3 dcl 2-13 set ref 275*
severity                  2            based           fixed bin(8,0)           level 3 packed unaligned dcl 2-13 set ref 275*
substr                                                 builtin function         dcl 61 ref 418 456 479
system_area                            based           area(1024)               dcl 43 ref 69 222
system_area_ptr                 000100 automatic       pointer                  dcl 42 set ref 68* 69 72 221* 222
test_idx                        000306 automatic       fixed bin(17,0)          dcl 113 set ref 144* 147 148*
test_string                     000270 automatic       varying char(50)         dcl 112 set ref 141* 144 149*
test_time                       000250 automatic       fixed bin(71,0)          dcl 110 set ref 148* 149*
text                                   based           structure                level 1 packed unaligned dcl 358 in procedure
                                                                                  "format_message"
text                      6            based           char                     level 2 in structure "log_message" packed unaligned
                                                                                  dcl 2-13 in procedure "format_log_message_" set
                                                                                  ref 314 314 407 408
text_line                              based           char                     level 2 packed unaligned dcl 375 set ref 466 475*
text_lth                  4            based           fixed bin(17,0)          level 3 in structure "log_message" packed unaligned
                                                                                  dcl 2-13 in procedure "format_log_message_" ref
                                                                                  311 311 314 314 325 325 328 328 407 408
text_lth                        000455 automatic       fixed bin(17,0)          dcl 349 in procedure "format_message" set ref 407*
                                                                                  417* 427 487
text_ptr                        000452 automatic       pointer                  dcl 347 set ref 408* 418* 427 428 437 440 444 452
                                                                                  456 456 475 482
text_remaining                  000474 automatic       bit(1)                   dcl 387 set ref 424* 426 487*
text_used                       000454 automatic       fixed bin(17,0)          dcl 348 set ref 403* 427 428 437 440 444 452 456 456
                                                                                  475 482* 482 482 484* 484 487
this_date                       000434 automatic       fixed bin(30,0)          dcl 264 set ref 283* 287
time                      2(18)        based           fixed bin(53,0)          level 3 packed unaligned dcl 2-13 ref 271 283 285
                                                                                  291
time_defaults_$zone_delta       000010 external static fixed bin(71,0)          dcl 50 ref 283 285
time_format              35            based           varying char(40)         level 2 dcl 1-3 set ref 81* 157 158 162 271 271
time_string                     000316 automatic       varying char(100)        dcl 261 in procedure "format_message_prefix" set ref
                                                                                  271* 273* 275*
time_string                     000206 automatic       varying char(40)         dcl 107 in procedure "adjust_log_message_format" set
                                                                                  ref 162* 164* 168 183*
total_lines                     000170 automatic       fixed bin(17,0)          dcl 48 set ref 413* 426* 426*
unspec                                                 builtin function         dcl 61 set ref 71* 328 328
used                      1            based           char                     level 2 in structure "output" packed unaligned
                                                                                  dcl 375 in procedure "format_message" ref 479
used                                   based           char                     level 2 in structure "text" packed unaligned dcl 358
                                                                                  in procedure "format_message" ref 427

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 2-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 2-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 2-20

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_log_message_format       000401 constant        entry                    internal dcl 104 ref 98
format_duplicate_message        001604 constant        entry                    internal dcl 302 ref 244
format_log_message_             000107 constant        entry                    external dcl 6
format_log_message_$adjust      000220 constant        entry                    external dcl 91 ref 84
format_log_message_$format      000273 constant        entry                    external dcl 228
format_log_message_$free        000241 constant        entry                    external dcl 212 ref 251
format_log_message_$init        000120 constant        entry                    external dcl 65 ref 239
format_message                  002015 constant        entry                    internal dcl 342 ref 245 247
format_message_prefix           001250 constant        entry                    internal dcl 258 ref 242

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2712        2734    2520        2722
Length      3170    2520        22         220     171           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
format_log_message_                 555 external procedure  is an external procedure.  
adjust_log_message_format               internal procedure  shares stack frame of external procedure format_log_message_.  
format_message_prefix                   internal procedure  shares stack frame of external procedure format_log_message_.  
format_duplicate_message                internal procedure  shares stack frame of external procedure format_log_message_.  
format_message                          internal procedure  shares stack frame of external procedure format_log_message_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
format_log_message_      000100 system_area_ptr             format_log_message_
                         000102 own_log_message_format      format_log_message_
                         000103 message_prefix              format_log_message_
                         000166 prev_message_ptr            format_log_message_
                         000170 total_lines                 format_log_message_
                         000172 log_message_format_ptr      format_log_message_
                         000174 log_message_ptr             format_log_message_
                         000206 time_string                 adjust_log_message_format
                         000221 result                      adjust_log_message_format
                         000246 base_time                   adjust_log_message_format
                         000250 test_time                   adjust_log_message_format
                         000252 base_string                 adjust_log_message_format
                         000270 test_string                 adjust_log_message_format
                         000306 test_idx                    adjust_log_message_format
                         000316 time_string                 format_message_prefix
                         000350 date_string                 format_message_prefix
                         000433 include_date                format_message_prefix
                         000434 this_date                   format_message_prefix
                         000435 previous_date               format_message_prefix
                         000452 text_ptr                    format_message
                         000454 text_used                   format_message
                         000455 text_lth                    format_message
                         000456 line_lth                    format_message
                         000457 breaking_lth                format_message
                         000460 prefix_lth                  format_message
                         000462 output_ptr                  format_message
                         000464 output_line_lth             format_message
                         000465 output_used                 format_message
                         000466 output_max_lth              format_message
                         000467 continuation_line           format_message
                         000470 nl_idx                      format_message
                         000471 max_breaking_lth            format_message
                         000472 break_idx                   format_message
                         000473 break_char                  format_message
                         000474 text_remaining              format_message

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            call_ext_in         call_ext_out_desc   call_ext_out        return
shorten_stack       ext_entry           ext_entry_desc      divide_fx4          alloc_based         free_based
clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
date_time_$format             date_time_$valid_format       get_system_free_area_         ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
time_defaults_$zone_delta




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000106        65 000114        68 000125        69 000133        71 000140        72 000143        73 000145
     74 000150        75 000152        76 000153        77 000155        78 000156        79 000160        80 000161
     81 000165        82 000172        84 000177        86 000210        87 000213        91 000214        94 000230
     96 000234        98 000235       100 000236       212 000237       215 000246       217 000252       219 000256
    221 000260       222 000262       224 000264       228 000265       231 000316       232 000322       233 000325
    234 000330       236 000331       237 000332       238 000336       239 000340       242 000346       244 000347
    245 000354       247 000360       251 000370       254 000400       104 000401       122 000402       123 000410
    124 000442       127 000446       139 000525       140 000527       141 000600       142 000606       144 000611
    147 000625       148 000632       149 000634       150 000704       151 000707       152 000710       157 000711
    158 000717       159 000751       162 000755       163 001030       164 001032       168 001033       183 001153
    185 001215       187 001220       189 001225       199 001231       202 001235       205 001245       207 001247
    258 001250       271 001251       273 001332       275 001334       278 001373       280 001400       283 001407
    285 001422       287 001433       290 001436       291 001440       292 001516       294 001556       295 001602
    297 001603       302 001604       305 001606       308 001614       311 001621       314 001635       317 001647
    318 001653       320 001660       322 001674       325 001710       328 001724       333 001760       334 001771
    335 002003       337 002012       342 002015       395 002017       396 002021       400 002025       401 002031
    403 002033       404 002034       406 002035       407 002040       408 002044       410 002046       411 002047
    412 002050       413 002051       414 002052       417 002053       418 002056       420 002060       421 002062
    424 002064       426 002066       427 002072       428 002075       429 002110       432 002113       433 002115
    434 002120       437 002123       438 002126       439 002127       440 002131       442 002133       443 002137
    444 002141       446 002156       447 002157       448 002161       449 002162       452 002163       453 002167
    454 002170       456 002172       457 002201       458 002212       459 002214       462 002215       466 002216
    467 002223       468 002225       471 002226       473 002237       475 002246       476 002254       477 002260
    479 002262       482 002273       484 002275       487 002300       490 002304       491 002306       493 002310


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
