	COMPILATION LISTING OF SEGMENT test_fnp
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1043.0 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 test_fnp: proc options (variable);
       12 
       13 /* test_fnp - T & D that runs the offline FNP T & D tests (tst3bt) on an FNP
       14*   that is offline (not known to the answering service).  The tests that are run
       15*   on the fnp, are located in the general T & D repository
       16*   >system_library_tandd>tandd_deck_file.  They are put there by the
       17*   load_tandd_library command using a "-fnp_tape" control argument when loading
       18*   an FNP Binary Deck Tape (this tape is available from you're friendly FER).
       19*   The documentation for the tests that are run on the FNP, can be found in "T &
       20*   D Microfiche Documentation" box (also available from you're friendly FER) in
       21*   the front of the program listing.
       22*
       23*   Originally written by B. S. Greenberg 1/80
       24*   Modified by J. A. Bush 8/81 for release with MR9.0
       25**/
       26 
       27 dcl  program_interrupt condition;
       28 dcl  tandd_$fnp_tandd_setup entry (fixed bin, fixed bin (71), fixed bin (35));
       29 dcl  tandd_$fnp_tandd_detach entry (fixed bin, fixed bin (35));
       30 dcl  tandd_$fnp_tandd_mask entry (fixed bin, fixed bin (35));
       31 dcl  tandd_$fnp_tandd_send_int entry (fixed bin, fixed bin (3), fixed bin (35));
       32 dcl  tandd_$fnp_tandd_get_ints entry (fixed bin, bit (2) aligned, fixed bin (35));
       33 dcl (tandd_$fnp_tandd_read, tandd_$fnp_tandd_write)
       34      entry (fixed bin, ptr, fixed bin (18), fixed bin (15), fixed bin, fixed bin (35));
       35 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
       36 dcl  ask_$ask_clr entry;
       37 dcl  ask_ entry options (variable);
       38 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       39 dcl  com_err_ entry options (variable);
       40 dcl  iox_$look_iocb entry (char (*), ptr, fixed bin (35));
       41 dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       42 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
       43 dcl  iox_$close entry (ptr, fixed bin (35));
       44 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
       45 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
       46 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
       47 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
       48 dcl  tolts_util_$search entry (ptr, char (32), ptr, fixed bin, fixed bin (35));
       49 dcl  tolts_util_$bci_to_ascii entry (bit (*), char (*) varying, fixed bin);
       50 dcl  tolts_alm_util_$ascii_to_bci_ entry (char (*), bit (*));
       51 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (5), fixed bin (2), ptr, fixed bin (35));
       52 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
       53 dcl  hcs_$wakeup entry (bit (*), fixed bin (71), fixed bin (71), fixed bin (35));
       54 dcl  get_process_id_ entry () returns (bit (36));
       55 dcl  get_temp_segment_ entry (char (*), pointer, fixed bin (35));
       56 dcl  release_temp_segment_ entry (char (*), pointer, fixed bin (35));
       57 
       58 /* AUTOMATIC */
       59 
       60 dcl (allow_pi, piflag) bit (1);
       61 dcl  ask_ans char (32);
       62 dcl  ascvar char (200) varying;
       63 dcl  damage_85_86_flag bit (1);
       64 dcl  save_pgmname char (6);
       65 dcl (printer_switch, message_switch, input_switch) ptr;
       66 dcl  rx fixed bin init (1);
       67 dcl (exec_in_fnp, loader_loaded) bit (1);
       68 dcl (loadsegptr, moduleptr) ptr;
       69 dcl  modullen fixed bin (15);
       70 dcl  deck_iocbp ptr init (null);
       71 dcl  module_listp ptr;
       72 dcl  cata_key char (32);
       73 dcl  bcdbuf bit (6*6*64) unaligned;
       74 dcl  chars_gotten fixed bin (21);
       75 dcl  ascbuf char (200);
       76 dcl  argno fixed bin;
       77 dcl  arglen fixed bin;
       78 dcl  code fixed bin (35);
       79 dcl  fnp_no fixed bin;
       80 dcl  fnp_type_str char (4);
       81 dcl  fnp_type fixed bin;
       82 dcl  argp ptr;
       83 dcl  execname char (6);
       84 dcl  temp_ptr ptr;
       85 dcl  temp_arg char (32);
       86 dcl  fnp_tag char (1);
       87 
       88 /* CONSTANT */
       89 
       90 dcl  myname char (32) options (constant) static init ("test_fnp");
       91 dcl  fnp_interrupt_vector_word bit (36) static options (constant) init ("000334000777"b3);
       92 dcl  bcd_dkend bit (72) int static options (constant) init
       93     ("532020202020202442254524"b3);			/* "$      dkend" in bcd */
       94 dcl  NL char (1) int static options (constant) init ("
       95 ");
       96 
       97 
       98 /* BASED */
       99 
      100 dcl  arg char (arglen) based (argp);
      101 dcl  bcd_array (0 : 6*64 - 1) bit (6) unaligned based (addr (bcdbuf));
      102 dcl  three_words bit (36) aligned dim (3) based;
      103 
      104 /* EXTERNAL STATIC */
      105 
      106 dcl  error_table_$timeout fixed bin (35) ext static;
      107 dcl  error_table_$moderr fixed bin (35) ext static;
      108 dcl  error_table_$bad_arg fixed bin (35) ext static;
      109 dcl  error_table_$badopt fixed bin (35) ext static;
      110 dcl  error_table_$noarg fixed bin (35) ext static;
      111 dcl  error_table_$noentry fixed bin (35) ext static;
      112 dcl  error_table_$too_many_args fixed bin (35) ext static;
      113 dcl (iox_$user_output, iox_$user_input) ptr external static;
      114 
      115 /* STRUCTURES */
      116 
      117 dcl 1 idb,
      118     2 pad1 bit (21) unaligned,
      119     2 fnp_address fixed bin (15) unsigned unaligned,
      120     2 tally fixed bin (18) unsigned unaligned,
      121     2 pad2 bit (15) unaligned,
      122     2 request_code fixed bin (3) unsigned unaligned;
      123 
      124 
      125 dcl 1 module_list aligned based (module_listp),
      126     2 n fixed bin,
      127     2 name (0 refer (module_list.n)) char (24) unal;
      128 
      129 dcl  wait_list (10) fixed bin;
      130 
      131 /* BUILTIN */
      132 
      133 dcl (addr, addrel, before, bin, bit, currentsize, clock, divide, fixed, index, length, ltrim, min,
      134      mod, null, ptr, reverse, rtrim, substr, unspec) builtin;
      135 dcl (linkage_error, cleanup, finish) condition;
      136 
      137 
      138 	input_switch, message_switch, printer_switch = null ();
      139 	fnp_no = -1;
      140 	execname = "bos";
      141 	do argno = 1 by 1;
      142 	     call cu_$arg_ptr (argno, argp, arglen, code);
      143 	     if code ^= 0 then go to end_arg_processing;
      144 	     if substr (arg, 1, 1) ^= "-" then do;
      145 		if fnp_no ^= -1 then do;
      146 		     call com_err_ (error_table_$too_many_args, myname, "FNP tag multiply specified");
      147 		     return;
      148 		end;
      149 		fnp_no = index ("abcdefghABCDEFGH", arg);
      150 		if length (arg) = 1 & fnp_no ^= 0 then do;
      151 		     if fnp_no > 8 then fnp_no = fnp_no - 8;
      152 		     fnp_tag = substr ("ABCDEFGH", fnp_no);
      153 		end;
      154 		else do;
      155 		     call com_err_ (error_table_$bad_arg, myname, "Bad FNP tag: ^a.", arg);
      156 		     return;
      157 		end;
      158 	     end;
      159 	     else if arg = "-exec" then do;
      160 		argno = argno + 1;
      161 		call cu_$arg_ptr (argno, argp, arglen, code);
      162 		if code ^= 0 then do;
      163 		     call com_err_ (code, myname, "Exec name (ios or bos) missing.");
      164 		     return;
      165 		end;
      166 		if arg = "bos" then execname = "bos";
      167 		else if arg = "BOS" then execname = "bos";
      168 		else if arg = "ios" then execname = "ios";
      169 		else if arg = "IOS" then execname = "ios";
      170 		else do;
      171 		     call com_err_ (error_table_$bad_arg, myname, "Bad exec name.  Must be IOS or BOS.");
      172 		     return;
      173 		end;
      174 	     end;
      175 	     else if arg = "-osw" | arg = "-output_switch"
      176 	     | arg = "-msw" | arg = "-message_switch"
      177 	     | arg = "-isw" | arg = "-input_switch" then do;
      178 
      179 		temp_arg = arg;
      180 		argno = argno + 1;
      181 		call cu_$arg_ptr (argno, argp, arglen, code);
      182 		if code ^= 0 then do;
      183 		     call com_err_ (code, myname, "Missing switch name after ^a.", temp_arg);
      184 		     return;
      185 		end;
      186 		call iox_$look_iocb (arg, temp_ptr, code);
      187 		if code ^= 0 then do;
      188 		     call com_err_ (code, myname, "^a", arg);
      189 		     return;
      190 		end;
      191 		if temp_arg = "-msw" | temp_arg = "-message_switch" then message_switch = temp_ptr;
      192 		else if temp_arg = "-isw" | temp_arg = "-input_switch" then input_switch = temp_ptr;
      193 		else if temp_arg = "-osw" | temp_arg = "-output_switch" then printer_switch = temp_ptr;
      194 	     end;
      195 
      196 	     else do;
      197 		call com_err_ (error_table_$badopt, myname, "^a", arg);
      198 		return;
      199 	     end;
      200 	end;
      201 end_arg_processing:
      202 	if fnp_no = -1 then do;
      203 	     call com_err_ (error_table_$noarg, myname, "A FNP tag must be provided.");
      204 	     return;
      205 	end;
      206 
      207 	if message_switch = null then message_switch = iox_$user_output;
      208 	if printer_switch = null then printer_switch = iox_$user_output;
      209 	if input_switch = null then input_switch = iox_$user_input;
      210 
      211 
      212 	event_wait_list_n_channels = 1;
      213 	event_wait_list_ptr = addr (wait_list);
      214 	event_wait_list.channel_id (1) = 0;
      215 	event_wait_list.n_channels = 1;
      216 	loadsegptr = null;
      217 
      218 	on cleanup call clean_up;
      219 	on finish call clean_up;
      220 
      221 	call ipc_$create_ev_chn (event_wait_list.channel_id (1), code);
      222 	if code ^= 0 then do;
      223 	     call com_err_ (0, myname, "Could not create IPC channel");
      224 	     return;
      225 	end;
      226 	call get_temp_segment_ (myname, loadsegptr, code);
      227 	if code ^= 0 then do;
      228 	     call com_err_ (code, myname, "Getting FNP core load segment.");
      229 	     call clean_up;
      230 	     return;
      231 	end;
      232 
      233 	call hcs_$initiate (">system_control_1", "cdt", "", 0b, 0, cdtp, code);
      234 	if cdtp ^= null then do;			/* if user has access to the cdt */
      235 	     fnpep = addr (cdt.fnp_entry (fnp_no));	/* get ptr to fnp entry */
      236 	     fnp_type = fnpe.type;
      237 	     fnp_type_str = substr (fnp_types (fnp_type), 3);
      238 	     if fnp_type_str = "355" then fnp_type_str = "6600"; /* these are the same */
      239 	end;
      240 	else do;					/* user does not have access to cdt, we must ask
      241*						   him what kind of FNP he is trying to test */
      242 	     call ask_$ask_clr;
      243 	     call com_err_ (0, myname, "What is the FNP type of FNP ^a?", fnp_tag);
      244 	     ask_ans = "";
      245 	     do while (ask_ans = "");
      246 		call ask_ ("Answer DN6600, DN6670, DN355, or quit. ", ask_ans);
      247 		if ask_ans = "quit" then do;		/* user wants to forget it all */
      248 		     call clean_up;
      249 		     return;
      250 		end;
      251 		ask_ans = substr (ask_ans, 3);	/* forget about case of prefix, don't care */
      252 		if ask_ans = "355" then do;
      253 		     fnp_type_str = "6600";
      254 		     fnp_type = DN355;
      255 		end;
      256 		else if ask_ans = "6600" then do;
      257 		     fnp_type_str = "6600";
      258 		     fnp_type = DN6600;
      259 		end;
      260 		else if ask_ans = "6670" then do;
      261 		     fnp_type_str = "6670";
      262 		     fnp_type = DN6670;
      263 		end;
      264 		else ask_ans = "";
      265 	     end;
      266 	end;
      267 
      268 /* Now find the fnp test catalog record in the tandd_deck_file */
      269 
      270 	cata_key = "cata.fnp.pol." || fnp_type_str;
      271 
      272 	call tolts_util_$search (deck_iocbp, cata_key, module_listp, (0), code);
      273 	if code ^= 0 then do;
      274 	     call com_err_ (code, myname, "Unable to find catalog for ^a. Deckfile may be damaged.", cata_key);
      275 	     call clean_up;
      276 	     return;
      277 	end;
      278 
      279 	on linkage_error begin;
      280 	     call com_err_ (error_table_$moderr, myname,
      281 		"Access to the gate >sl1>tandd_ is required to use this program.");
      282 	     call clean_up;
      283 	     go to nlret;
      284 	end;
      285 	call tandd_$fnp_tandd_setup (fnp_no, event_wait_list.channel_id (1), code);
      286 	revert linkage_error;
      287 	if code ^= 0 then do;
      288 	     call com_err_ (code, myname, "Setting up T & D on FNP ^a.", fnp_tag);
      289 	     call clean_up;
      290 	     return;
      291 	end;
      292 
      293 
      294 /* Start the actual testing */
      295 
      296 	damage_85_86_flag = "0"b;
      297 	call tandd_$fnp_tandd_mask (fnp_no, code);
      298 	if code ^= 0 then do;
      299 	     call com_err_ (code, myname, "Issuing mask PCW to FNP ^a DIA.", fnp_tag);
      300 	     call clean_up;
      301 	     return;
      302 	end;
      303 	call find_and_send_required_module ("Interrupt and fault vectors", "95", "00000"b3);
      304 	call find_and_send_required_module ("Primitive function test 1", "96", "04000"b3);
      305 	call exchange_terminate_interrupts (code);
      306 	if code ^= 0 then call perm_fail ("Cannot start primitive function test 1");
      307 	call find_and_send_required_module ("Primitive function test 2", "97", "01000"b3);
      308 	call exchange_terminate_interrupts (code);
      309 	if code ^= 0 then call perm_fail ("Cannot start primitive function test 2");
      310 ldrs:	exec_in_fnp = "0"b;
      311 	call load_fnp_interrupt_vectors;
      312 	call load_required_module ("I/O package", "99");
      313 	if execname = "bos" then call load_required_module ("FNP BOS", "20");
      314 	else call load_required_module ("FNP IOS", "io");
      315 
      316 /* Wait for FNP to request service */
      317 	allow_pi = "0"b;
      318 	on program_interrupt begin;
      319 	     piflag = "1"b;
      320 	     if allow_pi then
      321 		call hcs_$wakeup (get_process_id_ (), event_wait_list.channel_id (1), 0, (0));
      322 	end;
      323 fnp_service_loop:
      324 	exec_in_fnp = "1"b;				/* Says where to shove card buffers */
      325 	allow_pi = "0"b;				/* No PI's yet */
      326 	call wait (7, 0, (0));			/* Wait for a level 7 */
      327 	call read_idb;				/* See what he wants */
      328 	if idb.request_code = 1 | idb.request_code = 3 then do; /* Write */
      329 	     bcd_array (*) = "17"b3;			/* Ignore */
      330 	     call read_fnp ((idb.fnp_address), (idb.tally), addr (bcd_array)); /* Read message */
      331 	     call tolts_util_$bci_to_ascii (bcdbuf, ascvar, idb.tally * 3);
      332 	     if idb.request_code = 1 then temp_ptr = message_switch;
      333 	     else do;
      334 		temp_ptr = printer_switch;
      335 		ascvar = ascvar || NL;
      336 	     end;
      337 	     call iox_$put_chars (temp_ptr, addrel (addr (ascvar), 1), length (ascvar), code);
      338 	     if code ^= 0 then do;
      339 		call com_err_ (code, myname, "Could not output msg to ^[message^;printer^] switch",
      340 		     idb.request_code = 1);
      341 	     end;
      342 	     call tandd_$fnp_tandd_send_int (fnp_no, 3, code);
      343 	     if code ^= 0 then
      344 		call com_err_ (code, myname, "Attempting to send level 3 after console/printer write.");
      345 	end;
      346 	else if idb.request_code = 2 then do;		/* Console read */
      347 	     call iox_$get_line (input_switch, addr (ascbuf), length (ascbuf), chars_gotten, code);
      348 	     if code ^= 0 then do;
      349 		call com_err_ (code, myname, "Error reading input switch.");
      350 		go to fnp_service_loop;
      351 	     end;
      352 	     if chars_gotten > 0 then
      353 		if substr (ascbuf, chars_gotten, 1) = NL then
      354 		     chars_gotten = chars_gotten - 1;
      355 	     ascvar = ltrim (substr (ascbuf, 1, chars_gotten));
      356 	     if rtrim (ascvar) = "QUIT" | rtrim (ascvar) = "quit"
      357 	     then call perm_fail ("Program aborted by user.");
      358 	     call tolts_alm_util_$ascii_to_bci_ ((ascvar), bcdbuf);
      359 	     if mod (idb.tally, 2) = 1 then substr (bcdbuf, 1 + 18 * idb.tally, 18) = "171717"b3;
      360 	     call write_fnp ((idb.fnp_address), (idb.tally), addr (bcdbuf));
      361 	     call tandd_$fnp_tandd_send_int (fnp_no, 3, code);
      362 	     if code ^= 0 then
      363 		call com_err_ (code, myname, "Attempting to send level 3 after console read");
      364 	end;
      365 	else if idb.request_code = 4 then do;		/* Load pgm */
      366 	     substr (bcdbuf, 1, 18) = bit (fixed (idb.tally, 18), 18);
      367 	     call tolts_util_$bci_to_ascii (substr (bcdbuf, 1, 12), ascvar, 2);
      368 	     if ascvar = "00" then ascvar = next_program ();
      369 	     if ascvar = "io" then do;
      370 		execname = "ios";
      371 		go to ldrs;
      372 	     end;
      373 	     else if ascvar = "20" then do;
      374 		execname = "bos";
      375 		go to ldrs;
      376 	     end;
      377 	     if ascvar = "85" | ascvar = "86" then do;
      378 		save_pgmname = ascvar;
      379 		exec_in_fnp = "0"b;
      380 		call load_fnp_interrupt_vectors;
      381 		damage_85_86_flag = "1"b;
      382 		ascvar = rtrim (save_pgmname);
      383 	     end;
      384 	     call load_program ((ascvar), code);
      385 	     if code ^= 0 then call com_err_ (code, myname, "Error loading ^a", ascvar);
      386 	end;
      387 	else call com_err_ (0, myname, "Unrecognized idb request code: ^d.^/IDB: ^w ^w ^w",
      388 	     idb.request_code, addr (idb) -> three_words);
      389 	go to fnp_service_loop;
      390 pi_person:
      391 	allow_pi = "0"b;
      392 	if damage_85_86_flag then do;
      393 	     call ask_$ask_clr;
      394 	     call com_err_ (0, myname, "Exec has been destroyed.");
      395 	     ask_ans = "";
      396 	     do while (ask_ans = "");
      397 		call ask_ ("Which exec (IOS or BOS) do you want? ", ask_ans);
      398 		if ask_ans = "QUIT" | ask_ans = "quit" then
      399 		     call perm_fail ("Program aborted by user.");
      400 		else if ask_ans = "IOS" then ask_ans = "ios";
      401 		else if ask_ans = "BOS" then ask_ans = "bos";
      402 		else ask_ans = "";
      403 	     end;
      404 	     execname = ask_ans;
      405 	     damage_85_86_flag = "0"b;
      406 	     go to ldrs;
      407 	end;
      408 	call tandd_$fnp_tandd_send_int (fnp_no, 7, code);
      409 	if code ^= 0 then call com_err_ (code, myname, "Attempting to send level 7 for request.");
      410 	go to fnp_service_loop;
      411 
      412 nlret:	return;					/* taget of non-local gotos */
      413 
      414 /* Necessary subroutines that do all the work */
      415 
      416 find_and_send_required_module: proc (a_description, a_testid, a_fnp_address);
      417 dcl  a_description char (*);
      418 dcl  a_testid char (2);
      419 dcl  a_fnp_address bit (15);
      420 dcl  moduleptr ptr;
      421 dcl  modullen fixed bin (15);
      422 
      423 	     call get_and_load_module (a_testid, moduleptr, modullen, code);
      424 	     if code ^= 0 then do;
      425 		call com_err_ (code, myname, "Cannot locate or load ^a", a_description);
      426 		call perm_fail ("Cannot send " || a_description);
      427 	     end;
      428 	     call write_fnp (fixed (a_fnp_address, 15), modullen, moduleptr);
      429 	end find_and_send_required_module;
      430 
      431 /* Send a level 3 to the FNP, and wait for one back. */
      432 
      433 exchange_terminate_interrupts: proc (a_code);
      434 dcl  a_code fixed bin (35);
      435 
      436 	     call tandd_$fnp_tandd_send_int (fnp_no, 3, a_code);
      437 
      438 	     if a_code ^= 0 then
      439 		call com_err_ (a_code, myname, "Could not send level 3 to FNP ^a.", fnp_tag);
      440 	     else call wait (3, 5, a_code);
      441 	end exchange_terminate_interrupts;
      442 
      443 /* Load FNP Interrupt vectors and loader */
      444 
      445 load_fnp_interrupt_vectors: proc;
      446 
      447 	     call write_fnp (bin ("62"b3, 15), 1, addr (fnp_interrupt_vector_word));
      448 	     loader_loaded = "0"b;
      449 	     call get_and_load_module ("98", moduleptr, modullen, code); /* Get loader */
      450 	     if code ^= 0 then do;
      451 		call com_err_ (code, myname, "Cannot get module 98 (FNP loader)");
      452 		call perm_fail ("");
      453 	     end;
      454 	     call write_fnp (bin ("01000"b3, 15), modullen, moduleptr);
      455 	     call tandd_$fnp_tandd_send_int (fnp_no, 3, code);
      456 	     if code ^= 0 then call perm_fail ("Could not send interrupt after loading interrupt vectors");
      457 	     loader_loaded = "1"b;
      458 	end load_fnp_interrupt_vectors;
      459 
      460 load_required_module: proc (exp, a_progname);
      461 dcl  exp char (*), a_progname char (2);
      462 	     call load_program (a_progname, code);
      463 	     if code ^= 0 then do;
      464 		call com_err_ (code, myname, "Cannot load ^a (^a), aborting", exp, a_progname);
      465 		go to nlret;
      466 	     end;
      467 	end load_required_module;
      468 
      469 load_program: proc (a_progname, a_code);
      470 
      471 dcl  count fixed bin (15);
      472 dcl  a_code fixed bin (35);
      473 dcl  a_progname char (2);
      474 dcl  fnp_address fixed bin (15);
      475 dcl  deck_ptr ptr;
      476 dcl  nextc fixed bin, nextcx fixed bin;
      477 
      478 	     call get_deck_ptr (a_progname, deck_ptr, a_code);
      479 	     if a_code ^= 0 then return;
      480 	     call core_load (deck_ptr, nextc, "1"b);	/* put deck +rcws in buffer */
      481 	     if exec_in_fnp then fnp_address = idb.fnp_address;
      482 	     else fnp_address = bin ("01500"b3, 15);
      483 	     do nextcx = 0 to nextc - 1 by 308;
      484 		count = min (308, nextc - nextcx);
      485 		call write_fnp (fnp_address, 2*count, ptr (loadsegptr, nextcx));
      486 		call exchange_terminate_interrupts (a_code);
      487 		if a_code ^= 0 then do;
      488 		     call com_err_ (a_code,
      489 			myname,
      490 			"FNP loader missed interrupt for ^a; aborting load.", a_progname);
      491 		     return;
      492 		end;
      493 	     end;
      494 	     a_code = 0;
      495 	     return;
      496 	end load_program;
      497 
      498 core_load: proc (a_deck_ptr, a_len, rcw_sw);
      499 
      500 dcl  a_deck_ptr ptr;
      501 dcl (a_len, nwds, ccl) fixed bin;
      502 dcl (eof, rcw_sw) bit (1);
      503 dcl  cc (ccl) bit (36) aligned based;
      504 
      505 	     call hcs_$truncate_seg (loadsegptr, 0, (0));
      506 	     a_len = 0;
      507 	     eof = "0"b;
      508 	     prptr = a_deck_ptr;			/* iterate through entire a_deck */
      509 	     do while (^eof);			/* and copy bin card images into temp seg */
      510 		lrptr = addr (gc_phy_rec.gc_phy_rec_data (1)); /* get pointer to first logical record */
      511 		nwds = 0;
      512 		do while (nwds < bcw.blk_size & ^eof);	/* iterate through all logical records */
      513 		     if rcw.media_code = 2 then	/* bcd card image */
      514 			if substr (gc_log_rec_bits, 1, 72) = bcd_dkend then /* dkend card */
      515 			     eof = "1"b;		/* thats it folks */
      516 			else;
      517 		     else if rcw.media_code = 1 then do; /* binary card image */
      518 			if rcw_sw then do;		/* if copying entire log rec.. */
      519 			     ccl = rcw.rsize + 1;	/* add in rcw also */
      520 			     ptr (loadsegptr, a_len) -> cc = lrptr -> cc; /* copy bin card image */
      521 			     a_len = a_len + ccl;
      522 			end;
      523 			else if gc_log_rec_data (1) ^= "000500000000"b3 then do; /* unless xfer card, copy core image */
      524 			     ccl = rcw.rsize - 1;	/* don't want sequence number */
      525 			     ptr (loadsegptr, a_len) -> cc = addr (gc_log_rec_data) -> cc;
      526 			     a_len = a_len + ccl;
      527 			end;
      528 		     end;
      529 		     nwds = nwds + rcw.rsize + 1;	/* increment number of words */
      530 		     lrptr = addrel (lrptr, currentsize (gc_log_rec)); /* set next logical record */
      531 		end;
      532 		prptr = addrel (prptr, currentsize (gc_phy_rec)); /* append next block */
      533 	     end;
      534 	     if ^rcw_sw then a_len = a_len * 2;		/* if  core image only... */
      535 
      536 	end core_load;
      537 
      538 read_fnp:	proc (a_fnpaddr, a_fnpcount, a_dataptr);
      539 
      540 dcl  a_fnpaddr fixed bin (15);
      541 dcl  a_fnpcount fixed bin (15);
      542 dcl  a_dataptr ptr;
      543 dcl  probe entry;
      544 
      545 	     if a_fnpcount > divide (length (unspec (bcdbuf)), 18, 18, 0)
      546 	     then do;
      547 		call com_err_ (0, myname, "Garbage fnp read count: ^d: calling probe.", a_fnpcount);
      548 		call probe;
      549 		return;
      550 	     end;
      551 	     call tandd_$fnp_tandd_read (fnp_no, a_dataptr, divide (1+ a_fnpcount, 2, 17, 0), a_fnpaddr, fnp_type, code);
      552 	     if code ^= 0 then do;
      553 		call com_err_ (code, myname, "Cannot read FNP ^a loc. ^o", fnp_tag, a_fnpaddr);
      554 		call perm_fail ("");
      555 	     end;
      556 	end read_fnp;
      557 
      558 write_fnp: proc (a_fnpaddr, a_fnpcount, a_dataptr);
      559 
      560 dcl  a_fnpaddr fixed bin (15);
      561 dcl  a_fnpcount fixed bin (15);
      562 dcl  a_dataptr ptr;
      563 
      564 	     call tandd_$fnp_tandd_write (fnp_no, a_dataptr, divide (1+ a_fnpcount, 2, 17, 0), a_fnpaddr, fnp_type, code);
      565 	     if code ^= 0 then do;
      566 		call com_err_ (code, myname, "Cannot write FNP ^a loc. ^o", fnp_tag, a_fnpaddr);
      567 		call perm_fail ("");
      568 	     end;
      569 	end write_fnp;
      570 
      571 read_idb:	proc ();
      572 
      573 	     call read_fnp (bin ("04004"b3, 15), 4, addr (idb));
      574 	end read_idb;
      575 
      576 
      577 wait:	proc (ilevel, interval, a_code);
      578 
      579 dcl  ilevel fixed bin, interval fixed bin, a_code fixed bin (35);
      580 dcl  crap (8) fixed bin;
      581 dcl  start fixed bin (71);
      582 dcl (l3_happened, l7_happened) bit (1);
      583 
      584 	     call get_int_status;
      585 	     if a_code ^= 0 then return;
      586 	     allow_pi = "1"b;
      587 	     piflag = "0"b;
      588 	     do while (^(needed_int () | piflag));
      589 		start = clock ();
      590 		if interval ^= 0 then
      591 		     call timer_manager_$alarm_wakeup ((interval), "11"b, event_wait_list.channel_id (1));
      592 		call ipc_$block (addr (event_wait_list), addr (crap), a_code);
      593 		if a_code ^= 0 then return;
      594 		call get_int_status;
      595 		if a_code ^= 0 then return;
      596 		if interval ^= 0 & ^piflag & ^needed_int () & (clock () - start) > 1000000 * interval then do;
      597 		     a_code = error_table_$timeout;
      598 		     return;
      599 		end;
      600 		if piflag then go to pi_person;
      601 	     end;
      602 	     allow_pi = "0"b;
      603 	     a_code = 0;
      604 	     return;
      605 
      606 get_int_status: proc;
      607 dcl  temp_ints bit (2) aligned;
      608 
      609 		call tandd_$fnp_tandd_get_ints (fnp_no, temp_ints, a_code);
      610 		if a_code ^= 0 then return;
      611 		l3_happened = substr (temp_ints, 1, 1);
      612 		l7_happened = substr (temp_ints, 2, 1);
      613 	     end get_int_status;
      614 
      615 needed_int:    proc returns (bit (1) aligned);
      616 
      617 		return ((l3_happened & (ilevel = 3))
      618 		     | (l7_happened & (ilevel = 7)));
      619 	     end needed_int;
      620 
      621 	end wait;
      622 
      623 get_and_load_module: proc (a_modulename, a_moduleptr, a_modullen, a_code);
      624 
      625 dcl  a_modulename char (2);
      626 dcl  a_moduleptr ptr;
      627 dcl  a_modullen fixed bin (15);
      628 dcl  modullen fixed bin;
      629 dcl  a_code fixed bin (35);
      630 dcl  deck_ptr ptr;
      631 
      632 	     call get_deck_ptr (a_modulename, deck_ptr, a_code);
      633 	     if a_code ^= 0 then return;
      634 	     call core_load (deck_ptr, modullen, "0"b);	/* go core load module */
      635 	     a_moduleptr = loadsegptr;
      636 	     a_modullen = modullen;
      637 	end get_and_load_module;
      638 
      639 
      640 next_program: proc returns (char (2));
      641 
      642 	     rx = rx + 1;				/* increment roving index */
      643 	     return (substr (reverse (before (reverse (module_list.name (rx)), ".")), 1, 2));
      644 	end next_program;
      645 
      646 
      647 get_deck_ptr: proc (a_modulename, a_deckptr, a_code);
      648 dcl  a_modulename char (*);
      649 dcl  a_deckptr ptr;
      650 dcl  a_code fixed bin (35);
      651 dcl (i, j) fixed bin;
      652 
      653 	     if rx = module_list.n then		/* if we are at the top */
      654 		j = 1;
      655 	     else j = rx;				/* start from rx and go forward */
      656 retry_search:
      657 	     do i = j to module_list.n;		/* go through entire catalog */
      658 		if a_modulename =
      659 		substr (reverse (before (reverse (module_list.name (i)), ".")), 1, 2) then do;
      660 		     rx = i;			/* set roving index */
      661 		     call tolts_util_$search (deck_iocbp, (module_list.name (i)), a_deckptr, (0), a_code);
      662 		     return;			/* we found it return */
      663 		end;
      664 	     end;
      665 	     if rx < module_list.n & rx ^= 1 then do;	/* if we started in middle, try again */
      666 		rx, j = 1;
      667 		go to retry_search;
      668 	     end;
      669 	     a_code = error_table_$noentry;		/* we didn't find it */
      670 	     a_deckptr = null;			/* return null ptr */
      671 	end get_deck_ptr;
      672 
      673 clean_up:	proc;
      674 	     on linkage_error go to cleanup_ret;
      675 	     call tandd_$fnp_tandd_detach (fnp_no, (0));
      676 	     revert linkage_error;
      677 cleanup_ret:
      678 	     if loadsegptr ^= null then
      679 		call release_temp_segment_ (myname, loadsegptr, (0));
      680 	     if event_wait_list.channel_id (1) ^= 0 then
      681 		call ipc_$delete_ev_chn (event_wait_list.channel_id (1), (0));
      682 	     if deck_iocbp ^= null then do;		/* if we have opened deckfile... */
      683 		call iox_$close (deck_iocbp, (0));	/* close and detach it */
      684 		call iox_$detach_iocb (deck_iocbp, (0));
      685 		deck_iocbp = null;
      686 	     end;
      687 
      688 	end clean_up;
      689 
      690 perm_fail:
      691 	proc (excuse);
      692 dcl  excuse char (*);
      693 	     call com_err_ (0, myname, "^a", excuse);
      694 	     call clean_up;
      695 	     go to nlret;
      696 	end perm_fail;
      697 
      698 
  1     1 /* BEGIN INCLUDE FILE ... cdt.incl.pl1 */
  1     2 
  1     3 /* format: style3,idind25,indcomtxt */
  1     4 
  1     5 /* Channel Definition Table.
  1     6*   This table lists all of the hardware channels (ports) connected
  1     7*   to the system, and maintains the attributes of each one.
  1     8*
  1     9*   PG 741230
  1    10*   Modified by Mike Grady 5/6/76 to add FNP info.
  1    11*   Modified by Tom Casey 7/29/76 to add more FNP info and a few other things.
  1    12*   Modified by Robert Coren 6/13/77 to make terminal types be character strings.
  1    13*   Modified July 1979 by T. Casey to add several variables for MR8.0 process preservation facility.
  1    14*   Modified December 1980 by E. N. Kittlitz to eliminate cdte.phone_no.
  1    15*   Modified March 1981 by Robert Coren to add "listening" flag for multiplexers and to add TANDD_SERVICE service_type.
  1    16*   Modified April 1981 by E. N. Kittlitz to add cdte.dial_ev_chn, cdte.recent_wakeup_time, cdte.recent_wakeup_count.
  1    17*   Modified July 1981 by T. Casey for MR9.0 to add dialup_flags.detach_after_hangup
  1    18*   Modified December 1981 by E. N. Kittlitz for cdte.leave_edited, cdte.hold_arg,
  1    19*   Modified September 1981 by Benson I. Margulies for cdt_mgr_'s tree of multiplexer's.
  1    20*   Modified August 1982 by E. N. Kittlitz for check_acs.
  1    21*   Modified January 1983 by Keith Loepere for generic_destination.
  1    22*   Modified August 1983 by Robert Coren to add mpxe.check and mpxe.retry_load.
  1    23*   Modified 831216 by E. N. Kittlitz for required_access_class.
  1    24*   Modified 84-04-01 by BIM to finish communications AIM:
  1    25*   access class ranges,
  1    26*   access_control flags.
  1    27**/
  1    28 
  1    29 
  1    30 /****^  HISTORY COMMENTS:
  1    31*  1) change(87-03-17,Beattie), approve(87-04-06,MCR7656),
  1    32*     audit(87-07-13,Parisek), install(87-08-04,MR12.1-1056):
  1    33*     Add support for answering service to use IOCBs when tty_ cannot be
  1    34*     used to service login channels.
  1    35*                                                   END HISTORY COMMENTS */
  1    36 
  1    37 
  1    38 dcl	CDT_version_5	     fixed bin internal static initial (5) options (constant);
  1    39 dcl	CDT_version	     fixed bin internal static initial (6) options (constant);
  1    40 
  1    41 dcl	(cdtp, cdtep, fnpep, mpxep)
  1    42 			     ptr;
  1    43 
  1    44 dcl	1 cdt		     based (cdtp) aligned,	/* all of the system channels */
  1    45 	  2 author	     like author_dcl.author,	/* standard header */
  1    46 	  2 max_size	     fixed bin,		/* maximum number of cdte's in 255K */
  1    47 	  2 current_size	     fixed bin,		/* number of last cdte. */
  1    48 	  2 version	     fixed bin,
  1    49 	  2 freep		     fixed bin,		/* chain of free cdte's */
  1    50 	  2 n_cdtes	     fixed bin,		/* number of used cdte's */
  1    51 	  2 meters_last_reset    fixed bin (71),	/* clock time dialup meters were reset */
  1    52 	  2 realtime_in_dialup   fixed bin (71),	/* Dialup meter */
  1    53 	  2 cpu_in_dialup	     fixed bin (71),	/* .. */
  1    54 	  2 pf_in_dialup	     fixed bin,		/* .. */
  1    55 	  2 pp_in_dialup	     fixed bin,		/* .. */
  1    56 	  2 entries_to_dialup    fixed bin,		/* .. */
  1    57 	  2 flags,
  1    58 	    3 go		     bit (1) unal,		/* ans. serv. said "go ahead and answer the phones" */
  1    59 	    3 cdt_is_live	     bit (1) unal,		/* cdt is active */
  1    60 	    3 mux_mgr_system_init
  1    61 			     bit (1) unal,		/* mux mgr has loaded top-levels */
  1    62 	    3 pad1	     bit (33) unal,
  1    63 	  2 acceptable_fnp_tbf   fixed bin,		/* acceptable minutes between FNP crashes */
  1    64 	  2 spare_channel_count  fixed bin,		/* number of extra channels to leave room for in ring0 */
  1    65 	  2 threads	     aligned like channel_threads,
  1    66 						/* root of non-fnp-top-level-multiplexers */
  1    67 	  2 pad2		     (31) bit (36) aligned,	/* pad header to 80 words */
  1    68 	  2 fnp_entry	     dim (8) like fnpe,	/* max of 8 FNPs for now */
  1    69 	  2 cdt_entry	     dim (2500) like cdte;	/* # of cdte's in 255K */
  1    70 
  1    71 
  1    72 dcl	1 cdte		     based (cdtep) aligned,	/* a channel */
  1    73 	  2 in_use	     fixed bin,		/* see dialup_values. 0=NOW_FREE */
  1    74 /**** * These variables are filled in when the CDTE is created by cv_cmf. They are not dynamic. */
  1    75 	  2 pad1		     bit (36) aligned,
  1    76 	  2 name		     char (32),		/* ASCII name of channel */
  1    77 	  2 access_class	     (2) bit (72) aligned,	/* access class range */
  1    78 	  2 comment	     char (48),		/* printable message about channel */
  1    79 	  2 charge_type	     fixed bin (17) unal,	/* billing group */
  1    80 	  2 service_type	     fixed bin (17) unal,	/* service group (AS, ftp, mc) */
  1    81 	  2 line_type	     fixed bin (17) unal,	/* tty line type (protocol) */
  1    82 	  2 baud_rate	     fixed bin (17) unal,	/* 110, 133, 150, etc. */
  1    83 	  2 modem_type	     fixed bin (17) unal,	/* type of modem on this channel */
  1    84 	  2 pad2		     bit (18) unaligned,
  1    85 	  2 answerback	     char (8),		/* answerback string expected */
  1    86 	  2 initial_terminal_type
  1    87 			     char (32) unal,	/* as specified in the CMF */
  1    88 	  2 mpx_data	     unal,		/* data used only for multiplexed channels */
  1    89 	    3 mpx_type	     fixed bin (17),	/* type of multiplexing used */
  1    90 	    3 mpx_service	     fixed bin (17),	/* service type, active or inactive */
  1    91 	  2 flags,
  1    92 	  ( 3 attributes,
  1    93 	      4 ck_answerback    bit (1),		/* ON means that ansbk must equal our records */
  1    94 	      4 audit_access_error
  1    95 			     bit (1),		/* ON means ck that person auth is inside access class range  */
  1    96 						/*    this implies that the access_class describes a range of
  1    97*						   legitimate user auths. */
  1    98 	      4 hardwired	     bit (1),		/* ON means it is */
  1    99 	      4 set_modes	     bit (1),		/* ON means to set initial modes at dialup */
  1   100 	      4 dont_read_answerback
  1   101 			     bit (1),		/* ON means don't try to read answerback */
  1   102 	      4 pada	     bit (4),
  1   103 	    3 access_control     unaligned,		/* As below */
  1   104 	      4 dial_out	     bit (1),		/* dialing user must be on ACS */
  1   105 	      4 priv_attach	     bit (1),		/* PA_ user must be on ACS */
  1   106 	      4 dial_server	     bit (1),		/* accept_dials process must be on acs */
  1   107 	      4 login	     bit (1),		/* logging in user must be on acs */
  1   108 	      4 slave_dial	     bit (1),		/* dialing user must give -user and be on acs */
  1   109 	      4 pado	     bit (3),
  1   110 	    3 options,
  1   111 	      4 execute_initial_command
  1   112 			     bit (1),		/* ON means to do it */
  1   113 	      4 attached_by_operator
  1   114 			     bit (1),		/* ON means temporary attachment. */
  1   115 	      4 private_line     bit (1),		/* ON means private_line sync modem in use */
  1   116 	      4 bsc_ebcdic	     bit (1),		/* ON means bsc would like to use ebcdic code set */
  1   117 	      4 bsc_transparent  bit (1),		/* ON means bsc is in transparent mode */
  1   118 	      4 vip_pollselect   bit (1),		/* ON means VIP line is multidrop */
  1   119 	      4 autobaud	     bit (1),		/* ON means auto baud detection this channel */
  1   120 	      4 generic_destination_present
  1   121 			     bit (1),		/* ON means that the initial_command field contains
  1   122*						   a generic destination to match on dial_out or priv attach */
  1   123 	      4 use_iocb	     bit (1),		/* ON means to use IOCB operations to support channel */
  1   124 	      4 pado	     bit (9)
  1   125 	      )		     unaligned,
  1   126 	  2 initial_command	     char (64),		/* pseudo first input line */
  1   127 /**** The following variables represent dynamic control info, and
  1   128*      are used mostly by dialup_ and asu_ */
  1   129 	  2 event		     fixed bin (71),	/* event call channel for channel events */
  1   130 	  2 current_service_type fixed bin (17) unal,	/* Current usage of line. */
  1   131 	  2 tra_vec	     fixed bin (17) unal,	/* which section of dialup_ to do next */
  1   132 	  2 count		     fixed bin (17) unal,	/* How many login tries he's had. */
  1   133 	  2 dialup_flags	     unal,		/* flag bits for dialup to maintain */
  1   134 	    3 ppm		     bit (1) unal,		/* print preaccess message for IBM terminals */
  1   135 	    3 cpo		     bit (1) unal,		/* conditional printer-off (depends on answerback */
  1   136 	    3 wakeup_handler     bit (1) unal,		/* says who is wakeup handler for this channel */
  1   137 						/* 0 = dialup_, 1 = mc_tty_ */
  1   138 	    3 save_arg	     bit (1) unal,		/* -save login arg given */
  1   139 	    3 nosave_arg	     bit (1) unal,		/* -nosave login arg given */
  1   140 	    3 detach_after_hangup
  1   141 			     bit (1) unal,		/* remember WAIT_DETACH when setting WAIT_BEFORE_HANGUP */
  1   142 	    3 leave_edited	     bit (1) unal,		/* user control of edited mode */
  1   143 	    3 hold_arg	     bit (1) unal,		/* -hold arg given */
  1   144 	    3 no_hold_arg	     bit (1) unal,		/* -no_hold arg given */
  1   145 	    3 immediate_arg	     bit (1) unal,		/* -immediate arg given */
  1   146 	    3 current_access_class_valid
  1   147 			     bit (1) unal,		/* dialup_ or lg_ctl_ has determined the current_access_class */
  1   148 	    3 pad		     bit (7) unal,
  1   149 	  2 twx		     fixed bin,		/* channel device index */
  1   150 	  2 state		     fixed bin,		/* channel state */
  1   151 	  2 tty_id_code	     char (4),		/* channel id (answerback) */
  1   152 	  2 current_terminal_type
  1   153 			     char (32) unal,	/* most recently-set terminal type */
  1   154 	  2 process	     ptr unal,		/* ptr to ATE owning this channel */
  1   155 	  2 dialed_to_procid     bit (36),		/* Dialed channels remember owner's proc id */
  1   156 	  2 next_channel	     fixed bin (17) unal,	/* cdte index of next channel for this process */
  1   157 	  2 cur_line_type	     fixed bin (17) unal,	/* line type of currently dialed terminal */
  1   158 	  2 current_access_class (2) bit (72) aligned,	/* This is a range, but at this time it must be a null range.
  1   159*						   We do not yet define multi-class connections, but we will someday. */
  1   160 	  2 disconnected_ate_index
  1   161 			     fixed bin (17) unal,	/* index of ate of disconnected process */
  1   162 	  2 dial_ctl_ring	     fixed bin (3) unsigned unaligned,
  1   163 						/* used by dial_ctl_ to record ring of priv_attach or dial_out attachments */
  1   164 	  2 dial_rq_privileged   bit (1) unaligned,	/* used by dial ctl to record comm priv from priv_attach or dial_out request */
  1   165 	  2 pad3		     bit (14) unaligned,
  1   166 /**** The following variables are kept for metering purposes. */
  1   167 	  2 n_dialups	     fixed bin,		/* number of times channel has been dialed up */
  1   168 	  2 n_logins	     fixed bin,		/* number of login sessions on this channel */
  1   169 	  2 dialed_up_time	     fixed bin (35),	/* total time channel was dialed up (seconds) */
  1   170 	  2 dialup_time	     fixed bin (71),	/* time of present dialup */
  1   171 	  2 disconnected_proc_command
  1   172 			     fixed bin (12) unsigned unal,
  1   173 						/* 1 to 5 for -list,-create,-connect,-new_proc,-destroy */
  1   174 	  2 disconnected_proc_number
  1   175 			     fixed bin (12) unsigned unal,
  1   176 						/* {N} in -connect {N}, -new_proc {N}, -destroy {N} */
  1   177 	  2 n_disconnected_procs fixed bin (12) unsigned unal,
  1   178 						/* number of disconnected processes that user has */
  1   179 	  2 recent_wakeup_count  fixed bin,		/* counter to detect channel wakeup loop */
  1   180 	  2 recent_wakeup_time   fixed bin (71),	/* time of first wakeup in suspected channel wakeup loop */
  1   181 	  2 dial_ev_chn	     fixed bin (71),	/* Dialed channels remember master's IPC channel */
  1   182 /**** cdt_mgr_ uses these to maintain the tree of channels. They ****/
  1   183 /**** really belong in the mpxe, but it is full up, and the cdte ****/
  1   184 /**** had the space. */
  1   185 	  2 threads	     aligned like channel_threads,
  1   186 /**** The use name is that of the user who gave the dial or slave ****/
  1   187 /**** preaccess request. ****/
  1   188 	  2 user_name	     unaligned,
  1   189 	    3 person	     char (20) unaligned,
  1   190 	    3 project	     char (9) unaligned,
  1   191 	    3 pad		     char (3) unaligned,	/* no tag */
  1   192 	  2 iocbp		     ptr unaligned;		/* 104 words */
  1   193 
  1   194 
  1   195 dcl	generic_destination	     based char (32);	/* used to match destinations on dial_out and priv_attach,
  1   196*						   overlays initial_command field for slave and autocall lines */
  1   197 
  1   198 
  1   199 
  1   200 dcl	1 fnpe		     based (fnpep) aligned,	/* an FNP */
  1   201 						/* These variables are filled in from the CMF */
  1   202 	  2 type		     fixed bin,		/* type of this FNP, DN355, DN6670, etc. */
  1   203 	  2 memory	     fixed bin,		/* amount of memory on this FNP */
  1   204 	  2 nlslas	     fixed bin,		/* number of lslas on this FNP */
  1   205 	  2 nhslas	     fixed bin,		/* number of hslas on this FNP */
  1   206 	  2 service_type	     fixed bin,		/* service type */
  1   207 	  2 mpx_type	     fixed bin,		/* type of multiplexer on this fnp */
  1   208 	  2 coreimage	     char (168),		/* pathname of image, maybe in >sl1 */
  1   209 /**** The following are used during system operation to remember the state of the FNP */
  1   210 	  2 boot_segp	     ptr,			/* ptr to seg used for bootload */
  1   211 	  2 boot_ev_chan	     fixed bin (71),	/* for ring0 to report crashes and bootload complete */
  1   212 	  2 mpxe		     like mpxe,		/* standard multiplexer data */
  1   213 	  2 threads	     aligned like channel_threads,
  1   214 						/* same mpx threads as channel */
  1   215 	  2 pad3		     (25) fixed bin;	/* pad to 96 words per entry */
  1   216 
  1   217 /* This structure describes the data necessary to control a multiplexer.
  1   218*   For FNP's., a copy appears in the fnpe. For communications lines, it
  1   219*   overlays the initial_command field in the cdte. */
  1   220 
  1   221 dcl	1 mpxe		     based (mpxep) aligned,
  1   222 	  2 state		     fixed bin,		/* current state, up, down, loading */
  1   223 	  2 current_service_type fixed bin,		/* usually = service type, unless cdt installation changes it */
  1   224 	  2 current_mpx_type     fixed bin,		/* type of multiplexer currently running */
  1   225 	  2 n_bootloads	     fixed bin,		/* count of load attempts */
  1   226 	  2 time_initial_load    fixed bin (71),	/* time this MPX first completed a load */
  1   227 	  2 time_last_load	     fixed bin (71),	/* time MPX last completed a bootload */
  1   228 	  2 time_last_crash	     fixed bin (71),	/* time MPX last crashed */
  1   229 	  2 time_load_start	     fixed bin (71),	/* time current load started */
  1   230 	  2 last_tbf	     fixed bin,		/* number of minutes this MPX was up last bootload */
  1   231 	  2 flags		     unal,
  1   232 	    3 go		     bit (1),		/* start MPX after it loads */
  1   233 	    3 listening	     bit (1),		/* listen has been done on subchannels */
  1   234 	    3 check	     bit (1),		/* loaded with check option */
  1   235 	    3 retry_load	     bit (1),		/* reload if load fails */
  1   236 	    3 pad1	     bit (32),
  1   237 	  2 pad2		     (2) fixed bin;		/* pad to 16 words */
  1   238 
  1   239 /* These threads define the tree of multiplexers in the cdt. */
  1   240 /* next_sister and prev_sister link nodes at the same level, ordered */
  1   241 /* by alpha sort order of the channel name. Daughter points to the */
  1   242 /* first child of this node, if any. Daughter count is the number */
  1   243 /* of children, as a consistency check. Mother is a back pointer to */
  1   244 /* the parent, present in all the children, not just the first. */
  1   245 /* threads are cdt indexes. If positive, they index the cdt_entry array */
  1   246 /* in cdt, if negative, they are the negative of an index into the fnp_entry */
  1   247 /* array. If zero, they refer to the top of the non-fnp mpx tree. */
  1   248 
  1   249 dcl	1 channel_threads	     aligned based,
  1   250 	  2 next_sister	     fixed bin unaligned,
  1   251 	  2 prev_sister	     fixed bin unaligned,
  1   252 	  2 daughter	     fixed bin unaligned,
  1   253 	  2 mother	     fixed bin unaligned,	/* negative is a fnpx, positive a cdtx */
  1   254 	  2 pad		     bit (18) unaligned,
  1   255 	  2 daughter_count	     fixed bin unaligned;
  1   256 
  1   257 /* Values for cdte.service_type field */
  1   258 
  1   259 dcl	(
  1   260 	ANS_SERVICE	     init (1),		/* login or dial */
  1   261 	FTP_SERVICE	     init (2),		/* file transfer service */
  1   262 	MC_SERVICE	     init (3),		/* message coordinator */
  1   263 	SLAVE_SERVICE	     init (4),		/* special channel */
  1   264 	DIAL_SERVICE	     init (5),		/* transient state */
  1   265 	DIAL_OUT_SERVICE	     init (6),		/* auto call line */
  1   266 	MPX_SERVICE	     init (8),		/* ring0 demultiplexed line */
  1   267 	TANDD_SERVICE	     init (9)		/* transient state, attached for T & D */
  1   268 	)		     fixed bin internal static options (constant);
  1   269 
  1   270 /* Values for service type in both cdte and fnpe */
  1   271 
  1   272 dcl	(
  1   273 	INACTIVE		     init (7),		/* not to be used, even though configured */
  1   274 	ACTIVE		     init (1)
  1   275 	) /* for FNP only, configured and to be used */
  1   276 			     fixed bin internal static options (constant);
  1   277 
  1   278 /* Value for both cdte.in_use and fnpe.state */
  1   279 
  1   280 dcl	NOT_CONFIGURED	     fixed bin int static init (-1) options (constant);
  1   281 						/* was not configured at Multics bootload time */
  1   282 
  1   283 /* NOTE: an INACTIVE channel can be made active by operator command or CDT installation,
  1   284*   but a NOT_CONFIGURED channel can not be used until its multiplexer is reloaded */
  1   285 
  1   286 /* Value for cdte.in_use */
  1   287 
  1   288 dcl	CHANNEL_DELETED	     fixed bin int static init (-2);
  1   289 						/* channel deleted by CDT installation */
  1   290 
  1   291 /* NOTE: a configured channel being deleted by a CDT installation is set to CHANNEL_DELETED.
  1   292*   multiplexer_mgr_ sets cdte.in_use to NOW_FREE at the next reload of its multiplexer.
  1   293*   A NOT_CONFIGURED channel is set to NOW_FREE immediately when deleted by a CDT installation. */
  1   294 
  1   295 
  1   296 /* Values for mpxe.state field */
  1   297 
  1   298 dcl	(
  1   299 	FNP_FREE		     init (0),		/* this fnpe is not used */
  1   300 	FNP_UNKNOWN	     init (1),		/* FNP is in some unknown state */
  1   301 	FNP_DOWN		     init (2),		/* FNP crashed, not yet reloaded */
  1   302 	FNP_BOOT		     init (3),		/* FNP has been booted, but no response yet */
  1   303 	FNP_UP		     init (4)		/* FNP is up and running fine */
  1   304 	)		     fixed bin internal static options (constant);
  1   305 
  1   306 dcl	(
  1   307 	MPX_FREE		     init (0),		/* this mpxe is not used */
  1   308 	MPX_UNKNOWN	     init (1),		/* MPX is in some unknown state */
  1   309 	MPX_DOWN		     init (2),		/* MPX crashed, not yet reloaded */
  1   310 	MPX_BOOT		     init (3),		/* MPX has been booted, but no response yet */
  1   311 	MPX_UP		     init (4)		/* MPX is up and running fine */
  1   312 	)		     fixed bin internal static options (constant);
  1   313 
  2     1 /* BEGIN INCLUDE FILE ... fnp_types.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  2     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  2     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  2     9*     implementation.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /* Values for fnpe.type field */
  2    14 /*
  2    15*   Created 79 May 14 by Art Beattie by splitting information out from cdt.incl.pl1
  2    16*   Added in March 1982 - DN7100.fd.
  2    17**/
  2    18 
  2    19 dcl (DN355 init (1),				/* a DataNet 355 FNP */
  2    20      DN6600 init (2),				/* a DataNet 6600 FNP */
  2    21      DN6670 init (3),				/* a Honeywell Bull Network Processor (18x) */
  2    22      DN7100 init (4)				/* The DSA Datanet architecture (DN7) */
  2    23      ) fixed bin internal static options (constant);
  2    24 
  2    25 dcl  fnp_types (4) char (8) int static options (constant)
  2    26      init ("DN355", "DN6600", "DN6670", "DN7100");
  2    27 
  2    28 dcl  fnp_models (4) fixed bin (17) int static options (constant)
  2    29      init (355, 6600, 6670, 7100);
  2    30 	
  2    31 dcl  supported_fnp (4) bit (1) int static options (constant)
  2    32      init ("0"b, "0"b, "1"b, "1"b);
  2    33 
  2    34 
  2    35 /* END INCLUDE FILE ... fnp_types.incl.pl1 */
  1   314 
  1   315 
  1   316 /* END INCLUDE FILE ... cdt.incl.pl1 */
      699 
  3     1 /* BEGIN INCLUDE FILE ... author_dcl.incl.pl1 */
  3     2 
  3     3 /* This include file declares the "author" substructure
  3     4*   in a form suitable for using the PL/I "like" attribute.
  3     5*
  3     6*   Written 750304 by PG
  3     7**/
  3     8 
  3     9 dcl 1 author_dcl aligned based,
  4     1 /* BEGIN INCLUDE FILE author.incl.pl1 */
  4     2 
  4     3 /* the "author" items must always be the first ones in the table. The
  4     4*   module which moves the converted table to the System Control process
  4     5*   fills in these data items and assumes them to be at the head of the segment
  4     6*   regardless of the specific table's actual declaration. The variables
  4     7*   "lock" and "last_install_time" used to be "process_id" and "ev_channel"
  4     8*    respectively. For tables installed in multiple processes, these
  4     9*    are to be used to lock out multiple installations. */
  4    10 
  4    11 /*  Lock should be used as a modification lock. Since, in general,
  4    12*    entries may not be moved in system tables, even by installations,
  4    13*    it is sufficient for only installers and programs that change threads
  4    14*    to set or respect the lock. Simply updating data in an entry
  4    15*    requires no such protection.
  4    16*
  4    17*    Last_install_time is used by readers of system tables to detect
  4    18*    installations or other serious modifications. By checking it before
  4    19*    and after copying a block of data, they can be protected against
  4    20*    modifications.
  4    21*
  4    22*    Modules that set the lock should save proc_group_id, and then
  4    23*    put their group id there for the time they hold the lock.
  4    24*    if they do not actually install the, they should restore the group id.
  4    25**/
  4    26 
  4    27     2 author aligned,				/* validation data about table's author */
  4    28       3 proc_group_id char (32),			/* process-group-id  (personid.projectid.tag) */
  4    29       3 lock bit (36),				/* installation lock */
  4    30       3 update_attributes bit (1) unal,			/* update/add/delete attributes */
  4    31       3 update_authorization bit (1) unal,		/* update only authorizations */
  4    32       3 deferral_notified bit (1) unal,			/* installer notified of deferral of installation */
  4    33       3 pad bit (33) unaligned,
  4    34       3 last_install_time fixed bin (71),
  4    35       3 table char (4),				/* name of table, e.g., SAT MGT TTT RTDT PDT etc. */
  4    36       3 w_dir char (64),				/* author's working directory */
  4    37 
  4    38 /* END INCLUDE FILE author.incl.pl1 */
  3    10 
  3    11     2 pad;
  3    12 
  3    13 /* END INCLUDE FILE ... author_dcl.incl.pl1 */
      700 
  5     1 /* BEGIN INCLUDE FILE ... event_wait_list.incl.pl1 */
  5     2 
  5     3 /* ipc_$block wait list structure -- Must begin on an even word boundary.
  5     4*
  5     5*   Written 9-May-79 by M. N. Davidoff.
  5     6**/
  5     7 
  5     8      declare event_wait_list_n_channels
  5     9 			      fixed binary;
  5    10      declare event_wait_list_ptr    pointer;
  5    11 
  5    12      declare 1 event_wait_list      aligned based (event_wait_list_ptr),
  5    13 	     2 n_channels	      fixed binary,		/* number of channels in wait list */
  5    14 	     2 pad	      bit (36),
  5    15 	     2 channel_id	      (event_wait_list_n_channels refer (event_wait_list.n_channels)) fixed binary (71);
  5    16 						/* event channels to wait on */
  5    17 
  5    18 /* END INCLUDE FILE ... event_wait_list.incl.pl1 */
      701 
  6     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
  6     2 
  6     3 /* T. Casey, May 1978 */
  6     4 
  6     5 dcl  event_wait_info_ptr ptr;
  6     6 
  6     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
  6     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
  6     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
  6    10     2 sender bit (36),				/* process id of sender */
  6    11     2 origin,
  6    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
  6    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
  6    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
  6    15 
  6    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
      702 
  7     1 
  7     2 /* BEGIN INCLUDE FILE: gcos_ssf_records.incl.pl1 */
  7     3 
  7     4 /* Created by J. A. Bush 05/07/80 */
  7     5 
  7     6 dcl  prptr ptr;					/* GCOS physical record pointer */
  7     7 dcl  lrptr ptr;					/* GCOS logical record pointer */
  7     8 
  7     9 dcl 1 gc_phy_rec based (prptr) aligned,			/* GCOS ssf format (physical record) */
  7    10     2 bcw unaligned,				/* block control word */
  7    11      (3 bsn fixed bin (18),				/* block serial number */
  7    12       3 blk_size fixed bin (18)) unsigned,		/* block size (-bcw) */
  7    13     2 gc_phy_rec_data (0 refer (gc_phy_rec.bcw.blk_size)) bit (36);
  7    14 
  7    15 dcl 1 gc_log_rec based (lrptr) aligned,			/* GCOS ssf logical record format */
  7    16     2 rcw unaligned,				/* record control word */
  7    17      (3 rsize fixed bin (18),				/* size of rcd (-rcw) */
  7    18       3 nchar_used fixed bin (2),			/* characters used in last word */
  7    19       3 file_mark fixed bin (4),			/* file mark if rsize = 0 */
  7    20       3 mbz1 fixed bin (2),
  7    21       3 media_code fixed bin (4),			/* file media code */
  7    22       3 report_code fixed bin (6)) unsigned,		/* report code */
  7    23     2 gc_log_rec_data (0 refer (gc_log_rec.rcw.rsize)) bit (36); /* logical record data */
  7    24 
  7    25 dcl  gc_phy_rec_bits bit (gc_phy_rec.bcw.blk_size * 36) based (addr (gc_phy_rec.gc_phy_rec_data));
  7    26 dcl  gc_log_rec_bits bit (gc_log_rec.rcw.rsize * 36) based (addr (gc_log_rec.gc_log_rec_data));
  7    27 
  7    28 /* END INCLUDE FILE: gcos_ssf_records.incl.pl1 */
      703 
      704 
      705      end test_fnp;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1537.0  test_fnp.pl1                      >special_ldd>install>MR12.2-1061>test_fnp.pl1
699          1    08/06/87  0913.0  cdt.incl.pl1                      >ldd>include>cdt.incl.pl1
1-314        2    07/19/88  1524.1  fnp_types.incl.pl1                >special_ldd>install>MR12.2-1061>fnp_types.incl.pl1
700          3    09/09/75  2007.3  author_dcl.incl.pl1               >ldd>include>author_dcl.incl.pl1
3-10         4    04/21/82  1211.8  author.incl.pl1                   >ldd>include>author.incl.pl1
701          5    06/29/79  1728.0  event_wait_list.incl.pl1          >ldd>include>event_wait_list.incl.pl1
702          6    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
703          7    03/27/82  0437.1  gcos_ssf_records.incl.pl1         >ldd>include>gcos_ssf_records.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DN355                                  constant        fixed bin(17,0)          initial dcl 2-19 ref 254
DN6600                                 constant        fixed bin(17,0)          initial dcl 2-19 ref 258
DN6670                                 constant        fixed bin(17,0)          initial dcl 2-19 ref 262
NL                              006622 constant        char(1)                  initial packed unaligned dcl 94 ref 335 352
a_code                                 parameter       fixed bin(35,0)          dcl 434 in procedure "exchange_terminate_interrupts"
                                                                                  set ref 433 436* 438 438* 440*
a_code                                 parameter       fixed bin(35,0)          dcl 472 in procedure "load_program" set ref 469 478*
                                                                                  479 486* 487 488* 494*
a_code                                 parameter       fixed bin(35,0)          dcl 650 in procedure "get_deck_ptr" set ref 647 661*
                                                                                  669*
a_code                                 parameter       fixed bin(35,0)          dcl 629 in procedure "get_and_load_module" set ref
                                                                                  623 632* 633
a_code                                 parameter       fixed bin(35,0)          dcl 579 in procedure "wait" set ref 577 585 592* 593
                                                                                  595 597* 603* 609* 610
a_dataptr                              parameter       pointer                  dcl 562 in procedure "write_fnp" set ref 558 564*
a_dataptr                              parameter       pointer                  dcl 542 in procedure "read_fnp" set ref 538 551*
a_deck_ptr                             parameter       pointer                  dcl 500 ref 498 508
a_deckptr                              parameter       pointer                  dcl 649 set ref 647 661* 670*
a_description                          parameter       char                     packed unaligned dcl 417 set ref 416 425* 426
a_fnp_address                          parameter       bit(15)                  packed unaligned dcl 419 ref 416 428 428
a_fnpaddr                              parameter       fixed bin(15,0)          dcl 540 in procedure "read_fnp" set ref 538 551*
                                                                                  553*
a_fnpaddr                              parameter       fixed bin(15,0)          dcl 560 in procedure "write_fnp" set ref 558 564*
                                                                                  566*
a_fnpcount                             parameter       fixed bin(15,0)          dcl 541 in procedure "read_fnp" set ref 538 545 547*
                                                                                  551 551
a_fnpcount                             parameter       fixed bin(15,0)          dcl 561 in procedure "write_fnp" ref 558 564 564
a_len                                  parameter       fixed bin(17,0)          dcl 501 set ref 498 506* 520 521* 521 525 526* 526
                                                                                  534* 534
a_modulename                           parameter       char(2)                  packed unaligned dcl 625 in procedure
                                                                                  "get_and_load_module" set ref 623 632*
a_modulename                           parameter       char                     packed unaligned dcl 648 in procedure "get_deck_ptr"
                                                                                  ref 647 658
a_moduleptr                            parameter       pointer                  dcl 626 set ref 623 635*
a_modullen                             parameter       fixed bin(15,0)          dcl 627 set ref 623 636*
a_progname                             parameter       char(2)                  packed unaligned dcl 473 in procedure "load_program"
                                                                                  set ref 469 478* 488*
a_progname                             parameter       char(2)                  packed unaligned dcl 461 in procedure
                                                                                  "load_required_module" set ref 460 462* 464*
a_testid                               parameter       char(2)                  packed unaligned dcl 418 set ref 416 423*
addr                                                   builtin function         dcl 133 ref 213 235 329 330 330 330 330 337 337 347
                                                                                  347 360 360 387 447 447 510 513 525 573 573 592
                                                                                  592 592 592
addrel                                                 builtin function         dcl 133 ref 337 337 530 532
allow_pi                        000106 automatic       bit(1)                   packed unaligned dcl 60 set ref 317* 320 325* 390*
                                                                                  586* 602*
arg                                    based           char                     packed unaligned dcl 100 set ref 144 149 150 155*
                                                                                  159 166 167 168 169 175 175 175 175 175 175 179
                                                                                  186* 188* 197*
arglen                          000426 automatic       fixed bin(17,0)          dcl 77 set ref 142* 144 149 150 155 155 159 161* 166
                                                                                  167 168 169 175 175 175 175 175 175 179 181* 186
                                                                                  186 188 188 197 197
argno                           000425 automatic       fixed bin(17,0)          dcl 76 set ref 141* 142* 160* 160 161* 180* 180 181*
argp                            000434 automatic       pointer                  dcl 82 set ref 142* 144 149 150 155 159 161* 166 167
                                                                                  168 169 175 175 175 175 175 175 179 181* 186 188
                                                                                  197
ascbuf                          000343 automatic       char(200)                packed unaligned dcl 75 set ref 347 347 347 347 352
                                                                                  355
ascvar                          000120 automatic       varying char(200)        dcl 62 set ref 331* 335* 335 337 337 337 337 355*
                                                                                  356 356 358 367* 368 368* 369 373 377 377 378 382*
                                                                                  384 385*
ask_                            000032 constant        entry                    external dcl 37 ref 246 397
ask_$ask_clr                    000030 constant        entry                    external dcl 36 ref 242 393
ask_ans                         000110 automatic       char(32)                 packed unaligned dcl 61 set ref 244* 245 246* 247
                                                                                  251* 251 252 256 260 264* 395* 396 397* 398 398
                                                                                  400 400* 401 401* 402* 404
author                                 based           structure                level 2 dcl 3-9
author_dcl                             based           structure                level 1 dcl 3-9
bcd_array                              based           bit(6)                   array packed unaligned dcl 101 set ref 329* 330 330
bcd_dkend                       000010 constant        bit(72)                  initial packed unaligned dcl 92 ref 513
bcdbuf                          000242 automatic       bit(2304)                packed unaligned dcl 73 set ref 329 330 330 331*
                                                                                  358* 359* 360 360 366* 367 367 545
bcw                                    based           structure                level 2 packed packed unaligned dcl 7-9
before                                                 builtin function         dcl 133 ref 643 658
bin                                                    builtin function         dcl 133 ref 447 447 454 454 482 573 573
bit                                                    builtin function         dcl 133 ref 366
blk_size                  0(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 7-9 ref
                                                                                  512 532
cata_key                        000232 automatic       char(32)                 packed unaligned dcl 72 set ref 270* 272* 274*
cc                                     based           bit(36)                  array dcl 503 set ref 520* 520 525* 525
ccl                             000611 automatic       fixed bin(17,0)          dcl 501 set ref 519* 520 521 524* 525 526
cdt                                    based           structure                level 1 dcl 1-44
cdte                                   based           structure                level 1 dcl 1-72
cdtp                            000512 automatic       pointer                  dcl 1-41 set ref 233* 234 235
channel_id                2            based           fixed bin(71,0)          array level 2 dcl 5-12 set ref 214* 221* 285* 320*
                                                                                  590* 680 680*
channel_threads                        based           structure                level 1 dcl 1-249
chars_gotten                    000342 automatic       fixed bin(21,0)          dcl 74 set ref 347* 352 352 352* 352 355
cleanup                         000476 stack reference condition                dcl 135 ref 218
clock                                                  builtin function         dcl 133 ref 589 596
code                            000427 automatic       fixed bin(35,0)          dcl 78 set ref 142* 143 161* 162 163* 181* 182 183*
                                                                                  186* 187 188* 221* 222 226* 227 228* 233* 272* 273
                                                                                  274* 285* 287 288* 297* 298 299* 305* 306 308* 309
                                                                                  337* 338 339* 342* 343 343* 347* 348 349* 361* 362
                                                                                  362* 384* 385 385* 408* 409 409* 423* 424 425*
                                                                                  449* 450 451* 455* 456 462* 463 464* 551* 552 553*
                                                                                  564* 565 566*
com_err_                        000036 constant        entry                    external dcl 39 ref 146 155 163 171 183 188 197 203
                                                                                  223 228 243 274 280 288 299 339 343 349 362 385
                                                                                  387 394 409 425 438 451 464 488 547 553 566 693
count                           000572 automatic       fixed bin(15,0)          dcl 471 set ref 484* 485
crap                            000644 automatic       fixed bin(17,0)          array dcl 580 set ref 592 592
cu_$arg_ptr                     000034 constant        entry                    external dcl 38 ref 142 161 181
currentsize                                            builtin function         dcl 133 ref 530 532
damage_85_86_flag               000203 automatic       bit(1)                   packed unaligned dcl 63 set ref 296* 381* 392 405*
deck_iocbp                      000226 automatic       pointer                  initial dcl 70 set ref 70* 272* 661* 682 683* 684*
                                                                                  685*
deck_ptr                        000574 automatic       pointer                  dcl 475 in procedure "load_program" set ref 478*
                                                                                  480*
deck_ptr                        000706 automatic       pointer                  dcl 630 in procedure "get_and_load_module" set ref
                                                                                  632* 634*
divide                                                 builtin function         dcl 133 ref 545 551 551 564 564
eof                             000612 automatic       bit(1)                   packed unaligned dcl 502 set ref 507* 509 512 513*
error_table_$bad_arg            000106 external static fixed bin(35,0)          dcl 108 set ref 155* 171*
error_table_$badopt             000110 external static fixed bin(35,0)          dcl 109 set ref 197*
error_table_$moderr             000104 external static fixed bin(35,0)          dcl 107 set ref 280*
error_table_$noarg              000112 external static fixed bin(35,0)          dcl 110 set ref 203*
error_table_$noentry            000114 external static fixed bin(35,0)          dcl 111 ref 669
error_table_$timeout            000102 external static fixed bin(35,0)          dcl 106 ref 597
error_table_$too_many_args      000116 external static fixed bin(35,0)          dcl 112 set ref 146*
event_wait_list                        based           structure                level 1 dcl 5-12 set ref 592 592
event_wait_list_n_channels      000516 automatic       fixed bin(17,0)          dcl 5-8 set ref 212*
event_wait_list_ptr             000520 automatic       pointer                  dcl 5-10 set ref 213* 214 215 221 285 320 590 592
                                                                                  592 680 680
excuse                                 parameter       char                     packed unaligned dcl 692 set ref 690 693*
exec_in_fnp                     000215 automatic       bit(1)                   packed unaligned dcl 67 set ref 310* 323* 379* 481
execname                        000436 automatic       char(6)                  packed unaligned dcl 83 set ref 140* 166* 167* 168*
                                                                                  169* 313 370* 374* 404*
exp                                    parameter       char                     packed unaligned dcl 461 set ref 460 464*
finish                          000504 stack reference condition                dcl 135 ref 219
fixed                                                  builtin function         dcl 133 ref 366 428 428
fnp_address               0(21) 000454 automatic       fixed bin(15,0)          level 2 in structure "idb" packed packed unsigned
                                                                                  unaligned dcl 117 in procedure "test_fnp" set ref
                                                                                  330 360 481
fnp_address                     000573 automatic       fixed bin(15,0)          dcl 474 in procedure "load_program" set ref 481*
                                                                                  482* 485*
fnp_entry               120            based           structure                array level 2 dcl 1-44 set ref 235
fnp_interrupt_vector_word       000012 constant        bit(36)                  initial packed unaligned dcl 91 set ref 447 447
fnp_no                          000430 automatic       fixed bin(17,0)          dcl 79 set ref 139* 145 149* 150 151 151* 151 152
                                                                                  201 235 285* 297* 342* 361* 408* 436* 455* 551*
                                                                                  564* 609* 675*
fnp_tag                         000452 automatic       char(1)                  packed unaligned dcl 86 set ref 152* 243* 288* 299*
                                                                                  438* 553* 566*
fnp_type                        000432 automatic       fixed bin(17,0)          dcl 81 set ref 236* 237 254* 258* 262* 551* 564*
fnp_type_str                    000431 automatic       char(4)                  packed unaligned dcl 80 set ref 237* 238 238* 253*
                                                                                  257* 261* 270
fnp_types                       000000 constant        char(8)                  initial array packed unaligned dcl 2-25 ref 237
fnpe                                   based           structure                level 1 dcl 1-200
fnpep                           000514 automatic       pointer                  dcl 1-41 set ref 235* 236
gc_log_rec                             based           structure                level 1 dcl 7-15 set ref 530
gc_log_rec_bits                        based           bit                      packed unaligned dcl 7-26 ref 513
gc_log_rec_data           1            based           bit(36)                  array level 2 dcl 7-15 set ref 513 523 525
gc_phy_rec                             based           structure                level 1 dcl 7-9 set ref 532
gc_phy_rec_data           1            based           bit(36)                  array level 2 dcl 7-9 set ref 510
get_process_id_                 000074 constant        entry                    external dcl 54 ref 320 320
get_temp_segment_               000076 constant        entry                    external dcl 55 ref 226
hcs_$initiate                   000066 constant        entry                    external dcl 51 ref 233
hcs_$truncate_seg               000070 constant        entry                    external dcl 52 ref 505
hcs_$wakeup                     000072 constant        entry                    external dcl 53 ref 320
i                               000724 automatic       fixed bin(17,0)          dcl 651 set ref 656* 658 660 661*
idb                             000454 automatic       structure                level 1 packed packed unaligned dcl 117 set ref 387
                                                                                  573 573
ilevel                                 parameter       fixed bin(17,0)          dcl 579 ref 577 617 617
index                                                  builtin function         dcl 133 ref 149
input_switch                    000212 automatic       pointer                  dcl 65 set ref 138* 192* 209 209* 347*
interval                               parameter       fixed bin(17,0)          dcl 579 ref 577 590 590 596 596
iox_$close                      000046 constant        entry                    external dcl 43 ref 683
iox_$detach_iocb                000050 constant        entry                    external dcl 44 ref 684
iox_$get_line                   000042 constant        entry                    external dcl 41 ref 347
iox_$look_iocb                  000040 constant        entry                    external dcl 40 ref 186
iox_$put_chars                  000044 constant        entry                    external dcl 42 ref 337
iox_$user_input                 000122 external static pointer                  dcl 113 ref 209
iox_$user_output                000120 external static pointer                  dcl 113 ref 207 208
ipc_$block                      000056 constant        entry                    external dcl 47 ref 592
ipc_$create_ev_chn              000052 constant        entry                    external dcl 45 ref 221
ipc_$delete_ev_chn              000054 constant        entry                    external dcl 46 ref 680
j                               000725 automatic       fixed bin(17,0)          dcl 651 set ref 653* 655* 656 666*
l3_happened                     000656 automatic       bit(1)                   packed unaligned dcl 582 set ref 611* 617
l7_happened                     000657 automatic       bit(1)                   packed unaligned dcl 582 set ref 612* 617
length                                                 builtin function         dcl 133 ref 150 337 337 347 347 545
linkage_error                   000470 stack reference condition                dcl 135 ref 279 286 674 676
loader_loaded                   000216 automatic       bit(1)                   packed unaligned dcl 67 set ref 448* 457*
loadsegptr                      000220 automatic       pointer                  dcl 68 set ref 216* 226* 485 485 505* 520 525 635
                                                                                  677 677*
lrptr                           000524 automatic       pointer                  dcl 7-7 set ref 510* 513 513 513 517 519 520 523 524
                                                                                  525 529 530* 530 530
ltrim                                                  builtin function         dcl 133 ref 355
media_code                0(26)        based           fixed bin(4,0)           level 3 packed packed unsigned unaligned dcl 7-15
                                                                                  ref 513 517
message_switch                  000210 automatic       pointer                  dcl 65 set ref 138* 191* 207 207* 332
min                                                    builtin function         dcl 133 ref 484
mod                                                    builtin function         dcl 133 ref 359
module_list                            based           structure                level 1 dcl 125
module_listp                    000230 automatic       pointer                  dcl 71 set ref 272* 643 653 656 658 661 665
moduleptr                       000222 automatic       pointer                  dcl 68 in procedure "test_fnp" set ref 449* 454*
moduleptr                       000536 automatic       pointer                  dcl 420 in procedure "find_and_send_required_module"
                                                                                  set ref 423* 428*
modullen                        000224 automatic       fixed bin(15,0)          dcl 69 in procedure "test_fnp" set ref 449* 454*
modullen                        000704 automatic       fixed bin(17,0)          dcl 628 in procedure "get_and_load_module" set ref
                                                                                  634* 636
modullen                        000540 automatic       fixed bin(15,0)          dcl 421 in procedure "find_and_send_required_module"
                                                                                  set ref 423* 428*
mpxe                                   based           structure                level 1 dcl 1-221
myname                          000013 constant        char(32)                 initial packed unaligned dcl 90 set ref 146* 155*
                                                                                  163* 171* 183* 188* 197* 203* 223* 226* 228* 243*
                                                                                  274* 280* 288* 299* 339* 343* 349* 362* 385* 387*
                                                                                  394* 409* 425* 438* 451* 464* 488* 547* 553* 566*
                                                                                  677* 693*
n                                      based           fixed bin(17,0)          level 2 dcl 125 ref 653 656 665
n_channels                             based           fixed bin(17,0)          level 2 dcl 5-12 set ref 215*
name                      1            based           char(24)                 array level 2 packed packed unaligned dcl 125 ref
                                                                                  643 658 661
nextc                           000576 automatic       fixed bin(17,0)          dcl 476 set ref 480* 483 484
nextcx                          000577 automatic       fixed bin(17,0)          dcl 476 set ref 483* 484 485 485*
null                                                   builtin function         dcl 133 ref 70 138 207 208 209 216 234 670 677 682
                                                                                  685
nwds                            000610 automatic       fixed bin(17,0)          dcl 501 set ref 511* 512 529* 529
piflag                          000107 automatic       bit(1)                   packed unaligned dcl 60 set ref 319* 587* 588 596
                                                                                  600
printer_switch                  000206 automatic       pointer                  dcl 65 set ref 138* 193* 208 208* 334
probe                           000124 constant        entry                    external dcl 543 ref 548
program_interrupt               000100 stack reference condition                dcl 27 ref 318
prptr                           000522 automatic       pointer                  dcl 7-6 set ref 508* 510 512 532* 532 532
ptr                                                    builtin function         dcl 133 ref 485 485 520 525
rcw                                    based           structure                level 2 packed packed unaligned dcl 7-15
rcw_sw                                 parameter       bit(1)                   packed unaligned dcl 502 ref 498 518 534
release_temp_segment_           000100 constant        entry                    external dcl 56 ref 677
request_code              1(33) 000454 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 117 set
                                                                                  ref 328 328 332 339 346 365 387*
reverse                                                builtin function         dcl 133 ref 643 643 658 658
rsize                                  based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 7-15
                                                                                  ref 513 519 524 529 530
rtrim                                                  builtin function         dcl 133 ref 356 356 382
rx                              000214 automatic       fixed bin(17,0)          initial dcl 66 set ref 66* 642* 642 643 653 655 660*
                                                                                  665 665 666*
save_pgmname                    000204 automatic       char(6)                  packed unaligned dcl 64 set ref 378* 382
start                           000654 automatic       fixed bin(71,0)          dcl 581 set ref 589* 596
substr                                                 builtin function         dcl 133 set ref 144 152 237 251 352 355 359* 366*
                                                                                  367 367 513 611 612 643 658
tally                     1     000454 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 117 set
                                                                                  ref 330 331 359 359 360 366
tandd_$fnp_tandd_detach         000012 constant        entry                    external dcl 29 ref 675
tandd_$fnp_tandd_get_ints       000020 constant        entry                    external dcl 32 ref 609
tandd_$fnp_tandd_mask           000014 constant        entry                    external dcl 30 ref 297
tandd_$fnp_tandd_read           000022 constant        entry                    external dcl 33 ref 551
tandd_$fnp_tandd_send_int       000016 constant        entry                    external dcl 31 ref 342 361 408 436 455
tandd_$fnp_tandd_setup          000010 constant        entry                    external dcl 28 ref 285
tandd_$fnp_tandd_write          000024 constant        entry                    external dcl 33 ref 564
temp_arg                        000442 automatic       char(32)                 packed unaligned dcl 85 set ref 179* 183* 191 191
                                                                                  192 192 193 193
temp_ints                       000666 automatic       bit(2)                   dcl 607 set ref 609* 611 612
temp_ptr                        000440 automatic       pointer                  dcl 84 set ref 186* 191 192 193 332* 334* 337*
three_words                            based           bit(36)                  array dcl 102 set ref 387*
timer_manager_$alarm_wakeup     000026 constant        entry                    external dcl 35 ref 590
tolts_alm_util_$ascii_to_bci_   000064 constant        entry                    external dcl 50 ref 358
tolts_util_$bci_to_ascii        000062 constant        entry                    external dcl 49 ref 331 367
tolts_util_$search              000060 constant        entry                    external dcl 48 ref 272 661
type                                   based           fixed bin(17,0)          level 2 dcl 1-200 ref 236
unspec                                                 builtin function         dcl 133 ref 545
wait_list                       000456 automatic       fixed bin(17,0)          array dcl 129 set ref 213

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTIVE                                 internal static fixed bin(17,0)          initial dcl 1-272
ANS_SERVICE                            internal static fixed bin(17,0)          initial dcl 1-259
CDT_version                            internal static fixed bin(17,0)          initial dcl 1-39
CDT_version_5                          internal static fixed bin(17,0)          initial dcl 1-38
CHANNEL_DELETED                        internal static fixed bin(17,0)          initial dcl 1-288
DIAL_OUT_SERVICE                       internal static fixed bin(17,0)          initial dcl 1-259
DIAL_SERVICE                           internal static fixed bin(17,0)          initial dcl 1-259
DN7100                                 internal static fixed bin(17,0)          initial dcl 2-19
FNP_BOOT                               internal static fixed bin(17,0)          initial dcl 1-298
FNP_DOWN                               internal static fixed bin(17,0)          initial dcl 1-298
FNP_FREE                               internal static fixed bin(17,0)          initial dcl 1-298
FNP_UNKNOWN                            internal static fixed bin(17,0)          initial dcl 1-298
FNP_UP                                 internal static fixed bin(17,0)          initial dcl 1-298
FTP_SERVICE                            internal static fixed bin(17,0)          initial dcl 1-259
INACTIVE                               internal static fixed bin(17,0)          initial dcl 1-272
MC_SERVICE                             internal static fixed bin(17,0)          initial dcl 1-259
MPX_BOOT                               internal static fixed bin(17,0)          initial dcl 1-306
MPX_DOWN                               internal static fixed bin(17,0)          initial dcl 1-306
MPX_FREE                               internal static fixed bin(17,0)          initial dcl 1-306
MPX_SERVICE                            internal static fixed bin(17,0)          initial dcl 1-259
MPX_UNKNOWN                            internal static fixed bin(17,0)          initial dcl 1-306
MPX_UP                                 internal static fixed bin(17,0)          initial dcl 1-306
NOT_CONFIGURED                         internal static fixed bin(17,0)          initial dcl 1-280
SLAVE_SERVICE                          internal static fixed bin(17,0)          initial dcl 1-259
TANDD_SERVICE                          internal static fixed bin(17,0)          initial dcl 1-259
cdtep                                  automatic       pointer                  dcl 1-41
event_wait_info                        based           structure                level 1 dcl 6-7
event_wait_info_ptr                    automatic       pointer                  dcl 6-5
fnp_models                             internal static fixed bin(17,0)          initial array dcl 2-28
gc_phy_rec_bits                        based           bit                      packed unaligned dcl 7-25
generic_destination                    based           char(32)                 packed unaligned dcl 1-195
mpxep                                  automatic       pointer                  dcl 1-41
supported_fnp                          internal static bit(1)                   initial array packed unaligned dcl 2-31

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        006130 constant        entry                    internal dcl 673 ref 218 219 229 248 275 282 289 300
                                                                                  694
cleanup_ret                     006170 constant        label                    dcl 677 ref 674
core_load                       005006 constant        entry                    internal dcl 498 ref 480 634
end_arg_processing              001563 constant        label                    dcl 201 ref 143
exchange_terminate_interrupts   004351 constant        entry                    internal dcl 433 ref 305 308 486
find_and_send_required_module   004221 constant        entry                    internal dcl 416 ref 303 304 307
fnp_service_loop                003013 constant        label                    dcl 323 ref 350 389 410
get_and_load_module             005663 constant        entry                    internal dcl 623 ref 423 449
get_deck_ptr                    005766 constant        entry                    internal dcl 647 ref 478 632
get_int_status                  005614 constant        entry                    internal dcl 606 ref 584 594
ldrs                            002665 constant        label                    dcl 310 ref 371 375 406
load_fnp_interrupt_vectors      004444 constant        entry                    internal dcl 445 ref 311 380
load_program                    004645 constant        entry                    internal dcl 469 ref 384 462
load_required_module            004561 constant        entry                    internal dcl 460 ref 312 313 314
needed_int                      005645 constant        entry                    internal dcl 615 ref 588 596
next_program                    005724 constant        entry                    internal dcl 640 ref 368
nlret                           004220 constant        label                    dcl 412 ref 283 465 695
perm_fail                       006274 constant        entry                    internal dcl 690 ref 306 309 356 398 426 452 456 554
                                                                                  567
pi_person                       004004 constant        label                    dcl 390 ref 600
read_fnp                        005174 constant        entry                    internal dcl 538 ref 330 573
read_idb                        005440 constant        entry                    internal dcl 571 ref 327
retry_search                    006006 constant        label                    dcl 656 ref 667
test_fnp                        000752 constant        entry                    external dcl 11
wait                            005452 constant        entry                    internal dcl 577 ref 326 440
write_fnp                       005340 constant        entry                    internal dcl 558 ref 360 428 447 454 485

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7352        7500    6635        7362
Length     10144    6635       126         427     515           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
test_fnp                            912 external procedure  is an external procedure.  
on unit on line 218                  64 on unit               
on unit on line 219                  64 on unit               
on unit on line 279                  94 on unit               
on unit on line 318                  92 on unit               
find_and_send_required_module           internal procedure  shares stack frame of external procedure test_fnp.  
exchange_terminate_interrupts           internal procedure  shares stack frame of external procedure test_fnp.  
load_fnp_interrupt_vectors              internal procedure  shares stack frame of external procedure test_fnp.  
load_required_module                    internal procedure  shares stack frame of external procedure test_fnp.  
load_program                            internal procedure  shares stack frame of external procedure test_fnp.  
core_load                               internal procedure  shares stack frame of external procedure test_fnp.  
read_fnp                                internal procedure  shares stack frame of external procedure test_fnp.  
write_fnp                               internal procedure  shares stack frame of external procedure test_fnp.  
read_idb                                internal procedure  shares stack frame of external procedure test_fnp.  
wait                                    internal procedure  shares stack frame of external procedure test_fnp.  
get_int_status                          internal procedure  shares stack frame of external procedure test_fnp.  
needed_int                              internal procedure  shares stack frame of external procedure test_fnp.  
get_and_load_module                     internal procedure  shares stack frame of external procedure test_fnp.  
next_program                            internal procedure  shares stack frame of external procedure test_fnp.  
get_deck_ptr                            internal procedure  shares stack frame of external procedure test_fnp.  
clean_up                             92 internal procedure  enables or reverts conditions.  
on unit on line 674                  64 on unit               
perm_fail                            86 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
test_fnp                 000106 allow_pi                    test_fnp
                         000107 piflag                      test_fnp
                         000110 ask_ans                     test_fnp
                         000120 ascvar                      test_fnp
                         000203 damage_85_86_flag           test_fnp
                         000204 save_pgmname                test_fnp
                         000206 printer_switch              test_fnp
                         000210 message_switch              test_fnp
                         000212 input_switch                test_fnp
                         000214 rx                          test_fnp
                         000215 exec_in_fnp                 test_fnp
                         000216 loader_loaded               test_fnp
                         000220 loadsegptr                  test_fnp
                         000222 moduleptr                   test_fnp
                         000224 modullen                    test_fnp
                         000226 deck_iocbp                  test_fnp
                         000230 module_listp                test_fnp
                         000232 cata_key                    test_fnp
                         000242 bcdbuf                      test_fnp
                         000342 chars_gotten                test_fnp
                         000343 ascbuf                      test_fnp
                         000425 argno                       test_fnp
                         000426 arglen                      test_fnp
                         000427 code                        test_fnp
                         000430 fnp_no                      test_fnp
                         000431 fnp_type_str                test_fnp
                         000432 fnp_type                    test_fnp
                         000434 argp                        test_fnp
                         000436 execname                    test_fnp
                         000440 temp_ptr                    test_fnp
                         000442 temp_arg                    test_fnp
                         000452 fnp_tag                     test_fnp
                         000454 idb                         test_fnp
                         000456 wait_list                   test_fnp
                         000512 cdtp                        test_fnp
                         000514 fnpep                       test_fnp
                         000516 event_wait_list_n_channels  test_fnp
                         000520 event_wait_list_ptr         test_fnp
                         000522 prptr                       test_fnp
                         000524 lrptr                       test_fnp
                         000536 moduleptr                   find_and_send_required_module
                         000540 modullen                    find_and_send_required_module
                         000572 count                       load_program
                         000573 fnp_address                 load_program
                         000574 deck_ptr                    load_program
                         000576 nextc                       load_program
                         000577 nextcx                      load_program
                         000610 nwds                        core_load
                         000611 ccl                         core_load
                         000612 eof                         core_load
                         000644 crap                        wait
                         000654 start                       wait
                         000656 l3_happened                 wait
                         000657 l7_happened                 wait
                         000666 temp_ints                   get_int_status
                         000704 modullen                    get_and_load_module
                         000706 deck_ptr                    get_and_load_module
                         000724 i                           get_deck_ptr
                         000725 j                           get_deck_ptr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          tra_ext_1           mdfx1
enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc      reverse_cs
set_chars_eis       index_chars_eis     clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ask_                          ask_$ask_clr                  com_err_                      cu_$arg_ptr
get_process_id_               get_temp_segment_             hcs_$initiate                 hcs_$truncate_seg
hcs_$wakeup                   iox_$close                    iox_$detach_iocb              iox_$get_line
iox_$look_iocb                iox_$put_chars                ipc_$block                    ipc_$create_ev_chn
ipc_$delete_ev_chn            probe                         release_temp_segment_         tandd_$fnp_tandd_detach
tandd_$fnp_tandd_get_ints     tandd_$fnp_tandd_mask         tandd_$fnp_tandd_read         tandd_$fnp_tandd_send_int
tandd_$fnp_tandd_setup        tandd_$fnp_tandd_write        timer_manager_$alarm_wakeup   tolts_alm_util_$ascii_to_bci_
tolts_util_$bci_to_ascii      tolts_util_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$moderr           error_table_$noarg
error_table_$noentry          error_table_$timeout          error_table_$too_many_args    iox_$user_input
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000751        66 000757        70 000761       138 000763       139 000767       140 000771       141 000773
    142 000776       143 001013       144 001015       145 001022       146 001025       147 001051       149 001052
    150 001061       151 001066       152 001072       153 001104       155 001105       156 001141       158 001142
    159 001143       160 001150       161 001151       162 001166       163 001170       164 001214       166 001215
    167 001226       168 001235       169 001244       171 001253       172 001277       174 001300       175 001301
    179 001331       180 001334       181 001335       182 001352       183 001354       184 001403       186 001404
    187 001430       188 001432       189 001464       191 001465       192 001500       193 001513       194 001525
    197 001526       198 001560       200 001561       201 001563       203 001566       204 001612       207 001613
    208 001623       209 001633       212 001643       213 001645       214 001647       215 001651       216 001653
    218 001655       219 001677       221 001721       222 001733       223 001735       224 001762       226 001763
    227 002004       228 002006       229 002032       230 002036       233 002037       234 002112       235 002116
    236 002123       237 002125       238 002132       239 002141       242 002142       243 002147       244 002200
    245 002203       246 002210       247 002230       248 002234       249 002240       251 002241       252 002244
    253 002250       254 002252       255 002254       256 002255       257 002261       258 002263       259 002265
    260 002266       261 002272       262 002274       263 002276       264 002277       265 002302       270 002303
    272 002316       273 002337       274 002341       275 002370       276 002374       279 002375       280 002411
    282 002434       283 002441       285 002444       286 002460       287 002461       288 002463       289 002513
    290 002517       296 002520       297 002521       298 002532       299 002534       300 002564       301 002570
    303 002571       304 002603       305 002615       306 002617       307 002634       308 002646       309 002650
    310 002665       311 002666       312 002667       313 002701       314 002717       317 002726       318 002727
    319 002743       320 002746       322 003012       323 003013       325 003015       326 003016       327 003024
    328 003025       329 003034       330 003047       331 003061       332 003106       334 003115       335 003117
    337 003126       338 003152       339 003154       342 003211       343 003226       345 003254       346 003255
    347 003257       348 003302       349 003304       350 003330       352 003331       355 003341       356 003363
    358 003424       359 003451       360 003466       361 003477       362 003514       364 003542       365 003543
    366 003545       367 003554       368 003602       369 003616       370 003623       371 003625       373 003626
    374 003633       375 003635       377 003636       378 003650       379 003655       380 003656       381 003657
    382 003661       384 003701       385 003710       386 003743       387 003744       389 004003       390 004004
    392 004005       393 004007       394 004014       395 004044       396 004047       397 004054       398 004074
    400 004123       401 004133       402 004143       403 004146       404 004147       405 004152       406 004153
    408 004154       409 004171       410 004217       412 004220       416 004221       423 004232       424 004247
    425 004251       426 004306       427 004335       428 004336       429 004350       433 004351       436 004353
    438 004371       440 004425       441 004443       445 004444       447 004445       448 004455       449 004456
    450 004462       451 004464       452 004510       454 004520       455 004524       456 004541       457 004556
    458 004560       460 004561       462 004572       463 004603       464 004605       465 004643       467 004644
    469 004645       478 004647       479 004670       480 004674       481 004700       482 004706       483 004710
    484 004717       485 004725       486 004735       487 004744       488 004747       491 004777       493 005000
    494 005003       495 005005       498 005006       505 005010       506 005025       507 005027       508 005030
    509 005033       510 005036       511 005041       512 005042       513 005051       516 005066       517 005067
    518 005071       519 005077       520 005103       521 005114       522 005116       523 005117       524 005123
    525 005127       526 005137       529 005141       530 005147       531 005154       532 005155       533 005161
    534 005162       536 005173       538 005174       545 005176       547 005202       548 005234       549 005241
    551 005242       552 005270       553 005272       554 005327       556 005337       558 005340       564 005342
    565 005370       566 005372       567 005427       569 005437       571 005440       573 005441       574 005451
    577 005452       584 005454       585 005455       586 005461       587 005463       588 005464       589 005472
    590 005474       592 005520       593 005540       594 005544       595 005545       596 005551       597 005601
    598 005604       600 005605       601 005607       602 005610       603 005611       604 005613       606 005614
    609 005615       610 005631       611 005635       612 005640       613 005644       615 005645       617 005647
    623 005663       632 005665       633 005706       634 005712       635 005716       636 005721       637 005723
    640 005724       642 005726       643 005727       647 005766       653 005777       655 006005       656 006006
    658 006015       660 006053       661 006056       662 006104       664 006105       665 006107       666 006114
    667 006117       669 006120       670 006124       671 006126       673 006127       674 006135       675 006154
    676 006167       677 006170       680 006217       682 006235       683 006242       684 006254       685 006267
    688 006272       690 006273       693 006307       694 006337       695 006344


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
