	COMPILATION LISTING OF SEGMENT convert_string_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/17/88  1045.5 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 convert_string_: proc;
       13 
       14 /* Created by wholesale modification of tty_read 1/78 by D. Vinograd */
       15 /* Modified by D. Vinograd, 11/78, to avoid calling canonicalize_ unless really necessary. */
       16 
       17 
       18 /****^  HISTORY COMMENTS:
       19*  1) change(88-01-26,Brunelle), approve(88-01-26,MCR7813),
       20*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
       21*     Upgraded to handle special char sequences of 15 instead of 3 chars
       22*     (c_chars).
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* PARAMETERS */
       27 
       28 dcl  input_string char (*) var;
       29 dcl  output_string char (*) var;
       30 dcl  specp ptr;
       31 dcl  seqp ptr;
       32 dcl  mvtp ptr;
       33 dcl  tctp ptr;
       34 dcl  code fixed bin (35);
       35 
       36 /* AUTOMATIC */
       37 
       38 dcl  kill_char char (1);
       39 dcl  erase_char char (1);
       40 dcl  entry fixed bin;
       41 dcl  escape_index fixed bin;
       42 dcl  buffer_1 char (720) aligned;
       43 dcl  buffer_2 char (720) aligned;
       44 dcl  digit fixed bin;
       45 dcl  break_found bit (1);
       46 dcl  chars_moved bit (1);
       47 dcl  source_ptr ptr;
       48 dcl  target_ptr ptr;
       49 dcl  old_sourcep ptr;
       50 dcl  old_targetp ptr;
       51 dcl  source_len fixed bin;
       52 dcl  ret_len fixed bin;
       53 dcl  target_len fixed bin;
       54 dcl  xr fixed bin;					/* used for result of index builtin */
       55 dcl  bx fixed bin;					/* used in verify of white space */
       56 dcl  i fixed bin;					/* temporary work variable */
       57 dcl  next_char char (1) aligned;
       58 
       59 dcl 1 seq based (seqp) aligned like c_chars;		/* template of special chars sequence */
       60 
       61 dcl 1 octal aligned,
       62     2 pad bit (27) unal,
       63     2 result fixed bin (8) unal;			/* so arithmetic value can be easily addressed as char */
       64 
       65 dcl 1 util aligned,					/* structure passed to convert_string_util_$tct */
       66 						/* first 3 items in this structure are */
       67 						/* also used as general automatic variables */
       68     2 stringp ptr,
       69     2 stringl fixed bin,
       70     2 ctally fixed bin,
       71     2 tablep ptr,
       72     2 indicator fixed bin,
       73     2 pad (3) fixed bin;				/* workspace for convert_string_util_ */
       74 
       75 /* INTERNAL STATIC CONSTANTS */
       76 
       77 dcl  backspace char (1) int static init ("") options (constant); /* backspace */
       78 dcl  space char (1) static init (" ");
       79 dcl  tab char (1) static init ("	");
       80 dcl  cr char (1) static init ("");
       81 dcl  input fixed bin static init (1);
       82 dcl  output fixed bin static init (2);
       83 
       84 /* various strange-looking character strings */
       85 
       86 dcl  right_motion char (2) aligned int static options (constant) init
       87     ("	 ");					/* HT, SP */
       88 
       89 
       90 dcl  nl char (1) aligned int static options (constant) init
       91     ("
       92 ");						/* NL */
       93 
       94 dcl  bs char (1) aligned int static options (constant) init (""); /* BS */
       95 
       96 
       97 
       98 dcl  based_onechar char (1) based;
       99 
      100 /* ENTRIES */
      101 
      102 dcl  convert_string_util_$find_char entry (ptr);
      103 dcl  canonicalize_ entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
      104 dcl  convert_string_util_$tct entry (ptr);
      105 dcl  convert_string_util_$mvt entry (ptr);
      106 
      107 /* EXTERNAL STATIC */
      108 
      109 dcl  error_table_$improper_data_format ext static fixed bin (35);
      110 
      111 
      112 /* BASED */
      113 
      114 dcl  based_chars (0:10) char (1) unal based;
      115 dcl  based_one_char char (1) unal based;
      116 dcl  based_string char (util.stringl) based (util.stringp);
      117 dcl  based_ret char (source_len) based (source_ptr);
      118 dcl  based_source char (source_len) based (old_sourcep);
      119 dcl  based_target char (target_len) based (old_targetp);
      120 dcl  table (0: 127) fixed bin (8) unaligned based;
      121 
      122 dcl  based_fb8 fixed bin (8) unal based;
      123 
      124 dcl 1 mvt_args aligned based (addr (util)),		/* overlay of util structure for convert_string_util_$mvt */
      125     2 stringp ptr,
      126     2 stringl fixed bin,
      127     2 pad fixed bin,
      128     2 tablep ptr,
      129     2 targetp ptr;
      130 
      131 
      132 /* BUILTINS */
      133 
      134 dcl (addr, index, null, substr, verify, length, reverse) builtin;
      135 
  1     1 /* BEGIN...   remote_ttt_info.incl.pl1 ... 5/78 */
  1     2 
  1     3 dcl  rttp ptr;					/* ptr to data structure */
  1     4 
  1     5 
  1     6 dcl 1 remote_ttt_info based (rttp) aligned,		/* data */
  1     7     2 ttt_bits,					/* control bits */
  1     8      (3 escape_output bit (1),			/* if on enables output escape processing */
  1     9       3 translate_output bit (1),			/* if on enables output translation */
  1    10       3 translate_input bit (1),			/* if on enables input translation */
  1    11       3 escape_input bit (1),				/* if on enables input escape processing */
  1    12       3 erase_input bit (1),				/* if on enables input erase processing */
  1    13       3 canonicalize_input bit (1),			/* if on enables input canonicalization */
  1    14       3 edited bit (1)) unal,				/* if on enables edited escape processing */
  1    15     2 terminal_type char (32),			/* terminal type in TTT */
  1    16     2 kill_char char (1),				/* specified kil character */
  1    17     2 erase_char char (1),				/* and erase character */
  1    18     2 ttt_ptrs,					/* ptr to various ttt tables */
  1    19       3 input_mvtp ptr,				/* input translation table */
  1    20       3 output_mvtp ptr,				/* output translation table */
  1    21       3 input_tctp ptr,				/* input escape table */
  1    22       3 output_tctp ptr,				/* output escape table */
  1    23       3 specp ptr;					/* special table */
  1    24 
  1    25 /* END remote_ttt_info.incl.pl1 */
      136 
  2     1 
  2     2 /* Begin include file ...... prt_info.incl.pl1 */
  2     3 /* last modified 6/12/75 by Noel I. Morris	*/
  2     4 
  2     5 dcl  pip ptr;					/* pointer to printer info structure */
  2     6 
  2     7 dcl 1 prt_info based (pip) aligned,			/* printer info structure */
  2     8     2 devname char (4),				/* name of device */
  2     9     2 devx fixed bin,				/* device index */
  2    10     2 model fixed bin,				/* printer model number */
  2    11     2 type fixed bin,				/* printer type number */
  2    12     2 train fixed bin,				/* print train ID */
  2    13     2 line_length fixed bin,				/* max length of printed line */
  2    14     2 print_idcw bit (36),				/* IDCW to print 1 line */
  2    15     2 term_idcw bit (36);				/* IDCW to stop printer channel */
  2    16 
  2    17 /* End of include file ...... prt_info.incl.pl1 */
  2    18 
      137 
  3     1 
  3     2 /* BEGIN INCLUDE FILE ... prt_conv_info.incl.pl1 */
  3     3 /* Modified: 12 September 1980 by G. Palter */
  3     4 
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
  3     8*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  3     9*     Add modes.line_nbrs, flags.(eol eof)  bits for eor -nb.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 dcl  pcip ptr;					/* pointer to conversion info structure */
  3    14 
  3    15 dcl 1 pci based (pcip) aligned,			/* printer conversion info structure */
  3    16     2 cv_proc ptr,					/* pointer to character conversion procedure */
  3    17     2 lmarg fixed bin,				/* left margin indentation */
  3    18     2 rmarg fixed bin,				/* right margin limit */
  3    19     2 page_length fixed bin,				/* number of lines on page */
  3    20     2 phys_line_length fixed bin,			/* physical width of paper */
  3    21     2 phys_page_length fixed bin,			/* physical length of paper */
  3    22     2 lpi fixed bin,				/* lines per inch */
  3    23     2 sheets_per_page fixed bin,			/* sheets of paper per logical page */
  3    24     2 line_count fixed bin,				/* count of converted lines */
  3    25     2 page_count fixed bin,				/* count of converted pages */
  3    26     2 func fixed bin,				/* special conversion function */
  3    27 						/* 0 => normal conversion */
  3    28 						/* 1 => change NL to FF */
  3    29 						/* 2 => change NL to top inside page */
  3    30 						/* 3 => change NL to end of page */
  3    31                                                             /* 4 => change NL to top of outside page */
  3    32     (2 modes,					/* conversion modes */
  3    33      3 overflow_off bit (1),				/* "1"b to suppress end of page overflow */
  3    34       3 single_space bit (1),				/* "1"b to change all forms advance chars to NL */
  3    35       3 non_edited bit (1),				/* "1"b to print ASCII control chars */
  3    36       3 truncate bit (1),				/* "1"b to truncate lines that are too long */
  3    37       3 esc bit (1),				/* "1"b to process ESC character */
  3    38       3 ctl_char bit (1),				/* "1"b to output control characters */
  3    39       3 line_nbrs bit (1),				/* "1"b to output line numbers */
  3    40       3 pci_pad bit (5),
  3    41     2 flags,					/* flags internal to prt_conv_ */
  3    42       3 ignore_next_ff bit (1),			/* ON => prt_conv_ just output a FF; ignore next character if
  3    43*						   it's a FF */
  3    44       3 eol bit (1),				/* "1"b = end-of-line encountered */
  3    45       3 eof bit (1),				/* "1"b = end-of-segment encountered */
  3    46       3 flags_pad bit (3),
  3    47     2 coroutine_modes,
  3    48       3 upper_case bit(1),				/* "1"b to convert to upper case */
  3    49       3 ht bit(1),					/* "1"b to skip tab conversion */
  3    50       3 coroutine_pad bit(13),
  3    51       3 slew_table_idx bit(3) ) unal,			/* slew table index */
  3    52     2 top_label_line char (136),			/* contains an optional top of page label */
  3    53     2 bot_label_line char (136),			/* contains an optional bottom of page label */
  3    54     2 top_label_length fixed bin,			/* length of top label line */
  3    55     2 bot_label_length fixed bin,			/* length of bottom label line */
  3    56     2 form_stops (256) unal,				/* logical form stops */
  3    57       3 lbits bit (9),				/* leftmost bits */
  3    58       3 rbits bit (9),				/* rightmost bits */
  3    59 
  3    60 /* The following items are for internal use by the print conversion procedure.
  3    61*   They should be zeroed once and then never referenced again.		*/
  3    62 
  3    63     2 level fixed bin,				/* overstrike level */
  3    64     2 pos fixed bin,				/* print position at end of incomplete line */
  3    65     2 line fixed bin,				/* current line number */
  3    66     2 slew_residue fixed bin,				/* number of lines remaining to be slewed */
  3    67     2 label_nelem fixed bin,				/* characters remaining in label */
  3    68     2 label_wksp ptr,				/* pointer to label being processed */
  3    69     2 sav_pos fixed bin,				/* position saved during label processing */
  3    70     2 esc_state fixed bin,				/* state of ESC processing */
  3    71     2 esc_num fixed bin,				/* number following ESC sequence */
  3    72     2 temp bit (36);				/* conversion proc temporary */
  3    73 
  3    74 /* End of include file ...... prt_conv_info.incl.pl1 */
  3    75 
      138 
  4     1 /*	BEGIN INCLUDE FILE ... tty_convert.incl.pl1	*/
  4     2 
  4     3 /* tty_ conversion tables */
  4     4 /* Created 11/3/75 by Robert S. Coren */
  4     5 /* Info structures added 5/19/77 by Robert S. Coren */
  4     6 /* Length of cv_trans changed from 128 to 256 05/03/78 by Robert Coren */
  4     7 /* conversion table mnemonics added JRDavis 21 Aug 80 */
  4     8 /* fix special_chars_struc to have good refers Fri 13 Feb 81 JRDavis */
  4     9 
  4    10 
  4    11 /****^  HISTORY COMMENTS:
  4    12*  1) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
  4    13*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
  4    14*      Added INPUT_CONVERT_DSA_CR_PROCESSING constant.
  4    15*  2) change(88-01-22,Brunelle), approve(88-01-22,MCR7813),
  4    16*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
  4    17*     Expand c_chars definition from 3 chars to 15.  Change SPECIAL_VERSION
  4    18*     from 1 to 2.  Add version variable to get_special_info_struc and define
  4    19*     SPECIAL_INFO_STRUCT_VERSION_1.
  4    20*                                                   END HISTORY COMMENTS */
  4    21 
  4    22 
  4    23 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
  4    24 
  4    25 
  4    26      dcl	1 special_chars	     aligned based,		/* table of special character sequences */
  4    27 	  2 nl_seq	     aligned like c_chars,	/* new-line sequence */
  4    28 	  2 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  4    29 	  2 bs_seq	     aligned like c_chars,	/* backspace sequence */
  4    30 	  2 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  4    31 	  2 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  4    32 	  2 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  4    33 	  2 printer_on	     aligned like c_chars,	/* printer-on sequence */
  4    34 	  2 printer_off	     aligned like c_chars,	/* printer_off sequence */
  4    35 	  2 red_ribbon_shift     aligned like c_chars,	/* red ribbon shift sequence */
  4    36 	  2 black_ribbon_shift   aligned like c_chars,	/* black ribbon shift sequence */
  4    37 	  2 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  4    38 	  2 escape_length	     fixed bin,		/* number of escape sequences */
  4    39 	  2 not_edited_escapes   (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  4    40 						/* use in ^edited mode */
  4    41 	  2 edited_escapes	     (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  4    42 						/* use in edited mode */
  4    43 	  2 input_escapes	     aligned,
  4    44 	    3 len		     fixed bin (8) unaligned, /* length of string */
  4    45 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned,
  4    46 						/* escape sequence characters */
  4    47 	  2 input_results	     aligned,
  4    48 	    3 pad		     bit (9) unaligned,	/* so that strings will look the same */
  4    49 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned;
  4    50 						/* results of escape sequences */
  4    51 
  4    52 
  4    53      dcl	c_chars_ptr	     ptr;
  4    54      dcl	1 c_chars		     based (c_chars_ptr) aligned,
  4    55 	  2 count		     fixed bin (8) unaligned,
  4    56 	  2 chars		     (15) char (1) unaligned;
  4    57 
  4    58      dcl	sc_escape_len	     fixed bin;		/* count of output escapes to allocate in special_chars  */
  4    59      dcl	sc_input_escape_len	     fixed bin;		/* count of input escapes to allocate in special_chars  */
  4    60 
  4    61 
  4    62      dcl	1 cv_trans	     based aligned,		/* conversion/translation table format */
  4    63 	  2 value		     (0:255) fixed bin (8) unal;
  4    64 
  4    65 
  4    66      dcl	1 delay		     based aligned,		/* delay counts for output */
  4    67 	  2 vert_nl	     fixed bin,
  4    68 	  2 horz_nl	     float bin,
  4    69 	  2 const_tab	     fixed bin,
  4    70 	  2 var_tab	     float bin,
  4    71 	  2 backspace	     fixed bin,
  4    72 	  2 vt_ff		     fixed bin;
  4    73 
  4    74 /* info structures used with orders */
  4    75 
  4    76      dcl	1 special_chars_struc    aligned based,
  4    77 	  2 version	     fixed bin,
  4    78 	  2 default	     fixed bin,		/* non-zero indicates use default */
  4    79 	  2 special_chars,				/* same as level-1 above */
  4    80 						/* has to be spelled out instead of using like */
  4    81 						/* because of refer options */
  4    82 	    3 nl_seq	     aligned like c_chars,	/* new-line sequence */
  4    83 	    3 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  4    84 	    3 bs_seq	     aligned like c_chars,	/* backspace sequence */
  4    85 	    3 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  4    86 	    3 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  4    87 	    3 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  4    88 	    3 printer_on	     aligned like c_chars,	/* printer-on sequence */
  4    89 	    3 printer_off	     aligned like c_chars,	/* printer_off sequence */
  4    90 	    3 red_ribbon_shift   aligned like c_chars,	/* red ribbon shift sequence */
  4    91 	    3 black_ribbon_shift aligned like c_chars,	/* black ribbon shift sequence */
  4    92 	    3 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  4    93 	    3 escape_length	     fixed bin,		/* number of escape sequences */
  4    94 	    3 not_edited_escapes (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  4    95 						/* use in ^edited mode */
  4    96 	    3 edited_escapes     (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  4    97 						/* use in edited mode */
  4    98 	    3 input_escapes	     aligned,
  4    99 	      4 len	     fixed bin (8) unaligned, /* length of string */
  4   100 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned,
  4   101 						/* escape sequence characters */
  4   102 	    3 input_results	     aligned,
  4   103 	      4 pad	     bit (9) unaligned,	/* so that strings will look the same */
  4   104 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned;
  4   105 						/* results of escape sequences */
  4   106 
  4   107      dcl	1 cv_trans_struc	     aligned based,		/* all conversion/translation tables */
  4   108 	  2 version	     fixed bin,
  4   109 	  2 default	     fixed bin,		/* as above */
  4   110 	  2 cv_trans	     like cv_trans;
  4   111 
  4   112      dcl	1 delay_struc	     aligned based,
  4   113 	  2 version	     fixed bin,
  4   114 	  2 default	     fixed bin,		/* as above */
  4   115 	  2 delay		     like delay;
  4   116 
  4   117      dcl	1 get_special_info_struc based aligned,		/* get_special order */
  4   118 	  2 version	     char (8),
  4   119 	  2 area_ptr	     pointer,
  4   120 	  2 table_ptr	     pointer;
  4   121 
  4   122      dcl	SPECIAL_INFO_STRUCT_VERSION_1
  4   123 			     char (8) int static options (constant) init ("sisv1000");
  4   124      dcl	SPECIAL_VERSION	     fixed bin int static options (constant) init (1);
  4   125      dcl	SPECIAL_VERSION_2	     fixed bin int static options (constant) init (2);
  4   126      dcl	DELAY_VERSION	     fixed bin int static options (constant) init (1);
  4   127      dcl	CV_TRANS_VERSION	     fixed bin int static options (constant) init (2);
  4   128 
  4   129      dcl	CV_TRANS_SIZE	     (2) fixed bin int static options (constant) init (127, 255);
  4   130 						/* indexed by version number */
  4   131 
  4   132 
  4   133 /* values for input and output conversion tables */
  4   134 
  4   135      dcl	(
  4   136 	INPUT_CONVERT_ORDINARY   init (0),
  4   137 	INPUT_CONVERT_BREAK	     init (1),
  4   138 	INPUT_CONVERT_ESCAPE     init (2),
  4   139 	INPUT_CONVERT_DISCARD    init (3),
  4   140 	INPUT_CONVERT_FORMFEED   init (4),
  4   141 	INPUT_CONVERT_PRECEDENCE_DISCARD
  4   142 			     init (5),
  4   143 	INPUT_CONVERT_DSA_CR_PROCESSING
  4   144 			     init (6)
  4   145 	)		     fixed bin (8) unaligned internal static options (constant);
  4   146 
  4   147      dcl	(
  4   148 	OUTPUT_CONVERT_ORDINARY  init (0),
  4   149 	OUTPUT_CONVERT_NEWLINE   init (1),
  4   150 	OUTPUT_CONVERT_CR	     init (2),
  4   151 	OUTPUT_CONVERT_HT	     init (3),
  4   152 	OUTPUT_CONVERT_BS	     init (4),
  4   153 	OUTPUT_CONVERT_VT	     init (5),
  4   154 	OUTPUT_CONVERT_FF	     init (6),
  4   155 	OUTPUT_CONVERT_OCTAL     init (7),
  4   156 	OUTPUT_CONVERT_RRS	     init (8),
  4   157 	OUTPUT_CONVERT_BRS	     init (9),
  4   158 	OUTPUT_CONVERT_NO_MOTION init (10),
  4   159 	OUTPUT_CONVERT_PRECEDENCE_NO_MOTION
  4   160 			     init (11),
  4   161 	OUTPUT_CONVERT_DONT_SEND init (12),
  4   162 	OUTPUT_CONVERT_NOT_USED_13
  4   163 			     init (13),
  4   164 	OUTPUT_CONVERT_NOT_USED_14
  4   165 			     init (14),
  4   166 	OUTPUT_CONVERT_NOT_USED_15
  4   167 			     init (15),
  4   168 	OUTPUT_CONVERT_NOT_USED_16
  4   169 			     init (16),
  4   170 	OUTPUT_CONVERT_FIRST_SPECIAL
  4   171 			     init (17)
  4   172 	)		     fixed bin (8) unaligned internal static options (constant);
  4   173 
  4   174 /*	END INCLUDE FILE ... tty_convert.incl.pl1 */
      139 
      140 
      141 input:	entry (input_string, rttp, output_string, code);
      142 
      143 	entry = input;
      144 	mvtp = remote_ttt_info.input_mvtp;
      145 	tctp = remote_ttt_info.input_tctp;
      146 	goto common;
      147 
      148 output:	entry (input_string, rttp, output_string, code);
      149 
      150 	entry = output;
      151 	mvtp = remote_ttt_info.output_mvtp;
      152 	tctp = remote_ttt_info.output_tctp;
      153 common:
      154 	specp = remote_ttt_info.specp;
      155 	erase_char = remote_ttt_info.erase_char;
      156 	kill_char = remote_ttt_info.kill_char;
      157 	buffer_1 = input_string;
      158 	buffer_2 = "";
      159 	source_ptr = addr (buffer_1);
      160 	target_ptr = addr (buffer_2);
      161 	source_len = length (input_string);		/* the number of chars in buffer_1 now */
      162 	util.stringp = source_ptr;
      163 
      164 	if entry = output then do;
      165 	     if remote_ttt_info.escape_output then
      166 		call escape_output;
      167 	     if remote_ttt_info.translate_output then
      168 		call translate;
      169 	end;
      170 	else do;
      171 	     if remote_ttt_info.translate_input then
      172 		call translate;
      173 	     if remote_ttt_info.escape_input then
      174 		call escape_input;
      175 	     if remote_ttt_info.erase_input then
      176 		call erase;
      177 	     if remote_ttt_info.canonicalize_input &
      178 	     index (based_ret, cr || tab || backspace) ^= 0 then
      179 		call canonicalize_ (source_ptr, source_len, source_ptr, source_len, code);
      180 	end;
      181 
      182 	ret_len = source_len;
      183 	output_string = based_ret;
      184 finish:
      185 	return;
      186 table_error:
      187 	code = error_table_$improper_data_format;
      188 	goto finish;
      189 
      190 translate: proc;
      191 	     if mvtp ^= null
      192 	     then do;
      193 		mvt_args.stringp = source_ptr;
      194 		mvt_args.stringl = source_len;
      195 		mvt_args.tablep = mvtp;
      196 		mvt_args.targetp = target_ptr;
      197 
      198 		call convert_string_util_$mvt (addr (util)); /* this does the translation */
      199 
      200 		source_ptr = mvt_args.targetp;
      201 		target_ptr = mvt_args.stringp;
      202 		target_len = source_len;
      203 	     end;
      204 	end translate;
      205 
      206 erase:	proc;
      207 						/* ** ERASE/KILL PROCESSING ** */
      208 	     old_sourcep = source_ptr;
      209 	     old_targetp = target_ptr;
      210 	     if entry = output then do;
      211 		util.ctally = 0;
      212 		target_len = 0;
      213 		util.stringl = source_len ;
      214 		util.stringp = source_ptr;
      215 	     end;
      216 	     else do;
      217 		util.stringl = source_len;
      218 		util.stringp = source_ptr;
      219 	     end;
      220 						/* kill first */
      221 	     xr = 0;
      222 	     do while (xr < util.stringl);
      223 						/* search from the right, only last kill is interesting */
      224 		xr = util.stringl - index (reverse (based_string), kill_char);
      225 		if xr < util.stringl		/* found one */
      226 		then do;
      227 		     xr = xr + 1;			/* makes xr actual index of kill */
      228 		     if ^escaped ()			/* it's a real kill */
      229 		     then do;
      230 			source_ptr,
      231 			     util.stringp = addr (util.stringp -> based_chars (xr)); /* point to char after kill */
      232 			source_len = source_len - xr;
      233 			xr = util.stringl;		/* so as not to index again */
      234 		     end;
      235 		     else do;			/* it was escaped, we must scan rest of string */
      236 			util.stringl = xr - 2;
      237 			xr = 0;
      238 		     end;
      239 		end;
      240 	     end;					/* finished with kills */
      241 						/* now erase */
      242 	     util.stringl = source_len;
      243 	     target_len = 0;
      244 	     xr = 1;
      245 	     do while (xr ^= 0 & util.stringl > 0);
      246 		xr = index (based_string, erase_char);	/* look for first erase */
      247 		if xr = 1				/* first char */
      248 		then do;
      249 		     if target_len ^= 0		/* if not first char in whole string */
      250 		     then do;			/* we have to erase some already copied chars */
      251 			bx = verify (reverse (based_target), right_motion); /* skip white space */
      252 			if bx = 0			/* all white */
      253 			then do;
      254 			     target_ptr = old_targetp; /* wipe it all out */
      255 			     target_len = 0;
      256 			end;
      257 			else do;
      258 			     if bx ^= 1		/* there's some white space */
      259 			     then util.ctally = bx - 1; /* we'll erase it all */
      260 						/* no white, check for overstrikes */
      261 			     else do util.ctally = 1 to target_len - 2 by 2
      262 				     while (substr (based_target, target_len-util.ctally, 1) = bs);
      263 			     end;
      264 			     target_len = target_len - util.ctally;
      265 			     target_ptr = addr (old_targetp -> based_chars (target_len));
      266 			end;
      267 		     end;
      268 		     if target_len <= 0		/* we erased whole target string */
      269 		     then source_len = util.stringl - 1;
      270 		end;
      271 						/* not first char, see if it's escaped */
      272 		else
      273 		if xr ^= 0
      274 		then do;
      275 		     if escaped ()
      276 		     then util.ctally = xr;		/* copy everything */
      277 		     else do;
      278 			bx = verify (reverse (substr (based_string, 1, xr-1)), right_motion);
      279 			if bx = 0			/* all white */
      280 			then util.ctally = 0;	/* copy nothing */
      281 			else if bx ^= 1		/* some white */
      282 			then util.ctally = xr - bx;	/* which will not be copied */
      283 			else do util.ctally = xr - 2 to 2 by -2
      284 				while (substr (based_string, util.ctally, 1) = bs);
      285 			end;
      286 		     end;
      287 		     if util.ctally > 0
      288 		     then call copy_chars;
      289 		     else source_len = source_len - xr;
      290 		end;
      291 		if xr > 0				/* if we're going around again */
      292 		then do;
      293 		     source_ptr,
      294 			util.stringp = addr (util.stringp -> based_chars (xr)); /* point past erase */
      295 		     util.stringl = util.stringl - xr;
      296 		end;
      297 	     end;					/* end of erase search */
      298 	     if target_len > 0			/* if we moved any */
      299 	     then do;
      300 		if util.stringl > 0			/* if there are any more */
      301 		then do;
      302 		     util.ctally = util.stringl;
      303 		     call copy_chars;
      304 		end;
      305 		source_len = target_len ;
      306 		source_ptr = old_targetp;
      307 		target_ptr = old_sourcep;		/* switch buffers */
      308 	     end;
      309 	end erase;
      310 
      311 escape_output: proc;
      312 	     if tctp ^= null			/* must have output conversion table */
      313 	     & specp ^= null			/* and special chars table too */
      314 	     then do;
      315 		old_targetp = target_ptr;
      316 		old_sourcep = source_ptr;
      317 		chars_moved = "0"b;
      318 		util.tablep = tctp;
      319 		target_len = 0;			/* initially */
      320 		util.ctally = 0;
      321 		util.stringp = source_ptr;
      322 		util.stringl = source_len ;
      323 		do while (util.stringl > 0);		/* main formatting loop */
      324 		     call convert_string_util_$find_char (addr (util)); /* find next interesting character */
      325 		     if util.indicator = 0 & util.stringl = 0 & ^chars_moved then; /* nothing found */
      326 		     else do;
      327 			chars_moved = "1"b;		/* we'll have to do some moving */
      328 			if util.ctally > 0		/* we have some uninteresting ones to pick up */
      329 			then
      330 			     call copy_chars;	/* do it */
      331 						/* now examine indicator */
      332 			if util.indicator = 0	/* no interesting characters */
      333 			then;			/* otherwise go around again */
      334 			else if util.indicator = 3	/* tab or multiple blank */
      335 			then do;
      336 			     util.ctally = 1;
      337 			     do while (util.stringl > 0
      338 				     & (util.stringp -> based_onechar = space | util.stringp -> based_onechar = tab));
      339 				call copy_chars;
      340 				util.stringl = util.stringl - 1;
      341 				util.stringp = addr (util.stringp -> based_chars (1));
      342 			     end;
      343 			end;
      344 			else if util.indicator > 16 then do; /* special escape sequence */
      345 			     escape_index = util.indicator - 16;
      346 			     if escape_index > specp -> special_chars.escape_length /* not a good index */
      347 			     then goto table_error;
      348 			     if remote_ttt_info.edited then
      349 				seqp = addr (specp -> special_chars.edited_escapes (escape_index));
      350 			     else seqp = addr (specp -> special_chars.not_edited_escapes (escape_index));
      351 			     call insert_sequence ;
      352 
      353 			end;
      354 			else goto table_error;
      355 			if util.stringl > 0		/* if we're going around again */
      356 			then source_ptr = util.stringp; /* update source pointer */
      357 		     end;
      358 		end;
      359 		if target_len ^= 0
      360 		then do;
      361 		     source_ptr = old_targetp;
      362 		     source_len = target_len ;
      363 		     target_ptr = old_sourcep;
      364 		end;
      365 	     end;
      366 	     return;
      367 	end escape_output;
      368 
      369 escape_input: proc;
      370 						/* ** ESCAPE AND BREAK PROCESSING ** */
      371 	     if tctp ^= null			/* can't do this without input conversion table */
      372 	     then do;
      373 		old_targetp = target_ptr;
      374 		target_len = 0;
      375 		break_found = "0"b;
      376 		util.stringp = source_ptr;
      377 		util.stringl = source_len;
      378 		util.tablep = tctp;
      379 		do while (util.stringl > 0);
      380 		     call convert_string_util_$tct (addr (util)); /* scan string */
      381 		     if util.indicator = 0 & util.stringl = 0 & target_len = 0 /* never no nothing */
      382 		     then;
      383 		     else do;			/* there's work to do */
      384 			if util.ctally > 0		/* copy uninteresting characters */
      385 			then do;
      386 			     old_sourcep = source_ptr;
      387 			     call copy_chars;
      388 			end;
      389 			if util.indicator = 0
      390 			then;
      391 			else
      392 			if util.indicator = 1	/* break char */
      393 			then do;
      394 			     break_found = "1"b;	/* it can't be escaped or we'd have found the escape */
      395 			     if util.ctally > 0	/* scan back for preceding white space */
      396 			     then do;
      397 				bx = verify (reverse (substr (based_source, 1, util.ctally)), right_motion) - 1;
      398 				if bx < 0		/* all white */
      399 				then bx = util.ctally;
      400 				if bx > 0		/* any white */
      401 				then do;
      402 				     target_len = target_len - bx;
      403 				     target_ptr = addr (old_targetp -> based_chars (target_len));
      404 				end;
      405 			     end;
      406 						/* target_ptr shows where to put nl now in any case */
      407 			     go to insert_and_update;
      408 			end;
      409 			else
      410 			if util.indicator = 2	/* escape char */
      411 			then do;
      412 			     if util.stringl <= 1	/* there's nothing after it */
      413 			     then go to insert_and_update;
      414 			     if util.ctally > 0	/* check for overstruck escape */
      415 			     then do;
      416 				i = -1;		/* necessary to make compiler accept next statement */
      417 				if util.stringp -> based_chars (i) = bs
      418 				then go to insert_and_update;
      419 			     end;
      420 			     next_char = util.stringp -> based_chars (1);
      421 			     if next_char = bs
      422 			     then go to insert_and_update;
      423 			     if util.stringl > 2	/* check for following character overstruck */
      424 			     then if util.stringp -> based_chars (2) = bs
      425 				then go to insert_and_update;
      426 			     if tctp -> table (addr (next_char) -> based_fb8) = 2 | /* next char is escape */
      427 			     next_char = erase_char |
      428 			     next_char = kill_char
      429 			     then do;
      430 				util.stringp = addr (util.stringp -> based_chars (1)); /* skip over escape */
      431 				util.stringl = util.stringl - 1;
      432 				go to insert_and_update; /* put in following char as is */
      433 			     end;
      434 						/* check for octal escape */
      435 			     digit = char_value (next_char);
      436 			     if digit >= 0
      437 			     then do;		/* we have octal digit(s) */
      438 				octal.result = 0;
      439 				util.stringp = addr (util.stringp -> based_chars (1)); /* look at next */
      440 				do i = 1 to 3 while (digit >= 0);
      441 				     octal.result = 8*octal.result + digit;
      442 				     if util.stringl > i & i < 3
      443 				     then do;
      444 					digit = char_value ((util.stringp -> based_chars (i)));
      445 					if digit >= 0 /* next char is digit, see if it's overstruck */
      446 					then if util.stringl > i + 1
      447 					     then if util.stringp -> based_chars (i+1) = bs
      448 						then digit = -1;
      449 				     end;
      450 				     else digit = -1; /* no more chars, or we already have 3 */
      451 				end;
      452 				call insert_char ((addr (octal.result) -> based_one_char));
      453 				util.stringp = addr (util.stringp -> based_chars (i-1)); /* skip over octal digits */
      454 				util.stringl = util.stringl - i;
      455 			     end;
      456 						/* check for escaped nl with white space */
      457 			     else
      458 			     if verify (substr (based_string, 2, util.stringl-2), right_motion) = 0
      459 			     & substr (based_string, util.stringl, 1) = nl
      460 			     then do;
      461 				if util.stringl = source_len /* first thing in the string? */
      462 				then source_len = 0; /* then nothing */
      463 				util.stringl = 0;	/* we've reached end */
      464 			     end;
      465 			     else do;		/* look up next_char in input escape table */
      466 				if specp = null	/* no table means no escapes */
      467 				| specp -> special_chars.input_escapes.len = 0
      468 				then go to insert_and_update;
      469 				xr = index (specp -> special_chars.input_escapes.str, next_char);
      470 				if xr ^= 0	/* it's there */
      471 				then do;
      472 				     call insert_char ((substr (specp -> special_chars.input_results.str,
      473 					xr, 1)));
      474 				     util.stringp = addr (util.stringp -> based_chars (2)); /* move ptr */
      475 				     util.stringl = util.stringl - 2;
      476 				end;
      477 				else go to insert_and_update;
      478 			     end;
      479 			end;			/* of escape character */
      480 			else
      481 			if util.indicator = 3	/* throw away */
      482 			then call skip (1);
      483 			else
      484 			if util.indicator = 4	/* form feed */
      485 			then do;
      486 insert_and_update:
      487 			     call insert_char ((util.stringp -> based_one_char));
      488 			     util.stringp = addr (util.stringp -> based_chars (1));
      489 			     util.stringl = util.stringl - 1;
      490 			end;
      491 			else
      492 			if util.indicator = 5	/* hardware control sequence */
      493 			then ;
      494 			else goto table_error;	/* what else could it be? */
      495 			source_ptr = util.stringp;
      496 		     end;
      497 		end;				/* of tct loop */
      498 		if target_len ^= 0
      499 		then do;
      500 		     source_ptr = old_targetp;
      501 		     source_len = target_len;
      502 		end;
      503 	     end;
      504 	end escape_input;
      505 
      506 /* ** INTERNAL PROCEDURES ** */
      507 copy_chars: proc;
      508 
      509 /* this procedure copies util.ctally characters from source_ptr to target_ptr. It updates both pointers */
      510 /* and increments target_len by util.ctally */
      511 
      512 dcl  tally_chars char (util.ctally) based;
      513 
      514 	     target_ptr -> tally_chars = source_ptr -> tally_chars;
      515 
      516 	     source_ptr = addr (source_ptr -> based_chars (util.ctally));
      517 	     target_ptr = addr (target_ptr -> based_chars (util.ctally));
      518 	     target_len = target_len + util.ctally;
      519 
      520 	     return;
      521 
      522 	end copy_chars;
      523 
      524 insert_char: proc (i_char);
      525 
      526 /* this procedure inserts one character at target_ptr, and increments target_ptr and target_len by one character */
      527 
      528 dcl  i_char char (1) ;
      529 
      530 	     target_ptr -> based_one_char = i_char;
      531 	     target_ptr = addr (target_ptr -> based_chars (1));
      532 	     target_len = target_len + 1;
      533 	     return;
      534 
      535 	end insert_char;
      536 
      537 skip:	proc (to_skip);
      538 
      539 /* this procedure discards a specified number of characters from util.stringp */
      540 
      541 dcl  to_skip fixed bin;
      542 
      543 	     util.stringp = addr (util.stringp -> based_chars (to_skip)); /* skip over character */
      544 	     if source_len = util.stringl		/* if it's first character in the string */
      545 	     then source_len = source_len - to_skip;	/* then make sure it doesn't get picked up */
      546 	     util.stringl = util.stringl - to_skip;
      547 	end skip;
      548 
      549 escaped:	proc returns (bit (1) aligned);
      550 
      551 /* this procedure returns "1"b if the character at index xr in the string based on util.stringp */
      552 /* is preceded by a non-overstruck escape character; otherwise it returns "0"b */
      553 
      554 	     if xr <= 1				/* no preceding character */
      555 	     then return ("0"b);
      556 
      557 	     if tctp = null				/* no conversion table so no escapes */
      558 	     then return ("0"b);
      559 
      560 	     if tctp -> table (addr (substr (based_string, xr-1, 1)) -> based_fb8) ^= 2 /* not preceded by an escape */
      561 	     then return ("0"b);
      562 
      563 	     if xr = 2				/* escape can't be overstruck, it's first char */
      564 	     then return ("1"b);
      565 
      566 	     if substr (based_string, xr-2, 1) = bs	/* escape is overstruck */
      567 	     then return ("0"b);
      568 
      569 	     else return ("1"b);
      570 
      571 	end escaped;
      572 
      573 char_value: proc (a_char) returns (fixed bin);
      574 
      575 /* this procedure returns the numeric equivalent of an ASCII character if the character is 0 to 7; */
      576 /* otherwise it returns -1 */
      577 
      578 dcl  a_char char (1) aligned;
      579 dcl  numeric fixed bin;
      580 
      581 	     numeric = addr (a_char) -> based_fb8;
      582 	     if numeric >= 48			/* i.e., "0" */
      583 	     & numeric <= 55			/* i.e., "7" */
      584 	     then return (numeric - 48);
      585 
      586 	     else return (-1);
      587 
      588 	end char_value;
      589 insert_sequence: proc ;
      590 
      591 /* This procedure inserts the character sequence pointed to by seqp */
      592 
      593 dcl  i fixed bin;
      594 
      595 	     if seq.count = 0
      596 	     then return;				/* no sequence */
      597 
      598 	     if seq.count < 0 | seq.count > hbound (seq.chars, 1)	/* probably not a real sequence */
      599 	     then go to table_error;
      600 
      601 	     target_len = target_len + seq.count;
      602 
      603 	     do i = 1 to seq.count;
      604 		target_ptr -> based_onechar = seqp -> seq.chars (i);
      605 		target_ptr = addr (target_ptr -> based_chars (1)); /* bump pointer */
      606 	     end;
      607 
      608 	     return;
      609 
      610 	end insert_sequence ;
      611      end convert_string_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/17/88  1032.3  convert_string_.pl1               >spec>install>MR12.2-1171>convert_string_.pl1
136          1    08/03/78  2021.0  remote_ttt_info.incl.pl1          >ldd>include>remote_ttt_info.incl.pl1
137          2    08/29/75  1310.5  prt_info.incl.pl1                 >ldd>include>prt_info.incl.pl1
138          3    02/04/88  2009.3  prt_conv_info.incl.pl1            >ldd>include>prt_conv_info.incl.pl1
139          4    10/17/88  1024.1  tty_convert.incl.pl1              >spec>install>MR12.2-1171>tty_convert.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_char                                 parameter       char(1)                  dcl 578 set ref 573 581
addr                                                   builtin function         dcl 134 ref 159 160 193 194 195 196 198 198 200 201
                                                                                  230 265 293 324 324 341 348 350 380 380 403 426
                                                                                  430 439 452 453 474 488 516 517 531 543 560 581
                                                                                  605
backspace                       002152 constant        char(1)                  initial packed unaligned dcl 77 ref 177
based_chars                            based           char(1)                  array packed unaligned dcl 114 set ref 230 265 293
                                                                                  341 403 417 420 423 430 439 444 445 453 474 488
                                                                                  516 517 531 543 605
based_fb8                              based           fixed bin(8,0)           packed unaligned dcl 122 ref 426 560 581
based_one_char                         based           char(1)                  packed unaligned dcl 115 set ref 452 486 530*
based_onechar                          based           char(1)                  packed unaligned dcl 98 set ref 337 337 604*
based_ret                              based           char                     packed unaligned dcl 117 ref 177 183
based_source                           based           char                     packed unaligned dcl 118 ref 397
based_string                           based           char                     packed unaligned dcl 116 set ref 224 246 278 283 457
                                                                                  457 560 566
based_target                           based           char                     packed unaligned dcl 119 ref 251 261
break_found                     000665 automatic       bit(1)                   packed unaligned dcl 45 set ref 375* 394*
bs                              002152 constant        char(1)                  initial dcl 94 ref 261 283 417 421 423 445 566
buffer_1                        000114 automatic       char(720)                dcl 42 set ref 157* 159
buffer_2                        000400 automatic       char(720)                dcl 43 set ref 158* 160
bx                              000704 automatic       fixed bin(17,0)          dcl 55 set ref 251* 252 258 258 278* 279 281 281
                                                                                  397* 398 398* 400 402
c_chars                                based           structure                level 1 dcl 4-54
canonicalize_                   000012 constant        entry                    external dcl 103 ref 177
canonicalize_input        0(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 177
chars                     0(09)        based           char(1)                  array level 2 packed packed unaligned dcl 59 ref 598
                                                                                  604
chars_moved                     000666 automatic       bit(1)                   packed unaligned dcl 46 set ref 317* 325 327*
code                                   parameter       fixed bin(35,0)          dcl 34 set ref 141 148 177* 186*
convert_string_util_$find_char  000010 constant        entry                    external dcl 102 ref 324
convert_string_util_$mvt        000016 constant        entry                    external dcl 105 ref 198
convert_string_util_$tct        000014 constant        entry                    external dcl 104 ref 380
count                                  based           fixed bin(8,0)           level 2 packed packed unaligned dcl 59 ref 595 598
                                                                                  598 601 603
cr                                     constant        char(1)                  initial packed unaligned dcl 80 ref 177
ctally                    3     000710 automatic       fixed bin(17,0)          level 2 dcl 65 set ref 211* 258* 261* 261* 264 275*
                                                                                  279* 281* 283* 283* 287 302* 320* 328 336* 384 395
                                                                                  397 398 414 514 514 516 517 518
cv_trans                               based           structure                level 1 dcl 4-62
delay                                  based           structure                level 1 dcl 4-66
digit                           000664 automatic       fixed bin(17,0)          dcl 44 set ref 435* 436 440 441 444* 445 445* 450*
edited                    0(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 348
edited_escapes                         based           structure                array level 2 dcl 4-26 set ref 348
entry                           000112 automatic       fixed bin(17,0)          dcl 40 set ref 143* 150* 164 210
erase_char               12            based           char(1)                  level 2 in structure "remote_ttt_info" dcl 1-6
                                                                                  in procedure "convert_string_" ref 155
erase_char                      000111 automatic       char(1)                  packed unaligned dcl 39 in procedure
                                                                                  "convert_string_" set ref 155* 246 426
erase_input               0(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 175
error_table_$improper_data_format
                                000020 external static fixed bin(35,0)          dcl 109 ref 186
escape_index                    000113 automatic       fixed bin(17,0)          dcl 41 set ref 345* 346 348 350
escape_input              0(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 173
escape_length            54            based           fixed bin(17,0)          level 2 dcl 4-26 ref 346 348 466 466 469 469 469 469
                                                                                  472 472 472 472 472 472
escape_output                          based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 165
i                               001022 automatic       fixed bin(17,0)          dcl 593 in procedure "insert_sequence" set ref 603*
                                                                                  604*
i                               000705 automatic       fixed bin(17,0)          dcl 56 in procedure "convert_string_" set ref 416*
                                                                                  417 440* 442 442 444 445 445* 453 454
i_char                                 parameter       char(1)                  packed unaligned dcl 528 ref 524 530
index                                                  builtin function         dcl 134 ref 177 224 246 469
indicator                 6     000710 automatic       fixed bin(17,0)          level 2 dcl 65 set ref 325 332 334 344 345 381 389
                                                                                  391 409 480 483 491
input                                  constant        fixed bin(17,0)          initial dcl 81 ref 143
input_escapes                          based           structure                level 2 dcl 4-26
input_mvtp               14            based           pointer                  level 3 dcl 1-6 ref 144
input_results                          based           structure                level 2 dcl 4-26
input_string                           parameter       varying char             dcl 28 ref 141 148 157 161
input_tctp               20            based           pointer                  level 3 dcl 1-6 ref 145
kill_char                11            based           char(1)                  level 2 in structure "remote_ttt_info" dcl 1-6
                                                                                  in procedure "convert_string_" ref 156
kill_char                       000110 automatic       char(1)                  packed unaligned dcl 38 in procedure
                                                                                  "convert_string_" set ref 156* 224 426
len                                    based           fixed bin(8,0)           level 3 packed packed unaligned dcl 4-26 ref 466 469
                                                                                  472 472
length                                                 builtin function         dcl 134 ref 161
mvt_args                               based           structure                level 1 dcl 124
mvtp                            000104 automatic       pointer                  dcl 32 set ref 144* 151* 191 195
next_char                       000706 automatic       char(1)                  dcl 57 set ref 420* 421 426 426 426 435* 469
nl                              002153 constant        char(1)                  initial dcl 90 ref 457
not_edited_escapes       55            based           structure                array level 2 dcl 4-26 set ref 350
null                                                   builtin function         dcl 134 ref 191 312 312 371 466 557
numeric                         001012 automatic       fixed bin(17,0)          dcl 579 set ref 581* 582 582 582
octal                           000707 automatic       structure                level 1 dcl 61
old_sourcep                     000674 automatic       pointer                  dcl 49 set ref 208* 307 316* 363 386* 397
old_targetp                     000676 automatic       pointer                  dcl 50 set ref 209* 251 254 261 265 306 315* 361
                                                                                  373* 403 500
output                                 constant        fixed bin(17,0)          initial dcl 82 ref 150 164 210
output_mvtp              16            based           pointer                  level 3 dcl 1-6 ref 151
output_string                          parameter       varying char             dcl 29 set ref 141 148 183*
output_tctp              22            based           pointer                  level 3 dcl 1-6 ref 152
remote_ttt_info                        based           structure                level 1 dcl 1-6
result                    0(27) 000707 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 61 set ref 438*
                                                                                  441* 441 452
ret_len                         000701 automatic       fixed bin(17,0)          dcl 52 set ref 182*
reverse                                                builtin function         dcl 134 ref 224 251 278 397
right_motion                           constant        char(2)                  initial dcl 86 ref 251 278 397 457
rttp                                   parameter       pointer                  dcl 1-3 ref 141 144 145 148 151 152 153 155 156 165
                                                                                  167 171 173 175 177 348
seq                                    based           structure                level 1 dcl 59
seqp                            000102 automatic       pointer                  dcl 31 set ref 348* 350* 595 598 598 598 601 603 604
source_len                      000700 automatic       fixed bin(17,0)          dcl 51 set ref 161* 177 177* 177* 182 183 194 202
                                                                                  213 217 232* 232 242 268* 289* 289 305* 322 362*
                                                                                  377 397 461 461* 501* 544 544* 544
source_ptr                      000670 automatic       pointer                  dcl 47 set ref 159* 162 177 177* 177* 183 193 200*
                                                                                  208 214 218 230* 293* 306* 316 321 355* 361* 376
                                                                                  386 495* 500* 514 516* 516
space                                  constant        char(1)                  initial packed unaligned dcl 78 ref 337
special_chars                          based           structure                level 1 dcl 4-26
specp                    24            based           pointer                  level 3 in structure "remote_ttt_info" dcl 1-6
                                                                                  in procedure "convert_string_" ref 153
specp                           000100 automatic       pointer                  dcl 30 in procedure "convert_string_" set ref 153*
                                                                                  312 346 348 350 466 466 469 472
str                                    based           char                     level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 4-26 in procedure "convert_string_"
                                                                                  ref 472
str                                    based           char                     level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 4-26 in procedure "convert_string_"
                                                                                  ref 469
stringl                   2            based           fixed bin(17,0)          level 2 in structure "mvt_args" dcl 124 in procedure
                                                                                  "convert_string_" set ref 194*
stringl                   2     000710 automatic       fixed bin(17,0)          level 2 in structure "util" dcl 65 in procedure
                                                                                  "convert_string_" set ref 213* 217* 222 224 224
                                                                                  225 233 236* 242* 245 246 268 278 283 295* 295 300
                                                                                  302 322* 323 325 337 340* 340 355 377* 379 381 412
                                                                                  423 431* 431 442 445 454* 454 457 457 457 457 461
                                                                                  463* 475* 475 489* 489 544 546* 546 560 566
stringp                                based           pointer                  level 2 in structure "mvt_args" dcl 124 in procedure
                                                                                  "convert_string_" set ref 193* 201
stringp                         000710 automatic       pointer                  level 2 in structure "util" dcl 65 in procedure
                                                                                  "convert_string_" set ref 162* 214* 218* 224 230
                                                                                  230* 246 278 283 293 293* 321* 337 337 341* 341
                                                                                  355 376* 417 420 423 430* 430 439* 439 444 445
                                                                                  453* 453 457 457 474* 474 486 488* 488 495 543*
                                                                                  543 560 566
substr                                                 builtin function         dcl 134 ref 261 278 283 397 457 457 472 560 566
tab                                    constant        char(1)                  initial packed unaligned dcl 79 ref 177 337
table                                  based           fixed bin(8,0)           array packed unaligned dcl 120 ref 426 560
tablep                    4     000710 automatic       pointer                  level 2 in structure "util" dcl 65 in procedure
                                                                                  "convert_string_" set ref 318* 378*
tablep                    4            based           pointer                  level 2 in structure "mvt_args" dcl 124 in procedure
                                                                                  "convert_string_" set ref 195*
tally_chars                            based           char                     packed unaligned dcl 512 set ref 514* 514
target_len                      000702 automatic       fixed bin(17,0)          dcl 53 set ref 202* 212* 243* 249 251 255* 261 261
                                                                                  261 264* 264 265 268 298 305 319* 359 362 374* 381
                                                                                  402* 402 403 498 501 518* 518 532* 532 601* 601
target_ptr                      000672 automatic       pointer                  dcl 48 set ref 160* 196 201* 209 254* 265* 307* 315
                                                                                  363* 373 403* 514 517* 517 530 531* 531 604 605*
                                                                                  605
targetp                   6            based           pointer                  level 2 dcl 124 set ref 196* 200
tctp                            000106 automatic       pointer                  dcl 33 set ref 145* 152* 312 318 371 378 426 557 560
to_skip                                parameter       fixed bin(17,0)          dcl 541 ref 537 543 544 546
translate_input           0(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 171
translate_output          0(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-6 ref 167
ttt_bits                               based           structure                level 2 dcl 1-6
ttt_ptrs                 14            based           structure                level 2 dcl 1-6
util                            000710 automatic       structure                level 1 dcl 65 set ref 193 194 195 196 198 198 200
                                                                                  201 324 324 380 380
verify                                                 builtin function         dcl 134 ref 251 278 397 457
xr                              000703 automatic       fixed bin(17,0)          dcl 54 set ref 221* 222 224* 225 227* 227 230 232
                                                                                  233* 236 237* 244* 245 246* 247 272 275 278 281
                                                                                  283 289 291 293 295 469* 470 472 554 560 563 566

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CV_TRANS_SIZE                          internal static fixed bin(17,0)          initial array dcl 4-129
CV_TRANS_VERSION                       internal static fixed bin(17,0)          initial dcl 4-127
DELAY_VERSION                          internal static fixed bin(17,0)          initial dcl 4-126
INPUT_CONVERT_BREAK                    internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
INPUT_CONVERT_DISCARD                  internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
INPUT_CONVERT_DSA_CR_PROCESSING        internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
INPUT_CONVERT_ESCAPE                   internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
INPUT_CONVERT_FORMFEED                 internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
INPUT_CONVERT_ORDINARY                 internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
INPUT_CONVERT_PRECEDENCE_DISCARD       internal static fixed bin(8,0)           initial packed unaligned dcl 4-135
OUTPUT_CONVERT_BRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_BS                      internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_CR                      internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_DONT_SEND               internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_FF                      internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_FIRST_SPECIAL           internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_HT                      internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_NEWLINE                 internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_NOT_USED_13             internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_NOT_USED_14             internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_NOT_USED_15             internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_NOT_USED_16             internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_NO_MOTION               internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_OCTAL                   internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_ORDINARY                internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_PRECEDENCE_NO_MOTION    internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_RRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
OUTPUT_CONVERT_VT                      internal static fixed bin(8,0)           initial packed unaligned dcl 4-147
SPECIAL_INFO_STRUCT_VERSION_1          internal static char(8)                  initial packed unaligned dcl 4-122
SPECIAL_VERSION                        internal static fixed bin(17,0)          initial dcl 4-124
SPECIAL_VERSION_2                      internal static fixed bin(17,0)          initial dcl 4-125
c_chars_ptr                            automatic       pointer                  dcl 4-53
cv_trans_struc                         based           structure                level 1 dcl 4-107
delay_struc                            based           structure                level 1 dcl 4-112
get_special_info_struc                 based           structure                level 1 dcl 4-117
pci                                    based           structure                level 1 dcl 3-15
pcip                                   automatic       pointer                  dcl 3-13
pip                                    automatic       pointer                  dcl 2-5
prt_info                               based           structure                level 1 dcl 2-7
sc_escape_len                          automatic       fixed bin(17,0)          dcl 4-58
sc_input_escape_len                    automatic       fixed bin(17,0)          dcl 4-59
special_chars_struc                    based           structure                level 1 dcl 4-76

NAMES DECLARED BY EXPLICIT CONTEXT.
char_value                      001641 constant        entry                    internal dcl 573 ref 435 444
common                          000113 constant        label                    dcl 153 ref 146
convert_string_                 000013 constant        entry                    external dcl 12
copy_chars                      001505 constant        entry                    internal dcl 507 ref 287 303 328 339 387
erase                           000322 constant        entry                    internal dcl 206 ref 175
escape_input                    001022 constant        entry                    internal dcl 369 ref 173
escape_output                   000644 constant        entry                    internal dcl 311 ref 165
escaped                         001562 constant        entry                    internal dcl 549 ref 228 275
finish                          000257 constant        label                    dcl 184 ref 188
input                           000026 constant        entry                    external dcl 141
insert_and_update               001454 constant        label                    dcl 486 ref 407 412 417 421 423 432 466 470
insert_char                     001525 constant        entry                    internal dcl 524 ref 452 472 486
insert_sequence                 001660 constant        entry                    internal dcl 589 ref 351
output                          000062 constant        entry                    external dcl 148
skip                            001542 constant        entry                    internal dcl 537 ref 480
table_error                     000260 constant        label                    dcl 186 ref 344 346 491 598
translate                       000265 constant        entry                    internal dcl 190 ref 167 171

NAME DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 598

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2264        2306    2154        2274
Length      2556    2154        22         233     107           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
convert_string_                     585 external procedure  is an external procedure.  
translate                               internal procedure  shares stack frame of external procedure convert_string_.  
erase                                   internal procedure  shares stack frame of external procedure convert_string_.  
escape_output                           internal procedure  shares stack frame of external procedure convert_string_.  
escape_input                            internal procedure  shares stack frame of external procedure convert_string_.  
copy_chars                              internal procedure  shares stack frame of external procedure convert_string_.  
insert_char                             internal procedure  shares stack frame of external procedure convert_string_.  
skip                                    internal procedure  shares stack frame of external procedure convert_string_.  
escaped                                 internal procedure  shares stack frame of external procedure convert_string_.  
char_value                              internal procedure  shares stack frame of external procedure convert_string_.  
insert_sequence                         internal procedure  shares stack frame of external procedure convert_string_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_string_          000100 specp                       convert_string_
                         000102 seqp                        convert_string_
                         000104 mvtp                        convert_string_
                         000106 tctp                        convert_string_
                         000110 kill_char                   convert_string_
                         000111 erase_char                  convert_string_
                         000112 entry                       convert_string_
                         000113 escape_index                convert_string_
                         000114 buffer_1                    convert_string_
                         000400 buffer_2                    convert_string_
                         000664 digit                       convert_string_
                         000665 break_found                 convert_string_
                         000666 chars_moved                 convert_string_
                         000670 source_ptr                  convert_string_
                         000672 target_ptr                  convert_string_
                         000674 old_sourcep                 convert_string_
                         000676 old_targetp                 convert_string_
                         000700 source_len                  convert_string_
                         000701 ret_len                     convert_string_
                         000702 target_len                  convert_string_
                         000703 xr                          convert_string_
                         000704 bx                          convert_string_
                         000705 i                           convert_string_
                         000706 next_char                   convert_string_
                         000707 octal                       convert_string_
                         000710 util                        convert_string_
                         001012 numeric                     char_value
                         001022 i                           insert_sequence

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           ext_entry_desc      set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
canonicalize_                 convert_string_util_$find_char                              convert_string_util_$mvt
convert_string_util_$tct

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$improper_data_format




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000012       141 000020       143 000046       144 000050       145 000055       146 000057       148 000060
    150 000102       151 000104       152 000111       153 000113       155 000117       156 000121       157 000123
    158 000130       159 000133       160 000135       161 000137       162 000141       164 000142       165 000145
    167 000152       169 000160       171 000161       173 000166       175 000174       177 000202       182 000243
    183 000245       184 000257       186 000260       188 000264       190 000265       191 000266       193 000272
    194 000274       195 000276       196 000300       198 000302       200 000313       201 000315       202 000317
    204 000321       206 000322       208 000323       209 000325       210 000327       211 000332       212 000333
    213 000334       214 000336       215 000337       217 000340       218 000342       221 000343       222 000344
    224 000347       225 000365       227 000367       228 000370       230 000375       232 000403       233 000405
    234 000407       236 000410       237 000413       240 000414       242 000415       243 000417       244 000420
    245 000422       246 000426       247 000440       249 000442       251 000444       252 000457       254 000460
    255 000461       256 000462       258 000463       261 000470       263 000510       264 000513       265 000515
    268 000521       270 000526       272 000527       275 000531       278 000541       279 000557       281 000562
    283 000570       285 000604       287 000607       289 000613       291 000615       293 000617       295 000624
    297 000626       298 000627       300 000631       302 000633       303 000634       305 000635       306 000637
    307 000641       309 000643       311 000644       312 000645       315 000655       316 000657       317 000661
    318 000662       319 000664       320 000665       321 000666       322 000670       323 000672       324 000674
    325 000705       327 000714       328 000716       332 000721       334 000724       336 000726       337 000730
    339 000743       340 000744       341 000746       342 000752       343 000753       344 000754       345 000756
    346 000760       348 000763       350 001001       351 001004       355 001005       358 001011       359 001012
    361 001014       362 001016       363 001017       366 001021       369 001022       371 001023       373 001027
    374 001031       375 001032       376 001033       377 001035       378 001037       379 001041       380 001044
    381 001055       384 001064       386 001066       387 001070       389 001071       391 001074       394 001076
    395 001100       397 001102       398 001114       400 001117       402 001120       403 001122       407 001126
    409 001127       412 001131       414 001134       416 001136       417 001140       420 001145       421 001152
    423 001156       426 001165       430 001206       431 001212       432 001214       435 001215       436 001217
    438 001221       439 001223       440 001227       441 001237       442 001245       444 001253       445 001262
    449 001300       450 001301       451 001303       452 001305       453 001312       454 001320       455 001322
    457 001323       461 001345       463 001351       464 001352       466 001353       469 001373       470 001414
    472 001415       474 001434       475 001440       479 001442       480 001443       483 001452       486 001454
    488 001463       489 001467       490 001471       491 001472       495 001474       497 001476       498 001477
    500 001501       501 001503       504 001504       507 001505       514 001506       516 001514       517 001517
    518 001522       520 001524       524 001525       530 001527       531 001534       532 001540       533 001541
    537 001542       543 001544       544 001550       546 001556       547 001561       549 001562       554 001564
    557 001571       560 001577       563 001622       566 001630       569 001636       573 001641       581 001643
    582 001646       586 001655       589 001660       595 001661       598 001666       601 001671       603 001672
    604 001701       605 001706       606 001712       608 001714


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
