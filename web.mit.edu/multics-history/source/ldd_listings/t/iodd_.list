	COMPILATION LISTING OF SEGMENT iodd_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/14/88  1103.1 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4 */
       13 
       14 /* format: off */
       15 
       16 iodd_: proc;
       17 
       18 /* This is not the main entry point.  It is used to set the entry variable for
       19*   the driver module default handler if that entry was not defined.  We have
       20*   to be able to call something! */
       21 
       22 	return;
       23 
       24 
       25 iodd_init: entry (system_dir, testing);
       26 
       27 /* This is the initialization procedure for all IO Daemon drivers.  It is
       28*   called with two arguments: system_dir which defines the directory which
       29*   will contain the common IO Daemon data bases; and testing, which indicates
       30*   that the driver is being run in test mode.  This procedure determines from
       31*   the site operator which device is to be used, establishes communication
       32*   with the IO Coordinator, attaches the device control terminal if needed,
       33*   and transfers to the driver control procedure specified in the iod_tables
       34*   source file.
       35*
       36*   The design was adapted from the original IO Daemon driver designed by
       37*   Robert S. Coren in September 1973.  This design is provided to make the
       38*   IO Daemon compatible with the Access Isolation Mechanism.
       39*
       40*   Coded in January 1975 by J. C. Whitmore.
       41*
       42*   Modified in November 1975 by M. A. Braida
       43*   to initialize data for seg_fault_error check.   */
       44 /* Modified Nov 1977 by J. C. Whitmore for new iodd_static data, initiation of rqti segs, and condition handling */
       45 /* Modified Mar 1978 by J. C. Whitmore for upgrade and addition of per RQT accounting and rqti seg from iod_tables */
       46 /* Modified by J. C. Whitmore, 7/78, to setup for new driver -> coord command strategy & "x" cmd */
       47 /* Modified by J. C. Whitmore, 10/78, to extend number of RJE stations (version 3 iod_tables format) */
       48 /* Modified by J. C. Whitmore, 11/78, to start using driver version numbers starting at 5.0 (5 major changes since MR 6.0) */
       49 /* Modified by J. C. Whitmore, 3/79 (V-5.1),  for minor message and logic bug fixes */
       50 /* Modified by J. C. Whitmore, 5/79 (V-5.2), to retry listen attachment 5 times before aborting */
       51 /* Modified by C. Hornig, 8/79 (V-5.3), for multiple minor devices of the same generic type */
       52 /* Modified by J. C. Whitmore, 10/79 (V-5.4), for daemon_idle default condition handler */
       53 /* Modified by E. N. Kittlitz, 6/81 (V-5.5), for UNCA rate structures */
       54 /* Modified:  November 1981 by G. Palter, V-5.6, to use read_password_ to get the station password if it is omitted from
       55*   the station command, to not consider inability to set hangup_proc as fatal, to call head_sheet_$test when in a test
       56*   environment, FILL IN THE BLANK, and fix the following bugs from the I/O daemon error list:
       57*      0032: phx11372
       58*         When running an I/O daemon in test mode with the coordinator and driverin the same process, printing a single
       59*         request, exiting the I/O daemon, re-entering the I/O daemon, and printing another request will cause the
       60*         head/tail sheets of the first request to be printed surrounding the file specified in the second request */
       61 /* Modified January 1982 by E. N. Kittlitz (V-5.7) for accounting change.
       62*      accounting:nothing; in the IODT will really do nothing in io_daemon_account_. */
       63 /* Modified January 1983 by C. Marker  Added probe as a legal command in test mode. */
       64 /* Modified 1984-08-17 by E. Swenson for Version 2 PNTs. */
       65 /* Modified February 23, 1985 by C. Marker to use version 5 message segments */
       66 
       67 
       68 /****^  HISTORY COMMENTS:
       69*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
       70*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
       71*     Add support for logout_on_hangup.
       72*  2) change(88-02-18,Brunelle), approve(88-06-02,MCR7911),
       73*     audit(88-10-19,Wallman), install(88-11-08,MR12.2-1199):
       74*     Upgraded to version 5 iod tables.  Add support for head/tail_sheet entry
       75*     variables and paper_type variable.  Remove calls to head_sheet_$init &
       76*     tail_sheet_$init.
       77*  3) change(88-11-03,Brunelle), approve(88-11-03,MCR7911),
       78*     audit(88-11-03,Wallman), install(88-11-08,MR12.2-1199):
       79*     Corrected a pass-by-value problem which was causing control terminal i/o
       80*     to go to the message coordinator.
       81*  4) change(88-11-11,Brunelle), approve(88-11-03,PBF7911),
       82*     audit(88-11-14,Wallman), install(88-11-14,MR12.2-1212):
       83*     Add a 10 second wait in all non-IOM configurations to allow the
       84*     answering service at both ends of the communications line to handle
       85*     all the traffic generated when a re_init is signalled.
       86*                                                   END HISTORY COMMENTS */
       87 
       88 
       89 /* format: on */
       90 
       91 /* ----------- ARGUMENTS ------------- */
       92 
       93 dcl  system_dir char (*),				/* directory containing common data bases */
       94      testing bit (1) aligned;				/* test mode indicator */
       95 
       96 
       97 /* --------EXTERNAL ENTRIES---------- */
       98 
       99 dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      100 dcl  charge_user_ entry (char (*), char (*), ptr, fixed bin (35));
      101 dcl  convert_dial_message_
      102 	entry (fixed bin (71), char (*) aligned, char (*) aligned, fixed bin, 1 aligned like status_flags,
      103 	fixed bin (35));
      104 dcl  convert_ipc_code_ entry (fixed bin (35));
      105 dcl  continue_to_signal_ entry (fixed bin (35));
      106 dcl  cv_entry_ entry (char (*), ptr, fixed bin (35)) returns (entry);
      107 dcl  debug entry options (variable);
      108 dcl  dial_manager_$allow_dials entry (ptr, fixed bin (35));
      109 dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
      110 dcl  dial_manager_$release_channel entry (ptr, fixed bin (35));
      111 dcl  get_at_entry_ entry (char (*), char (*) aligned, char (*) aligned, char (*)) returns (fixed bin (35));
      112 dcl  get_group_id_ entry () returns (char (32));
      113 dcl  get_group_id_$tag_star entry () returns (char (32));
      114 dcl  get_process_id_ entry () returns (bit (36));
      115 dcl  get_authorization_ entry () returns (bit (72) aligned);
      116 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      117 dcl  hcs_$make_ptr entry (ptr, char (*), char (*), ptr, fixed bin (35));
      118 dcl  hcs_$terminate_name entry (char (*), fixed bin (35));
      119 dcl  hcs_$terminate_file entry (char (*), char (*) aligned, fixed bin (1), fixed bin (35));
      120 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
      121 dcl  hcs_$tty_index entry (char (*) aligned, fixed bin, fixed bin, fixed bin (35));
      122 dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      123 dcl  head_sheet_$print_head_sheet entry (ptr, ptr, ptr, fixed bin (35));
      124 dcl  head_sheet_$print_separator entry (ptr, ptr, char (*), fixed bin (35));
      125 dcl  head_sheet_$test entry (char (*));
      126 dcl  ioa_$ioa_stream entry () options (variable);
      127 dcl  ioa_$rsnnl entry () options (variable);
      128 dcl  io_daemon_account_$set_line_prices entry (fixed bin, ptr, fixed bin (35));
      129 dcl  iodd_command_processor_$init entry (ptr);
      130 dcl  iodd_hangup_$iodd_hangup_ entry (ptr);
      131 dcl  iodd_msg_ entry options (variable);
      132 dcl  iodd_quit_handler_$init entry (ptr);
      133 dcl  iodd_signal_handler_ entry;
      134 dcl  iodd_signal_handler_$init entry (ptr);
      135 dcl  ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
      136 dcl  ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
      137 dcl  ios_$write entry (char (*) aligned, ptr, fixed bin, fixed bin, fixed bin, bit (72) aligned);
      138 dcl  ios_$order entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned);
      139 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
      140 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
      141 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
      142 dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), ptr, ptr, fixed bin, fixed bin (35));
      143 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
      144 dcl  ipc_$decl_ev_wait_chn entry (fixed bin (71), fixed bin (35));
      145 dcl  logout entry () options (variable);
      146 dcl  message_segment_$add_file entry (char (*), char (*), ptr, fixed bin, bit (72) aligned, fixed bin (35));
      147 dcl  iodd_parse_$command entry (char (*), ptr, fixed bin (35));
      148 dcl  probe entry options (variable);
      149 dcl  print_devices entry options (variable);		/* command for data in iod tables */
      150 dcl  print_line_ids entry options (variable);		/*	"	"	*/
      151 dcl  read_password_$switch entry (ptr, ptr, char (*), char (*), fixed bin (35));
      152 dcl  scramble_ entry (char (8)) returns (char (8));
      153 dcl  set_iod_val entry options (variable);
      154 dcl  set_lock_$lock entry (bit (36) aligned, fixed bin, fixed bin (35));
      155 dcl  tail_sheet_$print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35));
      156 dcl  timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry);
      157 dcl  timer_manager_$reset_alarm_call entry (entry);
      158 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
      159 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      160 dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
      161 dcl  validate_card_input_$station entry (char (*), char (*), char (*), fixed bin (35));
      162 dcl  write_control_form_$init entry (ptr);
      163 
      164 
      165 /* --------- AUTOMATIC ----------- */
      166 
      167 dcl  code fixed bin (35);
      168 dcl  dev_label char (32);
      169 dcl  dev_class char (32);
      170 dcl  queue_type char (32);				/* queue_type when we need to look for it */
      171 dcl  request_type char (64);
      172 dcl  table_time fixed bin (71);
      173 dcl  first_arg char (32);
      174 dcl  second_arg char (64);
      175 dcl  dev_name char (32) aligned;
      176 dcl  dim_name char (32) aligned;
      177 dcl  (i, j) fixed bin;				/* index variables */
      178 dcl  ig char (4);					/* dummy for get_at_entry_ call */
      179 dcl  io_stat bit (72) aligned;
      180 dcl  line char (120);
      181 dcl  nchars fixed bin (21);
      182 dcl  init_ev_chan fixed bin (71);
      183 dcl  iodc_data_ptr ptr;
      184 dcl  seg_name char (32);				/* temp for segment initialization */
      185 dcl  question char (64);				/* question to ask operator */
      186 dcl  use_default bit (1);				/* switch indicating that default device classes are used */
      187 dcl  msgp ptr;					/* pointer to the event message */
      188 dcl  message_id bit (72) aligned;			/* id if a message segment message */
      189 dcl  driver_dir char (168);				/* path of driver major device directory */
      190 dcl  rqt_name char (32);
      191 dcl  rqt_string char (168) var;
      192 dcl  rqti_dir char (168);				/* path of dir with rqti segs */
      193 dcl  sys_dir char (168);				/* local copy of system directory path */
      194 dcl  meter_dir char (168);				/* path of meter data segs directory */
      195 dcl  entry_name char (32);				/* accounting proc entry point name */
      196 dcl  entry_variable entry variable options (variable);
      197 dcl  times fixed bin;				/* number of times the driver tries to find cord */
      198 dcl  temp_dir char (168) varying;
      199 dcl  temp_dir_entry char (256);
      200 dcl  temp_password char (8);				/* temporary for password manipulation */
      201 dcl  temp_ptr ptr;					/* random temporary pointer variable */
      202 dcl  input_iocbp ptr;				/* iocb pointer for reading request type data */
      203 
      204 dcl  1 st aligned based (addr (io_stat)),		/* breakout of an ios_ status code */
      205        2 code fixed bin (35) aligned,
      206        2 stat bit (36) aligned;
      207 
      208 dcl  temp_label label variable;			/* for the fancy footwork needed to get a */
      209 dcl  based_ptr ptr based;				/* referencing_dir pointer for the search rules */
      210 dcl  ref_ptr ptr;
      211 dcl  1 driver_message aligned like new_driver_msg;	/* allocate space for mseg message  structure */
      212 
      213 
      214 /* ----------EXTERNAL STATIC ---------- */
      215 
      216 dcl  iodd_stat_p ptr ext static;			/* external copy of stat_p */
      217 
      218 dcl  error_table_$ionmat fixed bin (35) ext static;
      219 dcl  error_table_$not_detached fixed bin (35) ext static;
      220 dcl  error_table_$not_closed fixed bin (35) ext static;
      221 dcl  error_table_$noentry fixed bin (35) ext static;
      222 dcl  error_table_$ai_restricted fixed bin (35) ext static;
      223 dcl  error_table_$user_not_found fixed bin (35) ext static;
      224 dcl  error_table_$noarg fixed bin (35) ext static;
      225 dcl  error_table_$badopt fixed bin (35) ext static;
      226 dcl  error_table_$no_ext_sym fixed bin (35) ext static;
      227 dcl  error_table_$no_operation fixed bin (35) ext static;
      228 dcl  error_table_$namedup fixed bin (35) ext static;
      229 
      230 
      231 /* ----------- INTERNAL STATIC -------- */
      232 
      233 dcl  io_daemon_driver_version char (8) int static options (constant) init ("5.7");
      234 						/* current version of the driver */
      235 dcl  null_stream char (32) int static init ("iodd_null_stream") options (constant);
      236 dcl  bel_string char (40) aligned int static options (constant) init ((40)"");
      237 dcl  stars char (50) aligned int static options (constant) init ((5)"**********");
      238 dcl  error fixed bin int static options (constant) init (2);
      239 dcl  normal fixed bin int static options (constant) init (1);
      240 dcl  master fixed bin int static options (constant) init (1);
      241 dcl  slave fixed bin int static options (constant) init (2);
      242 dcl  both fixed bin int static options (constant) init (0);
      243 dcl  id char (24) int static options (constant) init ("iodd_");
      244 dcl  STATION_PW_PROMPT char (23) static options (constant) init ("Enter station password:");
      245 dcl  try_10_times fixed bin int static options (constant) init (10);
      246 dcl  try_0_times fixed bin int static options (constant) init (0);
      247 
      248 dcl  1 real_iodd_static int static aligned like iodd_static;/* allocation of iodd_static */
      249 
      250 dcl  NL char (1) int static options (constant) init ("
      251 ");
      252 
      253 dcl  FF char (1) int static options (constant) init ("");
      254 
      255 dcl  1 driver_list aligned int static,			/* this is where the driver_ptr_list is allocated */
      256        2 dummy (32) fixed bin (71);			/* be sure we reserve enough space for 30 drivers */
      257 
      258 
      259 /* ----------- BUILTINS ------- */
      260 
      261 dcl  (addr, after, before, bit, char, fixed, hbound, index, length, ltrim,
      262      null, ptr, rtrim, size, string, substr, unspec) builtin;
      263 
      264 
      265 /* ---------- STRUCTURES & MISC INCLUDE FILES ---------- */
      266 
      267 dcl  1 request_dev aligned,				/* major and minor devices to request from coord */
      268        2 major_name char (32),			/* name of the major device */
      269        2 major_index fixed bin,			/* device table index for it */
      270        2 n_minor fixed bin,				/* number of minor devices requested */
      271        2 minor (30) aligned,				/* save room for 30 minor devices */
      272          3 name char (32) unal,			/* minor device name...unal for the compiler */
      273          3 index fixed bin,				/* device table index for it */
      274          3 dev_class char (32),			/* expected dvc to be used */
      275          3 dvc_index fixed bin;			/* device class table index for the dvc */
      276 
      277 dcl  1 event_info aligned,				/* ipc_ info from a wakeup */
      278        2 channel fixed bin (71),			/* event channel signaled */
      279        2 message fixed bin (71),			/* event message sent to us */
      280        2 sender bit (36),				/* sender's process id */
      281        2 origin,
      282          3 dev_signal bit (18) unal,			/* was this a process or device? */
      283          3 rings bit (18) unal,			/* what ring sent it? */
      284        2 wait_list_index fixed bin;			/* where was the channel in the wait list */
      285 
      286 dcl  1 ev_chan_list aligned,				/* wait list for ipc_$block */
      287        2 number fixed bin,
      288        2 channel (32) fixed bin (71);
      289 
      290 dcl  1 read_info aligned,				/* structure to be filled in by read_status order */
      291        2 ev_chan fixed bin (71),			/* event_channel the stream blocks on */
      292        2 input_pending bit (1);			/* 1 if the stream is waiting for us to read */
      293 
      294 dcl  1 input aligned,				/* structure to hold arguments input by the operator */
      295        2 max fixed bin,				/* <the most tokens we ever expect */
      296        2 number fixed bin,				/* current number of tokens */
      297        2 arg (4) char (64) var;			/* text of each token */
      298 
      299 dcl  1 status_flags aligned,				/* status structure for convert_dial_message_ */
      300        2 dialed_up bit (1) unal,			/* 1 = device has dialed the process */
      301        2 hung_up bit (1) unal,			/* 1 = device has hung up */
      302        2 control bit (1) unal,			/* 1 = accepted, rejected or number signal */
      303        2 stat_pad bit (33) unal;
      304 
      305 dcl  1 release_arg aligned like dial_manager_arg;		/* for calls to dial_manager_$release_channel */
      306 
      307 
      308 dcl  (quit, any_other, daemon_logout, daemon_slave_logout, program_interrupt, no_coord, seg_fault_error,
      309      daemon_new_device, command_error, alrm, daemon_idle) condition;
      310 
      311 
      312 	stat_p = addr (real_iodd_static);		/* initialize the pointer used for all iodd_static references */
      313 	sys_dir = system_dir;			/* copy the arguments */
      314 	iodd_static.sys_dir_ptr = addr (sys_dir);	/* so we can publish the dir name */
      315 	iodd_static.flags.test_entry = testing;
      316 	iodd_stat_p = stat_p;			/* make it easier to create iodd procs */
      317 	iodd_static.io_daemon_version = io_daemon_driver_version;
      318 						/* publish the version number */
      319 	rqti_dir = rtrim (sys_dir) || ">rqt_info_segs";	/* this is where we find rqti segs */
      320 	meter_dir = rtrim (sys_dir) || ">meter_data";	/* this is where we find the meter data segs */
      321 	list_ptr = addr (driver_list);
      322 	driver_ptr_list.number = 0;
      323 	iodd_static.auto_start_delay = 60;		/* ready for early quit, 60 sec for auto-start */
      324 	iodd_static.timer_chan = 0;
      325 	iodd_static.cmd_ack_chan = 0;
      326 
      327 	iodd_static.re_init_label = re_init_driver;
      328 	iodd_static.no_coord_label = no_coord_signal;
      329 
      330 	call iodd_signal_handler_$init (stat_p);	/* initialize our general signal handler */
      331 
      332 	on quit call early_quit;			/* setup some condition handlers */
      333 	on daemon_logout go to driver_logout_label;
      334 	on daemon_slave_logout go to driver_logout_label;
      335 	on daemon_new_device go to start_new_device_cleanup;
      336 						/* this is how we transfer back after new_device command */
      337 	on daemon_idle
      338 	     begin;
      339 	end;					/* do nothing but grab the condition */
      340 	on any_other call iodd_signal_handler_;		/* we don't want the standard default */
      341 						/* handler to come to command level */
      342 
      343 	call ios_$order ("user_i/o", "quit_enable", null (), io_stat); /* be sure quits are enabled */
      344 
      345 	code = get_at_entry_ ("user_i/o", dim_name, dev_name, ig); /* this MUST work */
      346 
      347 	if dim_name = "mrd_" then do;			/* separate the streams for message coord */
      348 	     call ios_$attach ("error_i/o", "mrd_", dev_name, "", io_stat);
      349 	     call ios_$attach ("log_i/o", "mrd_", dev_name, "", io_stat);
      350 	end;
      351 	else do;					/* use the same streams for consistency */
      352 	     call ios_$attach ("error_i/o", "syn", "user_i/o", "", io_stat);
      353 	     call ios_$attach ("log_i/o", "syn", "user_i/o", "", io_stat);
      354 	end;
      355 
      356 	call ios_$attach ("master_output", "syn", "user_i/o", "", io_stat);
      357 	call ios_$attach ("master_input", "syn", "user_i/o", "", io_stat);
      358 	call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
      359 	call ios_$attach ("log_output", "syn", "log_i/o", "", io_stat);
      360 
      361 	call iox_$look_iocb ("master_output", iodd_static.master_out, code);
      362 	call iox_$look_iocb ("master_input", iodd_static.master_in, code);
      363 	call iox_$look_iocb ("log_output", iodd_static.log_iocbp, code);
      364 	call iox_$look_iocb ("error_i/o", iodd_static.error_io, code);
      365 
      366 	call iodd_msg_ (normal, master, 0, "", "^/IO Daemon Driver Version: ^a^[^/Driver running in test mode.^]^/",
      367 	     iodd_static.io_daemon_version, iodd_static.test_entry);
      368 
      369 	temp_label = out;				/* get a pointer to use with make_ptr for reference proc */
      370 	ref_ptr = addr (temp_label) -> based_ptr;
      371 
      372 
      373 	iodd_static.ctl_term.ctl_attach_name = "";	/* initialize ctl_term once here, then let */
      374 	iodd_static.ctl_term.ctl_attach_type = 0;	/* it be handled dynamically */
      375 	iodd_static.ctl_term.ctl_dial_chan = 0;
      376 	iodd_static.ctl_term.ctl_ev_chan = 0;
      377 	iodd_static.ctl_term.ctl_device = "";
      378 	iodd_static.ctl_term.ctl_dev_dim = "";
      379 	iodd_static.ctl_term.attached = "0"b;
      380 
      381 new_device:					/* we come here after a new_device command (from the handler) */
      382 	iodd_static.ctl_term.form_type = "undefined_form";/* use default unless operator changes */
      383 	iodd_static.ctl_term.forms = "0"b;		/* don't simulate terminal FF unless asked */
      384 	iodd_static.slave.active = "0"b;		/* be sure slave functions are dead */
      385 	iodd_static.slave_ev_chan = 0;
      386 	iodd_static.slave_in, iodd_static.slave_out = null;
      387 	iodd_static.slave_input, iodd_static.slave_output = null_stream;
      388 	iodd_static.slave.allow_quits = "0"b;
      389 	iodd_static.slave.accept_input = "0"b;
      390 	iodd_static.slave.print_errors = "0"b;
      391 	iodd_static.slave.log_msg = "0"b;		/* must ask for log messages */
      392 	iodd_static.slave.echo_cmd = "0"b;		/* no echoing of command lines */
      393 	iodd_static.slave.priv1 = "0"b;		/* driver module defined privleges */
      394 	iodd_static.slave.priv2 = "0"b;		/* " */
      395 	iodd_static.slave.priv3 = "0"b;		/* " */
      396 	iodd_static.re_init_in_progress = "0"b;		/* this is not a re_init */
      397 	iodd_static.wakeup_time = 30;			/* default to 30 seconds between wakeups */
      398 	iodd_static.recursion_flag = "0"b;		/* be sure these are off for testing */
      399 	iodd_static.no_coord_flag = "0"b;
      400 	iodd_static.initialized = "0"b;
      401 	iodd_static.dummy_ptr = null;			/* in case it has been set */
      402 	iodd_static.attach_type = 0;
      403 	iodd_static.line_tab_idx = 0;
      404 	iodd_static.major_device = "";
      405 
      406 	if iodd_static.timer_chan ^= 0 then
      407 	     call ipc_$delete_ev_chn (iodd_static.timer_chan, code);
      408 	if iodd_static.cmd_ack_chan ^= 0 then
      409 	     call ipc_$delete_ev_chn (iodd_static.cmd_ack_chan, code);
      410 
      411 	call ipc_$create_ev_chn (iodd_static.timer_chan, code); /* get an event channel for the timer */
      412 	if code ^= 0 then do;			/* an error is very bad */
      413 no_ipc:
      414 	     call convert_ipc_code_ (code);
      415 	     call iodd_msg_ (error, master, code, id, "Fatal error: Unable to create event channel.");
      416 	     go to out;				/* not much else to do */
      417 	end;
      418 
      419 	call ipc_$create_ev_chn (iodd_static.cmd_ack_chan, code);
      420 	if code ^= 0 then
      421 	     go to no_ipc;
      422 
      423 	call io_daemon_account_$set_line_prices (0, null, code); /* set up default prices */
      424 
      425 
      426 /*	Get the device name and device class from the operator */
      427 
      428 ask_for_dev:					/* for variable line, try new station */
      429 	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
      430 	     go to get_tables;
      431 
      432 	call iodd_msg_ (normal, master, 0, "", "Enter command or device/request_type:");
      433 						/* ask for some input */
      434 get_dev_id:
      435 	call iox_$get_line (iodd_static.master_in, addr (line), 120, nchars, code);
      436 	if code ^= 0 then do;
      437 no_master:
      438 	     call iodd_msg_ (error, master, code, id, "Fatal_error: Unable to read from master console.");
      439 	     go to out;
      440 	end;
      441 	if nchars < 2 then
      442 	     go to get_dev_id;			/* ignore null lines */
      443 
      444 	input.max = 4;				/* most tokens allowed */
      445 	call iodd_parse_$command (substr (line, 1, nchars), addr (input), code);
      446 	if code ^= 0 then
      447 	     if code = error_table_$noarg then
      448 		go to get_dev_id;			/* line was all blank */
      449 	     else do;
      450 bad_line:
      451 		call iodd_msg_ (normal, master, 0, "", "Invalid response.  Try again.");
      452 		go to ask_for_dev;
      453 	     end;
      454 	if input.arg (1) = "quit" | input.arg (1) = "logout" then
      455 	     go to out;				/* easy out */
      456 	if input.arg (1) = "help" then do;
      457 	     call iodd_msg_ (normal, master, 0, "", "Enter device name and optional request type, or any of:");
      458 	     call iodd_msg_ (normal, master, 0, "", "logout, print_devices, listen <line_id>, print_line_ids");
      459 	     go to ask_for_dev;
      460 	end;
      461 	if input.arg (1) = "print_line_ids" then do;
      462 	     call print_line_ids ("-dir", rtrim (sys_dir));
      463 	     go to ask_for_dev;
      464 	end;
      465 	if input.arg (1) = "print_devices" then do;	/* he forgot the device names */
      466 	     call print_devices ("-dir", rtrim (sys_dir), "-an", before (get_group_id_$tag_star (), ".*"));
      467 	     go to ask_for_dev;
      468 	end;
      469 	if length (input.arg (1)) > length (first_arg) then
      470 	     go to bad_line;
      471 	first_arg = input.arg (1);			/* save intact for reinit function */
      472 	first_arg = before (first_arg, ".");		/* if major.minor, drop minor */
      473 	if first_arg = "" then
      474 	     go to bad_line;
      475 	if input.number = 1 then			/* assume second arg is null if not given */
      476 	     if first_arg = "listen" then
      477 		go to bad_line;			/* requires an second arg */
      478 	     else second_arg = "";
      479 	else do;
      480 	     if length (input.arg (2)) > length (second_arg) then
      481 		go to bad_line;
      482 	     second_arg = input.arg (2);		/* save the second_arg if not too big */
      483 	end;
      484 
      485 get_tables:
      486 
      487 /* This label is put here so a reinit will work even if the working tables
      488*   have changed.  Find the tables in iod_working_tables so we can validate the
      489*   requested device and device class */
      490 
      491 	seg_name = "iodc_data";			/* segment name for possible error msg */
      492 	call init_seg (sys_dir, seg_name, iodc_data_ptr, try_10_times, code);
      493 						/* use internal proc to initiate */
      494 	if code ^= 0 then do;
      495 fatal_init:
      496 	     call iodd_msg_ (error, master, code, id, "^/Fatal error:  Unable to initiate ^a in ^a", seg_name, sys_dir);
      497 	     if iodd_static.test_entry then
      498 		call early_quit;			/* let the quit handler take it to */
      499 	     go to out;				/* normally there is nothing to do but quit */
      500 	end;
      501 
      502 	seg_name = "iod_working_tables";		/* ....for error msg */
      503 	call init_seg (sys_dir, seg_name, ithp, try_10_times, code);
      504 	if code ^= 0 then
      505 	     go to fatal_init;
      506 
      507 	if iod_tables_hdr.version ^= IODT_VERSION_5 then do;
      508 	     call iodd_msg_ (error, master, 0, id,
      509 		"Fatal error: Incorrect version of iod_working_tables.");
      510 	     go to out;				/* this is really bad!! */
      511 	end;
      512 
      513 /*	Set the pointers to each table within the iod_working_tables */
      514 
      515 	iodd_static.ithp = ithp;
      516 	iodd_static.ltp, ltp = ptr (ithp, iod_tables_hdr.line_tab_offset);
      517 	iodd_static.idtp, idtp = ptr (ithp, iod_tables_hdr.device_tab_offset);
      518 	iodd_static.mdtp, mdtp = ptr (ithp, iod_tables_hdr.minor_device_tab_offset);
      519 	iodd_static.qgtp, qgtp = ptr (ithp, iod_tables_hdr.q_group_tab_offset);
      520 	iodd_static.dev_class_ptr = ptr (ithp, iod_tables_hdr.dev_class_tab_offset);
      521 	iodd_static.text_strings_ptr, text_strings_ptr = ptr (ithp, iod_tables_hdr.text_strings_offset);
      522 
      523 /*	see if we have to wait for a remote station to dial up  */
      524 
      525 	iodd_static.attach_type = 0;			/* start fresh, and avoid loop if tables change */
      526 
      527 	if first_arg = "listen" then do;		/* YES, wait for a station */
      528 						/* first validate the line_id given from master console */
      529 	     iodd_static.line_tab_idx = 0;
      530 	     do i = 1 to line_tab.n_lines while (iodd_static.line_tab_idx = 0);
      531 		ltep = addr (line_tab.entries (i));	/* get entry pointer */
      532 		if lte.line_id = second_arg then
      533 		     iodd_static.line_tab_idx = i;
      534 	     end;
      535 	     if iodd_static.line_tab_idx = 0 then do;
      536 		call iodd_msg_ (normal, master, 0, "", "No line table entry found for ^a", second_arg);
      537 		go to ask_for_dev;
      538 	     end;
      539 	     call attach_and_listen (code);		/* attach line, wait for dialup, and validate the station id */
      540 	     if code ^= 0 then
      541 		go to new_device;			/* just to be sure */
      542 	     request_type = "default";		/* try for default request types */
      543 	     input_iocbp = iodd_static.slave_in;	/* if we need to ask for a request_type */
      544 	end;
      545 	else do;
      546 
      547 /* this is the normal device and request type case */
      548 /* search for the major device in the device table */
      549 	     request_dev.major_index = 0;
      550 	     do i = 1 to iod_device_tab.n_devices while (request_dev.major_index = 0);
      551 		idtep = addr (iod_device_tab.entries (i));
      552 						/* use new ptr for easy reference */
      553 		if idte.dev_id = first_arg then
      554 		     request_dev.major_index = i;	/* record the index */
      555 	     end;
      556 	     if request_dev.major_index = 0 then do;	/* not found */
      557 		call iodd_msg_ (normal, master, 0, "", "Device ""^a"" not found in device table.", first_arg);
      558 		go to ask_for_dev;			/* let him try again....or quit */
      559 	     end;
      560 	     if idte.attach_type = ATTACH_TYPE_VARIABLE_LINE then do;
      561 						/* can't use Line variable type here */
      562 		call iodd_msg_ (normal, master, 0, "", "Specified device must be used with the ""listen"" command.");
      563 		go to ask_for_dev;
      564 	     end;
      565 	     iodd_static.attach_type = idte.attach_type;
      566 	     iodd_static.attach_name = idte.attach_name;	/* initialize major device info in static */
      567 	     iodd_static.major_device, request_dev.major_name = first_arg;
      568 	     request_type = second_arg;		/* keep first_arg and second_arg intact */
      569 	     input_iocbp = iodd_static.master_in;	/* in case we have to ask for a request type */
      570 	end;
      571 
      572 
      573 /*	Find each associated minor device and save the index and default device class */
      574 
      575 	request_dev.n_minor = 0;			/* indicate that none have been found yet */
      576 
      577 /* look for all posible minor devices...up to the max */
      578 	do i = idte.first_minor to idte.last_minor while (request_dev.n_minor < hbound (request_dev.minor, 1));
      579 	     mdtep = addr (minor_device_tab.entries (i)); /* set pointer to table entry */
      580 	     if mdte.major_index = request_dev.major_index then do;
      581 
      582 /* we found one that belongs to the major dev */
      583 		request_dev.n_minor = request_dev.n_minor + 1; /* count it */
      584 		request_dev.minor.name (request_dev.n_minor) = mdte.dev_id; /* copy the minor device name */
      585 		request_dev.minor.index (request_dev.n_minor) = i; /* save the minor index */
      586 		request_dev.minor.dvc_index (request_dev.n_minor) = mdte.default_dev_class; /* save the default device class index */
      587 	     end;
      588 	end;					/* end of the table search */
      589 
      590 	if (request_dev.n_minor > 0) & (i <= idte.last_minor) then /* see if we omitted a minor device */
      591 	     call iodd_msg_ (normal, slave, 0, "", "Restriction: only the first ^d minor devices will be used",
      592 		hbound (request_dev.minor, 1));
      593 
      594 	if request_dev.n_minor = 0 then do;		/* OOPS...the table is garbage */
      595 	     call iodd_msg_ (error, both, 0, id,
      596 		"Fatal error: Inconsistent data in minor_device_tab. Re-init the coordinator.");
      597 	     if iodd_static.test_entry then
      598 		call early_quit;			/* give programmer a look */
      599 	     go to out;				/* then give up */
      600 	end;
      601 
      602 /*	See if we should force the operator to give a device class */
      603 
      604 	if request_type = "" then			/* if no optional device class was given, check n_minor */
      605 	     if request_dev.n_minor = 1 then
      606 		use_default = "1"b;			/* assume the default */
      607 	     else use_default = "0"b;			/* force response for multiple devices */
      608 	else if request_type = "default" then
      609 	     use_default = "1"b;			/* operator overrides */
      610 	else use_default = "0"b;			/* take the given class or ask if multiple */
      611 
      612 /*	Now we check out each possible device class for the requested devices */
      613 
      614 	if request_dev.n_minor > 1 | use_default then do; /* must check further for the request type(s) */
      615 	     do i = 1 to request_dev.n_minor;		/* for multiple minor devices we must ask for each dvc */
      616 		if ^use_default | request_dev.minor (i).dvc_index = 0 then do;
      617 						/* no default? */
      618 get_dvc:
      619 		     if request_dev.minor (i).dvc_index = 0 then
      620 			question = "Enter request type for minor device ""^a"":";
      621 		     else question = "Enter request type (or ""default"") for minor device ""^a"":";
      622 		     call iodd_msg_ (normal, slave, 0, "", question, request_dev.minor.name (i));
      623 		     call iox_$control (input_iocbp, "runout", null, code);
      624 						/* invoke remote runout spacing */
      625 		     call iox_$get_line (input_iocbp, addr (line), 120, nchars, code);
      626 		     if code ^= 0 then
      627 			go to new_device;
      628 		     if nchars < 2 then
      629 			go to get_dvc;		/* ignore blank lines */
      630 
      631 		     input.max = 4;			/* most tokens allowed */
      632 		     call iodd_parse_$command (substr (line, 1, nchars), addr (input), code);
      633 						/* see what he said */
      634 		     if code ^= 0 then do;
      635 			if code = error_table_$noarg then
      636 			     go to get_dvc;		/* try again if line was blank */
      637 			else do;
      638 bad_dvc:
      639 			     call iodd_msg_ (normal, slave, 0, "", "Invalid response.");
      640 			     call iox_$control (input_iocbp, "resetread", null, code);
      641 						/* try for a clean start */
      642 			     request_dev.minor (i).dvc_index = 0;
      643 						/* not sure if it is the default any more */
      644 			     go to get_dvc;
      645 			end;
      646 		     end;
      647 		     if length (input.arg (1)) > length (request_type) then
      648 			go to bad_dvc;
      649 		     request_type = input.arg (1);
      650 		     if request_type = "quit" | request_type = "new_device" | request_type = "newdevice" then
      651 			go to ask_for_dev;
      652 		     if request_type = "default" then do; /* be sure there is a default */
      653 			if request_dev.minor (i).dvc_index = 0 then do;
      654 			     call iodd_msg_ (normal, slave, 0, "", "No default has been specified.");
      655 			     go to get_dvc;
      656 			end;
      657 		     end;
      658 		     else do;			/* have to search for the specified dvc */
      659 
      660 			call find_device_class (request_type, j, dev_class, queue_type, code);
      661 						/* use internal proc */
      662 			if code ^= 0 then
      663 			     go to bad_dvc;		/* let him try again...msg has been sent */
      664 
      665 			request_dev.minor (i).dvc_index = j;
      666 						/* store the returned index */
      667 		     end;
      668 		end;
      669 
      670 /*		Now check to be sure it is legal for this process. */
      671 
      672 		call validate_request (i, code);	/* use the internal proc */
      673 		if code ^= 0 then
      674 		     go to bad_dvc;			/* error has been printed already */
      675 	     end;
      676 	end;					/* end of dvc request loop for multiple minor devices */
      677 
      678 	else do;					/* we have a single device and a given request_type arg */
      679 
      680 	     call find_device_class (request_type, j, dev_class, queue_type, code);
      681 	     if code ^= 0 then
      682 		go to ask_for_dev;			/* the message has already been printed */
      683 
      684 	     request_dev.minor (1).dvc_index = j;	/* store the dvc index returned */
      685 
      686 	     call validate_request (1, code);		/* check it out */
      687 	     if code ^= 0 then
      688 		go to ask_for_dev;			/* if bad, start over */
      689 	end;
      690 
      691 /*	WHEW...Now request_dev contains all the information needed to communicate to the coordinator */
      692 
      693 
      694 re_init_junction:
      695 
      696 /* This is the point of entry for re-initialization of the driver after a
      697*   "no-coord" or "re_init" signal.  We can proceed on the assumption that the
      698*   same major and minor devices and device classes will be used. */
      699 
      700 	iodd_static.major_device = request_dev.major_name;/* this gets cleared by kill_device, so reset in case */
      701 	iodd_static.admin_ec_name = rtrim (request_dev.major_name) || "_admin.ec";
      702 						/* define x cmd ec name */
      703 	iodd_static.coord_proc_id = iodc_data.proc_id;	/* save coordinators process id */
      704 	iodd_static.driver_proc_id = get_process_id_ ();	/* and the drivers */
      705 	iodd_static.no_coord_flag = "1"b;		/* accept a no_coord signal now */
      706 	iodd_static.recursion_flag = "0"b;		/* be sure this is reset for reinit */
      707 	iodd_static.request_in_progress = "0"b;
      708 	iodd_static.initialized = "0"b;
      709 	iodd_static.master_hold = "0"b;
      710 	iodd_static.slave_hold = "0"b;
      711 	iodd_static.step = "0"b;
      712 	iodd_static.quit_during_request = "0"b;
      713 	iodd_static.logout_pending = "0"b;
      714 	iodd_static.runout_requests = "0"b;
      715 	iodd_static.quit_signaled = "0"b;
      716 	iodd_static.auto_logout_interval = 0;		/* default to no auto logout, must be set by command */
      717 	iodd_static.assigned_devices = 0;		/* no devices at this point */
      718 	iodd_static.current_devices = 0;
      719 	iodd_static.output_device = "Undefined";
      720 	iodd_static.auto_start_delay = 60;		/* wait 60 seconds after quit before auto-start */
      721 	if iodd_static.attach_type ^= ATTACH_TYPE_VARIABLE_LINE then do;
      722 						/* assume attachment good for variable line */
      723 	     iodd_static.slave_in, iodd_static.slave_out = null;
      724 						/* for now */
      725 	     iodd_static.slave.active = "0"b;		/* slave must be re-defined */
      726 	     iodd_static.slave_ev_chan = 0;
      727 	     iodd_static.slave.accept_input = "0"b;
      728 	     iodd_static.slave.print_errors = "0"b;
      729 	     iodd_static.slave_output = null_stream;	/* we are done with this now */
      730 	     iodd_static.slave_input = null_stream;
      731 	end;
      732 	iodd_static.slave.log_msg = "0"b;		/* must ask for log messages */
      733 	iodd_static.slave.echo_cmd = "0"b;		/* don't echo cmds by default */
      734 	iodd_static.slave.allow_quits = "0"b;
      735 	iodd_static.dev_io_stream = null_stream;
      736 	iodd_static.dev_in_stream = null_stream;
      737 	iodd_static.dev_out_stream = null_stream;
      738 	iodd_static.driver_ptr = null ();
      739 	iodd_static.driver_list_ptr,			/* be ready to publish the list */
      740 	     list_ptr = addr (driver_list);
      741 
      742 	iodd_static.chan_list_ptr = addr (ev_chan_list);	/* wait list for ipc_$block */
      743 	iodd_static.segptr = null;			/* signal_handler cannot rely on segptr */
      744 
      745 	call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat); /* reset error_output */
      746 
      747 	call ios_$detach ("broadcast_errors", "", "", io_stat); /* avoid multiple attachments for sure */
      748 
      749 	call ios_$attach ("broadcast_errors", "broadcast_", "error_i/o", "", io_stat); /* put back error stream */
      750 
      751 	iodd_static.master_output = "master_output";	/* incase they got clobbered */
      752 	iodd_static.master_input = "master_input";	/* save the default stream names */
      753 	iodd_static.log_stream = "log_output";
      754 
      755 	call iox_$look_iocb ("master_output", iodd_static.master_out, code);
      756 						/* reset the important iocb ptrs */
      757 	call iox_$look_iocb ("master_input", iodd_static.master_in, code);
      758 	call iox_$look_iocb ("log_output", iodd_static.log_iocbp, code);
      759 	call iox_$look_iocb ("error_i/o", iodd_static.error_io, code);
      760 
      761 /*        check to see if the table has changed on us since we last looked */
      762 
      763 	on seg_fault_error begin;
      764 	     ithp = null;				/* indicate that we need to initiate */
      765 	     go to get_tables;			/* and go back and get new indices */
      766 	end;
      767 
      768 	table_time = iod_tables_hdr.date_time_compiled;	/* reference through ptr to verify it */
      769 
      770 	revert seg_fault_error;			/* don't special case the condition any longer */
      771 
      772 
      773 /*	With all the static data initialized, get ready to request the devices */
      774 
      775 	rqt_string = "";				/* build this as devices are initialized */
      776 	driver_dir = rtrim (sys_dir) || ">" || request_dev.major_name;
      777 	init_ev_chan = iodc_data.init_event_channel;	/* copy the coord's ipc chan */
      778 	ev_chan_list.number = 2;			/* initially 2 channels in the wait list */
      779 	ev_chan_list.channel (1) = 0;			/* this one is empty for now */
      780 	ev_chan_list.channel (2) = iodd_static.timer_chan;/* timer is second priority */
      781 
      782 	driver_ptr_list.number = 0;			/* assume that no driver status segs exist */
      783 
      784 	new_driver_msg_p = addr (driver_message);	/* this is where we build the request */
      785 	driver_message.lock_id = "0"b;		/* this will ensure that set_lock works */
      786 
      787 	call set_lock_$lock (driver_message.lock_id, 0, code);
      788 						/* store process lock id */
      789 
      790 
      791 /* At this point we will loop through the requested minor devices, asking the
      792*   IO coordinator to establish this process as the driver.  There is a lot of
      793*   work to do for the initialization of each driver, so, the main loop will
      794*   take a few pages of listing */
      795 
      796 	if iodd_static.test_entry then
      797 	     call iodd_msg_ (normal, master, 0, "", "Requesting devices from coordinator.");
      798 
      799 	do i = 1 to request_dev.n_minor;		/* once around for each minor dev */
      800 
      801 	     call ipc_$create_ev_chn (driver_message.wakeup_chan, code);
      802 						/* get a channel for the coord to use */
      803 	     if code ^= 0 then do;
      804 		call convert_ipc_code_ (code);
      805 		call iodd_msg_ (error, both, code, id, "Fatal error: Unable to create minor device event channel.");
      806 		call kill_device;			/* drop any device assigned */
      807 		go to out;			/* thats all she wrote! */
      808 	     end;
      809 
      810 	     ev_chan_list.channel (1) = driver_message.wakeup_chan;
      811 						/* get ready to block for coord */
      812 	     driver_message.device_index = request_dev.minor (i).index;
      813 						/* fill in the rest of the request */
      814 	     driver_message.dev_class_index = request_dev.minor (i).dvc_index;
      815 
      816 	     call message_segment_$add_file (sys_dir, "coord_comm.ms", new_driver_msg_p, size (new_driver_msg) * 36,
      817 		message_id, code);			/* send off the request */
      818 
      819 	     if code ^= 0 then do;
      820 		call iodd_msg_ (error, both, code, id,
      821 		     "Fatal error: Unable to send new driver request to coord_comm.ms in ^a", sys_dir);
      822 		call kill_device;			/* drop any we have */
      823 		if iodd_static.test_entry then
      824 		     call early_quit;		/* give programmer a look */
      825 		go to out;			/* then bug out */
      826 	     end;
      827 
      828 	     unspec (event_message) = message_id;	/* give coord the message id in an event message */
      829 
      830 	     call hcs_$wakeup (iodd_static.coord_proc_id, init_ev_chan, event_message, code);
      831 	     if code ^= 0 then
      832 		signal no_coord;			/* on error assume the coord is gone */
      833 
      834 /*	now block until the coordinator gives us the device (up to 5 min max) */
      835 
      836 	     call ipc_$drain_chn (iodd_static.timer_chan, code);
      837 						/* clear the timer...in case */
      838 	     call timer_manager_$alarm_wakeup (300, RELATIVE_SECONDS, iodd_static.timer_chan);
      839 						/* start the clock */
      840 	     call ipc_$block (addr (ev_chan_list), addr (event_info), code);
      841 						/* and wait */
      842 	     call timer_manager_$reset_alarm_wakeup (iodd_static.timer_chan);
      843 						/* reset the clock */
      844 	     if code ^= 0 then do;			/* bad news, and dumb code */
      845 		call convert_ipc_code_ (code);
      846 		call iodd_msg_ (error, both, code, id, "Fatal error: from  ipc_$block .");
      847 		call kill_device;			/* flush any previous devices */
      848 		if iodd_static.test_entry then
      849 		     call early_quit;		/* take a peek, */
      850 		go to out;			/* then forget it */
      851 	     end;
      852 
      853 /*	It was a legal wakeup, who sent it? */
      854 
      855 	     if event_info.wait_list_index = 2 then do;	/* bad news if it was the timer */
      856 		call iodd_msg_ (normal, both, 0, id, "Coordinator did not respond to new driver wakeup.");
      857 		signal no_coord;			/* don't bother to flush devices */
      858 	     end;
      859 
      860 	     code = addr (event_info.message) -> ev_msg.code;
      861 						/* see what the coord said */
      862 	     if code ^= 0 then do;
      863 
      864 		if request_dev.n_minor = 1 then
      865 		     dev_label = request_dev.major_name;
      866 		else dev_label = rtrim (request_dev.major_name) || "." || request_dev.minor (i).name;
      867 
      868 		if code = 6 then do;		/* already assigned */
      869 		     call iodd_msg_ (normal, both, 0, id, "Device ^a assigned to another process", dev_label);
      870 		     go to ask_for_dev;		/* don't bother to flush */
      871 		end;
      872 		else if code = 7 then do;		/* already assigned to us, huh? */
      873 		     call iodd_msg_ (normal, both, 0, id, "Device ^a already assigned to this process.", dev_label);
      874 		end;				/* tell the operator, but, keep on truckin' */
      875 		else do;				/* otherwise it is very bad */
      876 		     call iodd_msg_ (error, both, 0, id, "Coordinator could not initialize ^a driver. Code = ^d",
      877 			dev_label, code);
      878 		     call kill_device;		/* we may have had some devices assigned */
      879 		     go to ask_for_dev;		/* start all over again */
      880 		end;
      881 
      882 	     end;					/* when we pass here, we are almost home free */
      883 
      884 
      885 /*	The coord gave the OK....so find the driver status segment */
      886 
      887 	     call hcs_$initiate (driver_dir, request_dev.minor (i).name, "", 0, 1, driver_status_ptr, code);
      888 	     if driver_status_ptr = null then do;
      889 		call iodd_msg_ (error, both, code, id, "Unable to initiate driver status segment: ^a in ^a",
      890 		     request_dev.minor (i).name, driver_dir);
      891 		call kill_device;			/* drop it */
      892 		go to ask_for_dev;			/* and start all over...UGH! */
      893 	     end;
      894 
      895 	     driver_ptr_list.number = driver_ptr_list.number + 1; /* add one to the list */
      896 	     driver_ptr_list.stat_segp (driver_ptr_list.number) = driver_status_ptr; /* save the driver ptr */
      897 	     driver_status.driver_chan = ev_chan_list.channel (1); /* and the event channel */
      898 	     driver_status.last_wake_time = 0;		/* havn't asked for work yet */
      899 	     driver_status.list_index = driver_ptr_list.number; /* for the future */
      900 	     string (driver_status.status_flags) = "0"b;	/* clear the flags */
      901 	     driver_status.dev_ctl_ptr = null;		/* don't leave uninitialized pointers around */
      902 
      903 /*	Now find the accounting procedure we will use for this driver */
      904 /*	It can be different for each minor device driver */
      905 
      906 	     dctep = addr (iodd_static.dev_class_ptr -> dev_class_tab.entries (request_dev.minor (i).dvc_index));
      907 	     qgtep = addr (iodd_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
      908 
      909 	     driver_status.generic_type = qgte.generic_type;
      910 						/* record generic type for minor dev */
      911 
      912 	     if return_string (qgte.accounting) = "nothing" then /* no accounting routine */
      913 		driver_status.have_accounting = "0"b;	/* so indicate that */
      914 	     else do;				/* otherwise it is more trouble */
      915 		driver_status.have_accounting = "1"b;	/* so indicate that */
      916 		if return_string (qgte.accounting) = "system" then /* use our special procedure */
      917 		     driver_status.acct_entry = charge_user_;
      918 		else do;
      919 		     temp_dir_entry = return_string (qgte.accounting);
      920 
      921 		     driver_status.acct_entry = cv_entry_ (temp_dir_entry, null (), code);
      922 		     if code ^= 0 then do;
      923 			if return_string (qgte.accounting) = "system" then
      924 			     call iodd_msg_ (error, both, code, id,
      925 				"Unable to get pointer to system accounting procedure: ^a", temp_dir_entry);
      926 			else call iodd_msg_ (error, both, code, id, "Unable to get pointer to accounting procedure: ^a.",
      927 				temp_dir_entry);
      928 			call kill_device;
      929 			go to ask_for_dev;		/* again */
      930 		     end;
      931 		end;
      932 	     end;
      933 
      934 /*	set up the line_charge prices for this logical driver */
      935 
      936 	     call io_daemon_account_$set_line_prices (driver_ptr_list.number, qgtep, code);
      937 	     if code ^= 0 then do;			/* OOPS */
      938 		call iodd_msg_ (error, both, code, id, "Unable to set line charge prices for request type ^a.",
      939 		     driver_status.req_type_label);
      940 		call kill_device;
      941 		go to ask_for_dev;
      942 	     end;
      943 
      944 
      945 /*	now see if there is a request type info seg specified for the driver */
      946 
      947 	     entry_name = qgte.rqti_seg_name;		/* get the entry name from the iod_tables */
      948 	     if entry_name ^= "" then do;		/* must find the rqti seg */
      949 		call init_seg (rqti_dir, entry_name, driver_status.rqti_ptr, try_0_times, code);
      950 						/* don't wait */
      951 		if driver_status.rqti_ptr = null then do;
      952 		     call iodd_msg_ (error, both, code, id, "Unable to find RQTI segment ^a.", entry_name);
      953 		     call kill_device;
      954 		     go to ask_for_dev;
      955 		end;
      956 	     end;
      957 	     else driver_status.rqti_ptr = null;	/* be sure of no mistake */
      958 
      959 	     rqt_name = before (rtrim (driver_status.req_type_label), ".");
      960 						/* get the real request type name */
      961 
      962 	     if index (rqt_string, rtrim (rqt_name)) = 0 then /* look for duplicates */
      963 		rqt_string = rqt_string || " " || rtrim (rqt_name); /* add to the string */
      964 
      965 /* associate minor device with rqt name for x command */
      966 	     call set_iod_val (rtrim (driver_status.device_id), rtrim (rqt_name));
      967 
      968 /*	Go back and look for the next minor device driver to be assigned */
      969 
      970 	end;					/* That's all for the big loop */
      971 
      972 /*	Time for final initialization */
      973 
      974 	idtep = addr (iod_device_tab.entries (request_dev.major_index)); /* locate major device data */
      975 	iodd_static.major_args = idte.args;
      976 
      977 /* if user says single sheet then set it, else force to continuous forms */
      978 	if idte.paper_type = PAPER_TYPE_SINGLE then
      979 	     iodd_static.paper_type = idte.paper_type;
      980 	else iodd_static.paper_type = PAPER_TYPE_CONTINUOUS;
      981 
      982 	iodd_static.assigned_devices = driver_ptr_list.number; /* start with the first in the list */
      983 	iodd_static.driver_ptr, driver_status_ptr = driver_ptr_list.stat_segp (1);
      984 	iodd_static.output_device = iodd_static.driver_ptr -> driver_status.device_id;
      985 
      986 /*	call the coord again and ask for the special command IPC channel (for drivers only) */
      987 
      988 	event_message = 0;				/* clear the event message of trash */
      989 	msgp = addr (event_message);			/* setup event message */
      990 	msgp -> ev_msg.code = 5;			/* code 5: requesting cmd channel */
      991 	msgp -> ev_msg.minor_dev_index =		/* name a minor device so coord can release */
      992 	     driver_ptr_list.stat_segp (1) -> driver_status.dev_index;
      993 	init_ev_chan = driver_ptr_list.stat_segp (1) -> driver_status.coord_chan;
      994 
      995 /* get request chan */
      996 
      997 	call hcs_$wakeup (iodd_static.coord_proc_id, init_ev_chan, event_message, code);
      998 	if code ^= 0 then
      999 	     signal no_coord;			/* on error assume the coord is gone */
     1000 
     1001 	call ipc_$drain_chn (iodd_static.timer_chan, code);
     1002 						/* clear the timer...in case */
     1003 	call timer_manager_$alarm_wakeup (300, RELATIVE_SECONDS, iodd_static.timer_chan);
     1004 
     1005 /* start the clock */
     1006 
     1007 	ev_chan_list.channel (1) = driver_ptr_list.stat_segp (1) -> driver_status.driver_chan;
     1008 
     1009 	call ipc_$block (addr (ev_chan_list), addr (event_info), code);
     1010 						/* and wait */
     1011 
     1012 	call timer_manager_$reset_alarm_wakeup (iodd_static.timer_chan);
     1013 						/* reset the clock */
     1014 	if code ^= 0 then do;			/* bad news, and dumb code */
     1015 	     call convert_ipc_code_ (code);
     1016 	     call iodd_msg_ (error, both, code, id, "Fatal error: from  ipc_$block .");
     1017 	     call kill_device;			/* flush any previous devices */
     1018 	     if iodd_static.test_entry then
     1019 		call early_quit;			/* take a peek, */
     1020 	     go to out;				/* then forget it */
     1021 	end;
     1022 
     1023 	if event_info.wait_list_index = 2 then do;	/* bad news if it was the timer */
     1024 	     call iodd_msg_ (normal, both, 0, id, "Coordinator did not respond to standard wakeup.");
     1025 	     signal no_coord;			/* don't bother to flush devices */
     1026 	end;
     1027 
     1028 	iodd_static.coord_cmd_chan = event_info.message;	/* save the returned ev chan */
     1029 
     1030 /*	Set the entry variables for calling the driver module */
     1031 
     1032 	temp_dir = return_string (idte.driver_module);
     1033 	temp_dir_entry = temp_dir || "$init";
     1034 	iodd_static.driver_init = cv_entry_ (temp_dir_entry, null (), code);
     1035 	if code ^= 0 then do;
     1036 bad_entry:
     1037 	     call iodd_msg_ (error, both, code, id, "Unable to find driver module ""^a"".", temp_dir_entry);
     1038 	     call kill_device;
     1039 	     go to ask_for_dev;
     1040 	end;
     1041 
     1042 	temp_dir_entry = temp_dir || "$request";
     1043 	iodd_static.driver_request = cv_entry_ (temp_dir_entry, null (), code);
     1044 	if code ^= 0 then
     1045 	     go to bad_entry;
     1046 
     1047 	temp_dir_entry = temp_dir || "$command";
     1048 	iodd_static.driver_command = cv_entry_ (temp_dir_entry, null (), code);
     1049 	if code ^= 0 then
     1050 	     go to bad_entry;
     1051 
     1052 	temp_dir_entry = temp_dir || "$default_handler";
     1053 	iodd_static.driver_default_handler = cv_entry_ (temp_dir_entry, null (), code);
     1054 	if code ^= 0 then do;
     1055 	     if code ^= error_table_$no_ext_sym then
     1056 		go to bad_entry;			/* we can handle one error only */
     1057 	     else do;
     1058 		temp_dir_entry = "iodd_$iodd_";
     1059 		iodd_static.driver_default_handler = cv_entry_ (temp_dir_entry, null (), code);
     1060 		if code ^= 0 then
     1061 		     go to bad_entry;		/* perish the thought! */
     1062 	     end;
     1063 	end;
     1064 
     1065 /* set the entry variables for the head_sheet entries.  If not supplied in
     1066*   iod_tables, use default of head_sheet_ */
     1067 
     1068 	temp_dir = return_string (idte.head_sheet);
     1069 	if temp_dir = "" then do;
     1070 	     iodd_static.print_head_sheet = head_sheet_$print_head_sheet;
     1071 	     iodd_static.print_head_separator = head_sheet_$print_separator;
     1072 	end;
     1073 	else do;
     1074 	     temp_dir_entry = temp_dir || "$print_head_sheet";
     1075 	     iodd_static.print_head_sheet = cv_entry_ (temp_dir_entry, null (), code);
     1076 	     if code ^= 0 then do;
     1077 bad_banner_entry:
     1078 		call iodd_msg_ (error, both, code, id, "Unable to find banner page module ""^a"".", temp_dir_entry);
     1079 		call kill_device;
     1080 		go to ask_for_dev;
     1081 	     end;
     1082 
     1083 	     temp_dir_entry = temp_dir || "$print_separator";
     1084 	     iodd_static.print_head_separator = cv_entry_ (temp_dir_entry, null (), code);
     1085 	     if code ^= 0 then
     1086 		go to bad_banner_entry;
     1087 	end;
     1088 
     1089 	if iodd_static.test_entry then do;		/* ... and that head sheet printer can find printer_notice */
     1090 	     if temp_dir = "" then
     1091 		call head_sheet_$test (sys_dir);
     1092 	     else do;
     1093 		temp_dir_entry = temp_dir || "$test";
     1094 		entry_variable = cv_entry_ (temp_dir_entry, null (), code);
     1095 		if code ^= 0 then
     1096 		     go to bad_banner_entry;
     1097 		call entry_variable (sys_dir);
     1098 	     end;
     1099 	end;
     1100 
     1101 /* set the entry variables for the tail_sheet entries */
     1102 	temp_dir = return_string (idte.tail_sheet);
     1103 	if temp_dir = "" then
     1104 	     iodd_static.print_tail_sheet = tail_sheet_$print_tail_sheet;
     1105 	else do;
     1106 	     temp_dir_entry = temp_dir || "$print_tail_sheet";
     1107 	     iodd_static.print_tail_sheet = cv_entry_ (temp_dir_entry, null (), code);
     1108 	     if code ^= 0 then
     1109 		go to bad_banner_entry;
     1110 	end;
     1111 
     1112 /*	Set up the wait list for blocking, except for the ctl_term entry */
     1113 
     1114 	call iox_$control (iodd_static.master_in, "read_status", addr (read_info), code);
     1115 	if code ^= 0 then do;
     1116 	     call iodd_msg_ (error, both, code, id, "Attempting read_status control on master_input.");
     1117 	     call kill_device;
     1118 	     go to out;
     1119 	end;
     1120 	ev_chan_list.channel (1) = read_info.ev_chan;	/* save the master console event channel in first position */
     1121 
     1122 	do i = 1 to driver_ptr_list.number;
     1123 	     ev_chan_list.channel (i + 2) = driver_ptr_list.stat_segp (i) -> driver_status.driver_chan;
     1124 	end;					/* leave the timer chan in position 2 for now */
     1125 	ev_chan_list.number = driver_ptr_list.number + 2;
     1126 
     1127 	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then /* for line variable, device is the slave */
     1128 	     ev_chan_list.channel (2) = iodd_static.slave_ev_chan; /* the slave is defined as station device */
     1129 
     1130 /*	Check on the control terminal. If we have one, its ev_chan will go into position 2 after attachment */
     1131 /*	unless this is a line variable type device.  Then allow ctl term, but not as the slave. */
     1132 
     1133 	if iodd_static.ctl_term.attached then do;	/* check to see if it is still dialed */
     1134 	     call check_for_dialup (code);
     1135 
     1136 	     if code = 0 then
     1137 		go to set_ctl_streams;		/* if still there, finish attachments */
     1138 
     1139 	     if code = 5 then do;			/* this signals we are changing ctl terminals */
     1140 		line = NL || "hangup terminal" || NL;
     1141 		call ios_$write (iodd_static.ctl_io, addr (line), 0, length (rtrim (line)), (0), io_stat);
     1142 		call ios_$order (iodd_static.ctl_io, "runout", null, io_stat);
     1143 		call ipc_$decl_ev_wait_chn (iodd_static.ctl_dial_chan, code);
     1144 
     1145 /* ready for dial_manager_ */
     1146 
     1147 		release_arg.version = dial_manager_arg_version_2;
     1148 		release_arg.channel_name = iodd_static.ctl_device;
     1149 		release_arg.dial_channel = iodd_static.ctl_dial_chan;
     1150 		release_arg.dial_qualifier = "";
     1151 
     1152 		call dial_manager_$release_channel (addr (release_arg), code);
     1153 		if code ^= 0 then
     1154 		     call ios_$order ((iodd_static.ctl_io), "hangup", null, io_stat);
     1155 
     1156 /* do what we can to drop it */
     1157 		call ipc_$delete_ev_chn (iodd_static.ctl_dial_chan, code);
     1158 						/* no longer needed */
     1159 	     end;
     1160 	     call ios_$detach (iodd_static.ctl_io, "", "", io_stat);
     1161 						/* drop the dead terminal */
     1162 	     call ios_$detach (iodd_static.ctl_input, "", "", io_stat);
     1163 	     call ios_$detach (iodd_static.ctl_output, "", "", io_stat);
     1164 	     iodd_static.ctl_term.attached = "0"b;	/* all clear now */
     1165 	end;
     1166 
     1167 	iodd_static.ctl_term.ctl_attach_name = idte.ctl_attach_name;
     1168 	iodd_static.ctl_term.ctl_attach_type = idte.ctl_attach_type;
     1169 
     1170 	if iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_TTY | iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_DIAL then do;
     1171 	     call wait_for_dial (code);		/*  must ask answering service for terminal line or for dial */
     1172 	     if code ^= 0 then do;
     1173 		if code > 10 then
     1174 		     call iodd_msg_ (normal, master, code, id, "Unable to get dialed terminal.");
     1175 		else call iodd_msg_ (normal, master, 0, id, "Unable to get dialed terminal. code = ^d", code);
     1176 		call kill_device;
     1177 		go to ask_for_dev;
     1178 	     end;
     1179 	end;
     1180 	else if iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_MC then do;
     1181 						/* we want the message coordinator */
     1182 	     iodd_static.ctl_dev_dim = "mrd_";
     1183 	     iodd_static.ctl_device = idte.ctl_attach_name;
     1184 						/* attach name was the device */
     1185 	end;
     1186 	else do;					/* otherwise, no ctl_term is required */
     1187 	     iodd_static.ctl_input = null_stream;	/* be sure all variables are cleared */
     1188 	     iodd_static.ctl_output = null_stream;
     1189 	     iodd_static.ctl_io = null_stream;
     1190 	     iodd_static.ctl_dev_dim = "Undefined";
     1191 	     iodd_static.ctl_dial_chan = 0;
     1192 	     iodd_static.ctl_ev_chan = 0;		/* this means the timer chan will be a dummy */
     1193 						/* in the event wait list...it avoids errors */
     1194 	     go to call_driver;			/* ready to pass this process along */
     1195 	end;
     1196 
     1197 	call ios_$attach ("ctl_i/o", iodd_static.ctl_dev_dim, iodd_static.ctl_device, "", io_stat);
     1198 	if st.code ^= 0 then do;			/* couldn't attach? */
     1199 	     if st.code = error_table_$ionmat then
     1200 		go to set_ctl_streams;		/* already attached, ??? */
     1201 	     call iodd_msg_ (normal, master, st.code, id,
     1202 		"Attaching ""ctl_i/o"" to ""^a"" with  interface module ""^a"".", iodd_static.ctl_device,
     1203 		iodd_static.ctl_dev_dim);
     1204 	     call kill_device;
     1205 	     go to ask_for_dev;			/* might be better to ask operator what to do */
     1206 	end;
     1207 
     1208 set_ctl_streams:					/* set the input, output, and error streams */
     1209 	iodd_static.ctl_term.attached = "1"b;		/* this must be true in all cases */
     1210 	iodd_static.ctl_io = "ctl_i/o";
     1211 	iodd_static.ctl_input = "ctl_input";
     1212 	iodd_static.ctl_output = "ctl_output";
     1213 
     1214 	if iodd_static.ctl_term.forms then
     1215 	     dim_name = "form_";			/* use the paging dim for simulating forms */
     1216 	else dim_name = "syn";
     1217 
     1218 	call ios_$attach ("ctl_input", dim_name, iodd_static.ctl_io, "", io_stat);
     1219 	if st.code ^= 0 then
     1220 	     if st.code ^= error_table_$ionmat then do;	/* let it ride if attached */
     1221 syn_err:
     1222 		call iodd_msg_ (normal, master, st.code, id, "Error attaching control terminal streams. Dim: ^a",
     1223 		     dim_name);
     1224 		go to start_new_device_cleanup;
     1225 	     end;
     1226 
     1227 	call ios_$attach ("ctl_output", dim_name, iodd_static.ctl_io, "", io_stat);
     1228 	if st.code ^= 0 then
     1229 	     if st.code ^= error_table_$ionmat then
     1230 		go to syn_err;
     1231 
     1232 /*	Put the control terminal event channel in the wait list */
     1233 
     1234 	call ios_$order (iodd_static.ctl_io, "read_status", addr (read_info), io_stat);
     1235 	if st.code ^= 0 then do;			/* did someone lie?  this should always work */
     1236 	     call iodd_msg_ (normal, master, st.code, id, """read_status"" on stream ""^a"".", iodd_static.ctl_io);
     1237 	     go to start_new_device_cleanup;
     1238 	end;
     1239 
     1240 	iodd_static.ctl_ev_chan = read_info.ev_chan;	/* save here for other uses */
     1241 
     1242 	if ^iodd_static.slave.active then do;		/* if active, it was a line variable type */
     1243 						/* so don't make the control terminal the salve */
     1244 	     ev_chan_list.channel (2) = read_info.ev_chan;/* slave term is lower priority than master */
     1245 	     iodd_static.slave_ev_chan = read_info.ev_chan;
     1246 
     1247 /*	Set the ctl_term as the slave device. */
     1248 
     1249 	     iodd_static.slave_input = iodd_static.ctl_input;
     1250 	     iodd_static.slave_output = iodd_static.ctl_output;
     1251 	     iodd_static.slave.active = "1"b;
     1252 
     1253 	     call iox_$look_iocb ((iodd_static.slave_output), iodd_static.slave_out, code);
     1254 	     if code ^= 0 then do;
     1255 slave_init_err:
     1256 		call iodd_msg_ (normal, master, code, id, "Unable to find slave iocbp.");
     1257 		go to start_new_device_cleanup;
     1258 	     end;
     1259 
     1260 	     call iox_$look_iocb ((iodd_static.slave_input), iodd_static.slave_in, code);
     1261 	     if code ^= 0 then
     1262 		go to slave_init_err;
     1263 
     1264 	     call ios_$order (iodd_static.ctl_io, "start", null (), io_stat);
     1265 	end;
     1266 
     1267 
     1268 call_driver:					/* call the init entry of the driver module */
     1269 	call set_iod_val ("device", rtrim (request_dev.major_name));
     1270 						/* set values for iod_val active function */
     1271 	call set_iod_val ("station_id", rtrim (request_dev.major_name));
     1272 	call set_iod_val ("channel", rtrim (iodd_static.attach_name));
     1273 	if iodd_static.assigned_devices > 1 then
     1274 	     request_type = "";			/* define request type if only one */
     1275 	else request_type = before (iodd_static.driver_ptr -> driver_status.req_type_label, ".");
     1276 	call set_iod_val ("request_type", rtrim (request_type));
     1277 	call set_iod_val ("rqt_string", (rqt_string));	/* define all the request types for iod_admin.ec */
     1278 
     1279 	if ^iodd_static.slave.active then do;		/* set slave control modes if ctl term active */
     1280 	     iodd_static.slave.allow_quits = "0"b;
     1281 	     iodd_static.slave.accept_input = "0"b;
     1282 	     iodd_static.slave.print_errors = "0"b;
     1283 	end;
     1284 	else do;
     1285 	     dim_name = "broadcast_";
     1286 	     call ios_$attach ("broadcast_errors", dim_name, iodd_static.slave_output, "", io_stat);
     1287 	     if st.code ^= 0 then
     1288 		call iodd_msg_ (normal, both, st.code, id, "Unable to attach broadcast_errors to slave.");
     1289 	     else do;
     1290 		call ios_$attach ("error_output", "syn", "broadcast_errors", "", io_stat);
     1291 		if st.code ^= 0 then
     1292 		     call iodd_msg_ (normal, both, st.code, id,
     1293 			"Unable to attach error_output stream to broadcast_errors.");
     1294 	     end;
     1295 
     1296 	     iodd_static.slave.allow_quits = "1"b;
     1297 	     iodd_static.slave.accept_input = "1"b;
     1298 	     iodd_static.slave.print_errors = "1"b;
     1299 	     if iodd_static.slave_output ^= iodd_static.ctl_output then
     1300 		iodd_static.slave.log_msg = "1"b;	/* send log msgs to slave if not the ctl terminal */
     1301 	end;
     1302 
     1303 	if iodd_static.test_entry then		/* see if we are testing in one process */
     1304 	     if iodd_static.coord_proc_id = iodd_static.driver_proc_id then /* make them different for locking */
     1305 		iodd_static.driver_proc_id = bit (fixed (iodd_static.driver_proc_id, 35) + 100, 36);
     1306 
     1307 	call iodd_command_processor_$init (stat_p);	/* be sure these related procs are initialized */
     1308 	call iodd_quit_handler_$init (stat_p);
     1309 
     1310 	call write_control_form_$init (stat_p);
     1311 
     1312 	iodd_static.initialized = "1"b;		/* tell the signal handler we are initialized */
     1313 
     1314 
     1315 	call iodd_static.driver_init (stat_p);		/* take it away */
     1316 
     1317 
     1318 /*	if we return, the driver was not able to initialize.  so try again */
     1319 
     1320 	call iodd_msg_ (error, both, 0, id, "Unable to initialize driver.^/");
     1321 
     1322 	go to start_new_device_cleanup;		/* let the handler do the work */
     1323 
     1324 
     1325 out:
     1326 	if iodd_static.test_entry then do;		/* make a clean return if testing */
     1327 	     if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
     1328 		call hangup_station;
     1329 	     call ipc_$delete_ev_chn (iodd_static.timer_chan, code);
     1330 	     call ipc_$delete_ev_chn (iodd_static.cmd_ack_chan, code);
     1331 	     call ipc_$delete_ev_chn (iodd_static.ctl_dial_chan, code);
     1332 	     call ipc_$delete_ev_chn (iodd_static.dial_ev_chan, code);
     1333 	     call ios_$attach ("error_output", "syn", "user_i/o", "", io_stat);
     1334 
     1335 /* put it back where we found it */
     1336 	     call ios_$detach ("broadcast_errors", "", "", io_stat);
     1337 	     call ios_$order ("user_i/o", "start", null (), io_stat);
     1338 
     1339 /* in case tty dim bug gives trouble */
     1340 	     return;				/* thereby going away */
     1341 	end;
     1342 	else call logout;				/* in normal mode must log out explicitly */
     1343 
     1344 start_new_device_cleanup:
     1345 
     1346 /* the transfer to here will invoke all cleanup handlers */
     1347 	call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
     1348 						/* put it back in case it was changed */
     1349 
     1350 	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
     1351 	     call hangup_station;
     1352 
     1353 	call kill_device;				/* inform the coordinator that current device is gone */
     1354 	go to new_device;				/* now go back and start over */
     1355 
     1356 driver_logout_label:
     1357 	if iodd_static.ctl_term.attached then do;	/* we may have a new ctl_term */
     1358 	     call ipc_$delete_ev_chn (iodd_static.ctl_dial_chan, code);
     1359 						/* tell initializer */
     1360 	     line = NL || "hangup terminal" || NL;
     1361 	     call ios_$write (iodd_static.ctl_io, addr (line), 0, length (rtrim (line)), (0), io_stat);
     1362 	     call ios_$order (iodd_static.ctl_io, "runout", null, io_stat);
     1363 	     call ios_$order (iodd_static.ctl_io, "hangup", null, io_stat);
     1364 						/* now free the tty chan */
     1365 	     call ios_$detach (iodd_static.ctl_io, "", "", io_stat);
     1366 	end;
     1367 	call kill_device;				/* tell the coord if we can */
     1368 	call hangup_station;			/* this will tell iox_ we don't have the terminal */
     1369 	go to out;				/* this will correct for test mode */
     1370 
     1371 re_init_driver:
     1372 
     1373 /* this will invoke all cleanup handlers */
     1374 	call kill_device;
     1375 	if iodd_static.re_init_in_progress then		/* Only way to get here with this set... */
     1376 	     if iodd_static.logout_on_hangup then do;	/* is in case of a hangup */
     1377 		call iodd_msg_ (error, both, 0, id, "Driver logging out.  (hangup_on_logout in effect.)");
     1378 		goto out;
     1379 	     end;
     1380 	iodd_static.recursion_flag = "0"b;		/* clear incase of signal during attachment */
     1381 	iodd_static.re_init_in_progress = "0"b;		/* anyone who cares already knows */
     1382 	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then do;
     1383 						/* re-validate the station if line variable type */
     1384 	     if ^iodd_static.initialized then
     1385 		call hangup_station;		/* in case remote_driver_ couldn't hangup */
     1386 	     iodd_static.initialized = "0"b;
     1387 	     iodd_static.no_coord_flag = "0"b;
     1388 	     call timer_manager_$sleep (10, RELATIVE_SECONDS);	/* let answering service clean up */
     1389 	     go to get_tables;
     1390 	end;
     1391 	iodd_static.initialized = "0"b;
     1392 	if iodd_static.attach_type ^= ATTACH_TYPE_IOM then
     1393 	     call timer_manager_$sleep (10, RELATIVE_SECONDS);	/* let answering service clean up */
     1394 	if iodd_static.no_coord_flag then
     1395 	     go to re_init_junction;
     1396 	go to new_device;
     1397 
     1398 no_coord_signal:
     1399 
     1400 /* this will invoke all cleanup handlers then wait for a new coordinator */
     1401 	call kill_device;				/* this is to terminate the segs */
     1402 	iodd_static.recursion_flag = "0"b;
     1403 	iodd_static.initialized = "0"b;
     1404 	iodd_static.re_init_in_progress = "0"b;		/* all who care have seen this */
     1405 
     1406 	call iodd_msg_ (error, master, 0, id, "Driver will await new coordinator.");
     1407 	times = 0;
     1408 
     1409 check_proc_id:
     1410 	if iodc_data.proc_id ^= (36)"0"b then
     1411 	     if iodc_data.proc_id ^= iodd_static.coord_proc_id then
     1412 						/* see if there is a new process id */
     1413 		if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
     1414 		     go to get_tables;
     1415 		else go to re_init_junction;
     1416 
     1417 /* 		not changed yet, wait 30 seconds and try again */
     1418 
     1419 	times = times + 1;				/* record the number of times we sleep */
     1420 	if times > 10 then do;			/* only wait 5 minutes */
     1421 
     1422 	     call iodd_msg_ (error, master, 0, id, "^a^/Waited too long for coordinator. Process logging out.^/^a^a",
     1423 		stars, stars, bel_string);
     1424 	     go to driver_logout_label;		/* nothing else left to do */
     1425 
     1426 	end;
     1427 	call timer_manager_$sleep (30, RELATIVE_SECONDS);		/* sleep for 30 seconds, then... */
     1428 	go to check_proc_id;			/* try again */
     1429 
     1430 
     1431 
     1432 /* ---------INTERNAL PROCEDURES ------------ */
     1433 
     1434 
     1435 early_quit: proc;
     1436 
     1437 /* If we get a quit before regular handler is set up */
     1438 
     1439 
     1440 dcl  cmd char (80);
     1441 dcl  line char (32);
     1442 dcl  nc fixed bin (21);
     1443 dcl  stat bit (72) aligned;
     1444 dcl  give_start bit (1);
     1445 
     1446 	give_start = "1"b;				/* give an auto start unless something happens */
     1447 
     1448 	call ioa_$ioa_stream ("user_i/o", "^/Early ""quit""^/");
     1449 
     1450 	call timer_manager_$alarm_call (iodd_static.auto_start_delay, RELATIVE_SECONDS, try_auto_start);
     1451 
     1452 	on alrm call continue_to_signal_ (code);	/* let this go through */
     1453 
     1454 	on any_other begin;
     1455 	     give_start = "0"b;			/* stop the auto start proc */
     1456 	     call timer_manager_$reset_alarm_call (try_auto_start);
     1457 						/* in case this frame goes away */
     1458 	     call continue_to_signal_ (code);
     1459 	end;
     1460 
     1461 get_line:
     1462 	call ioa_$ioa_stream ("user_i/o", "Enter command(early quit):");
     1463 	call iox_$get_line (iodd_static.master_in, addr (cmd), 80, nc, code);
     1464 						/* get a command line */
     1465 	if give_start then do;			/* expecting to give an auto start? */
     1466 	     give_start = "0"b;			/* we got something, so cancel the auto_start */
     1467 	     call timer_manager_$reset_alarm_call (try_auto_start);
     1468 						/* don't use a bad frame */
     1469 	end;
     1470 	if code ^= 0 then
     1471 	     go to no_master;
     1472 
     1473 	line = substr (cmd, 1, nc - 1);
     1474 	if line = "" then
     1475 	     go to get_line;			/* be nice about blank lines */
     1476 
     1477 	if line = "start" then do;
     1478 auto_start:
     1479 	     call ios_$order ("user_i/o", "start", null, stat);
     1480 						/* be sure we don't lose a wakeup */
     1481 	     return;
     1482 	end;
     1483 
     1484 	else if line = "new_device" then do;
     1485 	     go to start_new_device_cleanup;
     1486 	end;
     1487 
     1488 	else if line = "logout" then do;
     1489 	     go to driver_logout_label;		/* assume he really means it */
     1490 	end;
     1491 
     1492 	else if line = "return" then do;		/* return to the caller of iodd_$iodd_init */
     1493 	     if iodd_static.test_entry then
     1494 		go to out;
     1495 	end;
     1496 
     1497 	else if line = "debug" then do;
     1498 	     if iodd_static.test_entry then do;
     1499 		call ioa_$ioa_stream ("user_i/o", "Calling debug");
     1500 						/* let him know what we are doing */
     1501 		call debug;
     1502 		go to get_line;
     1503 	     end;
     1504 	end;
     1505 
     1506 	else if line = "probe" | line = "pb" then do;
     1507 	     if iodd_static.test_entry then do;
     1508 		call ioa_$ioa_stream ("user_i/o", "Calling probe");
     1509 						/* let him know what we are doing */
     1510 		call probe;
     1511 		go to get_line;
     1512 	     end;
     1513 	end;
     1514 
     1515 	else if line = "pi" then do;
     1516 	     if iodd_static.test_entry then do;
     1517 		signal program_interrupt;
     1518 		go to get_line;			/* in case it returns */
     1519 	     end;
     1520 	end;
     1521 
     1522 	else if line = "." | line = "hold" then
     1523 	     go to get_line;			/* we just cancelled the auto start */
     1524 
     1525 	else if line = "help" then do;		/* tell what commands can be used */
     1526 	     call ioa_$ioa_stream ("user_i/o", "Commands at this level are: hold, start, new_device, logout");
     1527 	     if iodd_static.test_entry then
     1528 		call ioa_$ioa_stream ("user_i/o", "Test commands: debug, probe, return, pi");
     1529 	     go to get_line;
     1530 	end;
     1531 
     1532 	call ioa_$ioa_stream ("user_i/o", "Invalid response: ""^a""  Type ""help"" for instructions.", line);
     1533 	go to get_line;
     1534 
     1535 try_auto_start: proc;
     1536 
     1537 	     if give_start then do;
     1538 		call ioa_$ioa_stream ("user_i/o", "Automatic start given.");
     1539 		go to auto_start;
     1540 	     end;
     1541 	     return;				/* otherwise forget it */
     1542 
     1543 	end;
     1544 
     1545      end early_quit;
     1546 
     1547 
     1548 
     1549 init_seg: proc (dir_name, seg_name, segp, num_times, ec);
     1550 
     1551 /* Little procedure to initiate segments */
     1552 
     1553 dcl  seg_name char (*);
     1554 dcl  segp ptr;
     1555 dcl  dir_name char (*);
     1556 dcl  num_times fixed bin;				/* number of times we should try to initiate */
     1557 dcl  ec fixed bin (35);
     1558 dcl  times fixed bin;
     1559 
     1560           times = 0;				/* haven't tried at all yet */
     1561 try_again:					/* be sure to set reference name */
     1562 	call hcs_$initiate (dir_name, seg_name, seg_name, 0, 1, segp, ec);
     1563 	if segp = null () then
     1564 	     if ec = error_table_$namedup then do;
     1565 		call hcs_$terminate_name (seg_name, ec);
     1566 		if ec = 0 then
     1567 		     go to try_again;
     1568 		return;				/* all attempts have failed */
     1569 	     end;
     1570 	     else if ec = error_table_$noentry then do;
     1571 
     1572 /* wait a bit and try again (coordinator may create seg. when it comes up) */
     1573 		times = times + 1;			/* count the number of times we try */
     1574 		if times > num_times then
     1575 		     return;			/* after num_times give up */
     1576 		call timer_manager_$sleep (30, RELATIVE_SECONDS);
     1577 		go to try_again;
     1578 	     end;
     1579 	     else return;				/* unrecoverable error */
     1580 	ec = 0;
     1581 	return;
     1582      end init_seg;
     1583 
     1584 
     1585 attach_and_listen: proc (code);
     1586 
     1587 dcl  station_id char (32);
     1588 dcl  code fixed bin (35);
     1589 dcl  att_desc char (256);
     1590 dcl  tries fixed bin;
     1591 dcl  station_password char (8);
     1592 dcl  cmd_msg char (32);
     1593 dcl  err_msg char (80);
     1594 dcl  len fixed bin (21);
     1595 
     1596 dcl  1 hangup_info aligned,				/* structure for the "hangup_proc" control order */
     1597        2 entry entry,				/* entry to be called */
     1598        2 data_ptr ptr,				/* pointer to be passed to entry */
     1599        2 priority fixed bin;				/* ipc_ call chan priority */
     1600 
     1601 	code = 0;
     1602 	tries = 0;				/* count the attach attempts, allow up to five */
     1603 
     1604 /* make attach description */
     1605 	call ioa_$rsnnl ("remote_teleprinter_ " || return_string (lte.att_desc), att_desc, len, lte.chan_id);
     1606 
     1607 attach_chan:
     1608 	tries = tries + 1;				/* increment the attempt count */
     1609 	if tries > 5 then do;			/* over 5, give up */
     1610 	     code = error_table_$no_operation;		/* be sure we abort this device */
     1611 	     call iodd_msg_ (error, master, 0, id, "All attach attempts failed.");
     1612 						/* sound beeper */
     1613 	     return;
     1614 	end;
     1615 
     1616 	call iodd_msg_ (normal, master, 0, "", "Attaching line ""^a"" on channel (^a).", lte.line_id, lte.chan_id);
     1617 
     1618 	call timer_manager_$sleep (5, RELATIVE_SECONDS);		/* pause to allow answering service to catch up */
     1619 
     1620 	iodd_static.major_device = "";		/* no station defined at this point */
     1621 	iodd_static.attach_type = 0;			/* nothing really attached yet either */
     1622 	iodd_static.attach_name = "";
     1623 	request_dev.major_index = 0;
     1624 	request_dev.major_name = "";
     1625 
     1626 	call iox_$attach_name ("teleprinter", iodd_static.slave_in, att_desc, null, code);
     1627 	if code ^= 0 then
     1628 	     if ^(code = error_table_$ionmat | code = error_table_$not_detached) then do;
     1629 						/* very bad */
     1630 		call iodd_msg_ (normal, master, code, id, "Unable to attach line.");
     1631 		call hangup_station;		/* just to be sure */
     1632 		go to attach_chan;			/* now try again */
     1633 	     end;
     1634 
     1635 	call iox_$open (iodd_static.slave_in, Stream_input_output, ""b, code);
     1636 	if code ^= 0 then
     1637 	     if code ^= error_table_$not_closed then do;
     1638 		call iodd_msg_ (normal, master, code, id, "Unable to open line io switch.");
     1639 		call hangup_station;		/* just to be sure */
     1640 		go to attach_chan;			/* now try again */
     1641 	     end;
     1642 
     1643 	iodd_static.slave.active = "1"b;		/* got a live one */
     1644 	iodd_static.slave.accept_input = "1"b;
     1645 	iodd_static.slave.print_errors = "1"b;
     1646 	iodd_static.slave_out = iodd_static.slave_in;	/* they are both the same */
     1647 	iodd_static.slave_input, iodd_static.slave_output = "teleprinter";
     1648 	iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE;
     1649 						/* tell all what we did */
     1650 	iodd_static.attach_name = lte.chan_id;
     1651 
     1652 	call iox_$control (iodd_static.slave_in, "read_status", addr (read_info), code);
     1653 	if code ^= 0 then do;
     1654 	     call iodd_msg_ (normal, master, code, id, "Attempting read_status control operation.");
     1655 	     call hangup_station;
     1656 	     go to attach_chan;			/* now try again */
     1657 	end;
     1658 
     1659 	iodd_static.slave_ev_chan = read_info.ev_chan;	/* save this for later */
     1660 
     1661 	hangup_info.entry = iodd_hangup_$iodd_hangup_;	/* in case answering service detects a hangup */
     1662 	hangup_info.data_ptr = stat_p;
     1663 	hangup_info.priority = 1;
     1664 
     1665 	call iox_$control (iodd_static.slave_in, "hangup_proc", addr (hangup_info), code);
     1666 	if code ^= 0 then
     1667 	     call iodd_msg_ (normal, master, code, id,
     1668 		"Warning: Could not establish handler for hangups from the device.");
     1669 
     1670 	call iodd_msg_ (normal, master, 0, "", "Requesting station identifier on line ""^a"".", lte.line_id);
     1671 
     1672 	call iox_$put_chars (iodd_static.slave_out, addr (FF), 1, code);
     1673 						/* start a new page */
     1674 	if code ^= 0 then
     1675 	     go to drop_station;
     1676 
     1677 	tries = 0;				/* attempt counter is now used for station IDs */
     1678 	cmd_msg = "Enter station command:" || NL;
     1679 	go to ask_for_station;
     1680 
     1681 clear_input_buffer:					/* flush all input buffers */
     1682 	call iox_$control (iodd_static.slave_in, "resetread", null, code);
     1683 
     1684 ask_for_station:
     1685 	tries = tries + 1;				/* increment the count of station ids requested */
     1686 	if tries > 10 then
     1687 	     go to drop_station;			/* over the limit, hangup the intruder */
     1688 
     1689 	call iox_$put_chars (iodd_static.slave_out, addr (cmd_msg), length (rtrim (cmd_msg)), code);
     1690 	if code ^= 0 then do;
     1691 drop_station:  call hangup_station;
     1692 	     call iodd_msg_ (normal, master, code, id, "Trouble initializing station.  Will re-attach line.");
     1693 	     tries = 0;				/* reset the attach counter for new station */
     1694 	     call timer_manager_$sleep (10, RELATIVE_SECONDS);	/* let the line settle or operator send quit */
     1695 	     go to attach_chan;
     1696 	end;
     1697 
     1698 	call iox_$control (iodd_static.slave_out, "runout", null, code);
     1699 						/* force out the message */
     1700 
     1701 /*	Look for the command line:  station <station_id> <station_password>	 */
     1702 
     1703 	line = "";				/* clear the input buffer */
     1704 	call iox_$get_line (iodd_static.slave_in, addr (line), 80, len, code);
     1705 	if code ^= 0 then
     1706 	     go to drop_station;
     1707 
     1708 	line = rtrim (line, " " || NL);		/* strip any new line chars */
     1709 
     1710 	if index (line, "station") = 0 then
     1711 	     go to bad_cmd;
     1712 
     1713 	station_id = before (ltrim (after (line, "station")), " ");
     1714 
     1715 	if station_id = "" then do;
     1716 bad_cmd:	     call iodd_msg_ (normal, both, 0, "***", "Invalid station command.");
     1717 	     go to clear_input_buffer;
     1718 	end;
     1719 
     1720 	station_password = before (ltrim (after (line, rtrim (station_id))), " ");
     1721 	if station_password = "" then			/* ... left off password: ask for it */
     1722 	     call read_password_$switch (iodd_static.slave_out, iodd_static.slave_in, STATION_PW_PROMPT,
     1723 		station_password, code);
     1724 	if station_password = "*" then		/* ... user really wants a blank password */
     1725 	     station_password = "";
     1726 
     1727 	if station_password ^= "" then do;
     1728 	     temp_password = station_password;
     1729 	     station_password = scramble_ (temp_password);
     1730 	     temp_password = "";			/* Security */
     1731 	end;
     1732 	call validate_card_input_$station (station_id, station_password, err_msg, code);
     1733 	station_password = "";			/* Security */
     1734 	if code ^= 0 then do;
     1735 	     call iodd_msg_ (normal, both, 0, "***", "^a: ^a", err_msg, station_id);
     1736 	     go to clear_input_buffer;
     1737 	end;
     1738 
     1739 /*	assume the station_id and major device are the same */
     1740 
     1741 	request_dev.major_name, iodd_static.major_device = station_id;
     1742 
     1743 	request_dev.major_index = 0;
     1744 	do i = 1 to iod_device_tab.n_devices while (request_dev.major_index = 0);
     1745 	     idtep = addr (iod_device_tab.entries (i));	/* use new ptr for easy reference */
     1746 	     if idte.dev_id = request_dev.major_name then
     1747 		request_dev.major_index = i;		/* record the index */
     1748 	end;
     1749 	if request_dev.major_index = 0 then do;		/* not found */
     1750 	     call iodd_msg_ (normal, both, 0, "***", "Station ""^a"" not defined in iod_tables.",
     1751 		request_dev.major_name);
     1752 	     go to clear_input_buffer;		/* let him try again....or quit */
     1753 	end;
     1754 
     1755 	if substr (lte.maj_dev_list, request_dev.major_index, 1) ^= "1"b then do;
     1756 						/* OOPS */
     1757 	     call iodd_msg_ (normal, both, 0, "***", "Station ""^a"" is not permitted to use Line ""^a"".", idte.dev_id,
     1758 		lte.line_id);
     1759 	     go to clear_input_buffer;
     1760 	end;
     1761 
     1762 	call iodd_msg_ (normal, master, 0, "", "Driver initializing for station:  ^a", iodd_static.major_device);
     1763 
     1764 	code = 0;					/* all was well, say so */
     1765 
     1766 	return;
     1767 
     1768      end attach_and_listen;
     1769 
     1770 
     1771 find_device_class: proc (string, ind, dev_class, request_type, ec);
     1772 
     1773 /* Internal procedure to search the queue group table and the device class
     1774*   table to find the device class index for the specified input string.
     1775*   The string is in the form of request_type.dev_class with the dev_class part
     1776*   being optional, thus assuming request_type.request_type.  */
     1777 
     1778 dcl  string char (*);				/* input can be no more than 64 chars */
     1779 dcl  ind fixed bin;					/* the device class index - output */
     1780 dcl  dev_class char (32);				/* device class name used - output */
     1781 dcl  request_type char (32);				/* queue group name used - output */
     1782 dcl  ec fixed bin (35);				/* error code returned */
     1783 dcl  i fixed bin;					/* random fixed bin variable */
     1784 dcl  qgt_index fixed bin;				/* index of the queue group entry in the table */
     1785 
     1786 
     1787 	ec = 0;					/* clear the error code */
     1788 
     1789 /* break it into two components, if there.  If only one component, make
     1790*   device_class the same as request_type */
     1791 
     1792 	request_type = before (string, ".");
     1793 	dev_class = after (string, ".");
     1794 	if dev_class = "" then
     1795 	     dev_class = request_type;
     1796 	if request_type = "" then do;
     1797 	     ec = error_table_$badopt;		/* first char was ".", naughty */
     1798 	     call iodd_msg_ (normal, slave, 0, "", "Illegal form of request_type: ^a", string);
     1799 	     return;
     1800 	end;
     1801 
     1802 /*	search the queue group table for the requested entry */
     1803 	do i = 1 to iodd_static.qgtp -> q_group_tab.n_q_groups;
     1804 	     if iodd_static.qgtp -> q_group_tab.entries (i).name = request_type then
     1805 		go to found_group;
     1806 	end;
     1807 
     1808 	call iodd_msg_ (normal, slave, 0, "", "Request type ""^a"" not found in table.", request_type);
     1809 	ec = error_table_$badopt;
     1810 	return;
     1811 
     1812 found_group:
     1813 	qgtep = addr (iodd_static.qgtp -> q_group_tab.entries (i));
     1814 						/* for easy reference */
     1815 	qgt_index = i;				/* save the index for the next test */
     1816 
     1817 /*	Now look in the device class table for the entry which matches the dev_class and request_type */
     1818 	do i = qgte.first_dev_class to qgte.last_dev_class;
     1819 	     dctep = addr (iodd_static.dev_class_ptr -> dev_class_tab.entries (i));
     1820 	     if dcte.qgte_index = qgt_index then	/* must belong to the request_type */
     1821 		if dcte.id = dev_class then do;	/* and be the right name */
     1822 		     ind = i;			/* return the index of the entry */
     1823 		     return;
     1824 		end;
     1825 	end;
     1826 
     1827 	ec = error_table_$badopt;			/* no entry found */
     1828 	call iodd_msg_ (normal, slave, 0, "", "Device class ""^a"" not found.", dev_class);
     1829 	return;
     1830 
     1831      end find_device_class;
     1832 
     1833 
     1834 validate_request: proc (ind, code);
     1835 
     1836 /* Internal procedure to check that the device class index for the minor
     1837*   device in the request_dev structure specified by "ind" is valid for this
     1838*   process at its current access authorization.  The IO coordinator will make
     1839*   the same checks,  this check is made so we can properly respond to the
     1840*   operator at the right time if an error occurs. */
     1841 
     1842 dcl  ind fixed bin;					/* minor device index in the request_dev structure */
     1843 dcl  code fixed bin (35);				/* error code to be returned */
     1844 dcl  ec fixed bin (35);				/* local error code */
     1845 dcl  i fixed bin;					/* index variables */
     1846 dcl  authorization bit (72) aligned;			/* access authorization of process */
     1847 dcl  dev_label char (32);				/* name for messages */
     1848 dcl  allowed_name char (24);				/* driver's name max of 22 char */
     1849 dcl  allowed_proj char (12);				/* driver's project...max of 9 char */
     1850 dcl  driver_name char (24);				/* driver's name max of 22 char */
     1851 dcl  driver_proj char (12);				/* driver's project...max of 9 char */
     1852 dcl  userid char (32);				/* copy of the required driver userid */
     1853 
     1854 	i = ind;					/* copy the argument */
     1855 	if request_dev.n_minor = 1 then
     1856 	     dev_label = request_dev.major_name;
     1857 	else dev_label = char (rtrim (request_dev.major_name) || "." || request_dev.minor (i).name, length (dev_label));
     1858 	if request_dev.minor (i).dvc_index = 0 then do;
     1859 	     call iodd_msg_ (normal, both, 0, "", "No default request type has been assigned to device ""^a"".",
     1860 		dev_label);
     1861 	     code = error_table_$noentry;		/* indicate an error */
     1862 	     return;				/* nothing more we can check */
     1863 	end;
     1864 
     1865 	dctep = addr (iodd_static.dev_class_ptr -> dev_class_tab.entries (request_dev.minor (i).dvc_index));
     1866 
     1867 	ec = 0;					/* initialize the failure indicator */
     1868 
     1869 /*	First check that this minor device is allowed for this device class */
     1870 	if ^(substr (dcte.device_list, request_dev.minor (i).index, 1)) then do;
     1871 						/* if the device bit is off...too bad */
     1872 	     call iodd_msg_ (normal, both, 0, "", "Device ""^a"" is not allowed for device class ""^a"".", dev_label,
     1873 		dcte.id);
     1874 	     ec = error_table_$noentry;		/* flag the error */
     1875 						/* then keep going to give all possible errors */
     1876 	end;
     1877 
     1878 /*	Now check that the process access authorization is high enough to handle all requests */
     1879 
     1880 	authorization = get_authorization_ ();		/* get current authorization */
     1881 
     1882 	if ^aim_check_$greater_or_equal (authorization, dcte.max_access) then do;
     1883 						/* fail if authorization is not greater or equal */
     1884 						/* to highest request driver is to handle */
     1885 	     call iodd_msg_ (normal, both, 0, "",
     1886 		"Process access authorization is not sufficient for device class ""^a"".", dcte.id);
     1887 	     ec = error_table_$ai_restricted;		/* set the failure flag */
     1888 						/* this error should be error_table_$ai_restricted */
     1889 
     1890 	end;
     1891 
     1892 /*	Now check for the correct process group id of the driver */
     1893 
     1894 	userid = get_group_id_ ();			/* get id of driver */
     1895 	driver_name = before (userid, ".");		/* and break into components */
     1896 	driver_proj = before (after (userid, "."), ".");
     1897 
     1898 /* 		get ready to look at the q_group_tab entry */
     1899 
     1900 	qgtep = addr (iodd_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
     1901 
     1902 	userid = qgte.driver_id;			/* get id of allowed drivers */
     1903 	allowed_name = before (userid, ".");		/* and break into components */
     1904 	allowed_proj = before (after (userid, "."), ".");
     1905 
     1906 	if allowed_name ^= driver_name then		/* name must be equal or "*" to be accepted */
     1907 	     if allowed_name ^= "*" then
     1908 		go to name_err;			/* too bad for him */
     1909 
     1910 	if allowed_proj ^= driver_proj then do;		/* project must match */
     1911 name_err:
     1912 	     call iodd_msg_ (normal, both, 0, "", "User ""^a.^a"" not authorized as driver for request type ""^a"".",
     1913 		driver_name, driver_proj, qgte.name);	/* tell the operator */
     1914 	     ec = error_table_$user_not_found;		/* indicate failure */
     1915 	end;
     1916 
     1917 /*	If all was well give back the device class name */
     1918 	if ec = 0 then
     1919 	     request_dev.minor (i).dev_class = dcte.id;	/* save the dvc name */
     1920 	code = ec;				/* report any errors */
     1921 
     1922 	return;
     1923 
     1924 
     1925      end validate_request;
     1926 
     1927 
     1928 kill_device: proc;
     1929 
     1930 /* internal procedure to tell the IO coordinator that the device and all
     1931*   minor devices which have been assigned to this process should be released */
     1932 
     1933 dcl  coord_chan fixed bin (71);			/* place for copy of coord ev chan */
     1934 dcl  send bit (1);					/* flag to abort sending a wakeup */
     1935 dcl  recursion_flag bit (1);
     1936 dcl  i fixed bin;					/* local index variable */
     1937 dcl  (p, p1) ptr;					/* temp ptr for easy reading */
     1938 dcl  code fixed bin (35);
     1939 
     1940           recursion_flag = "0"b;
     1941 
     1942 	on command_error ;
     1943 	on any_other begin;				/* in case driver_status is gone */
     1944 	     send = "0"b;				/* abort the wakeup */
     1945 	     if recursion_flag then
     1946 		go to forget_it;
     1947 	     recursion_flag = "1"b;
     1948 	     go to term_seg;			/* but try to clean up address space */
     1949 	end;
     1950 
     1951 	if driver_ptr_list.number = 0 then do;		/* see if any have been assigned */
     1952 	     send = "0"b;				/* if not, abort wakeup */
     1953 	     go to term_seg;			/* try to terminate the parent dir */
     1954 	end;
     1955 	else send = "1"b;
     1956 
     1957 	event_message = 0;				/* clear the event message of trash */
     1958 	msgp = addr (event_message);			/* setup event message */
     1959 	msgp -> ev_msg.code = 4;			/* code 4: we are about to logout */
     1960 	msgp -> ev_msg.minor_dev_index =		/* name a minor device so coord can release */
     1961 	     driver_ptr_list.stat_segp (1) -> driver_status.dev_index;
     1962 	coord_chan = driver_ptr_list.stat_segp (1) -> driver_status.coord_chan;
     1963 
     1964 /* save this in temp because we must terminate status seg before using it */
     1965 term_seg:
     1966 	do i = 1 to driver_ptr_list.number;		/* first terminate all driver status segs */
     1967 	     p = driver_ptr_list.stat_segp (i);
     1968 	     if send then do;			/* can we still reference a driver status seg ? */
     1969 		call ipc_$delete_ev_chn (p -> driver_status.driver_chan, code);
     1970 		p1 = p -> driver_status.rqti_ptr;	/* get rqti ptr */
     1971 		if p1 ^= null then
     1972 		     call hcs_$terminate_noname (p1, code);
     1973 						/* try to terminate */
     1974 	     end;
     1975 	     call hcs_$terminate_noname (p, code);
     1976 	     if code ^= 0 then
     1977 		call iodd_msg_ (error, master, code, "kill_device",
     1978 		     "Warning: driver status segment may be initiated.");
     1979 	end;
     1980 	if iodd_static.major_device ^= "" then do;
     1981 	     call hcs_$terminate_file (sys_dir, iodd_static.major_device, 0, code);
     1982 	     if code ^= 0 then
     1983 		call iodd_msg_ (error, master, code, "kill_device",
     1984 		     "Warning: directory ^a in ^a may not be terminated.", iodd_static.major_device, sys_dir);
     1985 	end;
     1986 	iodd_static.major_device = "";		/* the device is gone */
     1987 	driver_ptr_list.number = 0;			/* assume all driver stat segs are gone */
     1988 	if send then				/* inform the coord only after all terminations are done */
     1989 	     call hcs_$wakeup (iodd_static.coord_proc_id, coord_chan, event_message, code);
     1990 
     1991 /* forget error code....can't do anything about it */
     1992 forget_it:
     1993 	return;
     1994 
     1995      end kill_device;
     1996 
     1997 
     1998 hangup_station: proc;
     1999 
     2000 dcl  ec fixed bin (35);
     2001 
     2002 
     2003 	if iodd_static.slave_out ^= null then do;	/* when defined, drop it */
     2004 	     call iox_$control (iodd_static.slave_out, "hangup", null, ec);
     2005 	     call iox_$close (iodd_static.slave_out, ec);
     2006 	     call iox_$detach_iocb (iodd_static.slave_out, ec);
     2007 	end;
     2008 
     2009 	iodd_static.attach_name = "";
     2010 	iodd_static.slave_out, iodd_static.slave_in = null;
     2011 	iodd_static.slave.active = "0"b;		/* slave must be re-defined */
     2012 	iodd_static.slave.allow_quits = "0"b;
     2013 	iodd_static.slave.accept_input = "0"b;
     2014 	iodd_static.slave.print_errors = "0"b;
     2015 	iodd_static.slave.log_msg = "0"b;		/* must ask for log messages */
     2016 	iodd_static.slave.echo_cmd = "0"b;		/* don't echo cmds by default */
     2017 	iodd_static.slave.priv1 = "0"b;		/* driver module defined privleges */
     2018 	iodd_static.slave.priv2 = "0"b;		/* " */
     2019 	iodd_static.slave.priv3 = "0"b;		/* " */
     2020 	iodd_static.slave_output = null_stream;		/* we are done with this now */
     2021 	iodd_static.slave_input = null_stream;
     2022 
     2023 	return;
     2024 
     2025      end hangup_station;
     2026 
     2027 
     2028 wait_for_dial: proc (ec);
     2029 
     2030 /* Internal procedure to wait for a control terminal to be dialed to the driver
     2031*   process.  We have failed badly if a non-zero value is returned in "ec".  */
     2032 
     2033 dcl  ec fixed bin (35);				/* error code */
     2034 dcl  n_dev fixed bin;				/* dummy for number of dialed dev arg */
     2035 dcl  1 dial_wait aligned,				/* wait list for dial wakeup */
     2036        2 num fixed bin,
     2037        2 chan fixed bin (71);
     2038 
     2039 dcl  1 dial_arg aligned like dial_manager_arg;
     2040 
     2041 	call ipc_$create_ev_chn (iodd_static.ctl_dial_chan, ec);
     2042 	if ec ^= 0 then
     2043 	     return;
     2044 
     2045 	dial_wait.num = 1;				/* we will wait on one channel */
     2046 	dial_wait.chan = iodd_static.ctl_dial_chan;	/* this one */
     2047 	dial_arg.version = dial_manager_arg_version_2;	/* use the constant */
     2048 	dial_arg.dial_qualifier = char (iodd_static.ctl_attach_name, length (dial_arg.dial_qualifier));
     2049 	dial_arg.dial_channel = dial_wait.chan;
     2050 	dial_arg.channel_name = iodd_static.ctl_attach_name;
     2051 						/* this is the tty we want */
     2052 
     2053 	dial_arg.dial_out_destination = "";
     2054 	dial_arg.reservation_string = "";
     2055 	if iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_TTY then do;
     2056 						/* 1 is priv attach, 2 is dial */
     2057 
     2058 	     call dial_manager_$privileged_attach (addr (dial_arg), ec);
     2059 						/* ask for it */
     2060 	     if ec ^= 0 then
     2061 		return;				/* if all is well we will wait */
     2062 	     call iodd_msg_ (normal, both, 0, "",
     2063 		"^a driver waiting for control terminal channel ""^a"" to become active.", iodd_static.major_device,
     2064 		iodd_static.ctl_attach_name);		/* tell operator */
     2065 	end;
     2066 	else do;					/* this is the dial case */
     2067 	     call dial_manager_$allow_dials (addr (dial_arg), ec);
     2068 	     if ec ^= 0 then
     2069 		return;
     2070 
     2071 	     call iodd_msg_ (normal, both, 0, "", "^a driver waiting for control terminal ""^a"" to dial.",
     2072 		iodd_static.major_device, iodd_static.ctl_term.ctl_attach_name);
     2073 						/* tell operator we are waiting */
     2074 	end;
     2075 
     2076 wait:
     2077 	call ipc_$block (addr (dial_wait), addr (event_info), ec);
     2078 	if ec ^= 0 then
     2079 	     return;
     2080 
     2081 	call convert_dial_message_ (event_info.message, dev_name, dim_name, n_dev, status_flags, ec);
     2082 	if ec ^= 0 then
     2083 	     return;
     2084 
     2085 	if status_flags.hung_up then do;		/* someone sent a hangup?? */
     2086 	     call iodd_hangup_$iodd_hangup_ (addr (event_info));
     2087 	     go to wait;				/* in case it returns */
     2088 	end;
     2089 	if ^status_flags.dialed_up then
     2090 	     go to wait;				/* we wait until a "dial" is received */
     2091 
     2092 	iodd_static.ctl_device = dev_name;		/* save the device name here */
     2093 	iodd_static.ctl_dev_dim = dim_name;		/* and the dim */
     2094 
     2095 	call hcs_$make_ptr (ref_ptr, "iodd_hangup_", "iodd_hangup_", temp_ptr, ec);
     2096 						/* for ipc_ call chan */
     2097 	if ec ^= 0 then
     2098 	     return;
     2099 
     2100 	call ipc_$decl_ev_call_chn (iodd_static.ctl_dial_chan, temp_ptr, stat_p, 1, ec);
     2101 	if ec ^= 0 then
     2102 	     return;
     2103 
     2104 	call iodd_msg_ (normal, both, 0, "", "Control terminal accepted.");
     2105 	return;
     2106 
     2107      end wait_for_dial;
     2108 
     2109 
     2110 check_for_dialup: proc (ec);
     2111 
     2112 
     2113 /* This internal procedure checks to be sure the control terminal is in the
     2114*   dialed up state.  The driver can do I/O to the terminal only when it is in
     2115*   the dialed up state.  Otherwise com_err_ and ioa_ will signal "io_error"
     2116*   when trying to write on the control terminal.  That causes nasty things to
     2117*   happen.
     2118*
     2119*   Due to insufficient data from the standard tty dim, we have to call the
     2120*   hardcore tty interface directly.  This should be a temporary measure
     2121*   until a new order call can be defined.   (JCW - Jan 1975)
     2122*
     2123*   Note, due to the use of the hardcore tty interface, this procedure cannot
     2124*   be used for a control terminal attached through mrd_.
     2125**/
     2126 
     2127 dcl  ec fixed bin (35);				/* error code to be returned */
     2128 dcl  tw_index fixed bin;				/* device index of the tty channel */
     2129 dcl  state fixed bin;				/* device state that we are after */
     2130 						/* 1 = inactive  - this cannot happen (they say) */
     2131 						/* 2 = waiting   - terminal is not there */
     2132 						/* 5 = dialed up - on this state we can go */
     2133 
     2134 	ec = 0;					/* start clean */
     2135 
     2136 	if iodd_static.ctl_attach_name ^= idte.ctl_attach_name
     2137 	     | iodd_static.ctl_attach_type ^= idte.ctl_attach_type then do; /* same device? */
     2138 	     ec = 5;				/* the changing device code for caller */
     2139 	     return;
     2140 	end;
     2141 
     2142 	if iodd_static.ctl_dev_dim = "mrd_" then
     2143 	     return;				/* this is never a problem */
     2144 
     2145 	call hcs_$tty_index (iodd_static.ctl_device, tw_index, state, ec);
     2146 	if ec ^= 0 then
     2147 	     return;				/* let caller handle all errors */
     2148 
     2149 	if state ^= 5 then
     2150 	     ec = 10;				/* if not dialed up, drop the terminal */
     2151 
     2152 	return;
     2153 
     2154      end check_for_dialup;
     2155 
     2156 
     2157 return_string: proc (target) returns (char (*));
     2158 
     2159 /* little procedure to return a string from text_strings.chars given the
     2160*   first char index and total number of chars in the string */
     2161 
     2162 dcl  1 target unaligned like text_offset;
     2163 
     2164 	if target.total_chars = 0 then
     2165 	     return ("");
     2166 	else return (
     2167 		substr (iodd_static.text_strings_ptr -> text_strings.chars,
     2168 		target.first_char, target.total_chars)
     2169 		);
     2170 
     2171      end return_string;
     2172  /* BEGIN INCLUDE FILE...device_class.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  1     7*     Ancient History
  1     8*     Coded by R.S.Coren August 1973
  1     9*     Modified by J. Stern, 1/8/75
  1    10*     Modified by J. C. Whitmore, 5/78, to extent the size of the device list
  1    11*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  1    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    13*     Added comment field in dcte.
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 
  1    17 /* format: style4 */
  1    18 
  1    19 dcl  dctp ptr;					/* ptr to device class table */
  1    20 dcl  1 dev_class_tab aligned based (dctp),		/* the device class table */
  1    21        2 n_classes fixed bin,				/* number of device classes */
  1    22        2 pad fixed bin,
  1    23        2 entries (1 refer (dev_class_tab.n_classes)) like dcte;
  1    24 
  1    25 dcl  dctep ptr;					/* device class table entry ptr */
  1    26 
  1    27 dcl  1 dcte aligned based (dctep),			/* device class table entry */
  1    28 
  1    29 /* following items are initialized before daemon is run */
  1    30 
  1    31        2 id char (32),				/* device class name for this entry */
  1    32        2 comment unaligned like text_offset,		/* comment to apply to the device class */
  1    33        2 qgte_index fixed bin,			/* index of queue group table entry */
  1    34        2 pad1 fixed bin,
  1    35        2 max_access bit (72),				/* max request access class */
  1    36        2 min_access bit (72),				/* min request access class */
  1    37        2 min_banner bit (72),				/* min access class to be placed on output banner */
  1    38        2 device_list bit (360),			/* bit _i ON => minor device _i is valid for device class */
  1    39 
  1    40 /* remaining info is dynamic */
  1    41 
  1    42        2 pending_request fixed bin (18),		/* descriptor offset for allocated but unassigned request */
  1    43        2 restart_req fixed bin (18),			/* offset of next (or last) descriptor to be restarted */
  1    44        2 pad2 (3) fixed bin,
  1    45        2 n_waiting fixed bin,				/* number of waiting requests for device class */
  1    46        2 per_queue_info (4),				/* one copy of this for each queue */
  1    47          3 first_waiting fixed bin,			/* index of first waiting list entry */
  1    48          3 last_waiting fixed bin;			/* index of last waiting list entry */
  1    49 
  1    50 
  1    51 /* END INCLUDE FILE...device_class.incl.pl1 */
     2172 
     2173  /* BEGIN INCLUDE FILE ... dial_manager_arg.incl.pl1 */
  2     2 
  2     3 /* Modified by E. N. Kittlitz 11/80 to add reservation string, move dial-out
  2     4*   destination from dial_qualifier, add dial_message.
  2     5*   Modified by Robert Coren 4/83 to add required access class stuff.
  2     6*   Modified 1984-08-27 BIM for V4, privileged_operation.
  2     7**/
  2     8 
  2     9 
  2    10 dcl  dial_manager_arg_version_2 fixed bin internal static initial (2) options (constant);
  2    11 dcl  dial_manager_arg_version_3 fixed bin internal static initial (3) options (constant);
  2    12 dcl  dial_manager_arg_version_4 fixed bin internal static initial (4) options (constant);
  2    13 
  2    14 dcl 1 dial_manager_arg based aligned,
  2    15     2 version fixed bin,				/* = 4 */
  2    16     2 dial_qualifier char (22),			/* identify different processes with same process group id */
  2    17     2 dial_channel fixed bin (71),			/* event wait channel */
  2    18     2 channel_name char (32),				/* channel name for privileged attach */
  2    19 						/* limit of version 1 structure */
  2    20     2 dial_out_destination char (32),			/* dial-out destination (e.g. phone_no) */
  2    21     2 reservation_string char (256),			/* reservation string */
  2    22     2 dial_message fixed bin (71),			/* OUTPUT: A.S. message received by dial_manager_ */
  2    23 						/* limit of version 2 structure */
  2    24     2 access_class bit (72),				/* access class to be associated with the attachment */
  2    25     2 flags aligned,
  2    26      3 access_class_required bit (1) unaligned,		/* indicates whether to enforce access_class */
  2    27      3 privileged_operation bit (1) unaligned,		/* for accept_dials, accepts dials from */
  2    28 						/* system_low:access_class */
  2    29 						/* no effect on other operations yet. */
  2    30      3 mbz bit (34) unaligned;			/* must be zero */
  2    31 
  2    32 /* END INCLUDE FILE ... dial_manager_arg.incl.pl1 */
     2173 
     2174  /* BEGIN INCLUDE FILE ... driver_ptr_list.incl.pl1   */
  3     2 
  3     3 /* This is a list of pointers to the driver status segments used by this process */
  3     4 
  3     5 
  3     6 
  3     7 dcl list_ptr pointer;		/* should be set to iodd_static.driver_list_ptr */
  3     8 
  3     9 dcl 1 driver_ptr_list based(list_ptr),
  3    10        2 number fixed bin,		/* number of pointer entries */
  3    11        2 list_pad fixed bin,		/* pad to even word boundry */
  3    12        2 stat_seg(0 refer(driver_ptr_list.number)),
  3    13           3 stat_segp ptr;		/* pointer to driver status seg(i) */
  3    14 
  3    15 
  3    16 /* END INCLUDE FILE ... driver_ptr_list.incl.pl1  */
     2174 
     2175  /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  4     7*     Ancient History
  4     8*     Coded by Robert S. Coren August 1973
  4     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  4    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  4    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  4    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  4    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  4    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  4    16*     to denote accounting ^= nothing.
  4    17*                                                   END HISTORY COMMENTS */
  4    18 
  4    19 
  4    20 /* status data for a logical device driver */
  4    21 
  4    22 /* format: style4 */
  4    23 
  4    24 dcl  driver_status_ptr ptr;
  4    25 dcl  1 driver_status aligned based (driver_status_ptr),
  4    26        2 req_type_label char (32),			/* string to describe the request type */
  4    27        2 dev_name_label char (32),			/* string to describe the device */
  4    28        2 device_id char (32),				/* minor device name used by this logical driver */
  4    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  4    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  4    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  4    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  4    33        2 request_pending bit (36),			/* locking word for communication with coord */
  4    34 						/* 0 = ready for a request  */
  4    35 						/* driver pid = don't bug me */
  4    36 						/* coord  pid = got a request */
  4    37        2 status_flags,
  4    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  4    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  4    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  4    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  4    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  4    43          3 pad bit (31) unal,
  4    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  4    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  4    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  4    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  4    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  4    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  4    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  4    51 						/* for this logical driver */
  4    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  4    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  4    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  4    55        2 dev_out_stream char (32),			/* output stream for minor device */
  4    56        2 dev_in_stream char (32),			/* input stream for minor device */
  4    57        2 elem_size fixed bin,				/* element size for the stream */
  4    58        2 message_type fixed bin,			/* expected format of user request */
  4    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  4    60        2 forms_validation_ptr ptr,			/* forms validation data */
  4    61        2 dev_ptr1 ptr,				/* another one */
  4    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  4    63        2 dev_fb2 fixed bin,				/* and another */
  4    64        2 dev_fb3 fixed bin,				/* and another */
  4    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  4    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  4    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  4    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  4    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  4    70        2 generic_type char (32),			/* generic type of this minor device */
  4    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  4    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  4    73        2 desc_pad (13) fixed bin,
  4    74        2 message fixed bin;				/* place-holder for copy of request message */
  4    75 
  4    76 
  4    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
     2175 
     2176  /* BEGIN INCLUDE FILE ... iod_constants.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(88-08-31,Brunelle), approve(88-08-31,MCR7911),
  5     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5     7*     Created.
  5     8*                                                   END HISTORY COMMENTS */
  5     9 
  5    10 /* This file contains constants used by the I/O Daemon software in various tables */
  5    11 
  5    12 /* format: style4 */
  5    13 
  5    14 /* literals for use with idte.attach_type & iodd_static.attach_type */
  5    15 dcl  (ATTACH_TYPE_IOM init (1),
  5    16      ATTACH_TYPE_TTY init (2),
  5    17      ATTACH_TYPE_DIAL init (3),
  5    18      ATTACH_TYPE_VARIABLE_LINE init (4)) fixed bin int static options (constant);
  5    19 
  5    20 /* literals for use with idte.ctl_attach_type & iodd_static.ctl_attach_type */
  5    21 dcl  (CTL_ATTACH_TYPE_TTY init (1),
  5    22      CTL_ATTACH_TYPE_DIAL init (2),
  5    23      CTL_ATTACH_TYPE_MC init (3)) fixed bin int static options (constant);
  5    24 
  5    25 /* literals for use with idte.paper_type & iodd_static.paper_type */
  5    26 dcl  (PAPER_TYPE_DEFAULT init (-1),
  5    27      PAPER_TYPE_SINGLE init (1),
  5    28      PAPER_TYPE_CONTINUOUS init (2)) fixed bin int static options (constant);
  5    29 
  5    30 /* END INCLUDE FILE ... iod_constants.incl.pl1 */
     2176 
     2177  /* BEGIN INCLUDE FILE...iod_device_tab.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  6     7*     Ancient History
  6     8*     Created by J. Stern, January 1975
  6     9*     Modified by J. C. Whitmore April 1978
  6    10*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6    11*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    12*     Added comment, head_sheet, tail_sheet, paper_type, forms_table,
  6    13*     forms_validation, font_dir variables to device entries in support of laser
  6    14*     printers.  Changed driver_module, args to text_offset instead of strings.
  6    15*     Added comment, default_form  to minor device entries.  Changed args in
  6    16*     minor device entry to text_offset instead of string.
  6    17*                                                   END HISTORY COMMENTS */
  6    18 
  6    19 
  6    20 /* format: style4 */
  6    21 
  6    22 dcl  idtp ptr;					/* ptr to device table */
  6    23 dcl  1 iod_device_tab aligned based (idtp),		/* IO daemon device table */
  6    24        2 n_devices fixed bin,				/* number of major devices */
  6    25        2 pad fixed bin,
  6    26        2 entries (1 refer (iod_device_tab.n_devices)) like idte; /* entries for major devices */
  6    27 
  6    28 dcl  idtep ptr;					/* major device entry pointer */
  6    29 dcl  1 idte aligned based (idtep),			/* major device entry */
  6    30 
  6    31 /* static info associated with device from the parms file */
  6    32 
  6    33        2 dev_id char (24),				/* major device name */
  6    34        2 comment unaligned like text_offset,		/* comment to apply to the major device */
  6    35        2 attach_name char (32),			/* channel name or dial id for device attachment */
  6    36        2 attach_type fixed bin,			/* indicates meaning of attach_name */
  6    37 						/* see ATTACH_TYPE_XX in iod_constants.incl.pl1 */
  6    38        2 ctl_attach_name char (32),			/* channel, dial id, or source for control terminal attachment */
  6    39        2 ctl_attach_type fixed bin,			/* indicates meaning of ctl_attach_name */
  6    40 						/* see CTL_ATTACH_TYPE_XX in iod_constants.incl.pl1 */
  6    41        2 driver_module unaligned like text_offset,	/* offset to pathname of program to drive device */
  6    42        2 head_sheet unaligned like text_offset,		/* offset to name of head_sheet program to use */
  6    43        2 tail_sheet unaligned like text_offset,		/* offset to name of tail_sheet program to use */
  6    44        2 paper_type fixed bin,			/* -1=default , 1=continuous form, 2=single sheet */
  6    45        2 forms_table unaligned like text_offset,		/* offset to forms table to apply to this queue group */
  6    46        2 forms_validation unaligned like text_offset,	/* offset to name of routine for forms validation */
  6    47        2 font_dir unaligned like text_offset,		/* offset to location of downloadable fonts */
  6    48        2 args unaligned like text_offset,		/* offset to arguments to driver program */
  6    49        2 first_minor fixed bin,			/* index of first minor device for this major device */
  6    50        2 last_minor fixed bin,			/* index of last minor device for this major device */
  6    51 
  6    52 /* dynamic info associated with driver of this device */
  6    53 
  6    54        2 lock bit (36),				/* lock id of current driver */
  6    55        2 process_id bit (36);				/* process id of current driver */
  6    56 
  6    57 dcl  mdtp ptr;
  6    58 dcl  1 minor_device_tab aligned based (mdtp),
  6    59        2 n_minor fixed bin,				/* number of minor devices */
  6    60        2 pad fixed bin,
  6    61        2 entries (1 refer (minor_device_tab.n_minor)) like mdte;
  6    62 
  6    63 dcl  mdtep ptr;					/* minor device entry pointer */
  6    64 dcl  1 mdte aligned based (mdtep),			/* minor device entry */
  6    65 
  6    66 /* static info associated with device from the parms file */
  6    67 
  6    68        2 dev_id char (24),				/* minor device name */
  6    69        2 comment unaligned like text_offset,		/* comment to apply to the minor device */
  6    70        2 default_form unaligned like text_offset,		/* offset to default -form string for minor device */
  6    71        2 default_dev_class fixed bin,			/* default device class index */
  6    72        2 major_index fixed bin,			/* subscript of corresponding major device entry */
  6    73        2 args unaligned like text_offset,		/* offset to arguments to driver program */
  6    74 
  6    75 /* dynamic info associated with driver of this device */
  6    76 
  6    77        2 dev_class_index fixed bin,			/* index of device class table entry */
  6    78        2 current_request fixed bin (18),		/* offset of current request descriptor */
  6    79        2 driver_ptr ptr,				/* ptr to driver status segment */
  6    80        2 active fixed bin,				/* 1 if active, 0 if not active */
  6    81        2 seq_id fixed bin (35);			/* sequence number of last request */
  6    82 
  6    83 /* named constants for attach_type, ctl_attach_type and paper_type are found
  6    84*   in iod_constants.incl.pl1 */
  6    85 
  6    86 /* END INCLUDE FILE...iod_device_tab.incl.pl1 */
     2177 
     2178  /* BEGIN INCLUDE FILE. . . iod_event_message.incl.pl1 */
  7     2 
  7     3 /* Format of event message used to signal io_daemon coordinator */
  7     4 /* and the acknowledge message for signalling the driver */
  7     5 
  7     6 dcl event_message fixed bin(71);
  7     7 
  7     8 dcl 1 ev_msg based aligned,
  7     9 	2 code fixed bin(17) unal,		/* Purpose of wakeup: */
  7    10 					/* 0 = request completed */
  7    11 					/* 1 = request completed, new request wanted */
  7    12 					/* 2 = restart */
  7    13 					/* 3 = save  */
  7    14 					/* 4 = logout */
  7    15 	2 minor_dev_index fixed bin(17) unal,	/* minor device index for driver sending this message */
  7    16 	2 seq_id fixed bin(35);		/* id of request to be restarted/saved */
  7    17 
  7    18 dcl 1 ack_msg aligned based,			/* driver command acknowledgement message */
  7    19 	2 code fixed bin (35),		/* error_table_ code */
  7    20 	2 num fixed bin (35);		/* number for further info */
  7    21 
  7    22 /* END INCLUDE FILE. . . iod_event_message.incl.pl1 */
     2178 
     2179  /* BEGIN INCLUDE FILE iod_line_tab.incl.pl1 */
  8     2 
  8     3 
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  8     7*     Ancient History
  8     8*     Created by J. C. Whitmore Oct 1978
  8     9*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  8    10*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  8    11*     Upgraded to version 5.  Added comment field and changed att_desc from
  8    12*     string to text_offset.
  8    13*                                                   END HISTORY COMMENTS */
  8    14 
  8    15 
  8    16 /* format: style4 */
  8    17 
  8    18 dcl  ltp ptr;
  8    19 dcl  1 line_tab aligned based (ltp),			/* the line id table */
  8    20        2 n_lines fixed bin,				/* number of line id entries */
  8    21        2 pad fixed bin,				/* for the future */
  8    22        2 entries (1 refer (line_tab.n_lines)) like lte;
  8    23 
  8    24 dcl  ltep ptr;					/* line table entry pointer */
  8    25 dcl  1 lte aligned based (ltep),			/* line table entry */
  8    26        2 line_id char (24),				/* logical id for a tty line */
  8    27        2 comment unaligned like text_offset,		/* comment to apply to the line */
  8    28        2 chan_id char (32),				/* the physical channel name for attachment */
  8    29        2 att_desc unaligned like text_offset,		/* the attach description to use */
  8    30        2 maj_dev_list bit (360);			/* bit i ON => major device i is valid for this line id */
  8    31 
  8    32 
  8    33 /* END INCLUDE FILE iod_line_tab.incl.pl1 */
     2179 
     2180  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  9     7*     Ancient History
  9     8*     Created by J. Stern, 1/20/75
  9     9*     Modified by J. C. Whitmore April 1978 for enhancements
  9    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  9    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  9    12*     q_group_tab
  9    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  9    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  9    15*     Change version number to reflect changes in q_group_tab and
  9    16*     iod_device_tab for laser printer support.  Added font tables.
  9    17*                                                   END HISTORY COMMENTS */
  9    18 
  9    19 
  9    20 /* format: style4 */
  9    21 
  9    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  9    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  9    24        2 version char (8),				/* version of this structure */
  9    25        2 date_time_compiled fixed bin (71),
  9    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  9    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  9    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  9    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  9    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  9    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  9    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  9    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  9    34        2 text_strings_offset fixed bin (18),
  9    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  9    36 
  9    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  9    38 dcl  text_strings_ptr ptr;
  9    39 dcl  1 text_strings aligned based (text_strings_ptr),
  9    40        2 length fixed bin,
  9    41        2 chars char (1 refer (text_strings.length)) unaligned;
  9    42 
  9    43 /* this defines text offsets used to locate i/o daemon tables strings in
  9    44*   the text_strings structure */
  9    45 dcl  1 text_offset based,
  9    46        2 first_char fixed bin (18) unsigned unaligned,
  9    47        2 total_chars fixed bin (18) unsigned unaligned;
  9    48 
  9    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  9    50 
  9    51 
  9    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
     2180 
     2181  /* BEGIN INCLUDE FILE ... iodc_data.incl.pl1 */
 10     2 
 10     3 dcl 1 iodc_data based(iodc_data_ptr) aligned,
 10     4 	2 init_event_channel fixed bin(71),	/* channel over which first driver wakeup is expected */
 10     5 	2 proc_id bit(36);			/* coordinator's process id */
 10     6 
 10     7 
 10     8 /* END INCLUDE FILE ... iodc_data.incl.pl1 */
     2181 
     2182  /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
 11     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
 11     7*     Add support for logout_on_hangup option.
 11     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
 11     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 11    10*     Add head/tail_sheet entry variables and paper_type variable.
 11    11*                                                   END HISTORY COMMENTS */
 11    12 
 11    13 /* format: style4 */
 11    14 
 11    15 dcl  stat_p int static ptr;
 11    16 
 11    17 dcl  1 iodd_static based (stat_p) aligned,
 11    18 
 11    19 /*    The first part is set only once for a device driver */
 11    20 
 11    21        2 ithp ptr,					/* pointer to iod tables header */
 11    22        2 ltp ptr,					/* pointer to line table */
 11    23        2 idtp ptr,					/* pointer to device tab */
 11    24        2 mdtp ptr,					/* pointer to minor device table */
 11    25        2 qgtp ptr,					/* pointer to q_group table */
 11    26        2 dev_class_ptr ptr,				/* pointer to device class table */
 11    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
 11    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
 11    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
 11    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
 11    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
 11    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
 11    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
 11    34        2 no_coord_label label,			/* where to go for a no_coord condition */
 11    35        2 log_stream char (32),			/* stream name used for log output */
 11    36        2 master_input char (32),			/* master console input stream for commands */
 11    37        2 master_output char (32),			/* master console output stream for messages */
 11    38        2 master_out ptr,				/* master output iocbp */
 11    39        2 master_in ptr,				/* master input iocbp */
 11    40        2 log_iocbp ptr,				/* log output iocbp */
 11    41        2 error_io ptr,				/* error i/o iocbp */
 11    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
 11    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
 11    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
 11    45        2 device_dim char (32),			/* dim which drives the major device */
 11    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
 11    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
 11    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
 11    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
 11    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
 11    51        2 major_device char (32),			/* name of the major device */
 11    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
 11    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
 11    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
 11    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
 11    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
 11    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
 11    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
 11    59 
 11    60 /*    driver module entrypoints are defined by the following entry variables */
 11    61 
 11    62        2 driver_init entry variable options (variable),
 11    63        2 driver_request entry variable options (variable),
 11    64        2 driver_command entry variable options (variable),
 11    65        2 driver_default_handler entry variable options (variable),
 11    66 
 11    67 /*    entrypoints for head/tail_sheet_ entries */
 11    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
 11    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
 11    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
 11    71 
 11    72        2 paper_type fixed bin,			/* type of paper being used */
 11    73 						/* 1 = single sheet */
 11    74 						/* 2 = continuous forms */
 11    75 
 11    76 /*   The remainder of the data may be dynamic during the device driver's existence */
 11    77 
 11    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
 11    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
 11    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
 11    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
 11    82        2 current_devices fixed bin,			/* number of devices currently active in process */
 11    83        2 output_device char (32),			/* name of minor device currently in use */
 11    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
 11    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
 11    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
 11    87        2 segptr ptr,				/* ptr to current user segment being processed */
 11    88        2 flags,					/* control flags */
 11    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
 11    90          3 test_entry bit (1) unal,			/* driver test entry was called */
 11    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
 11    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
 11    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
 11    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
 11    95          3 master_hold bit (1) unal,			/* master_hold at command level */
 11    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
 11    97          3 step bit (1) unal,				/* run in step mode */
 11    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
 11    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
 11   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
 11   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
 11   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
 11   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
 11   104          3 pad bit (21) unal,				/* unused space */
 11   105        2 slave,					/* slave control device data (ctl term or remote reader) */
 11   106          3 slave_input char (32),			/* slave input stream name */
 11   107          3 slave_output char (32),			/* slave output stream name */
 11   108          3 slave_pad fixed bin,			/* allocation breakage */
 11   109          3 slave_in ptr,				/* slave input iocbp */
 11   110          3 slave_out ptr,				/* slave output iocbp */
 11   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
 11   112          3 active bit (1) unal,			/* on if there is a slave */
 11   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
 11   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
 11   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
 11   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
 11   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
 11   118          3 priv2 bit (1) unal,
 11   119          3 priv3 bit (1) unal,
 11   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
 11   121          3 slave_bit_pad bit (27) unal,			/* unused space */
 11   122        2 ctl_term,					/* control terminal data */
 11   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
 11   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
 11   125          3 ctl_pad fixed bin,				/* allocation breakage */
 11   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
 11   127          3 ctl_input char (32),			/* ctl input stream name */
 11   128          3 ctl_output char (32),			/* ctl output stream name */
 11   129          3 ctl_io char (32),				/* ctl i/o stream name */
 11   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
 11   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
 11   132          3 ctl_device char (32),			/* ctl terminal device name */
 11   133          3 form_type char (16),			/* format type if printing forms */
 11   134          3 attached bit (1) unal,			/* ctl term attached to process */
 11   135          3 forms bit (1) unal,			/* on if printing forms */
 11   136          3 pad bit (34) unal,
 11   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
 11   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
 11   139 
 11   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
     2182 
     2183  /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
 12     2 
 12     3 /* Written 05/04/78 by C. D. Tavares */
 12     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
 12     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
 12     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
 12     7 
 12     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
 12     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
 12    10      iox_$close entry (pointer, fixed bin (35)),
 12    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
 12    12      iox_$delete_record entry (pointer, fixed bin (35)),
 12    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
 12    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
 12    15      iox_$err_not_attached entry options (variable),
 12    16      iox_$err_not_closed entry options (variable),
 12    17      iox_$err_no_operation entry options (variable),
 12    18      iox_$err_not_open entry options (variable),
 12    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
 12    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
 12    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 12    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 12    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
 12    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
 12    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
 12    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
 12    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
 12    28      iox_$propagate entry (pointer),
 12    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 12    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 12    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
 12    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 12    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 12    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 12    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 12    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
 12    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
 12    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
 12    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
 12    40 
 12    41 dcl (iox_$user_output,
 12    42      iox_$user_input,
 12    43      iox_$user_io,
 12    44      iox_$error_output) external static pointer;
 12    45 
 12    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
     2183 
     2184  /* Begin include file ..... iox_modes.incl.pl1 */
 13     2 
 13     3 /* Written by C. D. Tavares, 03/17/75 */
 13     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 13     5 
 13     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 13     7     ("stream_input", "stream_output", "stream_input_output",
 13     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 13     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 13    10      "direct_input", "direct_output", "direct_update");
 13    11 
 13    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 13    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 13    14 
 13    15 dcl (Stream_input initial (1),
 13    16      Stream_output initial (2),
 13    17      Stream_input_output initial (3),
 13    18      Sequential_input initial (4),
 13    19      Sequential_output initial (5),
 13    20      Sequential_input_output initial (6),
 13    21      Sequential_update initial (7),
 13    22      Keyed_sequential_input initial (8),
 13    23      Keyed_sequential_output initial (9),
 13    24      Keyed_sequential_update initial (10),
 13    25      Direct_input initial (11),
 13    26      Direct_output initial (12),
 13    27      Direct_update initial (13)) fixed bin int static options (constant);
 13    28 
 13    29 /* End include file ..... iox_modes.incl.pl1 */
     2184 
     2185  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
 14     2 /* format: style3,idind30 */
 14     3 
 14     4 /* structure returned when message is read from a message segment */
 14     5 
 14     6 
 14     7 dcl	mseg_message_info_ptr	pointer;
 14     8 
 14     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
 14    10 	  2 version		char (8) aligned,
 14    11 	  2 message_code		fixed bin,
 14    12 	  2 control_flags		unaligned,
 14    13 	    3 own			bit (1),
 14    14 	    3 delete		bit (1),
 14    15 	    3 pad			bit (34),
 14    16 	  2 ms_ptr		ptr,		/* pointer to message */
 14    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
 14    18 	  2 ms_id			bit (72),		/* unique ID of message */
 14    19 						/* input in some cases */
 14    20 	  2 ms_access_class		bit (72),		/* message access class */
 14    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
 14    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
 14    23 	  2 sender_level		fixed bin,	/* validation level of sender */
 14    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
 14    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
 14    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
 14    27 
 14    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
 14    29 
 14    30 declare	(
 14    31 	MSEG_READ_FIRST		init (1),
 14    32 	MSEG_READ_LAST		init (2),
 14    33 	MSEG_READ_SPECIFIED		init (3),
 14    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
 14    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
 14    36 	fixed bin int static options (constant);
 14    37 
 14    38 declare  (MSEG_READ_OWN		init ("1"b),
 14    39 	MSEG_READ_DELETE		init ("01"b)
 14    40 	)			bit (36) aligned internal static options (constant);
 14    41 
 14    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     2185 
     2186  /* BEGIN INCLUDE FILE ... new_driver_msg.incl */
 15     2 
 15     3 dcl new_driver_msg_p ptr;
 15     4 
 15     5 dcl 1 new_driver_msg aligned based (new_driver_msg_p),
 15     6       2 wakeup_chan fixed bin (71),		/* event channel for waking driver */
 15     7       2 lock_id bit (36),			/* driver's lock id */
 15     8       2 device_index fixed bin,		/* index of minor device wanted by driver */
 15     9       2 dev_class_index fixed bin;		/* index of device class entry wanted by driver */
 15    10 
 15    11 /* END INCLUDE FILE ... new_driver_msg.incl.pl1 */
     2186 
     2187  /* BEGIN INCLUDE FILE...q_group_tab.incl.pl1 */
 16     2 
 16     3 
 16     4 
 16     5 /****^  HISTORY COMMENTS:
 16     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
 16     7*     Ancient History
 16     8*     Created by J. Stern, December 1974
 16     9*     Modified by J. Whitmore April 1978
 16    10*     Modified by R. McDonald May 1980 to include page charges (UNCA)
 16    11*     Modified by E. N. Kittlitz June 1981 for UNCA changes
 16    12*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
 16    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 16    14*     Add forms_validation, default_form and font_dir variables for laser
 16    15*     printer support.
 16    16*                                                   END HISTORY COMMENTS */
 16    17 
 16    18 
 16    19 /* format: style4 */
 16    20 
 16    21 dcl  qgtp ptr;					/* ptr to queue group table */
 16    22 dcl  1 q_group_tab aligned based (qgtp),
 16    23        2 n_q_groups fixed bin,			/* number of queue groups */
 16    24        2 pad fixed bin,
 16    25        2 entries (1 refer (q_group_tab.n_q_groups)) like qgte; /* entries of queue group table */
 16    26 
 16    27 dcl  qgtep ptr;					/* queue group table entry pointer */
 16    28 dcl  1 qgte aligned based (qgtep),			/* queue group table entry */
 16    29 
 16    30 /* static info from the parms file */
 16    31 
 16    32        2 name char (24),				/* queue group name */
 16    33        2 comment unaligned like text_offset,		/* comment to apply to the request_type */
 16    34        2 driver_id char (32),				/* person.project name of drivers for this q group */
 16    35        2 accounting unaligned like text_offset,		/* offset to accounting routine pathname, "system" => charge_user_ */
 16    36        2 generic_type char (32),			/* generic type of requests in this queue */
 16    37        2 default_generic_queue fixed bin (1),		/* 1 if this is default queue for above generic type, else 0 */
 16    38        2 rqti_seg_name char (32),			/* name of rqti seg, if required, else blank */
 16    39        2 max_queues fixed bin,			/* number of queues for this request type */
 16    40        2 default_queue fixed bin,			/* number of the default queue */
 16    41        2 line_charge,				/* price names for line charges */
 16    42          3 queue (4) char (32),			/* one name for each queue */
 16    43        2 page_charge,				/* price names for page charges */
 16    44          3 queue (4) char (32),			/* one name for each queue */
 16    45        2 forms_table unaligned like text_offset,		/* offset to forms table to apply to this queue group */
 16    46        2 forms_validation unaligned like text_offset,	/* offset to name of routine for forms validation */
 16    47        2 default_form unaligned like text_offset,		/* offset to default -form string if none given */
 16    48        2 font_dir unaligned like text_offset,		/* offset to location of downloadable fonts */
 16    49        2 first_dev_class fixed bin,			/* index of first device class entry of queue group */
 16    50        2 last_dev_class fixed bin,			/* index of last device class entry of queue group */
 16    51 
 16    52 /* dynamic info reflecting current status of queues */
 16    53 
 16    54        2 open fixed bin,				/* 1 if queues have been opened, else 0 */
 16    55        2 per_queue_info (4),
 16    56          3 last_read bit (72),			/* ID of last message read */
 16    57          3 mseg_index fixed bin,			/* message segment index */
 16    58          3 pad fixed bin;				/* pad to even word boundary */
 16    59 
 16    60 /* END INCLUDE FILE...q_group_tab.incl.pl1 */
     2187 
     2188  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 17     2 
 17     3 /* Descriptor associated with an I/O daemon request */
 17     4 /* Coded August 1973 by Robert S. Coren */
 17     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 17     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 17     7 
 17     8 dcl  1 request_descriptor based aligned,
 17     9 	2 mseg_message_info_copy like mseg_message_info,
 17    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 17    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 17    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 17    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 17    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 17    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 17    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 17    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 17    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 17    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 17    20 	2 driver_data bit(252),	/* driver maintained data */
 17    21 	2 flags,
 17    22 	   (3 continued,		/* unfinished by one driver and given to another */
 17    23 	    3 finished,
 17    24 	    3 restarted,
 17    25 	    3 cancelled,
 17    26 	    3 dont_delete,
 17    27 	    3 saved,		/* not to be freed */
 17    28 	    3 keep_in_queue,	/* keep request in queue */
 17    29 	    3 series_restart,	/* this request is part of restarted series */
 17    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 17    31 	    3 pad bit(27) unal,
 17    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 17    33 
 17    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
     2188 
     2189  /* BEGIN INCLUDE FILE timer_manager_constants.incl.pl1 */
 18     2 
 18     3 /****^  HISTORY COMMENTS:
 18     4*  1) change(85-03-05,Sibert), approve(87-05-25,MCR7678),
 18     5*     audit(87-04-02,GDixon), install(87-08-04,MR12.1-1056):
 18     6*     Initially written.
 18     7*                                                   END HISTORY COMMENTS */
 18     8 
 18     9 /* Values for the flags arguments in timer_manager_ calls */
 18    10 
 18    11 dcl ABSOLUTE_MICROSECONDS bit (2) int static options (constant) init ("00"b);
 18    12 dcl ABSOLUTE_SECONDS bit (2) int static options (constant) init ("01"b);
 18    13 dcl RELATIVE_MICROSECONDS bit (2) int static options (constant) init ("10"b);
 18    14 dcl RELATIVE_SECONDS bit (2) int static options (constant) init ("11"b);
 18    15 
 18    16 /* END INCLUDE FILE timer_manager_constants.incl.pl1 */
     2189 
     2190 
     2191      end iodd_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/14/88  1100.1  iodd_.pl1                         >spec>install>1212>iodd_.pl1
2172         1    11/09/88  0759.7  device_class.incl.pl1             >ldd>include>device_class.incl.pl1
2173         2    09/13/84  0921.5  dial_manager_arg.incl.pl1         >ldd>include>dial_manager_arg.incl.pl1
2174         3    08/29/75  1310.5  driver_ptr_list.incl.pl1          >ldd>include>driver_ptr_list.incl.pl1
2175         4    11/09/88  0759.7  driver_status.incl.pl1            >ldd>include>driver_status.incl.pl1
2176         5    11/09/88  0759.7  iod_constants.incl.pl1            >ldd>include>iod_constants.incl.pl1
2177         6    11/09/88  0759.7  iod_device_tab.incl.pl1           >ldd>include>iod_device_tab.incl.pl1
2178         7    09/28/78  1359.8  iod_event_message.incl.pl1        >ldd>include>iod_event_message.incl.pl1
2179         8    11/09/88  0759.7  iod_line_tab.incl.pl1             >ldd>include>iod_line_tab.incl.pl1
2180         9    11/09/88  0759.7  iod_tables_hdr.incl.pl1           >ldd>include>iod_tables_hdr.incl.pl1
2181        10    08/29/75  1310.5  iodc_data.incl.pl1                >ldd>include>iodc_data.incl.pl1
2182        11    11/09/88  0759.7  iodd_static.incl.pl1              >ldd>include>iodd_static.incl.pl1
2183        12    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
2184        13    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
2185        14    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
2186        15    08/29/75  1310.5  new_driver_msg.incl.pl1           >ldd>include>new_driver_msg.incl.pl1
2187        16    11/09/88  0759.7  q_group_tab.incl.pl1              >ldd>include>q_group_tab.incl.pl1
2188        17    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
2189        18    08/06/87  0913.5  timer_manager_constants.incl.pl1  >ldd>include>timer_manager_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTACH_TYPE_IOM                        constant        fixed bin(17,0)          initial dcl 5-15 ref 1392
ATTACH_TYPE_VARIABLE_LINE              constant        fixed bin(17,0)          initial dcl 5-15 ref 428 560 721 1127 1327 1350 1382
                                                                                  1409 1648
CTL_ATTACH_TYPE_DIAL                   constant        fixed bin(17,0)          initial dcl 5-21 ref 1170
CTL_ATTACH_TYPE_MC                     constant        fixed bin(17,0)          initial dcl 5-21 ref 1180
CTL_ATTACH_TYPE_TTY                    constant        fixed bin(17,0)          initial dcl 5-21 ref 1170 2055
FF                              000004 constant        char(1)                  initial packed unaligned dcl 253 set ref 1672 1672
IODT_VERSION_5                  000002 constant        char(8)                  initial packed unaligned dcl 9-49 ref 507
NL                              023534 constant        char(1)                  initial packed unaligned dcl 250 ref 1140 1140 1360
                                                                                  1360 1678 1708
PAPER_TYPE_CONTINUOUS                  constant        fixed bin(17,0)          initial dcl 5-26 ref 980
PAPER_TYPE_SINGLE                      constant        fixed bin(17,0)          initial dcl 5-26 ref 978
RELATIVE_SECONDS                000000 constant        bit(2)                   initial packed unaligned dcl 18-14 set ref 838*
                                                                                  1003* 1388* 1392* 1427* 1450* 1576* 1618* 1694*
STATION_PW_PROMPT               000005 constant        char(23)                 initial packed unaligned dcl 244 set ref 1721*
Stream_input_output             000052 constant        fixed bin(17,0)          initial dcl 13-15 set ref 1635*
accept_input            342(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  389* 727* 1281* 1297* 1644* 2013*
accounting               17            based           structure                level 2 packed packed unaligned dcl 16-28 set ref
                                                                                  912* 916* 919* 923*
acct_entry               60            based           entry variable           level 2 dcl 4-25 set ref 916* 921*
active                  342            based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  384* 725* 1242 1251* 1279 1643* 2011*
addr                                                   builtin function         dcl 261 ref 312 314 321 370 434 434 445 445 531 551
                                                                                  579 625 625 632 632 739 742 784 840 840 840 840
                                                                                  860 906 907 974 989 1009 1009 1009 1009 1114 1114
                                                                                  1141 1141 1152 1152 1198 1199 1201 1219 1219 1221
                                                                                  1228 1228 1234 1234 1235 1236 1287 1287 1291 1291
                                                                                  1361 1361 1463 1463 1652 1652 1665 1665 1672 1672
                                                                                  1689 1689 1704 1704 1745 1812 1819 1865 1900 1958
                                                                                  2058 2058 2067 2067 2076 2076 2076 2076 2086 2086
admin_ec_name           437            based           char(32)                 level 2 dcl 11-17 set ref 701*
after                                                  builtin function         dcl 261 ref 1713 1720 1793 1896 1904
aim_check_$greater_or_equal     000726 constant        entry                    external dcl 99 ref 1882
allow_quits             342(02)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  388* 734* 1280* 1296* 2012*
allowed_name                    003114 automatic       char(24)                 packed unaligned dcl 1848 set ref 1903* 1906 1906
allowed_proj                    003122 automatic       char(12)                 packed unaligned dcl 1849 set ref 1904* 1910
alrm                            000000 stack reference condition                dcl 308 ref 1452
any_other                       002542 stack reference condition                dcl 308 ref 340 1454 1943
arg                       2     002265 automatic       varying char(64)         array level 2 dcl 294 set ref 454 454 456 461 465
                                                                                  469 471 480 482 647 649
args                     40            based           structure                level 2 packed packed unaligned dcl 6-29 ref 975
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 11-17 set ref 717* 982* 1273
att_desc                        002706 automatic       char(256)                packed unaligned dcl 1589 in procedure
                                                                                  "attach_and_listen" set ref 1605* 1626*
att_desc                 17            based           structure                level 2 in structure "lte" packed packed unaligned
                                                                                  dcl 8-25 in procedure "iodd_" set ref 1605*
attach_name             136            based           char(32)                 level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 566* 1272 1272 1622*
                                                                                  1650* 2009*
attach_name               7            based           char(32)                 level 2 in structure "idte" dcl 6-29 in procedure
                                                                                  "iodd_" ref 566
attach_type              17            based           fixed bin(17,0)          level 2 in structure "idte" dcl 6-29 in procedure
                                                                                  "iodd_" ref 560 565
attach_type             146            based           fixed bin(17,0)          level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 402* 428 525* 565*
                                                                                  721 1127 1327 1350 1382 1392 1409 1621* 1648*
attached                436            based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  379* 1133 1164* 1208* 1356
authorization                   003102 automatic       bit(72)                  dcl 1846 set ref 1880* 1882*
auto_logout_interval    263            based           fixed bin(17,0)          level 2 dcl 11-17 set ref 716*
auto_start_delay        302            based           fixed bin(71,0)          level 2 dcl 11-17 set ref 323* 720* 1450*
based_ptr                              based           pointer                  dcl 209 ref 370
before                                                 builtin function         dcl 261 ref 466 466 472 959 1275 1713 1720 1792 1895
                                                                                  1896 1903 1904
bel_string                      023552 constant        char(40)                 initial dcl 236 set ref 1422*
bit                                                    builtin function         dcl 261 ref 1303
both                            000260 constant        fixed bin(17,0)          initial dcl 242 set ref 595* 805* 820* 846* 856*
                                                                                  869* 873* 876* 889* 923* 926* 938* 952* 1016*
                                                                                  1024* 1036* 1077* 1116* 1287* 1291* 1320* 1377*
                                                                                  1716* 1735* 1750* 1757* 1859* 1872* 1885* 1911*
                                                                                  2062* 2071* 2104*
chan                      2     003166 automatic       fixed bin(71,0)          level 2 dcl 2035 set ref 2046* 2049
chan_id                   7            based           char(32)                 level 2 dcl 8-25 set ref 1605* 1616* 1650
chan_list_ptr            20            based           pointer                  level 2 dcl 11-17 set ref 742*
channel                   2     002160 automatic       fixed bin(71,0)          array level 2 dcl 286 set ref 779* 780* 810* 897
                                                                                  1007* 1120* 1123* 1127* 1244*
channel_name             12     002374 automatic       char(32)                 level 2 in structure "release_arg" dcl 305
                                                                                  in procedure "iodd_" set ref 1148*
channel_name             12     003172 automatic       char(32)                 level 2 in structure "dial_arg" dcl 2039
                                                                                  in procedure "wait_for_dial" set ref 2050*
char                                                   builtin function         dcl 261 ref 1857 2048
charge_user_                    000730 constant        entry                    external dcl 100 ref 916
chars                     1            based           char                     level 2 packed packed unaligned dcl 9-39 ref 2166
cmd                             000100 automatic       char(80)                 packed unaligned dcl 1440 set ref 1463 1463 1473
cmd_ack_chan            170            based           fixed bin(71,0)          level 2 dcl 11-17 set ref 325* 408 408* 419* 1330*
cmd_msg                         003012 automatic       char(32)                 packed unaligned dcl 1592 set ref 1678* 1689 1689
                                                                                  1689 1689
code                                   based           fixed bin(35,0)          level 2 in structure "st" dcl 204 in procedure
                                                                                  "iodd_" set ref 1198 1199 1201* 1219 1219 1221*
                                                                                  1228 1228 1235 1236* 1287 1287* 1291 1291*
code                                   based           fixed bin(17,0)          level 2 in structure "ev_msg" packed packed
                                                                                  unaligned dcl 7-8 in procedure "iodd_" set ref 860
                                                                                  990* 1959*
code                                   parameter       fixed bin(35,0)          dcl 1588 in procedure "attach_and_listen" set ref
                                                                                  1585 1601* 1610* 1626* 1627 1627 1627 1630* 1635*
                                                                                  1636 1636 1638* 1652* 1653 1654* 1665* 1666 1666*
                                                                                  1672* 1674 1681* 1689* 1690 1692* 1698* 1704* 1705
                                                                                  1721* 1732* 1734 1764*
code                            000100 automatic       fixed bin(35,0)          dcl 167 in procedure "iodd_" set ref 345* 361* 362*
                                                                                  363* 364* 406* 408* 411* 412 413* 415* 419* 420
                                                                                  423* 434* 436 437* 445* 446 446 492* 494 495* 503*
                                                                                  504 539* 540 623* 625* 626 632* 634 635 640* 660*
                                                                                  662 672* 673 680* 681 686* 687 755* 757* 758* 759*
                                                                                  787* 801* 803 804* 805* 816* 819 820* 830* 831
                                                                                  836* 840* 844 845* 846* 860* 862 868 872 876* 887*
                                                                                  889* 921* 922 923* 926* 936* 937 938* 949* 952*
                                                                                  997* 998 1001* 1009* 1014 1015* 1016* 1034* 1035
                                                                                  1036* 1043* 1044 1048* 1049 1053* 1054 1055 1059*
                                                                                  1060 1075* 1076 1077* 1084* 1085 1094* 1095 1107*
                                                                                  1108 1114* 1115 1116* 1134* 1136 1139 1143* 1152*
                                                                                  1153 1157* 1171* 1172 1173 1173* 1175* 1253* 1254
                                                                                  1255* 1260* 1261 1329* 1330* 1331* 1332* 1358*
                                                                                  1452* 1458* 1463* 1470
code                            000112 automatic       fixed bin(35,0)          dcl 1938 in procedure "kill_device" set ref 1969*
                                                                                  1971* 1975* 1976 1976* 1981* 1982 1982* 1988*
code                                   parameter       fixed bin(35,0)          dcl 1843 in procedure "validate_request" set ref
                                                                                  1834 1861* 1920*
command_error                   000000 stack reference condition                dcl 308 ref 1942
continue_to_signal_             000736 constant        entry                    external dcl 105 ref 1452 1458
convert_dial_message_           000732 constant        entry                    external dcl 101 ref 2081
convert_ipc_code_               000734 constant        entry                    external dcl 104 ref 413 804 845 1015
coord_chan               40            based           fixed bin(71,0)          level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "iodd_" ref 993 1962
coord_chan                      000100 automatic       fixed bin(71,0)          dcl 1933 in procedure "kill_device" set ref 1962*
                                                                                  1988*
coord_cmd_chan          166            based           fixed bin(71,0)          level 2 dcl 11-17 set ref 1028*
coord_proc_id            24            based           bit(36)                  level 2 dcl 11-17 set ref 703* 830* 997* 1303 1409
                                                                                  1988*
ctl_attach_name         344            based           char(32)                 level 3 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 373* 1167* 2048 2050
                                                                                  2062* 2071* 2136
ctl_attach_name          20            based           char(32)                 level 2 in structure "idte" dcl 6-29 in procedure
                                                                                  "iodd_" ref 1167 1183 2136
ctl_attach_type         354            based           fixed bin(17,0)          level 3 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 374* 1168* 1170 1170
                                                                                  1180 2055 2136
ctl_attach_type          30            based           fixed bin(17,0)          level 2 in structure "idte" dcl 6-29 in procedure
                                                                                  "iodd_" ref 1168 2136
ctl_dev_dim             410            based           char(32)                 level 3 dcl 11-17 set ref 378* 1182* 1190* 1197*
                                                                                  1201* 2093* 2142
ctl_device              422            based           char(32)                 level 3 dcl 11-17 set ref 377* 1148 1183* 1197*
                                                                                  1201* 2092* 2145*
ctl_dial_chan           356            based           fixed bin(71,0)          level 3 dcl 11-17 set ref 375* 1143* 1149 1157*
                                                                                  1191* 1331* 1358* 2041* 2046 2100*
ctl_ev_chan             420            based           fixed bin(71,0)          level 3 dcl 11-17 set ref 376* 1192* 1240*
ctl_input               360            based           char(32)                 level 3 dcl 11-17 set ref 1162* 1187* 1211* 1249
ctl_io                  400            based           char(32)                 level 3 dcl 11-17 set ref 1141* 1142* 1153 1160*
                                                                                  1189* 1210* 1218* 1227* 1234* 1236* 1264* 1361*
                                                                                  1362* 1363* 1365*
ctl_output              370            based           char(32)                 level 3 dcl 11-17 set ref 1163* 1188* 1212* 1250
                                                                                  1299
ctl_term                344            based           structure                level 2 dcl 11-17
current_devices         266            based           fixed bin(17,0)          level 2 dcl 11-17 set ref 718*
cv_entry_                       000740 constant        entry                    external dcl 106 ref 921 1034 1043 1048 1053 1059
                                                                                  1075 1084 1094 1107
daemon_idle                     002606 stack reference condition                dcl 308 ref 337
daemon_logout                   002550 stack reference condition                dcl 308 ref 333
daemon_new_device               002600 stack reference condition                dcl 308 ref 335
daemon_slave_logout             002556 stack reference condition                dcl 308 ref 334
data_ptr                  4     003050 automatic       pointer                  level 2 dcl 1596 set ref 1662*
date_time_compiled        2            based           fixed bin(71,0)          level 2 dcl 9-23 ref 768
dcte                                   based           structure                level 1 dcl 1-27
dctep                           002614 automatic       pointer                  dcl 1-25 set ref 906* 907 1819* 1820 1820 1865* 1870
                                                                                  1872 1882 1885 1900 1918
debug                           000742 constant        entry                    external dcl 107 ref 1501
default_dev_class        10            based           fixed bin(17,0)          level 2 dcl 6-64 ref 586
dev_class                23     001101 automatic       char(32)                 array level 3 in structure "request_dev" dcl 267
                                                                                  in procedure "iodd_" set ref 1918*
dev_class                              parameter       char(32)                 packed unaligned dcl 1780 in procedure
                                                                                  "find_device_class" set ref 1771 1793* 1794 1794*
                                                                                  1820 1828*
dev_class                       000111 automatic       char(32)                 packed unaligned dcl 169 in procedure "iodd_" set
                                                                                  ref 660* 680*
dev_class_index           4     001074 automatic       fixed bin(17,0)          level 2 dcl 211 set ref 814*
dev_class_ptr            12            based           pointer                  level 2 dcl 11-17 set ref 520* 906 1819 1865
dev_class_tab                          based           structure                level 1 dcl 1-20
dev_class_tab_offset     12            based           fixed bin(18,0)          level 2 dcl 9-23 ref 520
dev_ctl_ptr             130            based           pointer                  level 2 dcl 4-25 set ref 901*
dev_id                                 based           char(24)                 level 2 in structure "mdte" dcl 6-64 in procedure
                                                                                  "iodd_" ref 584
dev_id                                 based           char(24)                 level 2 in structure "idte" dcl 6-29 in procedure
                                                                                  "iodd_" set ref 553 1746 1757*
dev_in_stream           106            based           char(32)                 level 2 dcl 11-17 set ref 736*
dev_index                51            based           fixed bin(17,0)          level 2 dcl 4-25 ref 991 1960
dev_io_stream            76            based           char(32)                 level 2 dcl 11-17 set ref 735*
dev_label                       003104 automatic       char(32)                 packed unaligned dcl 1847 in procedure
                                                                                  "validate_request" set ref 1855* 1857* 1857 1859*
                                                                                  1872*
dev_label                       000101 automatic       char(32)                 packed unaligned dcl 168 in procedure "iodd_" set
                                                                                  ref 864* 866* 869* 873* 876*
dev_name                        000204 automatic       char(32)                 dcl 175 set ref 345* 348* 349* 2081* 2092
dev_out_stream          116            based           char(32)                 level 2 dcl 11-17 set ref 737*
device_id                20            based           char(32)                 level 2 dcl 4-25 ref 966 966 984
device_index              3     001074 automatic       fixed bin(17,0)          level 2 dcl 211 set ref 812*
device_list              21            based           bit(360)                 level 2 dcl 1-27 ref 1870
device_tab_offset        10            based           fixed bin(18,0)          level 2 dcl 9-23 ref 517
dial_arg                        003172 automatic       structure                level 1 dcl 2039 set ref 2058 2058 2067 2067
dial_channel             10     003172 automatic       fixed bin(71,0)          level 2 in structure "dial_arg" dcl 2039
                                                                                  in procedure "wait_for_dial" set ref 2049*
dial_channel             10     002374 automatic       fixed bin(71,0)          level 2 in structure "release_arg" dcl 305
                                                                                  in procedure "iodd_" set ref 1149*
dial_ev_chan            152            based           fixed bin(71,0)          level 2 dcl 11-17 set ref 1332*
dial_manager_$allow_dials       000744 constant        entry                    external dcl 108 ref 2067
dial_manager_$privileged_attach 000746 constant        entry                    external dcl 109 ref 2058
dial_manager_$release_channel   000750 constant        entry                    external dcl 110 ref 1152
dial_manager_arg                       based           structure                level 1 dcl 2-14
dial_manager_arg_version_2             constant        fixed bin(17,0)          initial dcl 2-10 ref 1147 2047
dial_out_destination     22     003172 automatic       char(32)                 level 2 dcl 2039 set ref 2053*
dial_qualifier            1     002374 automatic       char(22)                 level 2 in structure "release_arg" dcl 305
                                                                                  in procedure "iodd_" set ref 1150*
dial_qualifier            1     003172 automatic       char(22)                 level 2 in structure "dial_arg" dcl 2039
                                                                                  in procedure "wait_for_dial" set ref 2048* 2048
dial_wait                       003166 automatic       structure                level 1 dcl 2035 set ref 2076 2076
dialed_up                       002373 automatic       bit(1)                   level 2 packed packed unaligned dcl 299 set ref 2089
dim_name                        000214 automatic       char(32)                 dcl 176 set ref 345* 347 1214* 1216* 1218* 1221*
                                                                                  1227* 1285* 1286* 2081* 2093
dir_name                               parameter       char                     packed unaligned dcl 1555 set ref 1549 1561*
driver_chan              42            based           fixed bin(71,0)          level 2 dcl 4-25 set ref 897* 1007 1123 1969*
driver_command          220            based           entry variable           level 2 dcl 11-17 set ref 1048*
driver_default_handler
                        224            based           entry variable           level 2 dcl 11-17 set ref 1053* 1059*
driver_dir                      000334 automatic       char(168)                packed unaligned dcl 189 set ref 776* 887* 889*
driver_id                 7            based           char(32)                 level 2 dcl 16-28 ref 1902
driver_init             210            based           entry variable           level 2 dcl 11-17 set ref 1034* 1315
driver_list                     000624 internal static structure                level 1 dcl 255 set ref 321 739
driver_list_ptr          16            based           pointer                  level 2 dcl 11-17 set ref 739*
driver_message                  001074 automatic       structure                level 1 dcl 211 set ref 784
driver_module            31            based           structure                level 2 packed packed unaligned dcl 6-29 set ref
                                                                                  1032*
driver_name                     003125 automatic       char(24)                 packed unaligned dcl 1850 set ref 1895* 1906 1911*
driver_proc_id           25            based           bit(36)                  level 2 dcl 11-17 set ref 704* 1303 1303* 1303
driver_proj                     003133 automatic       char(12)                 packed unaligned dcl 1851 set ref 1896* 1910 1911*
driver_ptr              304            based           pointer                  level 2 dcl 11-17 set ref 738* 983* 984 1275
driver_ptr_list                        based           structure                level 1 unaligned dcl 3-9
driver_request          214            based           entry variable           level 2 dcl 11-17 set ref 1043*
driver_status                          based           structure                level 1 dcl 4-25
driver_status_ptr               002620 automatic       pointer                  dcl 4-24 set ref 887* 888 896 897 898 899 900 901
                                                                                  909 912 915 916 921 938 949 951 957 959 966 966
                                                                                  983*
dummy_ptr               206            based           pointer                  level 2 dcl 11-17 set ref 401*
dvc_index                33     001101 automatic       fixed bin(17,0)          array level 3 dcl 267 set ref 586* 616 618 642* 653
                                                                                  665* 684* 814 906 1858 1865
ec                                     parameter       fixed bin(35,0)          dcl 2127 in procedure "check_for_dialup" set ref
                                                                                  2110 2134* 2138* 2145* 2146 2149*
ec                                     parameter       fixed bin(35,0)          dcl 1557 in procedure "init_seg" set ref 1549 1561*
                                                                                  1563 1565* 1566 1570 1580*
ec                              003100 automatic       fixed bin(35,0)          dcl 1844 in procedure "validate_request" set ref
                                                                                  1867* 1874* 1887* 1914* 1918 1920
ec                                     parameter       fixed bin(35,0)          dcl 2033 in procedure "wait_for_dial" set ref 2028
                                                                                  2041* 2042 2058* 2060 2067* 2068 2076* 2078 2081*
                                                                                  2082 2095* 2097 2100* 2101
ec                              003154 automatic       fixed bin(35,0)          dcl 2000 in procedure "hangup_station" set ref 2004*
                                                                                  2005* 2006*
ec                                     parameter       fixed bin(35,0)          dcl 1782 in procedure "find_device_class" set ref
                                                                                  1771 1787* 1797* 1809* 1827*
echo_cmd                342(08)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  392* 733* 2016*
entries                   2            based           structure                array level 2 in structure "q_group_tab" dcl 16-22
                                                                                  in procedure "iodd_" set ref 907 1812 1900
entries                   2            based           structure                array level 2 in structure "minor_device_tab"
                                                                                  dcl 6-58 in procedure "iodd_" set ref 579
entries                   2            based           structure                array level 2 in structure "dev_class_tab" dcl 1-20
                                                                                  in procedure "iodd_" set ref 906 1819 1865
entries                   2            based           structure                array level 2 in structure "line_tab" dcl 8-19
                                                                                  in procedure "iodd_" set ref 531
entries                   2            based           structure                array level 2 in structure "iod_device_tab" dcl 6-23
                                                                                  in procedure "iodd_" set ref 551 974 1745
entry                           003050 automatic       entry variable           level 2 dcl 1596 set ref 1661*
entry_name                      000667 automatic       char(32)                 packed unaligned dcl 195 set ref 947* 948 949* 952*
entry_variable                  000700 automatic       entry variable           dcl 196 set ref 1094* 1097
err_msg                         003022 automatic       char(80)                 packed unaligned dcl 1593 set ref 1732* 1735*
error                           000161 constant        fixed bin(17,0)          initial dcl 238 set ref 415* 437* 495* 508* 595*
                                                                                  805* 820* 846* 876* 889* 923* 926* 938* 952* 1016*
                                                                                  1036* 1077* 1116* 1320* 1377* 1406* 1422* 1611*
                                                                                  1976* 1982*
error_io                 74            based           pointer                  level 2 dcl 11-17 set ref 364* 759*
error_table_$ai_restricted      001134 external static fixed bin(35,0)          dcl 222 ref 1887
error_table_$badopt             001142 external static fixed bin(35,0)          dcl 225 ref 1797 1809 1827
error_table_$ionmat             001124 external static fixed bin(35,0)          dcl 218 ref 1199 1219 1228 1627
error_table_$namedup            001150 external static fixed bin(35,0)          dcl 228 ref 1563
error_table_$no_ext_sym         001144 external static fixed bin(35,0)          dcl 226 ref 1055
error_table_$no_operation       001146 external static fixed bin(35,0)          dcl 227 ref 1610
error_table_$noarg              001140 external static fixed bin(35,0)          dcl 224 ref 446 635
error_table_$noentry            001132 external static fixed bin(35,0)          dcl 221 ref 1570 1861 1874
error_table_$not_closed         001130 external static fixed bin(35,0)          dcl 220 ref 1636
error_table_$not_detached       001126 external static fixed bin(35,0)          dcl 219 ref 1627
error_table_$user_not_found     001136 external static fixed bin(35,0)          dcl 223 ref 1914
ev_chan                         002262 automatic       fixed bin(71,0)          level 2 dcl 290 set ref 1120 1240 1244 1245 1659
ev_chan_list                    002160 automatic       structure                level 1 dcl 286 set ref 742 840 840 1009 1009
ev_msg                                 based           structure                level 1 dcl 7-8
event_info                      002150 automatic       structure                level 1 dcl 277 set ref 840 840 1009 1009 2076 2076
                                                                                  2086 2086
event_message                   002632 automatic       fixed bin(71,0)          dcl 7-6 set ref 828* 830* 988* 989 997* 1957* 1958
                                                                                  1988*
first_arg                       000154 automatic       char(32)                 packed unaligned dcl 173 set ref 469 471* 472* 472
                                                                                  473 475 527 553 557* 567
first_char                             parameter       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 2162
                                                                                  ref 2166
first_dev_class         147            based           fixed bin(17,0)          level 2 dcl 16-28 ref 1818
first_minor              41            based           fixed bin(17,0)          level 2 dcl 6-29 ref 578
fixed                                                  builtin function         dcl 261 ref 1303
flags                   310            based           structure                level 2 dcl 11-17
form_type               432            based           char(16)                 level 3 dcl 11-17 set ref 381*
forms                   436(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  383* 1214
generic_type             20            based           char(32)                 level 2 in structure "qgte" dcl 16-28 in procedure
                                                                                  "iodd_" ref 909
generic_type            134            based           char(32)                 level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "iodd_" set ref 909*
get_at_entry_                   000752 constant        entry                    external dcl 111 ref 345
get_authorization_              000762 constant        entry                    external dcl 115 ref 1880
get_group_id_                   000754 constant        entry                    external dcl 112 ref 1894
get_group_id_$tag_star          000756 constant        entry                    external dcl 113 ref 466 466
get_process_id_                 000760 constant        entry                    external dcl 114 ref 704
give_start                      000140 automatic       bit(1)                   packed unaligned dcl 1444 set ref 1446* 1455* 1465
                                                                                  1466* 1537
hangup_info                     003050 automatic       structure                level 1 dcl 1596 set ref 1665 1665
have_accounting          47(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-25 set ref
                                                                                  912* 915*
hbound                                                 builtin function         dcl 261 ref 578 590 590
hcs_$initiate                   000764 constant        entry                    external dcl 116 ref 887 1561
hcs_$make_ptr                   000766 constant        entry                    external dcl 117 ref 2095
hcs_$terminate_file             000772 constant        entry                    external dcl 119 ref 1981
hcs_$terminate_name             000770 constant        entry                    external dcl 118 ref 1565
hcs_$terminate_noname           000774 constant        entry                    external dcl 120 ref 1971 1975
hcs_$tty_index                  000776 constant        entry                    external dcl 121 ref 2145
hcs_$wakeup                     001000 constant        entry                    external dcl 122 ref 830 997 1988
head_sheet               32            based           structure                level 2 packed packed unaligned dcl 6-29 set ref
                                                                                  1068*
head_sheet_$print_head_sheet    001002 constant        entry                    external dcl 123 ref 1070
head_sheet_$print_separator     001004 constant        entry                    external dcl 124 ref 1071
head_sheet_$test                001006 constant        entry                    external dcl 125 ref 1090
hung_up                   0(01) 002373 automatic       bit(1)                   level 2 packed packed unaligned dcl 299 set ref 2085
i                               003066 automatic       fixed bin(17,0)          dcl 1783 in procedure "find_device_class" set ref
                                                                                  1803* 1804* 1812 1815 1818* 1819 1822*
i                               003101 automatic       fixed bin(17,0)          dcl 1845 in procedure "validate_request" set ref
                                                                                  1854* 1857 1858 1865 1870 1918
i                               000224 automatic       fixed bin(17,0)          dcl 177 in procedure "iodd_" set ref 530* 531 532*
                                                                                  550* 551 553* 578* 579 585* 590 615* 616 618 622
                                                                                  642 653 665 672* 799* 812 814 866 887 889 906*
                                                                                  1122* 1123 1123* 1744* 1745 1746*
i                               000104 automatic       fixed bin(17,0)          dcl 1936 in procedure "kill_device" set ref 1965*
                                                                                  1967*
id                                     based           char(32)                 level 2 in structure "dcte" dcl 1-27 in procedure
                                                                                  "iodd_" set ref 1820 1872* 1885* 1918
id                              000013 constant        char(24)                 initial packed unaligned dcl 243 in procedure
                                                                                  "iodd_" set ref 415* 437* 495* 508* 595* 805* 820*
                                                                                  846* 856* 869* 873* 876* 889* 923* 926* 938* 952*
                                                                                  1016* 1024* 1036* 1077* 1116* 1173* 1175* 1201*
                                                                                  1221* 1236* 1255* 1287* 1291* 1320* 1377* 1406*
                                                                                  1422* 1611* 1630* 1638* 1654* 1666* 1692*
idte                                   based           structure                level 1 dcl 6-29
idtep                           002624 automatic       pointer                  dcl 6-28 set ref 551* 553 560 565 566 578 578 590
                                                                                  974* 975 978 978 1032 1068 1102 1167 1168 1183
                                                                                  1745* 1746 1757 2136 2136
idtp                            002622 automatic       pointer                  dcl 6-22 in procedure "iodd_" set ref 517* 550 551
                                                                                  974 1744 1745
idtp                      4            based           pointer                  level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 517*
ig                              000226 automatic       char(4)                  packed unaligned dcl 178 set ref 345*
ind                                    parameter       fixed bin(17,0)          dcl 1779 in procedure "find_device_class" set ref
                                                                                  1771 1822*
ind                                    parameter       fixed bin(17,0)          dcl 1842 in procedure "validate_request" ref 1834
                                                                                  1854
index                    22     001101 automatic       fixed bin(17,0)          array level 3 in structure "request_dev" dcl 267
                                                                                  in procedure "iodd_" set ref 585* 812 1870
index                                                  builtin function         dcl 261 in procedure "iodd_" ref 962 1710
init_ev_chan                    000272 automatic       fixed bin(71,0)          dcl 182 set ref 777* 830* 993* 997*
init_event_channel                     based           fixed bin(71,0)          level 2 dcl 10-3 ref 777
initialized             310            based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  400* 708* 1312* 1384 1386* 1391* 1403*
input                           002265 automatic       structure                level 1 dcl 294 set ref 445 445 632 632
input_iocbp                     001064 automatic       pointer                  dcl 202 set ref 543* 569* 623* 625* 640*
io_daemon_account_$set_line_prices
                                001014 constant        entry                    external dcl 128 ref 423 936
io_daemon_driver_version        000032 constant        char(8)                  initial packed unaligned dcl 233 ref 317
io_daemon_version       174            based           char(8)                  level 2 dcl 11-17 set ref 317* 366*
io_stat                         000230 automatic       bit(72)                  dcl 179 set ref 343* 348* 349* 352* 353* 356* 357*
                                                                                  358* 359* 745* 747* 749* 1141* 1142* 1153* 1160*
                                                                                  1162* 1163* 1197* 1198 1199 1201 1218* 1219 1219
                                                                                  1221 1227* 1228 1228 1234* 1235 1236 1264* 1286*
                                                                                  1287 1287 1290* 1291 1291 1333* 1336* 1337* 1344*
                                                                                  1361* 1362* 1363* 1365*
ioa_$ioa_stream                 001010 constant        entry                    external dcl 126 ref 1448 1461 1499 1508 1526 1527
                                                                                  1532 1538
ioa_$rsnnl                      001012 constant        entry                    external dcl 127 ref 1605
iod_device_tab                         based           structure                level 1 dcl 6-23
iod_tables_hdr                         based           structure                level 1 dcl 9-23
iodc_data                              based           structure                level 1 dcl 10-3
iodc_data_ptr                   000274 automatic       pointer                  dcl 183 set ref 492* 703 777 1409 1409
iodd_command_processor_$init    001016 constant        entry                    external dcl 129 ref 1307
iodd_hangup_$iodd_hangup_       001020 constant        entry                    external dcl 130 ref 1661 2086
iodd_msg_                       001022 constant        entry                    external dcl 131 ref 366 415 432 437 450 457 458 495
                                                                                  508 536 557 562 590 595 622 638 654 796 805 820
                                                                                  846 856 869 873 876 889 923 926 938 952 1016 1024
                                                                                  1036 1077 1116 1173 1175 1201 1221 1236 1255 1287
                                                                                  1291 1320 1377 1406 1422 1611 1616 1630 1638 1654
                                                                                  1666 1670 1692 1716 1735 1750 1757 1762 1798 1808
                                                                                  1828 1859 1872 1885 1911 1976 1982 2062 2071 2104
iodd_parse_$command             001062 constant        entry                    external dcl 147 ref 445 632
iodd_quit_handler_$init         001024 constant        entry                    external dcl 132 ref 1308
iodd_signal_handler_            001026 constant        entry                    external dcl 133 ref 340
iodd_signal_handler_$init       001030 constant        entry                    external dcl 134 ref 330
iodd_stat_p                     001122 external static pointer                  dcl 216 set ref 316*
iodd_static                            based           structure                level 1 dcl 11-17
ios_$attach                     001032 constant        entry                    external dcl 135 ref 348 349 352 353 356 357 358 359
                                                                                  745 749 1197 1218 1227 1286 1290 1333 1344
ios_$detach                     001034 constant        entry                    external dcl 136 ref 747 1160 1162 1163 1336 1365
ios_$order                      001040 constant        entry                    external dcl 138 ref 343 1142 1153 1234 1264 1337
                                                                                  1362 1363 1478
ios_$write                      001036 constant        entry                    external dcl 137 ref 1141 1361
iox_$attach_name                001152 constant        entry                    external dcl 12-8 ref 1626
iox_$close                      001154 constant        entry                    external dcl 12-8 ref 2005
iox_$control                    001156 constant        entry                    external dcl 12-8 ref 623 640 1114 1652 1665 1681
                                                                                  1698 2004
iox_$detach_iocb                001160 constant        entry                    external dcl 12-8 ref 2006
iox_$get_line                   001162 constant        entry                    external dcl 12-8 ref 434 625 1463 1704
iox_$look_iocb                  001164 constant        entry                    external dcl 12-8 ref 361 362 363 364 755 757 758
                                                                                  759 1253 1260
iox_$open                       001166 constant        entry                    external dcl 12-8 ref 1635
iox_$put_chars                  001170 constant        entry                    external dcl 12-8 ref 1672 1689
ipc_$block                      001044 constant        entry                    external dcl 140 ref 840 1009 2076
ipc_$create_ev_chn              001046 constant        entry                    external dcl 141 ref 411 419 801 2041
ipc_$decl_ev_call_chn           001050 constant        entry                    external dcl 142 ref 2100
ipc_$decl_ev_wait_chn           001054 constant        entry                    external dcl 144 ref 1143
ipc_$delete_ev_chn              001052 constant        entry                    external dcl 143 ref 406 408 1157 1329 1330 1331
                                                                                  1332 1358 1969
ipc_$drain_chn                  001042 constant        entry                    external dcl 139 ref 836 1001
ithp                            002640 automatic       pointer                  dcl 9-22 in procedure "iodd_" set ref 503* 507 515
                                                                                  516 516 517 517 518 518 519 519 520 520 521 521
                                                                                  764* 768
ithp                                   based           pointer                  level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 515*
j                               000225 automatic       fixed bin(17,0)          dcl 177 set ref 660* 665 680* 684
last_dev_class          150            based           fixed bin(17,0)          level 2 dcl 16-28 ref 1818
last_minor               42            based           fixed bin(17,0)          level 2 dcl 6-29 ref 578 590
last_wake_time           44            based           fixed bin(71,0)          level 2 dcl 4-25 set ref 898*
len                             003046 automatic       fixed bin(21,0)          dcl 1594 set ref 1605* 1704*
length                                 based           fixed bin(17,0)          level 2 in structure "text_strings" dcl 9-39
                                                                                  in procedure "iodd_" ref 2166
length                                                 builtin function         dcl 261 in procedure "iodd_" ref 469 469 480 480 647
                                                                                  647 1141 1141 1361 1361 1689 1689 1857 2048
line                            000232 automatic       char(120)                packed unaligned dcl 180 in procedure "iodd_" set
                                                                                  ref 434 434 445 445 625 625 632 632 1140* 1141
                                                                                  1141 1141 1141 1360* 1361 1361 1361 1361 1703*
                                                                                  1704 1704 1708* 1708 1710 1713 1720
line                            000124 automatic       char(32)                 packed unaligned dcl 1441 in procedure "early_quit"
                                                                                  set ref 1473* 1474 1477 1484 1488 1492 1497 1506
                                                                                  1506 1515 1522 1522 1525 1532*
line_id                                based           char(24)                 level 2 dcl 8-25 set ref 532 1616* 1670* 1757*
line_tab                               based           structure                level 1 dcl 8-19
line_tab_idx            151            based           fixed bin(17,0)          level 2 dcl 11-17 set ref 403* 529* 530 532* 535
line_tab_offset           7            based           fixed bin(18,0)          level 2 dcl 9-23 ref 516
list_index               50            based           fixed bin(17,0)          level 2 dcl 4-25 set ref 899*
list_ptr                        002616 automatic       pointer                  dcl 3-7 set ref 321* 322 739* 782 895 895 896 896
                                                                                  899 936 982 983 991 993 1007 1122 1123 1125 1951
                                                                                  1960 1962 1965 1967 1987
lock_id                   2     001074 automatic       bit(36)                  level 2 dcl 211 set ref 785* 787*
log_iocbp                72            based           pointer                  level 2 dcl 11-17 set ref 363* 758*
log_msg                 342(04)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  391* 732* 1299* 2015*
log_stream               36            based           char(32)                 level 2 dcl 11-17 set ref 753*
logout                          001056 constant        entry                    external dcl 145 ref 1342
logout_on_hangup        310(14)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 ref 1375
logout_pending          310(05)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  713*
lte                                    based           structure                level 1 dcl 8-25
ltep                            002636 automatic       pointer                  dcl 8-24 set ref 531* 532 1605 1605 1616 1616 1650
                                                                                  1670 1755 1757
ltp                       2            based           pointer                  level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 516*
ltp                             002634 automatic       pointer                  dcl 8-18 in procedure "iodd_" set ref 516* 530 531
ltrim                                                  builtin function         dcl 261 ref 1713 1720
maj_dev_list             20            based           bit(360)                 level 2 dcl 8-25 ref 1755
major_args              164            based           structure                level 2 packed packed unaligned dcl 11-17 set ref
                                                                                  975*
major_device            154            based           char(32)                 level 2 dcl 11-17 set ref 404* 567* 694* 1620* 1741*
                                                                                  1762* 1980 1981* 1982* 1986* 2062* 2071*
major_index              10     001101 automatic       fixed bin(17,0)          level 2 in structure "request_dev" dcl 267
                                                                                  in procedure "iodd_" set ref 549* 550 553* 556 580
                                                                                  974 1623* 1743* 1744 1746* 1749 1755
major_index              11            based           fixed bin(17,0)          level 2 in structure "mdte" dcl 6-64 in procedure
                                                                                  "iodd_" ref 580
major_name                      001101 automatic       char(32)                 level 2 dcl 267 set ref 567* 694 701 776 864 866
                                                                                  1268 1268 1271 1271 1624* 1741* 1746 1750* 1855
                                                                                  1857
master                          000164 constant        fixed bin(17,0)          initial dcl 240 set ref 366* 415* 432* 437* 450*
                                                                                  457* 458* 495* 508* 536* 557* 562* 796* 1173*
                                                                                  1175* 1201* 1221* 1236* 1255* 1406* 1422* 1611*
                                                                                  1616* 1630* 1638* 1654* 1666* 1670* 1692* 1762*
                                                                                  1976* 1982*
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  709*
master_in                70            based           pointer                  level 2 dcl 11-17 set ref 362* 434* 569 757* 1114*
                                                                                  1463*
master_input             46            based           char(32)                 level 2 dcl 11-17 set ref 752*
master_out               66            based           pointer                  level 2 dcl 11-17 set ref 361* 755*
master_output            56            based           char(32)                 level 2 dcl 11-17 set ref 751*
max                             002265 automatic       fixed bin(17,0)          level 2 dcl 294 set ref 444* 631*
max_access               13            based           bit(72)                  level 2 dcl 1-27 set ref 1882*
mdte                                   based           structure                level 1 dcl 6-64
mdtep                           002630 automatic       pointer                  dcl 6-63 set ref 579* 580 584 586
mdtp                            002626 automatic       pointer                  dcl 6-57 in procedure "iodd_" set ref 518* 579
mdtp                      6            based           pointer                  level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 518*
message                   2     002150 automatic       fixed bin(71,0)          level 2 dcl 277 set ref 860 1028 2081*
message_id                      000332 automatic       bit(72)                  dcl 188 set ref 816* 828
message_segment_$add_file       001060 constant        entry                    external dcl 146 ref 816
meter_dir                       000615 automatic       char(168)                packed unaligned dcl 194 set ref 320*
minor                    12     001101 automatic       structure                array level 2 dcl 267 set ref 578 590 590
minor_dev_index           0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-8 set ref 991*
                                                                                  1960*
minor_device_tab                       based           structure                level 1 dcl 6-58
minor_device_tab_offset
                         11            based           fixed bin(18,0)          level 2 dcl 9-23 ref 518
mseg_message_info                      based           structure                level 1 dcl 14-9
msgp                            000330 automatic       pointer                  dcl 187 set ref 989* 990 991 1958* 1959 1960
n_dev                           003164 automatic       fixed bin(17,0)          dcl 2034 set ref 2081*
n_devices                              based           fixed bin(17,0)          level 2 dcl 6-23 ref 550 1744
n_lines                                based           fixed bin(17,0)          level 2 dcl 8-19 ref 530
n_minor                  11     001101 automatic       fixed bin(17,0)          level 2 dcl 267 set ref 575* 578 583* 583 584 585
                                                                                  586 590 594 604 614 615 799 864 1855
n_q_groups                             based           fixed bin(17,0)          level 2 dcl 16-22 ref 1803
name                     12     001101 automatic       char(32)                 array level 3 in structure "request_dev" packed
                                                                                  packed unaligned dcl 267 in procedure "iodd_" set
                                                                                  ref 584* 622* 866 887* 889* 1857
name                                   based           char(24)                 level 2 in structure "qgte" dcl 16-28 in procedure
                                                                                  "iodd_" set ref 1911*
name                      2            based           char(24)                 array level 3 in structure "q_group_tab" dcl 16-22
                                                                                  in procedure "iodd_" set ref 1804
nc                              000134 automatic       fixed bin(21,0)          dcl 1442 set ref 1463* 1473
nchars                          000270 automatic       fixed bin(21,0)          dcl 181 set ref 434* 441 445 445 625* 628 632 632
new_driver_msg                         based           structure                level 1 dcl 15-5 ref 816
new_driver_msg_p                002644 automatic       pointer                  dcl 15-3 set ref 784* 816* 816
no_coord                        002564 stack reference condition                dcl 308 ref 831 857 998 1025
no_coord_flag           310(04)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  399* 705* 1387* 1394
no_coord_label           32            based           label variable           level 2 dcl 11-17 set ref 328*
normal                          000164 constant        fixed bin(17,0)          initial dcl 239 set ref 366* 432* 450* 457* 458*
                                                                                  536* 557* 562* 590* 622* 638* 654* 796* 856* 869*
                                                                                  873* 1024* 1173* 1175* 1201* 1221* 1236* 1255*
                                                                                  1287* 1291* 1616* 1630* 1638* 1654* 1666* 1670*
                                                                                  1692* 1716* 1735* 1750* 1757* 1762* 1798* 1808*
                                                                                  1828* 1859* 1872* 1885* 1911* 2062* 2071* 2104*
null                                                   builtin function         dcl 261 ref 343 343 386 401 423 423 623 623 640 640
                                                                                  723 738 743 764 888 901 921 921 951 957 1034 1034
                                                                                  1043 1043 1048 1048 1053 1053 1059 1059 1075 1075
                                                                                  1084 1084 1094 1094 1107 1107 1142 1142 1153 1153
                                                                                  1264 1264 1337 1337 1362 1362 1363 1363 1478 1478
                                                                                  1563 1626 1626 1681 1681 1698 1698 1971 2003 2004
                                                                                  2004 2010
null_stream                     000021 constant        char(32)                 initial packed unaligned dcl 235 ref 387 729 730 735
                                                                                  736 737 1187 1188 1189 2020 2021
num                             003166 automatic       fixed bin(17,0)          level 2 dcl 2035 set ref 2045*
num_times                              parameter       fixed bin(17,0)          dcl 1556 ref 1549 1574
number                                 based           fixed bin(17,0)          level 2 in structure "driver_ptr_list" dcl 3-9
                                                                                  in procedure "iodd_" set ref 322* 782* 895* 895
                                                                                  896 899 936* 982 1122 1125 1951 1965 1987*
number                          002160 automatic       fixed bin(17,0)          level 2 in structure "ev_chan_list" dcl 286
                                                                                  in procedure "iodd_" set ref 778* 1125*
number                    1     002265 automatic       fixed bin(17,0)          level 2 in structure "input" dcl 294 in procedure
                                                                                  "iodd_" set ref 475
output_device           267            based           char(32)                 level 2 dcl 11-17 set ref 719* 984*
p                               000106 automatic       pointer                  dcl 1937 set ref 1967* 1969 1970 1975*
p1                              000110 automatic       pointer                  dcl 1937 set ref 1970* 1971 1971*
paper_type              244            based           fixed bin(17,0)          level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 978* 980*
paper_type               34            based           fixed bin(17,0)          level 2 in structure "idte" dcl 6-29 in procedure
                                                                                  "iodd_" ref 978 978
print_devices                   001066 constant        entry                    external dcl 149 ref 466
print_errors            342(03)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  390* 728* 1282* 1298* 1645* 2014*
print_head_separator    234            based           entry variable           level 2 dcl 11-17 set ref 1071* 1084*
print_head_sheet        230            based           entry variable           level 2 dcl 11-17 set ref 1070* 1075*
print_line_ids                  001070 constant        entry                    external dcl 150 ref 462
print_tail_sheet        240            based           entry variable           level 2 dcl 11-17 set ref 1103* 1107*
priority                  6     003050 automatic       fixed bin(17,0)          level 2 dcl 1596 set ref 1663*
priv1                   342(05)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  393* 2017*
priv2                   342(06)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  394* 2018*
priv3                   342(07)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  395* 2019*
probe                           001064 constant        entry                    external dcl 148 ref 1510
proc_id                   2            based           bit(36)                  level 2 dcl 10-3 ref 703 1409 1409
program_interrupt               000000 stack reference condition                dcl 308 ref 1517
ptr                                                    builtin function         dcl 261 ref 516 517 518 519 520 521
q_group_tab                            based           structure                level 1 dcl 16-22
q_group_tab_offset       13            based           fixed bin(18,0)          level 2 dcl 9-23 ref 519
qgt_index                       003067 automatic       fixed bin(17,0)          dcl 1784 set ref 1815* 1820
qgte                                   based           structure                level 1 dcl 16-28
qgte_index               11            based           fixed bin(17,0)          level 2 dcl 1-27 ref 907 1820 1900
qgtep                           002650 automatic       pointer                  dcl 16-27 set ref 907* 909 912 916 919 923 936* 947
                                                                                  1812* 1818 1818 1900* 1902 1911
qgtp                     10            based           pointer                  level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 519* 907 1803 1804
                                                                                  1812 1900
qgtp                            002646 automatic       pointer                  dcl 16-21 in procedure "iodd_" set ref 519*
question                        000306 automatic       char(64)                 packed unaligned dcl 185 set ref 618* 621* 622*
queue_type                      000121 automatic       char(32)                 packed unaligned dcl 170 set ref 660* 680*
quit                            002534 stack reference condition                dcl 308 ref 332
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  712*
quit_signaled           310(12)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  715*
re_init_in_progress     310(11)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  396* 1375 1381* 1404*
re_init_label            26            based           label variable           level 2 dcl 11-17 set ref 327*
read_info                       002262 automatic       structure                level 1 dcl 290 set ref 1114 1114 1234 1234 1652
                                                                                  1652
read_password_$switch           001072 constant        entry                    external dcl 151 ref 1721
real_iodd_static                000010 internal static structure                level 1 dcl 248 set ref 312
recursion_flag          310(03)        based           bit(1)                   level 3 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 11-17 in procedure "iodd_" set ref
                                                                                  398* 706* 1380* 1402*
recursion_flag                  000103 automatic       bit(1)                   packed unaligned dcl 1935 in procedure "kill_device"
                                                                                  set ref 1940* 1945 1947*
ref_ptr                         001072 automatic       pointer                  dcl 210 set ref 370* 2095*
release_arg                     002374 automatic       structure                level 1 dcl 305 set ref 1152 1152
req_type_label                         based           char(32)                 level 2 dcl 4-25 set ref 938* 959 1275
request_descriptor                     based           structure                level 1 dcl 17-8
request_dev                     001101 automatic       structure                level 1 dcl 267
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  707*
request_type                           parameter       char(32)                 packed unaligned dcl 1781 in procedure
                                                                                  "find_device_class" set ref 1771 1792* 1794 1796
                                                                                  1804 1808*
request_type                    000131 automatic       char(64)                 packed unaligned dcl 171 in procedure "iodd_" set
                                                                                  ref 542* 568* 604 608 647 649* 650 650 650 652
                                                                                  660* 680* 1273* 1275* 1276 1276
reservation_string       32     003172 automatic       char(256)                level 2 dcl 2039 set ref 2054*
rqt_name                        000406 automatic       char(32)                 packed unaligned dcl 190 set ref 959* 962 962 966
                                                                                  966
rqt_string                      000416 automatic       varying char(168)        dcl 191 set ref 775* 962 962* 962 1277
rqti_dir                        000471 automatic       char(168)                packed unaligned dcl 192 set ref 319* 949*
rqti_ptr                 64            based           pointer                  level 2 dcl 4-25 set ref 949* 951 957* 1970
rqti_seg_name            31            based           char(32)                 level 2 dcl 16-28 ref 947
rtrim                                                  builtin function         dcl 261 ref 319 320 462 462 466 466 701 776 866 959
                                                                                  962 962 966 966 966 966 1141 1141 1268 1268 1271
                                                                                  1271 1272 1272 1276 1276 1361 1361 1689 1689 1708
                                                                                  1720 1857
runout_requests         310(10)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  714*
scramble_                       001074 constant        entry                    external dcl 152 ref 1729
second_arg                      000164 automatic       char(64)                 packed unaligned dcl 174 set ref 478* 480 482* 532
                                                                                  536* 568
seg_fault_error                 002572 stack reference condition                dcl 308 ref 763 770
seg_name                               parameter       char                     packed unaligned dcl 1553 in procedure "init_seg"
                                                                                  set ref 1549 1561* 1561* 1565*
seg_name                        000276 automatic       char(32)                 packed unaligned dcl 184 in procedure "iodd_" set
                                                                                  ref 485* 492* 495* 502* 503*
segp                                   parameter       pointer                  dcl 1554 set ref 1549 1561* 1563
segptr                  306            based           pointer                  level 2 dcl 11-17 set ref 743*
send                            000102 automatic       bit(1)                   packed unaligned dcl 1934 set ref 1944* 1952* 1955*
                                                                                  1968 1988
set_iod_val                     001076 constant        entry                    external dcl 153 ref 966 1268 1271 1272 1276 1277
set_lock_$lock                  001100 constant        entry                    external dcl 154 ref 787
size                                                   builtin function         dcl 261 ref 816
slave                           000161 constant        fixed bin(17,0)          initial dcl 241 in procedure "iodd_" set ref 590*
                                                                                  622* 638* 654* 1798* 1808* 1828*
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_"
slave_ev_chan           340            based           fixed bin(71,0)          level 3 dcl 11-17 set ref 385* 726* 1127 1245* 1659*
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  710*
slave_in                334            based           pointer                  level 3 dcl 11-17 set ref 386* 543 723* 1260* 1626*
                                                                                  1635* 1646 1652* 1665* 1681* 1704* 1721* 2010*
slave_input             312            based           char(32)                 level 3 dcl 11-17 set ref 387* 730* 1249* 1260 1647*
                                                                                  2021*
slave_out               336            based           pointer                  level 3 dcl 11-17 set ref 386* 723* 1253* 1646*
                                                                                  1672* 1689* 1698* 1721* 2003 2004* 2005* 2006*
                                                                                  2010*
slave_output            322            based           char(32)                 level 3 dcl 11-17 set ref 387* 729* 1250* 1253 1286*
                                                                                  1299 1647* 2020*
st                                     based           structure                level 1 dcl 204
stars                           023535 constant        char(50)                 initial dcl 237 set ref 1422* 1422*
stat                            000136 automatic       bit(72)                  dcl 1443 set ref 1478*
stat_p                          000724 internal static pointer                  dcl 11-15 set ref 312* 314 315 316 317 323 324 325
                                                                                  327 328 330* 361 362 363 364 366 366 373 374 375
                                                                                  376 377 378 379 381 383 384 385 386 386 387 387
                                                                                  388 389 390 391 392 393 394 395 396 397 398 399
                                                                                  400 401 402 403 404 406 406 408 408 411 419 428
                                                                                  434 497 515 516 517 518 519 520 521 525 529 530
                                                                                  532 535 543 565 566 567 569 597 694 701 703 704
                                                                                  705 706 707 708 709 710 711 712 713 714 715 716
                                                                                  717 718 719 720 721 723 723 725 726 727 728 729
                                                                                  730 732 733 734 735 736 737 738 739 742 743 751
                                                                                  752 753 755 757 758 759 780 796 823 830 836 838
                                                                                  842 848 906 907 975 978 980 982 983 984 984 997
                                                                                  1001 1003 1012 1018 1028 1034 1043 1048 1053 1059
                                                                                  1070 1071 1075 1084 1089 1103 1107 1114 1127 1127
                                                                                  1133 1141 1142 1143 1148 1149 1153 1157 1160 1162
                                                                                  1163 1164 1167 1168 1170 1170 1180 1182 1183 1187
                                                                                  1188 1189 1190 1191 1192 1197 1197 1201 1201 1208
                                                                                  1210 1211 1212 1214 1218 1227 1234 1236 1240 1242
                                                                                  1245 1249 1249 1250 1250 1251 1253 1253 1260 1260
                                                                                  1264 1272 1272 1273 1275 1279 1280 1281 1282 1286
                                                                                  1296 1297 1298 1299 1299 1299 1303 1303 1303 1303
                                                                                  1303 1307* 1308* 1310* 1312 1315 1315* 1325 1327
                                                                                  1329 1330 1331 1332 1350 1356 1358 1361 1362 1363
                                                                                  1365 1375 1375 1380 1381 1382 1384 1386 1387 1391
                                                                                  1392 1394 1402 1403 1404 1409 1409 1450 1463 1493
                                                                                  1498 1507 1516 1527 1620 1621 1622 1626 1635 1643
                                                                                  1644 1645 1646 1646 1647 1647 1648 1650 1652 1659
                                                                                  1662 1665 1672 1681 1689 1698 1704 1721 1721 1741
                                                                                  1762 1803 1804 1812 1819 1865 1900 1980 1981 1982
                                                                                  1986 1988 2003 2004 2005 2006 2009 2010 2010 2011
                                                                                  2012 2013 2014 2015 2016 2017 2018 2019 2020 2021
                                                                                  2041 2046 2048 2050 2055 2062 2062 2071 2071 2092
                                                                                  2093 2100 2100* 2136 2136 2142 2145 2166
stat_seg                  2            based           structure                array level 2 unaligned dcl 3-9
stat_segp                 2            based           pointer                  array level 3 dcl 3-9 set ref 896* 983 991 993 1007
                                                                                  1123 1960 1962 1967
state                           003341 automatic       fixed bin(17,0)          dcl 2129 set ref 2145* 2149
station_id                      002676 automatic       char(32)                 packed unaligned dcl 1587 set ref 1713* 1715 1720
                                                                                  1732* 1735* 1741
station_password                003010 automatic       char(8)                  packed unaligned dcl 1591 set ref 1720* 1721 1721*
                                                                                  1724 1724* 1727 1728 1729* 1732* 1733*
status_flags                    002373 automatic       structure                level 1 dcl 299 in procedure "iodd_" set ref 2081*
status_flags             47            based           structure                level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "iodd_" set ref 900*
step                    310(08)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  711*
string                                                 builtin function         dcl 261 in procedure "iodd_" set ref 900*
string                                 parameter       char                     packed unaligned dcl 1778 in procedure
                                                                                  "find_device_class" set ref 1771 1792 1793 1798*
substr                                                 builtin function         dcl 261 ref 445 445 632 632 1473 1755 1870 2166
sys_dir                         000543 automatic       char(168)                packed unaligned dcl 193 set ref 313* 314 319 320
                                                                                  462 462 466 466 492* 495* 503* 776 816* 820* 1090*
                                                                                  1097* 1981* 1982*
sys_dir_ptr              22            based           pointer                  level 2 dcl 11-17 set ref 314*
system_dir                             parameter       char                     packed unaligned dcl 93 ref 25 313
table_time                      000152 automatic       fixed bin(71,0)          dcl 172 set ref 768*
tail_sheet               33            based           structure                level 2 packed packed unaligned dcl 6-29 set ref
                                                                                  1102*
tail_sheet_$print_tail_sheet    001102 constant        entry                    external dcl 155 ref 1103
target                                 parameter       structure                level 1 packed packed unaligned dcl 2162 ref 2157
temp_dir                        000705 automatic       varying char(168)        dcl 198 set ref 1032* 1033 1042 1047 1052 1068* 1069
                                                                                  1074 1083 1090 1093 1102* 1103 1106
temp_dir_entry                  000760 automatic       char(256)                packed unaligned dcl 199 set ref 919* 921* 923* 926*
                                                                                  1033* 1034* 1036* 1042* 1043* 1047* 1048* 1052*
                                                                                  1053* 1058* 1059* 1074* 1075* 1077* 1083* 1084*
                                                                                  1093* 1094* 1106* 1107*
temp_label                      001066 automatic       label variable           dcl 208 set ref 369* 370
temp_password                   001060 automatic       char(8)                  packed unaligned dcl 200 set ref 1728* 1729* 1730*
temp_ptr                        001062 automatic       pointer                  dcl 201 set ref 2095* 2100*
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-17 set ref
                                                                                  315* 366* 497 597 796 823 848 1018 1089 1303 1325
                                                                                  1493 1498 1507 1516 1527
testing                                parameter       bit(1)                   dcl 93 ref 25 315
text_offset                            based           structure                level 1 packed packed unaligned dcl 9-45
text_strings                           based           structure                level 1 dcl 9-39
text_strings_offset      15            based           fixed bin(18,0)          level 2 dcl 9-23 ref 521
text_strings_ptr         14            based           pointer                  level 2 in structure "iodd_static" dcl 11-17
                                                                                  in procedure "iodd_" set ref 521* 2166
text_strings_ptr                002642 automatic       pointer                  dcl 9-38 in procedure "iodd_" set ref 521*
timer_chan              172            based           fixed bin(71,0)          level 2 dcl 11-17 set ref 324* 406 406* 411* 780
                                                                                  836* 838* 842* 1001* 1003* 1012* 1329*
timer_manager_$alarm_call       001104 constant        entry                    external dcl 156 ref 1450
timer_manager_$alarm_wakeup     001110 constant        entry                    external dcl 158 ref 838 1003
timer_manager_$reset_alarm_call 001106 constant        entry                    external dcl 157 ref 1456 1467
timer_manager_$reset_alarm_wakeup
                                001112 constant        entry                    external dcl 159 ref 842 1012
timer_manager_$sleep            001114 constant        entry                    external dcl 160 ref 1388 1392 1427 1576 1618 1694
times                           002666 automatic       fixed bin(17,0)          dcl 1558 in procedure "init_seg" set ref 1560* 1573*
                                                                                  1573 1574
times                           000704 automatic       fixed bin(17,0)          dcl 197 in procedure "iodd_" set ref 1407* 1419*
                                                                                  1419 1420
total_chars               0(18)        parameter       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 2162
                                                                                  ref 2164 2166
tries                           003006 automatic       fixed bin(17,0)          dcl 1590 set ref 1602* 1607* 1607 1609 1677* 1684*
                                                                                  1684 1686 1693*
try_0_times                     000260 constant        fixed bin(17,0)          initial dcl 246 set ref 949*
try_10_times                           constant        fixed bin(17,0)          initial dcl 245 set ref 492* 503*
tw_index                        003340 automatic       fixed bin(17,0)          dcl 2128 set ref 2145*
unspec                                                 builtin function         dcl 261 set ref 828*
use_default                     000326 automatic       bit(1)                   packed unaligned dcl 186 set ref 604* 607* 608* 610*
                                                                                  614 616
userid                          003136 automatic       char(32)                 packed unaligned dcl 1852 set ref 1894* 1895 1896
                                                                                  1902* 1903 1904
validate_card_input_$station    001116 constant        entry                    external dcl 161 ref 1732
version                         002374 automatic       fixed bin(17,0)          level 2 in structure "release_arg" dcl 305
                                                                                  in procedure "iodd_" set ref 1147*
version                                based           char(8)                  level 2 in structure "iod_tables_hdr" dcl 9-23
                                                                                  in procedure "iodd_" ref 507
version                         003172 automatic       fixed bin(17,0)          level 2 in structure "dial_arg" dcl 2039
                                                                                  in procedure "wait_for_dial" set ref 2047*
wait_list_index           6     002150 automatic       fixed bin(17,0)          level 2 dcl 277 set ref 855 1023
wakeup_chan                     001074 automatic       fixed bin(71,0)          level 2 dcl 211 set ref 801* 810
wakeup_time             300            based           fixed bin(71,0)          level 2 dcl 11-17 set ref 397*
write_control_form_$init        001120 constant        entry                    external dcl 162 ref 1310

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_MICROSECONDS                  internal static bit(2)                   initial packed unaligned dcl 18-11
ABSOLUTE_SECONDS                       internal static bit(2)                   initial packed unaligned dcl 18-12
ATTACH_TYPE_DIAL                       internal static fixed bin(17,0)          initial dcl 5-15
ATTACH_TYPE_TTY                        internal static fixed bin(17,0)          initial dcl 5-15
Direct_input                           internal static fixed bin(17,0)          initial dcl 13-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 13-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 13-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 13-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 13-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 13-15
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 14-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 14-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 14-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 14-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 14-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 14-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 14-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 14-30
PAPER_TYPE_DEFAULT                     internal static fixed bin(17,0)          initial dcl 5-26
RELATIVE_MICROSECONDS                  internal static bit(2)                   initial packed unaligned dcl 18-13
Sequential_input                       internal static fixed bin(17,0)          initial dcl 13-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 13-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 13-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 13-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 13-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 13-15
ack_msg                                based           structure                level 1 dcl 7-18
dctp                                   automatic       pointer                  dcl 1-19
dial_manager_arg_version_3             internal static fixed bin(17,0)          initial dcl 2-11
dial_manager_arg_version_4             internal static fixed bin(17,0)          initial dcl 2-12
iox_$attach_loud                000000 constant        entry                    external dcl 12-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 12-8
iox_$close_file                 000000 constant        entry                    external dcl 12-8
iox_$delete_record              000000 constant        entry                    external dcl 12-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 12-8
iox_$detach                     000000 constant        entry                    external dcl 12-8
iox_$err_no_operation           000000 constant        entry                    external dcl 12-8
iox_$err_not_attached           000000 constant        entry                    external dcl 12-8
iox_$err_not_closed             000000 constant        entry                    external dcl 12-8
iox_$err_not_open               000000 constant        entry                    external dcl 12-8
iox_$error_output                      external static pointer                  dcl 12-41
iox_$find_iocb                  000000 constant        entry                    external dcl 12-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 12-8
iox_$get_chars                  000000 constant        entry                    external dcl 12-8
iox_$modes                      000000 constant        entry                    external dcl 12-8
iox_$move_attach                000000 constant        entry                    external dcl 12-8
iox_$open_file                  000000 constant        entry                    external dcl 12-8
iox_$position                   000000 constant        entry                    external dcl 12-8
iox_$propagate                  000000 constant        entry                    external dcl 12-8
iox_$read_key                   000000 constant        entry                    external dcl 12-8
iox_$read_length                000000 constant        entry                    external dcl 12-8
iox_$read_record                000000 constant        entry                    external dcl 12-8
iox_$rewrite_record             000000 constant        entry                    external dcl 12-8
iox_$seek_key                   000000 constant        entry                    external dcl 12-8
iox_$user_input                        external static pointer                  dcl 12-41
iox_$user_io                           external static pointer                  dcl 12-41
iox_$user_output                       external static pointer                  dcl 12-41
iox_$write_record               000000 constant        entry                    external dcl 12-8
iox_modes                              internal static char(24)                 initial array dcl 13-6
mseg_message_info_ptr                  automatic       pointer                  dcl 14-7
short_iox_modes                        internal static char(4)                  initial array dcl 13-12

NAMES DECLARED BY EXPLICIT CONTEXT.
ask_for_dev                     004023 constant        label                    dcl 428 ref 452 459 463 467 537 558 563 650 681 687
                                                                                  870 879 892 929 941 954 1039 1080 1177 1205
ask_for_station                 017755 constant        label                    dcl 1684 ref 1679
attach_and_listen               016746 constant        entry                    internal dcl 1585 ref 539
attach_chan                     017037 constant        label                    dcl 1607 ref 1632 1640 1656 1695
auto_start                      016204 constant        label                    dcl 1478 ref 1539
bad_banner_entry                012044 constant        label                    dcl 1077 ref 1085 1095 1108
bad_cmd                         020247 constant        label                    dcl 1716 ref 1710
bad_dvc                         005734 constant        label                    dcl 638 ref 647 662 673
bad_entry                       011424 constant        label                    dcl 1036 ref 1044 1049 1055 1060
bad_line                        004212 constant        label                    dcl 450 ref 469 473 475 480
call_driver                     014052 constant        label                    dcl 1268 ref 1194
check_for_dialup                023235 constant        entry                    internal dcl 2110 ref 1134
check_proc_id                   015630 constant        label                    dcl 1409 ref 1428
clear_input_buffer              017721 constant        label                    dcl 1681 ref 1717 1736 1752 1759
driver_logout_label             015201 constant        label                    dcl 1356 ref 333 334 1424 1489
drop_station                    020017 constant        label                    dcl 1691 ref 1674 1686 1705
early_quit                      015733 constant        entry                    internal dcl 1435 ref 332 497 597 823 848 1018
fatal_init                      004613 constant        label                    dcl 495 ref 504
find_device_class               021002 constant        entry                    internal dcl 1771 ref 660 680
forget_it                       022427 constant        label                    dcl 1992 ref 1945
found_group                     021223 constant        label                    dcl 1812 ref 1804
get_dev_id                      004063 constant        label                    dcl 434 ref 441 446
get_dvc                         005540 constant        label                    dcl 618 ref 628 635 644 655
get_line                        016075 constant        label                    dcl 1461 ref 1474 1502 1511 1518 1522 1529 1533
get_tables                      004603 constant        label                    dcl 485 ref 428 765 1389 1409
hangup_station                  022430 constant        entry                    internal dcl 1998 ref 1327 1350 1368 1384 1631 1639
                                                                                  1655 1691
init_seg                        016602 constant        entry                    internal dcl 1549 ref 492 503 949
iodd_                           002334 constant        entry                    external dcl 16
iodd_init                       002346 constant        entry                    external dcl 25
kill_device                     022045 constant        entry                    internal dcl 1928 ref 806 822 847 878 891 928 940
                                                                                  953 1017 1038 1079 1117 1176 1204 1353 1367 1371
                                                                                  1398
name_err                        021757 constant        label                    dcl 1911 ref 1906
new_device                      003571 constant        label                    dcl 381 set ref 540 626 1354 1396
no_coord_signal                 015560 constant        label                    dcl 1398 ref 328
no_ipc                          003726 constant        label                    dcl 413 ref 420
no_master                       004111 constant        label                    dcl 437 ref 1470
out                             014704 constant        label                    dcl 1325 ref 369 416 439 454 499 510 599 807 825 850
                                                                                  1020 1118 1369 1378 1493
re_init_driver                  015430 constant        label                    dcl 1371 ref 327
re_init_junction                006155 constant        label                    dcl 694 ref 1394 1415
return_string                   023321 constant        entry                    internal dcl 2157 ref 912 916 919 923 1032 1068 1102
                                                                                  1605
set_ctl_streams                 013371 constant        label                    dcl 1208 ref 1136 1199
slave_init_err                  013735 constant        label                    dcl 1255 ref 1261
start_new_device_cleanup        015121 constant        label                    dcl 1344 ref 335 1224 1237 1257 1322 1485
syn_err                         013460 constant        label                    dcl 1221 ref 1228
term_seg                        022144 constant        label                    dcl 1965 ref 1948 1953
try_again                       016621 constant        label                    dcl 1561 ref 1566 1577
try_auto_start                  016542 constant        entry                    internal dcl 1535 ref 1450 1450 1456 1456 1467 1467
validate_request                021327 constant        entry                    internal dcl 1834 ref 672 686
wait                            022774 constant        label                    dcl 2076 ref 2087 2089
wait_for_dial                   022555 constant        entry                    internal dcl 2028 ref 1171

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     25100       26272   23573       25110
Length     27520   23573      1172        1211    1305         716

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iodd_                              2284 external procedure  is an external procedure.  
on unit on line 332                  64 on unit               
on unit on line 333                  64 on unit               
on unit on line 334                  64 on unit               
on unit on line 335                  64 on unit               
on unit on line 337                  64 on unit               
on unit on line 340                  64 on unit               
on unit on line 763                  64 on unit               
early_quit                          192 internal procedure  enables or reverts conditions.  
on unit on line 1452                 68 on unit               
on unit on line 1454                 72 on unit               
try_auto_start                       82 internal procedure  is assigned to an entry variable.  
init_seg                                internal procedure  shares stack frame of external procedure iodd_.  
attach_and_listen                       internal procedure  shares stack frame of external procedure iodd_.  
find_device_class                       internal procedure  shares stack frame of external procedure iodd_.  
validate_request                        internal procedure  shares stack frame of external procedure iodd_.  
kill_device                         160 internal procedure  enables or reverts conditions.  
on unit on line 1942                 64 on unit               
on unit on line 1943                 64 on unit               
hangup_station                          internal procedure  shares stack frame of external procedure iodd_.  
wait_for_dial                           internal procedure  shares stack frame of external procedure iodd_.  
check_for_dialup                        internal procedure  shares stack frame of external procedure iodd_.  
return_string                        66 internal procedure  uses returns(char(*)) or returns(bit(*)).  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 real_iodd_static            iodd_
000624 driver_list                 iodd_
000724 stat_p                      iodd_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
early_quit               000100 cmd                         early_quit
                         000124 line                        early_quit
                         000134 nc                          early_quit
                         000136 stat                        early_quit
                         000140 give_start                  early_quit
iodd_                    000100 code                        iodd_
                         000101 dev_label                   iodd_
                         000111 dev_class                   iodd_
                         000121 queue_type                  iodd_
                         000131 request_type                iodd_
                         000152 table_time                  iodd_
                         000154 first_arg                   iodd_
                         000164 second_arg                  iodd_
                         000204 dev_name                    iodd_
                         000214 dim_name                    iodd_
                         000224 i                           iodd_
                         000225 j                           iodd_
                         000226 ig                          iodd_
                         000230 io_stat                     iodd_
                         000232 line                        iodd_
                         000270 nchars                      iodd_
                         000272 init_ev_chan                iodd_
                         000274 iodc_data_ptr               iodd_
                         000276 seg_name                    iodd_
                         000306 question                    iodd_
                         000326 use_default                 iodd_
                         000330 msgp                        iodd_
                         000332 message_id                  iodd_
                         000334 driver_dir                  iodd_
                         000406 rqt_name                    iodd_
                         000416 rqt_string                  iodd_
                         000471 rqti_dir                    iodd_
                         000543 sys_dir                     iodd_
                         000615 meter_dir                   iodd_
                         000667 entry_name                  iodd_
                         000700 entry_variable              iodd_
                         000704 times                       iodd_
                         000705 temp_dir                    iodd_
                         000760 temp_dir_entry              iodd_
                         001060 temp_password               iodd_
                         001062 temp_ptr                    iodd_
                         001064 input_iocbp                 iodd_
                         001066 temp_label                  iodd_
                         001072 ref_ptr                     iodd_
                         001074 driver_message              iodd_
                         001101 request_dev                 iodd_
                         002150 event_info                  iodd_
                         002160 ev_chan_list                iodd_
                         002262 read_info                   iodd_
                         002265 input                       iodd_
                         002373 status_flags                iodd_
                         002374 release_arg                 iodd_
                         002614 dctep                       iodd_
                         002616 list_ptr                    iodd_
                         002620 driver_status_ptr           iodd_
                         002622 idtp                        iodd_
                         002624 idtep                       iodd_
                         002626 mdtp                        iodd_
                         002630 mdtep                       iodd_
                         002632 event_message               iodd_
                         002634 ltp                         iodd_
                         002636 ltep                        iodd_
                         002640 ithp                        iodd_
                         002642 text_strings_ptr            iodd_
                         002644 new_driver_msg_p            iodd_
                         002646 qgtp                        iodd_
                         002650 qgtep                       iodd_
                         002666 times                       init_seg
                         002676 station_id                  attach_and_listen
                         002706 att_desc                    attach_and_listen
                         003006 tries                       attach_and_listen
                         003010 station_password            attach_and_listen
                         003012 cmd_msg                     attach_and_listen
                         003022 err_msg                     attach_and_listen
                         003046 len                         attach_and_listen
                         003050 hangup_info                 attach_and_listen
                         003066 i                           find_device_class
                         003067 qgt_index                   find_device_class
                         003100 ec                          validate_request
                         003101 i                           validate_request
                         003102 authorization               validate_request
                         003104 dev_label                   validate_request
                         003114 allowed_name                validate_request
                         003122 allowed_proj                validate_request
                         003125 driver_name                 validate_request
                         003133 driver_proj                 validate_request
                         003136 userid                      validate_request
                         003154 ec                          hangup_station
                         003164 n_dev                       wait_for_dial
                         003166 dial_wait                   wait_for_dial
                         003172 dial_arg                    wait_for_dial
                         003340 tw_index                    check_for_dialup
                         003341 state                       check_for_dialup
kill_device              000100 coord_chan                  kill_device
                         000102 send                        kill_device
                         000103 recursion_flag              kill_device
                         000104 i                           kill_device
                         000106 p                           kill_device
                         000110 p1                          kill_device
                         000112 code                        kill_device

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          move_label_var      make_label_var      tra_ext_1
signal_op           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc      set_chars_eis       index_chars_eis     return_chars_eis    index_after_cs      verify_for_rtrim

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$greater_or_equal   charge_user_                  continue_to_signal_           convert_dial_message_
convert_ipc_code_             cv_entry_                     debug                         dial_manager_$allow_dials
dial_manager_$privileged_attach                             dial_manager_$release_channel get_at_entry_
get_authorization_            get_group_id_                 get_group_id_$tag_star        get_process_id_
hcs_$initiate                 hcs_$make_ptr                 hcs_$terminate_file           hcs_$terminate_name
hcs_$terminate_noname         hcs_$tty_index                hcs_$wakeup                   head_sheet_$print_head_sheet
head_sheet_$print_separator   head_sheet_$test              io_daemon_account_$set_line_prices
ioa_$ioa_stream               ioa_$rsnnl                    iodd_command_processor_$init  iodd_hangup_$iodd_hangup_
iodd_msg_                     iodd_parse_$command           iodd_quit_handler_$init       iodd_signal_handler_
iodd_signal_handler_$init     ios_$attach                   ios_$detach                   ios_$order
ios_$write                    iox_$attach_name              iox_$close                    iox_$control
iox_$detach_iocb              iox_$get_line                 iox_$look_iocb                iox_$open
iox_$put_chars                ipc_$block                    ipc_$create_ev_chn            ipc_$decl_ev_call_chn
ipc_$decl_ev_wait_chn         ipc_$delete_ev_chn            ipc_$drain_chn                logout
message_segment_$add_file     print_devices                 print_line_ids                probe
read_password_$switch         scramble_                     set_iod_val                   set_lock_$lock
tail_sheet_$print_tail_sheet  timer_manager_$alarm_call     timer_manager_$alarm_wakeup
timer_manager_$reset_alarm_call                             timer_manager_$reset_alarm_wakeup
timer_manager_$sleep          validate_card_input_$station  write_control_form_$init

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$badopt           error_table_$ionmat           error_table_$namedup
error_table_$no_ext_sym       error_table_$no_operation     error_table_$noarg            error_table_$noentry
error_table_$not_closed       error_table_$not_detached     error_table_$user_not_found   iodd_stat_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 002333        22 002341        25 002342       312 002361       313 002364       314 002372       315 002374
    316 002402       317 002403       319 002407       320 002435       321 002453       322 002456       323 002457
    324 002461       325 002463       327 002464       328 002467       330 002472       332 002500       333 002522
    334 002541       335 002560       337 002577       339 002613       340 002614       343 002635       345 002672
    347 002724       348 002730       349 002770       350 003025       352 003026       353 003070       356 003127
    357 003172       358 003233       359 003300       361 003341       362 003371       363 003417       364 003445
    366 003474       369 003543       370 003546       373 003550       374 003555       375 003556       376 003560
    377 003561       378 003564       379 003567       381 003571       383 003576       384 003600       385 003602
    386 003604       387 003610       388 003622       389 003624       390 003626       391 003630       392 003632
    393 003634       394 003636       395 003640       396 003642       397 003644       398 003646       399 003650
    400 003652       401 003654       402 003656       403 003660       404 003661       406 003664       408 003676
    411 003712       412 003724       413 003726       415 003735       416 003770       419 003771       420 004003
    423 004005       428 004023       432 004030       434 004063       436 004107       437 004111       439 004144
    441 004145       444 004150       445 004152       446 004204       450 004212       452 004246       454 004247
    456 004261       457 004266       458 004322       459 004356       461 004357       462 004364       463 004423
    465 004425       466 004432       467 004534       469 004536       471 004541       472 004545       473 004555
    475 004561       478 004570       480 004574       482 004577       485 004603       492 004606       494 004611
    495 004613       497 004656       499 004667       502 004670       503 004673       504 004676       507 004700
    508 004705       510 004741       515 004742       516 004744       517 004753       518 004762       519 004771
    520 005000       521 005005       525 005014       527 005016       529 005022       530 005023       531 005037
    532 005044       534 005052       535 005054       536 005060       537 005117       539 005120       540 005122
    542 005124       543 005127       544 005133       549 005134       550 005135       551 005147       553 005154
    555 005162       556 005164       557 005166       558 005226       560 005227       562 005233       563 005267
    565 005270       566 005273       567 005276       568 005307       569 005312       575 005314       578 005315
    579 005330       580 005335       583 005340       584 005341       585 005347       586 005352       588 005354
    590 005356       594 005426       595 005430       597 005464       599 005475       604 005476       607 005507
    608 005511       610 005520       614 005521       615 005525       616 005533       618 005540       621 005551
    622 005554       623 005612       625 005642       626 005665       628 005667       631 005672       632 005674
    634 005726       635 005731       638 005734       640 005770       642 006022       644 006025       647 006026
    649 006031       650 006035       652 006051       653 006055       654 006061       655 006115       657 006116
    660 006117       662 006122       665 006124       672 006131       673 006133       675 006135       676 006137
    680 006140       681 006143       684 006145       686 006147       687 006153       694 006155       701 006162
    703 006210       704 006214       705 006226       706 006230       707 006232       708 006234       709 006236
    710 006240       711 006242       712 006244       713 006246       714 006250       715 006252       716 006254
    717 006255       718 006256       719 006257       720 006262       721 006264       723 006267       725 006273
    726 006276       727 006300       728 006302       729 006304       730 006307       732 006312       733 006314
    734 006316       735 006320       736 006323       737 006326       738 006331       739 006333       742 006340
    743 006343       745 006345       747 006411       749 006443       751 006514       752 006521       753 006524
    755 006527       757 006555       758 006603       759 006631       763 006660       764 006674       765 006677
    768 006702       770 006705       775 006706       776 006707       777 006746       778 006751       779 006753
    780 006755       782 006761       784 006762       785 006764       787 006765       796 007000       799 007040
    801 007047       803 007060       804 007062       805 007071       806 007124       807 007130       810 007131
    812 007133       814 007140       816 007142       819 007207       820 007211       822 007250       823 007254
    825 007265       828 007266       830 007270       831 007306       836 007313       838 007325       840 007343
    842 007362       844 007372       845 007374       846 007403       847 007436       848 007442       850 007453
    855 007454       856 007457       857 007513       860 007516       862 007521       864 007522       866 007531
    868 007574       869 007600       870 007640       872 007641       873 007643       874 007703       876 007704
    878 007750       879 007754       887 007755       888 010024       889 010030       891 010075       892 010101
    895 010102       896 010103       897 010107       898 010111       899 010113       900 010115       901 010116
    906 010120       907 010131       909 010137       912 010142       914 010173       915 010174       916 010177
    918 010234       919 010235       921 010262       922 010313       923 010315       926 010403       928 010443
    929 010447       936 010450       937 010463       938 010465       940 010524       941 010530       947 010531
    948 010535       949 010541       951 010572       952 010577       953 010636       954 010642       956 010643
    957 010644       959 010647       962 010671       966 010746       970 011013       974 011016       975 011023
    978 011027       980 011034       982 011036       983 011040       984 011044       988 011051       989 011053
    990 011055       991 011057       993 011063       997 011065       998 011101      1001 011106      1003 011120
   1007 011136      1009 011142      1012 011161      1014 011171      1015 011173      1016 011202      1017 011235
   1018 011241      1020 011252      1023 011253      1024 011256      1025 011312      1028 011315      1032 011321
   1033 011352      1034 011371      1035 011422      1036 011424      1038 011463      1039 011467      1042 011470
   1043 011506      1044 011537      1047 011541      1048 011557      1049 011610      1052 011612      1053 011630
   1054 011661      1055 011663      1058 011666      1059 011671      1060 011720      1068 011722      1069 011753
   1070 011761      1071 011767      1072 011772      1074 011773      1075 012011      1076 012042      1077 012044
   1079 012103      1080 012107      1083 012110      1084 012126      1085 012157      1089 012161      1090 012166
   1093 012204      1094 012222      1095 012251      1097 012253      1102 012263      1103 012314      1106 012331
   1107 012347      1108 012400      1114 012402      1115 012436      1116 012440      1117 012473      1118 012477
   1120 012500      1122 012502      1123 012511      1124 012517      1125 012521      1127 012524      1133 012533
   1134 012536      1136 012540      1139 012542      1140 012544      1141 012564      1142 012637      1143 012671
   1147 012703      1148 012705      1149 012712      1150 012714      1152 012717      1153 012731      1157 012770
   1160 013002      1162 013027      1163 013054      1164 013101      1167 013105      1168 013111      1170 013113
   1171 013117      1172 013121      1173 013123      1175 013161      1176 013221      1177 013225      1179 013226
   1180 013227      1182 013231      1183 013234      1185 013237      1187 013240      1188 013243      1189 013246
   1190 013251      1191 013254      1192 013256      1194 013257      1197 013260      1198 013313      1199 013317
   1201 013322      1204 013364      1205 013370      1208 013371      1210 013375      1211 013400      1212 013403
   1214 013406      1216 013415      1218 013420      1219 013453      1221 013460      1224 013517      1227 013520
   1228 013556      1234 013563      1235 013620      1236 013624      1237 013664      1240 013665      1242 013671
   1244 013674      1245 013676      1249 013700      1250 013703      1251 013706      1253 013710      1254 013733
   1255 013735      1257 013770      1260 013771      1261 014016      1264 014020      1268 014052      1271 014111
   1272 014153      1273 014214      1275 014226      1276 014237      1277 014300      1279 014332      1280 014340
   1281 014342      1282 014344      1283 014346      1285 014347      1286 014352      1287 014407      1290 014447
   1291 014515      1296 014552      1297 014556      1298 014560      1299 014562      1303 014570      1307 014607
   1308 014615      1310 014624      1312 014633      1315 014637      1320 014647      1322 014703      1325 014704
   1327 014711      1329 014715      1330 014727      1331 014741      1332 014753      1333 014765      1336 015027
   1337 015061      1340 015114      1342 015115      1344 015121      1350 015166      1353 015174      1354 015200
   1356 015201      1358 015206      1360 015216      1361 015236      1362 015311      1363 015343      1365 015375
   1367 015422      1368 015426      1369 015427      1371 015430      1375 015434      1377 015444      1378 015477
   1380 015500      1381 015502      1382 015504      1384 015507      1386 015513      1387 015517      1388 015521
   1389 015533      1391 015534      1392 015536      1394 015552      1396 015557      1398 015560      1402 015564
   1403 015570      1404 015572      1406 015574      1407 015627      1409 015630      1415 015642      1419 015643
   1420 015644      1422 015647      1424 015715      1427 015716      1428 015731      1435 015732      1446 015740
   1448 015742      1450 015766      1452 016005      1454 016032      1455 016046      1456 016050      1458 016063
   1459 016074      1461 016075      1463 016117      1465 016144      1466 016146      1467 016147      1470 016161
   1473 016167      1474 016174      1477 016200      1478 016204      1481 016237      1484 016240      1485 016244
   1488 016247      1489 016253      1492 016256      1493 016262      1495 016272      1497 016273      1498 016277
   1499 016304      1501 016330      1502 016335      1504 016336      1506 016337      1507 016347      1508 016354
   1510 016400      1511 016405      1513 016406      1515 016407      1516 016413      1517 016420      1518 016423
   1520 016424      1522 016425      1525 016435      1526 016441      1527 016463      1529 016511      1532 016512
   1533 016540      1535 016541      1537 016547      1538 016552      1539 016576      1541 016601      1549 016602
   1560 016620      1561 016621      1563 016667      1565 016700      1566 016715      1568 016720      1570 016721
   1573 016723      1574 016724      1576 016730      1577 016742      1579 016743      1580 016744      1581 016745
   1585 016746      1601 016750      1602 016751      1605 016752      1607 017037      1609 017041      1610 017044
   1611 017050      1613 017103      1616 017104      1618 017151      1620 017164      1621 017171      1622 017172
   1623 017175      1624 017176      1626 017201      1627 017240      1630 017250      1631 017305      1632 017306
   1635 017307      1636 017327      1638 017335      1639 017367      1640 017370      1643 017371      1644 017375
   1645 017377      1646 017401      1647 017403      1648 017412      1650 017414      1652 017420      1653 017452
   1654 017455      1655 017510      1656 017511      1659 017512      1661 017516      1662 017522      1663 017523
   1665 017525      1666 017557      1670 017615      1672 017655      1674 017700      1677 017703      1678 017704
   1679 017717      1681 017721      1684 017755      1686 017756      1689 017761      1690 020014      1691 020017
   1692 020020      1693 020054      1694 020055      1695 020070      1698 020071      1703 020122      1704 020125
   1705 020152      1708 020155      1710 020173      1713 020201      1715 020243      1716 020247      1717 020310
   1720 020311      1721 020365      1724 020422      1727 020431      1728 020435      1729 020437      1730 020450
   1732 020452      1733 020500      1734 020502      1735 020505      1736 020552      1741 020553      1743 020566
   1744 020567      1745 020601      1746 020606      1748 020614      1749 020616      1750 020620      1752 020662
   1755 020663      1757 020670      1759 020735      1762 020736      1764 020777      1766 021001      1771 021002
   1787 021013      1792 021015      1793 021027      1794 021047      1796 021056      1797 021062      1798 021065
   1799 021125      1803 021126      1804 021137      1806 021153      1808 021155      1809 021216      1810 021222
   1812 021223      1815 021225      1818 021227      1819 021237      1820 021245      1822 021256      1823 021260
   1825 021261      1827 021263      1828 021267      1829 021326      1834 021327      1854 021331      1855 021333
   1857 021342      1858 021405      1859 021413      1861 021453      1862 021457      1865 021460      1867 021466
   1870 021467      1872 021475      1874 021540      1880 021543      1882 021551      1885 021570      1887 021630
   1894 021633      1895 021642      1896 021652      1900 021675      1902 021705      1903 021710      1904 021720
   1906 021743      1910 021753      1911 021757      1914 022026      1918 022031      1920 022041      1922 022043
   1928 022044      1940 022052      1942 022053      1943 022070      1944 022104      1945 022106      1947 022113
   1948 022116      1951 022121      1952 022124      1953 022125      1955 022126      1957 022130      1958 022132
   1959 022134      1960 022136      1962 022142      1965 022144      1967 022155      1968 022162      1969 022164
   1970 022175      1971 022200      1975 022215      1976 022226      1979 022270      1980 022272      1981 022300
   1982 022326      1986 022402      1987 022407      1988 022411      1992 022427      1998 022430      2003 022431
   2004 022437      2005 022466      2006 022500      2009 022512      2010 022517      2011 022523      2012 022526
   2013 022530      2014 022532      2015 022534      2016 022536      2017 022540      2018 022542      2019 022544
   2020 022546      2021 022551      2023 022554      2028 022555      2041 022557      2042 022572      2045 022576
   2046 022600      2047 022604      2048 022606      2049 022611      2050 022613      2053 022616      2054 022621
   2055 022624      2058 022627      2060 022641      2062 022645      2065 022711      2067 022712      2068 022724
   2071 022730      2076 022774      2078 023014      2081 023020      2082 023054      2085 023060      2086 023063
   2087 023074      2089 023075      2092 023100      2093 023105      2095 023110      2097 023146      2100 023152
   2101 023174      2104 023200      2105 023234      2110 023235      2134 023237      2136 023240      2138 023252
   2139 023254      2142 023255      2145 023262      2146 023306      2149 023312      2152 023317      2157 023320
   2164 023326      2166 023347


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
