	COMPILATION LISTING OF SEGMENT azm_stack_requests_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/28/87  0929.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-12-16,Parisek), approve(87-07-09,MCR7746),
       12*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
       13*     ssu_$print_message is called instead of ssu_$abort_line if a stack segment
       14*     cannot be located, therefore execution may resume during active requests
       15*     (phx19331).
       16*                                                   END HISTORY COMMENTS */
       17 
       18 
       19 azm_stack_requests_: proc ();
       20 
       21 	return;					/* not an entrypoint */
       22 
       23 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       24 
       25 
       26 /* Assorted requests for analyze_multics. */
       27 
       28 
       29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       30 	/*									*/
       31 	/* 0) Created: 06/25/83 by B. Braun from the division of the original azm_misc_requests_	*/
       32 	/* into smaller modules. This includes the azm requests stack, frame, why.		*/
       33 	/* 1) Modified Sept 1984 by R. A. Fawcett to add azm_stack_requests_$locks (This should be some where else??). */
       34 	/* 2) Modified Sept 1984 by R. A. Fawcett to add azm_stack_requests_$search_mcs. */
       35 	/* 3) Modified Jan 1985 by B. Braun to change the why request message when it cannot find */
       36 	/*    the cause of the failure.						*/
       37 	/*									*/
       38 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       39 
       40 	
       41 dcl  (
       42      P_sci_ptr pointer,
       43      P_azm_info_ptr pointer
       44      ) parameter;
       45 
       46 /* Automatic */
       47 
       48 dcl  af_sw bit (1) aligned;
       49 dcl  arg_sw bit (1);
       50 dcl  argl fixed bin (21);
       51 dcl  argno fixed bin;
       52 dcl  argp pointer;
       53 dcl  brief_sw bit (1) init ("0"b);
       54 dcl  code fixed bin (35);
       55 dcl  count fixed bin;
       56 dcl  first				fixed bin(18);
       57 dcl  for_sw bit (1);
       58 dcl  force_sw bit (1);
       59 dcl  fwd_sw bit (1);
       60 dcl  long_sw bit (1);
       61 dcl  lock_index fixed bin (17);
       62 dcl  1 lock_info (0:6),
       63        2 lseg char (32) init ("tc_data", "sst_seg", "sst_seg", "scs", "tty_buf", "tty_buf","disk_seg"),
       64        2 lsymb char (32) init ("apt_lock", "ptl", "astl", "connect_lock", "slock", "timer_lock","lock"),
       65        2 lock_word bit (36) init ("0"b, "0"b, "0"b, "0"b, "0"b, "0"b,"0"b);
       66 dcl  lock_name char (32);
       67 dcl  nargs fixed bin;
       68 dcl  ret_str char (168) var init ("");
       69 dcl  rv_lth fixed bin (21);
       70 dcl  rv_ptr ptr;
       71 dcl  sci_ptr pointer;				/* assorted info pointers */
       72 dcl  segno fixed bin;
       73 dcl  set_sw bit (1);
       74 dcl  struct_sw bit (1) init ("0"b);
       75 dcl  temp_ptr			ptr;
       76 dcl  val_arg fixed bin;
       77 
       78 
       79 /* Based */
       80 
       81 dcl  arg char (argl) based (argp);
       82 
       83 /* Constants */
       84 
       85 /* Builtins */
       86 
       87 dcl  (addr, baseptr, hbound, pointer, null, substr) builtin;
       88 
       89 /* Conditions */
       90 
       91 
       92 /* External Entries */
       93 
       94 dcl  amu_$get_va_args		entry (ptr, ptr, ptr, fixed bin, ptr);
       95 dcl  azm_stack_trace_		entry (char(*), ptr, ptr, ptr, bit (1), bit (1), bit (1), bit (1), fixed bin, fixed bin (35));
       96 dcl  azm_why_$find_bad_guy		entry (ptr, ptr, fixed bin (35));
       97 dcl  azm_why_$mcs 	entry (ptr, ptr, fixed bin(35));
       98 dcl  azm_why_$print_locks entry (ptr, ptr, char(*), bit(1), fixed bin(35));
       99 dcl  cv_dec_check_			entry (char (*), fixed bin (35)) returns (fixed bin (35));
      100 dcl  ioa_				entry options (variable);
      101 dcl  ssu_$abort_line		entry options (variable);
      102 dcl  ssu_$arg_count			entry (pointer, fixed bin, bit (1) aligned);
      103 dcl  ssu_$arg_ptr			entry (pointer, fixed bin, pointer, fixed bin (21));
      104 dcl ssu_$print_message		entry() options(variable);
      105 dcl  ssu_$return_arg		entry (ptr, fixed bin, bit (1) aligned, ptr, fixed bin (21));
      106 
      107 /* error codes */
      108 
      109 dcl  amu_et_$no_valid_stacks		fixed bin (35) external static;
      110 dcl  error_table_$action_not_performed  fixed bin(35) ext static;
      111 dcl  error_table_$bad_arg		fixed bin (35) external static;
      112 dcl  error_table_$badopt		fixed bin (35) external static;
      113 dcl  error_table_$noarg		fixed bin (35) external static;
      114 dcl  error_table_$too_many_args	fixed bin(35) ext static;
      115 
      116 azm_stack_requests_$frame:
      117      entry (P_sci_ptr, P_azm_info_ptr);
      118 
      119 sci_ptr = P_sci_ptr;
      120 call ssu_$abort_line (sci_ptr, 0, "This request has not been implemented yet.");
      121 
      122 
      123 azm_stack_requests_$stack:
      124      entry (P_sci_ptr, P_azm_info_ptr);
      125 
      126     call set_up;
      127     if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");
      128 
      129     if nargs = 0 then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage: stack <virtual-address> {-ctl_args}.");
      130 
      131     /* init va_args */
      132 
      133     va_args_ptr = addr(va_args);
      134     va.range = 0;
      135     va.segno, va.offset, va.offset_modifier,
      136        va.va_position, va.ecode  = 0;
      137     va.va_switches = "0"b;
      138     va.error_msg, va.va_string = "";
      139     va.resolved_va = null();
      140 
      141     call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
      142     call amu_$get_va_args(sci_ptr, amu_info_ptr, argp, nargs, va_args_ptr);
      143     if va.ecode ^= 0 | va.error_msg ^="" then do;
      144        call ssu_$abort_line (sci_ptr, va.ecode, "^a", va.error_msg);
      145        end;
      146   
      147     fwd_sw, for_sw, arg_sw, long_sw, force_sw = "0"b;
      148     count, val_arg = 0;
      149     va.range_idx = 0;  /* range is not allowed for stack request */
      150 
      151     do argno = 1 to nargs;
      152        call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
      153        if arg = "-lg" | arg = "-long" then long_sw = "1"b;
      154        else if arg = "-ag" | arg = "-arguments" then arg_sw = "1"b;
      155        else if arg = "-force" | arg = "-fc" then force_sw = "1"b;
      156        else if arg = "-for" then do;
      157 	call get_next_arg("decimal number", argp, argl);
      158 	count = cv_dec_check_ (arg, code);
      159 	if code ^= 0 | count < 0 then 
      160              call ssu_$abort_line (sci_ptr, 0, "-for requires a positive decimal number ""^a"".");
      161 	   for_sw = "1"b;
      162 	   end;
      163        else if arg = "-fwd" | arg = "-forward" then fwd_sw = "1"b;
      164        else do;
      165           if ^va_arg(argno) then do;
      166 	   if substr(arg,1,1) = "-" then code = error_table_$badopt;
      167 	   else code = error_table_$bad_arg;
      168 	   call ssu_$abort_line(sci_ptr, code, " ^a", arg);
      169 	   end;
      170           end;
      171        end;   /* arg processing */
      172     segno = va.segno;
      173     first = va.offset;
      174     temp_ptr = pointer (baseptr (segno), first);
      175     call azm_stack_trace_ ("stack", sci_ptr, amu_info_ptr, temp_ptr, fwd_sw, arg_sw, long_sw, force_sw, count, code);
      176     if code ^= 0 then do;
      177        if code = amu_et_$no_valid_stacks then do;
      178 	call ioa_ ("Frames may be invalid.");
      179 	call ioa_ ("Stack_begin and stack_end are equal ^p.", temp_ptr);
      180 	call ioa_ ("Use the -force and -fwd options and proceed at your own risk!");
      181 	end;
      182       else call ssu_$print_message (sci_ptr, code, "trace of stack ^p.", temp_ptr);
      183       end;
      184 
      185     return;
      186 
      187 azm_stack_requests_$why:
      188      entry (P_sci_ptr, P_azm_info_ptr);
      189 
      190 	call set_up;
      191 	if ^trans_selected () then do;
      192 	     call ssu_$abort_line (sci_ptr, 0, "No dump selected.");
      193 	     return;
      194 	     end;
      195 	if nargs ^= 0 then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "This request takes no arguments.");
      196 	call azm_why_$find_bad_guy (sci_ptr, amu_info_ptr, code);
      197 
      198 	if code = error_table_$action_not_performed then do;
      199 	   call ssu_$print_message (sci_ptr,0,"Unable to determine the cause of the failure.");
      200 	   return;
      201 	   end;
      202 	if code ^= 0 then do;
      203 	     call ssu_$abort_line (sci_ptr, code, "why.");
      204 	     end;
      205 	return;
      206 
      207 /* End why */
      208 
      209 azm_stack_requests_$locks:
      210      entry (P_sci_ptr, P_azm_info_ptr);
      211 
      212 	call set_up;
      213 	if ^trans_selected () then do;
      214 	     call ssu_$abort_line (sci_ptr, 0, "No dump selected.");
      215 	     return;
      216 	     end;
      217 	if nargs > 3 then call ssu_$abort_line (sci_ptr,
      218 	   error_table_$too_many_args, "This request takes 2 arguments max.");
      219 	lock_name = "";
      220 	set_sw = "0"b;
      221 	do argno = 1 to nargs;
      222 	   call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
      223 	   if arg = "-set" then set_sw = "1"b;
      224 	   else do;
      225 	      do lock_index = 0 to hbound(lock_info,1);
      226 	         if arg = lock_info (lock_index).lsymb then do;
      227 		  lock_name = arg;
      228 		  goto call_lock_list;
      229 		  end;
      230 	         end;
      231 	      call ioa_ ("valid locks are:");
      232 	      do lock_index = 0 to hbound(lock_info,1);
      233 	         call ioa_ ("^-^a",lock_info(lock_index).lsymb);
      234 	         end;
      235 	      return;
      236 	      end;
      237 	   end;
      238 call_lock_list:
      239 	
      240 	call azm_why_$print_locks (sci_ptr, amu_info_ptr, lock_name,set_sw,code);
      241 
      242 	if code ^= 0 then do;
      243 	     call ssu_$abort_line (sci_ptr, code, "locks.");
      244 	     end;
      245 
      246 	return;
      247 /* End locks */
      248 
      249 azm_stack_requests_$search_mcs:
      250 	
      251      entry (P_sci_ptr, P_azm_info_ptr);
      252 
      253 	call set_up;
      254 	if ^trans_selected () then do;
      255 	     call ssu_$abort_line (sci_ptr, 0, "No dump selected.");
      256 	     return;
      257 	     end;
      258 	if nargs ^= 0 then call ssu_$abort_line (sci_ptr,
      259 	   error_table_$too_many_args, "This request takes no arguments.");
      260 	call azm_why_$mcs (sci_ptr,amu_info_ptr,code);
      261 	if code ^= 0 then call ssu_$print_message (sci_ptr,code);
      262 	return;
      263 /* end search_mcs */
      264 
      265 get_next_arg: proc(Arg_expected, ap1, al1);
      266 
      267 /*  This guy gets the next argument from the argument string, complaining if it's not there  */
      268 
      269 dcl Arg_expected			char(*);
      270 dcl (ap1				ptr,
      271      al1				fixed bin(21));
      272 	    
      273 	if (argno + 1) > nargs then do;
      274 	     call ssu_$abort_line(sci_ptr, error_table_$noarg, "A ^a expected after ^a.", Arg_expected, arg);
      275 	     return;
      276 	     end;
      277 
      278 	argno = argno + 1;
      279 	call ssu_$arg_ptr (sci_ptr, argno, ap1, al1);
      280      
      281 end get_next_arg;
      282 
      283 set_up:
      284      proc;
      285 
      286 	sci_ptr = P_sci_ptr;
      287 	azm_info_ptr = P_azm_info_ptr;
      288 	amu_info_ptr = azm_info.aip;
      289 	call ssu_$return_arg (sci_ptr, nargs, af_sw, rv_ptr, rv_lth);
      290 	if ^af_sw then call ssu_$arg_count (sci_ptr, nargs, af_sw);
      291 
      292      end set_up;
      293 
      294 trans_selected:
      295      proc () returns (bit (1));
      296 
      297 	if amu_info_ptr = null () then return ("0"b);
      298 	return ("1"b);
      299      end trans_selected;
      300 
      301 va_arg:  proc(a_pos) returns(bit(1));
      302          
      303 dcl a_pos fixed bin;
      304 dcl i fixed bin;
      305 dcl arg_positions (3) aligned based (Ppos);
      306 
      307 /*dcl 1 arg_positions	 aligned based (Ppos),
      308*      2 indx (3) fixed bin; */
      309 dcl Ppos ptr;
      310 
      311     Ppos = addr(va.va_position);
      312     do i = 1 to hbound(arg_positions,1);
      313        if a_pos = arg_positions(i) then return("1"b);
      314        end;
      315     
      316     return("0"b);
      317 end va_arg;
      318 
  1     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  1     2 
  1     3 dcl 1 amu_info aligned based (amu_info_ptr),
  1     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  1     5     2 flags aligned,
  1     6       3 early_dump bit(1) unal,
  1     7       3 pad  bit(35) unal,
  1     8     2 type fixed bin unal,				/* One of the types below */
  1     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  1    10     2 chain,					/* a chain of all the amu_info's which exist */
  1    11       3 prev pointer unaligned,
  1    12       3 next pointer unaligned,
  1    13 
  1    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  1    15 
  1    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  1    17 						/*   SEE: amu_translation.incl.pl1 */
  1    18     2 fdump_info_ptr pointer, 			
  1    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  1    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  1    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  1    22 						/* See: amu_old_uid_table			*/
  1    23 	
  1    24 
  1    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  1    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  1    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  1    28 						/*   SEE: amu_copy_info.incl.pl1 */
  1    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  1    30 						/*   SEE: amu_process_info.incl.pl1 */
  1    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  1    32 
  1    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  1    34 
  1    35     2 error_info,					/* various info about how amu_error_ is to behave */
  1    36       3 error_flags aligned,
  1    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  1    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  1    39         4 pad bit (34) unaligned,
  1    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  1    41     2 definitions_info_ptr ptr;
  1    42 
  1    43 dcl  amu_area area based (amu_info.area_ptr);
  1    44 
  1    45 dcl  amu_info_ptr pointer;
  1    46 
  1    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  1    48      FDUMP_PROCESS_TYPE	init (1038),
  1    49      ONLINE_TYPE		init (1039),
  1    50      ONLINE_PROCESS_TYPE	init (1040),
  1    51      NETWORK_FDUMP_TYPE	init (1041),
  1    52      NETWORK_ONLINE_TYPE	init (1042),
  1    53      SAVED_PROC_TYPE	init (1043),
  1    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  1    55 
  1    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  1    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  1    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  1    59 
  1    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  1    61 
  1    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      319 
      320 
  2     1 /*	BEGIN INCLUDE FILE amu_translation.incl.pl1	*/
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(87-01-16,Parisek), approve(87-07-16,MCR7746),
  2     7*     audit(87-07-16,Fawcett), install(87-07-28,MR12.1-1049):
  2     8*     Added the "replaced" field to record whether a segment was replaced by
  2     9*     another segment via the "replace" request.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 dcl 1 translation_table aligned based (amu_info.translation_table_ptr),
  2    14     2 n_entries fixed bin,
  2    15     2 max_entries fixed bin,
  2    16 
  2    17     2 valid_array aligned,				/* one bit for each valid segno */
  2    18       3 valid (0 : 4095) bit (1) unaligned,
  2    19     2 used_array aligned,				/* one bit for each existing translation */
  2    20       3 used (0 : 4095) bit (1) unaligned,
  2    21 
  2    22     2 array (alloc_translation_table_max_entries refer (translation_table.max_entries)) like translation;
  2    23 
  2    24 dcl 1 translation aligned based (translation_ptr),	/* a single translation */
  2    25     2 segno fixed bin (18) unsigned unaligned,		/* foreign segno for this translation */
  2    26     2 flags unaligned,
  2    27       3 two_part bit (1) unaligned,			/* segment is in two pieces -- from an FDUMP */
  2    28       3 in_dump bit (1) unaligned,			/* segment is part of an FDUMP image */
  2    29       3 in_temp_seg bit (1) unaligned,			/* segment is a copy at the base of a temp segment */
  2    30       3 in_perm_seg bit (1) unaligned,			/* segment is in the file system */
  2    31       3 in_dp_dir bit (1) unaligned,
  2    32       3 replaced bit (1) unaligned,
  2    33       3 pad bit (12) unaligned,
  2    34     2 part1,					/* pointer to first (possibly only) part of segment */
  2    35       3 ptr pointer unaligned,
  2    36       3 lth fixed bin (19),
  2    37     2 part2 like translation.part1;
  2    38 
  2    39 dcl  alloc_translation_table_max_entries fixed bin;
  2    40 dcl  translation_ptr pointer;
  2    41 
  2    42 /*	END INCLUDE FILE amu_translation.incl.pl1	*/
      321 
      322 
  3     1 /*	BEGIN INCLUDE FILE azm_info.incl.pl1		*/
  3     2 
  3     3 dcl 1 azm_info aligned based (azm_info_ptr),
  3     4     2 version char(8),
  3     5     2 area_ptr ptr,					/* area pointer for azm to use when needed	*/
  3     6     2 aip pointer,					/* pointer for all amu_ calls */
  3     7     2 flags aligned,
  3     8       3 in_erf bit (1) unaligned,			/* examining an FDUMP */
  3     9       3 in_process bit (1) unaligned,			/* some specific process selected in FDUMP */
  3    10       3 online bit (1) unaligned,			/* examining online system, my process */
  3    11       3 saved_proc bit (1) unaligned,			/* examining "deadproc" */
  3    12       3 pad bit (33) unaligned,
  3    13 
  3    14     2 erf_name char (168),				/* name of ERF or deadproc path */
  3    15     2 pad fixed bin;
  3    16 
  3    17 dcl  azm_info_ptr pointer;
  3    18 
  3    19 dcl  AZM_INFO_VERSION_1 char (8) internal static options (constant) init ("azm_v1");
  3    20 dcl  AZM_INFO_VERSION_2 char (8) internal static options (constant) init ("azm_v2");
  3    21 
  3    22 /*	END INCLUDE FILE azm_info.incl.pl1		*/
      323 
      324 
  4     1 /*  START OF:	azm_va_args.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 /* This is a structure for argument processing of virtual addresses (VAs) and its related arguments. 
  4     4*   These related arguments can be a an offset modifier EXP which can be a positive or negative
  4     5*   octal number and a RANGE can be specified. Both EXP and RANGE are optional arguments. The VA
  4     6*   must always be specified. These three args are non-positional on the request line but there
  4     7*   is an implicit order among the three. The first non-control argument on the request line must be 
  4     8*   a VA. The second non-control argument on the request line can be a EXP or a RANGE. If it is a 
  4     9*   RANGE then an EXP cannot be specified. In other words, a EXP must follow a VA.
  4    10**/
  4    11 
  4    12 /* Created: 22 MAY 84 by BLB */
  4    13 
  4    14 dcl 1 va_args			aligned,
  4    15 					/* fully resolved segment number of the virtual address  */
  4    16       2 segno			fixed bin (18) aligned, 
  4    17 					/* fully resolved offset of the virtual address  */
  4    18       2 offset			fixed bin(18) unaligned,
  4    19 					/* offset modifier (+N, -N) of the virtual address  */
  4    20       2 offset_modifier		fixed bin(18),
  4    21 					/* The range of the addr area specified  */
  4    22       2 range			fixed bin(18) unaligned,
  4    23       2 va_switches			unaligned,
  4    24         3 valid_va			bit (1) unaligned,	/* on if valid virtual address		*/
  4    25         3 valid_modifier		bit (1) unaligned,  /* on if valid offset modifier		*/
  4    26         3 valid_range		bit (1) unaligned,	/* on if valid range			*/
  4    27         3 modifier_before_indirect      bit(1) unaligned,  /* on if the offset modifier is specified */ 
  4    28 						/* before indirection eg. A|B+10,*		*/
  4    29         3 va_pad			bit (32) unaligned, /* must be zero 				*/
  4    30       2 va_position			aligned,            /* index into the argument list for: 		*/
  4    31         3 va_idx			fixed bin,          /* virtual address				*/
  4    32         3 mod_idx			fixed bin,	/* the offset modifier index			*/
  4    33         3 range_idx			fixed bin,	/* the range argument index			*/
  4    34       2 resolved_va			ptr,		/* The resolved virtual address		*/
  4    35       2 ecode			fixed bin(35),	/* error code				*/
  4    36       2 error_msg			char(80) var,	/* error message				*/
  4    37       2 va_string			char(256) var;	/* The complete virtual address after parsing thru the args. */
  4    38 
  4    39 dcl 1 va				based (va_args_ptr) like va_args;
  4    40 dcl va_args_ptr			ptr;
  4    41 
  4    42 /*  END OF:	azm_va_args.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      325 
      326 
      327      end azm_stack_requests_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/28/87  0924.3  azm_stack_requests_.pl1           >spec>install>MR12.1-1049>azm_stack_requests_.pl1
319          1    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
321          2    07/28/87  0927.3  amu_translation.incl.pl1          >spec>install>MR12.1-1049>amu_translation.incl.pl1
323          3    11/20/84  0854.8  azm_info.incl.pl1                 >ldd>include>azm_info.incl.pl1
325          4    11/20/84  0854.8  azm_va_args.incl.pl1              >ldd>include>azm_va_args.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Arg_expected                           parameter       char                     unaligned dcl 269 set ref 265 274*
P_azm_info_ptr                         parameter       pointer                  dcl 41 ref 116 123 187 209 249 287
P_sci_ptr                              parameter       pointer                  dcl 41 ref 116 119 123 187 209 249 286
Ppos                            000620 automatic       pointer                  dcl 309 set ref 311* 312 313
a_pos                                  parameter       fixed bin(17,0)          dcl 303 ref 301 313
addr                                                   builtin function         dcl 87 ref 133 311
af_sw                           000100 automatic       bit(1)                   dcl 48 set ref 289* 290 290*
aip                       4            based           pointer                  level 2 dcl 3-3 ref 288
al1                                    parameter       fixed bin(21,0)          dcl 270 set ref 265 279*
amu_$get_va_args                000010 constant        entry                    external dcl 94 ref 142
amu_et_$no_valid_stacks         000040 external static fixed bin(35,0)          dcl 109 ref 177
amu_info_ptr                    000410 automatic       pointer                  dcl 1-45 set ref 142* 175* 196* 238* 260* 288* 297
ap1                                    parameter       pointer                  dcl 270 set ref 265 279*
arg                                    based           char                     unaligned dcl 81 set ref 153 153 154 154 155 155 156
                                                                                  158* 163 163 166 168* 223 226 227 274*
arg_positions                          based           fixed bin(17,0)          array dcl 305 ref 312 313
arg_sw                          000101 automatic       bit(1)                   unaligned dcl 49 set ref 147* 154* 175*
argl                            000102 automatic       fixed bin(21,0)          dcl 50 set ref 141* 152* 153 153 154 154 155 155 156
                                                                                  157* 158 158 163 163 166 168 168 222* 223 226 227
                                                                                  274 274
argno                           000103 automatic       fixed bin(17,0)          dcl 51 set ref 151* 152* 165* 221* 222* 273 278* 278
                                                                                  279*
argp                            000104 automatic       pointer                  dcl 52 set ref 141* 142* 152* 153 153 154 154 155
                                                                                  155 156 157* 158 163 163 166 168 222* 223 226 227
                                                                                  274
azm_info                               based           structure                level 1 dcl 3-3
azm_info_ptr                    000412 automatic       pointer                  dcl 3-17 set ref 287* 288
azm_stack_trace_                000012 constant        entry                    external dcl 95 ref 175
azm_why_$find_bad_guy           000014 constant        entry                    external dcl 96 ref 196
azm_why_$mcs                    000016 constant        entry                    external dcl 97 ref 260
azm_why_$print_locks            000020 constant        entry                    external dcl 98 ref 238
baseptr                                                builtin function         dcl 87 ref 174
brief_sw                        000106 automatic       bit(1)                   initial unaligned dcl 53 set ref 53*
code                            000107 automatic       fixed bin(35,0)          dcl 54 set ref 158* 159 166* 167* 168* 175* 176 177
                                                                                  182* 196* 198 202 203* 238* 242 243* 260* 261 261*
count                           000110 automatic       fixed bin(17,0)          dcl 55 set ref 148* 158* 159 175*
cv_dec_check_                   000022 constant        entry                    external dcl 99 ref 158
ecode                    12            based           fixed bin(35,0)          level 2 dcl 4-39 set ref 135* 143 144*
error_msg                13            based           varying char(80)         level 2 dcl 4-39 set ref 138* 143 144*
error_table_$action_not_performed
                                000042 external static fixed bin(35,0)          dcl 110 ref 198
error_table_$bad_arg            000044 external static fixed bin(35,0)          dcl 111 set ref 167 195*
error_table_$badopt             000046 external static fixed bin(35,0)          dcl 112 ref 166
error_table_$noarg              000050 external static fixed bin(35,0)          dcl 113 set ref 129* 274*
error_table_$too_many_args      000052 external static fixed bin(35,0)          dcl 114 set ref 217* 258*
first                           000111 automatic       fixed bin(18,0)          dcl 56 set ref 173* 174
for_sw                          000112 automatic       bit(1)                   unaligned dcl 57 set ref 147* 161*
force_sw                        000113 automatic       bit(1)                   unaligned dcl 58 set ref 147* 155* 175*
fwd_sw                          000114 automatic       bit(1)                   unaligned dcl 59 set ref 147* 163* 175*
hbound                                                 builtin function         dcl 87 ref 225 232 312
i                               000616 automatic       fixed bin(17,0)          dcl 304 set ref 312* 313*
ioa_                            000024 constant        entry                    external dcl 100 ref 178 179 180 231 233
lock_index                      000116 automatic       fixed bin(17,0)          dcl 61 set ref 225* 226* 232* 233*
lock_info                       000117 automatic       structure                array level 1 packed unaligned dcl 62 set ref 225
                                                                                  232
lock_name                       000306 automatic       char(32)                 unaligned dcl 66 set ref 219* 227* 238*
lock_word                20     000117 automatic       bit(36)                  initial array level 2 packed unaligned dcl 62 set
                                                                                  ref 62* 62* 62* 62* 62* 62* 62*
long_sw                         000115 automatic       bit(1)                   unaligned dcl 60 set ref 147* 153* 175*
lseg                            000117 automatic       char(32)                 initial array level 2 packed unaligned dcl 62 set
                                                                                  ref 62* 62* 62* 62* 62* 62* 62*
lsymb                    10     000117 automatic       char(32)                 initial array level 2 packed unaligned dcl 62 set
                                                                                  ref 62* 62* 62* 62* 62* 62* 62* 226 233*
nargs                           000316 automatic       fixed bin(17,0)          dcl 67 set ref 129 142* 151 195 217 221 258 273 289*
                                                                                  290*
null                                                   builtin function         dcl 87 ref 139 297
offset                    1            based           fixed bin(18,0)          level 2 packed unaligned dcl 4-39 set ref 135* 173
offset_modifier           2            based           fixed bin(18,0)          level 2 dcl 4-39 set ref 135*
part1                   347            based           structure                array level 3 in structure "translation_table"
                                                                                  dcl 2-13 in procedure "azm_stack_requests_"
part1                     1            based           structure                level 2 in structure "translation" dcl 2-24
                                                                                  in procedure "azm_stack_requests_"
pointer                                                builtin function         dcl 87 ref 174
range                     3            based           fixed bin(18,0)          level 2 packed unaligned dcl 4-39 set ref 134*
range_idx                 7            based           fixed bin(17,0)          level 3 dcl 4-39 set ref 149*
resolved_va              10            based           pointer                  level 2 dcl 4-39 set ref 139*
ret_str                         000317 automatic       varying char(168)        initial dcl 68 set ref 68*
rv_lth                          000372 automatic       fixed bin(21,0)          dcl 69 set ref 289*
rv_ptr                          000374 automatic       pointer                  dcl 70 set ref 289*
sci_ptr                         000376 automatic       pointer                  dcl 71 set ref 119* 120* 127* 129* 141* 142* 144*
                                                                                  152* 159* 168* 175* 182* 192* 195* 196* 199* 203*
                                                                                  214* 217* 222* 238* 243* 255* 258* 260* 261* 274*
                                                                                  279* 286* 289* 290*
segno                                  based           fixed bin(18,0)          level 2 in structure "va" dcl 4-39 in procedure
                                                                                  "azm_stack_requests_" set ref 135* 172
segno                           000400 automatic       fixed bin(17,0)          dcl 72 in procedure "azm_stack_requests_" set ref
                                                                                  172* 174
set_sw                          000401 automatic       bit(1)                   unaligned dcl 73 set ref 220* 223* 238*
ssu_$abort_line                 000026 constant        entry                    external dcl 101 ref 120 127 129 144 159 168 192 195
                                                                                  203 214 217 243 255 258 274
ssu_$arg_count                  000030 constant        entry                    external dcl 102 ref 290
ssu_$arg_ptr                    000032 constant        entry                    external dcl 103 ref 141 152 222 279
ssu_$print_message              000034 constant        entry                    external dcl 104 ref 182 199 261
ssu_$return_arg                 000036 constant        entry                    external dcl 105 ref 289
struct_sw                       000402 automatic       bit(1)                   initial unaligned dcl 74 set ref 74*
substr                                                 builtin function         dcl 87 ref 166
temp_ptr                        000404 automatic       pointer                  dcl 75 set ref 174* 175* 179* 182*
translation                            based           structure                level 1 dcl 2-24
va                                     based           structure                level 1 unaligned dcl 4-39
va_args                         000414 automatic       structure                level 1 dcl 4-14 set ref 133
va_args_ptr                     000556 automatic       pointer                  dcl 4-40 set ref 133* 134 135 135 135 135 135 137
                                                                                  138 138 139 142* 143 143 144 144 149 172 173 311
va_position               5            based           structure                level 2 dcl 4-39 set ref 135* 311
va_string                40            based           varying char(256)        level 2 dcl 4-39 set ref 138*
va_switches               3(19)        based           structure                level 2 packed unaligned dcl 4-39 set ref 137*
val_arg                         000406 automatic       fixed bin(17,0)          dcl 76 set ref 148*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 1-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 1-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 1-58
AZM_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 3-19
AZM_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 3-20
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 1-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 1-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 1-47
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 1-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 1-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 1-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 1-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 1-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 1-47
alloc_translation_table_max_entries    automatic       fixed bin(17,0)          dcl 2-39
amu_area                               based           area(1024)               dcl 1-43
amu_info                               based           structure                level 1 dcl 1-3
translation_ptr                        automatic       pointer                  dcl 2-40
translation_table                      based           structure                level 1 dcl 2-13

NAMES DECLARED BY EXPLICIT CONTEXT.
azm_stack_requests_             000512 constant        entry                    external dcl 19
azm_stack_requests_$frame       000525 constant        entry                    external dcl 116
azm_stack_requests_$locks       001664 constant        entry                    external dcl 209
azm_stack_requests_$search_mcs  002174 constant        entry                    external dcl 249
azm_stack_requests_$stack       000567 constant        entry                    external dcl 123
azm_stack_requests_$why         001476 constant        entry                    external dcl 187
call_lock_list                  002114 constant        label                    dcl 238 ref 228
get_next_arg                    002322 constant        entry                    internal dcl 265 ref 157
set_up                          002421 constant        entry                    internal dcl 283 ref 126 190 212 253
trans_selected                  002471 constant        entry                    internal dcl 294 ref 127 191 213 254
va_arg                          002511 constant        entry                    internal dcl 301 ref 165

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3142        3216    2605        3152
Length      3542    2605        54         307     335           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_stack_requests_                 550 external procedure  is an external procedure.  
get_next_arg                            internal procedure  shares stack frame of external procedure azm_stack_requests_.  
set_up                                  internal procedure  shares stack frame of external procedure azm_stack_requests_.  
trans_selected                          internal procedure  shares stack frame of external procedure azm_stack_requests_.  
va_arg                                  internal procedure  shares stack frame of external procedure azm_stack_requests_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_stack_requests_      000100 af_sw                       azm_stack_requests_
                         000101 arg_sw                      azm_stack_requests_
                         000102 argl                        azm_stack_requests_
                         000103 argno                       azm_stack_requests_
                         000104 argp                        azm_stack_requests_
                         000106 brief_sw                    azm_stack_requests_
                         000107 code                        azm_stack_requests_
                         000110 count                       azm_stack_requests_
                         000111 first                       azm_stack_requests_
                         000112 for_sw                      azm_stack_requests_
                         000113 force_sw                    azm_stack_requests_
                         000114 fwd_sw                      azm_stack_requests_
                         000115 long_sw                     azm_stack_requests_
                         000116 lock_index                  azm_stack_requests_
                         000117 lock_info                   azm_stack_requests_
                         000306 lock_name                   azm_stack_requests_
                         000316 nargs                       azm_stack_requests_
                         000317 ret_str                     azm_stack_requests_
                         000372 rv_lth                      azm_stack_requests_
                         000374 rv_ptr                      azm_stack_requests_
                         000376 sci_ptr                     azm_stack_requests_
                         000400 segno                       azm_stack_requests_
                         000401 set_sw                      azm_stack_requests_
                         000402 struct_sw                   azm_stack_requests_
                         000404 temp_ptr                    azm_stack_requests_
                         000406 val_arg                     azm_stack_requests_
                         000410 amu_info_ptr                azm_stack_requests_
                         000412 azm_info_ptr                azm_stack_requests_
                         000414 va_args                     azm_stack_requests_
                         000556 va_args_ptr                 azm_stack_requests_
                         000616 i                           va_arg
                         000620 Ppos                        va_arg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$get_va_args              azm_stack_trace_              azm_why_$find_bad_guy         azm_why_$mcs
azm_why_$print_locks          cv_dec_check_                 ioa_                          ssu_$abort_line
ssu_$arg_count                ssu_$arg_ptr                  ssu_$print_message            ssu_$return_arg

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$no_valid_stacks       error_table_$action_not_performed                           error_table_$bad_arg
error_table_$badopt           error_table_$noarg            error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     53 000300        62 000301        68 000505        74 000506        19 000511        21 000520       116 000521
    119 000533       120 000537       123 000564       126 000575       127 000576       129 000633       133 000661
    134 000663       135 000667       137 000677       138 000712       139 000714       141 000716       142 000735
    143 000754       144 000764       147 001013       148 001020       149 001022       151 001024       152 001033
    153 001050       154 001065       155 001100       156 001113       157 001117       158 001130       159 001155
    161 001206       162 001210       163 001211       165 001224       166 001231       167 001242       168 001245
    171 001276       172 001300       173 001302       174 001306       175 001315       176 001370       177 001372
    178 001375       179 001410       180 001430       181 001444       182 001445       185 001473       187 001474
    190 001504       191 001505       192 001512       193 001542       195 001543       196 001571       198 001604
    199 001610       200 001634       202 001635       203 001637       205 001661       209 001662       212 001672
    213 001673       214 001700       215 001730       217 001731       219 001760       220 001763       221 001764
    222 001773       223 002010       225 002021       226 002025       227 002035       228 002040       230 002041
    231 002043       232 002062       233 002067       234 002107       235 002111       237 002112       238 002114
    242 002144       243 002146       246 002171       249 002172       253 002202       254 002203       255 002210
    256 002240       258 002241       260 002267       261 002302       262 002321       265 002322       273 002333
    274 002337       275 002400       278 002401       279 002402       281 002420       283 002421       286 002422
    287 002426       288 002431       289 002433       290 002452       292 002470       294 002471       297 002473
    298 002504       301 002511       311 002513       312 002516       313 002523       314 002536       316 002540


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
